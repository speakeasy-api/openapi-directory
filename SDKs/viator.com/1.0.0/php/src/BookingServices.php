<?php

/**
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

declare(strict_types=1);

namespace OpenAPI\OpenAPI;

class BookingServices 
{
	
	public const CANCEL_BOOKING_SERVERS = [
        /** Sandbox server (uses test data) */
		'https://api.sandbox.viator.com/partner',
	];
	
	public const CANCEL_BOOKING_QUOTE_SERVERS = [
        /** Sandbox server (uses test data) */
		'https://api.sandbox.viator.com/partner',
	];
	
	public const CANCELLATION_REASONS_SERVERS = [
        /** Sandbox server (uses test data) */
		'https://api.sandbox.viator.com/partner',
	];

	// SDK private variables namespaced with _ to avoid conflicts with API models
	private \GuzzleHttp\ClientInterface $_defaultClient;
	private \GuzzleHttp\ClientInterface $_securityClient;
	private string $_serverUrl;
	private string $_language;
	private string $_sdkVersion;
	private string $_genVersion;	

	/**
	 * @param \GuzzleHttp\ClientInterface $defaultClient
	 * @param \GuzzleHttp\ClientInterface $securityClient
	 * @param string $serverUrl
	 * @param string $language
	 * @param string $sdkVersion
	 * @param string $genVersion
	 */
	public function __construct(\GuzzleHttp\ClientInterface $defaultClient, \GuzzleHttp\ClientInterface $securityClient, string $serverUrl, string $language, string $sdkVersion, string $genVersion)
	{
		$this->_defaultClient = $defaultClient;
		$this->_securityClient = $securityClient;
		$this->_serverUrl = $serverUrl;
		$this->_language = $language;
		$this->_sdkVersion = $sdkVersion;
		$this->_genVersion = $genVersion;
	}
	
    /**
     * /booking/availability
     * 
     * Get the tour-grade with the lowest price that is available for a product on each day of the specified month
     * 
     * This service:
     * - returns 
     * - useful when displaying a calendar of available tours
     * - For more information, see: [Availability services](#section/Key-concepts/Availability-services)
     * - **Notes:** 
     *   - [/booking/availability/dates](#operation/bookingAvailabilityDates) provides all availability in one call and is more suitable for calendars, etc.
     * 
     *   - Availability data is limited to a period of **12 months** into the future from the present time on the production server and **6 months** on the sandbox server. 
     * 
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\BookingAvailabilityRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\BookingAvailabilityResponse
     */
	public function bookingAvailability(
        \OpenAPI\OpenAPI\Models\Operations\BookingAvailabilityRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\BookingAvailabilityResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/booking/availability');
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "requestBody", "json");
        $options = array_merge_recursive($options, $body);
        $options = array_merge_recursive($options, Utils\Utils::getHeaders($request));
        
        $httpResponse = $this->_securityClient->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\BookingAvailabilityResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->bookingAvailability200ApplicationJSONObject = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Operations\BookingAvailability200ApplicationJSON', 'json');
            }
        }

        return $response;
    }
	
    /**
     * /booking/availability/dates
     * 
     * Get dates on which a product is available
     * 
     * This service:
     * - retrieves all available dates for a product, excluding days it does not operate and blocked-out dates
     * - returns a multi-dimensional array of year-month -&gt; days that have any availabile tour grade or traveler mix
     * - useful to present the user with a list of dates for selection on which *this* product is available for booking
     * - **Notes**: 
     * 
     *   - The user's desired traveler mix may not be eligible for booking; these details can be displayed when you retrieve its list of tour grades
     *   - Availability data is limited to a period of **12 months** into the future from the present time on the production server and **6 months** on the sandbox server. 
     * 
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\BookingAvailabilityDatesRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\BookingAvailabilityDatesResponse
     */
	public function bookingAvailabilityDates(
        \OpenAPI\OpenAPI\Models\Operations\BookingAvailabilityDatesRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\BookingAvailabilityDatesResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/booking/availability/dates');
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\BookingAvailabilityDatesRequest::class, $request, null));
        $options = array_merge_recursive($options, Utils\Utils::getHeaders($request));
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\BookingAvailabilityDatesResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->bookingAvailabilityDates200ApplicationJSONObject = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Operations\BookingAvailabilityDates200ApplicationJSON', 'json');
            }
        }

        return $response;
    }
	
    /**
     * /booking/availability/tourgrades
     * 
     * Get the tour grades of a product that are currently available
     * 
     * This service reports:
     * - all tour grades for the specified product, on the specified day, that are available for the specified age bands
     * - the pricing breakdown and the total depending on the travel date and traveler mix
     * 
     * **Note**: Availability data is limited to a period of **12 months** into the future from the present time on the production server and **6 months** on the sandbox server. 
     * 
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\BookingAvailabilityTourgradesRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\BookingAvailabilityTourgradesResponse
     */
	public function bookingAvailabilityTourgrades(
        \OpenAPI\OpenAPI\Models\Operations\BookingAvailabilityTourgradesRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\BookingAvailabilityTourgradesResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/booking/availability/tourgrades');
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "requestBody", "json");
        $options = array_merge_recursive($options, $body);
        $options = array_merge_recursive($options, Utils\Utils::getHeaders($request));
        
        $httpResponse = $this->_securityClient->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\BookingAvailabilityTourgradesResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->bookingAvailabilityTourgrades200ApplicationJSONObject = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Operations\BookingAvailabilityTourgrades200ApplicationJSON', 'json');
            }
        }

        return $response;
    }
	
    /**
     * /booking/availability/tourgrades/pricingmatrix
     * 
     * Get a pricing matrix that includes availability and tour-grades for a product
     * 
     * Given a month, this service returns days with available tour grades only (i.e., days which have at least one tourgrade available), and the pricing matrix for that tour grade for that day.
     * 
     * - **Note**: Availability data is limited to a period of **12 months** into the future from the present time on the production server and **6 months** on the sandbox server. 
     * 
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\BookingAvailabilityTourgradesPricingmatrixRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\BookingAvailabilityTourgradesPricingmatrixResponse
     */
	public function bookingAvailabilityTourgradesPricingmatrix(
        \OpenAPI\OpenAPI\Models\Operations\BookingAvailabilityTourgradesPricingmatrixRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\BookingAvailabilityTourgradesPricingmatrixResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/booking/availability/tourgrades/pricingmatrix');
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "requestBody", "json");
        $options = array_merge_recursive($options, $body);
        $options = array_merge_recursive($options, Utils\Utils::getHeaders($request));
        
        $httpResponse = $this->_securityClient->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\BookingAvailabilityTourgradesPricingmatrixResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->bookingAvailabilityTourgradesPricingmatrix200ApplicationJSONObject = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Operations\BookingAvailabilityTourgradesPricingmatrix200ApplicationJSON', 'json');
            }
        }

        return $response;
    }
	
    /**
     * /booking/book
     * 
     * Make a booking
     * 
     * For more information, see: 
     * 
     *   - [Cancellation policy](#section/Key-concepts/Cancellation-policy)
     *   - [Booking concepts](#section/Key-concepts/Booking-concepts)
     *   - [Booking process flow](#section/Common-workflows-and-data-validation/Booking-process-flow)
     *   - [Making a booking](#section/Common-workflows-and-data-validation/Making-a-booking)
     *   - [Supplier communications](#section/Key-concepts/Supplier-communications)
     * 
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\BookingBookRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\BookingBookResponse
     */
	public function bookingBook(
        \OpenAPI\OpenAPI\Models\Operations\BookingBookRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\BookingBookResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/booking/book');
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "requestBody", "json");
        $options = array_merge_recursive($options, $body);
        $options = array_merge_recursive($options, Utils\Utils::getHeaders($request));
        
        $httpResponse = $this->_securityClient->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\BookingBookResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->bookingBook200ApplicationJSONObject = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Operations\BookingBook200ApplicationJSON', 'json');
            }
        }

        return $response;
    }
	
    /**
     * /booking/calculateprice
     * 
     * Confirm the price of a tour / activity prior to booking
     * 
     * For more information, see: [Calculating prices](#section/Common-workflows-and-data-validation/Calculating-prices)  
     * 
     * - **Note**: Availability and pricing data is limited to a period of **six months** into the future from the present time
     * 
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\BookingCalculatepriceRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\BookingCalculatepriceResponse
     */
	public function bookingCalculateprice(
        \OpenAPI\OpenAPI\Models\Operations\BookingCalculatepriceRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\BookingCalculatepriceResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/booking/calculateprice');
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "requestBody", "json");
        $options = array_merge_recursive($options, $body);
        $options = array_merge_recursive($options, Utils\Utils::getHeaders($request));
        
        $httpResponse = $this->_securityClient->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\BookingCalculatepriceResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->bookingCalculateprice200ApplicationJSONObject = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Operations\BookingCalculateprice200ApplicationJSON', 'json');
            }
        }

        return $response;
    }
	
    /**
     * /booking/hotels
     * 
     * Get hotel pick-ups
     * Lists the hotel pickups available for either a product or a destination
     * 
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\BookingHotelsRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\BookingHotelsResponse
     */
	public function bookingHotels(
        \OpenAPI\OpenAPI\Models\Operations\BookingHotelsRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\BookingHotelsResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/booking/hotels');
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\BookingHotelsRequest::class, $request, null));
        $options = array_merge_recursive($options, Utils\Utils::getHeaders($request));
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\BookingHotelsResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->bookingHotels200ApplicationJSONObject = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Operations\BookingHotels200ApplicationJSON', 'json');
            }
        }

        return $response;
    }
	
    /**
     * /booking/mybookings
     * 
     * Get a user's bookings with travel dates in the future. 
     * 
     * This service can also be used to check the status of a booking. 
     * 
     * **Provide either:** 
     * - A `voucherKey`, **or...** 
     * - An email address (`email`) and a booking reference (`itineraryOrItemId`) ([Booking Reference](#section/Key-concepts/Booking-references))
     * 
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\BookingMybookingsRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\BookingMybookingsResponse
     */
	public function bookingMybookings(
        \OpenAPI\OpenAPI\Models\Operations\BookingMybookingsRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\BookingMybookingsResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/booking/mybookings');
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\BookingMybookingsRequest::class, $request, null));
        $options = array_merge_recursive($options, Utils\Utils::getHeaders($request));
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\BookingMybookingsResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->bookingMybookings200ApplicationJSONObject = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Operations\BookingMybookings200ApplicationJSON', 'json');
            }
        }

        return $response;
    }
	
    /**
     * /booking/pastbooking
     * 
     * Get the details of a single specific past booking based on the `voucherKey` or `itemId` and email address sent in the request.
     * 
     * **Note**: this service will only return past bookings that were made with the same API key that was used to make the booking
     * 
     * **Sample query parameters**:
     * - email=apitest@viator.com&amp;itemId=580669678
     * 
     * **or**
     * - voucherKey=1005851866:4af44c13ecf3f1a7d3f9ef2fc00c2257e08fa42ae20f877f3039ff9b52aba24e:580669678
     * 
     * **email**
     * - The email address passed must match the email address associated with the booking
     * 
     * **Departure details**
     * 
     * - Departure details such as the `departurePoint`, `departurePointAddress` and `departurePointDirections` is included in the response. 
     * - These fields may contain HTML escape characters such as &amp;amp; and special characters that are escaped by a backslash. Ensure that these fields are parsed after receiving the response as it will cause your JSON to be invalid.
     * 
     * For more information, see: [Reviewing bookings](#section/Common-workflows-and-data-validation/Reviewing-bookings)
     * 
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\BookingPastbookingRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\BookingPastbookingResponse
     */
	public function bookingPastbooking(
        \OpenAPI\OpenAPI\Models\Operations\BookingPastbookingRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\BookingPastbookingResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/booking/pastbooking');
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\BookingPastbookingRequest::class, $request, null));
        $options = array_merge_recursive($options, Utils\Utils::getHeaders($request));
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\BookingPastbookingResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->bookingPastbooking200ApplicationJSONObject = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Operations\BookingPastbooking200ApplicationJSON', 'json');
            }
        }

        return $response;
    }
	
    /**
     * /booking/pricingmatrix
     * 
     * Get the pricing matrix for tour-grades, product age bands and pax mixes
     * 
     * For more information, see: [Get the tour-grade pricing matrix](#section/Common-workflows-and-data-validation/Get-the-tour-grade-pricing-matrix)
     * 
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\BookingPricingmatrixRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\BookingPricingmatrixResponse
     */
	public function bookingPricingmatrix(
        \OpenAPI\OpenAPI\Models\Operations\BookingPricingmatrixRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\BookingPricingmatrixResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/booking/pricingmatrix');
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "requestBody", "json");
        $options = array_merge_recursive($options, $body);
        $options = array_merge_recursive($options, Utils\Utils::getHeaders($request));
        
        $httpResponse = $this->_securityClient->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\BookingPricingmatrixResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->bookingPricingmatrix200ApplicationJSONObject = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Operations\BookingPricingmatrix200ApplicationJSON', 'json');
            }
        }

        return $response;
    }
	
    /**
     * /booking/status
     * 
     * Get the booking status for multiple items based on different criteria
     * 
     * This service: 
     * - is ideally be used in software for bulk updates of pending bookings
     * - returns a maximum of 1000 bookings (narrow your search if you expect a greater number of results)
     * - will return &lt;u&gt;both&lt;/u&gt; live &lt;u&gt;and&lt;/u&gt; test bookings
     * - rate limited to &lt;u&gt;one request every 30 minutes&lt;/u&gt;
     * - For more information, see: [Get the bookiing status for multiple items](#section/Common-workflows-and-data-validation/Get-the-booking-status-for-multiple-items)
     * 
     * **Exceeding the rate limit**
     * - You will receive the following error message if you exceed the rate limit allowed for this service. Set `test` to `true` to bypass this limit:
     * ```javascript
     * {
     *     "data": null
     *     "vmid": 221002
     *     "errorMessage": ["Access allowed every 30 minutes"]
     *     "errorType": "EXCEPTION"
     *     "dateStamp": "2013-03-26T10:28:51+0000"
     *     "errorReference": 55315512721712161381352771
     *     "errorMessageText": ["Access allowed every 30 minutes"]
     *     "success": false
     *     "totalCount": 1
     *     "errorName": "PollingDeniedException"  
     * }
     * ```
     * 
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\BookingStatusRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\BookingStatusResponse
     */
	public function bookingStatus(
        \OpenAPI\OpenAPI\Models\Operations\BookingStatusRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\BookingStatusResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/booking/status');
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "requestBody", "json");
        $options = array_merge_recursive($options, $body);
        $options = array_merge_recursive($options, Utils\Utils::getHeaders($request));
        
        $httpResponse = $this->_securityClient->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\BookingStatusResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->bookingStatus200ApplicationJSONObject = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Operations\BookingStatus200ApplicationJSON', 'json');
            }
        }

        return $response;
    }
	
    /**
     * /booking/status/items
     * 
     * Get brief booking statuses
     * 
     * This service is similar to [/booking/status](#operation/bookingStatus) in that it:
     * - retrieves the booking status for multiple items based on different criteria
     * - has the same request parameters as [/booking/status](#operation/bookingStatus)
     * 
     * However, it differs in that it returns a multi-item array of booking items with less detail than what would be received from [/booking/status](#operation/bookingStatus).
     * 
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\BookingStatusItemsRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\BookingStatusItemsResponse
     */
	public function bookingStatusItems(
        \OpenAPI\OpenAPI\Models\Operations\BookingStatusItemsRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\BookingStatusItemsResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/booking/status/items');
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "requestBody", "json");
        $options = array_merge_recursive($options, $body);
        $options = array_merge_recursive($options, Utils\Utils::getHeaders($request));
        
        $httpResponse = $this->_securityClient->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\BookingStatusItemsResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->bookingStatusItems200ApplicationJSONObject = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Operations\BookingStatusItems200ApplicationJSON', 'json');
            }
        }

        return $response;
    }
	
    /**
     * /booking/voucher
     * 
     * Get voucher details
     * - Use this service to retrieve the voucher details of a booked item.
     * - The data returned is HTML-formatted and can be wrapped in a header and/or footer.
     * 
     * **Sample query parameters**
     * - leadLastName=Simpson test&amp;itemId=580669678
     * 
     * **or** 
     * - voucherKey=1005851866:4af44c13ecf3f1a7d3f9ef2fc00c2257e08fa42ae20f877f3039ff9b52aba24e:580669678&amp;fullHTML=true&amp;mobileVoucher=true
     * 
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\BookingVoucherRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\BookingVoucherResponse
     */
	public function bookingVoucher(
        \OpenAPI\OpenAPI\Models\Operations\BookingVoucherRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\BookingVoucherResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/booking/voucher');
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\BookingVoucherRequest::class, $request, null));
        $options = array_merge_recursive($options, Utils\Utils::getHeaders($request));
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\BookingVoucherResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->bookingVoucher200ApplicationJSONObject = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Operations\BookingVoucher200ApplicationJSON', 'json');
            }
        }

        return $response;
    }
	
    /**
     * /bookings/{booking-reference}/cancel
     * 
     * Submits a cancellation request for the specified booking
     * 
     * For information on how to use this service, see: [Cancellation API workflow](#section/Common-workflows-and-data-validation/Cancellation-API-workflow)
     * 
     * **Note**: 
     * 
     *   * This service &lt;u&gt;requires&lt;/u&gt; [exp-api-key](#section/Authentication/exp-api-key) to be included as a header parameter. Please speak to your account manager if you have not yet been issued an exp-api-key.
     *   * The base URL for the server for this endpoint is different from the older endpoints described in this document. Use `https://api.sandbox.viator.com/partner/bookings/{booking-reference}/cancel`
     * 
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\CancelBookingRequest $request
     * @param string $serverURL
     * @return \OpenAPI\OpenAPI\Models\Operations\CancelBookingResponse
     */
	public function cancelBooking(
        \OpenAPI\OpenAPI\Models\Operations\CancelBookingRequest $request,
        string $serverURL = null,
    ): \OpenAPI\OpenAPI\Models\Operations\CancelBookingResponse
    {
        $baseUrl = BookingServices::CANCEL_BOOKING_SERVERS[0];
        if (!empty($serverURL)) {
            $baseUrl = $serverURL;
        }
        
        $url = Utils\Utils::generateUrl($baseUrl, '/bookings/{booking-reference}/cancel', \OpenAPI\OpenAPI\Models\Operations\CancelBookingRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "cancellationRequest", "json");
        $options = array_merge_recursive($options, $body);
        $options = array_merge_recursive($options, Utils\Utils::getHeaders($request));
        
        $httpResponse = $this->_securityClient->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\CancelBookingResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->cancelBookingResponse = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\CancelBookingResponse', 'json');
            }
        }
        else if ($httpResponse->getStatusCode() === 400) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->cancelBooking400ApplicationJSONObject = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Operations\CancelBooking400ApplicationJSON', 'json');
            }
        }
        else if ($httpResponse->getStatusCode() === 401) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->fourHundredAndOneUNAUTHORIZED = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\FourHundredAndOneUNAUTHORIZED', 'json');
            }
        }
        else if ($httpResponse->getStatusCode() === 404) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->cancelBooking404ApplicationJSONObject = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Operations\CancelBooking404ApplicationJSON', 'json');
            }
        }
        else if ($httpResponse->getStatusCode() === 406) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->fourHundredAndSixNOTACCEPTABLE = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\FourHundredAndSixNOTACCEPTABLE', 'json');
            }
        }
        else if ($httpResponse->getStatusCode() === 500) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->fiveHundredINTERNALSERVERERROR = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\FiveHundredINTERNALSERVERERROR', 'json');
            }
        }
        else if ($httpResponse->getStatusCode() === 503) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->fiveHundredAndThreeSERVICEUNAVAILABLE = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\FiveHundredAndThreeSERVICEUNAVAILABLE', 'json');
            }
        }

        return $response;
    }
	
    /**
     * /bookings/{booking-reference}/cancel-quote
     * 
     * Retrieves a quote for the cancellation of a booking
     * 
     * For information on how to use this service, see: [Cancellation API workflow](#section/Common-workflows-and-data-validation/Cancellation-API-workflow)
     * 
     * **Note**: 
     * 
     *   * This service &lt;u&gt;requires&lt;/u&gt; [exp-api-key](#section/Authentication/exp-api-key) to be included as a header parameter. Please speak to your account manager if you have not yet been issued an exp-api-key.
     *   * The base URL for the server for this endpoint is different from the older endpoints described in this document. Use `https://api.sandbox.viator.com/partner/bookings/{booking-reference}/cancel-quote`
     * 
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\CancelBookingQuoteRequest $request
     * @param string $serverURL
     * @return \OpenAPI\OpenAPI\Models\Operations\CancelBookingQuoteResponse
     */
	public function cancelBookingQuote(
        \OpenAPI\OpenAPI\Models\Operations\CancelBookingQuoteRequest $request,
        string $serverURL = null,
    ): \OpenAPI\OpenAPI\Models\Operations\CancelBookingQuoteResponse
    {
        $baseUrl = BookingServices::CANCEL_BOOKING_QUOTE_SERVERS[0];
        if (!empty($serverURL)) {
            $baseUrl = $serverURL;
        }
        
        $url = Utils\Utils::generateUrl($baseUrl, '/bookings/{booking-reference}/cancel-quote', \OpenAPI\OpenAPI\Models\Operations\CancelBookingQuoteRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\CancelBookingQuoteResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->cancelBookingQuoteResponse = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\CancelBookingQuoteResponse', 'json');
            }
        }
        else if ($httpResponse->getStatusCode() === 401) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->fourHundredAndOneUNAUTHORIZED = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\FourHundredAndOneUNAUTHORIZED', 'json');
            }
        }
        else if ($httpResponse->getStatusCode() === 406) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->fourHundredAndSixNOTACCEPTABLE = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\FourHundredAndSixNOTACCEPTABLE', 'json');
            }
        }
        else if ($httpResponse->getStatusCode() === 500) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->fiveHundredINTERNALSERVERERROR = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\FiveHundredINTERNALSERVERERROR', 'json');
            }
        }
        else if ($httpResponse->getStatusCode() === 503) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->fiveHundredAndThreeSERVICEUNAVAILABLE = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\FiveHundredAndThreeSERVICEUNAVAILABLE', 'json');
            }
        }

        return $response;
    }
	
    /**
     * /bookings/cancel-reasons
     * 
     * Retrieves a dictionary of unique identification codes (`cancellationReasonCode`) and their associated natural-language descriptions (`cancellationReasonText`).
     * 
     * For information on how to use this service, see: [Cancellation API workflow](#section/Common-workflows-and-data-validation/Cancellation-API-workflow)
     * 
     * **Note**: 
     * 
     *   * This service &lt;u&gt;requires&lt;/u&gt; [exp-api-key](#section/Authentication/exp-api-key) to be included as a header parameter. Please speak to your account manager if you have not yet been issued an exp-api-key.
     *   * The base URL for the server for this endpoint is different from the older endpoints described in this document. Use `https://api.sandbox.viator.com/partner/cancel-reasons`
     * 
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\CancellationReasonsRequest $request
     * @param string $serverURL
     * @return \OpenAPI\OpenAPI\Models\Operations\CancellationReasonsResponse
     */
	public function cancellationReasons(
        \OpenAPI\OpenAPI\Models\Operations\CancellationReasonsRequest $request,
        string $serverURL = null,
    ): \OpenAPI\OpenAPI\Models\Operations\CancellationReasonsResponse
    {
        $baseUrl = BookingServices::CANCELLATION_REASONS_SERVERS[0];
        if (!empty($serverURL)) {
            $baseUrl = $serverURL;
        }
        
        $url = Utils\Utils::generateUrl($baseUrl, '/bookings/cancel-reasons');
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getHeaders($request));
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\CancellationReasonsResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->cancellationReasonsResponses = $serializer->deserialize((string)$httpResponse->getBody(), 'array<OpenAPI\OpenAPI\Models\Shared\CancellationReasonsResponse>', 'json');
            }
        }
        else if ($httpResponse->getStatusCode() === 401) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->fourHundredAndOneUNAUTHORIZED = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\FourHundredAndOneUNAUTHORIZED', 'json');
            }
        }
        else if ($httpResponse->getStatusCode() === 406) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->fourHundredAndSixNOTACCEPTABLE = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\FourHundredAndSixNOTACCEPTABLE', 'json');
            }
        }
        else if ($httpResponse->getStatusCode() === 500) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->fiveHundredINTERNALSERVERERROR = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\FiveHundredINTERNALSERVERERROR', 'json');
            }
        }
        else if ($httpResponse->getStatusCode() === 503) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->fiveHundredAndThreeSERVICEUNAVAILABLE = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\FiveHundredAndThreeSERVICEUNAVAILABLE', 'json');
            }
        }

        return $response;
    }
}