/*
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

import * as utils from "../internal/utils";
import * as operations from "./models/operations";
import * as shared from "./models/shared";
import { AxiosInstance, AxiosRequestConfig, AxiosResponse } from "axios";

export class Extras {
  _defaultClient: AxiosInstance;
  _securityClient: AxiosInstance;
  _serverURL: string;
  _language: string;
  _sdkVersion: string;
  _genVersion: string;

  constructor(
    defaultClient: AxiosInstance,
    securityClient: AxiosInstance,
    serverURL: string,
    language: string,
    sdkVersion: string,
    genVersion: string
  ) {
    this._defaultClient = defaultClient;
    this._securityClient = securityClient;
    this._serverURL = serverURL;
    this._language = language;
    this._sdkVersion = sdkVersion;
    this._genVersion = genVersion;
  }

  extrasChoicesList(
    config?: AxiosRequestConfig
  ): Promise<operations.ExtrasChoicesListResponse> {
    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/extras/_choices/";

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ExtrasChoicesListResponse =
        new operations.ExtrasChoicesListResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          break;
      }

      return res;
    });
  }

  extrasChoicesRead(
    req: operations.ExtrasChoicesReadRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.ExtrasChoicesReadResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ExtrasChoicesReadRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/extras/_choices/{id}/",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ExtrasChoicesReadResponse =
        new operations.ExtrasChoicesReadResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          break;
      }

      return res;
    });
  }

  extrasConfigContextsCreate(
    req: shared.WritableConfigContextInput,
    config?: AxiosRequestConfig
  ): Promise<operations.ExtrasConfigContextsCreateResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new shared.WritableConfigContextInput(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/extras/config-contexts/";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "request",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ExtrasConfigContextsCreateResponse =
        new operations.ExtrasConfigContextsCreateResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.configContext = utils.objectToClass(
              httpRes?.data,
              shared.ConfigContext
            );
          }
          break;
      }

      return res;
    });
  }

  extrasConfigContextsDelete(
    req: operations.ExtrasConfigContextsDeleteRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.ExtrasConfigContextsDeleteResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ExtrasConfigContextsDeleteRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/extras/config-contexts/{id}/",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ExtrasConfigContextsDeleteResponse =
        new operations.ExtrasConfigContextsDeleteResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
      }

      return res;
    });
  }

  extrasConfigContextsList(
    req: operations.ExtrasConfigContextsListRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.ExtrasConfigContextsListResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ExtrasConfigContextsListRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/extras/config-contexts/";

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ExtrasConfigContextsListResponse =
        new operations.ExtrasConfigContextsListResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.extrasConfigContextsList200ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.ExtrasConfigContextsList200ApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  extrasConfigContextsPartialUpdate(
    req: operations.ExtrasConfigContextsPartialUpdateRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.ExtrasConfigContextsPartialUpdateResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ExtrasConfigContextsPartialUpdateRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/extras/config-contexts/{id}/",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "writableConfigContextInput",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "patch",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ExtrasConfigContextsPartialUpdateResponse =
        new operations.ExtrasConfigContextsPartialUpdateResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.configContext = utils.objectToClass(
              httpRes?.data,
              shared.ConfigContext
            );
          }
          break;
      }

      return res;
    });
  }

  extrasConfigContextsRead(
    req: operations.ExtrasConfigContextsReadRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.ExtrasConfigContextsReadResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ExtrasConfigContextsReadRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/extras/config-contexts/{id}/",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ExtrasConfigContextsReadResponse =
        new operations.ExtrasConfigContextsReadResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.configContext = utils.objectToClass(
              httpRes?.data,
              shared.ConfigContext
            );
          }
          break;
      }

      return res;
    });
  }

  extrasConfigContextsUpdate(
    req: operations.ExtrasConfigContextsUpdateRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.ExtrasConfigContextsUpdateResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ExtrasConfigContextsUpdateRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/extras/config-contexts/{id}/",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "writableConfigContextInput",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "put",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ExtrasConfigContextsUpdateResponse =
        new operations.ExtrasConfigContextsUpdateResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.configContext = utils.objectToClass(
              httpRes?.data,
              shared.ConfigContext
            );
          }
          break;
      }

      return res;
    });
  }

  extrasExportTemplatesCreate(
    req: shared.ExportTemplateInput,
    config?: AxiosRequestConfig
  ): Promise<operations.ExtrasExportTemplatesCreateResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new shared.ExportTemplateInput(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/extras/export-templates/";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "request",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ExtrasExportTemplatesCreateResponse =
        new operations.ExtrasExportTemplatesCreateResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.exportTemplate = utils.objectToClass(
              httpRes?.data,
              shared.ExportTemplate
            );
          }
          break;
      }

      return res;
    });
  }

  extrasExportTemplatesDelete(
    req: operations.ExtrasExportTemplatesDeleteRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.ExtrasExportTemplatesDeleteResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ExtrasExportTemplatesDeleteRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/extras/export-templates/{id}/",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ExtrasExportTemplatesDeleteResponse =
        new operations.ExtrasExportTemplatesDeleteResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
      }

      return res;
    });
  }

  extrasExportTemplatesList(
    req: operations.ExtrasExportTemplatesListRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.ExtrasExportTemplatesListResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ExtrasExportTemplatesListRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/extras/export-templates/";

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ExtrasExportTemplatesListResponse =
        new operations.ExtrasExportTemplatesListResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.extrasExportTemplatesList200ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.ExtrasExportTemplatesList200ApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  extrasExportTemplatesPartialUpdate(
    req: operations.ExtrasExportTemplatesPartialUpdateRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.ExtrasExportTemplatesPartialUpdateResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ExtrasExportTemplatesPartialUpdateRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/extras/export-templates/{id}/",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "exportTemplateInput",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "patch",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ExtrasExportTemplatesPartialUpdateResponse =
        new operations.ExtrasExportTemplatesPartialUpdateResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.exportTemplate = utils.objectToClass(
              httpRes?.data,
              shared.ExportTemplate
            );
          }
          break;
      }

      return res;
    });
  }

  extrasExportTemplatesRead(
    req: operations.ExtrasExportTemplatesReadRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.ExtrasExportTemplatesReadResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ExtrasExportTemplatesReadRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/extras/export-templates/{id}/",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ExtrasExportTemplatesReadResponse =
        new operations.ExtrasExportTemplatesReadResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.exportTemplate = utils.objectToClass(
              httpRes?.data,
              shared.ExportTemplate
            );
          }
          break;
      }

      return res;
    });
  }

  extrasExportTemplatesUpdate(
    req: operations.ExtrasExportTemplatesUpdateRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.ExtrasExportTemplatesUpdateResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ExtrasExportTemplatesUpdateRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/extras/export-templates/{id}/",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "exportTemplateInput",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "put",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ExtrasExportTemplatesUpdateResponse =
        new operations.ExtrasExportTemplatesUpdateResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.exportTemplate = utils.objectToClass(
              httpRes?.data,
              shared.ExportTemplate
            );
          }
          break;
      }

      return res;
    });
  }

  extrasGraphsCreate(
    req: shared.WritableGraphInput,
    config?: AxiosRequestConfig
  ): Promise<operations.ExtrasGraphsCreateResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new shared.WritableGraphInput(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/extras/graphs/";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "request",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ExtrasGraphsCreateResponse =
        new operations.ExtrasGraphsCreateResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.graph = utils.objectToClass(httpRes?.data, shared.Graph);
          }
          break;
      }

      return res;
    });
  }

  extrasGraphsDelete(
    req: operations.ExtrasGraphsDeleteRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.ExtrasGraphsDeleteResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ExtrasGraphsDeleteRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(baseURL, "/extras/graphs/{id}/", req);

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ExtrasGraphsDeleteResponse =
        new operations.ExtrasGraphsDeleteResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
      }

      return res;
    });
  }

  extrasGraphsList(
    req: operations.ExtrasGraphsListRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.ExtrasGraphsListResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ExtrasGraphsListRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/extras/graphs/";

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ExtrasGraphsListResponse =
        new operations.ExtrasGraphsListResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.extrasGraphsList200ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.ExtrasGraphsList200ApplicationJSON
            );
          }
          break;
      }

      return res;
    });
  }

  extrasGraphsPartialUpdate(
    req: operations.ExtrasGraphsPartialUpdateRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.ExtrasGraphsPartialUpdateResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ExtrasGraphsPartialUpdateRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(baseURL, "/extras/graphs/{id}/", req);

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "writableGraphInput",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "patch",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ExtrasGraphsPartialUpdateResponse =
        new operations.ExtrasGraphsPartialUpdateResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.graph = utils.objectToClass(httpRes?.data, shared.Graph);
          }
          break;
      }

      return res;
    });
  }

  extrasGraphsRead(
    req: operations.ExtrasGraphsReadRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.ExtrasGraphsReadResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ExtrasGraphsReadRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(baseURL, "/extras/graphs/{id}/", req);

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ExtrasGraphsReadResponse =
        new operations.ExtrasGraphsReadResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.graph = utils.objectToClass(httpRes?.data, shared.Graph);
          }
          break;
      }

      return res;
    });
  }

  extrasGraphsUpdate(
    req: operations.ExtrasGraphsUpdateRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.ExtrasGraphsUpdateResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ExtrasGraphsUpdateRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(baseURL, "/extras/graphs/{id}/", req);

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "writableGraphInput",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "put",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ExtrasGraphsUpdateResponse =
        new operations.ExtrasGraphsUpdateResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.graph = utils.objectToClass(httpRes?.data, shared.Graph);
          }
          break;
      }

      return res;
    });
  }

  extrasImageAttachmentsCreate(
    req: shared.ImageAttachmentInput,
    config?: AxiosRequestConfig
  ): Promise<operations.ExtrasImageAttachmentsCreateResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new shared.ImageAttachmentInput(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/extras/image-attachments/";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "request",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ExtrasImageAttachmentsCreateResponse =
        new operations.ExtrasImageAttachmentsCreateResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.imageAttachment = utils.objectToClass(
              httpRes?.data,
              shared.ImageAttachment
            );
          }
          break;
      }

      return res;
    });
  }

  extrasImageAttachmentsDelete(
    req: operations.ExtrasImageAttachmentsDeleteRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.ExtrasImageAttachmentsDeleteResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ExtrasImageAttachmentsDeleteRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/extras/image-attachments/{id}/",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ExtrasImageAttachmentsDeleteResponse =
        new operations.ExtrasImageAttachmentsDeleteResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
      }

      return res;
    });
  }

  extrasImageAttachmentsList(
    req: operations.ExtrasImageAttachmentsListRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.ExtrasImageAttachmentsListResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ExtrasImageAttachmentsListRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/extras/image-attachments/";

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ExtrasImageAttachmentsListResponse =
        new operations.ExtrasImageAttachmentsListResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.extrasImageAttachmentsList200ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.ExtrasImageAttachmentsList200ApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  extrasImageAttachmentsPartialUpdate(
    req: operations.ExtrasImageAttachmentsPartialUpdateRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.ExtrasImageAttachmentsPartialUpdateResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ExtrasImageAttachmentsPartialUpdateRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/extras/image-attachments/{id}/",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "imageAttachmentInput",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "patch",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ExtrasImageAttachmentsPartialUpdateResponse =
        new operations.ExtrasImageAttachmentsPartialUpdateResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.imageAttachment = utils.objectToClass(
              httpRes?.data,
              shared.ImageAttachment
            );
          }
          break;
      }

      return res;
    });
  }

  extrasImageAttachmentsRead(
    req: operations.ExtrasImageAttachmentsReadRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.ExtrasImageAttachmentsReadResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ExtrasImageAttachmentsReadRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/extras/image-attachments/{id}/",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ExtrasImageAttachmentsReadResponse =
        new operations.ExtrasImageAttachmentsReadResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.imageAttachment = utils.objectToClass(
              httpRes?.data,
              shared.ImageAttachment
            );
          }
          break;
      }

      return res;
    });
  }

  extrasImageAttachmentsUpdate(
    req: operations.ExtrasImageAttachmentsUpdateRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.ExtrasImageAttachmentsUpdateResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ExtrasImageAttachmentsUpdateRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/extras/image-attachments/{id}/",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "imageAttachmentInput",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "put",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ExtrasImageAttachmentsUpdateResponse =
        new operations.ExtrasImageAttachmentsUpdateResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.imageAttachment = utils.objectToClass(
              httpRes?.data,
              shared.ImageAttachment
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Retrieve a list of recent changes.
   */
  extrasObjectChangesList(
    req: operations.ExtrasObjectChangesListRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.ExtrasObjectChangesListResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ExtrasObjectChangesListRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/extras/object-changes/";

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ExtrasObjectChangesListResponse =
        new operations.ExtrasObjectChangesListResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.extrasObjectChangesList200ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.ExtrasObjectChangesList200ApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Retrieve a list of recent changes.
   */
  extrasObjectChangesRead(
    req: operations.ExtrasObjectChangesReadRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.ExtrasObjectChangesReadResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ExtrasObjectChangesReadRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/extras/object-changes/{id}/",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ExtrasObjectChangesReadResponse =
        new operations.ExtrasObjectChangesReadResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.objectChange = utils.objectToClass(
              httpRes?.data,
              shared.ObjectChange
            );
          }
          break;
      }

      return res;
    });
  }

  extrasRecentActivityList(
    req: operations.ExtrasRecentActivityListRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.ExtrasRecentActivityListResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ExtrasRecentActivityListRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/extras/recent-activity/";

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ExtrasRecentActivityListResponse =
        new operations.ExtrasRecentActivityListResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.extrasRecentActivityList200ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.ExtrasRecentActivityList200ApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  extrasRecentActivityRead(
    req: operations.ExtrasRecentActivityReadRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.ExtrasRecentActivityReadResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ExtrasRecentActivityReadRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/extras/recent-activity/{id}/",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ExtrasRecentActivityReadResponse =
        new operations.ExtrasRecentActivityReadResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.userAction = utils.objectToClass(
              httpRes?.data,
              shared.UserAction
            );
          }
          break;
      }

      return res;
    });
  }

  extrasTagsCreate(
    req: shared.TagInput,
    config?: AxiosRequestConfig
  ): Promise<operations.ExtrasTagsCreateResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new shared.TagInput(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/extras/tags/";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "request",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ExtrasTagsCreateResponse =
        new operations.ExtrasTagsCreateResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.tag = utils.objectToClass(httpRes?.data, shared.Tag);
          }
          break;
      }

      return res;
    });
  }

  extrasTagsDelete(
    req: operations.ExtrasTagsDeleteRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.ExtrasTagsDeleteResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ExtrasTagsDeleteRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(baseURL, "/extras/tags/{id}/", req);

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ExtrasTagsDeleteResponse =
        new operations.ExtrasTagsDeleteResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
      }

      return res;
    });
  }

  extrasTagsList(
    req: operations.ExtrasTagsListRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.ExtrasTagsListResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ExtrasTagsListRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/extras/tags/";

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ExtrasTagsListResponse =
        new operations.ExtrasTagsListResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.extrasTagsList200ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.ExtrasTagsList200ApplicationJSON
            );
          }
          break;
      }

      return res;
    });
  }

  extrasTagsPartialUpdate(
    req: operations.ExtrasTagsPartialUpdateRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.ExtrasTagsPartialUpdateResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ExtrasTagsPartialUpdateRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(baseURL, "/extras/tags/{id}/", req);

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "tagInput",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "patch",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ExtrasTagsPartialUpdateResponse =
        new operations.ExtrasTagsPartialUpdateResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.tag = utils.objectToClass(httpRes?.data, shared.Tag);
          }
          break;
      }

      return res;
    });
  }

  extrasTagsRead(
    req: operations.ExtrasTagsReadRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.ExtrasTagsReadResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ExtrasTagsReadRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(baseURL, "/extras/tags/{id}/", req);

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ExtrasTagsReadResponse =
        new operations.ExtrasTagsReadResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.tag = utils.objectToClass(httpRes?.data, shared.Tag);
          }
          break;
      }

      return res;
    });
  }

  extrasTagsUpdate(
    req: operations.ExtrasTagsUpdateRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.ExtrasTagsUpdateResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ExtrasTagsUpdateRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(baseURL, "/extras/tags/{id}/", req);

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "tagInput",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "put",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ExtrasTagsUpdateResponse =
        new operations.ExtrasTagsUpdateResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.tag = utils.objectToClass(httpRes?.data, shared.Tag);
          }
          break;
      }

      return res;
    });
  }

  extrasTopologyMapsCreate(
    req: shared.WritableTopologyMapInput,
    config?: AxiosRequestConfig
  ): Promise<operations.ExtrasTopologyMapsCreateResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new shared.WritableTopologyMapInput(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/extras/topology-maps/";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "request",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ExtrasTopologyMapsCreateResponse =
        new operations.ExtrasTopologyMapsCreateResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.topologyMap = utils.objectToClass(
              httpRes?.data,
              shared.TopologyMap
            );
          }
          break;
      }

      return res;
    });
  }

  extrasTopologyMapsDelete(
    req: operations.ExtrasTopologyMapsDeleteRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.ExtrasTopologyMapsDeleteResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ExtrasTopologyMapsDeleteRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/extras/topology-maps/{id}/",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ExtrasTopologyMapsDeleteResponse =
        new operations.ExtrasTopologyMapsDeleteResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
      }

      return res;
    });
  }

  extrasTopologyMapsList(
    req: operations.ExtrasTopologyMapsListRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.ExtrasTopologyMapsListResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ExtrasTopologyMapsListRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/extras/topology-maps/";

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ExtrasTopologyMapsListResponse =
        new operations.ExtrasTopologyMapsListResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.extrasTopologyMapsList200ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.ExtrasTopologyMapsList200ApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  extrasTopologyMapsPartialUpdate(
    req: operations.ExtrasTopologyMapsPartialUpdateRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.ExtrasTopologyMapsPartialUpdateResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ExtrasTopologyMapsPartialUpdateRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/extras/topology-maps/{id}/",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "writableTopologyMapInput",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "patch",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ExtrasTopologyMapsPartialUpdateResponse =
        new operations.ExtrasTopologyMapsPartialUpdateResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.topologyMap = utils.objectToClass(
              httpRes?.data,
              shared.TopologyMap
            );
          }
          break;
      }

      return res;
    });
  }

  extrasTopologyMapsRead(
    req: operations.ExtrasTopologyMapsReadRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.ExtrasTopologyMapsReadResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ExtrasTopologyMapsReadRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/extras/topology-maps/{id}/",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ExtrasTopologyMapsReadResponse =
        new operations.ExtrasTopologyMapsReadResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.topologyMap = utils.objectToClass(
              httpRes?.data,
              shared.TopologyMap
            );
          }
          break;
      }

      return res;
    });
  }

  extrasTopologyMapsRender(
    req: operations.ExtrasTopologyMapsRenderRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.ExtrasTopologyMapsRenderResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ExtrasTopologyMapsRenderRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/extras/topology-maps/{id}/render/",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ExtrasTopologyMapsRenderResponse =
        new operations.ExtrasTopologyMapsRenderResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.topologyMap = utils.objectToClass(
              httpRes?.data,
              shared.TopologyMap
            );
          }
          break;
      }

      return res;
    });
  }

  extrasTopologyMapsUpdate(
    req: operations.ExtrasTopologyMapsUpdateRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.ExtrasTopologyMapsUpdateResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ExtrasTopologyMapsUpdateRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/extras/topology-maps/{id}/",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "writableTopologyMapInput",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "put",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ExtrasTopologyMapsUpdateResponse =
        new operations.ExtrasTopologyMapsUpdateResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.topologyMap = utils.objectToClass(
              httpRes?.data,
              shared.TopologyMap
            );
          }
          break;
      }

      return res;
    });
  }
}
