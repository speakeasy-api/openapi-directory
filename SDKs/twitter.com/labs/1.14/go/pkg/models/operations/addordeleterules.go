// Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.

package operations

import (
	"bytes"
	"encoding/json"
	"errors"
	"net/http"
	"openapi/pkg/models/shared"
)

type AddOrDeleteRulesQueryParams struct {
	// Dry Run can be used with both the add and delete action, with the expected result given, but without actually taking any action in the system (meaning the end state will always be as it was when the request was submitted). This is particularly useful to validate rule changes.
	DryRun *bool `queryParam:"style=form,explode=true,name=dry_run"`
}

type AddOrDeleteRulesRequestBodyType string

const (
	AddOrDeleteRulesRequestBodyTypeAddRulesRequest    AddOrDeleteRulesRequestBodyType = "AddRulesRequest"
	AddOrDeleteRulesRequestBodyTypeDeleteRulesRequest AddOrDeleteRulesRequestBodyType = "DeleteRulesRequest"
)

type AddOrDeleteRulesRequestBody struct {
	AddRulesRequest    *shared.AddRulesRequest
	DeleteRulesRequest *shared.DeleteRulesRequest

	Type AddOrDeleteRulesRequestBodyType
}

func CreateAddOrDeleteRulesRequestBodyAddRulesRequest(addRulesRequest shared.AddRulesRequest) AddOrDeleteRulesRequestBody {
	typ := AddOrDeleteRulesRequestBodyTypeAddRulesRequest

	return AddOrDeleteRulesRequestBody{
		AddRulesRequest: &addRulesRequest,
		Type:            typ,
	}
}

func CreateAddOrDeleteRulesRequestBodyDeleteRulesRequest(deleteRulesRequest shared.DeleteRulesRequest) AddOrDeleteRulesRequestBody {
	typ := AddOrDeleteRulesRequestBodyTypeDeleteRulesRequest

	return AddOrDeleteRulesRequestBody{
		DeleteRulesRequest: &deleteRulesRequest,
		Type:               typ,
	}
}

func (u *AddOrDeleteRulesRequestBody) UnmarshalJSON(data []byte) error {
	var d *json.Decoder

	addRulesRequest := new(shared.AddRulesRequest)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&addRulesRequest); err == nil {
		u.AddRulesRequest = addRulesRequest
		u.Type = AddOrDeleteRulesRequestBodyTypeAddRulesRequest
		return nil
	}

	deleteRulesRequest := new(shared.DeleteRulesRequest)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&deleteRulesRequest); err == nil {
		u.DeleteRulesRequest = deleteRulesRequest
		u.Type = AddOrDeleteRulesRequestBodyTypeDeleteRulesRequest
		return nil
	}

	return errors.New("could not unmarshal into supported union types")
}

func (u AddOrDeleteRulesRequestBody) MarshalJSON() ([]byte, error) {
	if u.AddRulesRequest != nil {
		return json.Marshal(u.AddRulesRequest)
	}

	if u.DeleteRulesRequest != nil {
		return json.Marshal(u.DeleteRulesRequest)
	}

	return nil, nil
}

type AddOrDeleteRulesRequest struct {
	QueryParams AddOrDeleteRulesQueryParams
	Request     AddOrDeleteRulesRequestBody `request:"mediaType=application/json"`
}

type AddOrDeleteRules200ApplicationJSONType string

const (
	AddOrDeleteRules200ApplicationJSONTypeAddRulesResponse    AddOrDeleteRules200ApplicationJSONType = "AddRulesResponse"
	AddOrDeleteRules200ApplicationJSONTypeDeleteRulesResponse AddOrDeleteRules200ApplicationJSONType = "DeleteRulesResponse"
)

type AddOrDeleteRules200ApplicationJSON struct {
	AddRulesResponse    *shared.AddRulesResponse
	DeleteRulesResponse *shared.DeleteRulesResponse

	Type AddOrDeleteRules200ApplicationJSONType
}

func CreateAddOrDeleteRules200ApplicationJSONAddRulesResponse(addRulesResponse shared.AddRulesResponse) AddOrDeleteRules200ApplicationJSON {
	typ := AddOrDeleteRules200ApplicationJSONTypeAddRulesResponse

	return AddOrDeleteRules200ApplicationJSON{
		AddRulesResponse: &addRulesResponse,
		Type:             typ,
	}
}

func CreateAddOrDeleteRules200ApplicationJSONDeleteRulesResponse(deleteRulesResponse shared.DeleteRulesResponse) AddOrDeleteRules200ApplicationJSON {
	typ := AddOrDeleteRules200ApplicationJSONTypeDeleteRulesResponse

	return AddOrDeleteRules200ApplicationJSON{
		DeleteRulesResponse: &deleteRulesResponse,
		Type:                typ,
	}
}

func (u *AddOrDeleteRules200ApplicationJSON) UnmarshalJSON(data []byte) error {
	var d *json.Decoder

	addRulesResponse := new(shared.AddRulesResponse)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&addRulesResponse); err == nil {
		u.AddRulesResponse = addRulesResponse
		u.Type = AddOrDeleteRules200ApplicationJSONTypeAddRulesResponse
		return nil
	}

	deleteRulesResponse := new(shared.DeleteRulesResponse)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&deleteRulesResponse); err == nil {
		u.DeleteRulesResponse = deleteRulesResponse
		u.Type = AddOrDeleteRules200ApplicationJSONTypeDeleteRulesResponse
		return nil
	}

	return errors.New("could not unmarshal into supported union types")
}

func (u AddOrDeleteRules200ApplicationJSON) MarshalJSON() ([]byte, error) {
	if u.AddRulesResponse != nil {
		return json.Marshal(u.AddRulesResponse)
	}

	if u.DeleteRulesResponse != nil {
		return json.Marshal(u.DeleteRulesResponse)
	}

	return nil, nil
}

type AddOrDeleteRulesResponse struct {
	ContentType string
	// The request has failed.
	Error *shared.Error
	// The request has failed.
	Problem     *shared.Problem
	StatusCode  int
	RawResponse *http.Response
	// The request was successful
	AddOrDeleteRules200ApplicationJSONOneOf *AddOrDeleteRules200ApplicationJSON
}
