// Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.

package operations

import (
	"bytes"
	"encoding/json"
	"errors"
	"net/http"
	"openapi/pkg/models/shared"
)

type GetPlaylistsSecurity struct {
	AuthHeader shared.SchemeAuthHeader `security:"scheme,type=apiKey,subtype=header"`
	ClientID   shared.SchemeClientID   `security:"scheme,type=apiKey,subtype=query"`
}

type GetPlaylistsQueryParams struct {
	// Filters content by level of access the user (logged in or anonymous) has to the track. The result list will include only tracks with the specified access. Include all options if you'd like to see all possible tracks. See `Track#access` schema for more details.
	//
	Access []shared.AccessEnum `queryParam:"style=form,explode=false,name=access"`
	// Number of results to return in the collection.
	Limit *int64 `queryParam:"style=form,explode=true,name=limit"`
	// Returns paginated collection of items (recommended, returning a list without pagination is deprecated and should not be used)
	LinkedPartitioning *bool `queryParam:"style=form,explode=true,name=linked_partitioning"`
	// Offset of first result. Deprecated, use `linked_partitioning` instead.
	Offset *int64 `queryParam:"style=form,explode=true,name=offset"`
	// search
	Q string `queryParam:"style=form,explode=true,name=q"`
}

type GetPlaylistsRequest struct {
	QueryParams GetPlaylistsQueryParams
	Security    GetPlaylistsSecurity
}

type GetPlaylists200ApplicationJSONType string

const (
	GetPlaylists200ApplicationJSONTypePlaylists       GetPlaylists200ApplicationJSONType = "Playlists"
	GetPlaylists200ApplicationJSONTypeArrayOfPlaylist GetPlaylists200ApplicationJSONType = "arrayOfPlaylist"
)

type GetPlaylists200ApplicationJSON struct {
	Playlists       *shared.Playlists
	ArrayOfPlaylist []shared.Playlist

	Type GetPlaylists200ApplicationJSONType
}

func CreateGetPlaylists200ApplicationJSONPlaylists(playlists shared.Playlists) GetPlaylists200ApplicationJSON {
	typ := GetPlaylists200ApplicationJSONTypePlaylists

	return GetPlaylists200ApplicationJSON{
		Playlists: &playlists,
		Type:      typ,
	}
}

func CreateGetPlaylists200ApplicationJSONArrayOfPlaylist(arrayOfPlaylist []shared.Playlist) GetPlaylists200ApplicationJSON {
	typ := GetPlaylists200ApplicationJSONTypeArrayOfPlaylist

	return GetPlaylists200ApplicationJSON{
		ArrayOfPlaylist: arrayOfPlaylist,
		Type:            typ,
	}
}

func (u *GetPlaylists200ApplicationJSON) UnmarshalJSON(data []byte) error {
	var d *json.Decoder

	playlists := new(shared.Playlists)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&playlists); err == nil {
		u.Playlists = playlists
		u.Type = GetPlaylists200ApplicationJSONTypePlaylists
		return nil
	}

	arrayOfPlaylist := []shared.Playlist{}
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&arrayOfPlaylist); err == nil {
		u.ArrayOfPlaylist = arrayOfPlaylist
		u.Type = GetPlaylists200ApplicationJSONTypeArrayOfPlaylist
		return nil
	}

	return errors.New("could not unmarshal into supported union types")
}

func (u GetPlaylists200ApplicationJSON) MarshalJSON() ([]byte, error) {
	if u.Playlists != nil {
		return json.Marshal(u.Playlists)
	}

	if u.ArrayOfPlaylist != nil {
		return json.Marshal(u.ArrayOfPlaylist)
	}

	return nil, nil
}

type GetPlaylistsResponse struct {
	ContentType string
	// Bad Request
	Error       *shared.Error
	StatusCode  int
	RawResponse *http.Response
	// Success
	GetPlaylists200ApplicationJSONOneOf *GetPlaylists200ApplicationJSON
}
