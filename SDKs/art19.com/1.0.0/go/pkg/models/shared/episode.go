// Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.

package shared

import (
	"encoding/json"
	"fmt"
	"time"
)

// EpisodeAttributesItunesTypeEnum - The type of the episode according to Apple's type categorization
type EpisodeAttributesItunesTypeEnum string

const (
	EpisodeAttributesItunesTypeEnumFull    EpisodeAttributesItunesTypeEnum = "full"
	EpisodeAttributesItunesTypeEnumBonus   EpisodeAttributesItunesTypeEnum = "bonus"
	EpisodeAttributesItunesTypeEnumTrailer EpisodeAttributesItunesTypeEnum = "trailer"
)

func (e *EpisodeAttributesItunesTypeEnum) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return err
	}
	switch s {
	case "full":
		fallthrough
	case "bonus":
		fallthrough
	case "trailer":
		*e = EpisodeAttributesItunesTypeEnum(s)
		return nil
	default:
		return fmt.Errorf("invalid value for EpisodeAttributesItunesTypeEnum: %s", s)
	}
}

// EpisodeAttributesPremiumStatusEnum - The current premium status of the episode
type EpisodeAttributesPremiumStatusEnum string

const (
	EpisodeAttributesPremiumStatusEnumActive        EpisodeAttributesPremiumStatusEnum = "active"
	EpisodeAttributesPremiumStatusEnumInactive      EpisodeAttributesPremiumStatusEnum = "inactive"
	EpisodeAttributesPremiumStatusEnumForceActive   EpisodeAttributesPremiumStatusEnum = "force-active"
	EpisodeAttributesPremiumStatusEnumForceInactive EpisodeAttributesPremiumStatusEnum = "force-inactive"
)

func (e *EpisodeAttributesPremiumStatusEnum) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return err
	}
	switch s {
	case "active":
		fallthrough
	case "inactive":
		fallthrough
	case "force-active":
		fallthrough
	case "force-inactive":
		*e = EpisodeAttributesPremiumStatusEnum(s)
		return nil
	default:
		return fmt.Errorf("invalid value for EpisodeAttributesPremiumStatusEnum: %s", s)
	}
}

// EpisodeAttributesStatusEnum - The status of an episode
type EpisodeAttributesStatusEnum string

const (
	EpisodeAttributesStatusEnumActive   EpisodeAttributesStatusEnum = "active"
	EpisodeAttributesStatusEnumInactive EpisodeAttributesStatusEnum = "inactive"
)

func (e *EpisodeAttributesStatusEnum) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return err
	}
	switch s {
	case "active":
		fallthrough
	case "inactive":
		*e = EpisodeAttributesStatusEnum(s)
		return nil
	default:
		return fmt.Errorf("invalid value for EpisodeAttributesStatusEnum: %s", s)
	}
}

type EpisodeAttributes struct {
	// Only visible to credentials having write privileges for the series.
	//
	AllowUserComments *bool `json:"allow_user_comments,omitempty"`
	// This will be replaced by the relationship `cascaded_cover_image` in a future update.<br/>
	// The image ID of the cover art for this episode. This is the preferred image ID to use.
	// If there is no specific cover for the episode, the image ID of the season or the
	// series will be returned, whichever has one defined.
	// The `/images` endpoint provides details to the image.
	//
	CascadedCoverImageID *string `json:"cascaded_cover_image_id,omitempty"`
	// This will be replaced by the relationship `cover_image` in a future update.<br/>
	// The image ID of the cover art for this episode, if an episode-specific image has been provided.
	// The `/images` endpoint provideds details to the image.
	//
	CoverImageID *string    `json:"cover_image_id,omitempty"`
	CreatedAt    *time.Time `json:"created_at,omitempty"`
	// The description of the episode, possibly in HTML format
	Description *string `json:"description,omitempty"`
	// Determines whether `description` is in HTML format or plain.
	DescriptionIsHTML *bool `json:"description_is_html,omitempty"`
	// The description with all HTML markup removed. If the description does not contain markup,
	// this is identical to `description`.
	//
	DescriptionPlain *string `json:"description_plain,omitempty"`
	// The file name, without extension, to present users when downloading the episode
	FileName *string `json:"file_name,omitempty"`
	// The type of the episode according to Apple's type categorization
	ItunesType *EpisodeAttributesItunesTypeEnum `json:"itunes_type,omitempty"`
	// The number of total downloads all time for this episode.
	// Only visible if the credential has the right privilege on the series.
	//
	ListenCount *int64 `json:"listen_count,omitempty"`
	// The current premium status of the episode
	PremiumStatus *EpisodeAttributesPremiumStatusEnum `json:"premium_status,omitempty"`
	// If `true`, the episode will be available for download and included in the feed as soon as its
	// release time is reached, provided it has a valid media file, and `release_end_at` is in the future (if applicable).
	//
	Published *bool `json:"published,omitempty"`
	// The date and time when an episode will no longer be included in the feed, or available for download.
	// `Published` will remain `true` unless the episode is manually unpublished.
	//
	ReleaseEndAt *time.Time `json:"release_end_at,omitempty"`
	// If `true`, the episode's release time is set in a way it is considered released right away.
	// Only visible if the credential has write privileges on the series.
	//
	ReleaseImmediately *bool `json:"release_immediately,omitempty"`
	// The date and time when an episode will be released. It will be available for download and included
	// in the feed if this time is reached, `published` is set to `true`, and the episode has a media file.
	//
	ReleasedAt *time.Time `json:"released_at,omitempty"`
	// A globally unique identifier describing the episode. This ID is commonly used by podcast applications
	// to determine whether an episode has already been downloaded or not.
	//
	RssGUID *string `json:"rss_guid,omitempty"`
	// Use the relationship `season` instead.<br />
	// The ID of the season an episode belongs to. This can be `null`. A series can have episodes with and
	// without seasons at the same time.
	//
	SeasonID *string `json:"season_id,omitempty"`
	// Use the relationship `series` instead.<br />
	// The ID of the series an episode belongs to.
	//
	SeriesID *string `json:"series_id,omitempty"`
	// The title of the episode modified for sorting. This converts all characters to
	// lower case, removes an eventually leading `The` as well as leading and trailling whitespace characters.
	//
	SortTitle *string `json:"sort_title,omitempty"`
	// The status of an episode
	Status *EpisodeAttributesStatusEnum `json:"status,omitempty"`
	// The title of the episode
	Title     *string    `json:"title,omitempty"`
	UpdatedAt *time.Time `json:"updated_at,omitempty"`
}

// EpisodeRelationshipsCascadedCoverImage - The cover art for this episode. This is the preferred image to use.
// If there is no specific cover image for the episode, the cover of the season or the
// series will be returned, whichever has one defined.
// The `/images` endpoint provides details to the image.
type EpisodeRelationshipsCascadedCoverImage struct {
	Data *ResourceIdentifier `json:"data,omitempty"`
}

type EpisodeRelationshipsAListOfClassificationsAssociatedWithTheEpisode struct {
	Data []ResourceIdentifier `json:"data,omitempty"`
}

// EpisodeRelationshipsCoverImage - The cover art for this episode, if an episode-specific image has been provided.
// The `/images` endpoint provideds details to the image.
type EpisodeRelationshipsCoverImage struct {
	Data *ResourceIdentifier `json:"data,omitempty"`
}

type EpisodeRelationshipsAListOfCreditsGivenToPeopleInTheEpisode struct {
	Data []ResourceIdentifier `json:"data,omitempty"`
}

// EpisodeRelationshipsAListOfDefaultWarpFeedMarkerPoints - Only visible if the credential has write privileges on the series
type EpisodeRelationshipsAListOfDefaultWarpFeedMarkerPoints struct {
	Data []ResourceIdentifier `json:"data,omitempty"`
}

// EpisodeRelationshipsAListOfEpisodeVersionsForThisEpisode - Only visible if the credential has write privileges on the series
type EpisodeRelationshipsAListOfEpisodeVersionsForThisEpisode struct {
	Data []ResourceIdentifier `json:"data,omitempty"`
}

type EpisodeRelationshipsBothTheCoverImageAndTheCascadedCoverImageForTheSeason struct {
	Data []ResourceIdentifier `json:"data,omitempty"`
}

type EpisodeRelationshipsTheSeasonTheEpisodeBelongsTo struct {
	Data *ResourceIdentifier `json:"data,omitempty"`
}

// EpisodeRelationshipsAListOfSegmentListsDirectlyAttachedToTheEpisode - Only visible if the credential has write privileges on the series
type EpisodeRelationshipsAListOfSegmentListsDirectlyAttachedToTheEpisode struct {
	Data []ResourceIdentifier `json:"data,omitempty"`
}

type EpisodeRelationshipsTheSeriesAnEpisodeBelongsTo struct {
	Data *ResourceIdentifier `json:"data,omitempty"`
}

type EpisodeRelationshipsAListOfAssociationsLinkingTagsToTheEpisodes struct {
	Data []ResourceIdentifier `json:"data,omitempty"`
}

type EpisodeRelationshipsAListOfTagsAssociatedWithTheEpisodes struct {
	Data []ResourceIdentifier `json:"data,omitempty"`
}

type EpisodeRelationships struct {
	// The cover art for this episode. This is the preferred image to use.
	// If there is no specific cover image for the episode, the cover of the season or the
	// series will be returned, whichever has one defined.
	// The `/images` endpoint provides details to the image.
	//
	CascadedCoverImage       *EpisodeRelationshipsCascadedCoverImage                             `json:"cascaded_cover_image,omitempty"`
	ClassificationInclusions *EpisodeRelationshipsAListOfClassificationsAssociatedWithTheEpisode `json:"classification_inclusions,omitempty"`
	// The cover art for this episode, if an episode-specific image has been provided.
	// The `/images` endpoint provideds details to the image.
	//
	CoverImage *EpisodeRelationshipsCoverImage                              `json:"cover_image,omitempty"`
	Credits    *EpisodeRelationshipsAListOfCreditsGivenToPeopleInTheEpisode `json:"credits,omitempty"`
	// Only visible if the credential has write privileges on the series
	DefaultMarkerPoints *EpisodeRelationshipsAListOfDefaultWarpFeedMarkerPoints `json:"default_marker_points,omitempty"`
	// Only visible if the credential has write privileges on the series
	EpisodeVersions *EpisodeRelationshipsAListOfEpisodeVersionsForThisEpisode                  `json:"episode_versions,omitempty"`
	Images          *EpisodeRelationshipsBothTheCoverImageAndTheCascadedCoverImageForTheSeason `json:"images,omitempty"`
	Season          *EpisodeRelationshipsTheSeasonTheEpisodeBelongsTo                          `json:"season,omitempty"`
	// Only visible if the credential has write privileges on the series
	SegmentLists *EpisodeRelationshipsAListOfSegmentListsDirectlyAttachedToTheEpisode `json:"segment_lists,omitempty"`
	Series       *EpisodeRelationshipsTheSeriesAnEpisodeBelongsTo                     `json:"series,omitempty"`
	Taggings     *EpisodeRelationshipsAListOfAssociationsLinkingTagsToTheEpisodes     `json:"taggings,omitempty"`
	Tags         *EpisodeRelationshipsAListOfTagsAssociatedWithTheEpisodes            `json:"tags,omitempty"`
}

type Episode struct {
	Attributes    *EpisodeAttributes    `json:"attributes,omitempty"`
	ID            *string               `json:"id,omitempty"`
	Relationships *EpisodeRelationships `json:"relationships,omitempty"`
	// The type of resource. This is always `episodes`
	Type *string `json:"type,omitempty"`
}
