// Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.

package operations

import (
	"bytes"
	"encoding/json"
	"errors"
	"net/http"
	"openapi/pkg/models/shared"
)

type UploadFileByTokenAsBinary1PathParams struct {
	// Upload token
	Token string `pathParam:"style=simple,explode=false,name=token"`
}

type UploadFileByTokenAsBinary1Headers struct {
	// Content-Range
	//
	// e.g. `bytes 0-999/3980`
	ContentRange *string `header:"style=simple,explode=false,name=Content-Range"`
}

type UploadFileByTokenAsBinary1RequestBodyFile struct {
	Content []byte `multipartForm:"content"`
	File    string `multipartForm:"name=file"`
}

// UploadFileByTokenAsBinary1RequestBody - File
type UploadFileByTokenAsBinary1RequestBody struct {
	File *UploadFileByTokenAsBinary1RequestBodyFile `multipartForm:"file"`
}

type UploadFileByTokenAsBinary1Request struct {
	PathParams UploadFileByTokenAsBinary1PathParams
	Headers    UploadFileByTokenAsBinary1Headers
	// File
	Request UploadFileByTokenAsBinary1RequestBody `request:"mediaType=multipart/form-data"`
}

type UploadFileByTokenAsBinary1507ApplicationJSONType string

const (
	UploadFileByTokenAsBinary1507ApplicationJSONTypeChunkUploadResponse UploadFileByTokenAsBinary1507ApplicationJSONType = "ChunkUploadResponse"
	UploadFileByTokenAsBinary1507ApplicationJSONTypeErrorResponse       UploadFileByTokenAsBinary1507ApplicationJSONType = "ErrorResponse"
)

type UploadFileByTokenAsBinary1507ApplicationJSON struct {
	ChunkUploadResponse *shared.ChunkUploadResponse
	ErrorResponse       *shared.ErrorResponse

	Type UploadFileByTokenAsBinary1507ApplicationJSONType
}

func CreateUploadFileByTokenAsBinary1507ApplicationJSONChunkUploadResponse(chunkUploadResponse shared.ChunkUploadResponse) UploadFileByTokenAsBinary1507ApplicationJSON {
	typ := UploadFileByTokenAsBinary1507ApplicationJSONTypeChunkUploadResponse

	return UploadFileByTokenAsBinary1507ApplicationJSON{
		ChunkUploadResponse: &chunkUploadResponse,
		Type:                typ,
	}
}

func CreateUploadFileByTokenAsBinary1507ApplicationJSONErrorResponse(errorResponse shared.ErrorResponse) UploadFileByTokenAsBinary1507ApplicationJSON {
	typ := UploadFileByTokenAsBinary1507ApplicationJSONTypeErrorResponse

	return UploadFileByTokenAsBinary1507ApplicationJSON{
		ErrorResponse: &errorResponse,
		Type:          typ,
	}
}

func (u *UploadFileByTokenAsBinary1507ApplicationJSON) UnmarshalJSON(data []byte) error {
	var d *json.Decoder

	chunkUploadResponse := new(shared.ChunkUploadResponse)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&chunkUploadResponse); err == nil {
		u.ChunkUploadResponse = chunkUploadResponse
		u.Type = UploadFileByTokenAsBinary1507ApplicationJSONTypeChunkUploadResponse
		return nil
	}

	errorResponse := new(shared.ErrorResponse)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&errorResponse); err == nil {
		u.ErrorResponse = errorResponse
		u.Type = UploadFileByTokenAsBinary1507ApplicationJSONTypeErrorResponse
		return nil
	}

	return errors.New("could not unmarshal into supported union types")
}

func (u UploadFileByTokenAsBinary1507ApplicationJSON) MarshalJSON() ([]byte, error) {
	if u.ChunkUploadResponse != nil {
		return json.Marshal(u.ChunkUploadResponse)
	}

	if u.ErrorResponse != nil {
		return json.Marshal(u.ErrorResponse)
	}

	return nil, nil
}

type UploadFileByTokenAsBinary1406ApplicationJSONType string

const (
	UploadFileByTokenAsBinary1406ApplicationJSONTypeChunkUploadResponse UploadFileByTokenAsBinary1406ApplicationJSONType = "ChunkUploadResponse"
	UploadFileByTokenAsBinary1406ApplicationJSONTypeErrorResponse       UploadFileByTokenAsBinary1406ApplicationJSONType = "ErrorResponse"
)

type UploadFileByTokenAsBinary1406ApplicationJSON struct {
	ChunkUploadResponse *shared.ChunkUploadResponse
	ErrorResponse       *shared.ErrorResponse

	Type UploadFileByTokenAsBinary1406ApplicationJSONType
}

func CreateUploadFileByTokenAsBinary1406ApplicationJSONChunkUploadResponse(chunkUploadResponse shared.ChunkUploadResponse) UploadFileByTokenAsBinary1406ApplicationJSON {
	typ := UploadFileByTokenAsBinary1406ApplicationJSONTypeChunkUploadResponse

	return UploadFileByTokenAsBinary1406ApplicationJSON{
		ChunkUploadResponse: &chunkUploadResponse,
		Type:                typ,
	}
}

func CreateUploadFileByTokenAsBinary1406ApplicationJSONErrorResponse(errorResponse shared.ErrorResponse) UploadFileByTokenAsBinary1406ApplicationJSON {
	typ := UploadFileByTokenAsBinary1406ApplicationJSONTypeErrorResponse

	return UploadFileByTokenAsBinary1406ApplicationJSON{
		ErrorResponse: &errorResponse,
		Type:          typ,
	}
}

func (u *UploadFileByTokenAsBinary1406ApplicationJSON) UnmarshalJSON(data []byte) error {
	var d *json.Decoder

	chunkUploadResponse := new(shared.ChunkUploadResponse)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&chunkUploadResponse); err == nil {
		u.ChunkUploadResponse = chunkUploadResponse
		u.Type = UploadFileByTokenAsBinary1406ApplicationJSONTypeChunkUploadResponse
		return nil
	}

	errorResponse := new(shared.ErrorResponse)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&errorResponse); err == nil {
		u.ErrorResponse = errorResponse
		u.Type = UploadFileByTokenAsBinary1406ApplicationJSONTypeErrorResponse
		return nil
	}

	return errors.New("could not unmarshal into supported union types")
}

func (u UploadFileByTokenAsBinary1406ApplicationJSON) MarshalJSON() ([]byte, error) {
	if u.ChunkUploadResponse != nil {
		return json.Marshal(u.ChunkUploadResponse)
	}

	if u.ErrorResponse != nil {
		return json.Marshal(u.ErrorResponse)
	}

	return nil, nil
}

type UploadFileByTokenAsBinary1404ApplicationJSONType string

const (
	UploadFileByTokenAsBinary1404ApplicationJSONTypeChunkUploadResponse UploadFileByTokenAsBinary1404ApplicationJSONType = "ChunkUploadResponse"
	UploadFileByTokenAsBinary1404ApplicationJSONTypeErrorResponse       UploadFileByTokenAsBinary1404ApplicationJSONType = "ErrorResponse"
)

type UploadFileByTokenAsBinary1404ApplicationJSON struct {
	ChunkUploadResponse *shared.ChunkUploadResponse
	ErrorResponse       *shared.ErrorResponse

	Type UploadFileByTokenAsBinary1404ApplicationJSONType
}

func CreateUploadFileByTokenAsBinary1404ApplicationJSONChunkUploadResponse(chunkUploadResponse shared.ChunkUploadResponse) UploadFileByTokenAsBinary1404ApplicationJSON {
	typ := UploadFileByTokenAsBinary1404ApplicationJSONTypeChunkUploadResponse

	return UploadFileByTokenAsBinary1404ApplicationJSON{
		ChunkUploadResponse: &chunkUploadResponse,
		Type:                typ,
	}
}

func CreateUploadFileByTokenAsBinary1404ApplicationJSONErrorResponse(errorResponse shared.ErrorResponse) UploadFileByTokenAsBinary1404ApplicationJSON {
	typ := UploadFileByTokenAsBinary1404ApplicationJSONTypeErrorResponse

	return UploadFileByTokenAsBinary1404ApplicationJSON{
		ErrorResponse: &errorResponse,
		Type:          typ,
	}
}

func (u *UploadFileByTokenAsBinary1404ApplicationJSON) UnmarshalJSON(data []byte) error {
	var d *json.Decoder

	chunkUploadResponse := new(shared.ChunkUploadResponse)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&chunkUploadResponse); err == nil {
		u.ChunkUploadResponse = chunkUploadResponse
		u.Type = UploadFileByTokenAsBinary1404ApplicationJSONTypeChunkUploadResponse
		return nil
	}

	errorResponse := new(shared.ErrorResponse)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&errorResponse); err == nil {
		u.ErrorResponse = errorResponse
		u.Type = UploadFileByTokenAsBinary1404ApplicationJSONTypeErrorResponse
		return nil
	}

	return errors.New("could not unmarshal into supported union types")
}

func (u UploadFileByTokenAsBinary1404ApplicationJSON) MarshalJSON() ([]byte, error) {
	if u.ChunkUploadResponse != nil {
		return json.Marshal(u.ChunkUploadResponse)
	}

	if u.ErrorResponse != nil {
		return json.Marshal(u.ErrorResponse)
	}

	return nil, nil
}

type UploadFileByTokenAsBinary1403ApplicationJSONType string

const (
	UploadFileByTokenAsBinary1403ApplicationJSONTypeChunkUploadResponse UploadFileByTokenAsBinary1403ApplicationJSONType = "ChunkUploadResponse"
	UploadFileByTokenAsBinary1403ApplicationJSONTypeErrorResponse       UploadFileByTokenAsBinary1403ApplicationJSONType = "ErrorResponse"
)

type UploadFileByTokenAsBinary1403ApplicationJSON struct {
	ChunkUploadResponse *shared.ChunkUploadResponse
	ErrorResponse       *shared.ErrorResponse

	Type UploadFileByTokenAsBinary1403ApplicationJSONType
}

func CreateUploadFileByTokenAsBinary1403ApplicationJSONChunkUploadResponse(chunkUploadResponse shared.ChunkUploadResponse) UploadFileByTokenAsBinary1403ApplicationJSON {
	typ := UploadFileByTokenAsBinary1403ApplicationJSONTypeChunkUploadResponse

	return UploadFileByTokenAsBinary1403ApplicationJSON{
		ChunkUploadResponse: &chunkUploadResponse,
		Type:                typ,
	}
}

func CreateUploadFileByTokenAsBinary1403ApplicationJSONErrorResponse(errorResponse shared.ErrorResponse) UploadFileByTokenAsBinary1403ApplicationJSON {
	typ := UploadFileByTokenAsBinary1403ApplicationJSONTypeErrorResponse

	return UploadFileByTokenAsBinary1403ApplicationJSON{
		ErrorResponse: &errorResponse,
		Type:          typ,
	}
}

func (u *UploadFileByTokenAsBinary1403ApplicationJSON) UnmarshalJSON(data []byte) error {
	var d *json.Decoder

	chunkUploadResponse := new(shared.ChunkUploadResponse)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&chunkUploadResponse); err == nil {
		u.ChunkUploadResponse = chunkUploadResponse
		u.Type = UploadFileByTokenAsBinary1403ApplicationJSONTypeChunkUploadResponse
		return nil
	}

	errorResponse := new(shared.ErrorResponse)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&errorResponse); err == nil {
		u.ErrorResponse = errorResponse
		u.Type = UploadFileByTokenAsBinary1403ApplicationJSONTypeErrorResponse
		return nil
	}

	return errors.New("could not unmarshal into supported union types")
}

func (u UploadFileByTokenAsBinary1403ApplicationJSON) MarshalJSON() ([]byte, error) {
	if u.ChunkUploadResponse != nil {
		return json.Marshal(u.ChunkUploadResponse)
	}

	if u.ErrorResponse != nil {
		return json.Marshal(u.ErrorResponse)
	}

	return nil, nil
}

type UploadFileByTokenAsBinary1401ApplicationJSONType string

const (
	UploadFileByTokenAsBinary1401ApplicationJSONTypeChunkUploadResponse UploadFileByTokenAsBinary1401ApplicationJSONType = "ChunkUploadResponse"
	UploadFileByTokenAsBinary1401ApplicationJSONTypeErrorResponse       UploadFileByTokenAsBinary1401ApplicationJSONType = "ErrorResponse"
)

type UploadFileByTokenAsBinary1401ApplicationJSON struct {
	ChunkUploadResponse *shared.ChunkUploadResponse
	ErrorResponse       *shared.ErrorResponse

	Type UploadFileByTokenAsBinary1401ApplicationJSONType
}

func CreateUploadFileByTokenAsBinary1401ApplicationJSONChunkUploadResponse(chunkUploadResponse shared.ChunkUploadResponse) UploadFileByTokenAsBinary1401ApplicationJSON {
	typ := UploadFileByTokenAsBinary1401ApplicationJSONTypeChunkUploadResponse

	return UploadFileByTokenAsBinary1401ApplicationJSON{
		ChunkUploadResponse: &chunkUploadResponse,
		Type:                typ,
	}
}

func CreateUploadFileByTokenAsBinary1401ApplicationJSONErrorResponse(errorResponse shared.ErrorResponse) UploadFileByTokenAsBinary1401ApplicationJSON {
	typ := UploadFileByTokenAsBinary1401ApplicationJSONTypeErrorResponse

	return UploadFileByTokenAsBinary1401ApplicationJSON{
		ErrorResponse: &errorResponse,
		Type:          typ,
	}
}

func (u *UploadFileByTokenAsBinary1401ApplicationJSON) UnmarshalJSON(data []byte) error {
	var d *json.Decoder

	chunkUploadResponse := new(shared.ChunkUploadResponse)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&chunkUploadResponse); err == nil {
		u.ChunkUploadResponse = chunkUploadResponse
		u.Type = UploadFileByTokenAsBinary1401ApplicationJSONTypeChunkUploadResponse
		return nil
	}

	errorResponse := new(shared.ErrorResponse)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&errorResponse); err == nil {
		u.ErrorResponse = errorResponse
		u.Type = UploadFileByTokenAsBinary1401ApplicationJSONTypeErrorResponse
		return nil
	}

	return errors.New("could not unmarshal into supported union types")
}

func (u UploadFileByTokenAsBinary1401ApplicationJSON) MarshalJSON() ([]byte, error) {
	if u.ChunkUploadResponse != nil {
		return json.Marshal(u.ChunkUploadResponse)
	}

	if u.ErrorResponse != nil {
		return json.Marshal(u.ErrorResponse)
	}

	return nil, nil
}

type UploadFileByTokenAsBinary1400ApplicationJSONType string

const (
	UploadFileByTokenAsBinary1400ApplicationJSONTypeChunkUploadResponse UploadFileByTokenAsBinary1400ApplicationJSONType = "ChunkUploadResponse"
	UploadFileByTokenAsBinary1400ApplicationJSONTypeErrorResponse       UploadFileByTokenAsBinary1400ApplicationJSONType = "ErrorResponse"
)

type UploadFileByTokenAsBinary1400ApplicationJSON struct {
	ChunkUploadResponse *shared.ChunkUploadResponse
	ErrorResponse       *shared.ErrorResponse

	Type UploadFileByTokenAsBinary1400ApplicationJSONType
}

func CreateUploadFileByTokenAsBinary1400ApplicationJSONChunkUploadResponse(chunkUploadResponse shared.ChunkUploadResponse) UploadFileByTokenAsBinary1400ApplicationJSON {
	typ := UploadFileByTokenAsBinary1400ApplicationJSONTypeChunkUploadResponse

	return UploadFileByTokenAsBinary1400ApplicationJSON{
		ChunkUploadResponse: &chunkUploadResponse,
		Type:                typ,
	}
}

func CreateUploadFileByTokenAsBinary1400ApplicationJSONErrorResponse(errorResponse shared.ErrorResponse) UploadFileByTokenAsBinary1400ApplicationJSON {
	typ := UploadFileByTokenAsBinary1400ApplicationJSONTypeErrorResponse

	return UploadFileByTokenAsBinary1400ApplicationJSON{
		ErrorResponse: &errorResponse,
		Type:          typ,
	}
}

func (u *UploadFileByTokenAsBinary1400ApplicationJSON) UnmarshalJSON(data []byte) error {
	var d *json.Decoder

	chunkUploadResponse := new(shared.ChunkUploadResponse)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&chunkUploadResponse); err == nil {
		u.ChunkUploadResponse = chunkUploadResponse
		u.Type = UploadFileByTokenAsBinary1400ApplicationJSONTypeChunkUploadResponse
		return nil
	}

	errorResponse := new(shared.ErrorResponse)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&errorResponse); err == nil {
		u.ErrorResponse = errorResponse
		u.Type = UploadFileByTokenAsBinary1400ApplicationJSONTypeErrorResponse
		return nil
	}

	return errors.New("could not unmarshal into supported union types")
}

func (u UploadFileByTokenAsBinary1400ApplicationJSON) MarshalJSON() ([]byte, error) {
	if u.ChunkUploadResponse != nil {
		return json.Marshal(u.ChunkUploadResponse)
	}

	if u.ErrorResponse != nil {
		return json.Marshal(u.ErrorResponse)
	}

	return nil, nil
}

type UploadFileByTokenAsBinary1Response struct {
	// Created
	ChunkUploadResponse *shared.ChunkUploadResponse
	ContentType         string
	StatusCode          int
	RawResponse         *http.Response
	// Bad Request
	UploadFileByTokenAsBinary1400ApplicationJSONOneOf *UploadFileByTokenAsBinary1400ApplicationJSON
	// Unauthorized
	UploadFileByTokenAsBinary1401ApplicationJSONOneOf *UploadFileByTokenAsBinary1401ApplicationJSON
	// Forbidden
	UploadFileByTokenAsBinary1403ApplicationJSONOneOf *UploadFileByTokenAsBinary1403ApplicationJSON
	// Not Found
	UploadFileByTokenAsBinary1404ApplicationJSONOneOf *UploadFileByTokenAsBinary1404ApplicationJSON
	// Not Acceptable
	UploadFileByTokenAsBinary1406ApplicationJSONOneOf *UploadFileByTokenAsBinary1406ApplicationJSON
	// Insufficient Storage
	UploadFileByTokenAsBinary1507ApplicationJSONOneOf *UploadFileByTokenAsBinary1507ApplicationJSON
}
