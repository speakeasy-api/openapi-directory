/*
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

import * as utils from "../internal/utils";
import * as operations from "./models/operations";
import * as shared from "./models/shared";
import { AxiosInstance, AxiosRequestConfig, AxiosResponse } from "axios";

export class Users {
  _defaultClient: AxiosInstance;
  _securityClient: AxiosInstance;
  _serverURL: string;
  _language: string;
  _sdkVersion: string;
  _genVersion: string;

  constructor(
    defaultClient: AxiosInstance,
    securityClient: AxiosInstance,
    serverURL: string,
    language: string,
    sdkVersion: string,
    genVersion: string
  ) {
    this._defaultClient = defaultClient;
    this._securityClient = securityClient;
    this._serverURL = serverURL;
    this._language = language;
    this._sdkVersion = sdkVersion;
    this._genVersion = genVersion;
  }

  /**
   * Removes an alias.
   */
  directoryUsersAliasesDelete(
    req: operations.DirectoryUsersAliasesDeleteRequest,
    security: operations.DirectoryUsersAliasesDeleteSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.DirectoryUsersAliasesDeleteResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DirectoryUsersAliasesDeleteRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/admin/directory/v1/users/{userKey}/aliases/{alias}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.DirectoryUsersAliasesDeleteSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DirectoryUsersAliasesDeleteResponse =
        new operations.DirectoryUsersAliasesDeleteResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          break;
      }

      return res;
    });
  }

  /**
   * Adds an alias.
   */
  directoryUsersAliasesInsert(
    req: operations.DirectoryUsersAliasesInsertRequest,
    security: operations.DirectoryUsersAliasesInsertSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.DirectoryUsersAliasesInsertResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DirectoryUsersAliasesInsertRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/admin/directory/v1/users/{userKey}/aliases",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "alias",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.DirectoryUsersAliasesInsertSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DirectoryUsersAliasesInsertResponse =
        new operations.DirectoryUsersAliasesInsertResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.alias = utils.objectToClass(httpRes?.data, shared.Alias);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Lists all aliases for a user.
   */
  directoryUsersAliasesList(
    req: operations.DirectoryUsersAliasesListRequest,
    security: operations.DirectoryUsersAliasesListSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.DirectoryUsersAliasesListResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DirectoryUsersAliasesListRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/admin/directory/v1/users/{userKey}/aliases",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.DirectoryUsersAliasesListSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DirectoryUsersAliasesListResponse =
        new operations.DirectoryUsersAliasesListResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.aliases = utils.objectToClass(httpRes?.data, shared.Aliases);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Watches for changes in users list.
   */
  directoryUsersAliasesWatch(
    req: operations.DirectoryUsersAliasesWatchRequest,
    security: operations.DirectoryUsersAliasesWatchSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.DirectoryUsersAliasesWatchResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DirectoryUsersAliasesWatchRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/admin/directory/v1/users/{userKey}/aliases/watch",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "channel",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.DirectoryUsersAliasesWatchSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DirectoryUsersAliasesWatchResponse =
        new operations.DirectoryUsersAliasesWatchResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.channel = utils.objectToClass(httpRes?.data, shared.Channel);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Deletes a user.
   */
  directoryUsersDelete(
    req: operations.DirectoryUsersDeleteRequest,
    security: operations.DirectoryUsersDeleteSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.DirectoryUsersDeleteResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DirectoryUsersDeleteRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/admin/directory/v1/users/{userKey}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.DirectoryUsersDeleteSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DirectoryUsersDeleteResponse =
        new operations.DirectoryUsersDeleteResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          break;
      }

      return res;
    });
  }

  /**
   * Retrieves a user.
   */
  directoryUsersGet(
    req: operations.DirectoryUsersGetRequest,
    security: operations.DirectoryUsersGetSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.DirectoryUsersGetResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DirectoryUsersGetRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/admin/directory/v1/users/{userKey}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.DirectoryUsersGetSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DirectoryUsersGetResponse =
        new operations.DirectoryUsersGetResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.user = utils.objectToClass(httpRes?.data, shared.User);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Creates a user.
   */
  directoryUsersInsert(
    req: operations.DirectoryUsersInsertRequest,
    security: operations.DirectoryUsersInsertSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.DirectoryUsersInsertResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DirectoryUsersInsertRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/admin/directory/v1/users";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "userInput",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.DirectoryUsersInsertSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DirectoryUsersInsertResponse =
        new operations.DirectoryUsersInsertResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.user = utils.objectToClass(httpRes?.data, shared.User);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Retrieves a paginated list of either deleted users or all users in a domain.
   */
  directoryUsersList(
    req: operations.DirectoryUsersListRequest,
    security: operations.DirectoryUsersListSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.DirectoryUsersListResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DirectoryUsersListRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/admin/directory/v1/users";
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.DirectoryUsersListSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DirectoryUsersListResponse =
        new operations.DirectoryUsersListResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.users = utils.objectToClass(httpRes?.data, shared.Users);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Makes a user a super administrator.
   */
  directoryUsersMakeAdmin(
    req: operations.DirectoryUsersMakeAdminRequest,
    security: operations.DirectoryUsersMakeAdminSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.DirectoryUsersMakeAdminResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DirectoryUsersMakeAdminRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/admin/directory/v1/users/{userKey}/makeAdmin",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "userMakeAdmin",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.DirectoryUsersMakeAdminSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DirectoryUsersMakeAdminResponse =
        new operations.DirectoryUsersMakeAdminResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          break;
      }

      return res;
    });
  }

  /**
   * Updates a user using patch semantics. The update method should be used instead, because it also supports patch semantics and has better performance. If you're mapping an external identity to a Google identity, use the [`update`](https://developers.google.com/admin-sdk/directory/v1/reference/users/update) method instead of the `patch` method. This method is unable to clear fields that contain repeated objects (`addresses`, `phones`, etc). Use the update method instead.
   */
  directoryUsersPatch(
    req: operations.DirectoryUsersPatchRequest,
    security: operations.DirectoryUsersPatchSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.DirectoryUsersPatchResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DirectoryUsersPatchRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/admin/directory/v1/users/{userKey}",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "userInput",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.DirectoryUsersPatchSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "patch",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DirectoryUsersPatchResponse =
        new operations.DirectoryUsersPatchResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.user = utils.objectToClass(httpRes?.data, shared.User);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Removes the user's photo.
   */
  directoryUsersPhotosDelete(
    req: operations.DirectoryUsersPhotosDeleteRequest,
    security: operations.DirectoryUsersPhotosDeleteSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.DirectoryUsersPhotosDeleteResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DirectoryUsersPhotosDeleteRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/admin/directory/v1/users/{userKey}/photos/thumbnail",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.DirectoryUsersPhotosDeleteSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DirectoryUsersPhotosDeleteResponse =
        new operations.DirectoryUsersPhotosDeleteResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          break;
      }

      return res;
    });
  }

  /**
   * Retrieves the user's photo.
   */
  directoryUsersPhotosGet(
    req: operations.DirectoryUsersPhotosGetRequest,
    security: operations.DirectoryUsersPhotosGetSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.DirectoryUsersPhotosGetResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DirectoryUsersPhotosGetRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/admin/directory/v1/users/{userKey}/photos/thumbnail",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.DirectoryUsersPhotosGetSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DirectoryUsersPhotosGetResponse =
        new operations.DirectoryUsersPhotosGetResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.userPhoto = utils.objectToClass(
              httpRes?.data,
              shared.UserPhoto
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Adds a photo for the user. This method supports [patch semantics](/admin-sdk/directory/v1/guides/performance#patch).
   */
  directoryUsersPhotosPatch(
    req: operations.DirectoryUsersPhotosPatchRequest,
    security: operations.DirectoryUsersPhotosPatchSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.DirectoryUsersPhotosPatchResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DirectoryUsersPhotosPatchRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/admin/directory/v1/users/{userKey}/photos/thumbnail",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "userPhoto",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.DirectoryUsersPhotosPatchSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "patch",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DirectoryUsersPhotosPatchResponse =
        new operations.DirectoryUsersPhotosPatchResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.userPhoto = utils.objectToClass(
              httpRes?.data,
              shared.UserPhoto
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Adds a photo for the user.
   */
  directoryUsersPhotosUpdate(
    req: operations.DirectoryUsersPhotosUpdateRequest,
    security: operations.DirectoryUsersPhotosUpdateSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.DirectoryUsersPhotosUpdateResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DirectoryUsersPhotosUpdateRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/admin/directory/v1/users/{userKey}/photos/thumbnail",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "userPhoto",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.DirectoryUsersPhotosUpdateSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "put",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DirectoryUsersPhotosUpdateResponse =
        new operations.DirectoryUsersPhotosUpdateResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.userPhoto = utils.objectToClass(
              httpRes?.data,
              shared.UserPhoto
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Signs a user out of all web and device sessions and reset their sign-in cookies. User will have to sign in by authenticating again.
   */
  directoryUsersSignOut(
    req: operations.DirectoryUsersSignOutRequest,
    security: operations.DirectoryUsersSignOutSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.DirectoryUsersSignOutResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DirectoryUsersSignOutRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/admin/directory/v1/users/{userKey}/signOut",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.DirectoryUsersSignOutSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "post",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DirectoryUsersSignOutResponse =
        new operations.DirectoryUsersSignOutResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          break;
      }

      return res;
    });
  }

  /**
   * Undeletes a deleted user.
   */
  directoryUsersUndelete(
    req: operations.DirectoryUsersUndeleteRequest,
    security: operations.DirectoryUsersUndeleteSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.DirectoryUsersUndeleteResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DirectoryUsersUndeleteRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/admin/directory/v1/users/{userKey}/undelete",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "userUndelete",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.DirectoryUsersUndeleteSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DirectoryUsersUndeleteResponse =
        new operations.DirectoryUsersUndeleteResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          break;
      }

      return res;
    });
  }

  /**
   * Updates a user. This method supports patch semantics, meaning that you only need to include the fields you wish to update. Fields that are not present in the request will be preserved, and fields set to `null` will be cleared. For repeating fields that contain arrays, individual items in the array can't be patched piecemeal; they must be supplied in the request body with the desired values for all items. See the [user accounts guide](https://developers.google.com/admin-sdk/directory/v1/guides/manage-users#update_user) for more information.
   */
  directoryUsersUpdate(
    req: operations.DirectoryUsersUpdateRequest,
    security: operations.DirectoryUsersUpdateSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.DirectoryUsersUpdateResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DirectoryUsersUpdateRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/admin/directory/v1/users/{userKey}",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "userInput",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.DirectoryUsersUpdateSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "put",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DirectoryUsersUpdateResponse =
        new operations.DirectoryUsersUpdateResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.user = utils.objectToClass(httpRes?.data, shared.User);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Watches for changes in users list.
   */
  directoryUsersWatch(
    req: operations.DirectoryUsersWatchRequest,
    security: operations.DirectoryUsersWatchSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.DirectoryUsersWatchResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DirectoryUsersWatchRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/admin/directory/v1/users/watch";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "channel",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.DirectoryUsersWatchSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DirectoryUsersWatchResponse =
        new operations.DirectoryUsersWatchResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.channel = utils.objectToClass(httpRes?.data, shared.Channel);
          }
          break;
      }

      return res;
    });
  }
}
