// Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.

package operations

import (
	"encoding/json"
	"fmt"
	"net/http"
)

type GetNetworkSwitchAccessPolicyRequest struct {
	AccessPolicyNumber string `pathParam:"style=simple,explode=false,name=accessPolicyNumber"`
	NetworkID          string `pathParam:"style=simple,explode=false,name=networkId"`
}

// GetNetworkSwitchAccessPolicy200ApplicationJSONAccessPolicyTypeEnum - Access Type of the policy. Automatically 'Hybrid authentication' when hostMode is 'Multi-Domain'.
type GetNetworkSwitchAccessPolicy200ApplicationJSONAccessPolicyTypeEnum string

const (
	GetNetworkSwitchAccessPolicy200ApplicationJSONAccessPolicyTypeEnumEightHundredAndTwo1x    GetNetworkSwitchAccessPolicy200ApplicationJSONAccessPolicyTypeEnum = "802.1x"
	GetNetworkSwitchAccessPolicy200ApplicationJSONAccessPolicyTypeEnumHybridAuthentication    GetNetworkSwitchAccessPolicy200ApplicationJSONAccessPolicyTypeEnum = "Hybrid authentication"
	GetNetworkSwitchAccessPolicy200ApplicationJSONAccessPolicyTypeEnumMacAuthenticationBypass GetNetworkSwitchAccessPolicy200ApplicationJSONAccessPolicyTypeEnum = "MAC authentication bypass"
)

func (e *GetNetworkSwitchAccessPolicy200ApplicationJSONAccessPolicyTypeEnum) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return err
	}
	switch s {
	case "802.1x":
		fallthrough
	case "Hybrid authentication":
		fallthrough
	case "MAC authentication bypass":
		*e = GetNetworkSwitchAccessPolicy200ApplicationJSONAccessPolicyTypeEnum(s)
		return nil
	default:
		return fmt.Errorf("invalid value for GetNetworkSwitchAccessPolicy200ApplicationJSONAccessPolicyTypeEnum: %s", s)
	}
}

// GetNetworkSwitchAccessPolicy200ApplicationJSONDot1xControlDirectionEnum - Supports either 'both' or 'inbound'. Set to 'inbound' to allow unauthorized egress on the switchport. Set to 'both' to control both traffic directions with authorization. Defaults to 'both'
type GetNetworkSwitchAccessPolicy200ApplicationJSONDot1xControlDirectionEnum string

const (
	GetNetworkSwitchAccessPolicy200ApplicationJSONDot1xControlDirectionEnumBoth    GetNetworkSwitchAccessPolicy200ApplicationJSONDot1xControlDirectionEnum = "both"
	GetNetworkSwitchAccessPolicy200ApplicationJSONDot1xControlDirectionEnumInbound GetNetworkSwitchAccessPolicy200ApplicationJSONDot1xControlDirectionEnum = "inbound"
)

func (e *GetNetworkSwitchAccessPolicy200ApplicationJSONDot1xControlDirectionEnum) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return err
	}
	switch s {
	case "both":
		fallthrough
	case "inbound":
		*e = GetNetworkSwitchAccessPolicy200ApplicationJSONDot1xControlDirectionEnum(s)
		return nil
	default:
		return fmt.Errorf("invalid value for GetNetworkSwitchAccessPolicy200ApplicationJSONDot1xControlDirectionEnum: %s", s)
	}
}

// GetNetworkSwitchAccessPolicy200ApplicationJSONDot1x - 802.1x Settings
type GetNetworkSwitchAccessPolicy200ApplicationJSONDot1x struct {
	// Supports either 'both' or 'inbound'. Set to 'inbound' to allow unauthorized egress on the switchport. Set to 'both' to control both traffic directions with authorization. Defaults to 'both'
	ControlDirection *GetNetworkSwitchAccessPolicy200ApplicationJSONDot1xControlDirectionEnum `json:"controlDirection,omitempty"`
}

// GetNetworkSwitchAccessPolicy200ApplicationJSONHostModeEnum - Choose the Host Mode for the access policy.
type GetNetworkSwitchAccessPolicy200ApplicationJSONHostModeEnum string

const (
	GetNetworkSwitchAccessPolicy200ApplicationJSONHostModeEnumMultiAuth   GetNetworkSwitchAccessPolicy200ApplicationJSONHostModeEnum = "Multi-Auth"
	GetNetworkSwitchAccessPolicy200ApplicationJSONHostModeEnumMultiDomain GetNetworkSwitchAccessPolicy200ApplicationJSONHostModeEnum = "Multi-Domain"
	GetNetworkSwitchAccessPolicy200ApplicationJSONHostModeEnumMultiHost   GetNetworkSwitchAccessPolicy200ApplicationJSONHostModeEnum = "Multi-Host"
	GetNetworkSwitchAccessPolicy200ApplicationJSONHostModeEnumSingleHost  GetNetworkSwitchAccessPolicy200ApplicationJSONHostModeEnum = "Single-Host"
)

func (e *GetNetworkSwitchAccessPolicy200ApplicationJSONHostModeEnum) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return err
	}
	switch s {
	case "Multi-Auth":
		fallthrough
	case "Multi-Domain":
		fallthrough
	case "Multi-Host":
		fallthrough
	case "Single-Host":
		*e = GetNetworkSwitchAccessPolicy200ApplicationJSONHostModeEnum(s)
		return nil
	default:
		return fmt.Errorf("invalid value for GetNetworkSwitchAccessPolicy200ApplicationJSONHostModeEnum: %s", s)
	}
}

// GetNetworkSwitchAccessPolicy200ApplicationJSONRadiusCriticalAuth - Critical auth settings for when authentication is rejected by the RADIUS server
type GetNetworkSwitchAccessPolicy200ApplicationJSONRadiusCriticalAuth struct {
	// VLAN that clients who use data will be placed on when RADIUS authentication fails. Will be null if hostMode is Multi-Auth
	DataVlanID *int64 `json:"dataVlanId,omitempty"`
	// Enable to suspend port bounce when RADIUS servers are unreachable
	SuspendPortBounce *bool `json:"suspendPortBounce,omitempty"`
	// VLAN that clients who use voice will be placed on when RADIUS authentication fails. Will be null if hostMode is Multi-Auth
	VoiceVlanID *int64 `json:"voiceVlanId,omitempty"`
}

// GetNetworkSwitchAccessPolicy200ApplicationJSONRadius - Object for RADIUS Settings
type GetNetworkSwitchAccessPolicy200ApplicationJSONRadius struct {
	// Critical auth settings for when authentication is rejected by the RADIUS server
	CriticalAuth *GetNetworkSwitchAccessPolicy200ApplicationJSONRadiusCriticalAuth `json:"criticalAuth,omitempty"`
	// VLAN that clients will be placed on when RADIUS authentication fails. Will be null if hostMode is Multi-Auth
	FailedAuthVlanID *int64 `json:"failedAuthVlanId,omitempty"`
	// Re-authentication period in seconds. Will be null if hostMode is Multi-Auth
	ReAuthenticationInterval *int64 `json:"reAuthenticationInterval,omitempty"`
}

type GetNetworkSwitchAccessPolicy200ApplicationJSONRadiusAccountingServers struct {
	// Public IP address of the RADIUS accounting server
	Host *string `json:"host,omitempty"`
	// UDP port that the RADIUS Accounting server listens on for access requests
	Port *int64 `json:"port,omitempty"`
}

type GetNetworkSwitchAccessPolicy200ApplicationJSONRadiusServers struct {
	// Public IP address of the RADIUS server
	Host *string `json:"host,omitempty"`
	// UDP port that the RADIUS server listens on for access requests
	Port *int64 `json:"port,omitempty"`
}

// GetNetworkSwitchAccessPolicy200ApplicationJSON - Successful operation
type GetNetworkSwitchAccessPolicy200ApplicationJSON struct {
	// Access Type of the policy. Automatically 'Hybrid authentication' when hostMode is 'Multi-Domain'.
	AccessPolicyType *GetNetworkSwitchAccessPolicy200ApplicationJSONAccessPolicyTypeEnum `json:"accessPolicyType,omitempty"`
	// 802.1x Settings
	Dot1x *GetNetworkSwitchAccessPolicy200ApplicationJSONDot1x `json:"dot1x,omitempty"`
	// ID for the guest VLAN allow unauthorized devices access to limited network resources
	GuestVlanID *int64 `json:"guestVlanId,omitempty"`
	// Choose the Host Mode for the access policy.
	HostMode *GetNetworkSwitchAccessPolicy200ApplicationJSONHostModeEnum `json:"hostMode,omitempty"`
	// Enabling this option will make switches execute 802.1X and MAC-bypass authentication simultaneously so that clients authenticate faster. Only required when accessPolicyType is 'Hybrid Authentication.
	IncreaseAccessSpeed *bool `json:"increaseAccessSpeed,omitempty"`
	// Name of the access policy
	Name *string `json:"name,omitempty"`
	// Object for RADIUS Settings
	Radius *GetNetworkSwitchAccessPolicy200ApplicationJSONRadius `json:"radius,omitempty"`
	// Enable to send start, interim-update and stop messages to a configured RADIUS accounting server for tracking connected clients
	RadiusAccountingEnabled *bool `json:"radiusAccountingEnabled,omitempty"`
	// List of RADIUS accounting servers to require connecting devices to authenticate against before granting network access
	RadiusAccountingServers []GetNetworkSwitchAccessPolicy200ApplicationJSONRadiusAccountingServers `json:"radiusAccountingServers,omitempty"`
	// Change of authentication for RADIUS re-authentication and disconnection
	RadiusCoaSupportEnabled *bool `json:"radiusCoaSupportEnabled,omitempty"`
	// Acceptable values are `""` for None, or `"11"` for Group Policies ACL
	RadiusGroupAttribute *string `json:"radiusGroupAttribute,omitempty"`
	// List of RADIUS servers to require connecting devices to authenticate against before granting network access
	RadiusServers []GetNetworkSwitchAccessPolicy200ApplicationJSONRadiusServers `json:"radiusServers,omitempty"`
	// If enabled, Meraki devices will periodically send access-request messages to these RADIUS servers
	RadiusTestingEnabled *bool `json:"radiusTestingEnabled,omitempty"`
	// Enable to restrict access for clients to a response_objectific set of IP addresses or hostnames prior to authentication
	URLRedirectWalledGardenEnabled *bool `json:"urlRedirectWalledGardenEnabled,omitempty"`
	// IP address ranges, in CIDR notation, to restrict access for clients to a specific set of IP addresses or hostnames prior to authentication
	URLRedirectWalledGardenRanges []string `json:"urlRedirectWalledGardenRanges,omitempty"`
	// CDP/LLDP capable voice clients will be able to use this VLAN. Automatically true when hostMode is 'Multi-Domain'.
	VoiceVlanClients *bool `json:"voiceVlanClients,omitempty"`
}

type GetNetworkSwitchAccessPolicyResponse struct {
	ContentType string
	StatusCode  int
	RawResponse *http.Response
	// Successful operation
	GetNetworkSwitchAccessPolicy200ApplicationJSONObject *GetNetworkSwitchAccessPolicy200ApplicationJSON
}
