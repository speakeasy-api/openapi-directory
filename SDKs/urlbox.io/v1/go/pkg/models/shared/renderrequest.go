// Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.

package shared

import (
	"bytes"
	"encoding/json"
	"errors"
	"fmt"
)

// RenderRequest2FormatEnum - The format of the rendered output
type RenderRequest2FormatEnum string

const (
	RenderRequest2FormatEnumPng  RenderRequest2FormatEnum = "png"
	RenderRequest2FormatEnumJpg  RenderRequest2FormatEnum = "jpg"
	RenderRequest2FormatEnumPdf  RenderRequest2FormatEnum = "pdf"
	RenderRequest2FormatEnumSvg  RenderRequest2FormatEnum = "svg"
	RenderRequest2FormatEnumMp4  RenderRequest2FormatEnum = "mp4"
	RenderRequest2FormatEnumWebp RenderRequest2FormatEnum = "webp"
	RenderRequest2FormatEnumWebm RenderRequest2FormatEnum = "webm"
	RenderRequest2FormatEnumHTML RenderRequest2FormatEnum = "html"
)

func (e RenderRequest2FormatEnum) ToPointer() *RenderRequest2FormatEnum {
	return &e
}

func (e *RenderRequest2FormatEnum) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "png":
		fallthrough
	case "jpg":
		fallthrough
	case "pdf":
		fallthrough
	case "svg":
		fallthrough
	case "mp4":
		fallthrough
	case "webp":
		fallthrough
	case "webm":
		fallthrough
	case "html":
		*e = RenderRequest2FormatEnum(v)
		return nil
	default:
		return fmt.Errorf("invalid value for RenderRequest2FormatEnum: %v", v)
	}
}

// RenderRequest2WaitUntilEnum - When
type RenderRequest2WaitUntilEnum string

const (
	RenderRequest2WaitUntilEnumRequestsfinished     RenderRequest2WaitUntilEnum = "requestsfinished"
	RenderRequest2WaitUntilEnumMostrequestsfinished RenderRequest2WaitUntilEnum = "mostrequestsfinished"
	RenderRequest2WaitUntilEnumLoaded               RenderRequest2WaitUntilEnum = "loaded"
	RenderRequest2WaitUntilEnumDomloaded            RenderRequest2WaitUntilEnum = "domloaded"
)

func (e RenderRequest2WaitUntilEnum) ToPointer() *RenderRequest2WaitUntilEnum {
	return &e
}

func (e *RenderRequest2WaitUntilEnum) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "requestsfinished":
		fallthrough
	case "mostrequestsfinished":
		fallthrough
	case "loaded":
		fallthrough
	case "domloaded":
		*e = RenderRequest2WaitUntilEnum(v)
		return nil
	default:
		return fmt.Errorf("invalid value for RenderRequest2WaitUntilEnum: %v", v)
	}
}

type RenderRequest2 struct {
	// Whether to block ads on the rendered page
	BlockAds *bool `json:"block_ads,omitempty"`
	// Whether to automatically click accept buttons on the rendered page
	ClickAccept *bool `json:"click_accept,omitempty"`
	// The amount of milliseconds to delay before taking a screenshot
	Delay *string `json:"delay,omitempty"`
	// The format of the rendered output
	Format *RenderRequest2FormatEnum `json:"format,omitempty"`
	// Whether to capture the full page
	FullPage *bool `json:"full_page,omitempty"`
	// Whether to enable GPU rendering
	Gpu *bool `json:"gpu,omitempty"`
	// The viewport height of the rendered output
	Height *int64 `json:"height,omitempty"`
	// Whether to hide cookie banners on the rendered page
	HideCookieBanners *bool `json:"hide_cookie_banners,omitempty"`
	// The raw HTML to render as an image or video
	HTML string `json:"html"`
	// Whether to return metadata about the URL
	Metadata *bool `json:"metadata,omitempty"`
	// Whether to render the image in retina quality
	Retina *bool `json:"retina,omitempty"`
	// The CSS selector of an element you would like to capture
	Selector *string `json:"selector,omitempty"`
	// The height of the thumbnail image
	ThumbHeight *int64 `json:"thumb_height,omitempty"`
	// The width of the thumbnail image
	ThumbWidth *int64 `json:"thumb_width,omitempty"`
	// The URL to render as an image or video
	URL *string `json:"url,omitempty"`
	// CSS selector of an element to wait to be present in the web page before rendering
	WaitFor *string `json:"wait_for,omitempty"`
	// CSS selector of an element, such as a loading spinner, to wait to leave the web page before rendering
	WaitToLeave *string `json:"wait_to_leave,omitempty"`
	// When
	WaitUntil *RenderRequest2WaitUntilEnum `json:"wait_until,omitempty"`
	// The viewport width of the rendered output
	Width *int64 `json:"width,omitempty"`
}

// RenderRequest1FormatEnum - The format of the rendered output
type RenderRequest1FormatEnum string

const (
	RenderRequest1FormatEnumPng  RenderRequest1FormatEnum = "png"
	RenderRequest1FormatEnumJpg  RenderRequest1FormatEnum = "jpg"
	RenderRequest1FormatEnumPdf  RenderRequest1FormatEnum = "pdf"
	RenderRequest1FormatEnumSvg  RenderRequest1FormatEnum = "svg"
	RenderRequest1FormatEnumMp4  RenderRequest1FormatEnum = "mp4"
	RenderRequest1FormatEnumWebp RenderRequest1FormatEnum = "webp"
	RenderRequest1FormatEnumWebm RenderRequest1FormatEnum = "webm"
	RenderRequest1FormatEnumHTML RenderRequest1FormatEnum = "html"
)

func (e RenderRequest1FormatEnum) ToPointer() *RenderRequest1FormatEnum {
	return &e
}

func (e *RenderRequest1FormatEnum) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "png":
		fallthrough
	case "jpg":
		fallthrough
	case "pdf":
		fallthrough
	case "svg":
		fallthrough
	case "mp4":
		fallthrough
	case "webp":
		fallthrough
	case "webm":
		fallthrough
	case "html":
		*e = RenderRequest1FormatEnum(v)
		return nil
	default:
		return fmt.Errorf("invalid value for RenderRequest1FormatEnum: %v", v)
	}
}

// RenderRequest1WaitUntilEnum - When
type RenderRequest1WaitUntilEnum string

const (
	RenderRequest1WaitUntilEnumRequestsfinished     RenderRequest1WaitUntilEnum = "requestsfinished"
	RenderRequest1WaitUntilEnumMostrequestsfinished RenderRequest1WaitUntilEnum = "mostrequestsfinished"
	RenderRequest1WaitUntilEnumLoaded               RenderRequest1WaitUntilEnum = "loaded"
	RenderRequest1WaitUntilEnumDomloaded            RenderRequest1WaitUntilEnum = "domloaded"
)

func (e RenderRequest1WaitUntilEnum) ToPointer() *RenderRequest1WaitUntilEnum {
	return &e
}

func (e *RenderRequest1WaitUntilEnum) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "requestsfinished":
		fallthrough
	case "mostrequestsfinished":
		fallthrough
	case "loaded":
		fallthrough
	case "domloaded":
		*e = RenderRequest1WaitUntilEnum(v)
		return nil
	default:
		return fmt.Errorf("invalid value for RenderRequest1WaitUntilEnum: %v", v)
	}
}

type RenderRequest1 struct {
	// Whether to block ads on the rendered page
	BlockAds *bool `json:"block_ads,omitempty"`
	// Whether to automatically click accept buttons on the rendered page
	ClickAccept *bool `json:"click_accept,omitempty"`
	// The amount of milliseconds to delay before taking a screenshot
	Delay *string `json:"delay,omitempty"`
	// The format of the rendered output
	Format *RenderRequest1FormatEnum `json:"format,omitempty"`
	// Whether to capture the full page
	FullPage *bool `json:"full_page,omitempty"`
	// Whether to enable GPU rendering
	Gpu *bool `json:"gpu,omitempty"`
	// The viewport height of the rendered output
	Height *int64 `json:"height,omitempty"`
	// Whether to hide cookie banners on the rendered page
	HideCookieBanners *bool `json:"hide_cookie_banners,omitempty"`
	// The raw HTML to render as an image or video
	HTML *string `json:"html,omitempty"`
	// Whether to return metadata about the URL
	Metadata *bool `json:"metadata,omitempty"`
	// Whether to render the image in retina quality
	Retina *bool `json:"retina,omitempty"`
	// The CSS selector of an element you would like to capture
	Selector *string `json:"selector,omitempty"`
	// The height of the thumbnail image
	ThumbHeight *int64 `json:"thumb_height,omitempty"`
	// The width of the thumbnail image
	ThumbWidth *int64 `json:"thumb_width,omitempty"`
	// The URL to render as an image or video
	URL string `json:"url"`
	// CSS selector of an element to wait to be present in the web page before rendering
	WaitFor *string `json:"wait_for,omitempty"`
	// CSS selector of an element, such as a loading spinner, to wait to leave the web page before rendering
	WaitToLeave *string `json:"wait_to_leave,omitempty"`
	// When
	WaitUntil *RenderRequest1WaitUntilEnum `json:"wait_until,omitempty"`
	// The viewport width of the rendered output
	Width *int64 `json:"width,omitempty"`
}

type RenderRequestType string

const (
	RenderRequestTypeRenderRequest1 RenderRequestType = "RenderRequest_1"
	RenderRequestTypeRenderRequest2 RenderRequestType = "RenderRequest_2"
)

type RenderRequest struct {
	RenderRequest1 *RenderRequest1
	RenderRequest2 *RenderRequest2

	Type RenderRequestType
}

func CreateRenderRequestRenderRequest1(renderRequest1 RenderRequest1) RenderRequest {
	typ := RenderRequestTypeRenderRequest1

	return RenderRequest{
		RenderRequest1: &renderRequest1,
		Type:           typ,
	}
}

func CreateRenderRequestRenderRequest2(renderRequest2 RenderRequest2) RenderRequest {
	typ := RenderRequestTypeRenderRequest2

	return RenderRequest{
		RenderRequest2: &renderRequest2,
		Type:           typ,
	}
}

func (u *RenderRequest) UnmarshalJSON(data []byte) error {
	var d *json.Decoder

	renderRequest1 := new(RenderRequest1)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&renderRequest1); err == nil {
		u.RenderRequest1 = renderRequest1
		u.Type = RenderRequestTypeRenderRequest1
		return nil
	}

	renderRequest2 := new(RenderRequest2)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&renderRequest2); err == nil {
		u.RenderRequest2 = renderRequest2
		u.Type = RenderRequestTypeRenderRequest2
		return nil
	}

	return errors.New("could not unmarshal into supported union types")
}

func (u RenderRequest) MarshalJSON() ([]byte, error) {
	if u.RenderRequest1 != nil {
		return json.Marshal(u.RenderRequest1)
	}

	if u.RenderRequest2 != nil {
		return json.Marshal(u.RenderRequest2)
	}

	return nil, nil
}
