"""Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT."""

from __future__ import annotations
import dataclasses
import requests as requests_http
from dataclasses_json import Undefined, dataclass_json
from enum import Enum
from sdk import utils
from typing import Optional

class UpdateNetworkApplianceTrafficShapingUplinkSelectionRequestBodyDefaultUplinkEnum(str, Enum):
    r"""The default uplink. Must be one of: 'wan1' or 'wan2'"""
    WAN1 = 'wan1'
    WAN2 = 'wan2'


@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class UpdateNetworkApplianceTrafficShapingUplinkSelectionRequestBodyFailoverAndFailbackImmediate:
    r"""Immediate WAN transition terminates all flows (new and existing) on current WAN when it is deemed unreliable."""
    
    enabled: bool = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('enabled') }})
    r"""Toggle for enabling or disabling immediate WAN failover and failback"""  
    

@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class UpdateNetworkApplianceTrafficShapingUplinkSelectionRequestBodyFailoverAndFailback:
    r"""WAN failover and failback behavior"""
    
    immediate: Optional[UpdateNetworkApplianceTrafficShapingUplinkSelectionRequestBodyFailoverAndFailbackImmediate] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('immediate'), 'exclude': lambda f: f is None }})
    r"""Immediate WAN transition terminates all flows (new and existing) on current WAN when it is deemed unreliable."""  
    
class UpdateNetworkApplianceTrafficShapingUplinkSelectionRequestBodyVpnTrafficUplinkPreferencesFailOverCriterionEnum(str, Enum):
    r"""Fail over criterion for this uplink preference rule. Must be one of: 'poorPerformance' or 'uplinkDown'"""
    POOR_PERFORMANCE = 'poorPerformance'
    UPLINK_DOWN = 'uplinkDown'

class UpdateNetworkApplianceTrafficShapingUplinkSelectionRequestBodyVpnTrafficUplinkPreferencesPerformanceClassBuiltinPerformanceClassNameEnum(str, Enum):
    r"""Name of builtin performance class, must be present when performanceClass type is 'builtin', and value must be one of: 'VoIP'"""
    VO_IP = 'VoIP'

class UpdateNetworkApplianceTrafficShapingUplinkSelectionRequestBodyVpnTrafficUplinkPreferencesPerformanceClassTypeEnum(str, Enum):
    r"""Type of this performance class. Must be one of: 'builtin' or 'custom'"""
    BUILTIN = 'builtin'
    CUSTOM = 'custom'


@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class UpdateNetworkApplianceTrafficShapingUplinkSelectionRequestBodyVpnTrafficUplinkPreferencesPerformanceClass:
    r"""Performance class setting for this uplink preference rule"""
    
    type: UpdateNetworkApplianceTrafficShapingUplinkSelectionRequestBodyVpnTrafficUplinkPreferencesPerformanceClassTypeEnum = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('type') }})
    r"""Type of this performance class. Must be one of: 'builtin' or 'custom'"""  
    builtin_performance_class_name: Optional[UpdateNetworkApplianceTrafficShapingUplinkSelectionRequestBodyVpnTrafficUplinkPreferencesPerformanceClassBuiltinPerformanceClassNameEnum] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('builtinPerformanceClassName'), 'exclude': lambda f: f is None }})
    r"""Name of builtin performance class, must be present when performanceClass type is 'builtin', and value must be one of: 'VoIP'"""  
    custom_performance_class_id: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('customPerformanceClassId'), 'exclude': lambda f: f is None }})
    r"""ID of created custom performance class, must be present when performanceClass type is 'custom'"""  
    
class UpdateNetworkApplianceTrafficShapingUplinkSelectionRequestBodyVpnTrafficUplinkPreferencesPreferredUplinkEnum(str, Enum):
    r"""Preferred uplink for this uplink preference rule. Must be one of: 'wan1', 'wan2', 'bestForVoIP', 'loadBalancing' or 'defaultUplink'"""
    BEST_FOR_VO_IP = 'bestForVoIP'
    DEFAULT_UPLINK = 'defaultUplink'
    LOAD_BALANCING = 'loadBalancing'
    WAN1 = 'wan1'
    WAN2 = 'wan2'

class UpdateNetworkApplianceTrafficShapingUplinkSelectionRequestBodyVpnTrafficUplinkPreferencesTrafficFiltersTypeEnum(str, Enum):
    r"""Type of this traffic filter. Must be one of: 'applicationCategory', 'application' or 'custom'"""
    APPLICATION = 'application'
    APPLICATION_CATEGORY = 'applicationCategory'
    CUSTOM = 'custom'


@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class UpdateNetworkApplianceTrafficShapingUplinkSelectionRequestBodyVpnTrafficUplinkPreferencesTrafficFiltersValueDestination:
    r"""Destination of this custom type traffic filter"""
    
    cidr: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('cidr'), 'exclude': lambda f: f is None }})
    r"""CIDR format address, or \\"any\\". E.g.: \\"192.168.10.0/24\\",  \\"192.168.10.1\\" (same as \\"192.168.10.1/32\\"), \\"0.0.0.0/0\\" (same as \\"any\\")"""  
    fqdn: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('fqdn'), 'exclude': lambda f: f is None }})
    r"""FQDN format address. Currently only availabe in 'destination' of 'vpnTrafficUplinkPreference' object. E.g.: 'www.google.com'"""  
    host: Optional[int] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('host'), 'exclude': lambda f: f is None }})
    r"""Host ID in the VLAN, should be used along with 'vlan', and not exceed the vlan subnet capacity. Currently only available under a template network."""  
    network: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('network'), 'exclude': lambda f: f is None }})
    r"""Meraki network ID. Currently only available under a template network, and the value should be ID of either same template network, or another template network currently. E.g.: \\"L_12345678\\"."""  
    port: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('port'), 'exclude': lambda f: f is None }})
    r"""E.g.: \\"any\\", \\"0\\" (also means \\"any\\"), \\"8080\\", \\"1-1024\\" """  
    vlan: Optional[int] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('vlan'), 'exclude': lambda f: f is None }})
    r"""VLAN ID of the configured VLAN in the Meraki network. Currently only available under a template network."""  
    
class UpdateNetworkApplianceTrafficShapingUplinkSelectionRequestBodyVpnTrafficUplinkPreferencesTrafficFiltersValueProtocolEnum(str, Enum):
    r"""Protocol of this custom type traffic filter. Must be one of: 'tcp', 'udp', 'icmp', 'icmp6' or 'any'"""
    ANY = 'any'
    ICMP = 'icmp'
    ICMP6 = 'icmp6'
    TCP = 'tcp'
    UDP = 'udp'


@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class UpdateNetworkApplianceTrafficShapingUplinkSelectionRequestBodyVpnTrafficUplinkPreferencesTrafficFiltersValueSource:
    r"""Source of this custom type traffic filter"""
    
    cidr: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('cidr'), 'exclude': lambda f: f is None }})
    r"""CIDR format address, or \\"any\\". E.g.: \\"192.168.10.0/24\\",  \\"192.168.10.1\\" (same as \\"192.168.10.1/32\\"), \\"0.0.0.0/0\\" (same as \\"any\\")"""  
    host: Optional[int] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('host'), 'exclude': lambda f: f is None }})
    r"""Host ID in the VLAN, should be used along with 'vlan', and not exceed the vlan subnet capacity. Currently only available under a template network."""  
    network: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('network'), 'exclude': lambda f: f is None }})
    r"""Meraki network ID. Currently only available under a template network, and the value should be ID of either same template network, or another template network currently. E.g.: \\"L_12345678\\"."""  
    port: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('port'), 'exclude': lambda f: f is None }})
    r"""E.g.: \\"any\\", \\"0\\" (also means \\"any\\"), \\"8080\\", \\"1-1024\\" """  
    vlan: Optional[int] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('vlan'), 'exclude': lambda f: f is None }})
    r"""VLAN ID of the configured VLAN in the Meraki network. Currently only available under a template network."""  
    

@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class UpdateNetworkApplianceTrafficShapingUplinkSelectionRequestBodyVpnTrafficUplinkPreferencesTrafficFiltersValue:
    r"""Value object of this traffic filter"""
    
    destination: Optional[UpdateNetworkApplianceTrafficShapingUplinkSelectionRequestBodyVpnTrafficUplinkPreferencesTrafficFiltersValueDestination] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('destination'), 'exclude': lambda f: f is None }})
    r"""Destination of this custom type traffic filter"""  
    id: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('id'), 'exclude': lambda f: f is None }})
    r"""ID of this applicationCategory or application type traffic filter. E.g.: \\"meraki:layer7/category/1\\", \\"meraki:layer7/application/4\\" """  
    protocol: Optional[UpdateNetworkApplianceTrafficShapingUplinkSelectionRequestBodyVpnTrafficUplinkPreferencesTrafficFiltersValueProtocolEnum] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('protocol'), 'exclude': lambda f: f is None }})
    r"""Protocol of this custom type traffic filter. Must be one of: 'tcp', 'udp', 'icmp', 'icmp6' or 'any'"""  
    source: Optional[UpdateNetworkApplianceTrafficShapingUplinkSelectionRequestBodyVpnTrafficUplinkPreferencesTrafficFiltersValueSource] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('source'), 'exclude': lambda f: f is None }})
    r"""Source of this custom type traffic filter"""  
    

@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class UpdateNetworkApplianceTrafficShapingUplinkSelectionRequestBodyVpnTrafficUplinkPreferencesTrafficFilters:
    
    type: UpdateNetworkApplianceTrafficShapingUplinkSelectionRequestBodyVpnTrafficUplinkPreferencesTrafficFiltersTypeEnum = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('type') }})
    r"""Type of this traffic filter. Must be one of: 'applicationCategory', 'application' or 'custom'"""  
    value: UpdateNetworkApplianceTrafficShapingUplinkSelectionRequestBodyVpnTrafficUplinkPreferencesTrafficFiltersValue = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('value') }})
    r"""Value object of this traffic filter"""  
    

@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class UpdateNetworkApplianceTrafficShapingUplinkSelectionRequestBodyVpnTrafficUplinkPreferences:
    
    preferred_uplink: UpdateNetworkApplianceTrafficShapingUplinkSelectionRequestBodyVpnTrafficUplinkPreferencesPreferredUplinkEnum = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('preferredUplink') }})
    r"""Preferred uplink for this uplink preference rule. Must be one of: 'wan1', 'wan2', 'bestForVoIP', 'loadBalancing' or 'defaultUplink'"""  
    traffic_filters: list[UpdateNetworkApplianceTrafficShapingUplinkSelectionRequestBodyVpnTrafficUplinkPreferencesTrafficFilters] = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('trafficFilters') }})
    r"""Array of traffic filters for this uplink preference rule"""  
    fail_over_criterion: Optional[UpdateNetworkApplianceTrafficShapingUplinkSelectionRequestBodyVpnTrafficUplinkPreferencesFailOverCriterionEnum] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('failOverCriterion'), 'exclude': lambda f: f is None }})
    r"""Fail over criterion for this uplink preference rule. Must be one of: 'poorPerformance' or 'uplinkDown'"""  
    performance_class: Optional[UpdateNetworkApplianceTrafficShapingUplinkSelectionRequestBodyVpnTrafficUplinkPreferencesPerformanceClass] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('performanceClass'), 'exclude': lambda f: f is None }})
    r"""Performance class setting for this uplink preference rule"""  
    
class UpdateNetworkApplianceTrafficShapingUplinkSelectionRequestBodyWanTrafficUplinkPreferencesPreferredUplinkEnum(str, Enum):
    r"""Preferred uplink for this uplink preference rule. Must be one of: 'wan1' or 'wan2'"""
    WAN1 = 'wan1'
    WAN2 = 'wan2'

class UpdateNetworkApplianceTrafficShapingUplinkSelectionRequestBodyWanTrafficUplinkPreferencesTrafficFiltersTypeEnum(str, Enum):
    r"""Type of this traffic filter. Must be one of: 'custom'"""
    CUSTOM = 'custom'


@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class UpdateNetworkApplianceTrafficShapingUplinkSelectionRequestBodyWanTrafficUplinkPreferencesTrafficFiltersValueDestination:
    r"""Destination of this custom type traffic filter"""
    
    cidr: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('cidr'), 'exclude': lambda f: f is None }})
    r"""CIDR format address, or \\"any\\". E.g.: \\"192.168.10.0/24\\",  \\"192.168.10.1\\" (same as \\"192.168.10.1/32\\"), \\"0.0.0.0/0\\" (same as \\"any\\")"""  
    port: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('port'), 'exclude': lambda f: f is None }})
    r"""E.g.: \\"any\\", \\"0\\" (also means \\"any\\"), \\"8080\\", \\"1-1024\\" """  
    
class UpdateNetworkApplianceTrafficShapingUplinkSelectionRequestBodyWanTrafficUplinkPreferencesTrafficFiltersValueProtocolEnum(str, Enum):
    r"""Protocol of this custom type traffic filter. Must be one of: 'tcp', 'udp', 'icmp6' or 'any'"""
    ANY = 'any'
    ICMP6 = 'icmp6'
    TCP = 'tcp'
    UDP = 'udp'


@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class UpdateNetworkApplianceTrafficShapingUplinkSelectionRequestBodyWanTrafficUplinkPreferencesTrafficFiltersValueSource:
    r"""Source of this custom type traffic filter"""
    
    cidr: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('cidr'), 'exclude': lambda f: f is None }})
    r"""CIDR format address, or \\"any\\". E.g.: \\"192.168.10.0/24\\",  \\"192.168.10.1\\" (same as \\"192.168.10.1/32\\"), \\"0.0.0.0/0\\" (same as \\"any\\")"""  
    host: Optional[int] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('host'), 'exclude': lambda f: f is None }})
    r"""Host ID in the VLAN, should be used along with 'vlan', and not exceed the vlan subnet capacity. Currently only available under a template network."""  
    port: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('port'), 'exclude': lambda f: f is None }})
    r"""E.g.: \\"any\\", \\"0\\" (also means \\"any\\"), \\"8080\\", \\"1-1024\\" """  
    vlan: Optional[int] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('vlan'), 'exclude': lambda f: f is None }})
    r"""VLAN ID of the configured VLAN in the Meraki network. Currently only available under a template network."""  
    

@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class UpdateNetworkApplianceTrafficShapingUplinkSelectionRequestBodyWanTrafficUplinkPreferencesTrafficFiltersValue:
    r"""Value object of this traffic filter"""
    
    destination: UpdateNetworkApplianceTrafficShapingUplinkSelectionRequestBodyWanTrafficUplinkPreferencesTrafficFiltersValueDestination = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('destination') }})
    r"""Destination of this custom type traffic filter"""  
    source: UpdateNetworkApplianceTrafficShapingUplinkSelectionRequestBodyWanTrafficUplinkPreferencesTrafficFiltersValueSource = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('source') }})
    r"""Source of this custom type traffic filter"""  
    protocol: Optional[UpdateNetworkApplianceTrafficShapingUplinkSelectionRequestBodyWanTrafficUplinkPreferencesTrafficFiltersValueProtocolEnum] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('protocol'), 'exclude': lambda f: f is None }})
    r"""Protocol of this custom type traffic filter. Must be one of: 'tcp', 'udp', 'icmp6' or 'any'"""  
    

@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class UpdateNetworkApplianceTrafficShapingUplinkSelectionRequestBodyWanTrafficUplinkPreferencesTrafficFilters:
    
    type: UpdateNetworkApplianceTrafficShapingUplinkSelectionRequestBodyWanTrafficUplinkPreferencesTrafficFiltersTypeEnum = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('type') }})
    r"""Type of this traffic filter. Must be one of: 'custom'"""  
    value: UpdateNetworkApplianceTrafficShapingUplinkSelectionRequestBodyWanTrafficUplinkPreferencesTrafficFiltersValue = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('value') }})
    r"""Value object of this traffic filter"""  
    

@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class UpdateNetworkApplianceTrafficShapingUplinkSelectionRequestBodyWanTrafficUplinkPreferences:
    
    preferred_uplink: UpdateNetworkApplianceTrafficShapingUplinkSelectionRequestBodyWanTrafficUplinkPreferencesPreferredUplinkEnum = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('preferredUplink') }})
    r"""Preferred uplink for this uplink preference rule. Must be one of: 'wan1' or 'wan2'"""  
    traffic_filters: list[UpdateNetworkApplianceTrafficShapingUplinkSelectionRequestBodyWanTrafficUplinkPreferencesTrafficFilters] = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('trafficFilters') }})
    r"""Array of traffic filters for this uplink preference rule"""  
    

@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class UpdateNetworkApplianceTrafficShapingUplinkSelectionRequestBody:
    
    active_active_auto_vpn_enabled: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('activeActiveAutoVpnEnabled'), 'exclude': lambda f: f is None }})
    r"""Toggle for enabling or disabling active-active AutoVPN"""  
    default_uplink: Optional[UpdateNetworkApplianceTrafficShapingUplinkSelectionRequestBodyDefaultUplinkEnum] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('defaultUplink'), 'exclude': lambda f: f is None }})
    r"""The default uplink. Must be one of: 'wan1' or 'wan2'"""  
    failover_and_failback: Optional[UpdateNetworkApplianceTrafficShapingUplinkSelectionRequestBodyFailoverAndFailback] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('failoverAndFailback'), 'exclude': lambda f: f is None }})
    r"""WAN failover and failback behavior"""  
    load_balancing_enabled: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('loadBalancingEnabled'), 'exclude': lambda f: f is None }})
    r"""Toggle for enabling or disabling load balancing"""  
    vpn_traffic_uplink_preferences: Optional[list[UpdateNetworkApplianceTrafficShapingUplinkSelectionRequestBodyVpnTrafficUplinkPreferences]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('vpnTrafficUplinkPreferences'), 'exclude': lambda f: f is None }})
    r"""Array of uplink preference rules for VPN traffic"""  
    wan_traffic_uplink_preferences: Optional[list[UpdateNetworkApplianceTrafficShapingUplinkSelectionRequestBodyWanTrafficUplinkPreferences]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('wanTrafficUplinkPreferences'), 'exclude': lambda f: f is None }})
    r"""Array of uplink preference rules for WAN traffic"""  
    

@dataclasses.dataclass
class UpdateNetworkApplianceTrafficShapingUplinkSelectionRequest:
    
    network_id: str = dataclasses.field(metadata={'path_param': { 'field_name': 'networkId', 'style': 'simple', 'explode': False }})  
    request_body: Optional[UpdateNetworkApplianceTrafficShapingUplinkSelectionRequestBody] = dataclasses.field(default=None, metadata={'request': { 'media_type': 'application/json' }})  
    
class UpdateNetworkApplianceTrafficShapingUplinkSelection200ApplicationJSONDefaultUplinkEnum(str, Enum):
    r"""The default uplink. Must be one of: 'wan1' or 'wan2'"""
    WAN1 = 'wan1'
    WAN2 = 'wan2'


@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class UpdateNetworkApplianceTrafficShapingUplinkSelection200ApplicationJSONFailoverAndFailbackImmediate:
    r"""Immediate WAN failover and failback"""
    
    enabled: bool = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('enabled') }})
    r"""Whether immediate WAN failover and failback is enabled"""  
    

@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class UpdateNetworkApplianceTrafficShapingUplinkSelection200ApplicationJSONFailoverAndFailback:
    r"""WAN failover and failback"""
    
    immediate: Optional[UpdateNetworkApplianceTrafficShapingUplinkSelection200ApplicationJSONFailoverAndFailbackImmediate] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('immediate'), 'exclude': lambda f: f is None }})
    r"""Immediate WAN failover and failback"""  
    
class UpdateNetworkApplianceTrafficShapingUplinkSelection200ApplicationJSONVpnTrafficUplinkPreferencesFailOverCriterionEnum(str, Enum):
    r"""Fail over criterion for uplink preference rule. Must be one of: 'poorPerformance' or 'uplinkDown'"""
    POOR_PERFORMANCE = 'poorPerformance'
    UPLINK_DOWN = 'uplinkDown'

class UpdateNetworkApplianceTrafficShapingUplinkSelection200ApplicationJSONVpnTrafficUplinkPreferencesPerformanceClassBuiltinPerformanceClassNameEnum(str, Enum):
    r"""Name of builtin performance class. Must be present when performanceClass type is 'builtin' and value must be one of: 'VoIP'"""
    VO_IP = 'VoIP'

class UpdateNetworkApplianceTrafficShapingUplinkSelection200ApplicationJSONVpnTrafficUplinkPreferencesPerformanceClassTypeEnum(str, Enum):
    r"""Type of this performance class. Must be one of: 'builtin' or 'custom'"""
    BUILTIN = 'builtin'
    CUSTOM = 'custom'


@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class UpdateNetworkApplianceTrafficShapingUplinkSelection200ApplicationJSONVpnTrafficUplinkPreferencesPerformanceClass:
    r"""Performance class setting for uplink preference rule"""
    
    type: UpdateNetworkApplianceTrafficShapingUplinkSelection200ApplicationJSONVpnTrafficUplinkPreferencesPerformanceClassTypeEnum = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('type') }})
    r"""Type of this performance class. Must be one of: 'builtin' or 'custom'"""  
    builtin_performance_class_name: Optional[UpdateNetworkApplianceTrafficShapingUplinkSelection200ApplicationJSONVpnTrafficUplinkPreferencesPerformanceClassBuiltinPerformanceClassNameEnum] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('builtinPerformanceClassName'), 'exclude': lambda f: f is None }})
    r"""Name of builtin performance class. Must be present when performanceClass type is 'builtin' and value must be one of: 'VoIP'"""  
    custom_performance_class_id: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('customPerformanceClassId'), 'exclude': lambda f: f is None }})
    r"""ID of created custom performance class, must be present when performanceClass type is \\"custom\\" """  
    
class UpdateNetworkApplianceTrafficShapingUplinkSelection200ApplicationJSONVpnTrafficUplinkPreferencesPreferredUplinkEnum(str, Enum):
    r"""Preferred uplink for uplink preference rule. Must be one of: 'wan1', 'wan2', 'bestForVoIP', 'loadBalancing' or 'defaultUplink'"""
    BEST_FOR_VO_IP = 'bestForVoIP'
    DEFAULT_UPLINK = 'defaultUplink'
    LOAD_BALANCING = 'loadBalancing'
    WAN1 = 'wan1'
    WAN2 = 'wan2'

class UpdateNetworkApplianceTrafficShapingUplinkSelection200ApplicationJSONVpnTrafficUplinkPreferencesTrafficFiltersTypeEnum(str, Enum):
    r"""Traffic filter type. Must be one of: 'applicationCategory', 'application' or 'custom'"""
    APPLICATION = 'application'
    APPLICATION_CATEGORY = 'applicationCategory'
    CUSTOM = 'custom'


@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class UpdateNetworkApplianceTrafficShapingUplinkSelection200ApplicationJSONVpnTrafficUplinkPreferencesTrafficFiltersValueDestination:
    r"""Destination of 'custom' type traffic filter"""
    
    cidr: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('cidr'), 'exclude': lambda f: f is None }})
    r"""CIDR format address (e.g.\\"192.168.10.1\\", which is the same as \\"192.168.10.1/32\\"), or \\"any\\". Cannot be used in combination with the \\"vlan\\" or \\"fqdn\\" property"""  
    fqdn: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('fqdn'), 'exclude': lambda f: f is None }})
    r"""FQDN format address. Cannot be used in combination with the \\"cidr\\" or \\"fqdn\\" property and is currently only available in the \\"destination\\" object of the \\"vpnTrafficUplinkPreference\\" object. E.g.: \\"www.google.com\\" """  
    host: Optional[int] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('host'), 'exclude': lambda f: f is None }})
    r"""Host ID in the VLAN. Should not exceed the VLAN subnet capacity. Must be used along with the \\"vlan\\" property and is currently only available under a template network."""  
    network: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('network'), 'exclude': lambda f: f is None }})
    r"""Meraki network ID. Currently only available under a template network, and the value should be ID of either same template network, or another template network currently. E.g.: \\"L_12345678\\"."""  
    port: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('port'), 'exclude': lambda f: f is None }})
    r"""E.g.: \\"any\\", \\"0\\" (also means \\"any\\"), \\"8080\\", \\"1-1024\\" """  
    vlan: Optional[int] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('vlan'), 'exclude': lambda f: f is None }})
    r"""VLAN ID of the configured VLAN in the Meraki network. Cannot be used in combination with the \\"cidr\\" or \\"fqdn\\" property and is currently only available under a template network."""  
    
class UpdateNetworkApplianceTrafficShapingUplinkSelection200ApplicationJSONVpnTrafficUplinkPreferencesTrafficFiltersValueProtocolEnum(str, Enum):
    r"""Protocol of 'custom' type traffic filter. Must be one of: 'tcp', 'udp', 'icmp', 'icmp6' or 'any'"""
    ANY = 'any'
    ICMP = 'icmp'
    ICMP6 = 'icmp6'
    TCP = 'tcp'
    UDP = 'udp'


@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class UpdateNetworkApplianceTrafficShapingUplinkSelection200ApplicationJSONVpnTrafficUplinkPreferencesTrafficFiltersValueSource:
    r"""Source of 'custom' type traffic filter"""
    
    cidr: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('cidr'), 'exclude': lambda f: f is None }})
    r"""CIDR format address (e.g.\\"192.168.10.1\\", which is the same as \\"192.168.10.1/32\\"), or \\"any\\". Cannot be used in combination with the \\"vlan\\" property"""  
    host: Optional[int] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('host'), 'exclude': lambda f: f is None }})
    r"""Host ID in the VLAN. Should not exceed the VLAN subnet capacity. Must be used along with the \\"vlan\\" property and is currently only available under a template network."""  
    network: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('network'), 'exclude': lambda f: f is None }})
    r"""Meraki network ID. Currently only available under a template network, and the value should be ID of either same template network, or another template network currently. E.g.: \\"L_12345678\\"."""  
    port: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('port'), 'exclude': lambda f: f is None }})
    r"""E.g.: \\"any\\", \\"0\\" (also means \\"any\\"), \\"8080\\", \\"1-1024\\" """  
    vlan: Optional[int] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('vlan'), 'exclude': lambda f: f is None }})
    r"""VLAN ID of the configured VLAN in the Meraki network. Cannot be used in combination with the \\"cidr\\" property and is currently only available under a template network."""  
    

@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class UpdateNetworkApplianceTrafficShapingUplinkSelection200ApplicationJSONVpnTrafficUplinkPreferencesTrafficFiltersValue:
    r"""Value of traffic filter"""
    
    destination: Optional[UpdateNetworkApplianceTrafficShapingUplinkSelection200ApplicationJSONVpnTrafficUplinkPreferencesTrafficFiltersValueDestination] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('destination'), 'exclude': lambda f: f is None }})
    r"""Destination of 'custom' type traffic filter"""  
    id: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('id'), 'exclude': lambda f: f is None }})
    r"""ID of 'applicationCategory' or 'application' type traffic filter"""  
    protocol: Optional[UpdateNetworkApplianceTrafficShapingUplinkSelection200ApplicationJSONVpnTrafficUplinkPreferencesTrafficFiltersValueProtocolEnum] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('protocol'), 'exclude': lambda f: f is None }})
    r"""Protocol of 'custom' type traffic filter. Must be one of: 'tcp', 'udp', 'icmp', 'icmp6' or 'any'"""  
    source: Optional[UpdateNetworkApplianceTrafficShapingUplinkSelection200ApplicationJSONVpnTrafficUplinkPreferencesTrafficFiltersValueSource] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('source'), 'exclude': lambda f: f is None }})
    r"""Source of 'custom' type traffic filter"""  
    

@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class UpdateNetworkApplianceTrafficShapingUplinkSelection200ApplicationJSONVpnTrafficUplinkPreferencesTrafficFilters:
    
    type: UpdateNetworkApplianceTrafficShapingUplinkSelection200ApplicationJSONVpnTrafficUplinkPreferencesTrafficFiltersTypeEnum = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('type') }})
    r"""Traffic filter type. Must be one of: 'applicationCategory', 'application' or 'custom'"""  
    value: UpdateNetworkApplianceTrafficShapingUplinkSelection200ApplicationJSONVpnTrafficUplinkPreferencesTrafficFiltersValue = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('value') }})
    r"""Value of traffic filter"""  
    

@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class UpdateNetworkApplianceTrafficShapingUplinkSelection200ApplicationJSONVpnTrafficUplinkPreferences:
    
    preferred_uplink: UpdateNetworkApplianceTrafficShapingUplinkSelection200ApplicationJSONVpnTrafficUplinkPreferencesPreferredUplinkEnum = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('preferredUplink') }})
    r"""Preferred uplink for uplink preference rule. Must be one of: 'wan1', 'wan2', 'bestForVoIP', 'loadBalancing' or 'defaultUplink'"""  
    traffic_filters: list[UpdateNetworkApplianceTrafficShapingUplinkSelection200ApplicationJSONVpnTrafficUplinkPreferencesTrafficFilters] = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('trafficFilters') }})
    r"""Traffic filters"""  
    fail_over_criterion: Optional[UpdateNetworkApplianceTrafficShapingUplinkSelection200ApplicationJSONVpnTrafficUplinkPreferencesFailOverCriterionEnum] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('failOverCriterion'), 'exclude': lambda f: f is None }})
    r"""Fail over criterion for uplink preference rule. Must be one of: 'poorPerformance' or 'uplinkDown'"""  
    performance_class: Optional[UpdateNetworkApplianceTrafficShapingUplinkSelection200ApplicationJSONVpnTrafficUplinkPreferencesPerformanceClass] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('performanceClass'), 'exclude': lambda f: f is None }})
    r"""Performance class setting for uplink preference rule"""  
    
class UpdateNetworkApplianceTrafficShapingUplinkSelection200ApplicationJSONWanTrafficUplinkPreferencesPreferredUplinkEnum(str, Enum):
    r"""Preferred uplink for uplink preference rule. Must be one of: 'wan1' or 'wan2'"""
    WAN1 = 'wan1'
    WAN2 = 'wan2'

class UpdateNetworkApplianceTrafficShapingUplinkSelection200ApplicationJSONWanTrafficUplinkPreferencesTrafficFiltersTypeEnum(str, Enum):
    r"""Traffic filter type. Must be \\"custom\\" """
    CUSTOM = 'custom'


@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class UpdateNetworkApplianceTrafficShapingUplinkSelection200ApplicationJSONWanTrafficUplinkPreferencesTrafficFiltersValueDestination:
    r"""Destination of 'custom' type traffic filter"""
    
    cidr: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('cidr'), 'exclude': lambda f: f is None }})
    r"""CIDR format address (e.g.\\"192.168.10.1\\", which is the same as \\"192.168.10.1/32\\"), or \\"any\\" """  
    port: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('port'), 'exclude': lambda f: f is None }})
    r"""E.g.: \\"any\\", \\"0\\" (also means \\"any\\"), \\"8080\\", \\"1-1024\\" """  
    
class UpdateNetworkApplianceTrafficShapingUplinkSelection200ApplicationJSONWanTrafficUplinkPreferencesTrafficFiltersValueProtocolEnum(str, Enum):
    r"""Protocol of 'custom' type traffic filter. Must be one of: 'tcp', 'udp', 'icmp6' or 'any'"""
    ANY = 'any'
    ICMP6 = 'icmp6'
    TCP = 'tcp'
    UDP = 'udp'


@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class UpdateNetworkApplianceTrafficShapingUplinkSelection200ApplicationJSONWanTrafficUplinkPreferencesTrafficFiltersValueSource:
    r"""Source of 'custom' type traffic filter"""
    
    cidr: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('cidr'), 'exclude': lambda f: f is None }})
    r"""CIDR format address (e.g.\\"192.168.10.1\\", which is the same as \\"192.168.10.1/32\\"), or \\"any\\". Cannot be used in combination with the \\"vlan\\" property"""  
    host: Optional[int] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('host'), 'exclude': lambda f: f is None }})
    r"""Host ID in the VLAN. Should not exceed the VLAN subnet capacity. Must be used along with the \\"vlan\\" property and is currently only available under a template network."""  
    port: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('port'), 'exclude': lambda f: f is None }})
    r"""E.g.: \\"any\\", \\"0\\" (also means \\"any\\"), \\"8080\\", \\"1-1024\\" """  
    vlan: Optional[int] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('vlan'), 'exclude': lambda f: f is None }})
    r"""VLAN ID of the configured VLAN in the Meraki network. Cannot be used in combination with the \\"cidr\\" property and is currently only available under a template network."""  
    

@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class UpdateNetworkApplianceTrafficShapingUplinkSelection200ApplicationJSONWanTrafficUplinkPreferencesTrafficFiltersValue:
    r"""Value of traffic filter"""
    
    destination: UpdateNetworkApplianceTrafficShapingUplinkSelection200ApplicationJSONWanTrafficUplinkPreferencesTrafficFiltersValueDestination = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('destination') }})
    r"""Destination of 'custom' type traffic filter"""  
    source: UpdateNetworkApplianceTrafficShapingUplinkSelection200ApplicationJSONWanTrafficUplinkPreferencesTrafficFiltersValueSource = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('source') }})
    r"""Source of 'custom' type traffic filter"""  
    protocol: Optional[UpdateNetworkApplianceTrafficShapingUplinkSelection200ApplicationJSONWanTrafficUplinkPreferencesTrafficFiltersValueProtocolEnum] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('protocol'), 'exclude': lambda f: f is None }})
    r"""Protocol of 'custom' type traffic filter. Must be one of: 'tcp', 'udp', 'icmp6' or 'any'"""  
    

@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class UpdateNetworkApplianceTrafficShapingUplinkSelection200ApplicationJSONWanTrafficUplinkPreferencesTrafficFilters:
    
    type: UpdateNetworkApplianceTrafficShapingUplinkSelection200ApplicationJSONWanTrafficUplinkPreferencesTrafficFiltersTypeEnum = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('type') }})
    r"""Traffic filter type. Must be \\"custom\\" """  
    value: UpdateNetworkApplianceTrafficShapingUplinkSelection200ApplicationJSONWanTrafficUplinkPreferencesTrafficFiltersValue = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('value') }})
    r"""Value of traffic filter"""  
    

@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class UpdateNetworkApplianceTrafficShapingUplinkSelection200ApplicationJSONWanTrafficUplinkPreferences:
    
    preferred_uplink: UpdateNetworkApplianceTrafficShapingUplinkSelection200ApplicationJSONWanTrafficUplinkPreferencesPreferredUplinkEnum = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('preferredUplink') }})
    r"""Preferred uplink for uplink preference rule. Must be one of: 'wan1' or 'wan2'"""  
    traffic_filters: list[UpdateNetworkApplianceTrafficShapingUplinkSelection200ApplicationJSONWanTrafficUplinkPreferencesTrafficFilters] = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('trafficFilters') }})
    r"""Traffic filters"""  
    

@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class UpdateNetworkApplianceTrafficShapingUplinkSelection200ApplicationJSON:
    r"""Successful operation"""
    
    active_active_auto_vpn_enabled: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('activeActiveAutoVpnEnabled'), 'exclude': lambda f: f is None }})
    r"""Whether active-active AutoVPN is enabled"""  
    default_uplink: Optional[UpdateNetworkApplianceTrafficShapingUplinkSelection200ApplicationJSONDefaultUplinkEnum] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('defaultUplink'), 'exclude': lambda f: f is None }})
    r"""The default uplink. Must be one of: 'wan1' or 'wan2'"""  
    failover_and_failback: Optional[UpdateNetworkApplianceTrafficShapingUplinkSelection200ApplicationJSONFailoverAndFailback] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('failoverAndFailback'), 'exclude': lambda f: f is None }})
    r"""WAN failover and failback"""  
    load_balancing_enabled: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('loadBalancingEnabled'), 'exclude': lambda f: f is None }})
    r"""Whether load balancing is enabled"""  
    vpn_traffic_uplink_preferences: Optional[list[UpdateNetworkApplianceTrafficShapingUplinkSelection200ApplicationJSONVpnTrafficUplinkPreferences]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('vpnTrafficUplinkPreferences'), 'exclude': lambda f: f is None }})
    r"""Uplink preference rules for VPN traffic"""  
    wan_traffic_uplink_preferences: Optional[list[UpdateNetworkApplianceTrafficShapingUplinkSelection200ApplicationJSONWanTrafficUplinkPreferences]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('wanTrafficUplinkPreferences'), 'exclude': lambda f: f is None }})
    r"""Uplink preference rules for WAN traffic"""  
    

@dataclasses.dataclass
class UpdateNetworkApplianceTrafficShapingUplinkSelectionResponse:
    
    content_type: str = dataclasses.field()  
    status_code: int = dataclasses.field()  
    raw_response: Optional[requests_http.Response] = dataclasses.field(default=None)  
    update_network_appliance_traffic_shaping_uplink_selection_200_application_json_object: Optional[UpdateNetworkApplianceTrafficShapingUplinkSelection200ApplicationJSON] = dataclasses.field(default=None)
    r"""Successful operation"""  
    