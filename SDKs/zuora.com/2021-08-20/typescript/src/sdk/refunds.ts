/*
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

import * as utils from "../internal/utils";
import * as operations from "./models/operations";
import * as shared from "./models/shared";
import { AxiosInstance, AxiosRequestConfig, AxiosResponse } from "axios";

export class Refunds {
  _defaultClient: AxiosInstance;
  _securityClient: AxiosInstance;
  _serverURL: string;
  _language: string;
  _sdkVersion: string;
  _genVersion: string;

  constructor(
    defaultClient: AxiosInstance,
    securityClient: AxiosInstance,
    serverURL: string,
    language: string,
    sdkVersion: string,
    genVersion: string
  ) {
    this._defaultClient = defaultClient;
    this._securityClient = securityClient;
    this._serverURL = serverURL;
    this._language = language;
    this._sdkVersion = sdkVersion;
    this._genVersion = genVersion;
  }

  /**
   * Delete a refund
   *
   * @remarks
   * **Note:** This operation is only available if you have [Invoice Settlement](https://knowledgecenter.zuora.com/Billing/Billing_and_Payments/Invoice_Settlement) enabled. The Invoice Settlement feature is generally available as of Zuora Billing Release 296 (March 2021). This feature includes Unapplied Payments, Credit and Debit Memo, and Invoice Item Settlement. If you want to enable Invoice Settlement, see [Invoice Settlement Enablement and Checklist Guide](https://knowledgecenter.zuora.com/Billing/Billing_and_Payments/Invoice_Settlement/Invoice_Settlement_Migration_Checklist_and_Guide) for more information.
   *
   * Deletes a refund. You can delete a refund with the Canceled or Error status.
   *
   * If you have the Invoice Settlement feature enabled, refunds applied to credit balance cannot be deleted.
   *
   */
  deleteRefund(
    req: operations.DELETERefundRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.DELETERefundResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DELETERefundRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v1/refunds/{refundId}",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };

    const r = client.request({
      url: url,
      method: "delete",
      headers: headers,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DELETERefundResponse =
        new operations.DELETERefundResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
          headers: utils.getHeadersFromResponse(httpRes.headers),
        });
      switch (true) {
        case httpRes?.status == 200:
          if (
            utils.matchContentType(
              contentType,
              `application/json; charset=utf-8`
            )
          ) {
            res.commonResponseType = utils.objectToClass(
              httpRes?.data,
              shared.CommonResponseType
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Retrieve a refund
   *
   * @remarks
   * **Note:** This operation is only available if you have [Invoice Settlement](https://knowledgecenter.zuora.com/Billing/Billing_and_Payments/Invoice_Settlement) enabled. The Invoice Settlement feature is generally available as of Zuora Billing Release 296 (March 2021). This feature includes Unapplied Payments, Credit and Debit Memo, and Invoice Item Settlement. If you want to enable Invoice Settlement, see [Invoice Settlement Enablement and Checklist Guide](https://knowledgecenter.zuora.com/Billing/Billing_and_Payments/Invoice_Settlement/Invoice_Settlement_Migration_Checklist_and_Guide) for more information.
   *
   * Retrieves the information about a specific refund.
   *
   */
  getRefund(
    req: operations.GETRefundRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GETRefundResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GETRefundRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v1/refunds/{refundId}",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };

    const r = client.request({
      url: url,
      method: "get",
      headers: headers,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GETRefundResponse =
        new operations.GETRefundResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
          headers: utils.getHeadersFromResponse(httpRes.headers),
        });
      switch (true) {
        case httpRes?.status == 200:
          if (
            utils.matchContentType(
              contentType,
              `application/json; charset=utf-8`
            )
          ) {
            res.getRefundType = utils.objectToClass(
              httpRes?.data,
              shared.GETRefundType
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Retrieve a refund part item
   *
   * @remarks
   * **Note:** This operation is only available if you have the [Invoice Item Settlement](https://knowledgecenter.zuora.com/Billing/Billing_and_Payments/Invoice_Settlement/C_Invoice_Item_Settlement) feature enabled. Invoice Item Settlement must be used together with other Invoice Settlement features (Unapplied Payments, and Credit and Debit memos).  If you wish to enable Invoice Settlement, see [Invoice Settlement Enablement and Checklist Guide](https://knowledgecenter.zuora.com/Billing/Billing_and_Payments/Invoice_Settlement/Invoice_Settlement_Migration_Checklist_and_Guide) for more information.
   *
   * Retrieves the information about a specific refund part item. A refund part item is a single line item in a refund part. A refund part can consist of several different types of items.
   *
   */
  getRefundItemPart(
    req: operations.GETRefundItemPartRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GETRefundItemPartResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GETRefundItemPartRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v1/refunds/{refundId}/parts/{refundpartid}/itemparts/{itempartid}",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };

    const r = client.request({
      url: url,
      method: "get",
      headers: headers,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GETRefundItemPartResponse =
        new operations.GETRefundItemPartResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
          headers: utils.getHeadersFromResponse(httpRes.headers),
        });
      switch (true) {
        case httpRes?.status == 200:
          if (
            utils.matchContentType(
              contentType,
              `application/json; charset=utf-8`
            )
          ) {
            res.getRefundItemPartType = utils.objectToClass(
              httpRes?.data,
              shared.GETRefundItemPartType
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * List all refund part items
   *
   * @remarks
   * **Note:** This operation is only available if you have the [Invoice Item Settlement](https://knowledgecenter.zuora.com/Billing/Billing_and_Payments/Invoice_Settlement/C_Invoice_Item_Settlement) feature enabled. Invoice Item Settlement must be used together with other Invoice Settlement features (Unapplied Payments, and Credit and Debit memos).  If you wish to enable Invoice Settlement, see [Invoice Settlement Enablement and Checklist Guide](https://knowledgecenter.zuora.com/Billing/Billing_and_Payments/Invoice_Settlement/Invoice_Settlement_Migration_Checklist_and_Guide) for more information.
   *
   * Retrieves the information about all items of a refund part. A refund part item is a single line item in a refund part. A refund part can consist of several different types of items.
   *
   */
  getRefundItemParts(
    req: operations.GETRefundItemPartsRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GETRefundItemPartsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GETRefundItemPartsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v1/refunds/{refundId}/parts/{refundpartid}/itemparts",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      headers: headers,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GETRefundItemPartsResponse =
        new operations.GETRefundItemPartsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
          headers: utils.getHeadersFromResponse(httpRes.headers),
        });
      switch (true) {
        case httpRes?.status == 200:
          if (
            utils.matchContentType(
              contentType,
              `application/json; charset=utf-8`
            )
          ) {
            res.getRefundItemPartCollectionType = utils.objectToClass(
              httpRes?.data,
              shared.GETRefundItemPartCollectionType
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Retrieve a refund part
   *
   * @remarks
   * **Note:** This operation is only available if you have [Invoice Settlement](https://knowledgecenter.zuora.com/Billing/Billing_and_Payments/Invoice_Settlement) enabled. The Invoice Settlement feature is generally available as of Zuora Billing Release 296 (March 2021). This feature includes Unapplied Payments, Credit and Debit Memo, and Invoice Item Settlement. If you want to enable Invoice Settlement, see [Invoice Settlement Enablement and Checklist Guide](https://knowledgecenter.zuora.com/Billing/Billing_and_Payments/Invoice_Settlement/Invoice_Settlement_Migration_Checklist_and_Guide) for more information.
   *
   * Retrieves the information about a specific refund part.
   *
   */
  getRefundPart(
    req: operations.GETRefundPartRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GETRefundPartResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GETRefundPartRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v1/refunds/{refundId}/parts/{refundpartid}",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };

    const r = client.request({
      url: url,
      method: "get",
      headers: headers,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GETRefundPartResponse =
        new operations.GETRefundPartResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
          headers: utils.getHeadersFromResponse(httpRes.headers),
        });
      switch (true) {
        case httpRes?.status == 200:
          if (
            utils.matchContentType(
              contentType,
              `application/json; charset=utf-8`
            )
          ) {
            res.refundPartResponseType = utils.objectToClass(
              httpRes?.data,
              shared.RefundPartResponseType
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * List all parts of a refund
   *
   * @remarks
   * **Note:** This operation is only available if you have [Invoice Settlement](https://knowledgecenter.zuora.com/Billing/Billing_and_Payments/Invoice_Settlement) enabled. The Invoice Settlement feature is generally available as of Zuora Billing Release 296 (March 2021). This feature includes Unapplied Payments, Credit and Debit Memo, and Invoice Item Settlement. If you want to enable Invoice Settlement, see [Invoice Settlement Enablement and Checklist Guide](https://knowledgecenter.zuora.com/Billing/Billing_and_Payments/Invoice_Settlement/Invoice_Settlement_Migration_Checklist_and_Guide) for more information.
   *
   * Retrieves the information about all parts of a refund.
   *
   */
  getRefundParts(
    req: operations.GETRefundPartsRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GETRefundPartsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GETRefundPartsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v1/refunds/{refundId}/parts",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };

    const r = client.request({
      url: url,
      method: "get",
      headers: headers,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GETRefundPartsResponse =
        new operations.GETRefundPartsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
          headers: utils.getHeadersFromResponse(httpRes.headers),
        });
      switch (true) {
        case httpRes?.status == 200:
          if (
            utils.matchContentType(
              contentType,
              `application/json; charset=utf-8`
            )
          ) {
            res.getRefundPartCollectionType = utils.objectToClass(
              httpRes?.data,
              shared.GETRefundPartCollectionType
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * List refunds
   *
   * @remarks
   * **Note:** This operation is only available if you have [Invoice Settlement](https://knowledgecenter.zuora.com/Billing/Billing_and_Payments/Invoice_Settlement) enabled. The Invoice Settlement feature is generally available as of Zuora Billing Release 296 (March 2021). This feature includes Unapplied Payments, Credit and Debit Memo, and Invoice Item Settlement. If you want to enable Invoice Settlement, see [Invoice Settlement Enablement and Checklist Guide](https://knowledgecenter.zuora.com/Billing/Billing_and_Payments/Invoice_Settlement/Invoice_Settlement_Migration_Checklist_and_Guide) for more information.
   *
   * Retrieves the information about all refunds. Two types of refunds are available, electronic refunds and external refunds.
   *
   * ### Filtering
   *
   * You can use query parameters to restrict the data returned in the response. Each query parameter corresponds to one field in the response body.
   *
   * If the value of a filterable field is string, you can set the corresponding query parameter to `null` when filtering. Then, you can get the response data with this field value being `null`.
   *
   * Examples:
   *
   * - /v1/refunds?status=Processed
   *
   * - /v1/refunds?amount=4&status=Processed
   *
   * - /v1/refunds?status=Processed&type=External&sort=+number
   *
   */
  getRefunds(
    req: operations.GETRefundsRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GETRefundsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GETRefundsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/v1/refunds";

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      headers: headers,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GETRefundsResponse =
        new operations.GETRefundsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
          headers: utils.getHeadersFromResponse(httpRes.headers),
        });
      switch (true) {
        case httpRes?.status == 200:
          if (
            utils.matchContentType(
              contentType,
              `application/json; charset=utf-8`
            )
          ) {
            res.getRefundCollectionType = utils.objectToClass(
              httpRes?.data,
              shared.GETRefundCollectionType
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * CRUD: Delete a refund
   */
  objectDELETERefund(
    req: operations.ObjectDELETERefundRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.ObjectDELETERefundResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ObjectDELETERefundRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v1/object/refund/{id}",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };

    const r = client.request({
      url: url,
      method: "delete",
      headers: headers,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ObjectDELETERefundResponse =
        new operations.ObjectDELETERefundResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
          headers: utils.getHeadersFromResponse(httpRes.headers),
        });
      switch (true) {
        case httpRes?.status == 200:
          if (
            utils.matchContentType(
              contentType,
              `application/json; charset=utf-8`
            )
          ) {
            res.proxyDeleteResponse = utils.objectToClass(
              httpRes?.data,
              shared.ProxyDeleteResponse
            );
          }
          break;
        case httpRes?.status == 401:
          if (
            utils.matchContentType(
              contentType,
              `application/json; charset=utf-8`
            )
          ) {
            res.proxyUnauthorizedResponse = utils.objectToClass(
              httpRes?.data,
              shared.ProxyUnauthorizedResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * CRUD: Retrieve a refund
   */
  objectGETRefund(
    req: operations.ObjectGETRefundRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.ObjectGETRefundResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ObjectGETRefundRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v1/object/refund/{id}",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      headers: headers,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ObjectGETRefundResponse =
        new operations.ObjectGETRefundResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
          headers: utils.getHeadersFromResponse(httpRes.headers),
        });
      switch (true) {
        case httpRes?.status == 200:
          if (
            utils.matchContentType(
              contentType,
              `application/json; charset=utf-8`
            )
          ) {
            res.proxyGetRefund = utils.objectToClass(
              httpRes?.data,
              shared.ProxyGetRefund
            );
          }
          break;
        case httpRes?.status == 401:
          if (
            utils.matchContentType(
              contentType,
              `application/json; charset=utf-8`
            )
          ) {
            res.proxyUnauthorizedResponse = utils.objectToClass(
              httpRes?.data,
              shared.ProxyUnauthorizedResponse
            );
          }
          break;
        case httpRes?.status == 404:
          if (
            utils.matchContentType(
              contentType,
              `application/json; charset=utf-8`
            )
          ) {
            res.proxyNoDataResponse = utils.objectToClass(
              httpRes?.data,
              shared.ProxyNoDataResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * CRUD: Create a refund
   *
   * @remarks
   * Creates a refund.
   *
   * If you have the Invoice Settlement feature enabled, you can use this operation to unapply the payment from an invoice or multiple invoices, and refund the payment.
   *
   * If the unapplied payment is left in the following scenarios, you have to reapply the unapplied payment to the original invoices:
   *
   * - An electronic refund in Processing status is handled to change to Error. An unapplied payment is left.
   * - An electronic refund gets to Error, and payment reapplying fails due to the concurrent issue.
   * - The refund canceling operation updates the status of a refund from Processed to Canceled. When it is successful, an unapplied payment is left.
   *
   */
  objectPOSTRefund(
    req: operations.ObjectPOSTRefundRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.ObjectPOSTRefundResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ObjectPOSTRefundRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/v1/object/refund";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "proxyCreateRefund",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._defaultClient;

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };
    const queryParams: string = utils.serializeQueryParams(req);
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url + queryParams,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ObjectPOSTRefundResponse =
        new operations.ObjectPOSTRefundResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
          headers: utils.getHeadersFromResponse(httpRes.headers),
        });
      switch (true) {
        case httpRes?.status == 200:
          if (
            utils.matchContentType(
              contentType,
              `application/json; charset=utf-8`
            )
          ) {
            res.proxyCreateOrModifyResponse = utils.objectToClass(
              httpRes?.data,
              shared.ProxyCreateOrModifyResponse
            );
          }
          break;
        case httpRes?.status == 400:
          if (
            utils.matchContentType(
              contentType,
              `application/json; charset=utf-8`
            )
          ) {
            res.proxyBadRequestResponse = utils.objectToClass(
              httpRes?.data,
              shared.ProxyBadRequestResponse
            );
          }
          break;
        case httpRes?.status == 401:
          if (
            utils.matchContentType(
              contentType,
              `application/json; charset=utf-8`
            )
          ) {
            res.proxyUnauthorizedResponse = utils.objectToClass(
              httpRes?.data,
              shared.ProxyUnauthorizedResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * CRUD: Update a refund
   */
  objectPUTRefund(
    req: operations.ObjectPUTRefundRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.ObjectPUTRefundResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ObjectPUTRefundRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v1/object/refund/{id}",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "proxyModifyRefund",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._defaultClient;

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };
    const queryParams: string = utils.serializeQueryParams(req);
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url + queryParams,
      method: "put",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ObjectPUTRefundResponse =
        new operations.ObjectPUTRefundResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
          headers: utils.getHeadersFromResponse(httpRes.headers),
        });
      switch (true) {
        case httpRes?.status == 200:
          if (
            utils.matchContentType(
              contentType,
              `application/json; charset=utf-8`
            )
          ) {
            res.proxyCreateOrModifyResponse = utils.objectToClass(
              httpRes?.data,
              shared.ProxyCreateOrModifyResponse
            );
          }
          break;
        case httpRes?.status == 401:
          if (
            utils.matchContentType(
              contentType,
              `application/json; charset=utf-8`
            )
          ) {
            res.proxyUnauthorizedResponse = utils.objectToClass(
              httpRes?.data,
              shared.ProxyUnauthorizedResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Cancel a refund
   *
   * @remarks
   * **Note:** This operation is only available if you have [Invoice Settlement](https://knowledgecenter.zuora.com/Billing/Billing_and_Payments/Invoice_Settlement) enabled. The Invoice Settlement feature is generally available as of Zuora Billing Release 296 (March 2021). This feature includes Unapplied Payments, Credit and Debit Memo, and Invoice Item Settlement. If you want to enable Invoice Settlement, see [Invoice Settlement Enablement and Checklist Guide](https://knowledgecenter.zuora.com/Billing/Billing_and_Payments/Invoice_Settlement/Invoice_Settlement_Migration_Checklist_and_Guide) for more information.
   *
   * Cancels a refund.
   *
   * If you have the Invoice Settlement feature enabled, refunds applied to credit balance cannot be cancelled.
   *
   */
  putCancelRefund(
    req: operations.PUTCancelRefundRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.PUTCancelRefundResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PUTCancelRefundRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v1/refunds/{refundId}/cancel",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };

    const r = client.request({
      url: url,
      method: "put",
      headers: headers,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PUTCancelRefundResponse =
        new operations.PUTCancelRefundResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
          headers: utils.getHeadersFromResponse(httpRes.headers),
        });
      switch (true) {
        case httpRes?.status == 200:
          if (
            utils.matchContentType(
              contentType,
              `application/json; charset=utf-8`
            )
          ) {
            res.getRefundType = utils.objectToClass(
              httpRes?.data,
              shared.GETRefundType
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Update a refund
   *
   * @remarks
   * **Note:** This operation is only available if you have [Invoice Settlement](https://knowledgecenter.zuora.com/Billing/Billing_and_Payments/Invoice_Settlement) enabled. The Invoice Settlement feature is generally available as of Zuora Billing Release 296 (March 2021). This feature includes Unapplied Payments, Credit and Debit Memo, and Invoice Item Settlement. If you want to enable Invoice Settlement, see [Invoice Settlement Enablement and Checklist Guide](https://knowledgecenter.zuora.com/Billing/Billing_and_Payments/Invoice_Settlement/Invoice_Settlement_Migration_Checklist_and_Guide) for more information.
   *
   * Updates the basic and finance information about a refund.
   *
   */
  putUpdateRefund(
    req: operations.PUTUpdateRefundRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.PUTUpdateRefundResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PUTUpdateRefundRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v1/refunds/{refundId}",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "putRefundType",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._defaultClient;

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "put",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PUTUpdateRefundResponse =
        new operations.PUTUpdateRefundResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
          headers: utils.getHeadersFromResponse(httpRes.headers),
        });
      switch (true) {
        case httpRes?.status == 200:
          if (
            utils.matchContentType(
              contentType,
              `application/json; charset=utf-8`
            )
          ) {
            res.getRefundType = utils.objectToClass(
              httpRes?.data,
              shared.GETRefundType
            );
          }
          break;
      }

      return res;
    });
  }
}
