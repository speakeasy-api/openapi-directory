"""Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT."""

import requests as requests_http
from . import utils
from sdk.models import operations, shared
from typing import Optional

class Subscriptions:
    _client: requests_http.Session
    _security_client: requests_http.Session
    _server_url: str
    _language: str
    _sdk_version: str
    _gen_version: str

    def __init__(self, client: requests_http.Session, security_client: requests_http.Session, server_url: str, language: str, sdk_version: str, gen_version: str) -> None:
        self._client = client
        self._security_client = security_client
        self._server_url = server_url
        self._language = language
        self._sdk_version = sdk_version
        self._gen_version = gen_version
        
    def cancel_subscription(self, request: operations.CancelSubscriptionRequest, security: operations.CancelSubscriptionSecurity) -> operations.CancelSubscriptionResponse:
        r"""CancelSubscription
        Sets the `canceled_date` field to the end of the active billing period.
        After this date, the status changes from ACTIVE to CANCELED.
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.CancelSubscriptionRequest, base_url, '/v2/subscriptions/{subscription_id}/cancel', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.CancelSubscriptionResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.CancelSubscriptionResponse])
                res.cancel_subscription_response = out

        return res

    def create_subscription(self, request: shared.CreateSubscriptionRequest, security: operations.CreateSubscriptionSecurity) -> operations.CreateSubscriptionResponse:
        r"""CreateSubscription
        Creates a subscription for a customer to a subscription plan.
        
        If you provide a card on file in the request, Square charges the card for
        the subscription. Otherwise, Square bills an invoice to the customer's email
        address. The subscription starts immediately, unless the request includes
        the optional `start_date`. Each individual subscription is associated with a particular location.
        """
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/v2/subscriptions'
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.CreateSubscriptionResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.CreateSubscriptionResponse])
                res.create_subscription_response = out

        return res

    def list_subscription_events(self, request: operations.ListSubscriptionEventsRequest, security: operations.ListSubscriptionEventsSecurity) -> operations.ListSubscriptionEventsResponse:
        r"""ListSubscriptionEvents
        Lists all events for a specific subscription.
        In the current implementation, only `START_SUBSCRIPTION` and `STOP_SUBSCRIPTION` (when the subscription was canceled) events are returned.
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.ListSubscriptionEventsRequest, base_url, '/v2/subscriptions/{subscription_id}/events', request)
        
        query_params = utils.get_query_params(operations.ListSubscriptionEventsRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ListSubscriptionEventsResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ListSubscriptionEventsResponse])
                res.list_subscription_events_response = out

        return res

    def resume_subscription(self, request: operations.ResumeSubscriptionRequest, security: operations.ResumeSubscriptionSecurity) -> operations.ResumeSubscriptionResponse:
        r"""ResumeSubscription
        Resumes a deactivated subscription.
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.ResumeSubscriptionRequest, base_url, '/v2/subscriptions/{subscription_id}/resume', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ResumeSubscriptionResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ResumeSubscriptionResponse])
                res.resume_subscription_response = out

        return res

    def retrieve_subscription(self, request: operations.RetrieveSubscriptionRequest, security: operations.RetrieveSubscriptionSecurity) -> operations.RetrieveSubscriptionResponse:
        r"""RetrieveSubscription
        Retrieves a subscription.
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.RetrieveSubscriptionRequest, base_url, '/v2/subscriptions/{subscription_id}', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.RetrieveSubscriptionResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.RetrieveSubscriptionResponse])
                res.retrieve_subscription_response = out

        return res

    def search_subscriptions(self, request: shared.SearchSubscriptionsRequest, security: operations.SearchSubscriptionsSecurity) -> operations.SearchSubscriptionsResponse:
        r"""SearchSubscriptions
        Searches for subscriptions.
        Results are ordered chronologically by subscription creation date. If
        the request specifies more than one location ID,
        the endpoint orders the result
        by location ID, and then by creation date within each location. If no locations are given
        in the query, all locations are searched.
        
        You can also optionally specify `customer_ids` to search by customer.
        If left unset, all customers
        associated with the specified locations are returned.
        If the request specifies customer IDs, the endpoint orders results
        first by location, within location by customer ID, and within
        customer by subscription creation date.
        
        For more information, see
        [Retrieve subscriptions](https://developer.squareup.com/docs/subscriptions-api/overview#retrieve-subscriptions).
        """
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/v2/subscriptions/search'
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.SearchSubscriptionsResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.SearchSubscriptionsResponse])
                res.search_subscriptions_response = out

        return res

    def update_subscription(self, request: operations.UpdateSubscriptionRequest, security: operations.UpdateSubscriptionSecurity) -> operations.UpdateSubscriptionResponse:
        r"""UpdateSubscription
        Updates a subscription. You can set, modify, and clear the
        `subscription` field values.
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.UpdateSubscriptionRequest, base_url, '/v2/subscriptions/{subscription_id}', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "update_subscription_request", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('PUT', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.UpdateSubscriptionResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.UpdateSubscriptionResponse])
                res.update_subscription_response = out

        return res

    