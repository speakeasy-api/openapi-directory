<?php

/**
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

declare(strict_types=1);

namespace OpenAPI\OpenAPI;

class Projects 
{

	// SDK private variables namespaced with _ to avoid conflicts with API models
	private \GuzzleHttp\ClientInterface $_defaultClient;
	private \GuzzleHttp\ClientInterface $_securityClient;
	private string $_serverUrl;
	private string $_language;
	private string $_sdkVersion;
	private string $_genVersion;	

	/**
	 * @param \GuzzleHttp\ClientInterface $defaultClient
	 * @param \GuzzleHttp\ClientInterface $securityClient
	 * @param string $serverUrl
	 * @param string $language
	 * @param string $sdkVersion
	 * @param string $genVersion
	 */
	public function __construct(\GuzzleHttp\ClientInterface $defaultClient, \GuzzleHttp\ClientInterface $securityClient, string $serverUrl, string $language, string $sdkVersion, string $genVersion)
	{
		$this->_defaultClient = $defaultClient;
		$this->_securityClient = $securityClient;
		$this->_serverUrl = $serverUrl;
		$this->_language = $language;
		$this->_sdkVersion = $sdkVersion;
		$this->_genVersion = $genVersion;
	}
	
    /**
     * Creates a new alerting policy.Design your application to single-thread API calls that modify the state of alerting policies in a single project. This includes calls to CreateAlertPolicy, DeleteAlertPolicy and UpdateAlertPolicy.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\MonitoringProjectsAlertPoliciesCreateRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\MonitoringProjectsAlertPoliciesCreateSecurity $security
     * @return \OpenAPI\OpenAPI\Models\Operations\MonitoringProjectsAlertPoliciesCreateResponse
     */
	public function monitoringProjectsAlertPoliciesCreate(
        \OpenAPI\OpenAPI\Models\Operations\MonitoringProjectsAlertPoliciesCreateRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\MonitoringProjectsAlertPoliciesCreateSecurity $security,
    ): \OpenAPI\OpenAPI\Models\Operations\MonitoringProjectsAlertPoliciesCreateResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v3/{name}/alertPolicies', \OpenAPI\OpenAPI\Models\Operations\MonitoringProjectsAlertPoliciesCreateRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "alertPolicy", "json");
        $options = array_merge_recursive($options, $body);
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\MonitoringProjectsAlertPoliciesCreateRequest::class, $request, null));
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\MonitoringProjectsAlertPoliciesCreateResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->alertPolicy = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\AlertPolicy', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Lists the existing alerting policies for the workspace.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\MonitoringProjectsAlertPoliciesListRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\MonitoringProjectsAlertPoliciesListSecurity $security
     * @return \OpenAPI\OpenAPI\Models\Operations\MonitoringProjectsAlertPoliciesListResponse
     */
	public function monitoringProjectsAlertPoliciesList(
        \OpenAPI\OpenAPI\Models\Operations\MonitoringProjectsAlertPoliciesListRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\MonitoringProjectsAlertPoliciesListSecurity $security,
    ): \OpenAPI\OpenAPI\Models\Operations\MonitoringProjectsAlertPoliciesListResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v3/{name}/alertPolicies', \OpenAPI\OpenAPI\Models\Operations\MonitoringProjectsAlertPoliciesListRequest::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\MonitoringProjectsAlertPoliciesListRequest::class, $request, null));
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\MonitoringProjectsAlertPoliciesListResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->listAlertPoliciesResponse = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\ListAlertPoliciesResponse', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Cloud Monitoring Agent only: Creates a new time series.This method is only for use by the Cloud Monitoring Agent. Use projects.timeSeries.create instead.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\MonitoringProjectsCollectdTimeSeriesCreateRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\MonitoringProjectsCollectdTimeSeriesCreateSecurity $security
     * @return \OpenAPI\OpenAPI\Models\Operations\MonitoringProjectsCollectdTimeSeriesCreateResponse
     */
	public function monitoringProjectsCollectdTimeSeriesCreate(
        \OpenAPI\OpenAPI\Models\Operations\MonitoringProjectsCollectdTimeSeriesCreateRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\MonitoringProjectsCollectdTimeSeriesCreateSecurity $security,
    ): \OpenAPI\OpenAPI\Models\Operations\MonitoringProjectsCollectdTimeSeriesCreateResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v3/{name}/collectdTimeSeries', \OpenAPI\OpenAPI\Models\Operations\MonitoringProjectsCollectdTimeSeriesCreateRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "createCollectdTimeSeriesRequest", "json");
        $options = array_merge_recursive($options, $body);
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\MonitoringProjectsCollectdTimeSeriesCreateRequest::class, $request, null));
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\MonitoringProjectsCollectdTimeSeriesCreateResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->createCollectdTimeSeriesResponse = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\CreateCollectdTimeSeriesResponse', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Creates a new group.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\MonitoringProjectsGroupsCreateRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\MonitoringProjectsGroupsCreateSecurity $security
     * @return \OpenAPI\OpenAPI\Models\Operations\MonitoringProjectsGroupsCreateResponse
     */
	public function monitoringProjectsGroupsCreate(
        \OpenAPI\OpenAPI\Models\Operations\MonitoringProjectsGroupsCreateRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\MonitoringProjectsGroupsCreateSecurity $security,
    ): \OpenAPI\OpenAPI\Models\Operations\MonitoringProjectsGroupsCreateResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v3/{name}/groups', \OpenAPI\OpenAPI\Models\Operations\MonitoringProjectsGroupsCreateRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "group", "json");
        $options = array_merge_recursive($options, $body);
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\MonitoringProjectsGroupsCreateRequest::class, $request, null));
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\MonitoringProjectsGroupsCreateResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->group = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\Group', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Lists the existing groups.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\MonitoringProjectsGroupsListRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\MonitoringProjectsGroupsListSecurity $security
     * @return \OpenAPI\OpenAPI\Models\Operations\MonitoringProjectsGroupsListResponse
     */
	public function monitoringProjectsGroupsList(
        \OpenAPI\OpenAPI\Models\Operations\MonitoringProjectsGroupsListRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\MonitoringProjectsGroupsListSecurity $security,
    ): \OpenAPI\OpenAPI\Models\Operations\MonitoringProjectsGroupsListResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v3/{name}/groups', \OpenAPI\OpenAPI\Models\Operations\MonitoringProjectsGroupsListRequest::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\MonitoringProjectsGroupsListRequest::class, $request, null));
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\MonitoringProjectsGroupsListResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->listGroupsResponse = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\ListGroupsResponse', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Lists the monitored resources that are members of a group.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\MonitoringProjectsGroupsMembersListRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\MonitoringProjectsGroupsMembersListSecurity $security
     * @return \OpenAPI\OpenAPI\Models\Operations\MonitoringProjectsGroupsMembersListResponse
     */
	public function monitoringProjectsGroupsMembersList(
        \OpenAPI\OpenAPI\Models\Operations\MonitoringProjectsGroupsMembersListRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\MonitoringProjectsGroupsMembersListSecurity $security,
    ): \OpenAPI\OpenAPI\Models\Operations\MonitoringProjectsGroupsMembersListResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v3/{name}/members', \OpenAPI\OpenAPI\Models\Operations\MonitoringProjectsGroupsMembersListRequest::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\MonitoringProjectsGroupsMembersListRequest::class, $request, null));
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\MonitoringProjectsGroupsMembersListResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->listGroupMembersResponse = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\ListGroupMembersResponse', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Updates an existing group. You can change any group attributes except name.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\MonitoringProjectsGroupsUpdateRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\MonitoringProjectsGroupsUpdateSecurity $security
     * @return \OpenAPI\OpenAPI\Models\Operations\MonitoringProjectsGroupsUpdateResponse
     */
	public function monitoringProjectsGroupsUpdate(
        \OpenAPI\OpenAPI\Models\Operations\MonitoringProjectsGroupsUpdateRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\MonitoringProjectsGroupsUpdateSecurity $security,
    ): \OpenAPI\OpenAPI\Models\Operations\MonitoringProjectsGroupsUpdateResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v3/{name}', \OpenAPI\OpenAPI\Models\Operations\MonitoringProjectsGroupsUpdateRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "group", "json");
        $options = array_merge_recursive($options, $body);
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\MonitoringProjectsGroupsUpdateRequest::class, $request, null));
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('PUT', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\MonitoringProjectsGroupsUpdateResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->group = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\Group', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Creates a new metric descriptor. The creation is executed asynchronously. User-created metric descriptors define custom metrics (https://cloud.google.com/monitoring/custom-metrics). The metric descriptor is updated if it already exists, except that metric labels are never removed.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\MonitoringProjectsMetricDescriptorsCreateRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\MonitoringProjectsMetricDescriptorsCreateSecurity $security
     * @return \OpenAPI\OpenAPI\Models\Operations\MonitoringProjectsMetricDescriptorsCreateResponse
     */
	public function monitoringProjectsMetricDescriptorsCreate(
        \OpenAPI\OpenAPI\Models\Operations\MonitoringProjectsMetricDescriptorsCreateRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\MonitoringProjectsMetricDescriptorsCreateSecurity $security,
    ): \OpenAPI\OpenAPI\Models\Operations\MonitoringProjectsMetricDescriptorsCreateResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v3/{name}/metricDescriptors', \OpenAPI\OpenAPI\Models\Operations\MonitoringProjectsMetricDescriptorsCreateRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "metricDescriptor", "json");
        $options = array_merge_recursive($options, $body);
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\MonitoringProjectsMetricDescriptorsCreateRequest::class, $request, null));
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\MonitoringProjectsMetricDescriptorsCreateResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->metricDescriptor = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\MetricDescriptor', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Lists metric descriptors that match a filter.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\MonitoringProjectsMetricDescriptorsListRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\MonitoringProjectsMetricDescriptorsListSecurity $security
     * @return \OpenAPI\OpenAPI\Models\Operations\MonitoringProjectsMetricDescriptorsListResponse
     */
	public function monitoringProjectsMetricDescriptorsList(
        \OpenAPI\OpenAPI\Models\Operations\MonitoringProjectsMetricDescriptorsListRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\MonitoringProjectsMetricDescriptorsListSecurity $security,
    ): \OpenAPI\OpenAPI\Models\Operations\MonitoringProjectsMetricDescriptorsListResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v3/{name}/metricDescriptors', \OpenAPI\OpenAPI\Models\Operations\MonitoringProjectsMetricDescriptorsListRequest::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\MonitoringProjectsMetricDescriptorsListRequest::class, $request, null));
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\MonitoringProjectsMetricDescriptorsListResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->listMetricDescriptorsResponse = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\ListMetricDescriptorsResponse', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Lists monitored resource descriptors that match a filter.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\MonitoringProjectsMonitoredResourceDescriptorsListRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\MonitoringProjectsMonitoredResourceDescriptorsListSecurity $security
     * @return \OpenAPI\OpenAPI\Models\Operations\MonitoringProjectsMonitoredResourceDescriptorsListResponse
     */
	public function monitoringProjectsMonitoredResourceDescriptorsList(
        \OpenAPI\OpenAPI\Models\Operations\MonitoringProjectsMonitoredResourceDescriptorsListRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\MonitoringProjectsMonitoredResourceDescriptorsListSecurity $security,
    ): \OpenAPI\OpenAPI\Models\Operations\MonitoringProjectsMonitoredResourceDescriptorsListResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v3/{name}/monitoredResourceDescriptors', \OpenAPI\OpenAPI\Models\Operations\MonitoringProjectsMonitoredResourceDescriptorsListRequest::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\MonitoringProjectsMonitoredResourceDescriptorsListRequest::class, $request, null));
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\MonitoringProjectsMonitoredResourceDescriptorsListResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->listMonitoredResourceDescriptorsResponse = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\ListMonitoredResourceDescriptorsResponse', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Lists the descriptors for supported channel types. The use of descriptors makes it possible for new channel types to be dynamically added.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\MonitoringProjectsNotificationChannelDescriptorsListRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\MonitoringProjectsNotificationChannelDescriptorsListSecurity $security
     * @return \OpenAPI\OpenAPI\Models\Operations\MonitoringProjectsNotificationChannelDescriptorsListResponse
     */
	public function monitoringProjectsNotificationChannelDescriptorsList(
        \OpenAPI\OpenAPI\Models\Operations\MonitoringProjectsNotificationChannelDescriptorsListRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\MonitoringProjectsNotificationChannelDescriptorsListSecurity $security,
    ): \OpenAPI\OpenAPI\Models\Operations\MonitoringProjectsNotificationChannelDescriptorsListResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v3/{name}/notificationChannelDescriptors', \OpenAPI\OpenAPI\Models\Operations\MonitoringProjectsNotificationChannelDescriptorsListRequest::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\MonitoringProjectsNotificationChannelDescriptorsListRequest::class, $request, null));
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\MonitoringProjectsNotificationChannelDescriptorsListResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->listNotificationChannelDescriptorsResponse = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\ListNotificationChannelDescriptorsResponse', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Creates a new notification channel, representing a single notification endpoint such as an email address, SMS number, or PagerDuty service.Design your application to single-thread API calls that modify the state of notification channels in a single project. This includes calls to CreateNotificationChannel, DeleteNotificationChannel and UpdateNotificationChannel.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\MonitoringProjectsNotificationChannelsCreateRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\MonitoringProjectsNotificationChannelsCreateSecurity $security
     * @return \OpenAPI\OpenAPI\Models\Operations\MonitoringProjectsNotificationChannelsCreateResponse
     */
	public function monitoringProjectsNotificationChannelsCreate(
        \OpenAPI\OpenAPI\Models\Operations\MonitoringProjectsNotificationChannelsCreateRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\MonitoringProjectsNotificationChannelsCreateSecurity $security,
    ): \OpenAPI\OpenAPI\Models\Operations\MonitoringProjectsNotificationChannelsCreateResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v3/{name}/notificationChannels', \OpenAPI\OpenAPI\Models\Operations\MonitoringProjectsNotificationChannelsCreateRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "notificationChannel", "json");
        $options = array_merge_recursive($options, $body);
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\MonitoringProjectsNotificationChannelsCreateRequest::class, $request, null));
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\MonitoringProjectsNotificationChannelsCreateResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->notificationChannel = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\NotificationChannel', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Requests a verification code for an already verified channel that can then be used in a call to VerifyNotificationChannel() on a different channel with an equivalent identity in the same or in a different project. This makes it possible to copy a channel between projects without requiring manual reverification of the channel. If the channel is not in the verified state, this method will fail (in other words, this may only be used if the SendNotificationChannelVerificationCode and VerifyNotificationChannel paths have already been used to put the given channel into the verified state).There is no guarantee that the verification codes returned by this method will be of a similar structure or form as the ones that are delivered to the channel via SendNotificationChannelVerificationCode; while VerifyNotificationChannel() will recognize both the codes delivered via SendNotificationChannelVerificationCode() and returned from GetNotificationChannelVerificationCode(), it is typically the case that the verification codes delivered via SendNotificationChannelVerificationCode() will be shorter and also have a shorter expiration (e.g. codes such as "G-123456") whereas GetVerificationCode() will typically return a much longer, websafe base 64 encoded string that has a longer expiration time.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\MonitoringProjectsNotificationChannelsGetVerificationCodeRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\MonitoringProjectsNotificationChannelsGetVerificationCodeSecurity $security
     * @return \OpenAPI\OpenAPI\Models\Operations\MonitoringProjectsNotificationChannelsGetVerificationCodeResponse
     */
	public function monitoringProjectsNotificationChannelsGetVerificationCode(
        \OpenAPI\OpenAPI\Models\Operations\MonitoringProjectsNotificationChannelsGetVerificationCodeRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\MonitoringProjectsNotificationChannelsGetVerificationCodeSecurity $security,
    ): \OpenAPI\OpenAPI\Models\Operations\MonitoringProjectsNotificationChannelsGetVerificationCodeResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v3/{name}:getVerificationCode', \OpenAPI\OpenAPI\Models\Operations\MonitoringProjectsNotificationChannelsGetVerificationCodeRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "getNotificationChannelVerificationCodeRequest", "json");
        $options = array_merge_recursive($options, $body);
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\MonitoringProjectsNotificationChannelsGetVerificationCodeRequest::class, $request, null));
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\MonitoringProjectsNotificationChannelsGetVerificationCodeResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->getNotificationChannelVerificationCodeResponse = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\GetNotificationChannelVerificationCodeResponse', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Lists the notification channels that have been created for the project. To list the types of notification channels that are supported, use the ListNotificationChannelDescriptors method.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\MonitoringProjectsNotificationChannelsListRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\MonitoringProjectsNotificationChannelsListSecurity $security
     * @return \OpenAPI\OpenAPI\Models\Operations\MonitoringProjectsNotificationChannelsListResponse
     */
	public function monitoringProjectsNotificationChannelsList(
        \OpenAPI\OpenAPI\Models\Operations\MonitoringProjectsNotificationChannelsListRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\MonitoringProjectsNotificationChannelsListSecurity $security,
    ): \OpenAPI\OpenAPI\Models\Operations\MonitoringProjectsNotificationChannelsListResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v3/{name}/notificationChannels', \OpenAPI\OpenAPI\Models\Operations\MonitoringProjectsNotificationChannelsListRequest::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\MonitoringProjectsNotificationChannelsListRequest::class, $request, null));
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\MonitoringProjectsNotificationChannelsListResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->listNotificationChannelsResponse = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\ListNotificationChannelsResponse', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Causes a verification code to be delivered to the channel. The code can then be supplied in VerifyNotificationChannel to verify the channel.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\MonitoringProjectsNotificationChannelsSendVerificationCodeRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\MonitoringProjectsNotificationChannelsSendVerificationCodeSecurity $security
     * @return \OpenAPI\OpenAPI\Models\Operations\MonitoringProjectsNotificationChannelsSendVerificationCodeResponse
     */
	public function monitoringProjectsNotificationChannelsSendVerificationCode(
        \OpenAPI\OpenAPI\Models\Operations\MonitoringProjectsNotificationChannelsSendVerificationCodeRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\MonitoringProjectsNotificationChannelsSendVerificationCodeSecurity $security,
    ): \OpenAPI\OpenAPI\Models\Operations\MonitoringProjectsNotificationChannelsSendVerificationCodeResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v3/{name}:sendVerificationCode', \OpenAPI\OpenAPI\Models\Operations\MonitoringProjectsNotificationChannelsSendVerificationCodeRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "requestBody", "json");
        $options = array_merge_recursive($options, $body);
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\MonitoringProjectsNotificationChannelsSendVerificationCodeRequest::class, $request, null));
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\MonitoringProjectsNotificationChannelsSendVerificationCodeResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->empty = $serializer->deserialize((string)$httpResponse->getBody(), 'array<string, mixed>', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Verifies a NotificationChannel by proving receipt of the code delivered to the channel as a result of calling SendNotificationChannelVerificationCode.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\MonitoringProjectsNotificationChannelsVerifyRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\MonitoringProjectsNotificationChannelsVerifySecurity $security
     * @return \OpenAPI\OpenAPI\Models\Operations\MonitoringProjectsNotificationChannelsVerifyResponse
     */
	public function monitoringProjectsNotificationChannelsVerify(
        \OpenAPI\OpenAPI\Models\Operations\MonitoringProjectsNotificationChannelsVerifyRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\MonitoringProjectsNotificationChannelsVerifySecurity $security,
    ): \OpenAPI\OpenAPI\Models\Operations\MonitoringProjectsNotificationChannelsVerifyResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v3/{name}:verify', \OpenAPI\OpenAPI\Models\Operations\MonitoringProjectsNotificationChannelsVerifyRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "verifyNotificationChannelRequest", "json");
        $options = array_merge_recursive($options, $body);
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\MonitoringProjectsNotificationChannelsVerifyRequest::class, $request, null));
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\MonitoringProjectsNotificationChannelsVerifyResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->notificationChannel = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\NotificationChannel', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Creates a Snooze that will prevent alerts, which match the provided criteria, from being opened. The Snooze applies for a specific time interval.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\MonitoringProjectsSnoozesCreateRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\MonitoringProjectsSnoozesCreateSecurity $security
     * @return \OpenAPI\OpenAPI\Models\Operations\MonitoringProjectsSnoozesCreateResponse
     */
	public function monitoringProjectsSnoozesCreate(
        \OpenAPI\OpenAPI\Models\Operations\MonitoringProjectsSnoozesCreateRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\MonitoringProjectsSnoozesCreateSecurity $security,
    ): \OpenAPI\OpenAPI\Models\Operations\MonitoringProjectsSnoozesCreateResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v3/{parent}/snoozes', \OpenAPI\OpenAPI\Models\Operations\MonitoringProjectsSnoozesCreateRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "snooze", "json");
        $options = array_merge_recursive($options, $body);
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\MonitoringProjectsSnoozesCreateRequest::class, $request, null));
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\MonitoringProjectsSnoozesCreateResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->snooze = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\Snooze', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Lists the Snoozes associated with a project. Can optionally pass in filter, which specifies predicates to match Snoozes.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\MonitoringProjectsSnoozesListRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\MonitoringProjectsSnoozesListSecurity $security
     * @return \OpenAPI\OpenAPI\Models\Operations\MonitoringProjectsSnoozesListResponse
     */
	public function monitoringProjectsSnoozesList(
        \OpenAPI\OpenAPI\Models\Operations\MonitoringProjectsSnoozesListRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\MonitoringProjectsSnoozesListSecurity $security,
    ): \OpenAPI\OpenAPI\Models\Operations\MonitoringProjectsSnoozesListResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v3/{parent}/snoozes', \OpenAPI\OpenAPI\Models\Operations\MonitoringProjectsSnoozesListRequest::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\MonitoringProjectsSnoozesListRequest::class, $request, null));
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\MonitoringProjectsSnoozesListResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->listSnoozesResponse = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\ListSnoozesResponse', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Creates or adds data to one or more time series. The response is empty if all time series in the request were written. If any time series could not be written, a corresponding failure message is included in the error response.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\MonitoringProjectsTimeSeriesCreateRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\MonitoringProjectsTimeSeriesCreateSecurity $security
     * @return \OpenAPI\OpenAPI\Models\Operations\MonitoringProjectsTimeSeriesCreateResponse
     */
	public function monitoringProjectsTimeSeriesCreate(
        \OpenAPI\OpenAPI\Models\Operations\MonitoringProjectsTimeSeriesCreateRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\MonitoringProjectsTimeSeriesCreateSecurity $security,
    ): \OpenAPI\OpenAPI\Models\Operations\MonitoringProjectsTimeSeriesCreateResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v3/{name}/timeSeries', \OpenAPI\OpenAPI\Models\Operations\MonitoringProjectsTimeSeriesCreateRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "createTimeSeriesRequest", "json");
        $options = array_merge_recursive($options, $body);
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\MonitoringProjectsTimeSeriesCreateRequest::class, $request, null));
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\MonitoringProjectsTimeSeriesCreateResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->empty = $serializer->deserialize((string)$httpResponse->getBody(), 'array<string, mixed>', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Creates or adds data to one or more service time series. A service time series is a time series for a metric from a Google Cloud service. The response is empty if all time series in the request were written. If any time series could not be written, a corresponding failure message is included in the error response. This endpoint rejects writes to user-defined metrics. This method is only for use by Google Cloud services. Use projects.timeSeries.create instead.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\MonitoringProjectsTimeSeriesCreateServiceRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\MonitoringProjectsTimeSeriesCreateServiceSecurity $security
     * @return \OpenAPI\OpenAPI\Models\Operations\MonitoringProjectsTimeSeriesCreateServiceResponse
     */
	public function monitoringProjectsTimeSeriesCreateService(
        \OpenAPI\OpenAPI\Models\Operations\MonitoringProjectsTimeSeriesCreateServiceRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\MonitoringProjectsTimeSeriesCreateServiceSecurity $security,
    ): \OpenAPI\OpenAPI\Models\Operations\MonitoringProjectsTimeSeriesCreateServiceResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v3/{name}/timeSeries:createService', \OpenAPI\OpenAPI\Models\Operations\MonitoringProjectsTimeSeriesCreateServiceRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "createTimeSeriesRequest", "json");
        $options = array_merge_recursive($options, $body);
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\MonitoringProjectsTimeSeriesCreateServiceRequest::class, $request, null));
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\MonitoringProjectsTimeSeriesCreateServiceResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->empty = $serializer->deserialize((string)$httpResponse->getBody(), 'array<string, mixed>', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Lists time series that match a filter.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\MonitoringProjectsTimeSeriesListRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\MonitoringProjectsTimeSeriesListSecurity $security
     * @return \OpenAPI\OpenAPI\Models\Operations\MonitoringProjectsTimeSeriesListResponse
     */
	public function monitoringProjectsTimeSeriesList(
        \OpenAPI\OpenAPI\Models\Operations\MonitoringProjectsTimeSeriesListRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\MonitoringProjectsTimeSeriesListSecurity $security,
    ): \OpenAPI\OpenAPI\Models\Operations\MonitoringProjectsTimeSeriesListResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v3/{name}/timeSeries', \OpenAPI\OpenAPI\Models\Operations\MonitoringProjectsTimeSeriesListRequest::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\MonitoringProjectsTimeSeriesListRequest::class, $request, null));
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\MonitoringProjectsTimeSeriesListResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->listTimeSeriesResponse = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\ListTimeSeriesResponse', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Queries time series using Monitoring Query Language.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\MonitoringProjectsTimeSeriesQueryRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\MonitoringProjectsTimeSeriesQuerySecurity $security
     * @return \OpenAPI\OpenAPI\Models\Operations\MonitoringProjectsTimeSeriesQueryResponse
     */
	public function monitoringProjectsTimeSeriesQuery(
        \OpenAPI\OpenAPI\Models\Operations\MonitoringProjectsTimeSeriesQueryRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\MonitoringProjectsTimeSeriesQuerySecurity $security,
    ): \OpenAPI\OpenAPI\Models\Operations\MonitoringProjectsTimeSeriesQueryResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v3/{name}/timeSeries:query', \OpenAPI\OpenAPI\Models\Operations\MonitoringProjectsTimeSeriesQueryRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "queryTimeSeriesRequest", "json");
        $options = array_merge_recursive($options, $body);
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\MonitoringProjectsTimeSeriesQueryRequest::class, $request, null));
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\MonitoringProjectsTimeSeriesQueryResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->queryTimeSeriesResponse = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\QueryTimeSeriesResponse', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Creates a new Uptime check configuration.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\MonitoringProjectsUptimeCheckConfigsCreateRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\MonitoringProjectsUptimeCheckConfigsCreateSecurity $security
     * @return \OpenAPI\OpenAPI\Models\Operations\MonitoringProjectsUptimeCheckConfigsCreateResponse
     */
	public function monitoringProjectsUptimeCheckConfigsCreate(
        \OpenAPI\OpenAPI\Models\Operations\MonitoringProjectsUptimeCheckConfigsCreateRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\MonitoringProjectsUptimeCheckConfigsCreateSecurity $security,
    ): \OpenAPI\OpenAPI\Models\Operations\MonitoringProjectsUptimeCheckConfigsCreateResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v3/{parent}/uptimeCheckConfigs', \OpenAPI\OpenAPI\Models\Operations\MonitoringProjectsUptimeCheckConfigsCreateRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "uptimeCheckConfig", "json");
        $options = array_merge_recursive($options, $body);
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\MonitoringProjectsUptimeCheckConfigsCreateRequest::class, $request, null));
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\MonitoringProjectsUptimeCheckConfigsCreateResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->uptimeCheckConfig = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\UptimeCheckConfig', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Lists the existing valid Uptime check configurations for the project (leaving out any invalid configurations).
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\MonitoringProjectsUptimeCheckConfigsListRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\MonitoringProjectsUptimeCheckConfigsListSecurity $security
     * @return \OpenAPI\OpenAPI\Models\Operations\MonitoringProjectsUptimeCheckConfigsListResponse
     */
	public function monitoringProjectsUptimeCheckConfigsList(
        \OpenAPI\OpenAPI\Models\Operations\MonitoringProjectsUptimeCheckConfigsListRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\MonitoringProjectsUptimeCheckConfigsListSecurity $security,
    ): \OpenAPI\OpenAPI\Models\Operations\MonitoringProjectsUptimeCheckConfigsListResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v3/{parent}/uptimeCheckConfigs', \OpenAPI\OpenAPI\Models\Operations\MonitoringProjectsUptimeCheckConfigsListRequest::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\MonitoringProjectsUptimeCheckConfigsListRequest::class, $request, null));
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\MonitoringProjectsUptimeCheckConfigsListResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->listUptimeCheckConfigsResponse = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\ListUptimeCheckConfigsResponse', 'json');
            }
        }

        return $response;
    }
}