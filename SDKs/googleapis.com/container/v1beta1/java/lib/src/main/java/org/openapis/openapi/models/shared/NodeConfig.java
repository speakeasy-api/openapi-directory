/* 
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

package org.openapis.openapi.models.shared;

import com.fasterxml.jackson.annotation.JsonInclude.Include;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;

/**
 * NodeConfig - Parameters that describe the nodes in a cluster. GKE Autopilot clusters do not recognize parameters in `NodeConfig`. Use AutoprovisioningNodePoolDefaults instead.
 */
public class NodeConfig {
    /**
     * A list of hardware accelerators to be attached to each node. See https://cloud.google.com/compute/docs/gpus for more information about support for GPUs.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("accelerators")
    public AcceleratorConfig[] accelerators;

    public NodeConfig withAccelerators(AcceleratorConfig[] accelerators) {
        this.accelerators = accelerators;
        return this;
    }
    
    /**
     * Specifies options for controlling advanced machine features.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("advancedMachineFeatures")
    public AdvancedMachineFeatures advancedMachineFeatures;

    public NodeConfig withAdvancedMachineFeatures(AdvancedMachineFeatures advancedMachineFeatures) {
        this.advancedMachineFeatures = advancedMachineFeatures;
        return this;
    }
    
    /**
     *  The Customer Managed Encryption Key used to encrypt the boot disk attached to each node in the node pool. This should be of the form projects/[KEY_PROJECT_ID]/locations/[LOCATION]/keyRings/[RING_NAME]/cryptoKeys/[KEY_NAME]. For more information about protecting resources with Cloud KMS Keys please see: https://cloud.google.com/compute/docs/disks/customer-managed-encryption
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("bootDiskKmsKey")
    public String bootDiskKmsKey;

    public NodeConfig withBootDiskKmsKey(String bootDiskKmsKey) {
        this.bootDiskKmsKey = bootDiskKmsKey;
        return this;
    }
    
    /**
     * ConfidentialNodes is configuration for the confidential nodes feature, which makes nodes run on confidential VMs.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("confidentialNodes")
    public ConfidentialNodes confidentialNodes;

    public NodeConfig withConfidentialNodes(ConfidentialNodes confidentialNodes) {
        this.confidentialNodes = confidentialNodes;
        return this;
    }
    
    /**
     * Size of the disk attached to each node, specified in GB. The smallest allowed disk size is 10GB. If unspecified, the default disk size is 100GB.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("diskSizeGb")
    public Integer diskSizeGb;

    public NodeConfig withDiskSizeGb(Integer diskSizeGb) {
        this.diskSizeGb = diskSizeGb;
        return this;
    }
    
    /**
     * Type of the disk attached to each node (e.g. 'pd-standard', 'pd-ssd' or 'pd-balanced') If unspecified, the default disk type is 'pd-standard'
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("diskType")
    public String diskType;

    public NodeConfig withDiskType(String diskType) {
        this.diskType = diskType;
        return this;
    }
    
    /**
     * EphemeralStorageConfig contains configuration for the ephemeral storage filesystem.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("ephemeralStorageConfig")
    public EphemeralStorageConfig ephemeralStorageConfig;

    public NodeConfig withEphemeralStorageConfig(EphemeralStorageConfig ephemeralStorageConfig) {
        this.ephemeralStorageConfig = ephemeralStorageConfig;
        return this;
    }
    
    /**
     * EphemeralStorageLocalSsdConfig contains configuration for the node ephemeral storage using Local SSDs.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("ephemeralStorageLocalSsdConfig")
    public EphemeralStorageLocalSsdConfig ephemeralStorageLocalSsdConfig;

    public NodeConfig withEphemeralStorageLocalSsdConfig(EphemeralStorageLocalSsdConfig ephemeralStorageLocalSsdConfig) {
        this.ephemeralStorageLocalSsdConfig = ephemeralStorageLocalSsdConfig;
        return this;
    }
    
    /**
     * Configuration of Fast Socket feature.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("fastSocket")
    public FastSocket fastSocket;

    public NodeConfig withFastSocket(FastSocket fastSocket) {
        this.fastSocket = fastSocket;
        return this;
    }
    
    /**
     * GcfsConfig contains configurations of Google Container File System.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("gcfsConfig")
    public GcfsConfig gcfsConfig;

    public NodeConfig withGcfsConfig(GcfsConfig gcfsConfig) {
        this.gcfsConfig = gcfsConfig;
        return this;
    }
    
    /**
     * Configuration of gVNIC feature.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("gvnic")
    public VirtualNIC gvnic;

    public NodeConfig withGvnic(VirtualNIC gvnic) {
        this.gvnic = gvnic;
        return this;
    }
    
    /**
     * The image type to use for this node. Note that for a given image type, the latest version of it will be used. Please see https://cloud.google.com/kubernetes-engine/docs/concepts/node-images for available image types.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("imageType")
    public String imageType;

    public NodeConfig withImageType(String imageType) {
        this.imageType = imageType;
        return this;
    }
    
    /**
     * Node kubelet configs.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("kubeletConfig")
    public NodeKubeletConfig kubeletConfig;

    public NodeConfig withKubeletConfig(NodeKubeletConfig kubeletConfig) {
        this.kubeletConfig = kubeletConfig;
        return this;
    }
    
    /**
     * The map of Kubernetes labels (key/value pairs) to be applied to each node. These will added in addition to any default label(s) that Kubernetes may apply to the node. In case of conflict in label keys, the applied set may differ depending on the Kubernetes version -- it's best to assume the behavior is undefined and conflicts should be avoided. For more information, including usage and the valid values, see: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("labels")
    public java.util.Map<String, String> labels;

    public NodeConfig withLabels(java.util.Map<String, String> labels) {
        this.labels = labels;
        return this;
    }
    
    /**
     * Parameters that can be configured on Linux nodes.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("linuxNodeConfig")
    public LinuxNodeConfig linuxNodeConfig;

    public NodeConfig withLinuxNodeConfig(LinuxNodeConfig linuxNodeConfig) {
        this.linuxNodeConfig = linuxNodeConfig;
        return this;
    }
    
    /**
     * LocalNvmeSsdBlockConfig contains configuration for using raw-block local NVMe SSDs
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("localNvmeSsdBlockConfig")
    public LocalNvmeSsdBlockConfig localNvmeSsdBlockConfig;

    public NodeConfig withLocalNvmeSsdBlockConfig(LocalNvmeSsdBlockConfig localNvmeSsdBlockConfig) {
        this.localNvmeSsdBlockConfig = localNvmeSsdBlockConfig;
        return this;
    }
    
    /**
     * The number of local SSD disks to be attached to the node. The limit for this value is dependent upon the maximum number of disks available on a machine per zone. See: https://cloud.google.com/compute/docs/disks/local-ssd for more information.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("localSsdCount")
    public Integer localSsdCount;

    public NodeConfig withLocalSsdCount(Integer localSsdCount) {
        this.localSsdCount = localSsdCount;
        return this;
    }
    
    /**
     * NodePoolLoggingConfig specifies logging configuration for nodepools.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("loggingConfig")
    public NodePoolLoggingConfig loggingConfig;

    public NodeConfig withLoggingConfig(NodePoolLoggingConfig loggingConfig) {
        this.loggingConfig = loggingConfig;
        return this;
    }
    
    /**
     * The name of a Google Compute Engine [machine type](https://cloud.google.com/compute/docs/machine-types). If unspecified, the default machine type is `e2-medium`.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("machineType")
    public String machineType;

    public NodeConfig withMachineType(String machineType) {
        this.machineType = machineType;
        return this;
    }
    
    /**
     * The metadata key/value pairs assigned to instances in the cluster. Keys must conform to the regexp `[a-zA-Z0-9-_]+` and be less than 128 bytes in length. These are reflected as part of a URL in the metadata server. Additionally, to avoid ambiguity, keys must not conflict with any other metadata keys for the project or be one of the reserved keys: - "cluster-location" - "cluster-name" - "cluster-uid" - "configure-sh" - "containerd-configure-sh" - "enable-oslogin" - "gci-ensure-gke-docker" - "gci-metrics-enabled" - "gci-update-strategy" - "instance-template" - "kube-env" - "startup-script" - "user-data" - "disable-address-manager" - "windows-startup-script-ps1" - "common-psm1" - "k8s-node-setup-psm1" - "install-ssh-psm1" - "user-profile-psm1" Values are free-form strings, and only have meaning as interpreted by the image running in the instance. The only restriction placed on them is that each value's size must be less than or equal to 32 KB. The total size of all keys and values must be less than 512 KB.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("metadata")
    public java.util.Map<String, String> metadata;

    public NodeConfig withMetadata(java.util.Map<String, String> metadata) {
        this.metadata = metadata;
        return this;
    }
    
    /**
     * Minimum CPU platform to be used by this instance. The instance may be scheduled on the specified or newer CPU platform. Applicable values are the friendly names of CPU platforms, such as `minCpuPlatform: "Intel Haswell"` or `minCpuPlatform: "Intel Sandy Bridge"`. For more information, read [how to specify min CPU platform](https://cloud.google.com/compute/docs/instances/specify-min-cpu-platform).
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("minCpuPlatform")
    public String minCpuPlatform;

    public NodeConfig withMinCpuPlatform(String minCpuPlatform) {
        this.minCpuPlatform = minCpuPlatform;
        return this;
    }
    
    /**
     * Setting this field will assign instances of this pool to run on the specified node group. This is useful for running workloads on [sole tenant nodes](https://cloud.google.com/compute/docs/nodes/sole-tenant-nodes).
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("nodeGroup")
    public String nodeGroup;

    public NodeConfig withNodeGroup(String nodeGroup) {
        this.nodeGroup = nodeGroup;
        return this;
    }
    
    /**
     * The set of Google API scopes to be made available on all of the node VMs under the "default" service account. The following scopes are recommended, but not required, and by default are not included: * `https://www.googleapis.com/auth/compute` is required for mounting persistent storage on your nodes. * `https://www.googleapis.com/auth/devstorage.read_only` is required for communicating with **gcr.io** (the [Google Container Registry](https://cloud.google.com/container-registry/)). If unspecified, no scopes are added, unless Cloud Logging or Cloud Monitoring are enabled, in which case their required scopes will be added.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("oauthScopes")
    public String[] oauthScopes;

    public NodeConfig withOauthScopes(String[] oauthScopes) {
        this.oauthScopes = oauthScopes;
        return this;
    }
    
    /**
     * Whether the nodes are created as preemptible VM instances. See: https://cloud.google.com/compute/docs/instances/preemptible for more inforamtion about preemptible VM instances.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("preemptible")
    public Boolean preemptible;

    public NodeConfig withPreemptible(Boolean preemptible) {
        this.preemptible = preemptible;
        return this;
    }
    
    /**
     * [ReservationAffinity](https://cloud.google.com/compute/docs/instances/reserving-zonal-resources) is the configuration of desired reservation which instances could take capacity from.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("reservationAffinity")
    public ReservationAffinity reservationAffinity;

    public NodeConfig withReservationAffinity(ReservationAffinity reservationAffinity) {
        this.reservationAffinity = reservationAffinity;
        return this;
    }
    
    /**
     * The resource labels for the node pool to use to annotate any related Google Compute Engine resources.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("resourceLabels")
    public java.util.Map<String, String> resourceLabels;

    public NodeConfig withResourceLabels(java.util.Map<String, String> resourceLabels) {
        this.resourceLabels = resourceLabels;
        return this;
    }
    
    /**
     * SandboxConfig contains configurations of the sandbox to use for the node.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("sandboxConfig")
    public SandboxConfig sandboxConfig;

    public NodeConfig withSandboxConfig(SandboxConfig sandboxConfig) {
        this.sandboxConfig = sandboxConfig;
        return this;
    }
    
    /**
     * The Google Cloud Platform Service Account to be used by the node VMs. Specify the email address of the Service Account; otherwise, if no Service Account is specified, the "default" service account is used.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("serviceAccount")
    public String serviceAccount;

    public NodeConfig withServiceAccount(String serviceAccount) {
        this.serviceAccount = serviceAccount;
        return this;
    }
    
    /**
     * A set of Shielded Instance options.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("shieldedInstanceConfig")
    public ShieldedInstanceConfig shieldedInstanceConfig;

    public NodeConfig withShieldedInstanceConfig(ShieldedInstanceConfig shieldedInstanceConfig) {
        this.shieldedInstanceConfig = shieldedInstanceConfig;
        return this;
    }
    
    /**
     * Spot flag for enabling Spot VM, which is a rebrand of the existing preemptible flag.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("spot")
    public Boolean spot;

    public NodeConfig withSpot(Boolean spot) {
        this.spot = spot;
        return this;
    }
    
    /**
     * The list of instance tags applied to all nodes. Tags are used to identify valid sources or targets for network firewalls and are specified by the client during cluster or node pool creation. Each tag within the list must comply with RFC1035.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("tags")
    public String[] tags;

    public NodeConfig withTags(String[] tags) {
        this.tags = tags;
        return this;
    }
    
    /**
     * List of kubernetes taints to be applied to each node. For more information, including usage and the valid values, see: https://kubernetes.io/docs/concepts/configuration/taint-and-toleration/
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("taints")
    public NodeTaint[] taints;

    public NodeConfig withTaints(NodeTaint[] taints) {
        this.taints = taints;
        return this;
    }
    
    /**
     * Parameters that can be configured on Windows nodes. Windows Node Config that define the parameters that will be used to configure the Windows node pool settings
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("windowsNodeConfig")
    public WindowsNodeConfig windowsNodeConfig;

    public NodeConfig withWindowsNodeConfig(WindowsNodeConfig windowsNodeConfig) {
        this.windowsNodeConfig = windowsNodeConfig;
        return this;
    }
    
    /**
     * WorkloadMetadataConfig defines the metadata configuration to expose to workloads on the node pool.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("workloadMetadataConfig")
    public WorkloadMetadataConfig workloadMetadataConfig;

    public NodeConfig withWorkloadMetadataConfig(WorkloadMetadataConfig workloadMetadataConfig) {
        this.workloadMetadataConfig = workloadMetadataConfig;
        return this;
    }
    
    public NodeConfig(){}
}
