<?php

/**
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

declare(strict_types=1);

namespace OpenAPI\OpenAPI;

class Forms 
{

	// SDK private variables namespaced with _ to avoid conflicts with API models
	private \GuzzleHttp\ClientInterface $_defaultClient;
	private \GuzzleHttp\ClientInterface $_securityClient;
	private string $_serverUrl;
	private string $_language;
	private string $_sdkVersion;
	private string $_genVersion;	

	/**
	 * @param \GuzzleHttp\ClientInterface $defaultClient
	 * @param \GuzzleHttp\ClientInterface $securityClient
	 * @param string $serverUrl
	 * @param string $language
	 * @param string $sdkVersion
	 * @param string $genVersion
	 */
	public function __construct(\GuzzleHttp\ClientInterface $defaultClient, \GuzzleHttp\ClientInterface $securityClient, string $serverUrl, string $language, string $sdkVersion, string $genVersion)
	{
		$this->_defaultClient = $defaultClient;
		$this->_securityClient = $securityClient;
		$this->_serverUrl = $serverUrl;
		$this->_language = $language;
		$this->_sdkVersion = $sdkVersion;
		$this->_genVersion = $genVersion;
	}
	
    /**
     * Change the form with a batch of updates.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\FormsFormsBatchUpdateRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\FormsFormsBatchUpdateSecurity $security
     * @return \OpenAPI\OpenAPI\Models\Operations\FormsFormsBatchUpdateResponse
     */
	public function formsFormsBatchUpdate(
        \OpenAPI\OpenAPI\Models\Operations\FormsFormsBatchUpdateRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\FormsFormsBatchUpdateSecurity $security,
    ): \OpenAPI\OpenAPI\Models\Operations\FormsFormsBatchUpdateResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v1/forms/{formId}:batchUpdate', \OpenAPI\OpenAPI\Models\Operations\FormsFormsBatchUpdateRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "batchUpdateFormRequestInput", "json");
        $options = array_merge_recursive($options, $body);
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\FormsFormsBatchUpdateRequest::class, $request, null));
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\FormsFormsBatchUpdateResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->batchUpdateFormResponse = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\BatchUpdateFormResponse', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Create a new form using the title given in the provided form message in the request. *Important:* Only the form.info.title and form.info.document_title fields are copied to the new form. All other fields including the form description, items and settings are disallowed. To create a new form and add items, you must first call forms.create to create an empty form with a title and (optional) document title, and then call forms.update to add the items.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\FormsFormsCreateRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\FormsFormsCreateSecurity $security
     * @return \OpenAPI\OpenAPI\Models\Operations\FormsFormsCreateResponse
     */
	public function formsFormsCreate(
        \OpenAPI\OpenAPI\Models\Operations\FormsFormsCreateRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\FormsFormsCreateSecurity $security,
    ): \OpenAPI\OpenAPI\Models\Operations\FormsFormsCreateResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v1/forms');
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "formInput", "json");
        $options = array_merge_recursive($options, $body);
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\FormsFormsCreateRequest::class, $request, null));
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\FormsFormsCreateResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->form = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\Form', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Get a form.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\FormsFormsGetRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\FormsFormsGetSecurity $security
     * @return \OpenAPI\OpenAPI\Models\Operations\FormsFormsGetResponse
     */
	public function formsFormsGet(
        \OpenAPI\OpenAPI\Models\Operations\FormsFormsGetRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\FormsFormsGetSecurity $security,
    ): \OpenAPI\OpenAPI\Models\Operations\FormsFormsGetResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v1/forms/{formId}', \OpenAPI\OpenAPI\Models\Operations\FormsFormsGetRequest::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\FormsFormsGetRequest::class, $request, null));
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\FormsFormsGetResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->form = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\Form', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Get one response from the form.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\FormsFormsResponsesGetRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\FormsFormsResponsesGetSecurity $security
     * @return \OpenAPI\OpenAPI\Models\Operations\FormsFormsResponsesGetResponse
     */
	public function formsFormsResponsesGet(
        \OpenAPI\OpenAPI\Models\Operations\FormsFormsResponsesGetRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\FormsFormsResponsesGetSecurity $security,
    ): \OpenAPI\OpenAPI\Models\Operations\FormsFormsResponsesGetResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v1/forms/{formId}/responses/{responseId}', \OpenAPI\OpenAPI\Models\Operations\FormsFormsResponsesGetRequest::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\FormsFormsResponsesGetRequest::class, $request, null));
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\FormsFormsResponsesGetResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->formResponse = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\FormResponse', 'json');
            }
        }

        return $response;
    }
	
    /**
     * List a form's responses.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\FormsFormsResponsesListRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\FormsFormsResponsesListSecurity $security
     * @return \OpenAPI\OpenAPI\Models\Operations\FormsFormsResponsesListResponse
     */
	public function formsFormsResponsesList(
        \OpenAPI\OpenAPI\Models\Operations\FormsFormsResponsesListRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\FormsFormsResponsesListSecurity $security,
    ): \OpenAPI\OpenAPI\Models\Operations\FormsFormsResponsesListResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v1/forms/{formId}/responses', \OpenAPI\OpenAPI\Models\Operations\FormsFormsResponsesListRequest::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\FormsFormsResponsesListRequest::class, $request, null));
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\FormsFormsResponsesListResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->listFormResponsesResponse = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\ListFormResponsesResponse', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Create a new watch. If a watch ID is provided, it must be unused. For each invoking project, the per form limit is one watch per Watch.EventType. A watch expires seven days after it is created (see Watch.expire_time).
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\FormsFormsWatchesCreateRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\FormsFormsWatchesCreateSecurity $security
     * @return \OpenAPI\OpenAPI\Models\Operations\FormsFormsWatchesCreateResponse
     */
	public function formsFormsWatchesCreate(
        \OpenAPI\OpenAPI\Models\Operations\FormsFormsWatchesCreateRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\FormsFormsWatchesCreateSecurity $security,
    ): \OpenAPI\OpenAPI\Models\Operations\FormsFormsWatchesCreateResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v1/forms/{formId}/watches', \OpenAPI\OpenAPI\Models\Operations\FormsFormsWatchesCreateRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "createWatchRequestInput", "json");
        $options = array_merge_recursive($options, $body);
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\FormsFormsWatchesCreateRequest::class, $request, null));
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\FormsFormsWatchesCreateResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->watch = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\Watch', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Delete a watch.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\FormsFormsWatchesDeleteRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\FormsFormsWatchesDeleteSecurity $security
     * @return \OpenAPI\OpenAPI\Models\Operations\FormsFormsWatchesDeleteResponse
     */
	public function formsFormsWatchesDelete(
        \OpenAPI\OpenAPI\Models\Operations\FormsFormsWatchesDeleteRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\FormsFormsWatchesDeleteSecurity $security,
    ): \OpenAPI\OpenAPI\Models\Operations\FormsFormsWatchesDeleteResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v1/forms/{formId}/watches/{watchId}', \OpenAPI\OpenAPI\Models\Operations\FormsFormsWatchesDeleteRequest::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\FormsFormsWatchesDeleteRequest::class, $request, null));
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('DELETE', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\FormsFormsWatchesDeleteResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->empty = $serializer->deserialize((string)$httpResponse->getBody(), 'array<string, mixed>', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Return a list of the watches owned by the invoking project. The maximum number of watches is two: For each invoker, the limit is one for each event type per form.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\FormsFormsWatchesListRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\FormsFormsWatchesListSecurity $security
     * @return \OpenAPI\OpenAPI\Models\Operations\FormsFormsWatchesListResponse
     */
	public function formsFormsWatchesList(
        \OpenAPI\OpenAPI\Models\Operations\FormsFormsWatchesListRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\FormsFormsWatchesListSecurity $security,
    ): \OpenAPI\OpenAPI\Models\Operations\FormsFormsWatchesListResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v1/forms/{formId}/watches', \OpenAPI\OpenAPI\Models\Operations\FormsFormsWatchesListRequest::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\FormsFormsWatchesListRequest::class, $request, null));
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\FormsFormsWatchesListResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->listWatchesResponse = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\ListWatchesResponse', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Renew an existing watch for seven days. The state of the watch after renewal is `ACTIVE`, and the `expire_time` is seven days from the renewal. Renewing a watch in an error state (e.g. `SUSPENDED`) succeeds if the error is no longer present, but fail otherwise. After a watch has expired, RenewWatch returns `NOT_FOUND`.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\FormsFormsWatchesRenewRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\FormsFormsWatchesRenewSecurity $security
     * @return \OpenAPI\OpenAPI\Models\Operations\FormsFormsWatchesRenewResponse
     */
	public function formsFormsWatchesRenew(
        \OpenAPI\OpenAPI\Models\Operations\FormsFormsWatchesRenewRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\FormsFormsWatchesRenewSecurity $security,
    ): \OpenAPI\OpenAPI\Models\Operations\FormsFormsWatchesRenewResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v1/forms/{formId}/watches/{watchId}:renew', \OpenAPI\OpenAPI\Models\Operations\FormsFormsWatchesRenewRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "requestBody", "json");
        $options = array_merge_recursive($options, $body);
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\FormsFormsWatchesRenewRequest::class, $request, null));
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\FormsFormsWatchesRenewResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->watch = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\Watch', 'json');
            }
        }

        return $response;
    }
}