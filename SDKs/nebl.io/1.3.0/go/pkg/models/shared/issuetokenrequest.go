// Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.

package shared

// IssueTokenRequestFlags - Object representing flags that potentialy modify this transaction
type IssueTokenRequestFlags struct {
	// If true change will be split into 2 outputs, one for NEBL change and one for NTP1 change (recommended)
	SplitChange *bool `json:"splitChange,omitempty"`
}

type IssueTokenRequestMetadataEncryptions struct {
	// key format (pem or der)
	Format *string `json:"format,omitempty"`
	// userData key to encrypt
	Key *string `json:"key,omitempty"`
	// RSA public key used for encryption
	Pubkey *string `json:"pubkey,omitempty"`
	// pkcs1 or pkcs8
	Type *string `json:"type,omitempty"`
}

// IssueTokenRequestMetadataRulesExpiration - Object describing expiration rules of the token
type IssueTokenRequestMetadataRulesExpiration struct {
	// Whether this rule can be modified in future transactions
	Locked *bool `json:"locked,omitempty"`
	// Blockheight at wh
	ValidUntil *float64 `json:"validUntil,omitempty"`
}

type IssueTokenRequestMetadataRulesFeesItems struct {
	// Address fee is auto sent to
	Address *string `json:"address,omitempty"`
	// How fee should be paid, either with a tokenId, or with NEBL if null
	TokenID *string `json:"tokenId,omitempty"`
	// Amount of NTP1 token, or NEBL (in satoshi) to pay as fee
	Value *string `json:"value,omitempty"`
}

type IssueTokenRequestMetadataRulesFees struct {
	// Array of objects describing fee rules
	Items []IssueTokenRequestMetadataRulesFeesItems `json:"items,omitempty"`
	// Whether this rule can be modified in future transactions
	Locked *bool `json:"locked,omitempty"`
}

type IssueTokenRequestMetadataRulesHolders struct {
	// Address that can hold the token
	Address *string `json:"address,omitempty"`
	// Whether this rule can be modified in future transactions
	Locked *bool `json:"locked,omitempty"`
}

// IssueTokenRequestMetadataRules - Object describing token rules
type IssueTokenRequestMetadataRules struct {
	// Object describing expiration rules of the token
	Expiration *IssueTokenRequestMetadataRulesExpiration `json:"expiration,omitempty"`
	Fees       *IssueTokenRequestMetadataRulesFees       `json:"fees,omitempty"`
	// Array of objects describing what addresses can hold the token
	Holders []IssueTokenRequestMetadataRulesHolders `json:"holders,omitempty"`
}

type IssueTokenRequestMetadataUrls struct {
	// Hash of data at the URL, used for verification
	DataHash *string `json:"dataHash,omitempty"`
	// mimeType of URL content
	MimeType *string `json:"mimeType,omitempty"`
	// Name of the URL
	Name *string `json:"name,omitempty"`
	// Actual URL
	URL *string `json:"url,omitempty"`
}

type IssueTokenRequestMetadataUserDataMeta struct {
	Key   *string `json:"key,omitempty"`
	Value *string `json:"value,omitempty"`
}

// IssueTokenRequestMetadataUserData - Metadata set by user on token
type IssueTokenRequestMetadataUserData struct {
	Meta []IssueTokenRequestMetadataUserDataMeta `json:"meta,omitempty"`
}

// IssueTokenRequestMetadata - Object representing all metadata at token issuance
type IssueTokenRequestMetadata struct {
	// Long name or description of token (ex. Nibble)
	Description *string `json:"description,omitempty"`
	// Array of encryption instruction objects for encrypting userData
	Encryptions []IssueTokenRequestMetadataEncryptions `json:"encryptions,omitempty"`
	// Name of token issuer
	Issuer *string `json:"issuer,omitempty"`
	// Object describing token rules
	Rules *IssueTokenRequestMetadataRules `json:"rules,omitempty"`
	// Token Symbol it will be identified by (ex. NIBBL)
	TokenName *string                         `json:"tokenName,omitempty"`
	Urls      []IssueTokenRequestMetadataUrls `json:"urls,omitempty"`
	// Metadata set by user on token
	UserData *IssueTokenRequestMetadataUserData `json:"userData,omitempty"`
}

type IssueTokenRequestTransfer struct {
	// Address to send the amount of issued tokens to
	Address *string  `json:"address,omitempty"`
	Amount  *float64 `json:"amount,omitempty"`
}

// IssueTokenRequest - Object representing the token to be created
type IssueTokenRequest struct {
	// Number of tokens to issue
	Amount float64 `json:"amount"`
	// Number of decimal places the token should be divisble by (0-7)
	Divisibility float64 `json:"divisibility"`
	// Fee in satoshi to include in the issuance transaction min 1000000000 (10 NEBL)
	Fee float64 `json:"fee"`
	// Object representing flags that potentialy modify this transaction
	Flags *IssueTokenRequestFlags `json:"flags,omitempty"`
	// Address issuing the token
	IssueAddress string `json:"issueAddress"`
	// Object representing all metadata at token issuance
	Metadata *IssueTokenRequestMetadata `json:"metadata,omitempty"`
	// whether the token should be reissuable
	Reissuable bool                        `json:"reissuable"`
	Transfer   []IssueTokenRequestTransfer `json:"transfer"`
}
