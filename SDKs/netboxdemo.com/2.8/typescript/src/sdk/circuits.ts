/*
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

import * as utils from "../internal/utils";
import * as operations from "./models/operations";
import * as shared from "./models/shared";
import { AxiosInstance, AxiosRequestConfig, AxiosResponse } from "axios";

export class Circuits {
  _defaultClient: AxiosInstance;
  _securityClient: AxiosInstance;
  _serverURL: string;
  _language: string;
  _sdkVersion: string;
  _genVersion: string;

  constructor(
    defaultClient: AxiosInstance,
    securityClient: AxiosInstance,
    serverURL: string,
    language: string,
    sdkVersion: string,
    genVersion: string
  ) {
    this._defaultClient = defaultClient;
    this._securityClient = securityClient;
    this._serverURL = serverURL;
    this._language = language;
    this._sdkVersion = sdkVersion;
    this._genVersion = genVersion;
  }

  circuitsCircuitTerminationsCreate(
    req: shared.WritableCircuitTerminationInput,
    config?: AxiosRequestConfig
  ): Promise<operations.CircuitsCircuitTerminationsCreateResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new shared.WritableCircuitTerminationInput(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/circuits/circuit-terminations/";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "request",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CircuitsCircuitTerminationsCreateResponse =
        new operations.CircuitsCircuitTerminationsCreateResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.circuitTermination = utils.objectToClass(
              httpRes?.data,
              shared.CircuitTermination
            );
          }
          break;
      }

      return res;
    });
  }

  circuitsCircuitTerminationsDelete(
    req: operations.CircuitsCircuitTerminationsDeleteRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.CircuitsCircuitTerminationsDeleteResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CircuitsCircuitTerminationsDeleteRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/circuits/circuit-terminations/{id}/",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CircuitsCircuitTerminationsDeleteResponse =
        new operations.CircuitsCircuitTerminationsDeleteResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
      }

      return res;
    });
  }

  /**
   * Call to super to allow for caching
   */
  circuitsCircuitTerminationsList(
    req: operations.CircuitsCircuitTerminationsListRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.CircuitsCircuitTerminationsListResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CircuitsCircuitTerminationsListRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/circuits/circuit-terminations/";

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CircuitsCircuitTerminationsListResponse =
        new operations.CircuitsCircuitTerminationsListResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.circuitsCircuitTerminationsList200ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.CircuitsCircuitTerminationsList200ApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  circuitsCircuitTerminationsPartialUpdate(
    req: operations.CircuitsCircuitTerminationsPartialUpdateRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.CircuitsCircuitTerminationsPartialUpdateResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CircuitsCircuitTerminationsPartialUpdateRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/circuits/circuit-terminations/{id}/",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "writableCircuitTerminationInput",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "patch",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CircuitsCircuitTerminationsPartialUpdateResponse =
        new operations.CircuitsCircuitTerminationsPartialUpdateResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.circuitTermination = utils.objectToClass(
              httpRes?.data,
              shared.CircuitTermination
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Call to super to allow for caching
   */
  circuitsCircuitTerminationsRead(
    req: operations.CircuitsCircuitTerminationsReadRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.CircuitsCircuitTerminationsReadResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CircuitsCircuitTerminationsReadRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/circuits/circuit-terminations/{id}/",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CircuitsCircuitTerminationsReadResponse =
        new operations.CircuitsCircuitTerminationsReadResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.circuitTermination = utils.objectToClass(
              httpRes?.data,
              shared.CircuitTermination
            );
          }
          break;
      }

      return res;
    });
  }

  circuitsCircuitTerminationsUpdate(
    req: operations.CircuitsCircuitTerminationsUpdateRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.CircuitsCircuitTerminationsUpdateResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CircuitsCircuitTerminationsUpdateRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/circuits/circuit-terminations/{id}/",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "writableCircuitTerminationInput",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "put",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CircuitsCircuitTerminationsUpdateResponse =
        new operations.CircuitsCircuitTerminationsUpdateResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.circuitTermination = utils.objectToClass(
              httpRes?.data,
              shared.CircuitTermination
            );
          }
          break;
      }

      return res;
    });
  }

  circuitsCircuitTypesCreate(
    req: shared.CircuitTypeInput,
    config?: AxiosRequestConfig
  ): Promise<operations.CircuitsCircuitTypesCreateResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new shared.CircuitTypeInput(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/circuits/circuit-types/";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "request",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CircuitsCircuitTypesCreateResponse =
        new operations.CircuitsCircuitTypesCreateResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.circuitType = utils.objectToClass(
              httpRes?.data,
              shared.CircuitType
            );
          }
          break;
      }

      return res;
    });
  }

  circuitsCircuitTypesDelete(
    req: operations.CircuitsCircuitTypesDeleteRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.CircuitsCircuitTypesDeleteResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CircuitsCircuitTypesDeleteRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/circuits/circuit-types/{id}/",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CircuitsCircuitTypesDeleteResponse =
        new operations.CircuitsCircuitTypesDeleteResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
      }

      return res;
    });
  }

  /**
   * Call to super to allow for caching
   */
  circuitsCircuitTypesList(
    req: operations.CircuitsCircuitTypesListRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.CircuitsCircuitTypesListResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CircuitsCircuitTypesListRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/circuits/circuit-types/";

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CircuitsCircuitTypesListResponse =
        new operations.CircuitsCircuitTypesListResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.circuitsCircuitTypesList200ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.CircuitsCircuitTypesList200ApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  circuitsCircuitTypesPartialUpdate(
    req: operations.CircuitsCircuitTypesPartialUpdateRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.CircuitsCircuitTypesPartialUpdateResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CircuitsCircuitTypesPartialUpdateRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/circuits/circuit-types/{id}/",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "circuitTypeInput",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "patch",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CircuitsCircuitTypesPartialUpdateResponse =
        new operations.CircuitsCircuitTypesPartialUpdateResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.circuitType = utils.objectToClass(
              httpRes?.data,
              shared.CircuitType
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Call to super to allow for caching
   */
  circuitsCircuitTypesRead(
    req: operations.CircuitsCircuitTypesReadRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.CircuitsCircuitTypesReadResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CircuitsCircuitTypesReadRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/circuits/circuit-types/{id}/",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CircuitsCircuitTypesReadResponse =
        new operations.CircuitsCircuitTypesReadResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.circuitType = utils.objectToClass(
              httpRes?.data,
              shared.CircuitType
            );
          }
          break;
      }

      return res;
    });
  }

  circuitsCircuitTypesUpdate(
    req: operations.CircuitsCircuitTypesUpdateRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.CircuitsCircuitTypesUpdateResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CircuitsCircuitTypesUpdateRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/circuits/circuit-types/{id}/",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "circuitTypeInput",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "put",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CircuitsCircuitTypesUpdateResponse =
        new operations.CircuitsCircuitTypesUpdateResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.circuitType = utils.objectToClass(
              httpRes?.data,
              shared.CircuitType
            );
          }
          break;
      }

      return res;
    });
  }

  circuitsCircuitsCreate(
    req: shared.WritableCircuitInput,
    config?: AxiosRequestConfig
  ): Promise<operations.CircuitsCircuitsCreateResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new shared.WritableCircuitInput(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/circuits/circuits/";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "request",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CircuitsCircuitsCreateResponse =
        new operations.CircuitsCircuitsCreateResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.circuit = utils.objectToClass(httpRes?.data, shared.Circuit);
          }
          break;
      }

      return res;
    });
  }

  circuitsCircuitsDelete(
    req: operations.CircuitsCircuitsDeleteRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.CircuitsCircuitsDeleteResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CircuitsCircuitsDeleteRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/circuits/circuits/{id}/",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CircuitsCircuitsDeleteResponse =
        new operations.CircuitsCircuitsDeleteResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
      }

      return res;
    });
  }

  /**
   * Call to super to allow for caching
   */
  circuitsCircuitsList(
    req: operations.CircuitsCircuitsListRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.CircuitsCircuitsListResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CircuitsCircuitsListRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/circuits/circuits/";

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CircuitsCircuitsListResponse =
        new operations.CircuitsCircuitsListResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.circuitsCircuitsList200ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.CircuitsCircuitsList200ApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  circuitsCircuitsPartialUpdate(
    req: operations.CircuitsCircuitsPartialUpdateRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.CircuitsCircuitsPartialUpdateResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CircuitsCircuitsPartialUpdateRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/circuits/circuits/{id}/",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "writableCircuitInput",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "patch",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CircuitsCircuitsPartialUpdateResponse =
        new operations.CircuitsCircuitsPartialUpdateResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.circuit = utils.objectToClass(httpRes?.data, shared.Circuit);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Call to super to allow for caching
   */
  circuitsCircuitsRead(
    req: operations.CircuitsCircuitsReadRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.CircuitsCircuitsReadResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CircuitsCircuitsReadRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/circuits/circuits/{id}/",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CircuitsCircuitsReadResponse =
        new operations.CircuitsCircuitsReadResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.circuit = utils.objectToClass(httpRes?.data, shared.Circuit);
          }
          break;
      }

      return res;
    });
  }

  circuitsCircuitsUpdate(
    req: operations.CircuitsCircuitsUpdateRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.CircuitsCircuitsUpdateResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CircuitsCircuitsUpdateRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/circuits/circuits/{id}/",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "writableCircuitInput",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "put",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CircuitsCircuitsUpdateResponse =
        new operations.CircuitsCircuitsUpdateResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.circuit = utils.objectToClass(httpRes?.data, shared.Circuit);
          }
          break;
      }

      return res;
    });
  }

  circuitsProvidersCreate(
    req: shared.ProviderInput,
    config?: AxiosRequestConfig
  ): Promise<operations.CircuitsProvidersCreateResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new shared.ProviderInput(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/circuits/providers/";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "request",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CircuitsProvidersCreateResponse =
        new operations.CircuitsProvidersCreateResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.provider = utils.objectToClass(httpRes?.data, shared.Provider);
          }
          break;
      }

      return res;
    });
  }

  circuitsProvidersDelete(
    req: operations.CircuitsProvidersDeleteRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.CircuitsProvidersDeleteResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CircuitsProvidersDeleteRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/circuits/providers/{id}/",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CircuitsProvidersDeleteResponse =
        new operations.CircuitsProvidersDeleteResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
      }

      return res;
    });
  }

  /**
   * A convenience method for rendering graphs for a particular provider.
   */
  circuitsProvidersGraphs(
    req: operations.CircuitsProvidersGraphsRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.CircuitsProvidersGraphsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CircuitsProvidersGraphsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/circuits/providers/{id}/graphs/",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CircuitsProvidersGraphsResponse =
        new operations.CircuitsProvidersGraphsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.provider = utils.objectToClass(httpRes?.data, shared.Provider);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Call to super to allow for caching
   */
  circuitsProvidersList(
    req: operations.CircuitsProvidersListRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.CircuitsProvidersListResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CircuitsProvidersListRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/circuits/providers/";

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CircuitsProvidersListResponse =
        new operations.CircuitsProvidersListResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.circuitsProvidersList200ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.CircuitsProvidersList200ApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  circuitsProvidersPartialUpdate(
    req: operations.CircuitsProvidersPartialUpdateRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.CircuitsProvidersPartialUpdateResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CircuitsProvidersPartialUpdateRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/circuits/providers/{id}/",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "providerInput",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "patch",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CircuitsProvidersPartialUpdateResponse =
        new operations.CircuitsProvidersPartialUpdateResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.provider = utils.objectToClass(httpRes?.data, shared.Provider);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Call to super to allow for caching
   */
  circuitsProvidersRead(
    req: operations.CircuitsProvidersReadRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.CircuitsProvidersReadResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CircuitsProvidersReadRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/circuits/providers/{id}/",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CircuitsProvidersReadResponse =
        new operations.CircuitsProvidersReadResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.provider = utils.objectToClass(httpRes?.data, shared.Provider);
          }
          break;
      }

      return res;
    });
  }

  circuitsProvidersUpdate(
    req: operations.CircuitsProvidersUpdateRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.CircuitsProvidersUpdateResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CircuitsProvidersUpdateRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/circuits/providers/{id}/",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "providerInput",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "put",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CircuitsProvidersUpdateResponse =
        new operations.CircuitsProvidersUpdateResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.provider = utils.objectToClass(httpRes?.data, shared.Provider);
          }
          break;
      }

      return res;
    });
  }
}
