// Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.

package operations

import (
	"encoding/json"
	"fmt"
	"net/http"
)

// PostNetworksIDActionsAddSubnetAddSubnetRequestTypeEnum - Type of Subnetwork
type PostNetworksIDActionsAddSubnetAddSubnetRequestTypeEnum string

const (
	PostNetworksIDActionsAddSubnetAddSubnetRequestTypeEnumCloud   PostNetworksIDActionsAddSubnetAddSubnetRequestTypeEnum = "cloud"
	PostNetworksIDActionsAddSubnetAddSubnetRequestTypeEnumServer  PostNetworksIDActionsAddSubnetAddSubnetRequestTypeEnum = "server"
	PostNetworksIDActionsAddSubnetAddSubnetRequestTypeEnumVswitch PostNetworksIDActionsAddSubnetAddSubnetRequestTypeEnum = "vswitch"
)

func (e PostNetworksIDActionsAddSubnetAddSubnetRequestTypeEnum) ToPointer() *PostNetworksIDActionsAddSubnetAddSubnetRequestTypeEnum {
	return &e
}

func (e *PostNetworksIDActionsAddSubnetAddSubnetRequestTypeEnum) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "cloud":
		fallthrough
	case "server":
		fallthrough
	case "vswitch":
		*e = PostNetworksIDActionsAddSubnetAddSubnetRequestTypeEnum(v)
		return nil
	default:
		return fmt.Errorf("invalid value for PostNetworksIDActionsAddSubnetAddSubnetRequestTypeEnum: %v", v)
	}
}

type PostNetworksIDActionsAddSubnetAddSubnetRequest struct {
	// Range to allocate IPs from. Must be a Subnet of the ip_range of the parent network object and must not overlap with any other subnets or with any destinations in routes. If the Subnet is of type vSwitch, it also can not overlap with any gateway in routes. Minimum Network size is /30. We suggest that you pick a bigger Network with a /24 netmask.
	IPRange *string `json:"ip_range,omitempty"`
	// Name of Network zone. The Location object contains the `network_zone` property each Location belongs to.
	NetworkZone string `json:"network_zone"`
	// Type of Subnetwork
	Type PostNetworksIDActionsAddSubnetAddSubnetRequestTypeEnum `json:"type"`
	// ID of the robot vSwitch. Must be supplied if the subnet is of type vswitch.
	VswitchID *int64 `json:"vswitch_id,omitempty"`
}

type PostNetworksIDActionsAddSubnetRequest struct {
	RequestBody *PostNetworksIDActionsAddSubnetAddSubnetRequest `request:"mediaType=application/json"`
	// ID of the Network
	ID int64 `pathParam:"style=simple,explode=false,name=id"`
}

// PostNetworksIDActionsAddSubnetActionResponseActionError - Error message for the Action if error occurred, otherwise null
type PostNetworksIDActionsAddSubnetActionResponseActionError struct {
	// Fixed machine readable code
	Code string `json:"code"`
	// Humanized error message
	Message string `json:"message"`
}

type PostNetworksIDActionsAddSubnetActionResponseActionResources struct {
	// ID of the Resource
	ID int64 `json:"id"`
	// Type of resource referenced
	Type string `json:"type"`
}

// PostNetworksIDActionsAddSubnetActionResponseActionStatusEnum - Status of the Action
type PostNetworksIDActionsAddSubnetActionResponseActionStatusEnum string

const (
	PostNetworksIDActionsAddSubnetActionResponseActionStatusEnumSuccess PostNetworksIDActionsAddSubnetActionResponseActionStatusEnum = "success"
	PostNetworksIDActionsAddSubnetActionResponseActionStatusEnumRunning PostNetworksIDActionsAddSubnetActionResponseActionStatusEnum = "running"
	PostNetworksIDActionsAddSubnetActionResponseActionStatusEnumError   PostNetworksIDActionsAddSubnetActionResponseActionStatusEnum = "error"
)

func (e PostNetworksIDActionsAddSubnetActionResponseActionStatusEnum) ToPointer() *PostNetworksIDActionsAddSubnetActionResponseActionStatusEnum {
	return &e
}

func (e *PostNetworksIDActionsAddSubnetActionResponseActionStatusEnum) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "success":
		fallthrough
	case "running":
		fallthrough
	case "error":
		*e = PostNetworksIDActionsAddSubnetActionResponseActionStatusEnum(v)
		return nil
	default:
		return fmt.Errorf("invalid value for PostNetworksIDActionsAddSubnetActionResponseActionStatusEnum: %v", v)
	}
}

type PostNetworksIDActionsAddSubnetActionResponseAction struct {
	// Command executed in the Action
	Command string `json:"command"`
	// Error message for the Action if error occurred, otherwise null
	Error PostNetworksIDActionsAddSubnetActionResponseActionError `json:"error"`
	// Point in time when the Action was finished (in ISO-8601 format). Only set if the Action is finished otherwise null.
	Finished string `json:"finished"`
	// ID of the Resource
	ID int64 `json:"id"`
	// Progress of Action in percent
	Progress float64 `json:"progress"`
	// Resources the Action relates to
	Resources []PostNetworksIDActionsAddSubnetActionResponseActionResources `json:"resources"`
	// Point in time when the Action was started (in ISO-8601 format)
	Started string `json:"started"`
	// Status of the Action
	Status PostNetworksIDActionsAddSubnetActionResponseActionStatusEnum `json:"status"`
}

// PostNetworksIDActionsAddSubnetActionResponse - The `action` key contains the `add_subnet` Action
type PostNetworksIDActionsAddSubnetActionResponse struct {
	Action PostNetworksIDActionsAddSubnetActionResponseAction `json:"action"`
}

type PostNetworksIDActionsAddSubnetResponse struct {
	// The `action` key contains the `add_subnet` Action
	ActionResponse *PostNetworksIDActionsAddSubnetActionResponse
	ContentType    string
	StatusCode     int
	RawResponse    *http.Response
}
