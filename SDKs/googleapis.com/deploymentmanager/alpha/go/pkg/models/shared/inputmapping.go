// Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.

package shared

import (
	"encoding/json"
	"fmt"
)

// InputMappingLocationEnum - The location where this mapping applies.
type InputMappingLocationEnum string

const (
	InputMappingLocationEnumUnknown InputMappingLocationEnum = "UNKNOWN"
	InputMappingLocationEnumPath    InputMappingLocationEnum = "PATH"
	InputMappingLocationEnumQuery   InputMappingLocationEnum = "QUERY"
	InputMappingLocationEnumBody    InputMappingLocationEnum = "BODY"
	InputMappingLocationEnumHeader  InputMappingLocationEnum = "HEADER"
)

func (e *InputMappingLocationEnum) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return err
	}
	switch s {
	case "UNKNOWN":
		fallthrough
	case "PATH":
		fallthrough
	case "QUERY":
		fallthrough
	case "BODY":
		fallthrough
	case "HEADER":
		*e = InputMappingLocationEnum(s)
		return nil
	default:
		return fmt.Errorf("invalid value for InputMappingLocationEnum: %s", s)
	}
}

// InputMapping - InputMapping creates a 'virtual' property that will be injected into the properties before sending the request to the underlying API.
type InputMapping struct {
	// The name of the field that is going to be injected.
	FieldName *string `json:"fieldName,omitempty"`
	// The location where this mapping applies.
	Location *InputMappingLocationEnum `json:"location,omitempty"`
	// Regex to evaluate on method to decide if input applies.
	MethodMatch *string `json:"methodMatch,omitempty"`
	// A jsonPath expression to select an element.
	Value *string `json:"value,omitempty"`
}
