/*
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

import * as utils from "../internal/utils";
import * as operations from "./models/operations";
import * as shared from "./models/shared";
import { AxiosInstance, AxiosRequestConfig, AxiosResponse } from "axios";

export class Articles {
  _defaultClient: AxiosInstance;
  _securityClient: AxiosInstance;
  _serverURL: string;
  _language: string;
  _sdkVersion: string;
  _genVersion: string;

  constructor(
    defaultClient: AxiosInstance,
    securityClient: AxiosInstance,
    serverURL: string,
    language: string,
    sdkVersion: string,
    genVersion: string
  ) {
    this._defaultClient = defaultClient;
    this._securityClient = securityClient;
    this._serverURL = serverURL;
    this._language = language;
    this._sdkVersion = sdkVersion;
    this._genVersion = genVersion;
  }

  /**
   * Account Article Report
   *
   * @remarks
   * Return status on all reports generated for the account from the oauth credentials
   */
  accountArticleReport(
    req: operations.AccountArticleReportRequest,
    security: operations.AccountArticleReportSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.AccountArticleReportResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.AccountArticleReportRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/account/articles/export";
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.AccountArticleReportSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.AccountArticleReportResponse =
        new operations.AccountArticleReportResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.accountReports = [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.accountReports = utils.objectToClass(
              httpRes?.data,
              shared.AccountReport,
              resFieldDepth
            );
          }
          break;
        case [400, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Initiate a new Report
   *
   * @remarks
   * Initiate a new Article Report for this Account. There is a limit of 1 report per day.
   */
  accountArticleReportGenerate(
    config?: AxiosRequestConfig
  ): Promise<operations.AccountArticleReportGenerateResponse> {
    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/account/articles/export";

    const client: AxiosInstance = this._defaultClient;

    const r = client.request({
      url: url,
      method: "post",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.AccountArticleReportGenerateResponse =
        new operations.AccountArticleReportGenerateResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.accountReport = utils.objectToClass(
              httpRes?.data,
              shared.AccountReport
            );
          }
          break;
        case [429, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * View article details
   *
   * @remarks
   * View an article
   */
  articleDetails(
    req: operations.ArticleDetailsRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.ArticleDetailsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ArticleDetailsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/articles/{article_id}",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ArticleDetailsResponse =
        new operations.ArticleDetailsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.articleComplete = utils.objectToClass(
              httpRes?.data,
              shared.ArticleComplete
            );
          }
          break;
        case [400, 404, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Article file details
   *
   * @remarks
   * File by id
   */
  articleFileDetails(
    req: operations.ArticleFileDetailsRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.ArticleFileDetailsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ArticleFileDetailsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/articles/{article_id}/files/{file_id}",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ArticleFileDetailsResponse =
        new operations.ArticleFileDetailsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.publicFile = utils.objectToClass(
              httpRes?.data,
              shared.PublicFile
            );
          }
          break;
        case [400, 404, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * List article files
   *
   * @remarks
   * Files list for article
   */
  articleFiles(
    req: operations.ArticleFilesRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.ArticleFilesResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ArticleFilesRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/articles/{article_id}/files",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ArticleFilesResponse =
        new operations.ArticleFilesResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.publicFiles = [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.publicFiles = utils.objectToClass(
              httpRes?.data,
              shared.PublicFile,
              resFieldDepth
            );
          }
          break;
        case [400, 404, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Public Article Confidentiality for article version
   *
   * @remarks
   * Confidentiality for article version. The confidentiality feature is now deprecated. This has been replaced by the new extended embargo functionality and all items that used to be confidential have now been migrated to items with a permanent embargo on files. All API endpoints related to this functionality will remain for backwards compatibility, but will now be attached to the new extended embargo workflows.
   */
  articleVersionConfidentiality(
    req: operations.ArticleVersionConfidentialityRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.ArticleVersionConfidentialityResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ArticleVersionConfidentialityRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/articles/{article_id}/versions/{v_number}/confidentiality",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ArticleVersionConfidentialityResponse =
        new operations.ArticleVersionConfidentialityResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.articleConfidentiality = utils.objectToClass(
              httpRes?.data,
              shared.ArticleConfidentiality
            );
          }
          break;
        case [400, 404, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Article details for version
   *
   * @remarks
   * Article with specified version
   */
  articleVersionDetails(
    req: operations.ArticleVersionDetailsRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.ArticleVersionDetailsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ArticleVersionDetailsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/articles/{article_id}/versions/{v_number}",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ArticleVersionDetailsResponse =
        new operations.ArticleVersionDetailsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.articleComplete = utils.objectToClass(
              httpRes?.data,
              shared.ArticleComplete
            );
          }
          break;
        case [400, 404, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Public Article Embargo for article version
   *
   * @remarks
   * Embargo for article version
   */
  articleVersionEmbargo(
    req: operations.ArticleVersionEmbargoRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.ArticleVersionEmbargoResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ArticleVersionEmbargoRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/articles/{article_id}/versions/{v_number}/embargo",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ArticleVersionEmbargoResponse =
        new operations.ArticleVersionEmbargoResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.articleEmbargo = utils.objectToClass(
              httpRes?.data,
              shared.ArticleEmbargo
            );
          }
          break;
        case [400, 404, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Update article version
   *
   * @remarks
   * Updating an article version by passing body parameters; request can also be made with the PATCH method.
   */
  articleVersionUpdate(
    req: operations.ArticleVersionUpdateRequest,
    security: operations.ArticleVersionUpdateSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.ArticleVersionUpdateResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ArticleVersionUpdateRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/account/articles/{article_id}/versions/{version_id}/",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "articleUpdate",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ArticleVersionUpdateSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "put",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ArticleVersionUpdateResponse =
        new operations.ArticleVersionUpdateResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
          headers: utils.getHeadersFromResponse(httpRes.headers),
        });
      switch (true) {
        case httpRes?.status == 205:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.locationWarningsUpdate = utils.objectToClass(
              httpRes?.data,
              shared.LocationWarningsUpdate
            );
          }
          break;
        case httpRes?.status == 403:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorMessage = utils.objectToClass(
              httpRes?.data,
              shared.ErrorMessage
            );
          }
          break;
        case [404, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Update article version thumbnail
   *
   * @remarks
   * For a given public article version update the article thumbnail by choosing one of the associated files
   */
  articleVersionUpdateThumb(
    req: operations.ArticleVersionUpdateThumbRequest,
    security: operations.ArticleVersionUpdateThumbSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.ArticleVersionUpdateThumbResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ArticleVersionUpdateThumbRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/account/articles/{article_id}/versions/{version_id}/update_thumb",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "fileId",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ArticleVersionUpdateThumbSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "put",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ArticleVersionUpdateThumbResponse =
        new operations.ArticleVersionUpdateThumbResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
          headers: utils.getHeadersFromResponse(httpRes.headers),
        });
      switch (true) {
        case httpRes?.status == 205:
          break;
        case httpRes?.status == 403:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorMessage = utils.objectToClass(
              httpRes?.data,
              shared.ErrorMessage
            );
          }
          break;
        case [404, 422].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * List article versions
   *
   * @remarks
   * List public article versions
   */
  articleVersions(
    req: operations.ArticleVersionsRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.ArticleVersionsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ArticleVersionsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/articles/{article_id}/versions",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ArticleVersionsResponse =
        new operations.ArticleVersionsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.articleVersions = [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.articleVersions = utils.objectToClass(
              httpRes?.data,
              shared.ArticleVersions,
              resFieldDepth
            );
          }
          break;
        case [400, 404, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Public Articles
   *
   * @remarks
   * Returns a list of public articles
   */
  articlesList(
    req: operations.ArticlesListRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.ArticlesListResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ArticlesListRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/articles";

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      headers: headers,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ArticlesListResponse =
        new operations.ArticlesListResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
          headers: utils.getHeadersFromResponse(httpRes.headers),
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.articles = [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.articles = utils.objectToClass(
              httpRes?.data,
              shared.Article,
              resFieldDepth
            );
          }
          break;
        case [400, 422, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Public Articles Search
   *
   * @remarks
   * Returns a list of public articles, filtered by the search parameters
   */
  articlesSearch(
    req: operations.ArticlesSearchRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.ArticlesSearchResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ArticlesSearchRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/articles/search";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "articleSearch",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._defaultClient;

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ArticlesSearchResponse =
        new operations.ArticlesSearchResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
          headers: utils.getHeadersFromResponse(httpRes.headers),
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.articleWithProjects = [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.articleWithProjects = utils.objectToClass(
              httpRes?.data,
              shared.ArticleWithProject,
              resFieldDepth
            );
          }
          break;
        case [400, 422, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Delete article author
   *
   * @remarks
   * De-associate author from article
   */
  privateArticleAuthorDelete(
    req: operations.PrivateArticleAuthorDeleteRequest,
    security: operations.PrivateArticleAuthorDeleteSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.PrivateArticleAuthorDeleteResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PrivateArticleAuthorDeleteRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/account/articles/{article_id}/authors/{author_id}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.PrivateArticleAuthorDeleteSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PrivateArticleAuthorDeleteResponse =
        new operations.PrivateArticleAuthorDeleteResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case [204, 404, 500].includes(httpRes?.status):
          break;
        case httpRes?.status == 403:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorMessage = utils.objectToClass(
              httpRes?.data,
              shared.ErrorMessage
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Add article authors
   *
   * @remarks
   * Associate new authors with the article. This will add new authors to the list of already associated authors
   */
  privateArticleAuthorsAdd(
    req: operations.PrivateArticleAuthorsAddRequest,
    security: operations.PrivateArticleAuthorsAddSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.PrivateArticleAuthorsAddResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PrivateArticleAuthorsAddRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/account/articles/{article_id}/authors",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "authorsCreator",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.PrivateArticleAuthorsAddSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PrivateArticleAuthorsAddResponse =
        new operations.PrivateArticleAuthorsAddResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
          headers: utils.getHeadersFromResponse(httpRes.headers),
        });
      switch (true) {
        case httpRes?.status == 205:
          break;
        case [400, 404, 500].includes(httpRes?.status):
          break;
        case httpRes?.status == 403:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorMessage = utils.objectToClass(
              httpRes?.data,
              shared.ErrorMessage
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * List article authors
   *
   * @remarks
   * List article authors
   */
  privateArticleAuthorsList(
    req: operations.PrivateArticleAuthorsListRequest,
    security: operations.PrivateArticleAuthorsListSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.PrivateArticleAuthorsListResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PrivateArticleAuthorsListRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/account/articles/{article_id}/authors",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.PrivateArticleAuthorsListSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PrivateArticleAuthorsListResponse =
        new operations.PrivateArticleAuthorsListResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.authors = [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.authors = utils.objectToClass(
              httpRes?.data,
              shared.Author,
              resFieldDepth
            );
          }
          break;
        case [400, 404, 500].includes(httpRes?.status):
          break;
        case httpRes?.status == 403:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorMessage = utils.objectToClass(
              httpRes?.data,
              shared.ErrorMessage
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Replace article authors
   *
   * @remarks
   * Associate new authors with the article. This will remove all already associated authors and add these new ones
   */
  privateArticleAuthorsReplace(
    req: operations.PrivateArticleAuthorsReplaceRequest,
    security: operations.PrivateArticleAuthorsReplaceSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.PrivateArticleAuthorsReplaceResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PrivateArticleAuthorsReplaceRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/account/articles/{article_id}/authors",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "authorsCreator",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.PrivateArticleAuthorsReplaceSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "put",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PrivateArticleAuthorsReplaceResponse =
        new operations.PrivateArticleAuthorsReplaceResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
          headers: utils.getHeadersFromResponse(httpRes.headers),
        });
      switch (true) {
        case httpRes?.status == 205:
          break;
        case [400, 404, 500].includes(httpRes?.status):
          break;
        case httpRes?.status == 403:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorMessage = utils.objectToClass(
              httpRes?.data,
              shared.ErrorMessage
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Add article categories
   *
   * @remarks
   * Associate new categories with the article. This will add new categories to the list of already associated categories
   */
  privateArticleCategoriesAdd(
    req: operations.PrivateArticleCategoriesAddRequest,
    security: operations.PrivateArticleCategoriesAddSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.PrivateArticleCategoriesAddResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PrivateArticleCategoriesAddRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/account/articles/{article_id}/categories",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "categoriesCreator",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.PrivateArticleCategoriesAddSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PrivateArticleCategoriesAddResponse =
        new operations.PrivateArticleCategoriesAddResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case [205, 400, 404, 500].includes(httpRes?.status):
          break;
        case httpRes?.status == 403:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorMessage = utils.objectToClass(
              httpRes?.data,
              shared.ErrorMessage
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * List article categories
   *
   * @remarks
   * List article categories
   */
  privateArticleCategoriesList(
    req: operations.PrivateArticleCategoriesListRequest,
    security: operations.PrivateArticleCategoriesListSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.PrivateArticleCategoriesListResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PrivateArticleCategoriesListRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/account/articles/{article_id}/categories",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.PrivateArticleCategoriesListSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PrivateArticleCategoriesListResponse =
        new operations.PrivateArticleCategoriesListResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.categories = [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.categories = utils.objectToClass(
              httpRes?.data,
              shared.Category,
              resFieldDepth
            );
          }
          break;
        case [400, 404, 500].includes(httpRes?.status):
          break;
        case httpRes?.status == 403:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorMessage = utils.objectToClass(
              httpRes?.data,
              shared.ErrorMessage
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Replace article categories
   *
   * @remarks
   * Associate new categories with the article. This will remove all already associated categories and add these new ones
   */
  privateArticleCategoriesReplace(
    req: operations.PrivateArticleCategoriesReplaceRequest,
    security: operations.PrivateArticleCategoriesReplaceSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.PrivateArticleCategoriesReplaceResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PrivateArticleCategoriesReplaceRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/account/articles/{article_id}/categories",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "categoriesCreator",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.PrivateArticleCategoriesReplaceSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "put",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PrivateArticleCategoriesReplaceResponse =
        new operations.PrivateArticleCategoriesReplaceResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case [205, 400, 404, 500].includes(httpRes?.status):
          break;
        case httpRes?.status == 403:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorMessage = utils.objectToClass(
              httpRes?.data,
              shared.ErrorMessage
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Delete article category
   *
   * @remarks
   * De-associate category from article
   */
  privateArticleCategoryDelete(
    req: operations.PrivateArticleCategoryDeleteRequest,
    security: operations.PrivateArticleCategoryDeleteSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.PrivateArticleCategoryDeleteResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PrivateArticleCategoryDeleteRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/account/articles/{article_id}/categories/{category_id}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.PrivateArticleCategoryDeleteSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PrivateArticleCategoryDeleteResponse =
        new operations.PrivateArticleCategoryDeleteResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case [204, 404, 500].includes(httpRes?.status):
          break;
        case httpRes?.status == 403:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorMessage = utils.objectToClass(
              httpRes?.data,
              shared.ErrorMessage
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Delete article confidentiality
   *
   * @remarks
   * Delete confidentiality settings. The confidentiality feature is now deprecated. This has been replaced by the new extended embargo functionality and all items that used to be confidential have now been migrated to items with a permanent embargo on files. All API endpoints related to this functionality will remain for backwards compatibility, but will now be attached to the new extended embargo workflows.
   */
  privateArticleConfidentialityDelete(
    req: operations.PrivateArticleConfidentialityDeleteRequest,
    security: operations.PrivateArticleConfidentialityDeleteSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.PrivateArticleConfidentialityDeleteResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PrivateArticleConfidentialityDeleteRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/account/articles/{article_id}/confidentiality",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.PrivateArticleConfidentialityDeleteSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PrivateArticleConfidentialityDeleteResponse =
        new operations.PrivateArticleConfidentialityDeleteResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case [204, 400, 404, 500].includes(httpRes?.status):
          break;
        case httpRes?.status == 403:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorMessage = utils.objectToClass(
              httpRes?.data,
              shared.ErrorMessage
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Article confidentiality details
   *
   * @remarks
   * View confidentiality settings. The confidentiality feature is now deprecated. This has been replaced by the new extended embargo functionality and all items that used to be confidential have now been migrated to items with a permanent embargo on files. All API endpoints related to this functionality will remain for backwards compatibility, but will now be attached to the new extended embargo workflows.
   */
  privateArticleConfidentialityDetails(
    req: operations.PrivateArticleConfidentialityDetailsRequest,
    security: operations.PrivateArticleConfidentialityDetailsSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.PrivateArticleConfidentialityDetailsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PrivateArticleConfidentialityDetailsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/account/articles/{article_id}/confidentiality",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.PrivateArticleConfidentialityDetailsSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PrivateArticleConfidentialityDetailsResponse =
        new operations.PrivateArticleConfidentialityDetailsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.articleConfidentiality = utils.objectToClass(
              httpRes?.data,
              shared.ArticleConfidentiality
            );
          }
          break;
        case [400, 404, 500].includes(httpRes?.status):
          break;
        case httpRes?.status == 403:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorMessage = utils.objectToClass(
              httpRes?.data,
              shared.ErrorMessage
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Update article confidentiality
   *
   * @remarks
   * Update confidentiality settings. The confidentiality feature is now deprecated. This has been replaced by the new extended embargo functionality and all items that used to be confidential have now been migrated to items with a permanent embargo on files. All API endpoints related to this functionality will remain for backwards compatibility, but will now be attached to the new extended embargo workflows.
   */
  privateArticleConfidentialityUpdate(
    req: operations.PrivateArticleConfidentialityUpdateRequest,
    security: operations.PrivateArticleConfidentialityUpdateSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.PrivateArticleConfidentialityUpdateResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PrivateArticleConfidentialityUpdateRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/account/articles/{article_id}/confidentiality",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "confidentialityCreator",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.PrivateArticleConfidentialityUpdateSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "put",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PrivateArticleConfidentialityUpdateResponse =
        new operations.PrivateArticleConfidentialityUpdateResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case [205, 400, 404, 500].includes(httpRes?.status):
          break;
        case httpRes?.status == 403:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorMessage = utils.objectToClass(
              httpRes?.data,
              shared.ErrorMessage
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Create new Article
   *
   * @remarks
   * Create a new Article by sending article information
   */
  privateArticleCreate(
    req: shared.ArticleCreate,
    security: operations.PrivateArticleCreateSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.PrivateArticleCreateResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new shared.ArticleCreate(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/account/articles";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "request",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.PrivateArticleCreateSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PrivateArticleCreateResponse =
        new operations.PrivateArticleCreateResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.locationWarnings = utils.objectToClass(
              httpRes?.data,
              shared.LocationWarnings
            );
          }
          break;
        case [400, 500].includes(httpRes?.status):
          break;
        case httpRes?.status == 403:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorMessage = utils.objectToClass(
              httpRes?.data,
              shared.ErrorMessage
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Delete article
   *
   * @remarks
   * Delete an article
   */
  privateArticleDelete(
    req: operations.PrivateArticleDeleteRequest,
    security: operations.PrivateArticleDeleteSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.PrivateArticleDeleteResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PrivateArticleDeleteRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/account/articles/{article_id}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.PrivateArticleDeleteSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PrivateArticleDeleteResponse =
        new operations.PrivateArticleDeleteResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case [204, 404, 500].includes(httpRes?.status):
          break;
        case httpRes?.status == 403:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorMessage = utils.objectToClass(
              httpRes?.data,
              shared.ErrorMessage
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Article details
   *
   * @remarks
   * View a private article
   */
  privateArticleDetails(
    req: operations.PrivateArticleDetailsRequest,
    security: operations.PrivateArticleDetailsSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.PrivateArticleDetailsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PrivateArticleDetailsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/account/articles/{article_id}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.PrivateArticleDetailsSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PrivateArticleDetailsResponse =
        new operations.PrivateArticleDetailsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.articleCompletePrivate = utils.objectToClass(
              httpRes?.data,
              shared.ArticleCompletePrivate
            );
          }
          break;
        case [400, 404, 500].includes(httpRes?.status):
          break;
        case httpRes?.status == 403:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorMessage = utils.objectToClass(
              httpRes?.data,
              shared.ErrorMessage
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Delete Article Embargo
   *
   * @remarks
   * Will lift the embargo for the specified article
   */
  privateArticleEmbargoDelete(
    req: operations.PrivateArticleEmbargoDeleteRequest,
    security: operations.PrivateArticleEmbargoDeleteSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.PrivateArticleEmbargoDeleteResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PrivateArticleEmbargoDeleteRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/account/articles/{article_id}/embargo",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.PrivateArticleEmbargoDeleteSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PrivateArticleEmbargoDeleteResponse =
        new operations.PrivateArticleEmbargoDeleteResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case [204, 404, 500].includes(httpRes?.status):
          break;
        case httpRes?.status == 403:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorMessage = utils.objectToClass(
              httpRes?.data,
              shared.ErrorMessage
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Article Embargo Details
   *
   * @remarks
   * View a private article embargo details
   */
  privateArticleEmbargoDetails(
    req: operations.PrivateArticleEmbargoDetailsRequest,
    security: operations.PrivateArticleEmbargoDetailsSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.PrivateArticleEmbargoDetailsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PrivateArticleEmbargoDetailsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/account/articles/{article_id}/embargo",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.PrivateArticleEmbargoDetailsSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PrivateArticleEmbargoDetailsResponse =
        new operations.PrivateArticleEmbargoDetailsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.articleEmbargo = utils.objectToClass(
              httpRes?.data,
              shared.ArticleEmbargo
            );
          }
          break;
        case [400, 404, 500].includes(httpRes?.status):
          break;
        case httpRes?.status == 403:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorMessage = utils.objectToClass(
              httpRes?.data,
              shared.ErrorMessage
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Update Article Embargo
   *
   * @remarks
   * Note: setting an article under whole embargo does not imply that the article will be published when the embargo will expire. You must explicitly call the publish endpoint to enable this functionality.
   */
  privateArticleEmbargoUpdate(
    req: operations.PrivateArticleEmbargoUpdateRequest,
    security: operations.PrivateArticleEmbargoUpdateSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.PrivateArticleEmbargoUpdateResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PrivateArticleEmbargoUpdateRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/account/articles/{article_id}/embargo",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "articleEmbargoUpdater",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.PrivateArticleEmbargoUpdateSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "put",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PrivateArticleEmbargoUpdateResponse =
        new operations.PrivateArticleEmbargoUpdateResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
          headers: utils.getHeadersFromResponse(httpRes.headers),
        });
      switch (true) {
        case httpRes?.status == 205:
          break;
        case [400, 404, 500].includes(httpRes?.status):
          break;
        case httpRes?.status == 403:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorMessage = utils.objectToClass(
              httpRes?.data,
              shared.ErrorMessage
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Single File
   *
   * @remarks
   * View details of file for specified article
   */
  privateArticleFile(
    req: operations.PrivateArticleFileRequest,
    security: operations.PrivateArticleFileSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.PrivateArticleFileResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PrivateArticleFileRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/account/articles/{article_id}/files/{file_id}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.PrivateArticleFileSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PrivateArticleFileResponse =
        new operations.PrivateArticleFileResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.privateFile = utils.objectToClass(
              httpRes?.data,
              shared.PrivateFile
            );
          }
          break;
        case [400, 404, 500].includes(httpRes?.status):
          break;
        case httpRes?.status == 403:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorMessage = utils.objectToClass(
              httpRes?.data,
              shared.ErrorMessage
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * File Delete
   *
   * @remarks
   * Complete file upload
   */
  privateArticleFileDelete(
    req: operations.PrivateArticleFileDeleteRequest,
    security: operations.PrivateArticleFileDeleteSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.PrivateArticleFileDeleteResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PrivateArticleFileDeleteRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/account/articles/{article_id}/files/{file_id}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.PrivateArticleFileDeleteSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PrivateArticleFileDeleteResponse =
        new operations.PrivateArticleFileDeleteResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case [204, 400, 404, 500].includes(httpRes?.status):
          break;
        case httpRes?.status == 403:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorMessage = utils.objectToClass(
              httpRes?.data,
              shared.ErrorMessage
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * List article files
   *
   * @remarks
   * List private files
   */
  privateArticleFilesList(
    req: operations.PrivateArticleFilesListRequest,
    security: operations.PrivateArticleFilesListSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.PrivateArticleFilesListResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PrivateArticleFilesListRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/account/articles/{article_id}/files",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.PrivateArticleFilesListSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PrivateArticleFilesListResponse =
        new operations.PrivateArticleFilesListResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.privateFiles = [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.privateFiles = utils.objectToClass(
              httpRes?.data,
              shared.PrivateFile,
              resFieldDepth
            );
          }
          break;
        case [400, 404, 500].includes(httpRes?.status):
          break;
        case httpRes?.status == 403:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorMessage = utils.objectToClass(
              httpRes?.data,
              shared.ErrorMessage
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * List private links
   *
   * @remarks
   * List private links
   */
  privateArticlePrivateLink(
    req: operations.PrivateArticlePrivateLinkRequest,
    security: operations.PrivateArticlePrivateLinkSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.PrivateArticlePrivateLinkResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PrivateArticlePrivateLinkRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/account/articles/{article_id}/private_links",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.PrivateArticlePrivateLinkSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PrivateArticlePrivateLinkResponse =
        new operations.PrivateArticlePrivateLinkResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.privateLinks = [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.privateLinks = utils.objectToClass(
              httpRes?.data,
              shared.PrivateLink,
              resFieldDepth
            );
          }
          break;
        case [400, 404, 500].includes(httpRes?.status):
          break;
        case httpRes?.status == 403:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorMessage = utils.objectToClass(
              httpRes?.data,
              shared.ErrorMessage
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Create private link
   *
   * @remarks
   * Create new private link for this article
   */
  privateArticlePrivateLinkCreate(
    req: operations.PrivateArticlePrivateLinkCreateRequest,
    security: operations.PrivateArticlePrivateLinkCreateSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.PrivateArticlePrivateLinkCreateResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PrivateArticlePrivateLinkCreateRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/account/articles/{article_id}/private_links",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "privateLinkCreator",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.PrivateArticlePrivateLinkCreateSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PrivateArticlePrivateLinkCreateResponse =
        new operations.PrivateArticlePrivateLinkCreateResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
          headers: utils.getHeadersFromResponse(httpRes.headers),
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.privateLinkResponse = utils.objectToClass(
              httpRes?.data,
              shared.PrivateLinkResponse
            );
          }
          break;
        case [400, 404, 422, 500].includes(httpRes?.status):
          break;
        case httpRes?.status == 403:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorMessage = utils.objectToClass(
              httpRes?.data,
              shared.ErrorMessage
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Disable private link
   *
   * @remarks
   * Disable/delete private link for this article
   */
  privateArticlePrivateLinkDelete(
    req: operations.PrivateArticlePrivateLinkDeleteRequest,
    security: operations.PrivateArticlePrivateLinkDeleteSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.PrivateArticlePrivateLinkDeleteResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PrivateArticlePrivateLinkDeleteRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/account/articles/{article_id}/private_links/{link_id}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.PrivateArticlePrivateLinkDeleteSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PrivateArticlePrivateLinkDeleteResponse =
        new operations.PrivateArticlePrivateLinkDeleteResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case [204, 400, 404, 500].includes(httpRes?.status):
          break;
        case httpRes?.status == 403:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorMessage = utils.objectToClass(
              httpRes?.data,
              shared.ErrorMessage
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Update private link
   *
   * @remarks
   * Update existing private link for this article
   */
  privateArticlePrivateLinkUpdate(
    req: operations.PrivateArticlePrivateLinkUpdateRequest,
    security: operations.PrivateArticlePrivateLinkUpdateSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.PrivateArticlePrivateLinkUpdateResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PrivateArticlePrivateLinkUpdateRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/account/articles/{article_id}/private_links/{link_id}",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "privateLinkCreator",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.PrivateArticlePrivateLinkUpdateSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "put",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PrivateArticlePrivateLinkUpdateResponse =
        new operations.PrivateArticlePrivateLinkUpdateResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
          headers: utils.getHeadersFromResponse(httpRes.headers),
        });
      switch (true) {
        case httpRes?.status == 205:
          break;
        case [400, 404, 422, 500].includes(httpRes?.status):
          break;
        case httpRes?.status == 403:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorMessage = utils.objectToClass(
              httpRes?.data,
              shared.ErrorMessage
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Private Article Publish
   *
   * @remarks
   * - If the whole article is under embargo, it will not be published immediately, but when the embargo expires or is lifted.
   * - When an article is published, a new public version will be generated. Any further updates to the article will affect the private article data. In order to make these changes publicly visible, an explicit publish operation is needed.
   */
  privateArticlePublish(
    req: operations.PrivateArticlePublishRequest,
    security: operations.PrivateArticlePublishSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.PrivateArticlePublishResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PrivateArticlePublishRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/account/articles/{article_id}/publish",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.PrivateArticlePublishSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "post",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PrivateArticlePublishResponse =
        new operations.PrivateArticlePublishResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
          headers: utils.getHeadersFromResponse(httpRes.headers),
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.location = utils.objectToClass(httpRes?.data, shared.Location);
          }
          break;
        case [400, 404, 500].includes(httpRes?.status):
          break;
        case httpRes?.status == 403:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorMessage = utils.objectToClass(
              httpRes?.data,
              shared.ErrorMessage
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Private Article Reserve DOI
   *
   * @remarks
   * Reserve DOI for article
   */
  privateArticleReserveDoi(
    req: operations.PrivateArticleReserveDoiRequest,
    security: operations.PrivateArticleReserveDoiSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.PrivateArticleReserveDoiResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PrivateArticleReserveDoiRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/account/articles/{article_id}/reserve_doi",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.PrivateArticleReserveDoiSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "post",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PrivateArticleReserveDoiResponse =
        new operations.PrivateArticleReserveDoiResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.articleDOI = utils.objectToClass(
              httpRes?.data,
              shared.ArticleDOI
            );
          }
          break;
        case [400, 404, 500].includes(httpRes?.status):
          break;
        case httpRes?.status == 403:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorMessage = utils.objectToClass(
              httpRes?.data,
              shared.ErrorMessage
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Private Article Reserve Handle
   *
   * @remarks
   * Reserve Handle for article
   */
  privateArticleReserveHandle(
    req: operations.PrivateArticleReserveHandleRequest,
    security: operations.PrivateArticleReserveHandleSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.PrivateArticleReserveHandleResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PrivateArticleReserveHandleRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/account/articles/{article_id}/reserve_handle",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.PrivateArticleReserveHandleSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "post",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PrivateArticleReserveHandleResponse =
        new operations.PrivateArticleReserveHandleResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.articleHandle = utils.objectToClass(
              httpRes?.data,
              shared.ArticleHandle
            );
          }
          break;
        case [400, 404, 500].includes(httpRes?.status):
          break;
        case httpRes?.status == 403:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorMessage = utils.objectToClass(
              httpRes?.data,
              shared.ErrorMessage
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Private Article Resource
   *
   * @remarks
   * Edit article resource data.
   */
  privateArticleResource(
    req: operations.PrivateArticleResourceRequest,
    security: operations.PrivateArticleResourceSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.PrivateArticleResourceResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PrivateArticleResourceRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/account/articles/{article_id}/resource",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "resource",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.PrivateArticleResourceSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PrivateArticleResourceResponse =
        new operations.PrivateArticleResourceResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
          headers: utils.getHeadersFromResponse(httpRes.headers),
        });
      switch (true) {
        case httpRes?.status == 205:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.location = utils.objectToClass(httpRes?.data, shared.Location);
          }
          break;
        case [400, 404, 422].includes(httpRes?.status):
          break;
        case httpRes?.status == 403:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorMessage = utils.objectToClass(
              httpRes?.data,
              shared.ErrorMessage
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Update article
   *
   * @remarks
   * Updating an article by passing body parameters; request can also be made with the PATCH method.
   */
  privateArticleUpdate(
    req: operations.PrivateArticleUpdateRequest,
    security: operations.PrivateArticleUpdateSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.PrivateArticleUpdateResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PrivateArticleUpdateRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/account/articles/{article_id}",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "articleUpdate",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.PrivateArticleUpdateSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "put",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PrivateArticleUpdateResponse =
        new operations.PrivateArticleUpdateResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
          headers: utils.getHeadersFromResponse(httpRes.headers),
        });
      switch (true) {
        case httpRes?.status == 205:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.locationWarningsUpdate = utils.objectToClass(
              httpRes?.data,
              shared.LocationWarningsUpdate
            );
          }
          break;
        case httpRes?.status == 403:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorMessage = utils.objectToClass(
              httpRes?.data,
              shared.ErrorMessage
            );
          }
          break;
        case [404, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Complete Upload
   *
   * @remarks
   * Complete file upload
   */
  privateArticleUploadComplete(
    req: operations.PrivateArticleUploadCompleteRequest,
    security: operations.PrivateArticleUploadCompleteSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.PrivateArticleUploadCompleteResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PrivateArticleUploadCompleteRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/account/articles/{article_id}/files/{file_id}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.PrivateArticleUploadCompleteSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "post",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PrivateArticleUploadCompleteResponse =
        new operations.PrivateArticleUploadCompleteResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case [202, 400, 404, 500].includes(httpRes?.status):
          break;
        case httpRes?.status == 403:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorMessage = utils.objectToClass(
              httpRes?.data,
              shared.ErrorMessage
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Initiate Upload
   *
   * @remarks
   * Initiate a new file upload within the article. Either use the link property to point to an existing file that resides elsewhere and will not be uploaded to Figshare or use the other 3 parameters (md5, name, size).
   */
  privateArticleUploadInitiate(
    req: operations.PrivateArticleUploadInitiateRequest,
    security: operations.PrivateArticleUploadInitiateSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.PrivateArticleUploadInitiateResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PrivateArticleUploadInitiateRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/account/articles/{article_id}/files",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "fileCreator",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.PrivateArticleUploadInitiateSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PrivateArticleUploadInitiateResponse =
        new operations.PrivateArticleUploadInitiateResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
          headers: utils.getHeadersFromResponse(httpRes.headers),
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.location = utils.objectToClass(httpRes?.data, shared.Location);
          }
          break;
        case [400, 404, 422, 500].includes(httpRes?.status):
          break;
        case httpRes?.status == 403:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorMessage = utils.objectToClass(
              httpRes?.data,
              shared.ErrorMessage
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Private Articles
   *
   * @remarks
   * Get Own Articles
   */
  privateArticlesList(
    req: operations.PrivateArticlesListRequest,
    security: operations.PrivateArticlesListSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.PrivateArticlesListResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PrivateArticlesListRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/account/articles";
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.PrivateArticlesListSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PrivateArticlesListResponse =
        new operations.PrivateArticlesListResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.articles = [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.articles = utils.objectToClass(
              httpRes?.data,
              shared.Article,
              resFieldDepth
            );
          }
          break;
        case [400, 500].includes(httpRes?.status):
          break;
        case httpRes?.status == 403:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorMessage = utils.objectToClass(
              httpRes?.data,
              shared.ErrorMessage
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Private Articles search
   *
   * @remarks
   * Returns a list of private articles filtered by the search parameters
   */
  privateArticlesSearch(
    req: shared.PrivateArticleSearch,
    security: operations.PrivateArticlesSearchSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.PrivateArticlesSearchResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new shared.PrivateArticleSearch(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/account/articles/search";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "request",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.PrivateArticlesSearchSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PrivateArticlesSearchResponse =
        new operations.PrivateArticlesSearchResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.articleWithProjects = [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.articleWithProjects = utils.objectToClass(
              httpRes?.data,
              shared.ArticleWithProject,
              resFieldDepth
            );
          }
          break;
        case [400, 500].includes(httpRes?.status):
          break;
        case httpRes?.status == 403:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorMessage = utils.objectToClass(
              httpRes?.data,
              shared.ErrorMessage
            );
          }
          break;
      }

      return res;
    });
  }
}
