// Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.

package shared

import (
	"encoding/json"
	"fmt"
	"openapi/pkg/types"
)

// PayCodePayCodeNominalCode - The pay codes' nominal code
type PayCodePayCodeNominalCode struct {
	// The links' href
	AtHref *string `json:"@href,omitempty"`
	// The links' target type
	AtRel *string `json:"@rel,omitempty"`
	// The links' title
	AtTitle *string `json:"@title,omitempty"`
}

// PayCodePayCodeRegionEnum - The pay codes' region
type PayCodePayCodeRegionEnum string

const (
	PayCodePayCodeRegionEnumNotSet   PayCodePayCodeRegionEnum = "NotSet"
	PayCodePayCodeRegionEnumEngland  PayCodePayCodeRegionEnum = "England"
	PayCodePayCodeRegionEnumScotland PayCodePayCodeRegionEnum = "Scotland"
	PayCodePayCodeRegionEnumWales    PayCodePayCodeRegionEnum = "Wales"
)

func (e *PayCodePayCodeRegionEnum) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return err
	}
	switch s {
	case "NotSet":
		fallthrough
	case "England":
		fallthrough
	case "Scotland":
		fallthrough
	case "Wales":
		*e = PayCodePayCodeRegionEnum(s)
		return nil
	default:
		return fmt.Errorf("invalid value for PayCodePayCodeRegionEnum: %s", s)
	}
}

// PayCodePayCodeTerritoryEnum - The pay codes' territory
type PayCodePayCodeTerritoryEnum string

const (
	PayCodePayCodeTerritoryEnumUnitedKingdom PayCodePayCodeTerritoryEnum = "UnitedKingdom"
)

func (e *PayCodePayCodeTerritoryEnum) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return err
	}
	switch s {
	case "UnitedKingdom":
		*e = PayCodePayCodeTerritoryEnum(s)
		return nil
	default:
		return fmt.Errorf("invalid value for PayCodePayCodeTerritoryEnum: %s", s)
	}
}

// PayCodePayCodeTypeEnum - The pay codes' type
type PayCodePayCodeTypeEnum string

const (
	PayCodePayCodeTypeEnumNotSet    PayCodePayCodeTypeEnum = "NotSet"
	PayCodePayCodeTypeEnumPayment   PayCodePayCodeTypeEnum = "Payment"
	PayCodePayCodeTypeEnumDeduction PayCodePayCodeTypeEnum = "Deduction"
)

func (e *PayCodePayCodeTypeEnum) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return err
	}
	switch s {
	case "NotSet":
		fallthrough
	case "Payment":
		fallthrough
	case "Deduction":
		*e = PayCodePayCodeTypeEnum(s)
		return nil
	default:
		return fmt.Errorf("invalid value for PayCodePayCodeTypeEnum: %s", s)
	}
}

type PayCodePayCode struct {
	// The pay codes' benefit
	Benefit *bool `json:"Benefit,omitempty"`
	// The pay codes' code
	Code *string `json:"Code,omitempty"`
	// The pay codes' description
	Description *string `json:"Description,omitempty"`
	// The pay codes' effective date
	EffectiveDate *types.Date `json:"EffectiveDate,omitempty"`
	// The pay codes' meta data
	MetaData map[string]interface{} `json:"MetaData,omitempty"`
	// The pay codes' niable
	Niable *bool `json:"Niable,omitempty"`
	// The pay codes' nominal code
	NominalCode *PayCodePayCodeNominalCode `json:"NominalCode,omitempty"`
	// The pay codes' non arrestable
	NonArrestable *bool `json:"NonArrestable,omitempty"`
	// The pay codes' notional
	Notional *bool `json:"Notional,omitempty"`
	// The pay codes' readonly
	Readonly *bool `json:"Readonly,omitempty"`
	// The pay codes' region
	Region *PayCodePayCodeRegionEnum `json:"Region,omitempty"`
	// The pay codes' revision
	Revision *int `json:"Revision,omitempty"`
	// The pay codes' taxable
	Taxable *bool `json:"Taxable,omitempty"`
	// The pay codes' territory
	Territory *PayCodePayCodeTerritoryEnum `json:"Territory,omitempty"`
	// The pay codes' type
	Type *PayCodePayCodeTypeEnum `json:"Type,omitempty"`
}

// PayCode - The pay code object.
type PayCode struct {
	PayCode *PayCodePayCode `json:"PayCode,omitempty"`
}
