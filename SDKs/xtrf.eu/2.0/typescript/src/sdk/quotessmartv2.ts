/*
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

import * as utils from "../internal/utils";
import * as operations from "./models/operations";
import * as shared from "./models/shared";
import { AxiosInstance, AxiosRequestConfig, AxiosResponse } from "axios";

/**
 * To change the description use /examples/TagsDescriptions.json
 */
export class QuotesSmartV2 {
  _defaultClient: AxiosInstance;
  _securityClient: AxiosInstance;
  _serverURL: string;
  _language: string;
  _sdkVersion: string;
  _genVersion: string;

  constructor(
    defaultClient: AxiosInstance,
    securityClient: AxiosInstance,
    serverURL: string,
    language: string,
    sdkVersion: string,
    genVersion: string
  ) {
    this._defaultClient = defaultClient;
    this._securityClient = securityClient;
    this._serverURL = serverURL;
    this._language = language;
    this._sdkVersion = sdkVersion;
    this._genVersion = genVersion;
  }

  /**
   * Adds files to the quote as added by PM.
   *
   * @remarks
   * Adds files to the quote as added by PM. The files have to be uploaded beforehand (see "POST v2/quotes/{quoteId}/files/upload" operation). The following properties can be specified for each file:<ul><li>category (required, 400 Bad Request is returned otherwise)</li><li>languageIds – when the file category depends on a list of languages</li><li>languageCombinationIds – when the file category depends on a list of language combinations</li></ul>
   */
  addFiles2(
    req: operations.AddFiles2Request,
    config?: AxiosRequestConfig
  ): Promise<operations.AddFiles2Response> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.AddFiles2Request(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v2/quotes/{quoteId}/files/add",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "timeDTO",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "put",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.AddFiles2Response =
        new operations.AddFiles2Response({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
      }

      return res;
    });
  }

  /**
   * Prepares a ZIP archive that contains the specified files.
   *
   * @remarks
   * Prepares a ZIP archive that contains the specified files.
   */
  archive1(
    req: shared.FilesDto,
    config?: AxiosRequestConfig
  ): Promise<operations.Archive1Response> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new shared.FilesDto(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/v2/quotes/files/archive";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "request",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.Archive1Response = new operations.Archive1Response({
        statusCode: httpRes.status,
        contentType: contentType,
        rawResponse: httpRes,
      });
      switch (true) {
        default:
          if (
            utils.matchContentType(
              contentType,
              `application/json;charset=UTF-8`
            )
          ) {
            res.filesArchiveDto = utils.objectToClass(
              httpRes?.data,
              shared.FilesArchiveDto
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Changes quote status if possible (400 Bad Request is returned otherwise).
   *
   * @remarks
   * Changes quote status if possible (400 Bad Request is returned otherwise). The status has to be specified using one of the following keys: <ul><li>PENDING – available when the job has one of the following statuses: REQUESTED, REJECTED</li><li>SENT – available when the job has one of the following statuses: PENDING</li><li>APPROVED – available when the job has one of the following statuses: REQUESTED, PENDING, SENT, APPROVED_BY_CLIENT</li><li>REJECTED – available when the job has one of the following statuses: REQUESTED, PENDING, SENT</li></ul>
   */
  changeStatus3(
    req: operations.ChangeStatus3Request,
    config?: AxiosRequestConfig
  ): Promise<operations.ChangeStatus3Response> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ChangeStatus3Request(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v2/quotes/{quoteId}/status",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "projectStatusDTO",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "put",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ChangeStatus3Response =
        new operations.ChangeStatus3Response({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
      }

      return res;
    });
  }

  /**
   * Adds a payable to a quote.
   *
   * @remarks
   * Adds a payable to a quote.
   */
  createPayable3(
    req: operations.CreatePayable3Request,
    config?: AxiosRequestConfig
  ): Promise<operations.CreatePayable3Response> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CreatePayable3Request(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v2/quotes/{quoteId}/finance/payables",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "payableCreateDTO",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CreatePayable3Response =
        new operations.CreatePayable3Response({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.payableDTO = utils.objectToClass(
              httpRes?.data,
              shared.PayableDTO
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Adds a receivable to a quote.
   *
   * @remarks
   * Adds a receivable to a quote.
   */
  createReceivable3(
    req: operations.CreateReceivable3Request,
    config?: AxiosRequestConfig
  ): Promise<operations.CreateReceivable3Response> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CreateReceivable3Request(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v2/quotes/{quoteId}/finance/receivables",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "receivableCreateDTO",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CreateReceivable3Response =
        new operations.CreateReceivable3Response({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.receivableDTO = utils.objectToClass(
              httpRes?.data,
              shared.ReceivableDTO
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Creates a new Smart Quote.
   *
   * @remarks
   * Creates a new Smart Quote. If the specified service ID refers to Classic Quote, 400 Bad Request is returned instead.
   */
  create7(
    req: shared.QuoteCreateDTO,
    config?: AxiosRequestConfig
  ): Promise<operations.Create7Response> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new shared.QuoteCreateDTO(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/v2/quotes";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "request",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.Create7Response = new operations.Create7Response({
        statusCode: httpRes.status,
        contentType: contentType,
        rawResponse: httpRes,
      });
      switch (true) {
        case httpRes?.status == 201:
          if (
            utils.matchContentType(
              contentType,
              `application/json;charset=UTF-8`
            )
          ) {
            res.quoteDTOv2 = utils.objectToClass(
              httpRes?.data,
              shared.QuoteDTOv2
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Deletes a payable.
   *
   * @remarks
   * Deletes a payable.
   */
  deletePayable3(
    req: operations.DeletePayable3Request,
    config?: AxiosRequestConfig
  ): Promise<operations.DeletePayable3Response> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DeletePayable3Request(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v2/quotes/{quoteId}/finance/payables/{payableId}",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DeletePayable3Response =
        new operations.DeletePayable3Response({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
      }

      return res;
    });
  }

  /**
   * Deletes a receivable.
   *
   * @remarks
   * Deletes a receivable.
   */
  deleteReceivable3(
    req: operations.DeleteReceivable3Request,
    config?: AxiosRequestConfig
  ): Promise<operations.DeleteReceivable3Response> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DeleteReceivable3Request(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v2/quotes/{quoteId}/finance/receivables/{receivableId}",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DeleteReceivable3Response =
        new operations.DeleteReceivable3Response({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
      }

      return res;
    });
  }

  /**
   * Returns quote details.
   *
   * @remarks
   * Returns quote details. If the specified quote ID refers to Classic Quote, 400 Bad Request is returned instead.
   */
  getById10(
    req: operations.GetById10Request,
    config?: AxiosRequestConfig
  ): Promise<operations.GetById10Response> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetById10Request(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(baseURL, "/v2/quotes/{quoteId}", req);

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetById10Response =
        new operations.GetById10Response({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        default:
          if (
            utils.matchContentType(
              contentType,
              `application/json;charset=UTF-8`
            )
          ) {
            res.quoteDTOv2 = utils.objectToClass(
              httpRes?.data,
              shared.QuoteDTOv2
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Returns Client Contacts information for a quote.
   *
   * @remarks
   * Returns Client Contacts information for a quote.
   */
  getContacts3(
    req: operations.GetContacts3Request,
    config?: AxiosRequestConfig
  ): Promise<operations.GetContacts3Response> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetContacts3Request(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v2/quotes/{quoteId}/clientContacts",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetContacts3Response =
        new operations.GetContacts3Response({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        default:
          if (
            utils.matchContentType(
              contentType,
              `application/json;charset=UTF-8`
            )
          ) {
            res.smartContactsDTO = utils.objectToClass(
              httpRes?.data,
              shared.SmartContactsDTO
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Returns a list of custom field keys and values for a project.
   *
   * @remarks
   * Returns a list of custom field keys and values for a project.
   */
  getCustomFields9(
    req: operations.GetCustomFields9Request,
    config?: AxiosRequestConfig
  ): Promise<operations.GetCustomFields9Response> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetCustomFields9Request(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v2/quotes/{quoteId}/customFields",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetCustomFields9Response =
        new operations.GetCustomFields9Response({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        default:
          if (
            utils.matchContentType(
              contentType,
              `application/json;charset=UTF-8`
            )
          ) {
            res.customFieldsDTO = [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.customFieldsDTO = utils.objectToClass(
              httpRes?.data,
              shared.CustomFieldDTO,
              resFieldDepth
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Returns details of a file.
   *
   * @remarks
   * Returns details of a file.
   */
  getFileById3(
    req: operations.GetFileById3Request,
    config?: AxiosRequestConfig
  ): Promise<operations.GetFileById3Response> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetFileById3Request(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v2/quotes/files/{fileId}",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetFileById3Response =
        new operations.GetFileById3Response({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        default:
          if (
            utils.matchContentType(
              contentType,
              `application/json;charset=UTF-8`
            )
          ) {
            res.projectFileDto = utils.objectToClass(
              httpRes?.data,
              shared.ProjectFileDto
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Downloads a file content.
   *
   * @remarks
   * Downloads a file content.
   */
  getFileContentById1(
    req: operations.GetFileContentById1Request,
    config?: AxiosRequestConfig
  ): Promise<operations.GetFileContentById1Response> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetFileContentById1Request(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v2/quotes/files/{fileId}/download/{fileName}",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetFileContentById1Response =
        new operations.GetFileContentById1Response({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        default:
          break;
      }

      return res;
    });
  }

  /**
   * Returns list of files in a quote.
   *
   * @remarks
   * Returns list of files in a quote. Only files added to the quote (i.e. files that have assigned category and languages) are listed.
   */
  getFiles1(
    req: operations.GetFiles1Request,
    config?: AxiosRequestConfig
  ): Promise<operations.GetFiles1Response> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetFiles1Request(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v2/quotes/{quoteId}/files",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetFiles1Response =
        new operations.GetFiles1Response({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        default:
          if (
            utils.matchContentType(
              contentType,
              `application/json;charset=UTF-8`
            )
          ) {
            res.projectFileDtos = [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.projectFileDtos = utils.objectToClass(
              httpRes?.data,
              shared.ProjectFileDto,
              resFieldDepth
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Returns finance information for a quote.
   *
   * @remarks
   * Returns finance information for a quote.
   */
  getFinance3(
    req: operations.GetFinance3Request,
    config?: AxiosRequestConfig
  ): Promise<operations.GetFinance3Response> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetFinance3Request(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v2/quotes/{quoteId}/finance",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetFinance3Response =
        new operations.GetFinance3Response({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        default:
          if (
            utils.matchContentType(
              contentType,
              `application/json;charset=UTF-8`
            )
          ) {
            res.financeDTO = utils.objectToClass(
              httpRes?.data,
              shared.FinanceDTO
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Returns list of jobs in a quote.
   *
   * @remarks
   * Returns list of jobs in a quote.
   */
  getJobs1(
    req: operations.GetJobs1Request,
    config?: AxiosRequestConfig
  ): Promise<operations.GetJobs1Response> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetJobs1Request(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v2/quotes/{quoteId}/jobs",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetJobs1Response = new operations.GetJobs1Response({
        statusCode: httpRes.status,
        contentType: contentType,
        rawResponse: httpRes,
      });
      switch (true) {
        default:
          if (
            utils.matchContentType(
              contentType,
              `application/json;charset=UTF-8`
            )
          ) {
            res.jobDtos = [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.jobDtos = utils.objectToClass(
              httpRes?.data,
              shared.JobDto,
              resFieldDepth
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Updates Business Days for a quote.
   *
   * @remarks
   * Updates Business Days for a quote.
   */
  updateBusinessDays(
    req: operations.UpdateBusinessDaysRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.UpdateBusinessDaysResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.UpdateBusinessDaysRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v2/quotes/{quoteId}/businessDays",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "put",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UpdateBusinessDaysResponse =
        new operations.UpdateBusinessDaysResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
      }

      return res;
    });
  }

  /**
   * Updates Client Notes for a quote.
   *
   * @remarks
   * Updates Client Notes for a quote.
   */
  updateClientNotes1(
    req: operations.UpdateClientNotes1Request,
    config?: AxiosRequestConfig
  ): Promise<operations.UpdateClientNotes1Response> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.UpdateClientNotes1Request(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v2/quotes/{quoteId}/clientNotes",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "stringDTO",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "put",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UpdateClientNotes1Response =
        new operations.UpdateClientNotes1Response({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
      }

      return res;
    });
  }

  /**
   * Updates Client Reference Number for a quote.
   *
   * @remarks
   * Updates Client Reference Number for a quote.
   */
  updateClientReferenceNumber1(
    req: operations.UpdateClientReferenceNumber1Request,
    config?: AxiosRequestConfig
  ): Promise<operations.UpdateClientReferenceNumber1Response> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.UpdateClientReferenceNumber1Request(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v2/quotes/{quoteId}/clientReferenceNumber",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "stringDTO",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "put",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UpdateClientReferenceNumber1Response =
        new operations.UpdateClientReferenceNumber1Response({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
      }

      return res;
    });
  }

  /**
   * Updates Client Contacts for a quote.
   *
   * @remarks
   * Updates Client Contacts for a quote.
   */
  updateContacts3(
    req: operations.UpdateContacts3Request,
    config?: AxiosRequestConfig
  ): Promise<operations.UpdateContacts3Response> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.UpdateContacts3Request(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v2/quotes/{quoteId}/clientContacts",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "smartContactsDTO",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "put",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UpdateContacts3Response =
        new operations.UpdateContacts3Response({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        default:
          if (
            utils.matchContentType(
              contentType,
              `application/json;charset=UTF-8`
            )
          ) {
            res.smartContactsDTO = utils.objectToClass(
              httpRes?.data,
              shared.SmartContactsDTO
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Updates a custom field with a specified key in a quote.
   *
   * @remarks
   * Updates a custom field with a specified key in a quote.
   */
  updateCustomField3(
    req: operations.UpdateCustomField3Request,
    config?: AxiosRequestConfig
  ): Promise<operations.UpdateCustomField3Response> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.UpdateCustomField3Request(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v2/quotes/{quoteId}/customFields/{key}",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "smartCustomFieldDTO",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "put",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UpdateCustomField3Response =
        new operations.UpdateCustomField3Response({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
      }

      return res;
    });
  }

  /**
   * Updates Expected Delivery Date for a quote.
   *
   * @remarks
   * Updates Expected Delivery Date for a quote.
   */
  updateExpectedDeliveryDate(
    req: operations.UpdateExpectedDeliveryDateRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.UpdateExpectedDeliveryDateResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.UpdateExpectedDeliveryDateRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v2/quotes/{quoteId}/expectedDeliveryDate",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "timeDTO",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "put",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UpdateExpectedDeliveryDateResponse =
        new operations.UpdateExpectedDeliveryDateResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
      }

      return res;
    });
  }

  /**
   * Updates Internal Notes for a quote.
   *
   * @remarks
   * Updates Internal Notes for a quote.
   */
  updateInternalNotes1(
    req: operations.UpdateInternalNotes1Request,
    config?: AxiosRequestConfig
  ): Promise<operations.UpdateInternalNotes1Response> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.UpdateInternalNotes1Request(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v2/quotes/{quoteId}/internalNotes",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "stringDTO",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "put",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UpdateInternalNotes1Response =
        new operations.UpdateInternalNotes1Response({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
      }

      return res;
    });
  }

  /**
   * Updates a payable.
   *
   * @remarks
   * Updates a payable.
   */
  updatePayable3(
    req: operations.UpdatePayable3Request,
    config?: AxiosRequestConfig
  ): Promise<operations.UpdatePayable3Response> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.UpdatePayable3Request(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v2/quotes/{quoteId}/finance/payables/{payableId}",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "payableDTO",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "put",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UpdatePayable3Response =
        new operations.UpdatePayable3Response({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.payableDTO = utils.objectToClass(
              httpRes?.data,
              shared.PayableDTO
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Updates Quote Expiry Date for a quote.
   *
   * @remarks
   * Updates Quote Expiry Date for a quote.
   */
  updateQuoteExpiry(
    req: operations.UpdateQuoteExpiryRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.UpdateQuoteExpiryResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.UpdateQuoteExpiryRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v2/quotes/{quoteId}/quoteExpiry",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "timeDTO",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "put",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UpdateQuoteExpiryResponse =
        new operations.UpdateQuoteExpiryResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
      }

      return res;
    });
  }

  /**
   * Updates a receivable.
   *
   * @remarks
   * Updates a receivable.
   */
  updateReceivable3(
    req: operations.UpdateReceivable3Request,
    config?: AxiosRequestConfig
  ): Promise<operations.UpdateReceivable3Response> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.UpdateReceivable3Request(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v2/quotes/{quoteId}/finance/receivables/{receivableId}",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "receivableDTO",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "put",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UpdateReceivable3Response =
        new operations.UpdateReceivable3Response({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.receivableDTO = utils.objectToClass(
              httpRes?.data,
              shared.ReceivableDTO
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Updates source language for a quote.
   *
   * @remarks
   * Updates source language for a quote.
   */
  updateSourceLanguage1(
    req: operations.UpdateSourceLanguage1Request,
    config?: AxiosRequestConfig
  ): Promise<operations.UpdateSourceLanguage1Response> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.UpdateSourceLanguage1Request(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v2/quotes/{quoteId}/sourceLanguage",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "sourceLanguageDTO",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "put",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UpdateSourceLanguage1Response =
        new operations.UpdateSourceLanguage1Response({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
      }

      return res;
    });
  }

  /**
   * Updates specialization for a quote.
   *
   * @remarks
   * Updates specialization for a quote.
   */
  updateSpecialization1(
    req: operations.UpdateSpecialization1Request,
    config?: AxiosRequestConfig
  ): Promise<operations.UpdateSpecialization1Response> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.UpdateSpecialization1Request(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v2/quotes/{quoteId}/specialization",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "specializationDTO",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "put",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UpdateSpecialization1Response =
        new operations.UpdateSpecialization1Response({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
      }

      return res;
    });
  }

  /**
   * Updates target languages for a quote.
   *
   * @remarks
   * Updates target languages for a quote.
   */
  updateTargetLanguages1(
    req: operations.UpdateTargetLanguages1Request,
    config?: AxiosRequestConfig
  ): Promise<operations.UpdateTargetLanguages1Response> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.UpdateTargetLanguages1Request(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v2/quotes/{quoteId}/targetLanguages",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "targetLanguagesDTO",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "put",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UpdateTargetLanguages1Response =
        new operations.UpdateTargetLanguages1Response({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
      }

      return res;
    });
  }

  /**
   * Updates instructions for all vendors performing the jobs in a quote.
   *
   * @remarks
   * Updates instructions for all vendors performing the jobs in a quote. See also "PUT /jobs/{jobId}/instructions" for updating instructions for a specific job in a project or quote.
   */
  updateVendorInstructions1(
    req: operations.UpdateVendorInstructions1Request,
    config?: AxiosRequestConfig
  ): Promise<operations.UpdateVendorInstructions1Response> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.UpdateVendorInstructions1Request(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v2/quotes/{quoteId}/vendorInstructions",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "stringDTO",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "put",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UpdateVendorInstructions1Response =
        new operations.UpdateVendorInstructions1Response({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
      }

      return res;
    });
  }

  /**
   * Updates volume for a quote.
   *
   * @remarks
   * Updates volume for a quote.
   */
  updateVolume1(
    req: operations.UpdateVolume1Request,
    config?: AxiosRequestConfig
  ): Promise<operations.UpdateVolume1Response> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.UpdateVolume1Request(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v2/quotes/{quoteId}/volume",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "bigDecimalDTO",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "put",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UpdateVolume1Response =
        new operations.UpdateVolume1Response({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
      }

      return res;
    });
  }

  /**
   * Uploads file to the quote as a file uploaded by PM.
   *
   * @remarks
   * Uploads file to the quote as a file uploaded by PM. Only one file can be uploaded at once. When the upload is finished the file has to be added by specifying its category and languages (see "PUT /v2/quotes/{quoteId}/files/add" operation).
   */
  uploadFile3(
    req: operations.UploadFile3Request,
    config?: AxiosRequestConfig
  ): Promise<operations.UploadFile3Response> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.UploadFile3Request(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v2/quotes/{quoteId}/files/upload",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "fileToUploadDto",
        "multipart"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UploadFile3Response =
        new operations.UploadFile3Response({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        default:
          if (
            utils.matchContentType(
              contentType,
              `application/json;charset=UTF-8`
            )
          ) {
            res.fileDto = utils.objectToClass(httpRes?.data, shared.FileDto1);
          }
          break;
      }

      return res;
    });
  }
}
