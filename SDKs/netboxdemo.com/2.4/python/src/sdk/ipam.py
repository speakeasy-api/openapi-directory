"""Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT."""

import requests as requests_http
from . import utils
from sdk.models import operations, shared
from typing import Optional

class Ipam:
    _client: requests_http.Session
    _security_client: requests_http.Session
    _server_url: str
    _language: str
    _sdk_version: str
    _gen_version: str

    def __init__(self, client: requests_http.Session, security_client: requests_http.Session, server_url: str, language: str, sdk_version: str, gen_version: str) -> None:
        self._client = client
        self._security_client = security_client
        self._server_url = server_url
        self._language = language
        self._sdk_version = sdk_version
        self._gen_version = gen_version
        
    def ipam_choices_list(self) -> operations.IpamChoicesListResponse:
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/ipam/_choices/'
        
        
        client = self._security_client
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.IpamChoicesListResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        

        return res

    def ipam_choices_read(self, request: operations.IpamChoicesReadRequest) -> operations.IpamChoicesReadResponse:
        base_url = self._server_url
        
        url = utils.generate_url(operations.IpamChoicesReadRequest, base_url, '/ipam/_choices/{id}/', request)
        
        
        client = self._security_client
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.IpamChoicesReadResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        

        return res

    def ipam_aggregates_create(self, request: shared.WritableAggregateInput) -> operations.IpamAggregatesCreateResponse:
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/ipam/aggregates/'
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = self._security_client
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.IpamAggregatesCreateResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 201:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Aggregate])
                res.aggregate = out

        return res

    def ipam_aggregates_delete(self, request: operations.IpamAggregatesDeleteRequest) -> operations.IpamAggregatesDeleteResponse:
        base_url = self._server_url
        
        url = utils.generate_url(operations.IpamAggregatesDeleteRequest, base_url, '/ipam/aggregates/{id}/', request)
        
        
        client = self._security_client
        
        http_res = client.request('DELETE', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.IpamAggregatesDeleteResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        

        return res

    def ipam_aggregates_list(self, request: operations.IpamAggregatesListRequest) -> operations.IpamAggregatesListResponse:
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/ipam/aggregates/'
        
        query_params = utils.get_query_params(operations.IpamAggregatesListRequest, request)
        
        client = self._security_client
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.IpamAggregatesListResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.IpamAggregatesList200ApplicationJSON])
                res.ipam_aggregates_list_200_application_json_object = out

        return res

    def ipam_aggregates_partial_update(self, request: operations.IpamAggregatesPartialUpdateRequest) -> operations.IpamAggregatesPartialUpdateResponse:
        base_url = self._server_url
        
        url = utils.generate_url(operations.IpamAggregatesPartialUpdateRequest, base_url, '/ipam/aggregates/{id}/', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "writable_aggregate_input", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = self._security_client
        
        http_res = client.request('PATCH', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.IpamAggregatesPartialUpdateResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Aggregate])
                res.aggregate = out

        return res

    def ipam_aggregates_read(self, request: operations.IpamAggregatesReadRequest) -> operations.IpamAggregatesReadResponse:
        base_url = self._server_url
        
        url = utils.generate_url(operations.IpamAggregatesReadRequest, base_url, '/ipam/aggregates/{id}/', request)
        
        
        client = self._security_client
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.IpamAggregatesReadResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Aggregate])
                res.aggregate = out

        return res

    def ipam_aggregates_update(self, request: operations.IpamAggregatesUpdateRequest) -> operations.IpamAggregatesUpdateResponse:
        base_url = self._server_url
        
        url = utils.generate_url(operations.IpamAggregatesUpdateRequest, base_url, '/ipam/aggregates/{id}/', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "writable_aggregate_input", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = self._security_client
        
        http_res = client.request('PUT', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.IpamAggregatesUpdateResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Aggregate])
                res.aggregate = out

        return res

    def ipam_ip_addresses_create(self, request: shared.WritableIPAddressInput) -> operations.IpamIPAddressesCreateResponse:
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/ipam/ip-addresses/'
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = self._security_client
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.IpamIPAddressesCreateResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 201:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.IPAddress])
                res.ip_address = out

        return res

    def ipam_ip_addresses_delete(self, request: operations.IpamIPAddressesDeleteRequest) -> operations.IpamIPAddressesDeleteResponse:
        base_url = self._server_url
        
        url = utils.generate_url(operations.IpamIPAddressesDeleteRequest, base_url, '/ipam/ip-addresses/{id}/', request)
        
        
        client = self._security_client
        
        http_res = client.request('DELETE', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.IpamIPAddressesDeleteResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        

        return res

    def ipam_ip_addresses_list(self, request: operations.IpamIPAddressesListRequest) -> operations.IpamIPAddressesListResponse:
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/ipam/ip-addresses/'
        
        query_params = utils.get_query_params(operations.IpamIPAddressesListRequest, request)
        
        client = self._security_client
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.IpamIPAddressesListResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.IpamIPAddressesList200ApplicationJSON])
                res.ipam_ip_addresses_list_200_application_json_object = out

        return res

    def ipam_ip_addresses_partial_update(self, request: operations.IpamIPAddressesPartialUpdateRequest) -> operations.IpamIPAddressesPartialUpdateResponse:
        base_url = self._server_url
        
        url = utils.generate_url(operations.IpamIPAddressesPartialUpdateRequest, base_url, '/ipam/ip-addresses/{id}/', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "writable_ip_address_input", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = self._security_client
        
        http_res = client.request('PATCH', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.IpamIPAddressesPartialUpdateResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.IPAddress])
                res.ip_address = out

        return res

    def ipam_ip_addresses_read(self, request: operations.IpamIPAddressesReadRequest) -> operations.IpamIPAddressesReadResponse:
        base_url = self._server_url
        
        url = utils.generate_url(operations.IpamIPAddressesReadRequest, base_url, '/ipam/ip-addresses/{id}/', request)
        
        
        client = self._security_client
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.IpamIPAddressesReadResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.IPAddress])
                res.ip_address = out

        return res

    def ipam_ip_addresses_update(self, request: operations.IpamIPAddressesUpdateRequest) -> operations.IpamIPAddressesUpdateResponse:
        base_url = self._server_url
        
        url = utils.generate_url(operations.IpamIPAddressesUpdateRequest, base_url, '/ipam/ip-addresses/{id}/', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "writable_ip_address_input", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = self._security_client
        
        http_res = client.request('PUT', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.IpamIPAddressesUpdateResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.IPAddress])
                res.ip_address = out

        return res

    def ipam_prefixes_available_ips_create(self, request: operations.IpamPrefixesAvailableIpsCreateRequest) -> operations.IpamPrefixesAvailableIpsCreateResponse:
        r"""A convenience method for returning available IP addresses within a prefix. By default, the number of IPs
        returned will be equivalent to PAGINATE_COUNT. An arbitrary limit (up to MAX_PAGE_SIZE, if set) may be passed,
        however results will not be paginated.
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.IpamPrefixesAvailableIpsCreateRequest, base_url, '/ipam/prefixes/{id}/available-ips/', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "writable_prefix_input", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = self._security_client
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.IpamPrefixesAvailableIpsCreateResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 201:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Prefix])
                res.prefix = out

        return res

    def ipam_prefixes_available_ips_read(self, request: operations.IpamPrefixesAvailableIpsReadRequest) -> operations.IpamPrefixesAvailableIpsReadResponse:
        r"""A convenience method for returning available IP addresses within a prefix. By default, the number of IPs
        returned will be equivalent to PAGINATE_COUNT. An arbitrary limit (up to MAX_PAGE_SIZE, if set) may be passed,
        however results will not be paginated.
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.IpamPrefixesAvailableIpsReadRequest, base_url, '/ipam/prefixes/{id}/available-ips/', request)
        
        
        client = self._security_client
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.IpamPrefixesAvailableIpsReadResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Prefix])
                res.prefix = out

        return res

    def ipam_prefixes_available_prefixes_create(self, request: operations.IpamPrefixesAvailablePrefixesCreateRequest) -> operations.IpamPrefixesAvailablePrefixesCreateResponse:
        r"""A convenience method for returning available child prefixes within a parent."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.IpamPrefixesAvailablePrefixesCreateRequest, base_url, '/ipam/prefixes/{id}/available-prefixes/', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "writable_prefix_input", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = self._security_client
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.IpamPrefixesAvailablePrefixesCreateResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 201:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Prefix])
                res.prefix = out

        return res

    def ipam_prefixes_available_prefixes_read(self, request: operations.IpamPrefixesAvailablePrefixesReadRequest) -> operations.IpamPrefixesAvailablePrefixesReadResponse:
        r"""A convenience method for returning available child prefixes within a parent."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.IpamPrefixesAvailablePrefixesReadRequest, base_url, '/ipam/prefixes/{id}/available-prefixes/', request)
        
        
        client = self._security_client
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.IpamPrefixesAvailablePrefixesReadResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Prefix])
                res.prefix = out

        return res

    def ipam_prefixes_create(self, request: shared.WritablePrefixInput) -> operations.IpamPrefixesCreateResponse:
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/ipam/prefixes/'
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = self._security_client
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.IpamPrefixesCreateResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 201:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Prefix])
                res.prefix = out

        return res

    def ipam_prefixes_delete(self, request: operations.IpamPrefixesDeleteRequest) -> operations.IpamPrefixesDeleteResponse:
        base_url = self._server_url
        
        url = utils.generate_url(operations.IpamPrefixesDeleteRequest, base_url, '/ipam/prefixes/{id}/', request)
        
        
        client = self._security_client
        
        http_res = client.request('DELETE', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.IpamPrefixesDeleteResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        

        return res

    def ipam_prefixes_list(self, request: operations.IpamPrefixesListRequest) -> operations.IpamPrefixesListResponse:
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/ipam/prefixes/'
        
        query_params = utils.get_query_params(operations.IpamPrefixesListRequest, request)
        
        client = self._security_client
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.IpamPrefixesListResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.IpamPrefixesList200ApplicationJSON])
                res.ipam_prefixes_list_200_application_json_object = out

        return res

    def ipam_prefixes_partial_update(self, request: operations.IpamPrefixesPartialUpdateRequest) -> operations.IpamPrefixesPartialUpdateResponse:
        base_url = self._server_url
        
        url = utils.generate_url(operations.IpamPrefixesPartialUpdateRequest, base_url, '/ipam/prefixes/{id}/', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "writable_prefix_input", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = self._security_client
        
        http_res = client.request('PATCH', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.IpamPrefixesPartialUpdateResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Prefix])
                res.prefix = out

        return res

    def ipam_prefixes_read(self, request: operations.IpamPrefixesReadRequest) -> operations.IpamPrefixesReadResponse:
        base_url = self._server_url
        
        url = utils.generate_url(operations.IpamPrefixesReadRequest, base_url, '/ipam/prefixes/{id}/', request)
        
        
        client = self._security_client
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.IpamPrefixesReadResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Prefix])
                res.prefix = out

        return res

    def ipam_prefixes_update(self, request: operations.IpamPrefixesUpdateRequest) -> operations.IpamPrefixesUpdateResponse:
        base_url = self._server_url
        
        url = utils.generate_url(operations.IpamPrefixesUpdateRequest, base_url, '/ipam/prefixes/{id}/', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "writable_prefix_input", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = self._security_client
        
        http_res = client.request('PUT', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.IpamPrefixesUpdateResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Prefix])
                res.prefix = out

        return res

    def ipam_rirs_create(self, request: shared.RIRInput) -> operations.IpamRirsCreateResponse:
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/ipam/rirs/'
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = self._security_client
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.IpamRirsCreateResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 201:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Rir])
                res.rir = out

        return res

    def ipam_rirs_delete(self, request: operations.IpamRirsDeleteRequest) -> operations.IpamRirsDeleteResponse:
        base_url = self._server_url
        
        url = utils.generate_url(operations.IpamRirsDeleteRequest, base_url, '/ipam/rirs/{id}/', request)
        
        
        client = self._security_client
        
        http_res = client.request('DELETE', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.IpamRirsDeleteResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        

        return res

    def ipam_rirs_list(self, request: operations.IpamRirsListRequest) -> operations.IpamRirsListResponse:
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/ipam/rirs/'
        
        query_params = utils.get_query_params(operations.IpamRirsListRequest, request)
        
        client = self._security_client
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.IpamRirsListResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.IpamRirsList200ApplicationJSON])
                res.ipam_rirs_list_200_application_json_object = out

        return res

    def ipam_rirs_partial_update(self, request: operations.IpamRirsPartialUpdateRequest) -> operations.IpamRirsPartialUpdateResponse:
        base_url = self._server_url
        
        url = utils.generate_url(operations.IpamRirsPartialUpdateRequest, base_url, '/ipam/rirs/{id}/', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "rir_input", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = self._security_client
        
        http_res = client.request('PATCH', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.IpamRirsPartialUpdateResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Rir])
                res.rir = out

        return res

    def ipam_rirs_read(self, request: operations.IpamRirsReadRequest) -> operations.IpamRirsReadResponse:
        base_url = self._server_url
        
        url = utils.generate_url(operations.IpamRirsReadRequest, base_url, '/ipam/rirs/{id}/', request)
        
        
        client = self._security_client
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.IpamRirsReadResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Rir])
                res.rir = out

        return res

    def ipam_rirs_update(self, request: operations.IpamRirsUpdateRequest) -> operations.IpamRirsUpdateResponse:
        base_url = self._server_url
        
        url = utils.generate_url(operations.IpamRirsUpdateRequest, base_url, '/ipam/rirs/{id}/', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "rir_input", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = self._security_client
        
        http_res = client.request('PUT', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.IpamRirsUpdateResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Rir])
                res.rir = out

        return res

    def ipam_roles_create(self, request: shared.RoleInput) -> operations.IpamRolesCreateResponse:
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/ipam/roles/'
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = self._security_client
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.IpamRolesCreateResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 201:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Role])
                res.role = out

        return res

    def ipam_roles_delete(self, request: operations.IpamRolesDeleteRequest) -> operations.IpamRolesDeleteResponse:
        base_url = self._server_url
        
        url = utils.generate_url(operations.IpamRolesDeleteRequest, base_url, '/ipam/roles/{id}/', request)
        
        
        client = self._security_client
        
        http_res = client.request('DELETE', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.IpamRolesDeleteResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        

        return res

    def ipam_roles_list(self, request: operations.IpamRolesListRequest) -> operations.IpamRolesListResponse:
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/ipam/roles/'
        
        query_params = utils.get_query_params(operations.IpamRolesListRequest, request)
        
        client = self._security_client
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.IpamRolesListResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.IpamRolesList200ApplicationJSON])
                res.ipam_roles_list_200_application_json_object = out

        return res

    def ipam_roles_partial_update(self, request: operations.IpamRolesPartialUpdateRequest) -> operations.IpamRolesPartialUpdateResponse:
        base_url = self._server_url
        
        url = utils.generate_url(operations.IpamRolesPartialUpdateRequest, base_url, '/ipam/roles/{id}/', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "role_input", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = self._security_client
        
        http_res = client.request('PATCH', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.IpamRolesPartialUpdateResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Role])
                res.role = out

        return res

    def ipam_roles_read(self, request: operations.IpamRolesReadRequest) -> operations.IpamRolesReadResponse:
        base_url = self._server_url
        
        url = utils.generate_url(operations.IpamRolesReadRequest, base_url, '/ipam/roles/{id}/', request)
        
        
        client = self._security_client
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.IpamRolesReadResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Role])
                res.role = out

        return res

    def ipam_roles_update(self, request: operations.IpamRolesUpdateRequest) -> operations.IpamRolesUpdateResponse:
        base_url = self._server_url
        
        url = utils.generate_url(operations.IpamRolesUpdateRequest, base_url, '/ipam/roles/{id}/', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "role_input", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = self._security_client
        
        http_res = client.request('PUT', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.IpamRolesUpdateResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Role])
                res.role = out

        return res

    def ipam_services_create(self, request: shared.WritableServiceInput) -> operations.IpamServicesCreateResponse:
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/ipam/services/'
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = self._security_client
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.IpamServicesCreateResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 201:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Service])
                res.service = out

        return res

    def ipam_services_delete(self, request: operations.IpamServicesDeleteRequest) -> operations.IpamServicesDeleteResponse:
        base_url = self._server_url
        
        url = utils.generate_url(operations.IpamServicesDeleteRequest, base_url, '/ipam/services/{id}/', request)
        
        
        client = self._security_client
        
        http_res = client.request('DELETE', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.IpamServicesDeleteResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        

        return res

    def ipam_services_list(self, request: operations.IpamServicesListRequest) -> operations.IpamServicesListResponse:
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/ipam/services/'
        
        query_params = utils.get_query_params(operations.IpamServicesListRequest, request)
        
        client = self._security_client
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.IpamServicesListResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.IpamServicesList200ApplicationJSON])
                res.ipam_services_list_200_application_json_object = out

        return res

    def ipam_services_partial_update(self, request: operations.IpamServicesPartialUpdateRequest) -> operations.IpamServicesPartialUpdateResponse:
        base_url = self._server_url
        
        url = utils.generate_url(operations.IpamServicesPartialUpdateRequest, base_url, '/ipam/services/{id}/', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "writable_service_input", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = self._security_client
        
        http_res = client.request('PATCH', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.IpamServicesPartialUpdateResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Service])
                res.service = out

        return res

    def ipam_services_read(self, request: operations.IpamServicesReadRequest) -> operations.IpamServicesReadResponse:
        base_url = self._server_url
        
        url = utils.generate_url(operations.IpamServicesReadRequest, base_url, '/ipam/services/{id}/', request)
        
        
        client = self._security_client
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.IpamServicesReadResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Service])
                res.service = out

        return res

    def ipam_services_update(self, request: operations.IpamServicesUpdateRequest) -> operations.IpamServicesUpdateResponse:
        base_url = self._server_url
        
        url = utils.generate_url(operations.IpamServicesUpdateRequest, base_url, '/ipam/services/{id}/', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "writable_service_input", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = self._security_client
        
        http_res = client.request('PUT', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.IpamServicesUpdateResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Service])
                res.service = out

        return res

    def ipam_vlan_groups_create(self, request: shared.WritableVLANGroupInput) -> operations.IpamVlanGroupsCreateResponse:
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/ipam/vlan-groups/'
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = self._security_client
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.IpamVlanGroupsCreateResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 201:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.VLANGroup])
                res.vlan_group = out

        return res

    def ipam_vlan_groups_delete(self, request: operations.IpamVlanGroupsDeleteRequest) -> operations.IpamVlanGroupsDeleteResponse:
        base_url = self._server_url
        
        url = utils.generate_url(operations.IpamVlanGroupsDeleteRequest, base_url, '/ipam/vlan-groups/{id}/', request)
        
        
        client = self._security_client
        
        http_res = client.request('DELETE', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.IpamVlanGroupsDeleteResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        

        return res

    def ipam_vlan_groups_list(self, request: operations.IpamVlanGroupsListRequest) -> operations.IpamVlanGroupsListResponse:
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/ipam/vlan-groups/'
        
        query_params = utils.get_query_params(operations.IpamVlanGroupsListRequest, request)
        
        client = self._security_client
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.IpamVlanGroupsListResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.IpamVlanGroupsList200ApplicationJSON])
                res.ipam_vlan_groups_list_200_application_json_object = out

        return res

    def ipam_vlan_groups_partial_update(self, request: operations.IpamVlanGroupsPartialUpdateRequest) -> operations.IpamVlanGroupsPartialUpdateResponse:
        base_url = self._server_url
        
        url = utils.generate_url(operations.IpamVlanGroupsPartialUpdateRequest, base_url, '/ipam/vlan-groups/{id}/', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "writable_vlan_group_input", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = self._security_client
        
        http_res = client.request('PATCH', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.IpamVlanGroupsPartialUpdateResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.VLANGroup])
                res.vlan_group = out

        return res

    def ipam_vlan_groups_read(self, request: operations.IpamVlanGroupsReadRequest) -> operations.IpamVlanGroupsReadResponse:
        base_url = self._server_url
        
        url = utils.generate_url(operations.IpamVlanGroupsReadRequest, base_url, '/ipam/vlan-groups/{id}/', request)
        
        
        client = self._security_client
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.IpamVlanGroupsReadResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.VLANGroup])
                res.vlan_group = out

        return res

    def ipam_vlan_groups_update(self, request: operations.IpamVlanGroupsUpdateRequest) -> operations.IpamVlanGroupsUpdateResponse:
        base_url = self._server_url
        
        url = utils.generate_url(operations.IpamVlanGroupsUpdateRequest, base_url, '/ipam/vlan-groups/{id}/', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "writable_vlan_group_input", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = self._security_client
        
        http_res = client.request('PUT', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.IpamVlanGroupsUpdateResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.VLANGroup])
                res.vlan_group = out

        return res

    def ipam_vlans_create(self, request: shared.WritableVLANInput) -> operations.IpamVlansCreateResponse:
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/ipam/vlans/'
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = self._security_client
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.IpamVlansCreateResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 201:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Vlan])
                res.vlan = out

        return res

    def ipam_vlans_delete(self, request: operations.IpamVlansDeleteRequest) -> operations.IpamVlansDeleteResponse:
        base_url = self._server_url
        
        url = utils.generate_url(operations.IpamVlansDeleteRequest, base_url, '/ipam/vlans/{id}/', request)
        
        
        client = self._security_client
        
        http_res = client.request('DELETE', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.IpamVlansDeleteResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        

        return res

    def ipam_vlans_list(self, request: operations.IpamVlansListRequest) -> operations.IpamVlansListResponse:
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/ipam/vlans/'
        
        query_params = utils.get_query_params(operations.IpamVlansListRequest, request)
        
        client = self._security_client
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.IpamVlansListResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.IpamVlansList200ApplicationJSON])
                res.ipam_vlans_list_200_application_json_object = out

        return res

    def ipam_vlans_partial_update(self, request: operations.IpamVlansPartialUpdateRequest) -> operations.IpamVlansPartialUpdateResponse:
        base_url = self._server_url
        
        url = utils.generate_url(operations.IpamVlansPartialUpdateRequest, base_url, '/ipam/vlans/{id}/', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "writable_vlan_input", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = self._security_client
        
        http_res = client.request('PATCH', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.IpamVlansPartialUpdateResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Vlan])
                res.vlan = out

        return res

    def ipam_vlans_read(self, request: operations.IpamVlansReadRequest) -> operations.IpamVlansReadResponse:
        base_url = self._server_url
        
        url = utils.generate_url(operations.IpamVlansReadRequest, base_url, '/ipam/vlans/{id}/', request)
        
        
        client = self._security_client
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.IpamVlansReadResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Vlan])
                res.vlan = out

        return res

    def ipam_vlans_update(self, request: operations.IpamVlansUpdateRequest) -> operations.IpamVlansUpdateResponse:
        base_url = self._server_url
        
        url = utils.generate_url(operations.IpamVlansUpdateRequest, base_url, '/ipam/vlans/{id}/', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "writable_vlan_input", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = self._security_client
        
        http_res = client.request('PUT', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.IpamVlansUpdateResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Vlan])
                res.vlan = out

        return res

    def ipam_vrfs_create(self, request: shared.WritableVRFInput) -> operations.IpamVrfsCreateResponse:
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/ipam/vrfs/'
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = self._security_client
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.IpamVrfsCreateResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 201:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Vrf])
                res.vrf = out

        return res

    def ipam_vrfs_delete(self, request: operations.IpamVrfsDeleteRequest) -> operations.IpamVrfsDeleteResponse:
        base_url = self._server_url
        
        url = utils.generate_url(operations.IpamVrfsDeleteRequest, base_url, '/ipam/vrfs/{id}/', request)
        
        
        client = self._security_client
        
        http_res = client.request('DELETE', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.IpamVrfsDeleteResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        

        return res

    def ipam_vrfs_list(self, request: operations.IpamVrfsListRequest) -> operations.IpamVrfsListResponse:
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/ipam/vrfs/'
        
        query_params = utils.get_query_params(operations.IpamVrfsListRequest, request)
        
        client = self._security_client
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.IpamVrfsListResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.IpamVrfsList200ApplicationJSON])
                res.ipam_vrfs_list_200_application_json_object = out

        return res

    def ipam_vrfs_partial_update(self, request: operations.IpamVrfsPartialUpdateRequest) -> operations.IpamVrfsPartialUpdateResponse:
        base_url = self._server_url
        
        url = utils.generate_url(operations.IpamVrfsPartialUpdateRequest, base_url, '/ipam/vrfs/{id}/', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "writable_vrf_input", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = self._security_client
        
        http_res = client.request('PATCH', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.IpamVrfsPartialUpdateResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Vrf])
                res.vrf = out

        return res

    def ipam_vrfs_read(self, request: operations.IpamVrfsReadRequest) -> operations.IpamVrfsReadResponse:
        base_url = self._server_url
        
        url = utils.generate_url(operations.IpamVrfsReadRequest, base_url, '/ipam/vrfs/{id}/', request)
        
        
        client = self._security_client
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.IpamVrfsReadResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Vrf])
                res.vrf = out

        return res

    def ipam_vrfs_update(self, request: operations.IpamVrfsUpdateRequest) -> operations.IpamVrfsUpdateResponse:
        base_url = self._server_url
        
        url = utils.generate_url(operations.IpamVrfsUpdateRequest, base_url, '/ipam/vrfs/{id}/', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "writable_vrf_input", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = self._security_client
        
        http_res = client.request('PUT', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.IpamVrfsUpdateResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Vrf])
                res.vrf = out

        return res

    