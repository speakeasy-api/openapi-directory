/*
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

import * as utils from "../internal/utils";
import * as operations from "./models/operations";
import * as shared from "./models/shared";
import { AxiosInstance, AxiosRequestConfig, AxiosResponse } from "axios";

export class Bidders {
  _defaultClient: AxiosInstance;
  _securityClient: AxiosInstance;
  _serverURL: string;
  _language: string;
  _sdkVersion: string;
  _genVersion: string;

  constructor(
    defaultClient: AxiosInstance,
    securityClient: AxiosInstance,
    serverURL: string,
    language: string,
    sdkVersion: string,
    genVersion: string
  ) {
    this._defaultClient = defaultClient;
    this._securityClient = securityClient;
    this._serverURL = serverURL;
    this._language = language;
    this._sdkVersion = sdkVersion;
    this._genVersion = genVersion;
  }

  /**
   * Watches all creatives pertaining to a bidder. It is sufficient to invoke this endpoint once per bidder. A Pub/Sub topic will be created and notifications will be pushed to the topic when any of the bidder's creatives change status. All of the bidder's service accounts will have access to read from the topic. Subsequent invocations of this method will return the existing Pub/Sub configuration.
   */
  realtimebiddingBiddersCreativesWatch(
    req: operations.RealtimebiddingBiddersCreativesWatchRequest,
    security: operations.RealtimebiddingBiddersCreativesWatchSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.RealtimebiddingBiddersCreativesWatchResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.RealtimebiddingBiddersCreativesWatchRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v1/{parent}/creatives:watch",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.RealtimebiddingBiddersCreativesWatchSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.RealtimebiddingBiddersCreativesWatchResponse =
        new operations.RealtimebiddingBiddersCreativesWatchResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.watchCreativesResponse = utils.objectToClass(
              httpRes?.data,
              shared.WatchCreativesResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Lists all the bidder's endpoints.
   */
  realtimebiddingBiddersEndpointsList(
    req: operations.RealtimebiddingBiddersEndpointsListRequest,
    security: operations.RealtimebiddingBiddersEndpointsListSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.RealtimebiddingBiddersEndpointsListResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.RealtimebiddingBiddersEndpointsListRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v1/{parent}/endpoints",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.RealtimebiddingBiddersEndpointsListSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.RealtimebiddingBiddersEndpointsListResponse =
        new operations.RealtimebiddingBiddersEndpointsListResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listEndpointsResponse = utils.objectToClass(
              httpRes?.data,
              shared.ListEndpointsResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Lists all the bidder accounts that belong to the caller.
   */
  realtimebiddingBiddersList(
    req: operations.RealtimebiddingBiddersListRequest,
    security: operations.RealtimebiddingBiddersListSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.RealtimebiddingBiddersListResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.RealtimebiddingBiddersListRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/v1/bidders";
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.RealtimebiddingBiddersListSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.RealtimebiddingBiddersListResponse =
        new operations.RealtimebiddingBiddersListResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listBiddersResponse = utils.objectToClass(
              httpRes?.data,
              shared.ListBiddersResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Activates a pretargeting configuration.
   */
  realtimebiddingBiddersPretargetingConfigsActivate(
    req: operations.RealtimebiddingBiddersPretargetingConfigsActivateRequest,
    security: operations.RealtimebiddingBiddersPretargetingConfigsActivateSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.RealtimebiddingBiddersPretargetingConfigsActivateResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.RealtimebiddingBiddersPretargetingConfigsActivateRequest(
          req
        );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(baseURL, "/v1/{name}:activate", req);

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.RealtimebiddingBiddersPretargetingConfigsActivateSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.RealtimebiddingBiddersPretargetingConfigsActivateResponse =
        new operations.RealtimebiddingBiddersPretargetingConfigsActivateResponse(
          {
            statusCode: httpRes.status,
            contentType: contentType,
            rawResponse: httpRes,
          }
        );
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.pretargetingConfig = utils.objectToClass(
              httpRes?.data,
              shared.PretargetingConfig
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Adds targeted apps to the pretargeting configuration.
   */
  realtimebiddingBiddersPretargetingConfigsAddTargetedApps(
    req: operations.RealtimebiddingBiddersPretargetingConfigsAddTargetedAppsRequest,
    security: operations.RealtimebiddingBiddersPretargetingConfigsAddTargetedAppsSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.RealtimebiddingBiddersPretargetingConfigsAddTargetedAppsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.RealtimebiddingBiddersPretargetingConfigsAddTargetedAppsRequest(
          req
        );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v1/{pretargetingConfig}:addTargetedApps",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "addTargetedAppsRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.RealtimebiddingBiddersPretargetingConfigsAddTargetedAppsSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.RealtimebiddingBiddersPretargetingConfigsAddTargetedAppsResponse =
        new operations.RealtimebiddingBiddersPretargetingConfigsAddTargetedAppsResponse(
          {
            statusCode: httpRes.status,
            contentType: contentType,
            rawResponse: httpRes,
          }
        );
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.pretargetingConfig = utils.objectToClass(
              httpRes?.data,
              shared.PretargetingConfig
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Adds targeted publishers to the pretargeting config.
   */
  realtimebiddingBiddersPretargetingConfigsAddTargetedPublishers(
    req: operations.RealtimebiddingBiddersPretargetingConfigsAddTargetedPublishersRequest,
    security: operations.RealtimebiddingBiddersPretargetingConfigsAddTargetedPublishersSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.RealtimebiddingBiddersPretargetingConfigsAddTargetedPublishersResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.RealtimebiddingBiddersPretargetingConfigsAddTargetedPublishersRequest(
          req
        );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v1/{pretargetingConfig}:addTargetedPublishers",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "addTargetedPublishersRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.RealtimebiddingBiddersPretargetingConfigsAddTargetedPublishersSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.RealtimebiddingBiddersPretargetingConfigsAddTargetedPublishersResponse =
        new operations.RealtimebiddingBiddersPretargetingConfigsAddTargetedPublishersResponse(
          {
            statusCode: httpRes.status,
            contentType: contentType,
            rawResponse: httpRes,
          }
        );
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.pretargetingConfig = utils.objectToClass(
              httpRes?.data,
              shared.PretargetingConfig
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Adds targeted sites to the pretargeting configuration.
   */
  realtimebiddingBiddersPretargetingConfigsAddTargetedSites(
    req: operations.RealtimebiddingBiddersPretargetingConfigsAddTargetedSitesRequest,
    security: operations.RealtimebiddingBiddersPretargetingConfigsAddTargetedSitesSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.RealtimebiddingBiddersPretargetingConfigsAddTargetedSitesResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.RealtimebiddingBiddersPretargetingConfigsAddTargetedSitesRequest(
          req
        );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v1/{pretargetingConfig}:addTargetedSites",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "addTargetedSitesRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.RealtimebiddingBiddersPretargetingConfigsAddTargetedSitesSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.RealtimebiddingBiddersPretargetingConfigsAddTargetedSitesResponse =
        new operations.RealtimebiddingBiddersPretargetingConfigsAddTargetedSitesResponse(
          {
            statusCode: httpRes.status,
            contentType: contentType,
            rawResponse: httpRes,
          }
        );
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.pretargetingConfig = utils.objectToClass(
              httpRes?.data,
              shared.PretargetingConfig
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Creates a pretargeting configuration. A pretargeting configuration's state (PretargetingConfig.state) is active upon creation, and it will start to affect traffic shortly after. A bidder may create a maximum of 10 pretargeting configurations. Attempts to exceed this maximum results in a 400 bad request error.
   */
  realtimebiddingBiddersPretargetingConfigsCreate(
    req: operations.RealtimebiddingBiddersPretargetingConfigsCreateRequest,
    security: operations.RealtimebiddingBiddersPretargetingConfigsCreateSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.RealtimebiddingBiddersPretargetingConfigsCreateResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.RealtimebiddingBiddersPretargetingConfigsCreateRequest(
          req
        );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v1/{parent}/pretargetingConfigs",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "pretargetingConfigInput",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.RealtimebiddingBiddersPretargetingConfigsCreateSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.RealtimebiddingBiddersPretargetingConfigsCreateResponse =
        new operations.RealtimebiddingBiddersPretargetingConfigsCreateResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.pretargetingConfig = utils.objectToClass(
              httpRes?.data,
              shared.PretargetingConfig
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Deletes a pretargeting configuration.
   */
  realtimebiddingBiddersPretargetingConfigsDelete(
    req: operations.RealtimebiddingBiddersPretargetingConfigsDeleteRequest,
    security: operations.RealtimebiddingBiddersPretargetingConfigsDeleteSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.RealtimebiddingBiddersPretargetingConfigsDeleteResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.RealtimebiddingBiddersPretargetingConfigsDeleteRequest(
          req
        );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(baseURL, "/v1/{name}", req);
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.RealtimebiddingBiddersPretargetingConfigsDeleteSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.RealtimebiddingBiddersPretargetingConfigsDeleteResponse =
        new operations.RealtimebiddingBiddersPretargetingConfigsDeleteResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.empty = utils.objectToClass(httpRes?.data);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Lists all pretargeting configurations for a single bidder.
   */
  realtimebiddingBiddersPretargetingConfigsList(
    req: operations.RealtimebiddingBiddersPretargetingConfigsListRequest,
    security: operations.RealtimebiddingBiddersPretargetingConfigsListSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.RealtimebiddingBiddersPretargetingConfigsListResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.RealtimebiddingBiddersPretargetingConfigsListRequest(
        req
      );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v1/{parent}/pretargetingConfigs",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.RealtimebiddingBiddersPretargetingConfigsListSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.RealtimebiddingBiddersPretargetingConfigsListResponse =
        new operations.RealtimebiddingBiddersPretargetingConfigsListResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listPretargetingConfigsResponse = utils.objectToClass(
              httpRes?.data,
              shared.ListPretargetingConfigsResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Removes targeted apps from the pretargeting configuration.
   */
  realtimebiddingBiddersPretargetingConfigsRemoveTargetedApps(
    req: operations.RealtimebiddingBiddersPretargetingConfigsRemoveTargetedAppsRequest,
    security: operations.RealtimebiddingBiddersPretargetingConfigsRemoveTargetedAppsSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.RealtimebiddingBiddersPretargetingConfigsRemoveTargetedAppsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.RealtimebiddingBiddersPretargetingConfigsRemoveTargetedAppsRequest(
          req
        );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v1/{pretargetingConfig}:removeTargetedApps",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "removeTargetedAppsRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.RealtimebiddingBiddersPretargetingConfigsRemoveTargetedAppsSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.RealtimebiddingBiddersPretargetingConfigsRemoveTargetedAppsResponse =
        new operations.RealtimebiddingBiddersPretargetingConfigsRemoveTargetedAppsResponse(
          {
            statusCode: httpRes.status,
            contentType: contentType,
            rawResponse: httpRes,
          }
        );
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.pretargetingConfig = utils.objectToClass(
              httpRes?.data,
              shared.PretargetingConfig
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Removes targeted publishers from the pretargeting config.
   */
  realtimebiddingBiddersPretargetingConfigsRemoveTargetedPublishers(
    req: operations.RealtimebiddingBiddersPretargetingConfigsRemoveTargetedPublishersRequest,
    security: operations.RealtimebiddingBiddersPretargetingConfigsRemoveTargetedPublishersSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.RealtimebiddingBiddersPretargetingConfigsRemoveTargetedPublishersResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.RealtimebiddingBiddersPretargetingConfigsRemoveTargetedPublishersRequest(
          req
        );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v1/{pretargetingConfig}:removeTargetedPublishers",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "removeTargetedPublishersRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.RealtimebiddingBiddersPretargetingConfigsRemoveTargetedPublishersSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.RealtimebiddingBiddersPretargetingConfigsRemoveTargetedPublishersResponse =
        new operations.RealtimebiddingBiddersPretargetingConfigsRemoveTargetedPublishersResponse(
          {
            statusCode: httpRes.status,
            contentType: contentType,
            rawResponse: httpRes,
          }
        );
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.pretargetingConfig = utils.objectToClass(
              httpRes?.data,
              shared.PretargetingConfig
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Removes targeted sites from the pretargeting configuration.
   */
  realtimebiddingBiddersPretargetingConfigsRemoveTargetedSites(
    req: operations.RealtimebiddingBiddersPretargetingConfigsRemoveTargetedSitesRequest,
    security: operations.RealtimebiddingBiddersPretargetingConfigsRemoveTargetedSitesSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.RealtimebiddingBiddersPretargetingConfigsRemoveTargetedSitesResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.RealtimebiddingBiddersPretargetingConfigsRemoveTargetedSitesRequest(
          req
        );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v1/{pretargetingConfig}:removeTargetedSites",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "removeTargetedSitesRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.RealtimebiddingBiddersPretargetingConfigsRemoveTargetedSitesSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.RealtimebiddingBiddersPretargetingConfigsRemoveTargetedSitesResponse =
        new operations.RealtimebiddingBiddersPretargetingConfigsRemoveTargetedSitesResponse(
          {
            statusCode: httpRes.status,
            contentType: contentType,
            rawResponse: httpRes,
          }
        );
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.pretargetingConfig = utils.objectToClass(
              httpRes?.data,
              shared.PretargetingConfig
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Suspends a pretargeting configuration.
   */
  realtimebiddingBiddersPretargetingConfigsSuspend(
    req: operations.RealtimebiddingBiddersPretargetingConfigsSuspendRequest,
    security: operations.RealtimebiddingBiddersPretargetingConfigsSuspendSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.RealtimebiddingBiddersPretargetingConfigsSuspendResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.RealtimebiddingBiddersPretargetingConfigsSuspendRequest(
          req
        );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(baseURL, "/v1/{name}:suspend", req);

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.RealtimebiddingBiddersPretargetingConfigsSuspendSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.RealtimebiddingBiddersPretargetingConfigsSuspendResponse =
        new operations.RealtimebiddingBiddersPretargetingConfigsSuspendResponse(
          {
            statusCode: httpRes.status,
            contentType: contentType,
            rawResponse: httpRes,
          }
        );
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.pretargetingConfig = utils.objectToClass(
              httpRes?.data,
              shared.PretargetingConfig
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Batch approves multiple publisher connections.
   */
  realtimebiddingBiddersPublisherConnectionsBatchApprove(
    req: operations.RealtimebiddingBiddersPublisherConnectionsBatchApproveRequest,
    security: operations.RealtimebiddingBiddersPublisherConnectionsBatchApproveSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.RealtimebiddingBiddersPublisherConnectionsBatchApproveResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.RealtimebiddingBiddersPublisherConnectionsBatchApproveRequest(
          req
        );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v1/{parent}/publisherConnections:batchApprove",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "batchApprovePublisherConnectionsRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.RealtimebiddingBiddersPublisherConnectionsBatchApproveSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.RealtimebiddingBiddersPublisherConnectionsBatchApproveResponse =
        new operations.RealtimebiddingBiddersPublisherConnectionsBatchApproveResponse(
          {
            statusCode: httpRes.status,
            contentType: contentType,
            rawResponse: httpRes,
          }
        );
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.batchApprovePublisherConnectionsResponse = utils.objectToClass(
              httpRes?.data,
              shared.BatchApprovePublisherConnectionsResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Batch rejects multiple publisher connections.
   */
  realtimebiddingBiddersPublisherConnectionsBatchReject(
    req: operations.RealtimebiddingBiddersPublisherConnectionsBatchRejectRequest,
    security: operations.RealtimebiddingBiddersPublisherConnectionsBatchRejectSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.RealtimebiddingBiddersPublisherConnectionsBatchRejectResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.RealtimebiddingBiddersPublisherConnectionsBatchRejectRequest(
          req
        );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v1/{parent}/publisherConnections:batchReject",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "batchRejectPublisherConnectionsRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.RealtimebiddingBiddersPublisherConnectionsBatchRejectSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.RealtimebiddingBiddersPublisherConnectionsBatchRejectResponse =
        new operations.RealtimebiddingBiddersPublisherConnectionsBatchRejectResponse(
          {
            statusCode: httpRes.status,
            contentType: contentType,
            rawResponse: httpRes,
          }
        );
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.batchRejectPublisherConnectionsResponse = utils.objectToClass(
              httpRes?.data,
              shared.BatchRejectPublisherConnectionsResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Lists publisher connections for a given bidder.
   */
  realtimebiddingBiddersPublisherConnectionsList(
    req: operations.RealtimebiddingBiddersPublisherConnectionsListRequest,
    security: operations.RealtimebiddingBiddersPublisherConnectionsListSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.RealtimebiddingBiddersPublisherConnectionsListResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.RealtimebiddingBiddersPublisherConnectionsListRequest(
          req
        );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v1/{parent}/publisherConnections",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.RealtimebiddingBiddersPublisherConnectionsListSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.RealtimebiddingBiddersPublisherConnectionsListResponse =
        new operations.RealtimebiddingBiddersPublisherConnectionsListResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listPublisherConnectionsResponse = utils.objectToClass(
              httpRes?.data,
              shared.ListPublisherConnectionsResponse
            );
          }
          break;
      }

      return res;
    });
  }
}
