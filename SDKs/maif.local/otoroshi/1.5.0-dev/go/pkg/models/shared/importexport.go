// Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.

package shared

import (
	"bytes"
	"encoding/json"
	"errors"
	"time"
)

// ImportExportAdmins - Administrator using FIDO U2F device to access Otoroshi
type ImportExportAdmins struct {
	// The creation date of the user
	CreatedAt int64 `json:"createdAt"`
	// The label for the user
	Label string `json:"label"`
	// The hashed password of the user
	Password string `json:"password"`
	// The U2F registration slug
	Registration map[string]string `json:"registration"`
	// The email address of the user
	Username string `json:"username"`
}

// ImportExportAPIKeys - An Otoroshi Api Key. An Api Key is defined for a group of services to allow usage of the same Api Key for multiple services.
type ImportExportAPIKeys struct {
	// The group/service ids (prefixed by group_ or service_ on which the key is authorized
	AuthorizedEntities []string `json:"authorizedEntities"`
	// The unique id of the Api Key. Usually 16 random alpha numerical characters, but can be anything
	ClientID string `json:"clientId"`
	// The name of the api key, for humans ;-)
	ClientName string `json:"clientName"`
	// The secret of the Api Key. Usually 64 random alpha numerical characters, but can be anything
	ClientSecret string `json:"clientSecret"`
	// Authorized number of calls per day
	DailyQuota *int64 `json:"dailyQuota,omitempty"`
	// Whether or not the key is enabled. If disabled, resources won't be available to calls using this key
	Enabled bool `json:"enabled"`
	// Bunch of metadata for the key
	Metadata map[string]string `json:"metadata,omitempty"`
	// Authorized number of calls per month
	MonthlyQuota *int64 `json:"monthlyQuota,omitempty"`
	// Authorized number of calls per second, measured on 10 seconds
	ThrottlingQuota *int64 `json:"throttlingQuota,omitempty"`
}

// ImportExportErrorTemplates - Error templates for a service descriptor
type ImportExportErrorTemplates struct {
	// Map for custom messages
	Messages map[string]string `json:"messages"`
	// The Id of the service for which the error template is enabled
	ServiceID string `json:"serviceId"`
	// The html template for 40x errors
	Template40x string `json:"template40x"`
	// The html template for 50x errors
	Template50x string `json:"template50x"`
	// The html template for build page
	TemplateBuild string `json:"templateBuild"`
	// The html template for maintenance page
	TemplateMaintenance string `json:"templateMaintenance"`
}

type ImportExportServiceDescriptorsJwtVerifierType string

const (
	ImportExportServiceDescriptorsJwtVerifierTypeLocalJwtVerifier ImportExportServiceDescriptorsJwtVerifierType = "LocalJwtVerifier"
	ImportExportServiceDescriptorsJwtVerifierTypeRefJwtVerifier   ImportExportServiceDescriptorsJwtVerifierType = "RefJwtVerifier"
)

type ImportExportServiceDescriptorsJwtVerifier struct {
	LocalJwtVerifier *LocalJwtVerifier
	RefJwtVerifier   *RefJwtVerifier

	Type ImportExportServiceDescriptorsJwtVerifierType
}

func CreateImportExportServiceDescriptorsJwtVerifierLocalJwtVerifier(localJwtVerifier LocalJwtVerifier) ImportExportServiceDescriptorsJwtVerifier {
	typ := ImportExportServiceDescriptorsJwtVerifierTypeLocalJwtVerifier

	return ImportExportServiceDescriptorsJwtVerifier{
		LocalJwtVerifier: &localJwtVerifier,
		Type:             typ,
	}
}

func CreateImportExportServiceDescriptorsJwtVerifierRefJwtVerifier(refJwtVerifier RefJwtVerifier) ImportExportServiceDescriptorsJwtVerifier {
	typ := ImportExportServiceDescriptorsJwtVerifierTypeRefJwtVerifier

	return ImportExportServiceDescriptorsJwtVerifier{
		RefJwtVerifier: &refJwtVerifier,
		Type:           typ,
	}
}

func (u *ImportExportServiceDescriptorsJwtVerifier) UnmarshalJSON(data []byte) error {
	var d *json.Decoder

	localJwtVerifier := new(LocalJwtVerifier)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&localJwtVerifier); err == nil {
		u.LocalJwtVerifier = localJwtVerifier
		u.Type = ImportExportServiceDescriptorsJwtVerifierTypeLocalJwtVerifier
		return nil
	}

	refJwtVerifier := new(RefJwtVerifier)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&refJwtVerifier); err == nil {
		u.RefJwtVerifier = refJwtVerifier
		u.Type = ImportExportServiceDescriptorsJwtVerifierTypeRefJwtVerifier
		return nil
	}

	return errors.New("could not unmarshal into supported union types")
}

func (u ImportExportServiceDescriptorsJwtVerifier) MarshalJSON() ([]byte, error) {
	if u.LocalJwtVerifier != nil {
		return json.Marshal(u.LocalJwtVerifier)
	}

	if u.RefJwtVerifier != nil {
		return json.Marshal(u.RefJwtVerifier)
	}

	return nil, nil
}

type ImportExportServiceDescriptorsSecComSettingsType string

const (
	ImportExportServiceDescriptorsSecComSettingsTypeHSAlgoSettings   ImportExportServiceDescriptorsSecComSettingsType = "HSAlgoSettings"
	ImportExportServiceDescriptorsSecComSettingsTypeRSAlgoSettings   ImportExportServiceDescriptorsSecComSettingsType = "RSAlgoSettings"
	ImportExportServiceDescriptorsSecComSettingsTypeESAlgoSettings   ImportExportServiceDescriptorsSecComSettingsType = "ESAlgoSettings"
	ImportExportServiceDescriptorsSecComSettingsTypeJWKSAlgoSettings ImportExportServiceDescriptorsSecComSettingsType = "JWKSAlgoSettings"
)

type ImportExportServiceDescriptorsSecComSettings struct {
	HSAlgoSettings   *HSAlgoSettings
	RSAlgoSettings   *RSAlgoSettings
	ESAlgoSettings   *ESAlgoSettings
	JWKSAlgoSettings *JWKSAlgoSettings

	Type ImportExportServiceDescriptorsSecComSettingsType
}

func CreateImportExportServiceDescriptorsSecComSettingsHSAlgoSettings(hsAlgoSettings HSAlgoSettings) ImportExportServiceDescriptorsSecComSettings {
	typ := ImportExportServiceDescriptorsSecComSettingsTypeHSAlgoSettings

	return ImportExportServiceDescriptorsSecComSettings{
		HSAlgoSettings: &hsAlgoSettings,
		Type:           typ,
	}
}

func CreateImportExportServiceDescriptorsSecComSettingsRSAlgoSettings(rsAlgoSettings RSAlgoSettings) ImportExportServiceDescriptorsSecComSettings {
	typ := ImportExportServiceDescriptorsSecComSettingsTypeRSAlgoSettings

	return ImportExportServiceDescriptorsSecComSettings{
		RSAlgoSettings: &rsAlgoSettings,
		Type:           typ,
	}
}

func CreateImportExportServiceDescriptorsSecComSettingsESAlgoSettings(esAlgoSettings ESAlgoSettings) ImportExportServiceDescriptorsSecComSettings {
	typ := ImportExportServiceDescriptorsSecComSettingsTypeESAlgoSettings

	return ImportExportServiceDescriptorsSecComSettings{
		ESAlgoSettings: &esAlgoSettings,
		Type:           typ,
	}
}

func CreateImportExportServiceDescriptorsSecComSettingsJWKSAlgoSettings(jwksAlgoSettings JWKSAlgoSettings) ImportExportServiceDescriptorsSecComSettings {
	typ := ImportExportServiceDescriptorsSecComSettingsTypeJWKSAlgoSettings

	return ImportExportServiceDescriptorsSecComSettings{
		JWKSAlgoSettings: &jwksAlgoSettings,
		Type:             typ,
	}
}

func (u *ImportExportServiceDescriptorsSecComSettings) UnmarshalJSON(data []byte) error {
	var d *json.Decoder

	hsAlgoSettings := new(HSAlgoSettings)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&hsAlgoSettings); err == nil {
		u.HSAlgoSettings = hsAlgoSettings
		u.Type = ImportExportServiceDescriptorsSecComSettingsTypeHSAlgoSettings
		return nil
	}

	rsAlgoSettings := new(RSAlgoSettings)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&rsAlgoSettings); err == nil {
		u.RSAlgoSettings = rsAlgoSettings
		u.Type = ImportExportServiceDescriptorsSecComSettingsTypeRSAlgoSettings
		return nil
	}

	esAlgoSettings := new(ESAlgoSettings)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&esAlgoSettings); err == nil {
		u.ESAlgoSettings = esAlgoSettings
		u.Type = ImportExportServiceDescriptorsSecComSettingsTypeESAlgoSettings
		return nil
	}

	jwksAlgoSettings := new(JWKSAlgoSettings)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&jwksAlgoSettings); err == nil {
		u.JWKSAlgoSettings = jwksAlgoSettings
		u.Type = ImportExportServiceDescriptorsSecComSettingsTypeJWKSAlgoSettings
		return nil
	}

	return errors.New("could not unmarshal into supported union types")
}

func (u ImportExportServiceDescriptorsSecComSettings) MarshalJSON() ([]byte, error) {
	if u.HSAlgoSettings != nil {
		return json.Marshal(u.HSAlgoSettings)
	}

	if u.RSAlgoSettings != nil {
		return json.Marshal(u.RSAlgoSettings)
	}

	if u.ESAlgoSettings != nil {
		return json.Marshal(u.ESAlgoSettings)
	}

	if u.JWKSAlgoSettings != nil {
		return json.Marshal(u.JWKSAlgoSettings)
	}

	return nil, nil
}

// ImportExportServiceDescriptors - An otoroshi service descriptor. Represent a forward HTTP call on a domain to another location with some optional api management mecanism
type ImportExportServiceDescriptors struct {
	// The configuration of the canary mode for a service descriptor
	Canary *Canary `json:"Canary,omitempty"`
	// Specify headers that will be added to each client request. Useful to add authentication
	AdditionalHeaders map[string]string `json:"additionalHeaders,omitempty"`
	// The Open API configuration for your service (if one)
	API *ExposedAPI `json:"api,omitempty"`
	// A reference to a global auth module config
	AuthConfigRef *string `json:"authConfigRef,omitempty"`
	// Display a construction page when a user try to use the service
	BuildMode bool `json:"buildMode"`
	// Configuration for the faults that can be injected in requests
	ChaosConfig *ChaosConfig `json:"chaosConfig,omitempty"`
	// The configuration of the circuit breaker for a service descriptor
	ClientConfig *ClientConfig `json:"clientConfig,omitempty"`
	// A reference to validation authority
	ClientValidatorRef *string `json:"clientValidatorRef,omitempty"`
	// The configuration for cors support
	Cors *CorsSettings `json:"cors,omitempty"`
	// The domain on which the service is available.
	Domain string `json:"domain"`
	// Activate or deactivate your service. Once disabled, users will get an error page saying the service does not exist
	Enabled bool `json:"enabled"`
	// When enabled, Otoroshi will try to exchange headers with downstream service to ensure no one else can use the service from outside
	EnforceSecureCommunication bool `json:"enforceSecureCommunication"`
	// The line on which the service is available. Based on that value, the name of the line will be appended to the subdomain. For line prod, nothing will be appended. For example, if the subdomain is 'foo' and line is 'preprod', then the exposed service will be available at 'foo.preprod.mydomain'
	Env string `json:"env"`
	// Will force redirection to https:// if not present
	ForceHTTPS bool `json:"forceHttps"`
	// Each service descriptor is attached to groups. A group can have one or more services. Each API key is linked to a group and allow access to every service in the group
	Groups []string `json:"groups"`
	// Configuration for gzip of service responses
	Gzip *Gzip `json:"gzip,omitempty"`
	// Specify headers that will be verified after routing.
	HeadersVerification map[string]string `json:"headersVerification,omitempty"`
	// The configuration for checking health of a service. Otoroshi will perform GET call on the URL to check if the service is still alive
	HealthCheck *HealthCheck `json:"healthCheck,omitempty"`
	// A unique random string to identify your service
	ID string `json:"id"`
	// The filtering configuration block for a service of globally.
	IPFiltering *IPFiltering                               `json:"ipFiltering,omitempty"`
	JwtVerifier *ImportExportServiceDescriptorsJwtVerifier `json:"jwtVerifier,omitempty"`
	// The host used localy, mainly localhost:xxxx
	LocalHost *string `json:"localHost,omitempty"`
	// The scheme used localy, mainly http
	LocalScheme *string `json:"localScheme,omitempty"`
	// Display a maintainance page when a user try to use the service
	MaintenanceMode bool `json:"maintenanceMode"`
	// Specify headers that MUST be present on client request to route it. Useful to implement versioning
	MatchingHeaders map[string]string `json:"matchingHeaders,omitempty"`
	// The root path on which the service is available
	MatchingRoot *string `json:"matchingRoot,omitempty"`
	// Just a bunch of random properties
	Metadata map[string]string `json:"metadata,omitempty"`
	// The name of your service. Only for debug and human readability purposes
	Name string `json:"name"`
	// Host header will be overriden with Host of the target
	OverrideHost *bool `json:"overrideHost,omitempty"`
	// When enabled, user will be allowed to use the service (UI) only if they are registered users of the private apps domain
	PrivateApp bool `json:"privateApp"`
	// If you define a public pattern that is a little bit too much, you can make some of public URL private again
	PrivatePatterns []string `json:"privatePatterns,omitempty"`
	// By default, every services are private only and you'll need an API key to access it. However, if you want to expose a public UI, you can define one or more public patterns (regex) to allow access to anybody. For example if you want to allow anybody on any URL, just use '/.*'
	PublicPatterns []string `json:"publicPatterns,omitempty"`
	// If you work locally with Otoroshi, you may want to use that feature to redirect one particuliar service to a local host. For example, you can relocate https://foo.preprod.bar.com to http://localhost:8080 to make some tests
	RedirectToLocal *bool `json:"redirectToLocal,omitempty"`
	// The configuration for redirection per service
	Redirection *RedirectionSettings `json:"redirection,omitempty"`
	// Otoroshi will append this root to any target choosen. If the specified root is '/api/foo', then a request to https://yyyyyyy/bar will actually hit https://xxxxxxxxx/api/foo/bar
	Root string `json:"root"`
	// URI patterns excluded from secured communications
	SecComExcludedPatterns []string                                      `json:"secComExcludedPatterns,omitempty"`
	SecComSettings         *ImportExportServiceDescriptorsSecComSettings `json:"secComSettings,omitempty"`
	// When enabled, Otoroshi will send headers to consumer like request id, client latency, overhead, etc ...
	SendOtoroshiHeadersBack *bool `json:"sendOtoroshiHeadersBack,omitempty"`
	// The configuration for statsd metrics push
	StatsdConfig *StatsdConfig `json:"statsdConfig,omitempty"`
	// The subdomain on which the service is available
	Subdomain string `json:"subdomain"`
	// The list of target that Otoroshi will proxy and expose through the subdomain defined before. Otoroshi will do round-robin load balancing between all those targets with circuit breaker mecanism to avoid cascading failures
	Targets []Target `json:"targets"`
	// A reference to a request transformer
	TransformerRef *string `json:"transformerRef,omitempty"`
	// The fact that this service will be seen by users and cannot be impacted by the Snow Monkey
	UserFacing *bool `json:"userFacing,omitempty"`
	// Send X-Forwarded-* headers
	XForwardedHeaders *bool `json:"xForwardedHeaders,omitempty"`
}

// ImportExportServiceGroups - An Otoroshi service group is just a group of service descriptor. It is useful to be able to define Api Keys for the whole group
type ImportExportServiceGroups struct {
	// The descriptoin of the group
	Description *string `json:"description,omitempty"`
	// The unique id of the group. Usually 64 random alpha numerical characters, but can be anything
	ID string `json:"id"`
	// The name of the group
	Name string `json:"name"`
}

// ImportExportSimpleAdmins - Administrator using just login/password tuple to access Otoroshi
type ImportExportSimpleAdmins struct {
	// The creation date of the user
	CreatedAt int64 `json:"createdAt"`
	// The label for the user
	Label string `json:"label"`
	// The hashed password of the user
	Password string `json:"password"`
	// The email address of the user
	Username string `json:"username"`
}

// ImportExport - The structure that can be imported to or exported from Otoroshi. It represent the memory state of Otoroshi
type ImportExport struct {
	// Current U2F admin at the time of export
	Admins []ImportExportAdmins `json:"admins"`
	// Current apik keys at the time of export
	APIKeys []ImportExportAPIKeys `json:"apiKeys"`
	// Current env variables at the time of export
	AppConfig map[string]string `json:"appConfig,omitempty"`
	// The global config object of Otoroshi, used to customize settings of the current Otoroshi instance
	Config  GlobalConfig `json:"config"`
	Date    time.Time    `json:"date"`
	DateRaw int64        `json:"dateRaw"`
	// Current error templates at the time of export
	ErrorTemplates []ImportExportErrorTemplates `json:"errorTemplates"`
	Label          string                       `json:"label"`
	// Current service descriptors at the time of export
	ServiceDescriptors []ImportExportServiceDescriptors `json:"serviceDescriptors"`
	// Current service groups at the time of export
	ServiceGroups []ImportExportServiceGroups `json:"serviceGroups"`
	// Current simple admins at the time of export
	SimpleAdmins []ImportExportSimpleAdmins `json:"simpleAdmins"`
	// Global stats for the current Otoroshi instances
	Stats ImportExportStats `json:"stats"`
}
