"""Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT."""

from __future__ import annotations
import dataclasses
from ..shared import category as shared_category
from ..shared import picture as shared_picture
from ..shared import tag as shared_tag
from ..shared import user as shared_user
from dataclasses_json import Undefined, dataclass_json
from enum import Enum
from sdk import utils


@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class ChannelMetadataConnectionsPrivacyUsers:
    r"""Information provided to channel moderators about which users they have specifically permitted to access a private channel. This data requires a bearer token with the `private` scope."""
    
    options: list[str] = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('options') }})
    r"""An array of HTTP methods permitted on this URI. This data requires a bearer token with the `private` scope."""  
    total: float = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('total') }})
    r"""The total number of users on this connection. This data requires a bearer token with the `private` scope."""  
    uri: str = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('uri') }})
    r"""The API URI that resolves to the connection data. This data requires a bearer token with the `private` scope."""  
    

@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class ChannelMetadataConnectionsUsers:
    r"""Information about the users following or moderating this channel."""
    
    options: list[str] = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('options') }})
    r"""An array of HTTP methods permitted on this URI."""  
    total: float = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('total') }})
    r"""The total number of users on this connection."""  
    uri: str = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('uri') }})
    r"""The API URI that resolves to the connection data."""  
    

@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class ChannelMetadataConnectionsVideos:
    r"""Information about the videos that belong to this channel."""
    
    options: list[str] = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('options') }})
    r"""An array of HTTP methods permitted on this URI."""  
    total: float = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('total') }})
    r"""The total number of videos on this connection."""  
    uri: str = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('uri') }})
    r"""The API URI that resolves to the connection data."""  
    

@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class ChannelMetadataConnections:
    r"""A collection of information that is connected to this resource."""
    
    privacy_users: ChannelMetadataConnectionsPrivacyUsers = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('privacy_users') }})
    r"""Information provided to channel moderators about which users they have specifically permitted to access a private channel. This data requires a bearer token with the `private` scope."""  
    users: ChannelMetadataConnectionsUsers = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('users') }})
    r"""Information about the users following or moderating this channel."""  
    videos: ChannelMetadataConnectionsVideos = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('videos') }})
    r"""Information about the videos that belong to this channel."""  
    

@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class ChannelMetadataInteractionsAddModerators:
    r"""An action indicating that the authenticated user is the owner of the channel and may therefore add other users as channel moderators. This data requires a bearer token with the `private` scope."""
    
    options: list[str] = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('options') }})
    r"""An array of HTTP methods permitted on this URI. This data requires a bearer token with the `private` scope."""  
    uri: str = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('uri') }})
    r"""The API URI that resolves to the connection data. This data requires a bearer token with the `private` scope."""  
    

@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class ChannelMetadataInteractionsAddTo:
    r"""When a channel appears in the context of adding or removing a video from it (`/videos/{video_id}/available_channels`), include information about adding or removing the video. This data requires a bearer token with the `private` scope."""
    
    options: list[str] = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('options') }})
    r"""An array of HTTP methods permitted on this URI. This data requires a bearer token with the `private` scope."""  
    uri: str = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('uri') }})
    r"""The API URI that resolves to the connection data. This data requires a bearer token with the `private` scope."""  
    
class ChannelMetadataInteractionsFollowTypeEnum(str, Enum):
    r"""Whether the authenticated user is a moderator or subscriber. This data requires a bearer token with the `private` scope.
    
    Option descriptions:
     * `moderator` - The authenticated user is a moderator.
     * `subscriber` - The authenticated user is a subscriber.
    """
    MODERATOR = 'moderator'
    SUBSCRIBER = 'subscriber'


@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class ChannelMetadataInteractionsFollow:
    r"""An action indicating if the authenticated user has followed this channel. This data requires a bearer token with the `private` scope."""
    
    added: bool = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('added') }})
    r"""Whether the authenticated user has followed this channel. This data requires a bearer token with the `private` scope."""  
    added_time: str = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('added_time') }})
    r"""The time in ISO 8601 format that the user followed this channel, or the null value if the user hasn't followed the channel. This data requires a bearer token with the `private` scope."""  
    type: ChannelMetadataInteractionsFollowTypeEnum = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('type') }})
    r"""Whether the authenticated user is a moderator or subscriber. This data requires a bearer token with the `private` scope.
    
    Option descriptions:
     * `moderator` - The authenticated user is a moderator.
     * `subscriber` - The authenticated user is a subscriber.
    """  
    uri: str = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('uri') }})
    r"""The URI for following or unfollowing this channel. PUT to this URI to follow the channel, or DELETE to this URI to unfollow the channel. This data requires a bearer token with the `private` scope."""  
    

@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class ChannelMetadataInteractionsModerateVideos:
    r"""An action indicating that the authenticated user is a moderator of the channel and may therefore add or remove videos from the channel. This data requires a bearer token with the `private` scope."""
    
    options: list[str] = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('options') }})
    r"""An array of HTTP methods allowed on this URI. This data requires a bearer token with the `private` scope."""  
    uri: str = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('uri') }})
    r"""The API URI that resolves to the connection data. This data requires a bearer token with the `private` scope."""  
    

@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class ChannelMetadataInteractions:
    r"""A list of resource URIs related to the channel."""
    
    add_moderators: ChannelMetadataInteractionsAddModerators = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('add_moderators') }})
    r"""An action indicating that the authenticated user is the owner of the channel and may therefore add other users as channel moderators. This data requires a bearer token with the `private` scope."""  
    add_to: ChannelMetadataInteractionsAddTo = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('add_to') }})
    r"""When a channel appears in the context of adding or removing a video from it (`/videos/{video_id}/available_channels`), include information about adding or removing the video. This data requires a bearer token with the `private` scope."""  
    follow: ChannelMetadataInteractionsFollow = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('follow') }})
    r"""An action indicating if the authenticated user has followed this channel. This data requires a bearer token with the `private` scope."""  
    moderate_videos: ChannelMetadataInteractionsModerateVideos = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('moderate_videos') }})
    r"""An action indicating that the authenticated user is a moderator of the channel and may therefore add or remove videos from the channel. This data requires a bearer token with the `private` scope."""  
    

@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class ChannelMetadata:
    r"""Metadata about the channel."""
    
    connections: ChannelMetadataConnections = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('connections') }})
    r"""A collection of information that is connected to this resource."""  
    interactions: ChannelMetadataInteractions = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('interactions') }})
    r"""A list of resource URIs related to the channel."""  
    
class ChannelPrivacyViewEnum(str, Enum):
    r"""Who can view the channel:
    
    Option descriptions:
     * `anybody` - Anyone can view the channel.
     * `moderators` - Only moderators can view the channel.
     * `users` - Only registered users can view the channel.
    """
    ANYBODY = 'anybody'
    MODERATORS = 'moderators'
    USERS = 'users'


@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class ChannelPrivacy:
    r"""The privacy settings of the channel."""
    
    view: ChannelPrivacyViewEnum = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('view') }})
    r"""Who can view the channel:
    
    Option descriptions:
     * `anybody` - Anyone can view the channel.
     * `moderators` - Only moderators can view the channel.
     * `users` - Only registered users can view the channel.
    """  
    

@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class Channel:
    r"""The channel was created."""
    
    categories: list[shared_category.Category] = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('categories') }})
    r"""The categories to which this channel belongs as specified by the channel moderators."""  
    created_time: str = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('created_time') }})
    r"""The time in ISO 8601 format when the channel was created."""  
    description: str = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('description') }})
    r"""A brief explanation of the channel's content."""  
    header: shared_picture.Picture = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('header') }})
    r"""The banner that appears by default at the top of the channel page."""  
    link: str = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('link') }})
    r"""The URL to access the channel in a browser."""  
    metadata: ChannelMetadata = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('metadata') }})
    r"""Metadata about the channel."""  
    modified_time: str = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('modified_time') }})
    r"""The time in ISO 8601 format when the album was last modified."""  
    name: str = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('name') }})
    r"""The display name that identifies the channel."""  
    pictures: shared_picture.Picture = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('pictures') }})
    r"""The active image for the channel; defaults to the thumbnail of the last video added to the channel."""  
    privacy: ChannelPrivacy = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('privacy') }})
    r"""The privacy settings of the channel."""  
    resource_key: str = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('resource_key') }})
    r"""The channel resource key."""  
    tags: list[shared_tag.Tag] = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('tags') }})
    r"""An array of all tags assigned to this channel."""  
    uri: str = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('uri') }})
    r"""The unique identifier to access the channel resource."""  
    user: shared_user.User = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('user') }})
    r"""The Vimeo user who owns the channel."""  
    