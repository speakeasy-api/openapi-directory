<?php

/**
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

declare(strict_types=1);

namespace OpenAPI\OpenAPI;

class PortfolioAnalysis 
{

	// SDK private variables namespaced with _ to avoid conflicts with API models
	private \GuzzleHttp\ClientInterface $_defaultClient;
	private \GuzzleHttp\ClientInterface $_securityClient;
	private string $_serverUrl;
	private string $_language;
	private string $_sdkVersion;
	private string $_genVersion;	

	/**
	 * @param \GuzzleHttp\ClientInterface $defaultClient
	 * @param \GuzzleHttp\ClientInterface $securityClient
	 * @param string $serverUrl
	 * @param string $language
	 * @param string $sdkVersion
	 * @param string $genVersion
	 */
	public function __construct(\GuzzleHttp\ClientInterface $defaultClient, \GuzzleHttp\ClientInterface $securityClient, string $serverUrl, string $language, string $sdkVersion, string $genVersion)
	{
		$this->_defaultClient = $defaultClient;
		$this->_securityClient = $securityClient;
		$this->_serverUrl = $serverUrl;
		$this->_language = $language;
		$this->_sdkVersion = $sdkVersion;
		$this->_genVersion = $genVersion;
	}
	
    /**
     * Alpha
     * 
     * Compute the Jensenâ€™s alpha of one or several portfolio(s) in the Capital Asset Pricing Model (CAPM).
     * 
     * References
     * * Carl R. Bacon, Practical Portfolio Performance Measurement and Attribution  
     * 
     * 
     * @param mixed $request
     * @return \OpenAPI\OpenAPI\Models\Operations\PostPortfolioAnalysisAlphaResponse
     */
	public function postPortfolioAnalysisAlpha(
        mixed $request,
    ): \OpenAPI\OpenAPI\Models\Operations\PostPortfolioAnalysisAlphaResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/portfolio/analysis/alpha');
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "request", "json");
        if ($body === null) {
            throw new \Exception('Request body is required');
        }
        $options = array_merge_recursive($options, $body);
        
        $httpResponse = $this->_securityClient->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\PostPortfolioAnalysisAlphaResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->postPortfolioAnalysisAlpha200ApplicationJSONObject = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Operations\PostPortfolioAnalysisAlpha200ApplicationJSON', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Beta
     * 
     * Compute the beta of one or several portfolio(s) in the Capital Asset Pricing Model (CAPM).
     * 
     * References
     * * Carl R. Bacon, Practical Portfolio Performance Measurement and Attribution  
     * 
     * 
     * @param mixed $request
     * @return \OpenAPI\OpenAPI\Models\Operations\PostPortfolioAnalysisBetaResponse
     */
	public function postPortfolioAnalysisBeta(
        mixed $request,
    ): \OpenAPI\OpenAPI\Models\Operations\PostPortfolioAnalysisBetaResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/portfolio/analysis/beta');
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "request", "json");
        if ($body === null) {
            throw new \Exception('Request body is required');
        }
        $options = array_merge_recursive($options, $body);
        
        $httpResponse = $this->_securityClient->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\PostPortfolioAnalysisBetaResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->postPortfolioAnalysisBeta200ApplicationJSONObject = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Operations\PostPortfolioAnalysisBeta200ApplicationJSON', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Return Contributions
     * 
     * Perform a return contribution analysis of one or several portfolio(s), optionally using groups of assets.
     * 
     * References
     * * Carl R. Bacon, Practical Portfolio Performance Measurement and Attribution
     * 
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\PostPortfolioAnalysisContributionsReturnRequestBody $request
     * @return \OpenAPI\OpenAPI\Models\Operations\PostPortfolioAnalysisContributionsReturnResponse
     */
	public function postPortfolioAnalysisContributionsReturn(
        \OpenAPI\OpenAPI\Models\Operations\PostPortfolioAnalysisContributionsReturnRequestBody $request,
    ): \OpenAPI\OpenAPI\Models\Operations\PostPortfolioAnalysisContributionsReturnResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/portfolio/analysis/contributions/return');
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "request", "json");
        if ($body === null) {
            throw new \Exception('Request body is required');
        }
        $options = array_merge_recursive($options, $body);
        
        $httpResponse = $this->_securityClient->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\PostPortfolioAnalysisContributionsReturnResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->postPortfolioAnalysisContributionsReturn200ApplicationJSONObject = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Operations\PostPortfolioAnalysisContributionsReturn200ApplicationJSON', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Risk Contributions
     * 
     * Perform a risk contribution analysis of one or several portfolio(s), optionally using groups of assets.
     * 
     * References
     * * Carl R. Bacon, Practical Portfolio Performance Measurement and Attribution
     * 
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\PostPortfolioAnalysisContributionsRiskRequestBody $request
     * @return \OpenAPI\OpenAPI\Models\Operations\PostPortfolioAnalysisContributionsRiskResponse
     */
	public function postPortfolioAnalysisContributionsRisk(
        \OpenAPI\OpenAPI\Models\Operations\PostPortfolioAnalysisContributionsRiskRequestBody $request,
    ): \OpenAPI\OpenAPI\Models\Operations\PostPortfolioAnalysisContributionsRiskResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/portfolio/analysis/contributions/risk');
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "request", "json");
        if ($body === null) {
            throw new \Exception('Request body is required');
        }
        $options = array_merge_recursive($options, $body);
        
        $httpResponse = $this->_securityClient->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\PostPortfolioAnalysisContributionsRiskResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->postPortfolioAnalysisContributionsRisk200ApplicationJSONObject = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Operations\PostPortfolioAnalysisContributionsRisk200ApplicationJSON', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Correlation Spectrum
     * 
     * Compute the correlation spectrum of one or several portfolio(s).
     * 
     * References
     * * [Tristan Froidure, Khalid Jalalzai and Yves Choueifaty, Portfolio Rho-Representativity, International Journal of Theoretical and Applied FinanceVol. 22, No. 07, 1950034 (2019)](https://www.worldscientific.com/doi/10.1142/S0219024919500341)
     * 
     * 
     * @param mixed $request
     * @return \OpenAPI\OpenAPI\Models\Operations\PostPortfolioAnalysisCorrelationSpectrumResponse
     */
	public function postPortfolioAnalysisCorrelationSpectrum(
        mixed $request,
    ): \OpenAPI\OpenAPI\Models\Operations\PostPortfolioAnalysisCorrelationSpectrumResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/portfolio/analysis/correlation-spectrum');
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "request", "json");
        if ($body === null) {
            throw new \Exception('Request body is required');
        }
        $options = array_merge_recursive($options, $body);
        
        $httpResponse = $this->_securityClient->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\PostPortfolioAnalysisCorrelationSpectrumResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->postPortfolioAnalysisCorrelationSpectrum200ApplicationJSONObject = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Operations\PostPortfolioAnalysisCorrelationSpectrum200ApplicationJSON', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Diversification Ratio
     * 
     * Compute the diversification ratio of one or several portfolio(s).
     * 
     * References
     * * [Yves Choueifaty and Yves Coignard, Toward Maximum Diversification, The Journal of Portfolio Management Fall 2008, 35 (1) 40-51](https://doi.org/10.3905/JPM.2008.35.1.40)
     * * [Tristan Froidure, Khalid Jalalzai and Yves Choueifaty, Portfolio Rho-Representativity, International Journal of Theoretical and Applied FinanceVol. 22, No. 07, 1950034 (2019)](https://www.worldscientific.com/doi/10.1142/S0219024919500341)
     * 
     * 
     * @param mixed $request
     * @return \OpenAPI\OpenAPI\Models\Operations\PostPortfolioAnalysisDiversificationRatioResponse
     */
	public function postPortfolioAnalysisDiversificationRatio(
        mixed $request,
    ): \OpenAPI\OpenAPI\Models\Operations\PostPortfolioAnalysisDiversificationRatioResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/portfolio/analysis/diversification-ratio');
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "request", "json");
        if ($body === null) {
            throw new \Exception('Request body is required');
        }
        $options = array_merge_recursive($options, $body);
        
        $httpResponse = $this->_securityClient->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\PostPortfolioAnalysisDiversificationRatioResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->postPortfolioAnalysisDiversificationRatio200ApplicationJSONObject = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Operations\PostPortfolioAnalysisDiversificationRatio200ApplicationJSON', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Drawdowns
     * 
     * Compute the drawdown function - also called the underwater equity curve -, as well as the worst 10 drawdowns of one or several portfolio(s).
     * 
     * References
     * * [Wikipedia, Drawdown](https://en.wikipedia.org/wiki/Drawdown_(economics))        
     * 
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\PostPortfolioAnalysisDrawdownsRequestBody $request
     * @return \OpenAPI\OpenAPI\Models\Operations\PostPortfolioAnalysisDrawdownsResponse
     */
	public function postPortfolioAnalysisDrawdowns(
        \OpenAPI\OpenAPI\Models\Operations\PostPortfolioAnalysisDrawdownsRequestBody $request,
    ): \OpenAPI\OpenAPI\Models\Operations\PostPortfolioAnalysisDrawdownsResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/portfolio/analysis/drawdowns');
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "request", "json");
        if ($body === null) {
            throw new \Exception('Request body is required');
        }
        $options = array_merge_recursive($options, $body);
        
        $httpResponse = $this->_securityClient->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\PostPortfolioAnalysisDrawdownsResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->postPortfolioAnalysisDrawdowns200ApplicationJSONObject = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Operations\PostPortfolioAnalysisDrawdowns200ApplicationJSON', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Effective Number of Bets
     * 
     * Compute the effective number of bets of one or several portfolio(s).
     * 
     * References
     * * [Meucci, Attilio and Santangelo, Alberto and Deguest, Romain, Risk Budgeting and Diversification Based on Optimized Uncorrelated Factors (November 10, 2015)](https://papers.ssrn.com/sol3/papers.cfm?abstract_id=2276632)
     * 
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\PostPortfolioAnalysisEffectiveNumberOfBetsRequestBody $request
     * @return \OpenAPI\OpenAPI\Models\Operations\PostPortfolioAnalysisEffectiveNumberOfBetsResponse
     */
	public function postPortfolioAnalysisEffectiveNumberOfBets(
        \OpenAPI\OpenAPI\Models\Operations\PostPortfolioAnalysisEffectiveNumberOfBetsRequestBody $request,
    ): \OpenAPI\OpenAPI\Models\Operations\PostPortfolioAnalysisEffectiveNumberOfBetsResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/portfolio/analysis/effective-number-of-bets');
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "request", "json");
        if ($body === null) {
            throw new \Exception('Request body is required');
        }
        $options = array_merge_recursive($options, $body);
        
        $httpResponse = $this->_securityClient->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\PostPortfolioAnalysisEffectiveNumberOfBetsResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->postPortfolioAnalysisEffectiveNumberOfBets200ApplicationJSONObject = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Operations\PostPortfolioAnalysisEffectiveNumberOfBets200ApplicationJSON', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Factor Exposures
     * 
     * Compute the exposures of one or several portfolio(s) to a set of factors, using a returns-based linear regression analysis.
     * 
     * References
     * * [Measuring Factor Exposures: Uses and Abuses, Ronen Israel and Adrienne Ross, The Journal of Alternative Investments Summer 2017, 20 (1) 10-25](https://jai.pm-research.com/content/20/1/10.short) 
     * 
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\PostPortfolioAnalysisFactorsExposuresRequestBody $request
     * @return \OpenAPI\OpenAPI\Models\Operations\PostPortfolioAnalysisFactorsExposuresResponse
     */
	public function postPortfolioAnalysisFactorsExposures(
        \OpenAPI\OpenAPI\Models\Operations\PostPortfolioAnalysisFactorsExposuresRequestBody $request,
    ): \OpenAPI\OpenAPI\Models\Operations\PostPortfolioAnalysisFactorsExposuresResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/portfolio/analysis/factors/exposures');
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "request", "json");
        if ($body === null) {
            throw new \Exception('Request body is required');
        }
        $options = array_merge_recursive($options, $body);
        
        $httpResponse = $this->_securityClient->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\PostPortfolioAnalysisFactorsExposuresResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->postPortfolioAnalysisFactorsExposures200ApplicationJSONObject = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Operations\PostPortfolioAnalysisFactorsExposures200ApplicationJSON', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Mean-Variance Efficient Frontier
     * 
     * Compute the discretized mean-variance efficient frontier associated to a list of assets, optionally subject to:
     * * Minimum and maximum weights constraints
     * * Maximum group weights constraints
     * * Minimum and maximum portfolio exposure constraint
     * 
     * References
     *  * Harry M. Markowitz, Portfolio Selection, Efficient Diversification of Investments, Second edition, Blackwell Publishers Inc.
     * 
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\PostPortfolioAnalysisMeanVarianceEfficientFrontierRequestBody $request
     * @return \OpenAPI\OpenAPI\Models\Operations\PostPortfolioAnalysisMeanVarianceEfficientFrontierResponse
     */
	public function postPortfolioAnalysisMeanVarianceEfficientFrontier(
        \OpenAPI\OpenAPI\Models\Operations\PostPortfolioAnalysisMeanVarianceEfficientFrontierRequestBody $request,
    ): \OpenAPI\OpenAPI\Models\Operations\PostPortfolioAnalysisMeanVarianceEfficientFrontierResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/portfolio/analysis/mean-variance/efficient-frontier');
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "request", "json");
        if ($body === null) {
            throw new \Exception('Request body is required');
        }
        $options = array_merge_recursive($options, $body);
        
        $httpResponse = $this->_securityClient->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\PostPortfolioAnalysisMeanVarianceEfficientFrontierResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->postPortfolioAnalysisMeanVarianceEfficientFrontier200ApplicationJSONObject = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Operations\PostPortfolioAnalysisMeanVarianceEfficientFrontier200ApplicationJSON', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Mean-Variance Minimum Variance Frontier
     * 
     * Compute the discretized mean-variance minimum variance frontier associated to a list of assets, optionally subject to:
     * * Minimum and maximum weights constraints
     * * Maximum group weights constraints
     * * Minimum and maximum portfolio exposure constraint
     * 
     * > This endpoint is similar to the endpoint [`/portfolio/analysis/mean-variance/efficient-frontier`](#post-/portfolio/analysis/mean-variance/efficient-frontier), because the mean-variance efficient frontier is the "top" portion of the mean-variance minimum variance frontier.
     * 
     * References
     *  * Harry M. Markowitz, Portfolio Selection, Efficient Diversification of Investments, Second edition, Blackwell Publishers Inc.
     * 
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\PostPortfolioAnalysisMeanVarianceMinimumVarianceFrontierRequestBody $request
     * @return \OpenAPI\OpenAPI\Models\Operations\PostPortfolioAnalysisMeanVarianceMinimumVarianceFrontierResponse
     */
	public function postPortfolioAnalysisMeanVarianceMinimumVarianceFrontier(
        \OpenAPI\OpenAPI\Models\Operations\PostPortfolioAnalysisMeanVarianceMinimumVarianceFrontierRequestBody $request,
    ): \OpenAPI\OpenAPI\Models\Operations\PostPortfolioAnalysisMeanVarianceMinimumVarianceFrontierResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/portfolio/analysis/mean-variance/minimum-variance-frontier');
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "request", "json");
        if ($body === null) {
            throw new \Exception('Request body is required');
        }
        $options = array_merge_recursive($options, $body);
        
        $httpResponse = $this->_securityClient->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\PostPortfolioAnalysisMeanVarianceMinimumVarianceFrontierResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->postPortfolioAnalysisMeanVarianceMinimumVarianceFrontier200ApplicationJSONObject = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Operations\PostPortfolioAnalysisMeanVarianceMinimumVarianceFrontier200ApplicationJSON', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Arithmetic Return
     * 
     * Compute the arithmetic return of one or several portfolio(s) from either:  
     * * Portfolio assets arithmetic returns
     * * Portfolio values
     * 
     * References
     * * [Wikipedia, Rate of Return](https://en.wikipedia.org/wiki/Rate_of_return#Return)
     * * Harry M. Markowitz, Portfolio Selection, Efficient Diversification of Investments, Second edition, Blackwell Publishers Inc.
     * 
     * 
     * @param mixed $request
     * @return \OpenAPI\OpenAPI\Models\Operations\PostPortfolioAnalysisReturnResponse
     */
	public function postPortfolioAnalysisReturn(
        mixed $request,
    ): \OpenAPI\OpenAPI\Models\Operations\PostPortfolioAnalysisReturnResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/portfolio/analysis/return');
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "request", "json");
        if ($body === null) {
            throw new \Exception('Request body is required');
        }
        $options = array_merge_recursive($options, $body);
        
        $httpResponse = $this->_securityClient->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\PostPortfolioAnalysisReturnResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->postPortfolioAnalysisReturn200ApplicationJSONObject = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Operations\PostPortfolioAnalysisReturn200ApplicationJSON', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Arithmetic Average Return
     * 
     * Compute the arithmetic average of the arithmetic return(s) of one or several portfolio(s).
     * 
     * References
     * * [Wikipedia, Arithmetic Average Rate of Return](https://en.wikipedia.org/wiki/Rate_of_return#Arithmetic_average_rate_of_return)
     * 
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\PostPortfolioAnalysisReturnsAverageRequestBody $request
     * @return \OpenAPI\OpenAPI\Models\Operations\PostPortfolioAnalysisReturnsAverageResponse
     */
	public function postPortfolioAnalysisReturnsAverage(
        \OpenAPI\OpenAPI\Models\Operations\PostPortfolioAnalysisReturnsAverageRequestBody $request,
    ): \OpenAPI\OpenAPI\Models\Operations\PostPortfolioAnalysisReturnsAverageResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/portfolio/analysis/returns/average');
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "request", "json");
        if ($body === null) {
            throw new \Exception('Request body is required');
        }
        $options = array_merge_recursive($options, $body);
        
        $httpResponse = $this->_securityClient->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\PostPortfolioAnalysisReturnsAverageResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->postPortfolioAnalysisReturnsAverage200ApplicationJSONObject = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Operations\PostPortfolioAnalysisReturnsAverage200ApplicationJSON', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Tracking Error
     * 
     * Compute the tracking error between a benchmark and one or several portfolio(s).
     * 
     * References
     * * [Wikipedia, Tracking error](https://en.wikipedia.org/wiki/Tracking_error) 
     * * Carl R. Bacon, Practical Portfolio Performance Measurement and Attribution 
     * 
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\PostPortfolioAnalysisTrackingErrorRequestBody $request
     * @return \OpenAPI\OpenAPI\Models\Operations\PostPortfolioAnalysisTrackingErrorResponse
     */
	public function postPortfolioAnalysisTrackingError(
        \OpenAPI\OpenAPI\Models\Operations\PostPortfolioAnalysisTrackingErrorRequestBody $request,
    ): \OpenAPI\OpenAPI\Models\Operations\PostPortfolioAnalysisTrackingErrorResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/portfolio/analysis/tracking-error');
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "request", "json");
        if ($body === null) {
            throw new \Exception('Request body is required');
        }
        $options = array_merge_recursive($options, $body);
        
        $httpResponse = $this->_securityClient->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\PostPortfolioAnalysisTrackingErrorResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->postPortfolioAnalysisTrackingError200ApplicationJSONObject = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Operations\PostPortfolioAnalysisTrackingError200ApplicationJSON', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Ulcer Index
     * 
     * Compute the Ulcer Index of one or several portfolio(s).
     * 
     * References
     * * Carl R. Bacon, Practical Portfolio Performance Measurement and Attribution
     * * [Peter G. Martin, Ulcer Index, An Alternative Approach to the Measurement of Investment Risk & Risk-Adjusted Performance](http://www.tangotools.com/ui/ui.htm)
     * 
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\PostPortfolioAnalysisUlcerIndexRequestBody $request
     * @return \OpenAPI\OpenAPI\Models\Operations\PostPortfolioAnalysisUlcerIndexResponse
     */
	public function postPortfolioAnalysisUlcerIndex(
        \OpenAPI\OpenAPI\Models\Operations\PostPortfolioAnalysisUlcerIndexRequestBody $request,
    ): \OpenAPI\OpenAPI\Models\Operations\PostPortfolioAnalysisUlcerIndexResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/portfolio/analysis/ulcer-index');
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "request", "json");
        if ($body === null) {
            throw new \Exception('Request body is required');
        }
        $options = array_merge_recursive($options, $body);
        
        $httpResponse = $this->_securityClient->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\PostPortfolioAnalysisUlcerIndexResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->postPortfolioAnalysisUlcerIndex200ApplicationJSONObject = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Operations\PostPortfolioAnalysisUlcerIndex200ApplicationJSON', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Ulcer Performance Index
     * 
     * Compute the Ulcer Performance Index of one or several portfolio(s).
     * 
     * References
     * * Carl R. Bacon, Practical Portfolio Performance Measurement and Attribution
     * * [Peter G. Martin, Ulcer Index, An Alternative Approach to the Measurement of Investment Risk & Risk-Adjusted Performance](http://www.tangotools.com/ui/ui.htm)
     * 
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\PostPortfolioAnalysisUlcerPerformanceIndexRequestBody $request
     * @return \OpenAPI\OpenAPI\Models\Operations\PostPortfolioAnalysisUlcerPerformanceIndexResponse
     */
	public function postPortfolioAnalysisUlcerPerformanceIndex(
        \OpenAPI\OpenAPI\Models\Operations\PostPortfolioAnalysisUlcerPerformanceIndexRequestBody $request,
    ): \OpenAPI\OpenAPI\Models\Operations\PostPortfolioAnalysisUlcerPerformanceIndexResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/portfolio/analysis/ulcer-performance-index');
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "request", "json");
        if ($body === null) {
            throw new \Exception('Request body is required');
        }
        $options = array_merge_recursive($options, $body);
        
        $httpResponse = $this->_securityClient->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\PostPortfolioAnalysisUlcerPerformanceIndexResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->postPortfolioAnalysisUlcerPerformanceIndex200ApplicationJSONObject = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Operations\PostPortfolioAnalysisUlcerPerformanceIndex200ApplicationJSON', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Volatility
     * 
     * Compute the volatility (i.e., standard deviation) of one or several portfolio(s) from either:  
     * * Portfolio assets covariance matrix
     * * Portfolio values
     * 
     * References
     * * [Wikipedia, Standard Deviation](https://en.wikipedia.org/wiki/Standard_deviation#Finance)
     * * Carl R. Bacon, Practical Portfolio Performance Measurement and Attribution
     * * Harry M. Markowitz, Portfolio Selection, Efficient Diversification of Investments, Second edition, Blackwell Publishers Inc.
     * 
     * 
     * @param mixed $request
     * @return \OpenAPI\OpenAPI\Models\Operations\PostPortfolioAnalysisVolatilityResponse
     */
	public function postPortfolioAnalysisVolatility(
        mixed $request,
    ): \OpenAPI\OpenAPI\Models\Operations\PostPortfolioAnalysisVolatilityResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/portfolio/analysis/volatility');
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "request", "json");
        if ($body === null) {
            throw new \Exception('Request body is required');
        }
        $options = array_merge_recursive($options, $body);
        
        $httpResponse = $this->_securityClient->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\PostPortfolioAnalysisVolatilityResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->postPortfolioAnalysisVolatility200ApplicationJSONObject = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Operations\PostPortfolioAnalysisVolatility200ApplicationJSON', 'json');
            }
        }

        return $response;
    }
}