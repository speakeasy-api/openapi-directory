/*
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

import * as utils from "../internal/utils";
import * as operations from "./models/operations";
import { AxiosInstance, AxiosRequestConfig, AxiosResponse } from "axios";

export class Test {
  _defaultClient: AxiosInstance;
  _securityClient: AxiosInstance;
  _serverURL: string;
  _language: string;
  _sdkVersion: string;
  _genVersion: string;

  constructor(
    defaultClient: AxiosInstance,
    securityClient: AxiosInstance,
    serverURL: string,
    language: string,
    sdkVersion: string,
    genVersion: string
  ) {
    this._defaultClient = defaultClient;
    this._securityClient = securityClient;
    this._serverURL = serverURL;
    this._language = language;
    this._sdkVersion = sdkVersion;
    this._genVersion = genVersion;
  }

  /**
   * Logically deletes a test run
   */
  testArchiveTestRun(
    req: operations.TestArchiveTestRunRequest,
    security: operations.TestArchiveTestRunSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.TestArchiveTestRunResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.TestArchiveTestRunRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v0.1/apps/{owner_name}/{app_name}/test_runs/{test_run_id}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.TestArchiveTestRunSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.TestArchiveTestRunResponse =
        new operations.TestArchiveTestRunResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.testRun = utils.objectToClass(
              httpRes?.data,
              operations.TestArchiveTestRunTestRun
            );
          }
          break;
        case httpRes?.status == 404:
          break;
      }

      return res;
    });
  }

  /**
   * Creates a short ID for a list of devices
   */
  testCreateDeviceSelection(
    req: operations.TestCreateDeviceSelectionRequest,
    security: operations.TestCreateDeviceSelectionSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.TestCreateDeviceSelectionResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.TestCreateDeviceSelectionRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v0.1/apps/{owner_name}/{app_name}/device_selection",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.TestCreateDeviceSelectionSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.TestCreateDeviceSelectionResponse =
        new operations.TestCreateDeviceSelectionResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.deviceSelection = utils.objectToClass(
              httpRes?.data,
              operations.TestCreateDeviceSelectionDeviceSelection
            );
          }
          break;
        case httpRes?.status == 400:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.testCloudErrorDetails = utils.objectToClass(
              httpRes?.data,
              operations.TestCreateDeviceSelectionTestCloudErrorDetails
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Creates a device set belonging to the owner
   */
  testCreateDeviceSetOfOwner(
    req: operations.TestCreateDeviceSetOfOwnerRequest,
    security: operations.TestCreateDeviceSetOfOwnerSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.TestCreateDeviceSetOfOwnerResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.TestCreateDeviceSetOfOwnerRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v0.1/apps/{owner_name}/{app_name}/owner/device_sets",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.TestCreateDeviceSetOfOwnerSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.TestCreateDeviceSetOfOwnerResponse =
        new operations.TestCreateDeviceSetOfOwnerResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.deviceSet = utils.objectToClass(
              httpRes?.data,
              operations.TestCreateDeviceSetOfOwnerDeviceSet
            );
          }
          break;
        case httpRes?.status == 400:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.testCloudErrorDetails = utils.objectToClass(
              httpRes?.data,
              operations.TestCreateDeviceSetOfOwnerTestCloudErrorDetails
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Creates a device set belonging to the user
   */
  testCreateDeviceSetOfUser(
    req: operations.TestCreateDeviceSetOfUserRequest,
    security: operations.TestCreateDeviceSetOfUserSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.TestCreateDeviceSetOfUserResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.TestCreateDeviceSetOfUserRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v0.1/apps/{owner_name}/{app_name}/user/device_sets",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.TestCreateDeviceSetOfUserSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.TestCreateDeviceSetOfUserResponse =
        new operations.TestCreateDeviceSetOfUserResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.deviceSet = utils.objectToClass(
              httpRes?.data,
              operations.TestCreateDeviceSetOfUserDeviceSet
            );
          }
          break;
        case httpRes?.status == 400:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.testCloudErrorDetails = utils.objectToClass(
              httpRes?.data,
              operations.TestCreateDeviceSetOfUserTestCloudErrorDetails
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Accept a free trial subscription
   */
  testCreateSubscription(
    req: operations.TestCreateSubscriptionRequest,
    security: operations.TestCreateSubscriptionSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.TestCreateSubscriptionResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.TestCreateSubscriptionRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v0.1/apps/{owner_name}/{app_name}/subscriptions",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.TestCreateSubscriptionSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "post",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.TestCreateSubscriptionResponse =
        new operations.TestCreateSubscriptionResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.subscription = utils.objectToClass(
              httpRes?.data,
              operations.TestCreateSubscriptionSubscription
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Creates a new test run
   */
  testCreateTestRun(
    req: operations.TestCreateTestRunRequest,
    security: operations.TestCreateTestRunSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.TestCreateTestRunResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.TestCreateTestRunRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v0.1/apps/{owner_name}/{app_name}/test_runs",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.TestCreateTestRunSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "post",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.TestCreateTestRunResponse =
        new operations.TestCreateTestRunResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
          headers: utils.getHeadersFromResponse(httpRes.headers),
        });
      switch (true) {
        case httpRes?.status == 201:
          break;
      }

      return res;
    });
  }

  /**
   * Creates new test series for an application
   */
  testCreateTestSeries(
    req: operations.TestCreateTestSeriesRequest,
    security: operations.TestCreateTestSeriesSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.TestCreateTestSeriesResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.TestCreateTestSeriesRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v0.1/apps/{owner_name}/{app_name}/test_series",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.TestCreateTestSeriesSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.TestCreateTestSeriesResponse =
        new operations.TestCreateTestSeriesResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.testSeries = utils.objectToClass(
              httpRes?.data,
              operations.TestCreateTestSeriesTestSeries
            );
          }
          break;
        case httpRes?.status == 400:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.testCloudErrorDetails = utils.objectToClass(
              httpRes?.data,
              operations.TestCreateTestSeriesTestCloudErrorDetails
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Deletes a device set belonging to the owner
   */
  testDeleteDeviceSetOfOwner(
    req: operations.TestDeleteDeviceSetOfOwnerRequest,
    security: operations.TestDeleteDeviceSetOfOwnerSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.TestDeleteDeviceSetOfOwnerResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.TestDeleteDeviceSetOfOwnerRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v0.1/apps/{owner_name}/{app_name}/owner/device_sets/{id}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.TestDeleteDeviceSetOfOwnerSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.TestDeleteDeviceSetOfOwnerResponse =
        new operations.TestDeleteDeviceSetOfOwnerResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case [200, 404].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Deletes a device set belonging to the user
   */
  testDeleteDeviceSetOfUser(
    req: operations.TestDeleteDeviceSetOfUserRequest,
    security: operations.TestDeleteDeviceSetOfUserSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.TestDeleteDeviceSetOfUserResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.TestDeleteDeviceSetOfUserRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v0.1/apps/{owner_name}/{app_name}/user/device_sets/{id}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.TestDeleteDeviceSetOfUserSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.TestDeleteDeviceSetOfUserResponse =
        new operations.TestDeleteDeviceSetOfUserResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case [200, 404].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Deletes a single test series
   */
  testDeleteTestSeries(
    req: operations.TestDeleteTestSeriesRequest,
    security: operations.TestDeleteTestSeriesSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.TestDeleteTestSeriesResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.TestDeleteTestSeriesRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v0.1/apps/{owner_name}/{app_name}/test_series/{test_series_slug}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.TestDeleteTestSeriesSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.TestDeleteTestSeriesResponse =
        new operations.TestDeleteTestSeriesResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case [200, 404].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Lists account data
   */
  testGdprExportAccount(
    config?: AxiosRequestConfig
  ): Promise<operations.TestGdprExportAccountResponse> {
    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/v0.1/account/test/export/accounts";

    const client: AxiosInstance = this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.TestGdprExportAccountResponse =
        new operations.TestGdprExportAccountResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.testGdprExportAccount200ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.TestGdprExportAccount200ApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Lists all the endpoints available for Test accounts data
   */
  testGdprExportAccounts(
    config?: AxiosRequestConfig
  ): Promise<operations.TestGdprExportAccountsResponse> {
    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/v0.1/account/test/export";

    const client: AxiosInstance = this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.TestGdprExportAccountsResponse =
        new operations.TestGdprExportAccountsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.testGdprExportAccounts200ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.TestGdprExportAccounts200ApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Lists app data
   */
  testGdprExportApp(
    req: operations.TestGdprExportAppRequest,
    security: operations.TestGdprExportAppSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.TestGdprExportAppResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.TestGdprExportAppRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v0.1/apps/{owner_name}/{app_name}/test/export/apps",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.TestGdprExportAppSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.TestGdprExportAppResponse =
        new operations.TestGdprExportAppResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.testGdprExportApp200ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.TestGdprExportApp200ApplicationJSON
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Lists all the endpoints available for Test apps data
   */
  testGdprExportApps(
    req: operations.TestGdprExportAppsRequest,
    security: operations.TestGdprExportAppsSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.TestGdprExportAppsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.TestGdprExportAppsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v0.1/apps/{owner_name}/{app_name}/test/export",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.TestGdprExportAppsSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.TestGdprExportAppsResponse =
        new operations.TestGdprExportAppsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.testGdprExportApps200ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.TestGdprExportApps200ApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Lists feature flag data
   */
  testGdprExportFeatureFlag(
    config?: AxiosRequestConfig
  ): Promise<operations.TestGdprExportFeatureFlagResponse> {
    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/v0.1/account/test/export/featureFlags";

    const client: AxiosInstance = this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.TestGdprExportFeatureFlagResponse =
        new operations.TestGdprExportFeatureFlagResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.testGdprExportFeatureFlag200ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.TestGdprExportFeatureFlag200ApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Lists file set file data
   */
  testGdprExportFileSetFile(
    req: operations.TestGdprExportFileSetFileRequest,
    security: operations.TestGdprExportFileSetFileSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.TestGdprExportFileSetFileResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.TestGdprExportFileSetFileRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v0.1/apps/{owner_name}/{app_name}/test/export/fileSetFiles",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.TestGdprExportFileSetFileSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.TestGdprExportFileSetFileResponse =
        new operations.TestGdprExportFileSetFileResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.testGdprExportFileSetFile200ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.TestGdprExportFileSetFile200ApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Lists hash file data
   */
  testGdprExportHashFile(
    req: operations.TestGdprExportHashFileRequest,
    security: operations.TestGdprExportHashFileSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.TestGdprExportHashFileResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.TestGdprExportHashFileRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v0.1/apps/{owner_name}/{app_name}/test/export/hashFiles",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.TestGdprExportHashFileSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.TestGdprExportHashFileResponse =
        new operations.TestGdprExportHashFileResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.testGdprExportHashFile200ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.TestGdprExportHashFile200ApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Lists pipeline test data
   */
  testGdprExportPipelineTest(
    req: operations.TestGdprExportPipelineTestRequest,
    security: operations.TestGdprExportPipelineTestSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.TestGdprExportPipelineTestResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.TestGdprExportPipelineTestRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v0.1/apps/{owner_name}/{app_name}/test/export/pipelineTests",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.TestGdprExportPipelineTestSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.TestGdprExportPipelineTestResponse =
        new operations.TestGdprExportPipelineTestResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.testGdprExportPipelineTest200ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.TestGdprExportPipelineTest200ApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Lists test run data
   */
  testGdprExportTestRun(
    req: operations.TestGdprExportTestRunRequest,
    security: operations.TestGdprExportTestRunSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.TestGdprExportTestRunResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.TestGdprExportTestRunRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v0.1/apps/{owner_name}/{app_name}/test/export/testRuns",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.TestGdprExportTestRunSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.TestGdprExportTestRunResponse =
        new operations.TestGdprExportTestRunResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.testGdprExportTestRun200ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.TestGdprExportTestRun200ApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Returns list of all test runs for a given test series
   */
  testGetAllTestRunsForSeries(
    req: operations.TestGetAllTestRunsForSeriesRequest,
    security: operations.TestGetAllTestRunsForSeriesSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.TestGetAllTestRunsForSeriesResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.TestGetAllTestRunsForSeriesRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v0.1/apps/{owner_name}/{app_name}/test_series/{test_series_slug}/test_runs",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.TestGetAllTestRunsForSeriesSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.TestGetAllTestRunsForSeriesResponse =
        new operations.TestGetAllTestRunsForSeriesResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.testRuns = [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.testRuns = utils.objectToClass(
              httpRes?.data,
              operations.TestGetAllTestRunsForSeriesTestRun,
              resFieldDepth
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Returns list of all test series for an application
   */
  testGetAllTestSeries(
    req: operations.TestGetAllTestSeriesRequest,
    security: operations.TestGetAllTestSeriesSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.TestGetAllTestSeriesResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.TestGetAllTestSeriesRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v0.1/apps/{owner_name}/{app_name}/test_series",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.TestGetAllTestSeriesSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.TestGetAllTestSeriesResponse =
        new operations.TestGetAllTestSeriesResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.testSeries = [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.testSeries = utils.objectToClass(
              httpRes?.data,
              operations.TestGetAllTestSeriesTestSeries,
              resFieldDepth
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Returns a list of available devices
   */
  testGetDeviceConfigurations(
    req: operations.TestGetDeviceConfigurationsRequest,
    security: operations.TestGetDeviceConfigurationsSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.TestGetDeviceConfigurationsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.TestGetDeviceConfigurationsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v0.1/apps/{owner_name}/{app_name}/device_configurations",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.TestGetDeviceConfigurationsSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.TestGetDeviceConfigurationsResponse =
        new operations.TestGetDeviceConfigurationsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.testGetDeviceConfigurations200ApplicationJSONObjects = [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.testGetDeviceConfigurations200ApplicationJSONObjects =
              utils.objectToClass(
                httpRes?.data,
                operations.TestGetDeviceConfigurations200ApplicationJSON,
                resFieldDepth
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Gets a device set belonging to the owner
   */
  testGetDeviceSetOfOwner(
    req: operations.TestGetDeviceSetOfOwnerRequest,
    security: operations.TestGetDeviceSetOfOwnerSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.TestGetDeviceSetOfOwnerResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.TestGetDeviceSetOfOwnerRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v0.1/apps/{owner_name}/{app_name}/owner/device_sets/{id}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.TestGetDeviceSetOfOwnerSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.TestGetDeviceSetOfOwnerResponse =
        new operations.TestGetDeviceSetOfOwnerResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.deviceSet = utils.objectToClass(
              httpRes?.data,
              operations.TestGetDeviceSetOfOwnerDeviceSet
            );
          }
          break;
        case httpRes?.status == 404:
          break;
      }

      return res;
    });
  }

  /**
   * Gets a device set belonging to the user
   */
  testGetDeviceSetOfUser(
    req: operations.TestGetDeviceSetOfUserRequest,
    security: operations.TestGetDeviceSetOfUserSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.TestGetDeviceSetOfUserResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.TestGetDeviceSetOfUserRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v0.1/apps/{owner_name}/{app_name}/user/device_sets/{id}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.TestGetDeviceSetOfUserSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.TestGetDeviceSetOfUserResponse =
        new operations.TestGetDeviceSetOfUserResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.deviceSet = utils.objectToClass(
              httpRes?.data,
              operations.TestGetDeviceSetOfUserDeviceSet
            );
          }
          break;
        case httpRes?.status == 404:
          break;
      }

      return res;
    });
  }

  /**
   * Get information about the currently active subscriptions, if any
   */
  testGetSubscriptions(
    req: operations.TestGetSubscriptionsRequest,
    security: operations.TestGetSubscriptionsSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.TestGetSubscriptionsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.TestGetSubscriptionsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v0.1/apps/{owner_name}/{app_name}/subscriptions",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.TestGetSubscriptionsSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.TestGetSubscriptionsResponse =
        new operations.TestGetSubscriptionsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.subscription = utils.objectToClass(
              httpRes?.data,
              operations.TestGetSubscriptionsSubscription
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Returns a single test report
   */
  testGetTestReport(
    req: operations.TestGetTestReportRequest,
    security: operations.TestGetTestReportSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.TestGetTestReportResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.TestGetTestReportRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v0.1/apps/{owner_name}/{app_name}/test_runs/{test_run_id}/report",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.TestGetTestReportSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.TestGetTestReportResponse =
        new operations.TestGetTestReportResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.testGetTestReport200ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.TestGetTestReport200ApplicationJSON
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Returns a single test runs
   */
  testGetTestRun(
    req: operations.TestGetTestRunRequest,
    security: operations.TestGetTestRunSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.TestGetTestRunResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.TestGetTestRunRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v0.1/apps/{owner_name}/{app_name}/test_runs/{test_run_id}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.TestGetTestRunSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.TestGetTestRunResponse =
        new operations.TestGetTestRunResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.testRun = utils.objectToClass(
              httpRes?.data,
              operations.TestGetTestRunTestRun
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Gets state of the test run
   */
  testGetTestRunState(
    req: operations.TestGetTestRunStateRequest,
    security: operations.TestGetTestRunStateSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.TestGetTestRunStateResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.TestGetTestRunStateRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v0.1/apps/{owner_name}/{app_name}/test_runs/{test_run_id}/state",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.TestGetTestRunStateSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.TestGetTestRunStateResponse =
        new operations.TestGetTestRunStateResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.testRunState = utils.objectToClass(
              httpRes?.data,
              operations.TestGetTestRunStateTestRunState
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Returns a list of test runs
   */
  testGetTestRuns(
    req: operations.TestGetTestRunsRequest,
    security: operations.TestGetTestRunsSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.TestGetTestRunsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.TestGetTestRunsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v0.1/apps/{owner_name}/{app_name}/test_runs",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.TestGetTestRunsSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.TestGetTestRunsResponse =
        new operations.TestGetTestRunsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.testRuns = [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.testRuns = utils.objectToClass(
              httpRes?.data,
              operations.TestGetTestRunsTestRun,
              resFieldDepth
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Lists device sets belonging to the owner
   */
  testListDeviceSetsOfOwner(
    req: operations.TestListDeviceSetsOfOwnerRequest,
    security: operations.TestListDeviceSetsOfOwnerSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.TestListDeviceSetsOfOwnerResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.TestListDeviceSetsOfOwnerRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v0.1/apps/{owner_name}/{app_name}/owner/device_sets",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.TestListDeviceSetsOfOwnerSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.TestListDeviceSetsOfOwnerResponse =
        new operations.TestListDeviceSetsOfOwnerResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.deviceSets = [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.deviceSets = utils.objectToClass(
              httpRes?.data,
              operations.TestListDeviceSetsOfOwnerDeviceSet,
              resFieldDepth
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Lists device sets belonging to the user
   */
  testListDeviceSetsOfUser(
    req: operations.TestListDeviceSetsOfUserRequest,
    security: operations.TestListDeviceSetsOfUserSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.TestListDeviceSetsOfUserResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.TestListDeviceSetsOfUserRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v0.1/apps/{owner_name}/{app_name}/user/device_sets",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.TestListDeviceSetsOfUserSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.TestListDeviceSetsOfUserResponse =
        new operations.TestListDeviceSetsOfUserResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.deviceSets = [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.deviceSets = utils.objectToClass(
              httpRes?.data,
              operations.TestListDeviceSetsOfUserDeviceSet,
              resFieldDepth
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Updates name and slug of a test series
   */
  testPatchTestSeries(
    req: operations.TestPatchTestSeriesRequest,
    security: operations.TestPatchTestSeriesSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.TestPatchTestSeriesResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.TestPatchTestSeriesRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v0.1/apps/{owner_name}/{app_name}/test_series/{test_series_slug}",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.TestPatchTestSeriesSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "patch",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.TestPatchTestSeriesResponse =
        new operations.TestPatchTestSeriesResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.testSeries = utils.objectToClass(
              httpRes?.data,
              operations.TestPatchTestSeriesTestSeries
            );
          }
          break;
        case [400, 404].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Starts test run
   */
  testStartTestRun(
    req: operations.TestStartTestRunRequest,
    security: operations.TestStartTestRunSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.TestStartTestRunResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.TestStartTestRunRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v0.1/apps/{owner_name}/{app_name}/test_runs/{test_run_id}/start",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.TestStartTestRunSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.TestStartTestRunResponse =
        new operations.TestStartTestRunResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.testCloudTestRunStartResult = utils.objectToClass(
              httpRes?.data,
              operations.TestStartTestRunTestCloudTestRunStartResult
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Uploads file for a test run
   */
  testStartUploadingFile(
    req: operations.TestStartUploadingFileRequest,
    security: operations.TestStartUploadingFileSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.TestStartUploadingFileResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.TestStartUploadingFileRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v0.1/apps/{owner_name}/{app_name}/test_runs/{test_run_id}/files",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.TestStartUploadingFileSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "post",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.TestStartUploadingFileResponse =
        new operations.TestStartUploadingFileResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
          headers: utils.getHeadersFromResponse(httpRes.headers),
        });
      switch (true) {
        case httpRes?.status == 200:
          break;
        case httpRes?.status == 400:
          break;
      }

      return res;
    });
  }

  /**
   * Stop a test run execution
   */
  testStopTestRun(
    req: operations.TestStopTestRunRequest,
    security: operations.TestStopTestRunSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.TestStopTestRunResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.TestStopTestRunRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v0.1/apps/{owner_name}/{app_name}/test_runs/{test_run_id}/stop",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.TestStopTestRunSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "put",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.TestStopTestRunResponse =
        new operations.TestStopTestRunResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.testRun = utils.objectToClass(
              httpRes?.data,
              operations.TestStopTestRunTestRun
            );
          }
          break;
        case httpRes?.status == 404:
          break;
      }

      return res;
    });
  }

  /**
   * Updates a device set belonging to the owner
   */
  testUpdateDeviceSetOfOwner(
    req: operations.TestUpdateDeviceSetOfOwnerRequest,
    security: operations.TestUpdateDeviceSetOfOwnerSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.TestUpdateDeviceSetOfOwnerResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.TestUpdateDeviceSetOfOwnerRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v0.1/apps/{owner_name}/{app_name}/owner/device_sets/{id}",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.TestUpdateDeviceSetOfOwnerSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "put",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.TestUpdateDeviceSetOfOwnerResponse =
        new operations.TestUpdateDeviceSetOfOwnerResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.deviceSet = utils.objectToClass(
              httpRes?.data,
              operations.TestUpdateDeviceSetOfOwnerDeviceSet
            );
          }
          break;
        case httpRes?.status == 400:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.testCloudErrorDetails = utils.objectToClass(
              httpRes?.data,
              operations.TestUpdateDeviceSetOfOwnerTestCloudErrorDetails
            );
          }
          break;
        case httpRes?.status == 404:
          break;
      }

      return res;
    });
  }

  /**
   * Updates a device set belonging to the user
   */
  testUpdateDeviceSetOfUser(
    req: operations.TestUpdateDeviceSetOfUserRequest,
    security: operations.TestUpdateDeviceSetOfUserSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.TestUpdateDeviceSetOfUserResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.TestUpdateDeviceSetOfUserRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v0.1/apps/{owner_name}/{app_name}/user/device_sets/{id}",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.TestUpdateDeviceSetOfUserSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "put",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.TestUpdateDeviceSetOfUserResponse =
        new operations.TestUpdateDeviceSetOfUserResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.deviceSet = utils.objectToClass(
              httpRes?.data,
              operations.TestUpdateDeviceSetOfUserDeviceSet
            );
          }
          break;
        case httpRes?.status == 400:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.testCloudErrorDetails = utils.objectToClass(
              httpRes?.data,
              operations.TestUpdateDeviceSetOfUserTestCloudErrorDetails
            );
          }
          break;
        case httpRes?.status == 404:
          break;
      }

      return res;
    });
  }

  /**
   * Adds file with the given hash to a test run
   */
  testUploadHash(
    req: operations.TestUploadHashRequest,
    security: operations.TestUploadHashSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.TestUploadHashResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.TestUploadHashRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v0.1/apps/{owner_name}/{app_name}/test_runs/{test_run_id}/hashes",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.TestUploadHashSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.TestUploadHashResponse =
        new operations.TestUploadHashResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
          headers: utils.getHeadersFromResponse(httpRes.headers),
        });
      switch (true) {
        case [201, 412].includes(httpRes?.status):
          break;
        case httpRes?.status == 401:
          break;
      }

      return res;
    });
  }

  /**
   * Adds file with the given hash to a test run
   */
  testUploadHashesBatch(
    req: operations.TestUploadHashesBatchRequest,
    security: operations.TestUploadHashesBatchSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.TestUploadHashesBatchResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.TestUploadHashesBatchRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v0.1/apps/{owner_name}/{app_name}/test_runs/{test_run_id}/hashes/batch",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.TestUploadHashesBatchSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.TestUploadHashesBatchResponse =
        new operations.TestUploadHashesBatchResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.testCloudFileHashResponses = [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.testCloudFileHashResponses = utils.objectToClass(
              httpRes?.data,
              operations.TestUploadHashesBatchTestCloudFileHashResponse,
              resFieldDepth
            );
          }
          break;
      }

      return res;
    });
  }
}
