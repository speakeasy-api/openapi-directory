"""Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT."""

import requests as requests_http
from . import utils
from sdk.models import operations, shared
from typing import Optional

class Messages:
    r"""Manage conversations and messages with other users. <br /><br /> It's important to note that messages are always sent by email to the users.   So it's possible to create a fully functional app using the trash nothing API without using any of the conversations or messages API endpoints.  These API endpoints are useful for developers who want to build a complete messaging interface into their app."""
    _client: requests_http.Session
    _security_client: requests_http.Session
    _server_url: str
    _language: str
    _sdk_version: str
    _gen_version: str

    def __init__(self, client: requests_http.Session, security_client: requests_http.Session, server_url: str, language: str, sdk_version: str, gen_version: str) -> None:
        self._client = client
        self._security_client = security_client
        self._server_url = server_url
        self._language = language
        self._sdk_version = sdk_version
        self._gen_version = gen_version
        
    def archive_all_conversations(self, request: operations.ArchiveAllConversationsRequestBody) -> operations.ArchiveAllConversationsResponse:
        r"""Archive all conversations"""
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/conversations/archive-all'
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request", 'multipart')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = self._security_client
        
        http_res = client.request('PUT', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ArchiveAllConversationsResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        

        return res

    def archive_conversation(self, request: operations.ArchiveConversationRequest) -> operations.ArchiveConversationResponse:
        r"""Archive conversation"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.ArchiveConversationRequest, base_url, '/conversations/{conversation_id}/archive', request)
        
        
        client = self._security_client
        
        http_res = client.request('PUT', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ArchiveConversationResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        

        return res

    def block_conversation(self, request: operations.BlockConversationRequest) -> operations.BlockConversationResponse:
        r"""Block conversation"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.BlockConversationRequest, base_url, '/conversations/{conversation_id}/block', request)
        
        
        client = self._security_client
        
        http_res = client.request('PUT', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.BlockConversationResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        

        return res

    def delete_conversation(self, request: operations.DeleteConversationRequest) -> operations.DeleteConversationResponse:
        r"""Delete conversation"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.DeleteConversationRequest, base_url, '/conversations/{conversation_id}', request)
        
        query_params = utils.get_query_params(operations.DeleteConversationRequest, request)
        
        client = self._security_client
        
        http_res = client.request('DELETE', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DeleteConversationResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        

        return res

    def get_conversation_messages(self, request: operations.GetConversationMessagesRequest) -> operations.GetConversationMessagesResponse:
        r"""List conversation messages"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.GetConversationMessagesRequest, base_url, '/conversations/{conversation_id}/messages', request)
        
        query_params = utils.get_query_params(operations.GetConversationMessagesRequest, request)
        
        client = self._security_client
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetConversationMessagesResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.GetConversationMessages200ApplicationJSON])
                res.get_conversation_messages_200_application_json_object = out
        elif http_res.status_code in [400, 403, 404]:
            pass

        return res

    def get_conversations(self, request: operations.GetConversationsRequest) -> operations.GetConversationsResponse:
        r"""List conversations"""
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/conversations'
        
        query_params = utils.get_query_params(operations.GetConversationsRequest, request)
        
        client = self._security_client
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetConversationsResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.GetConversations200ApplicationJSON])
                res.get_conversations_200_application_json_object = out
        elif http_res.status_code == 400:
            pass

        return res

    def mark_all_conversations_read(self, request: operations.MarkAllConversationsReadRequestBody) -> operations.MarkAllConversationsReadResponse:
        r"""Mark all conversations as read"""
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/conversations/mark-all-read'
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request", 'multipart')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = self._security_client
        
        http_res = client.request('PUT', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.MarkAllConversationsReadResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        

        return res

    def mark_conversation_read(self, request: operations.MarkConversationReadRequest) -> operations.MarkConversationReadResponse:
        r"""Mark conversation as read"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.MarkConversationReadRequest, base_url, '/conversations/{conversation_id}/mark-read', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'multipart')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = self._security_client
        
        http_res = client.request('PUT', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.MarkConversationReadResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        

        return res

    def reply_to_conversation(self, request: operations.ReplyToConversationRequest) -> operations.ReplyToConversationResponse:
        r"""Reply to conversation"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.ReplyToConversationRequest, base_url, '/conversations/{conversation_id}/reply', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'multipart')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = self._security_client
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ReplyToConversationResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Message])
                res.message = out
        elif http_res.status_code in [400, 403, 404]:
            pass

        return res

    def report_conversation(self, request: operations.ReportConversationRequest) -> operations.ReportConversationResponse:
        r"""Report conversation"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.ReportConversationRequest, base_url, '/conversations/{conversation_id}/report', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'multipart')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = self._security_client
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ReportConversationResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        

        return res

    def search_conversations(self, request: operations.SearchConversationsRequest) -> operations.SearchConversationsResponse:
        r"""Search conversations
        Searches all conversations except blocked conversations.
        """
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/conversations/search'
        
        query_params = utils.get_query_params(operations.SearchConversationsRequest, request)
        
        client = self._security_client
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.SearchConversationsResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.SearchConversations200ApplicationJSON])
                res.search_conversations_200_application_json_object = out
        elif http_res.status_code == 400:
            pass

        return res

    def unarchive_conversation(self, request: operations.UnarchiveConversationRequest) -> operations.UnarchiveConversationResponse:
        r"""Unarchive conversation"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.UnarchiveConversationRequest, base_url, '/conversations/{conversation_id}/unarchive', request)
        
        
        client = self._security_client
        
        http_res = client.request('PUT', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.UnarchiveConversationResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        

        return res

    def unblock_conversation(self, request: operations.UnblockConversationRequest) -> operations.UnblockConversationResponse:
        r"""Unblock conversation"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.UnblockConversationRequest, base_url, '/conversations/{conversation_id}/unblock', request)
        
        
        client = self._security_client
        
        http_res = client.request('PUT', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.UnblockConversationResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        

        return res

    