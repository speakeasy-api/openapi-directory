"""Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT."""

import requests as requests_http
from . import utils
from sdk.models import operations
from typing import Any, Optional

class Build:
    _client: requests_http.Session
    _security_client: requests_http.Session
    _server_url: str
    _language: str
    _sdk_version: str
    _gen_version: str

    def __init__(self, client: requests_http.Session, security_client: requests_http.Session, server_url: str, language: str, sdk_version: str, gen_version: str) -> None:
        self._client = client
        self._security_client = security_client
        self._server_url = server_url
        self._language = language
        self._sdk_version = sdk_version
        self._gen_version = gen_version
        
    def branch_configurations_create(self, request: operations.BranchConfigurationsCreateRequest, security: operations.BranchConfigurationsCreateSecurity) -> operations.BranchConfigurationsCreateResponse:
        r"""Configures the branch for build"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.BranchConfigurationsCreateRequest, base_url, '/v0.1/apps/{owner_name}/{app_name}/branches/{branch}/config', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.BranchConfigurationsCreateResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.BranchConfigurationsCreate200ApplicationJSON])
                res.branch_configurations_create_200_application_json_object = out

        return res

    def branch_configurations_delete(self, request: operations.BranchConfigurationsDeleteRequest, security: operations.BranchConfigurationsDeleteSecurity) -> operations.BranchConfigurationsDeleteResponse:
        r"""Deletes the branch build configuration"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.BranchConfigurationsDeleteRequest, base_url, '/v0.1/apps/{owner_name}/{app_name}/branches/{branch}/config', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('DELETE', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.BranchConfigurationsDeleteResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.BranchConfigurationsDelete200ApplicationJSON])
                res.branch_configurations_delete_200_application_json_object = out

        return res

    def branch_configurations_get(self, request: operations.BranchConfigurationsGetRequest, security: operations.BranchConfigurationsGetSecurity) -> operations.BranchConfigurationsGetResponse:
        r"""Gets the branch configuration"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.BranchConfigurationsGetRequest, base_url, '/v0.1/apps/{owner_name}/{app_name}/branches/{branch}/config', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.BranchConfigurationsGetResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.BranchConfigurationsGet200ApplicationJSON])
                res.branch_configurations_get_200_application_json_object = out
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.BranchConfigurationsGetDefaultApplicationJSON])
                res.branch_configurations_get_default_application_json_object = out

        return res

    def branch_configurations_update(self, request: operations.BranchConfigurationsUpdateRequest, security: operations.BranchConfigurationsUpdateSecurity) -> operations.BranchConfigurationsUpdateResponse:
        r"""Reconfigures the branch for build"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.BranchConfigurationsUpdateRequest, base_url, '/v0.1/apps/{owner_name}/{app_name}/branches/{branch}/config', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('PUT', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.BranchConfigurationsUpdateResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.BranchConfigurationsUpdate200ApplicationJSON])
                res.branch_configurations_update_200_application_json_object = out

        return res

    def build_configurations_get(self, request: operations.BuildConfigurationsGetRequest, security: operations.BuildConfigurationsGetSecurity) -> operations.BuildConfigurationsGetResponse:
        r"""Gets the build configuration in Azure pipeline YAML format"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.BuildConfigurationsGetRequest, base_url, '/v0.1/apps/{owner_name}/{app_name}/branches/{branch}/export_config', request)
        
        query_params = utils.get_query_params(operations.BuildConfigurationsGetRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.BuildConfigurationsGetResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.BuildConfigurationsGet200ApplicationJSON])
                res.build_configurations_get_200_application_json_object = out
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.BuildConfigurationsGetDefaultApplicationJSON])
                res.build_configurations_get_default_application_json_object = out

        return res

    def builds_create(self, request: operations.BuildsCreateRequest, security: operations.BuildsCreateSecurity) -> operations.BuildsCreateResponse:
        r"""Create a build"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.BuildsCreateRequest, base_url, '/v0.1/apps/{owner_name}/{app_name}/branches/{branch}/builds', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.BuildsCreateResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.BuildsCreate200ApplicationJSON])
                res.builds_create_200_application_json_object = out

        return res

    def builds_distribute(self, request: operations.BuildsDistributeRequest, security: operations.BuildsDistributeSecurity) -> operations.BuildsDistributeResponse:
        r"""Distribute a build"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.BuildsDistributeRequest, base_url, '/v0.1/apps/{owner_name}/{app_name}/builds/{build_id}/distribute', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.BuildsDistributeResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.BuildsDistribute200ApplicationJSON])
                res.builds_distribute_200_application_json_object = out

        return res

    def builds_get(self, request: operations.BuildsGetRequest, security: operations.BuildsGetSecurity) -> operations.BuildsGetResponse:
        r"""Returns the build detail for the given build ID"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.BuildsGetRequest, base_url, '/v0.1/apps/{owner_name}/{app_name}/builds/{build_id}', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.BuildsGetResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.BuildsGet200ApplicationJSON])
                res.builds_get_200_application_json_object = out

        return res

    def builds_get_download_uri(self, request: operations.BuildsGetDownloadURIRequest, security: operations.BuildsGetDownloadURISecurity) -> operations.BuildsGetDownloadURIResponse:
        r"""Gets the download URI"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.BuildsGetDownloadURIRequest, base_url, '/v0.1/apps/{owner_name}/{app_name}/builds/{build_id}/downloads/{download_type}', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.BuildsGetDownloadURIResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.BuildsGetDownloadURI200ApplicationJSON])
                res.builds_get_download_uri_200_application_json_object = out

        return res

    def builds_get_log(self, request: operations.BuildsGetLogRequest, security: operations.BuildsGetLogSecurity) -> operations.BuildsGetLogResponse:
        r"""Get the build log"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.BuildsGetLogRequest, base_url, '/v0.1/apps/{owner_name}/{app_name}/builds/{build_id}/logs', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.BuildsGetLogResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.BuildsGetLog200ApplicationJSON])
                res.builds_get_log_200_application_json_object = out

        return res

    def builds_get_status_by_app_id(self, request: operations.BuildsGetStatusByAppIDRequest, security: operations.BuildsGetStatusByAppIDSecurity) -> operations.BuildsGetStatusByAppIDResponse:
        r"""Application specific build service status"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.BuildsGetStatusByAppIDRequest, base_url, '/v0.1/apps/{owner_name}/{app_name}/build_service_status', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.BuildsGetStatusByAppIDResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.BuildsGetStatusByAppID200ApplicationJSON])
                res.builds_get_status_by_app_id_200_application_json_object = out
        else:
            pass

        return res

    def builds_list_branches(self, request: operations.BuildsListBranchesRequest, security: operations.BuildsListBranchesSecurity) -> operations.BuildsListBranchesResponse:
        r"""Returns the list of Git branches for this application"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.BuildsListBranchesRequest, base_url, '/v0.1/apps/{owner_name}/{app_name}/branches', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.BuildsListBranchesResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[list[operations.BuildsListBranches200ApplicationJSON]])
                res.builds_list_branches_200_application_json_objects = out
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.BuildsListBranchesDefaultApplicationJSON])
                res.builds_list_branches_default_application_json_object = out

        return res

    def builds_list_by_branch(self, request: operations.BuildsListByBranchRequest, security: operations.BuildsListByBranchSecurity) -> operations.BuildsListByBranchResponse:
        r"""Returns the list of builds for the branch"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.BuildsListByBranchRequest, base_url, '/v0.1/apps/{owner_name}/{app_name}/branches/{branch}/builds', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.BuildsListByBranchResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[list[operations.BuildsListByBranch200ApplicationJSON]])
                res.builds_list_by_branch_200_application_json_objects = out

        return res

    def builds_list_toolset_projects(self, request: operations.BuildsListToolsetProjectsRequest, security: operations.BuildsListToolsetProjectsSecurity) -> operations.BuildsListToolsetProjectsResponse:
        r"""Returns the projects in the repository for the branch, for all toolsets"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.BuildsListToolsetProjectsRequest, base_url, '/v0.1/apps/{owner_name}/{app_name}/branches/{branch}/toolset_projects', request)
        
        query_params = utils.get_query_params(operations.BuildsListToolsetProjectsRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.BuildsListToolsetProjectsResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.BuildsListToolsetProjects200ApplicationJSON])
                res.builds_list_toolset_projects_200_application_json_object = out

        return res

    def builds_list_toolsets(self, request: operations.BuildsListToolsetsRequest, security: operations.BuildsListToolsetsSecurity) -> operations.BuildsListToolsetsResponse:
        r"""Returns available toolsets for application"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.BuildsListToolsetsRequest, base_url, '/v0.1/apps/{owner_name}/{app_name}/toolsets', request)
        
        query_params = utils.get_query_params(operations.BuildsListToolsetsRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.BuildsListToolsetsResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.BuildsListToolsets200ApplicationJSON])
                res.builds_list_toolsets_200_application_json_object = out
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.BuildsListToolsetsDefaultApplicationJSON])
                res.builds_list_toolsets_default_application_json_object = out

        return res

    def builds_list_xamarin_sdk_bundles(self, request: operations.BuildsListXamarinSDKBundlesRequest, security: operations.BuildsListXamarinSDKBundlesSecurity) -> operations.BuildsListXamarinSDKBundlesResponse:
        r"""Gets the Xamarin SDK bundles available to this app"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.BuildsListXamarinSDKBundlesRequest, base_url, '/v0.1/apps/{owner_name}/{app_name}/xamarin_sdk_bundles', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.BuildsListXamarinSDKBundlesResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[list[operations.BuildsListXamarinSDKBundles200ApplicationJSON]])
                res.builds_list_xamarin_sdk_bundles_200_application_json_objects = out
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.BuildsListXamarinSDKBundlesDefaultApplicationJSON])
                res.builds_list_xamarin_sdk_bundles_default_application_json_object = out

        return res

    def builds_list_xcode_versions(self, request: operations.BuildsListXcodeVersionsRequest, security: operations.BuildsListXcodeVersionsSecurity) -> operations.BuildsListXcodeVersionsResponse:
        r"""Gets the Xcode versions available to this app"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.BuildsListXcodeVersionsRequest, base_url, '/v0.1/apps/{owner_name}/{app_name}/xcode_versions', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.BuildsListXcodeVersionsResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[list[operations.BuildsListXcodeVersions200ApplicationJSON]])
                res.builds_list_xcode_versions_200_application_json_objects = out
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.BuildsListXcodeVersionsDefaultApplicationJSON])
                res.builds_list_xcode_versions_default_application_json_object = out

        return res

    def builds_update(self, request: operations.BuildsUpdateRequest, security: operations.BuildsUpdateSecurity) -> operations.BuildsUpdateResponse:
        r"""Cancels a build"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.BuildsUpdateRequest, base_url, '/v0.1/apps/{owner_name}/{app_name}/builds/{build_id}', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('PATCH', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.BuildsUpdateResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.BuildsUpdate200ApplicationJSON])
                res.builds_update_200_application_json_object = out

        return res

    def builds_webhook(self, request: dict[str, Any]) -> operations.BuildsWebhookResponse:
        r"""Public webhook sink"""
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/v0.1/public/hooks'
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        
        client = self._client
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.BuildsWebhookResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            pass
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.BuildsWebhookDefaultApplicationJSON])
                res.builds_webhook_default_application_json_object = out

        return res

    def commits_list_by_sha_list(self, request: operations.CommitsListByShaListRequest, security: operations.CommitsListByShaListSecurity) -> operations.CommitsListByShaListResponse:
        r"""Returns commit information for a batch of shas"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.CommitsListByShaListRequest, base_url, '/v0.1/apps/{owner_name}/{app_name}/commits/batch', request)
        
        query_params = utils.get_query_params(operations.CommitsListByShaListRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.CommitsListByShaListResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[list[operations.CommitsListByShaList200ApplicationJSON]])
                res.commits_list_by_sha_list_200_application_json_objects = out

        return res

    def file_assets_create(self, request: operations.FileAssetsCreateRequest, security: operations.FileAssetsCreateSecurity) -> operations.FileAssetsCreateResponse:
        r"""Create a new asset to upload a file"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.FileAssetsCreateRequest, base_url, '/v0.1/apps/{owner_name}/{app_name}/file_asset', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.FileAssetsCreateResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.FileAssetsCreate200ApplicationJSON])
                res.file_assets_create_200_application_json_object = out
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.FileAssetsCreateDefaultApplicationJSON])
                res.file_assets_create_default_application_json_object = out

        return res

    def repositories_list(self, request: operations.RepositoriesListRequest, security: operations.RepositoriesListSecurity) -> operations.RepositoriesListResponse:
        r"""Gets the repositories available from the source code host"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.RepositoriesListRequest, base_url, '/v0.1/apps/{owner_name}/{app_name}/source_hosts/{source_host}/repositories', request)
        
        query_params = utils.get_query_params(operations.RepositoriesListRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.RepositoriesListResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[list[operations.RepositoriesList200ApplicationJSON]])
                res.repositories_list_200_application_json_objects = out
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.RepositoriesListDefaultApplicationJSON])
                res.repositories_list_default_application_json_object = out

        return res

    def repository_configurations_create_or_update(self, request: operations.RepositoryConfigurationsCreateOrUpdateRequest, security: operations.RepositoryConfigurationsCreateOrUpdateSecurity) -> operations.RepositoryConfigurationsCreateOrUpdateResponse:
        r"""Configures the repository for build"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.RepositoryConfigurationsCreateOrUpdateRequest, base_url, '/v0.1/apps/{owner_name}/{app_name}/repo_config', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.RepositoryConfigurationsCreateOrUpdateResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.RepositoryConfigurationsCreateOrUpdate200ApplicationJSON])
                res.repository_configurations_create_or_update_200_application_json_object = out
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.RepositoryConfigurationsCreateOrUpdateDefaultApplicationJSON])
                res.repository_configurations_create_or_update_default_application_json_object = out

        return res

    def repository_configurations_delete(self, request: operations.RepositoryConfigurationsDeleteRequest, security: operations.RepositoryConfigurationsDeleteSecurity) -> operations.RepositoryConfigurationsDeleteResponse:
        r"""Removes the configuration for the repository"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.RepositoryConfigurationsDeleteRequest, base_url, '/v0.1/apps/{owner_name}/{app_name}/repo_config', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('DELETE', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.RepositoryConfigurationsDeleteResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.RepositoryConfigurationsDelete200ApplicationJSON])
                res.repository_configurations_delete_200_application_json_object = out
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.RepositoryConfigurationsDeleteDefaultApplicationJSON])
                res.repository_configurations_delete_default_application_json_object = out

        return res

    def repository_configurations_list(self, request: operations.RepositoryConfigurationsListRequest, security: operations.RepositoryConfigurationsListSecurity) -> operations.RepositoryConfigurationsListResponse:
        r"""Returns the repository build configuration status of the app"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.RepositoryConfigurationsListRequest, base_url, '/v0.1/apps/{owner_name}/{app_name}/repo_config', request)
        
        query_params = utils.get_query_params(operations.RepositoryConfigurationsListRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.RepositoryConfigurationsListResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[list[operations.RepositoryConfigurationsList200ApplicationJSON]])
                res.repository_configurations_list_200_application_json_anies = out
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.RepositoryConfigurationsListDefaultApplicationJSON])
                res.repository_configurations_list_default_application_json_object = out

        return res

    