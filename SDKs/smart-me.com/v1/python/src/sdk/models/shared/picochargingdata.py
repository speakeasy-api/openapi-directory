"""Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT."""

from __future__ import annotations
import dataclasses
import dateutil.parser
from dataclasses_json import Undefined, dataclass_json
from datetime import datetime
from enum import Enum
from marshmallow import fields
from sdk import utils
from typing import Optional

class PicoChargingDataConnectionModeEnum(str, Enum):
    r"""The mode how this station is connected to the cloud"""
    NETWORK_TO_CLOUD_CONNECTION_MODE_NO_CONNECTION = 'NetworkToCloudConnectionMode_NoConnection'
    NETWORK_TO_CLOUD_CONNECTION_MODE_DIRECT_WI_FI_CONNECTION = 'NetworkToCloudConnectionMode_DirectWiFiConnection'
    NETWORK_TO_CLOUD_CONNECTION_MODE_GPRS_CONNECTION = 'NetworkToCloudConnectionMode_GPRSConnection'
    NETWORK_TO_CLOUD_CONNECTION_MODE_NB_IOT_CONNECTION = 'NetworkToCloudConnectionMode_NBIotConnection'
    NETWORK_TO_CLOUD_CONNECTION_MODE_LTE_CAT_M1_CONNECTION = 'NetworkToCloudConnectionMode_LteCatM1Connection'
    NETWORK_TO_CLOUD_CONNECTION_MODE_MESH_WI_FI_CONNECTION = 'NetworkToCloudConnectionMode_MeshWiFiConnection'
    NETWORK_TO_CLOUD_CONNECTION_MODE_MESH_MOBILE_CONNECTION = 'NetworkToCloudConnectionMode_MeshMobileConnection'

class PicoChargingDataLastWarningOrErrorEnum(str, Enum):
    r"""The last warning or error of the station. This message is only shown if the warning or error happend in the last 5 minutes."""
    METER_DATALOGGER_EVENT = 'MeterDataloggerEvent'
    METER_RESTART = 'MeterRestart'
    POWER_DOWN = 'PowerDown'
    MISSING_PHASE_L1 = 'MissingPhaseL1'
    MISSING_PHASE_L2 = 'MissingPhaseL2'
    MISSING_PHASE_L3 = 'MissingPhaseL3'
    TAMPER_DETECTION_COVER = 'TamperDetectionCover'
    MAGNETIC_FIELD_DETECTION = 'MagneticFieldDetection'
    CLOCK_ADJUSTED = 'ClockAdjusted'
    OVERVOLTAGE = 'Overvoltage'
    UNDERVOLTAGE = 'Undervoltage'
    OVERVOLTAGE_L1 = 'OvervoltageL1'
    OVERVOLTAGE_L2 = 'OvervoltageL2'
    OVERVOLTAGE_L3 = 'OvervoltageL3'
    CHARGING_TRANSACTION = 'ChargingTransaction'
    PICO_ERROR_CONTROLLER_PANIC = 'PicoErrorControllerPanic'
    PICO_ERROR_MID_SERVICE_PANIC = 'PicoErrorMidServicePanic'
    PICO_WARNING_RCD_TRIGGERED = 'PicoWarningRcdTriggered'
    PICO_WARNING_CABLE_LOCK_ERROR = 'PicoWarningCableLockError'
    PICO_WARNING_DIODE_FAILURE = 'PicoWarningDiodeFailure'
    PICO_WARNING_OVERLOAD = 'PicoWarningOverload'
    PICO_WARNING_HIGH_TEMPERATURE = 'PicoWarningHighTemperature'

class PicoChargingDataLoadSheddingStateEnum(str, Enum):
    r"""Max. dynamic current (e.g. set over API or Modbus TCP) of this station or the loadmanagement group of the station if the station is in a group. in A"""
    MAX_CURRENT = 'MaxCurrent'
    HALF_CURRENT = 'HalfCurrent'
    MIN_CURRENT = 'MinCurrent'
    NO_CURRENT = 'NoCurrent'

class PicoChargingDataStateEnum(str, Enum):
    r"""The state of the charging station"""
    BOOTING = 'Booting'
    READY_NO_CAR_CONNECTED = 'ReadyNoCarConnected'
    READY_CAR_CONNECTED = 'ReadyCarConnected'
    STARTED_WAIT_FOR_CAR = 'StartedWaitForCar'
    CHARGING = 'Charging'
    INSTALLATION = 'Installation'
    AUTHORIZE = 'Authorize'
    OFFLINE = 'Offline'


@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class PicoChargingData:
    r"""Container class for the pico charging station API"""
    
    active_charging_energy: Optional[float] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('ActiveChargingEnergy'), 'exclude': lambda f: f is None }})
    r"""The energy used by this active charging (in kWh)"""  
    active_charging_power: Optional[float] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('ActiveChargingPower'), 'exclude': lambda f: f is None }})
    r"""The power of the active charging (in kW)"""  
    connection_mode: Optional[PicoChargingDataConnectionModeEnum] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('ConnectionMode'), 'exclude': lambda f: f is None }})
    r"""The mode how this station is connected to the cloud"""  
    duration: Optional[int] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('Duration'), 'exclude': lambda f: f is None }})
    r"""The duration of this charging in seconds"""  
    last_warning_or_error: Optional[PicoChargingDataLastWarningOrErrorEnum] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('LastWarningOrError'), 'exclude': lambda f: f is None }})
    r"""The last warning or error of the station. This message is only shown if the warning or error happend in the last 5 minutes."""  
    last_warning_or_error_message: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('LastWarningOrErrorMessage'), 'exclude': lambda f: f is None }})
    r"""The message of the last warning or error of the station."""  
    last_warning_or_error_time: Optional[datetime] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('LastWarningOrErrorTime'), 'encoder': utils.datetimeisoformat(True), 'decoder': dateutil.parser.isoparse, 'mm_field': fields.DateTime(format='iso'), 'exclude': lambda f: f is None }})
    r"""The time when the LastWarningOrError happend"""  
    loadmanagement_group_name: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('LoadmanagementGroupName'), 'exclude': lambda f: f is None }})
    r"""The name of the loadmanagement group. Or string.empty if the station is not in a group"""  
    load_shedding_state: Optional[PicoChargingDataLoadSheddingStateEnum] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('LoadSheddingState'), 'exclude': lambda f: f is None }})
    r"""Max. dynamic current (e.g. set over API or Modbus TCP) of this station or the loadmanagement group of the station if the station is in a group. in A"""  
    max_allowed_charging_current: Optional[int] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('MaxAllowedChargingCurrent'), 'exclude': lambda f: f is None }})
    r"""Max allowed charging current in A"""  
    max_dynamic_current: Optional[int] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('MaxDynamicCurrent'), 'exclude': lambda f: f is None }})
    r"""Max. dynamic current (e.g. set over API or Modbus TCP) of this station or the loadmanagement group of the station if the station is in a group. in A"""  
    max_loadmanagement_group_current: Optional[int] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('MaxLoadmanagementGroupCurrent'), 'exclude': lambda f: f is None }})
    r"""Max. current of the loadmanagement group of this station (if there is any) in A"""  
    max_station_current: Optional[int] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('MaxStationCurrent'), 'exclude': lambda f: f is None }})
    r"""Max. current of the station in A"""  
    min_station_current: Optional[int] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('MinStationCurrent'), 'exclude': lambda f: f is None }})
    r"""Min. current of the station in A"""  
    state: Optional[PicoChargingDataStateEnum] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('State'), 'exclude': lambda f: f is None }})
    r"""The state of the charging station"""  
    value_date: Optional[datetime] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('ValueDate'), 'encoder': utils.datetimeisoformat(True), 'decoder': dateutil.parser.isoparse, 'mm_field': fields.DateTime(format='iso'), 'exclude': lambda f: f is None }})
    r"""The date of this values"""  
    