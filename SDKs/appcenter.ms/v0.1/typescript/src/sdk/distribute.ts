/*
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

import * as utils from "../internal/utils";
import * as operations from "./models/operations";
import * as shared from "./models/shared";
import { AxiosInstance, AxiosRequestConfig, AxiosResponse } from "axios";

export class Distribute {
  _defaultClient: AxiosInstance;
  _securityClient: AxiosInstance;
  _serverURL: string;
  _language: string;
  _sdkVersion: string;
  _genVersion: string;

  constructor(
    defaultClient: AxiosInstance,
    securityClient: AxiosInstance,
    serverURL: string,
    language: string,
    sdkVersion: string,
    genVersion: string
  ) {
    this._defaultClient = defaultClient;
    this._securityClient = securityClient;
    this._serverURL = serverURL;
    this._language = language;
    this._sdkVersion = sdkVersion;
    this._genVersion = genVersion;
  }

  /**
   * Fetch all apple test flight groups
   */
  appleMappingTestFlightGroups(
    req: operations.AppleMappingTestFlightGroupsRequest,
    security: operations.AppleMappingTestFlightGroupsSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.AppleMappingTestFlightGroupsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.AppleMappingTestFlightGroupsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v0.1/apps/{owner_name}/{app_name}/apple_test_flight_groups",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.AppleMappingTestFlightGroupsSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.AppleMappingTestFlightGroupsResponse =
        new operations.AppleMappingTestFlightGroupsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.appleMappingTestFlightGroups200ApplicationJSONObjects = [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.appleMappingTestFlightGroups200ApplicationJSONObjects =
              utils.objectToClass(
                httpRes?.data,
                operations.AppleMappingTestFlightGroups200ApplicationJSON,
                resFieldDepth
              );
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.appleMappingTestFlightGroupsDefaultApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.AppleMappingTestFlightGroupsDefaultApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Create a mapping for an existing app in apple store for the specified application.
   */
  appleMappingCreate(
    req: operations.AppleMappingCreateRequest,
    security: operations.AppleMappingCreateSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.AppleMappingCreateResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.AppleMappingCreateRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v0.1/apps/{owner_name}/{app_name}/apple_mapping",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.AppleMappingCreateSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.AppleMappingCreateResponse =
        new operations.AppleMappingCreateResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.appleMappingCreate201ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.AppleMappingCreate201ApplicationJSON
              );
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.appleMappingCreateDefaultApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.AppleMappingCreateDefaultApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Delete mapping of apple app to an existing app in apple store.
   */
  appleMappingDelete(
    req: operations.AppleMappingDeleteRequest,
    security: operations.AppleMappingDeleteSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.AppleMappingDeleteResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.AppleMappingDeleteRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v0.1/apps/{owner_name}/{app_name}/apple_mapping",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "string"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.AppleMappingDeleteSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "delete",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.AppleMappingDeleteResponse =
        new operations.AppleMappingDeleteResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.appleMappingDeleteDefaultApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.AppleMappingDeleteDefaultApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Get mapping of apple app to an existing app in apple store.
   */
  appleMappingGet(
    req: operations.AppleMappingGetRequest,
    security: operations.AppleMappingGetSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.AppleMappingGetResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.AppleMappingGetRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v0.1/apps/{owner_name}/{app_name}/apple_mapping",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.AppleMappingGetSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.AppleMappingGetResponse =
        new operations.AppleMappingGetResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.appleMappingGet200ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.AppleMappingGet200ApplicationJSON
            );
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.appleMappingGetDefaultApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.AppleMappingGetDefaultApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Returns the device details.
   */
  devicesDeviceDetails(
    req: operations.DevicesDeviceDetailsRequest,
    security: operations.DevicesDeviceDetailsSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.DevicesDeviceDetailsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DevicesDeviceDetailsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v0.1/user/devices/{device_udid}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.DevicesDeviceDetailsSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DevicesDeviceDetailsResponse =
        new operations.DevicesDeviceDetailsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.devicesDeviceDetails200ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.DevicesDeviceDetails200ApplicationJSON
              );
          }
          break;
        case httpRes?.status == 400:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.devicesDeviceDetails400ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.DevicesDeviceDetails400ApplicationJSON
              );
          }
          break;
        case httpRes?.status == 403:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.devicesDeviceDetails403ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.DevicesDeviceDetails403ApplicationJSON
              );
          }
          break;
        case httpRes?.status == 404:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.devicesDeviceDetails404ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.DevicesDeviceDetails404ApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Returns the resign status to the caller
   */
  devicesGetReleaseUpdateDevicesStatus(
    req: operations.DevicesGetReleaseUpdateDevicesStatusRequest,
    security: operations.DevicesGetReleaseUpdateDevicesStatusSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.DevicesGetReleaseUpdateDevicesStatusResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DevicesGetReleaseUpdateDevicesStatusRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v0.1/apps/{owner_name}/{app_name}/releases/{release_id}/update_devices/{resign_id}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.DevicesGetReleaseUpdateDevicesStatusSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DevicesGetReleaseUpdateDevicesStatusResponse =
        new operations.DevicesGetReleaseUpdateDevicesStatusResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.devicesGetReleaseUpdateDevicesStatus200ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.DevicesGetReleaseUpdateDevicesStatus200ApplicationJSON
              );
          }
          break;
        case httpRes?.status == 400:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.devicesGetReleaseUpdateDevicesStatus400ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.DevicesGetReleaseUpdateDevicesStatus400ApplicationJSON
              );
          }
          break;
        case httpRes?.status == 404:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.devicesGetReleaseUpdateDevicesStatus404ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.DevicesGetReleaseUpdateDevicesStatus404ApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Returns all devices associated with the given distribution group
   */
  devicesList(
    req: operations.DevicesListRequest,
    security: operations.DevicesListSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.DevicesListResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DevicesListRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v0.1/apps/{owner_name}/{app_name}/distribution_groups/{distribution_group_name}/devices",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.DevicesListSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DevicesListResponse =
        new operations.DevicesListResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.devicesList200ApplicationJSONObjects = [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.devicesList200ApplicationJSONObjects = utils.objectToClass(
              httpRes?.data,
              operations.DevicesList200ApplicationJSON,
              resFieldDepth
            );
          }
          break;
        case httpRes?.status == 400:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.devicesList400ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.DevicesList400ApplicationJSON
            );
          }
          break;
        case httpRes?.status == 404:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.devicesList404ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.DevicesList404ApplicationJSON
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Returns all devices associated with the given distribution group.
   */
  devicesListCsvFormat(
    req: operations.DevicesListCsvFormatRequest,
    security: operations.DevicesListCsvFormatSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.DevicesListCsvFormatResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DevicesListCsvFormatRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v0.1/apps/{owner_name}/{app_name}/distribution_groups/{distribution_group_name}/devices/download_devices_list",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.DevicesListCsvFormatSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DevicesListCsvFormatResponse =
        new operations.DevicesListCsvFormatResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          break;
        case [400, 404, 500].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `text/csv`)) {
            const resBody: string = JSON.stringify(httpRes?.data, null, 0);
            const out: Uint8Array = new Uint8Array(resBody.length);
            for (let i = 0; i < resBody.length; i++)
              out[i] = resBody.charCodeAt(i);
            res.body = out;
          }
          break;
      }

      return res;
    });
  }

  /**
   * Registers a user for an existing device
   */
  devicesRegisterUserForDevice(
    req: operations.DevicesRegisterUserForDeviceRequest,
    security: operations.DevicesRegisterUserForDeviceSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.DevicesRegisterUserForDeviceResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DevicesRegisterUserForDeviceRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v0.1/users/{user_id}/devices/register",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.DevicesRegisterUserForDeviceSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DevicesRegisterUserForDeviceResponse =
        new operations.DevicesRegisterUserForDeviceResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.devicesRegisterUserForDevice200ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.DevicesRegisterUserForDevice200ApplicationJSON
              );
          }
          break;
        case httpRes?.status == 404:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.devicesRegisterUserForDevice404ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.DevicesRegisterUserForDevice404ApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Removes an existing device from a user
   */
  devicesRemoveUserDevice(
    req: operations.DevicesRemoveUserDeviceRequest,
    security: operations.DevicesRemoveUserDeviceSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.DevicesRemoveUserDeviceResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DevicesRemoveUserDeviceRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v0.1/user/devices/{device_udid}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.DevicesRemoveUserDeviceSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DevicesRemoveUserDeviceResponse =
        new operations.DevicesRemoveUserDeviceResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          break;
        case httpRes?.status == 403:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.devicesRemoveUserDevice403ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.DevicesRemoveUserDevice403ApplicationJSON
              );
          }
          break;
        case httpRes?.status == 404:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.devicesRemoveUserDevice404ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.DevicesRemoveUserDevice404ApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Returns all devices associated with the given user.
   */
  devicesUserDevicesList(
    config?: AxiosRequestConfig
  ): Promise<operations.DevicesUserDevicesListResponse> {
    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/v0.1/user/devices";

    const client: AxiosInstance = this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DevicesUserDevicesListResponse =
        new operations.DevicesUserDevicesListResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.devicesUserDevicesList200ApplicationJSONObjects = [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.devicesUserDevicesList200ApplicationJSONObjects =
              utils.objectToClass(
                httpRes?.data,
                operations.DevicesUserDevicesList200ApplicationJSON,
                resFieldDepth
              );
          }
          break;
        case httpRes?.status == 400:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.devicesUserDevicesList400ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.DevicesUserDevicesList400ApplicationJSON
              );
          }
          break;
        case httpRes?.status == 403:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.devicesUserDevicesList403ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.DevicesUserDevicesList403ApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Notify download(s) for the provided distribution release(s).
   */
  distibutionReleasesInstallAnalytics(
    req: operations.DistibutionReleasesInstallAnalyticsRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.DistibutionReleasesInstallAnalyticsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DistibutionReleasesInstallAnalyticsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v0.1/public/apps/{owner_name}/{app_name}/install_analytics",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DistibutionReleasesInstallAnalyticsResponse =
        new operations.DistibutionReleasesInstallAnalyticsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
      }

      return res;
    });
  }

  /**
   * Return information about the provisioning profile. Only available for iOS.
   */
  provisioningProfile(
    req: operations.ProvisioningProfileRequest,
    security: operations.ProvisioningProfileSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.ProvisioningProfileResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ProvisioningProfileRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v0.1/apps/{owner_name}/{app_name}/releases/{release_id}/provisioning_profile",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ProvisioningProfileSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ProvisioningProfileResponse =
        new operations.ProvisioningProfileResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.provisioningProfileResponse = utils.objectToClass(
              httpRes?.data,
              shared.ProvisioningProfileResponse
            );
          }
          break;
        case httpRes?.status == 400:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.provisioningProfile400ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.ProvisioningProfile400ApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Distributes a release to a group
   */
  releasesAddDistributionGroup(
    req: operations.ReleasesAddDistributionGroupRequest,
    security: operations.ReleasesAddDistributionGroupSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.ReleasesAddDistributionGroupResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ReleasesAddDistributionGroupRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v0.1/apps/{owner_name}/{app_name}/releases/{release_id}/groups",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ReleasesAddDistributionGroupSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ReleasesAddDistributionGroupResponse =
        new operations.ReleasesAddDistributionGroupResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.releasesAddDistributionGroup201ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.ReleasesAddDistributionGroup201ApplicationJSON
              );
          }
          break;
        case httpRes?.status == 400:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.releasesAddDistributionGroup400ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.ReleasesAddDistributionGroup400ApplicationJSON
              );
          }
          break;
        case httpRes?.status == 404:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.releasesAddDistributionGroup404ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.ReleasesAddDistributionGroup404ApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Distributes a release to a store
   */
  releasesAddStore(
    req: operations.ReleasesAddStoreRequest,
    security: operations.ReleasesAddStoreSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.ReleasesAddStoreResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ReleasesAddStoreRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v0.1/apps/{owner_name}/{app_name}/releases/{release_id}/stores",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ReleasesAddStoreSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ReleasesAddStoreResponse =
        new operations.ReleasesAddStoreResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.releasesAddStore201ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.ReleasesAddStore201ApplicationJSON
            );
          }
          break;
        case httpRes?.status == 400:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.releasesAddStore400ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.ReleasesAddStore400ApplicationJSON
            );
          }
          break;
        case httpRes?.status == 404:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.releasesAddStore404ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.ReleasesAddStore404ApplicationJSON
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Distributes a release to a user
   */
  releasesAddTesters(
    req: operations.ReleasesAddTestersRequest,
    security: operations.ReleasesAddTestersSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.ReleasesAddTestersResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ReleasesAddTestersRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v0.1/apps/{owner_name}/{app_name}/releases/{release_id}/testers",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ReleasesAddTestersSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ReleasesAddTestersResponse =
        new operations.ReleasesAddTestersResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.releasesAddTesters201ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.ReleasesAddTesters201ApplicationJSON
              );
          }
          break;
        case httpRes?.status == 400:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.releasesAddTesters400ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.ReleasesAddTesters400ApplicationJSON
              );
          }
          break;
        case httpRes?.status == 404:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.releasesAddTesters404ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.ReleasesAddTesters404ApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Return detailed information about releases avaiable to a tester.
   */
  releasesAvailableToTester(
    req: operations.ReleasesAvailableToTesterRequest,
    security: operations.ReleasesAvailableToTesterSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.ReleasesAvailableToTesterResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ReleasesAvailableToTesterRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v0.1/apps/{owner_name}/{app_name}/releases/filter_by_tester",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ReleasesAvailableToTesterSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ReleasesAvailableToTesterResponse =
        new operations.ReleasesAvailableToTesterResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.releasesAvailableToTester200ApplicationJSONObjects = [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.releasesAvailableToTester200ApplicationJSONObjects =
              utils.objectToClass(
                httpRes?.data,
                operations.ReleasesAvailableToTester200ApplicationJSON,
                resFieldDepth
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Initiate a new release upload. This API is part of multi-step upload process.
   */
  releasesCreateReleaseUpload(
    req: operations.ReleasesCreateReleaseUploadRequest,
    security: operations.ReleasesCreateReleaseUploadSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.ReleasesCreateReleaseUploadResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ReleasesCreateReleaseUploadRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v0.1/apps/{owner_name}/{app_name}/uploads/releases",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ReleasesCreateReleaseUploadSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ReleasesCreateReleaseUploadResponse =
        new operations.ReleasesCreateReleaseUploadResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.releasesCreateReleaseUpload201ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.ReleasesCreateReleaseUpload201ApplicationJSON
              );
          }
          break;
        case httpRes?.status == 400:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.releasesCreateReleaseUpload400ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.ReleasesCreateReleaseUpload400ApplicationJSON
              );
          }
          break;
        case httpRes?.status == 404:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.releasesCreateReleaseUpload404ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.ReleasesCreateReleaseUpload404ApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Deletes a release.
   */
  releasesDelete(
    req: operations.ReleasesDeleteRequest,
    security: operations.ReleasesDeleteSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.ReleasesDeleteResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ReleasesDeleteRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v0.1/apps/{owner_name}/{app_name}/releases/{release_id}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ReleasesDeleteSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ReleasesDeleteResponse =
        new operations.ReleasesDeleteResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          break;
        case httpRes?.status == 404:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.releasesDelete404ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.ReleasesDelete404ApplicationJSON
            );
          }
          break;
        case httpRes?.status == 500:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.releasesDelete500ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.ReleasesDelete500ApplicationJSON
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Delete the given distribution group from the release
   */
  releasesDeleteDistributionGroup(
    req: operations.ReleasesDeleteDistributionGroupRequest,
    security: operations.ReleasesDeleteDistributionGroupSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.ReleasesDeleteDistributionGroupResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ReleasesDeleteDistributionGroupRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v0.1/apps/{owner_name}/{app_name}/releases/{release_id}/groups/{group_id}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ReleasesDeleteDistributionGroupSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ReleasesDeleteDistributionGroupResponse =
        new operations.ReleasesDeleteDistributionGroupResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          break;
        case httpRes?.status == 404:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.releasesDeleteDistributionGroup404ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.ReleasesDeleteDistributionGroup404ApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Delete the given distribution store from the release
   */
  releasesDeleteDistributionStore(
    req: operations.ReleasesDeleteDistributionStoreRequest,
    security: operations.ReleasesDeleteDistributionStoreSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.ReleasesDeleteDistributionStoreResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ReleasesDeleteDistributionStoreRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v0.1/apps/{owner_name}/{app_name}/releases/{release_id}/stores/{store_id}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ReleasesDeleteDistributionStoreSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ReleasesDeleteDistributionStoreResponse =
        new operations.ReleasesDeleteDistributionStoreResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          break;
        case httpRes?.status == 404:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.releasesDeleteDistributionStore404ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.ReleasesDeleteDistributionStore404ApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Delete the given tester from the release
   */
  releasesDeleteDistributionTester(
    req: operations.ReleasesDeleteDistributionTesterRequest,
    security: operations.ReleasesDeleteDistributionTesterSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.ReleasesDeleteDistributionTesterResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ReleasesDeleteDistributionTesterRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v0.1/apps/{owner_name}/{app_name}/releases/{release_id}/testers/{tester_id}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ReleasesDeleteDistributionTesterSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ReleasesDeleteDistributionTesterResponse =
        new operations.ReleasesDeleteDistributionTesterResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          break;
        case httpRes?.status == 404:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.releasesDeleteDistributionTester404ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.ReleasesDeleteDistributionTester404ApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Delete the given tester from the all releases
   */
  releasesDeleteTesterFromDestinations(
    req: operations.ReleasesDeleteTesterFromDestinationsRequest,
    security: operations.ReleasesDeleteTesterFromDestinationsSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.ReleasesDeleteTesterFromDestinationsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ReleasesDeleteTesterFromDestinationsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v0.1/apps/{owner_name}/{app_name}/testers/{tester_id}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ReleasesDeleteTesterFromDestinationsSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ReleasesDeleteTesterFromDestinationsResponse =
        new operations.ReleasesDeleteTesterFromDestinationsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          break;
        case httpRes?.status == 404:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.releasesDeleteTesterFromDestinations404ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.ReleasesDeleteTesterFromDestinations404ApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Deletes a release with id 'release_id' in a given distribution group.
   */
  releasesDeleteWithDistributionGroupId(
    req: operations.ReleasesDeleteWithDistributionGroupIdRequest,
    security: operations.ReleasesDeleteWithDistributionGroupIdSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.ReleasesDeleteWithDistributionGroupIdResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ReleasesDeleteWithDistributionGroupIdRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v0.1/apps/{owner_name}/{app_name}/distribution_groups/{distribution_group_name}/releases/{release_id}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ReleasesDeleteWithDistributionGroupIdSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ReleasesDeleteWithDistributionGroupIdResponse =
        new operations.ReleasesDeleteWithDistributionGroupIdResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case [200, 404].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Returns the manifest.plist in XML format for installing the release on a device. Only available for iOS.
   */
  releasesGetIosManifest(
    req: operations.ReleasesGetIosManifestRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.ReleasesGetIosManifestResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ReleasesGetIosManifestRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v0.1/public/apps/{app_id}/releases/{release_id}/ios_manifest",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ReleasesGetIosManifestResponse =
        new operations.ReleasesGetIosManifestResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          break;
        case httpRes?.status == 400:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.releasesGetIosManifest400ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.ReleasesGetIosManifest400ApplicationJSON
              );
          }
          break;
        case httpRes?.status == 403:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.releasesGetIosManifest403ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.ReleasesGetIosManifest403ApplicationJSON
              );
          }
          break;
        case httpRes?.status == 404:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.releasesGetIosManifest404ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.ReleasesGetIosManifest404ApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Return detailed information about a distributed release in a given distribution group.
   */
  releasesGetLatestByDistributionGroup(
    req: operations.ReleasesGetLatestByDistributionGroupRequest,
    security: operations.ReleasesGetLatestByDistributionGroupSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.ReleasesGetLatestByDistributionGroupResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ReleasesGetLatestByDistributionGroupRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v0.1/apps/{owner_name}/{app_name}/distribution_groups/{distribution_group_name}/releases/{release_id}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ReleasesGetLatestByDistributionGroupSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ReleasesGetLatestByDistributionGroupResponse =
        new operations.ReleasesGetLatestByDistributionGroupResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.releasesGetLatestByDistributionGroup200ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.ReleasesGetLatestByDistributionGroup200ApplicationJSON
              );
          }
          break;
        case httpRes?.status == 404:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.releasesGetLatestByDistributionGroup404ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.ReleasesGetLatestByDistributionGroup404ApplicationJSON
              );
          }
          break;
        case httpRes?.status == 501:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.releasesGetLatestByDistributionGroup501ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.ReleasesGetLatestByDistributionGroup501ApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * If 'latest' is not specified then it will return the specified release if it's enabled. If 'latest' is specified, regardless of whether a release hash is provided, the latest enabled release is returned.
   */
  releasesGetLatestByHash(
    req: operations.ReleasesGetLatestByHashRequest,
    security: operations.ReleasesGetLatestByHashSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.ReleasesGetLatestByHashResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ReleasesGetLatestByHashRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v0.1/sdk/apps/{app_secret}/releases/{release_hash}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ReleasesGetLatestByHashSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ReleasesGetLatestByHashResponse =
        new operations.ReleasesGetLatestByHashResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.releasesGetLatestByHash200ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.ReleasesGetLatestByHash200ApplicationJSON
              );
          }
          break;
        case httpRes?.status == 404:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.releasesGetLatestByHash404ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.ReleasesGetLatestByHash404ApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Get a release with 'latest' for the given public group.
   */
  releasesGetLatestByPublicDistributionGroup(
    req: operations.ReleasesGetLatestByPublicDistributionGroupRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.ReleasesGetLatestByPublicDistributionGroupResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ReleasesGetLatestByPublicDistributionGroupRequest(
        req
      );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v0.1/public/sdk/apps/{app_secret}/distribution_groups/{distribution_group_id}/releases/latest",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ReleasesGetLatestByPublicDistributionGroupResponse =
        new operations.ReleasesGetLatestByPublicDistributionGroupResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.releasesGetLatestByPublicDistributionGroup200ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.ReleasesGetLatestByPublicDistributionGroup200ApplicationJSON
              );
          }
          break;
        case httpRes?.status == 403:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.releasesGetLatestByPublicDistributionGroup403ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.ReleasesGetLatestByPublicDistributionGroup403ApplicationJSON
              );
          }
          break;
        case httpRes?.status == 404:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.releasesGetLatestByPublicDistributionGroup404ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.ReleasesGetLatestByPublicDistributionGroup404ApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Get a release with id `release_id`. If `release_id` is `latest`, return the latest release that was distributed to the current user (from all the distribution groups).
   */
  releasesGetLatestByUser(
    req: operations.ReleasesGetLatestByUserRequest,
    security: operations.ReleasesGetLatestByUserSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.ReleasesGetLatestByUserResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ReleasesGetLatestByUserRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v0.1/apps/{owner_name}/{app_name}/releases/{release_id}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ReleasesGetLatestByUserSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ReleasesGetLatestByUserResponse =
        new operations.ReleasesGetLatestByUserResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.releasesGetLatestByUser200ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.ReleasesGetLatestByUser200ApplicationJSON
              );
          }
          break;
        case httpRes?.status == 400:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.releasesGetLatestByUser400ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.ReleasesGetLatestByUser400ApplicationJSON
              );
          }
          break;
        case httpRes?.status == 404:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.releasesGetLatestByUser404ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.ReleasesGetLatestByUser404ApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Get the latest release distributed to a private group the given user is a member of for the given app.
   */
  releasesGetLatestPrivateRelease(
    req: operations.ReleasesGetLatestPrivateReleaseRequest,
    security: operations.ReleasesGetLatestPrivateReleaseSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.ReleasesGetLatestPrivateReleaseResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ReleasesGetLatestPrivateReleaseRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v0.1/sdk/apps/{app_secret}/releases/private/latest",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ReleasesGetLatestPrivateReleaseSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ReleasesGetLatestPrivateReleaseResponse =
        new operations.ReleasesGetLatestPrivateReleaseResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.releasesGetLatestPrivateRelease200ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.ReleasesGetLatestPrivateRelease200ApplicationJSON
              );
          }
          break;
        case httpRes?.status == 404:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.releasesGetLatestPrivateRelease404ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.ReleasesGetLatestPrivateRelease404ApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Get the latest public release for the given app.
   */
  releasesGetLatestPublicRelease(
    req: operations.ReleasesGetLatestPublicReleaseRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.ReleasesGetLatestPublicReleaseResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ReleasesGetLatestPublicReleaseRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v0.1/public/sdk/apps/{app_secret}/releases/latest",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ReleasesGetLatestPublicReleaseResponse =
        new operations.ReleasesGetLatestPublicReleaseResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.releasesGetLatestPublicRelease200ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.ReleasesGetLatestPublicRelease200ApplicationJSON
              );
          }
          break;
        case httpRes?.status == 404:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.releasesGetLatestPublicRelease404ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.ReleasesGetLatestPublicRelease404ApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Get all public distribution groups that a given release has been distributed to
   */
  releasesGetPublicGroupsForReleaseByHash(
    req: operations.ReleasesGetPublicGroupsForReleaseByHashRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.ReleasesGetPublicGroupsForReleaseByHashResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ReleasesGetPublicGroupsForReleaseByHashRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v0.1/public/sdk/apps/{app_secret}/releases/{release_hash}/public_distribution_groups",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ReleasesGetPublicGroupsForReleaseByHashResponse =
        new operations.ReleasesGetPublicGroupsForReleaseByHashResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.releasesGetPublicGroupsForReleaseByHash200ApplicationJSONObjects =
              [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.releasesGetPublicGroupsForReleaseByHash200ApplicationJSONObjects =
              utils.objectToClass(
                httpRes?.data,
                operations.ReleasesGetPublicGroupsForReleaseByHash200ApplicationJSON,
                resFieldDepth
              );
          }
          break;
        case httpRes?.status == 404:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.releasesGetPublicGroupsForReleaseByHash404ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.ReleasesGetPublicGroupsForReleaseByHash404ApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Get the current status of the release upload.
   */
  releasesGetReleaseUploadStatus(
    req: operations.ReleasesGetReleaseUploadStatusRequest,
    security: operations.ReleasesGetReleaseUploadStatusSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.ReleasesGetReleaseUploadStatusResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ReleasesGetReleaseUploadStatusRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v0.1/apps/{owner_name}/{app_name}/uploads/releases/{upload_id}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ReleasesGetReleaseUploadStatusSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ReleasesGetReleaseUploadStatusResponse =
        new operations.ReleasesGetReleaseUploadStatusResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.releasesGetReleaseUploadStatus200ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.ReleasesGetReleaseUploadStatus200ApplicationJSON
              );
          }
          break;
        case httpRes?.status == 400:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.releasesGetReleaseUploadStatus400ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.ReleasesGetReleaseUploadStatus400ApplicationJSON
              );
          }
          break;
        case httpRes?.status == 404:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.releasesGetReleaseUploadStatus404ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.ReleasesGetReleaseUploadStatus404ApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Gets the sparkle feed of the releases that are distributed to all the public distribution groups.
   */
  releasesGetSparkleFeed(
    req: operations.ReleasesGetSparkleFeedRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.ReleasesGetSparkleFeedResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ReleasesGetSparkleFeedRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v0.1/public/sparkle/apps/{app_secret}",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ReleasesGetSparkleFeedResponse =
        new operations.ReleasesGetSparkleFeedResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.releasesGetSparkleFeedDefaultApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.ReleasesGetSparkleFeedDefaultApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Return basic information about releases.
   */
  releasesList(
    req: operations.ReleasesListRequest,
    security: operations.ReleasesListSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.ReleasesListResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ReleasesListRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v0.1/apps/{owner_name}/{app_name}/releases",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ReleasesListSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ReleasesListResponse =
        new operations.ReleasesListResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.releasesList200ApplicationJSONObjects = [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.releasesList200ApplicationJSONObjects = utils.objectToClass(
              httpRes?.data,
              operations.ReleasesList200ApplicationJSON,
              resFieldDepth
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Return basic information about distributed releases in a given distribution group.
   */
  releasesListByDistributionGroup(
    req: operations.ReleasesListByDistributionGroupRequest,
    security: operations.ReleasesListByDistributionGroupSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.ReleasesListByDistributionGroupResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ReleasesListByDistributionGroupRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v0.1/apps/{owner_name}/{app_name}/distribution_groups/{distribution_group_name}/releases",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ReleasesListByDistributionGroupSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ReleasesListByDistributionGroupResponse =
        new operations.ReleasesListByDistributionGroupResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.releasesListByDistributionGroup200ApplicationJSONObjects = [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.releasesListByDistributionGroup200ApplicationJSONObjects =
              utils.objectToClass(
                httpRes?.data,
                operations.ReleasesListByDistributionGroup200ApplicationJSON,
                resFieldDepth
              );
          }
          break;
        case httpRes?.status == 404:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.releasesListByDistributionGroup404ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.ReleasesListByDistributionGroup404ApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Get the latest release from every distribution group associated with an application.
   */
  releasesListLatest(
    req: operations.ReleasesListLatestRequest,
    security: operations.ReleasesListLatestSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.ReleasesListLatestResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ReleasesListLatestRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v0.1/apps/{owner_name}/{app_name}/recent_releases",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ReleasesListLatestSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ReleasesListLatestResponse =
        new operations.ReleasesListLatestResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.releasesListLatest200ApplicationJSONObjects = [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.releasesListLatest200ApplicationJSONObjects =
              utils.objectToClass(
                httpRes?.data,
                operations.ReleasesListLatest200ApplicationJSON,
                resFieldDepth
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Update details about the specified distribution group associated with the release
   */
  releasesPutDistributionGroup(
    req: operations.ReleasesPutDistributionGroupRequest,
    security: operations.ReleasesPutDistributionGroupSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.ReleasesPutDistributionGroupResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ReleasesPutDistributionGroupRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v0.1/apps/{owner_name}/{app_name}/releases/{release_id}/groups/{group_id}",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ReleasesPutDistributionGroupSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "put",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ReleasesPutDistributionGroupResponse =
        new operations.ReleasesPutDistributionGroupResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          break;
        case httpRes?.status == 404:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.releasesPutDistributionGroup404ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.ReleasesPutDistributionGroup404ApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Update details about the specified tester associated with the release
   */
  releasesPutDistributionTester(
    req: operations.ReleasesPutDistributionTesterRequest,
    security: operations.ReleasesPutDistributionTesterSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.ReleasesPutDistributionTesterResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ReleasesPutDistributionTesterRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v0.1/apps/{owner_name}/{app_name}/releases/{release_id}/testers/{tester_id}",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ReleasesPutDistributionTesterSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "put",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ReleasesPutDistributionTesterResponse =
        new operations.ReleasesPutDistributionTesterResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          break;
        case httpRes?.status == 404:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.releasesPutDistributionTester404ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.ReleasesPutDistributionTester404ApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Updates a release.
   */
  releasesUpdate(
    req: operations.ReleasesUpdateRequest,
    security: operations.ReleasesUpdateSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.ReleasesUpdateResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ReleasesUpdateRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v0.1/apps/{owner_name}/{app_name}/releases/{release_id}",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "raw"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ReleasesUpdateSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "patch",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ReleasesUpdateResponse =
        new operations.ReleasesUpdateResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.releasesUpdate200ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.ReleasesUpdate200ApplicationJSON
            );
          }
          break;
        case httpRes?.status == 400:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.releasesUpdate400ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.ReleasesUpdate400ApplicationJSON
            );
          }
          break;
        case httpRes?.status == 404:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.releasesUpdate404ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.ReleasesUpdate404ApplicationJSON
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Update details of a release.
   */
  releasesUpdateDetails(
    req: operations.ReleasesUpdateDetailsRequest,
    security: operations.ReleasesUpdateDetailsSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.ReleasesUpdateDetailsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ReleasesUpdateDetailsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v0.1/apps/{owner_name}/{app_name}/releases/{release_id}",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ReleasesUpdateDetailsSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "put",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ReleasesUpdateDetailsResponse =
        new operations.ReleasesUpdateDetailsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.releasesUpdateDetails200ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.ReleasesUpdateDetails200ApplicationJSON
              );
          }
          break;
        case httpRes?.status == 400:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.releasesUpdateDetails400ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.ReleasesUpdateDetails400ApplicationJSON
              );
          }
          break;
        case httpRes?.status == 404:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.releasesUpdateDetails404ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.ReleasesUpdateDetails404ApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Update the current status of the release upload.
   */
  releasesUpdateReleaseUploadStatus(
    req: operations.ReleasesUpdateReleaseUploadStatusRequest,
    security: operations.ReleasesUpdateReleaseUploadStatusSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.ReleasesUpdateReleaseUploadStatusResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ReleasesUpdateReleaseUploadStatusRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v0.1/apps/{owner_name}/{app_name}/uploads/releases/{upload_id}",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ReleasesUpdateReleaseUploadStatusSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url + queryParams,
      method: "patch",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ReleasesUpdateReleaseUploadStatusResponse =
        new operations.ReleasesUpdateReleaseUploadStatusResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.releasesUpdateReleaseUploadStatus200ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.ReleasesUpdateReleaseUploadStatus200ApplicationJSON
              );
          }
          break;
        case httpRes?.status == 400:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.releasesUpdateReleaseUploadStatus400ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.ReleasesUpdateReleaseUploadStatus400ApplicationJSON
              );
          }
          break;
        case httpRes?.status == 404:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.releasesUpdateReleaseUploadStatus404ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.ReleasesUpdateReleaseUploadStatus404ApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Application specific store service status
   */
  storeNotificationsGetNotificationByAppId(
    req: operations.StoreNotificationsGetNotificationByAppIdRequest,
    security: operations.StoreNotificationsGetNotificationByAppIdSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.StoreNotificationsGetNotificationByAppIdResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.StoreNotificationsGetNotificationByAppIdRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v0.1/apps/{owner_name}/{app_name}/store_service_status",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.StoreNotificationsGetNotificationByAppIdSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.StoreNotificationsGetNotificationByAppIdResponse =
        new operations.StoreNotificationsGetNotificationByAppIdResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.storeNotificationsGetNotificationByAppId200ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.StoreNotificationsGetNotificationByAppId200ApplicationJSON
              );
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.storeNotificationsGetNotificationByAppIdDefaultApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.StoreNotificationsGetNotificationByAppIdDefaultApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Returns publish logs for a particular release published to a particular store
   */
  storeReleasePublishLogsGet(
    req: operations.StoreReleasePublishLogsGetRequest,
    security: operations.StoreReleasePublishLogsGetSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.StoreReleasePublishLogsGetResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.StoreReleasePublishLogsGetRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v0.1/apps/{owner_name}/{app_name}/distribution_stores/{store_name}/releases/{release_id}/publish_logs",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.StoreReleasePublishLogsGetSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.StoreReleasePublishLogsGetResponse =
        new operations.StoreReleasePublishLogsGetResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.storeReleasePublishLogsGetDefaultApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.StoreReleasePublishLogsGetDefaultApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * delete the release with release Id
   */
  storeReleasesDelete(
    req: operations.StoreReleasesDeleteRequest,
    security: operations.StoreReleasesDeleteSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.StoreReleasesDeleteResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.StoreReleasesDeleteRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v0.1/apps/{owner_name}/{app_name}/distribution_stores/{store_name}/releases/{release_id}",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "string"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.StoreReleasesDeleteSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "delete",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.StoreReleasesDeleteResponse =
        new operations.StoreReleasesDeleteResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.storeReleasesDeleteDefaultApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.StoreReleasesDeleteDefaultApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Return releases published in a store for releaseId and storeId
   */
  storeReleasesGet(
    req: operations.StoreReleasesGetRequest,
    security: operations.StoreReleasesGetSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.StoreReleasesGetResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.StoreReleasesGetRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v0.1/apps/{owner_name}/{app_name}/distribution_stores/{store_name}/releases/{release_id}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.StoreReleasesGetSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.StoreReleasesGetResponse =
        new operations.StoreReleasesGetResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.storeReleasesGet200ApplicationJSONObjects = [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.storeReleasesGet200ApplicationJSONObjects = utils.objectToClass(
              httpRes?.data,
              operations.StoreReleasesGet200ApplicationJSON,
              resFieldDepth
            );
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.storeReleasesGetDefaultApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.StoreReleasesGetDefaultApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Returns the latest release published in a store.
   */
  storeReleasesGetLatest(
    req: operations.StoreReleasesGetLatestRequest,
    security: operations.StoreReleasesGetLatestSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.StoreReleasesGetLatestResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.StoreReleasesGetLatestRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v0.1/apps/{owner_name}/{app_name}/distribution_stores/{store_name}/latest_release",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.StoreReleasesGetLatestSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.StoreReleasesGetLatestResponse =
        new operations.StoreReleasesGetLatestResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.storeReleasesGetLatest200ApplicationJSONObjects = [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.storeReleasesGetLatest200ApplicationJSONObjects =
              utils.objectToClass(
                httpRes?.data,
                operations.StoreReleasesGetLatest200ApplicationJSON,
                resFieldDepth
              );
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.storeReleasesGetLatestDefaultApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.StoreReleasesGetLatestDefaultApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Return the Error Details of release which failed in publishing.
   */
  storeReleasesGetPublishError(
    req: operations.StoreReleasesGetPublishErrorRequest,
    security: operations.StoreReleasesGetPublishErrorSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.StoreReleasesGetPublishErrorResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.StoreReleasesGetPublishErrorRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v0.1/apps/{owner_name}/{app_name}/distribution_stores/{store_name}/releases/{release_id}/publish_error_details",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.StoreReleasesGetPublishErrorSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.StoreReleasesGetPublishErrorResponse =
        new operations.StoreReleasesGetPublishErrorResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.storeReleasesGetPublishError200ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.StoreReleasesGetPublishError200ApplicationJSON
              );
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.storeReleasesGetPublishErrorDefaultApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.StoreReleasesGetPublishErrorDefaultApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Return the Real time Status publishing of release from store.
   */
  storeReleasesGetRealTimeStatusByReleaseId(
    req: operations.StoreReleasesGetRealTimeStatusByReleaseIdRequest,
    security: operations.StoreReleasesGetRealTimeStatusByReleaseIdSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.StoreReleasesGetRealTimeStatusByReleaseIdResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.StoreReleasesGetRealTimeStatusByReleaseIdRequest(
        req
      );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v0.1/apps/{owner_name}/{app_name}/distribution_stores/{store_name}/releases/{release_id}/realtimestatus",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.StoreReleasesGetRealTimeStatusByReleaseIdSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.StoreReleasesGetRealTimeStatusByReleaseIdResponse =
        new operations.StoreReleasesGetRealTimeStatusByReleaseIdResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.storeReleasesGetRealTimeStatusByReleaseId200ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.StoreReleasesGetRealTimeStatusByReleaseId200ApplicationJSON
              );
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.storeReleasesGetRealTimeStatusByReleaseIdDefaultApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.StoreReleasesGetRealTimeStatusByReleaseIdDefaultApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Return all releases published  in a store
   */
  storeReleasesList(
    req: operations.StoreReleasesListRequest,
    security: operations.StoreReleasesListSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.StoreReleasesListResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.StoreReleasesListRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v0.1/apps/{owner_name}/{app_name}/distribution_stores/{store_name}/releases",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.StoreReleasesListSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.StoreReleasesListResponse =
        new operations.StoreReleasesListResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.storeReleasesList200ApplicationJSONObjects = [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.storeReleasesList200ApplicationJSONObjects =
              utils.objectToClass(
                httpRes?.data,
                operations.StoreReleasesList200ApplicationJSON,
                resFieldDepth
              );
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.storeReleasesListDefaultApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.StoreReleasesListDefaultApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Create a new external store for the specified application.
   */
  storesCreate(
    req: operations.StoresCreateRequest,
    security: operations.StoresCreateSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.StoresCreateResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.StoresCreateRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v0.1/apps/{owner_name}/{app_name}/distribution_stores",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.StoresCreateSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.StoresCreateResponse =
        new operations.StoresCreateResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.storesCreate201ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.StoresCreate201ApplicationJSON
            );
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.storesCreateDefaultApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.StoresCreateDefaultApplicationJSON
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * delete the store based on specific store name.
   */
  storesDelete(
    req: operations.StoresDeleteRequest,
    security: operations.StoresDeleteSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.StoresDeleteResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.StoresDeleteRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v0.1/apps/{owner_name}/{app_name}/distribution_stores/{store_name}",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "string"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.StoresDeleteSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "delete",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.StoresDeleteResponse =
        new operations.StoresDeleteResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.storesDeleteDefaultApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.StoresDeleteDefaultApplicationJSON
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Return the store details for specified store name.
   */
  storesGet(
    req: operations.StoresGetRequest,
    security: operations.StoresGetSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.StoresGetResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.StoresGetRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v0.1/apps/{owner_name}/{app_name}/distribution_stores/{store_name}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.StoresGetSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.StoresGetResponse =
        new operations.StoresGetResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.storesGet200ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.StoresGet200ApplicationJSON
            );
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.storesGetDefaultApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.StoresGetDefaultApplicationJSON
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Get all the store details from Storage store table for a particular application.
   */
  storesList(
    req: operations.StoresListRequest,
    security: operations.StoresListSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.StoresListResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.StoresListRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v0.1/apps/{owner_name}/{app_name}/distribution_stores",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.StoresListSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.StoresListResponse =
        new operations.StoresListResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.storesList200ApplicationJSONObjects = [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.storesList200ApplicationJSONObjects = utils.objectToClass(
              httpRes?.data,
              operations.StoresList200ApplicationJSON,
              resFieldDepth
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Update the store.
   */
  storesPatch(
    req: operations.StoresPatchRequest,
    security: operations.StoresPatchSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.StoresPatchResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.StoresPatchRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v0.1/apps/{owner_name}/{app_name}/distribution_stores/{store_name}",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.StoresPatchSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "patch",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.StoresPatchResponse =
        new operations.StoresPatchResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.storesPatchDefaultApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.StoresPatchDefaultApplicationJSON
            );
          }
          break;
      }

      return res;
    });
  }
}
