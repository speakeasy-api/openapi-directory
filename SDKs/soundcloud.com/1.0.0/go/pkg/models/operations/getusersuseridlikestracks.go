// Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.

package operations

import (
	"bytes"
	"encoding/json"
	"errors"
	"net/http"
	"openapi/pkg/models/shared"
)

type GetUsersUserIDLikesTracksSecurity struct {
	AuthHeader shared.SchemeAuthHeader `security:"scheme,type=apiKey,subtype=header"`
	ClientID   shared.SchemeClientID   `security:"scheme,type=apiKey,subtype=query"`
}

type GetUsersUserIDLikesTracksPathParams struct {
	// SoundCloud User id
	UserID int64 `pathParam:"style=simple,explode=false,name=user_id"`
}

type GetUsersUserIDLikesTracksQueryParams struct {
	// Filters content by level of access the user (logged in or anonymous) has to the track. The result list will include only tracks with the specified access. Include all options if you'd like to see all possible tracks. See `Track#access` schema for more details.
	//
	Access []shared.AccessEnum `queryParam:"style=form,explode=false,name=access"`
	// Number of results to return in the collection.
	Limit *int64 `queryParam:"style=form,explode=true,name=limit"`
	// Returns paginated collection of items (recommended, returning a list without pagination is deprecated and should not be used)
	LinkedPartitioning *bool `queryParam:"style=form,explode=true,name=linked_partitioning"`
}

type GetUsersUserIDLikesTracksRequest struct {
	PathParams  GetUsersUserIDLikesTracksPathParams
	QueryParams GetUsersUserIDLikesTracksQueryParams
	Security    GetUsersUserIDLikesTracksSecurity
}

type GetUsersUserIDLikesTracks200ApplicationJSONType string

const (
	GetUsersUserIDLikesTracks200ApplicationJSONTypeTracks       GetUsersUserIDLikesTracks200ApplicationJSONType = "Tracks"
	GetUsersUserIDLikesTracks200ApplicationJSONTypeArrayOfTrack GetUsersUserIDLikesTracks200ApplicationJSONType = "arrayOfTrack"
)

type GetUsersUserIDLikesTracks200ApplicationJSON struct {
	Tracks       *shared.Tracks
	ArrayOfTrack []shared.Track

	Type GetUsersUserIDLikesTracks200ApplicationJSONType
}

func CreateGetUsersUserIDLikesTracks200ApplicationJSONTracks(tracks shared.Tracks) GetUsersUserIDLikesTracks200ApplicationJSON {
	typ := GetUsersUserIDLikesTracks200ApplicationJSONTypeTracks

	return GetUsersUserIDLikesTracks200ApplicationJSON{
		Tracks: &tracks,
		Type:   typ,
	}
}

func CreateGetUsersUserIDLikesTracks200ApplicationJSONArrayOfTrack(arrayOfTrack []shared.Track) GetUsersUserIDLikesTracks200ApplicationJSON {
	typ := GetUsersUserIDLikesTracks200ApplicationJSONTypeArrayOfTrack

	return GetUsersUserIDLikesTracks200ApplicationJSON{
		ArrayOfTrack: arrayOfTrack,
		Type:         typ,
	}
}

func (u *GetUsersUserIDLikesTracks200ApplicationJSON) UnmarshalJSON(data []byte) error {
	var d *json.Decoder

	tracks := new(shared.Tracks)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&tracks); err == nil {
		u.Tracks = tracks
		u.Type = GetUsersUserIDLikesTracks200ApplicationJSONTypeTracks
		return nil
	}

	arrayOfTrack := []shared.Track{}
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&arrayOfTrack); err == nil {
		u.ArrayOfTrack = arrayOfTrack
		u.Type = GetUsersUserIDLikesTracks200ApplicationJSONTypeArrayOfTrack
		return nil
	}

	return errors.New("could not unmarshal into supported union types")
}

func (u GetUsersUserIDLikesTracks200ApplicationJSON) MarshalJSON() ([]byte, error) {
	if u.Tracks != nil {
		return json.Marshal(u.Tracks)
	}

	if u.ArrayOfTrack != nil {
		return json.Marshal(u.ArrayOfTrack)
	}

	return nil, nil
}

type GetUsersUserIDLikesTracksResponse struct {
	ContentType string
	// Bad Request
	Error       *shared.Error
	StatusCode  int
	RawResponse *http.Response
	// Success
	GetUsersUserIDLikesTracks200ApplicationJSONOneOf *GetUsersUserIDLikesTracks200ApplicationJSON
}
