// Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.

package shared

import (
	"encoding/json"
	"fmt"
	"time"
)

// UserEntityAuthenticationMethodEnum - How is this user authenticated?
type UserEntityAuthenticationMethodEnum string

const (
	UserEntityAuthenticationMethodEnumPassword                 UserEntityAuthenticationMethodEnum = "password"
	UserEntityAuthenticationMethodEnumUnusedFormerLdap         UserEntityAuthenticationMethodEnum = "unused_former_ldap"
	UserEntityAuthenticationMethodEnumSso                      UserEntityAuthenticationMethodEnum = "sso"
	UserEntityAuthenticationMethodEnumNone                     UserEntityAuthenticationMethodEnum = "none"
	UserEntityAuthenticationMethodEnumEmailSignup              UserEntityAuthenticationMethodEnum = "email_signup"
	UserEntityAuthenticationMethodEnumPasswordWithImportedHash UserEntityAuthenticationMethodEnum = "password_with_imported_hash"
)

func (e *UserEntityAuthenticationMethodEnum) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return err
	}
	switch s {
	case "password":
		fallthrough
	case "unused_former_ldap":
		fallthrough
	case "sso":
		fallthrough
	case "none":
		fallthrough
	case "email_signup":
		fallthrough
	case "password_with_imported_hash":
		*e = UserEntityAuthenticationMethodEnum(s)
		return nil
	default:
		return fmt.Errorf("invalid value for UserEntityAuthenticationMethodEnum: %s", s)
	}
}

// UserEntityRequire2faEnum - 2FA required setting
type UserEntityRequire2faEnum string

const (
	UserEntityRequire2faEnumUseSystemSetting UserEntityRequire2faEnum = "use_system_setting"
	UserEntityRequire2faEnumAlwaysRequire    UserEntityRequire2faEnum = "always_require"
	UserEntityRequire2faEnumNeverRequire     UserEntityRequire2faEnum = "never_require"
)

func (e *UserEntityRequire2faEnum) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return err
	}
	switch s {
	case "use_system_setting":
		fallthrough
	case "always_require":
		fallthrough
	case "never_require":
		*e = UserEntityRequire2faEnum(s)
		return nil
	default:
		return fmt.Errorf("invalid value for UserEntityRequire2faEnum: %s", s)
	}
}

// UserEntitySslRequiredEnum - SSL required setting
type UserEntitySslRequiredEnum string

const (
	UserEntitySslRequiredEnumUseSystemSetting UserEntitySslRequiredEnum = "use_system_setting"
	UserEntitySslRequiredEnumAlwaysRequire    UserEntitySslRequiredEnum = "always_require"
	UserEntitySslRequiredEnumNeverRequire     UserEntitySslRequiredEnum = "never_require"
)

func (e *UserEntitySslRequiredEnum) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return err
	}
	switch s {
	case "use_system_setting":
		fallthrough
	case "always_require":
		fallthrough
	case "never_require":
		*e = UserEntitySslRequiredEnum(s)
		return nil
	default:
		return fmt.Errorf("invalid value for UserEntitySslRequiredEnum: %s", s)
	}
}

// UserEntity - Create User
type UserEntity struct {
	// Is 2fa active for the user?
	Active2fa *bool `json:"active_2fa,omitempty"`
	// List of group IDs of which this user is an administrator
	AdminGroupIds []int `json:"admin_group_ids,omitempty"`
	// A list of allowed IPs if applicable.  Newline delimited
	AllowedIps *string `json:"allowed_ips,omitempty"`
	// Number of api keys associated with this user
	APIKeysCount *int `json:"api_keys_count,omitempty"`
	// DEPRECATED: Can the user create Bundles (aka Share Links)? Use the bundle permission instead.
	AttachmentsPermission *bool `json:"attachments_permission,omitempty"`
	// Scheduled Date/Time at which user will be deactivated
	AuthenticateUntil *time.Time `json:"authenticate_until,omitempty"`
	// How is this user authenticated?
	AuthenticationMethod *UserEntityAuthenticationMethodEnum `json:"authentication_method,omitempty"`
	// URL holding the user's avatar
	AvatarURL *string `json:"avatar_url,omitempty"`
	// Allow this user to perform operations on the account, payments, and invoices?
	BillingPermission *bool `json:"billing_permission,omitempty"`
	// Exempt this user from being disabled based on inactivity?
	BypassInactiveDisable *bool `json:"bypass_inactive_disable,omitempty"`
	// Allow this user to skip site-wide IP blacklists?
	BypassSiteAllowedIps *bool `json:"bypass_site_allowed_ips,omitempty"`
	// User's company
	Company *string `json:"company,omitempty"`
	// When this user was created
	CreatedAt *time.Time `json:"created_at,omitempty"`
	// Can the user connect with WebDAV?
	DavPermission *bool `json:"dav_permission,omitempty"`
	// Number of days remaining until password expires
	DaysRemainingUntilPasswordExpire *int `json:"days_remaining_until_password_expire,omitempty"`
	// Is user disabled? Disabled users cannot log in, and do not count for billing purposes.  Users can be automatically disabled after an inactivity period via a Site setting.
	Disabled *bool `json:"disabled,omitempty"`
	// User email address
	Email *string `json:"email,omitempty"`
	// Is this user managed by a SsoStrategy?
	ExternallyManaged *bool `json:"externally_managed,omitempty"`
	// User's first login time
	FirstLoginAt *time.Time `json:"first_login_at,omitempty"`
	// Can the user access with FTP/FTPS?
	FtpPermission *bool `json:"ftp_permission,omitempty"`
	// Comma-separated list of group IDs of which this user is a member
	GroupIds *string `json:"group_ids,omitempty"`
	// Text to display to the user in the header of the UI
	HeaderText *string `json:"header_text,omitempty"`
	// User ID
	ID *int `json:"id,omitempty"`
	// Preferred language
	Language *string `json:"language,omitempty"`
	// User's most recent activity time, which is the latest of most recent login, most recent API use, enablement, or creation
	LastActiveAt *time.Time `json:"last_active_at,omitempty"`
	// User's most recent API use time
	LastAPIUseAt *time.Time `json:"last_api_use_at,omitempty"`
	// User's most recent login time via WebDAV
	LastDavLoginAt *time.Time `json:"last_dav_login_at,omitempty"`
	// User's most recent login time via Desktop app
	LastDesktopLoginAt *time.Time `json:"last_desktop_login_at,omitempty"`
	// User's most recent login time via FTP
	LastFtpLoginAt *time.Time `json:"last_ftp_login_at,omitempty"`
	// User's most recent login time via any protocol
	LastLoginAt *time.Time `json:"last_login_at,omitempty"`
	// The most recent protocol and cipher used
	LastProtocolCipher *string `json:"last_protocol_cipher,omitempty"`
	// User's most recent login time via Rest API
	LastRestapiLoginAt *time.Time `json:"last_restapi_login_at,omitempty"`
	// User's most recent login time via SFTP
	LastSftpLoginAt *time.Time `json:"last_sftp_login_at,omitempty"`
	// User's most recent login time via web
	LastWebLoginAt *time.Time `json:"last_web_login_at,omitempty"`
	// Time in the future that the user will no longer be locked out if applicable
	LockoutExpires *time.Time `json:"lockout_expires,omitempty"`
	// User's full name
	Name *string `json:"name,omitempty"`
	// Any internal notes on the user
	Notes *string `json:"notes,omitempty"`
	// Hour of the day at which daily notifications should be sent. Can be in range 0 to 23
	NotificationDailySendTime *int `json:"notification_daily_send_time,omitempty"`
	// Enable integration with Office for the web?
	OfficeIntegrationEnabled *bool `json:"office_integration_enabled,omitempty"`
	// Password expiration datetime
	PasswordExpireAt *time.Time `json:"password_expire_at,omitempty"`
	// Is user's password expired?
	PasswordExpired *bool `json:"password_expired,omitempty"`
	// Last time the user's password was set
	PasswordSetAt *time.Time `json:"password_set_at,omitempty"`
	// Number of days to allow user to use the same password
	PasswordValidityDays *int `json:"password_validity_days,omitempty"`
	// Number of public keys associated with this user
	PublicKeysCount *int `json:"public_keys_count,omitempty"`
	// Should the user receive admin alerts such a certificate expiration notifications and overages?
	ReceiveAdminAlerts *bool `json:"receive_admin_alerts,omitempty"`
	// 2FA required setting
	Require2fa *UserEntityRequire2faEnum `json:"require_2fa,omitempty"`
	// Is a password change required upon next user login?
	RequirePasswordChange *bool `json:"require_password_change,omitempty"`
	// Can this user access the REST API?
	RestapiPermission *bool `json:"restapi_permission,omitempty"`
	// Does this user manage it's own credentials or is it a shared/bot user?
	SelfManaged *bool `json:"self_managed,omitempty"`
	// Can the user access with SFTP?
	SftpPermission *bool `json:"sftp_permission,omitempty"`
	// Is the user an administrator for this site?
	SiteAdmin *bool `json:"site_admin,omitempty"`
	// Skip Welcome page in the UI?
	SkipWelcomeScreen *bool `json:"skip_welcome_screen,omitempty"`
	// SSL required setting
	SslRequired *UserEntitySslRequiredEnum `json:"ssl_required,omitempty"`
	// SSO (Single Sign On) strategy ID for the user, if applicable.
	SsoStrategyID *int `json:"sso_strategy_id,omitempty"`
	// Is the user subscribed to the newsletter?
	SubscribeToNewsletter *bool `json:"subscribe_to_newsletter,omitempty"`
	// User time zone
	TimeZone *string `json:"time_zone,omitempty"`
	// Type(s) of 2FA methods in use.  Will be either `sms`, `totp`, `u2f`, `yubi`, or multiple values sorted alphabetically and joined by an underscore.
	TypeOf2fa *string `json:"type_of_2fa,omitempty"`
	// Root folder for FTP (and optionally SFTP if the appropriate site-wide setting is set.)  Note that this is not used for API, Desktop, or Web interface.
	UserRoot *string `json:"user_root,omitempty"`
	// User's username
	Username *string `json:"username,omitempty"`
}
