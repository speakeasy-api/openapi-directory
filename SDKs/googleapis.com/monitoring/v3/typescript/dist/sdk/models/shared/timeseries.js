"use strict";
/*
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TimeSeries = exports.TimeSeriesValueTypeEnum = exports.TimeSeriesMetricKindEnum = void 0;
var utils_1 = require("../../../internal/utils");
var metric_1 = require("./metric");
var monitoredresource_1 = require("./monitoredresource");
var monitoredresourcemetadata_1 = require("./monitoredresourcemetadata");
var point_1 = require("./point");
var class_transformer_1 = require("class-transformer");
/**
 * The metric kind of the time series. When listing time series, this metric kind might be different from the metric kind of the associated metric if this time series is an alignment or reduction of other time series.When creating a time series, this field is optional. If present, it must be the same as the metric kind of the associated metric. If the associated metric's descriptor must be auto-created, then this field specifies the metric kind of the new descriptor and must be either GAUGE (the default) or CUMULATIVE.
 */
var TimeSeriesMetricKindEnum;
(function (TimeSeriesMetricKindEnum) {
    TimeSeriesMetricKindEnum["MetricKindUnspecified"] = "METRIC_KIND_UNSPECIFIED";
    TimeSeriesMetricKindEnum["Gauge"] = "GAUGE";
    TimeSeriesMetricKindEnum["Delta"] = "DELTA";
    TimeSeriesMetricKindEnum["Cumulative"] = "CUMULATIVE";
})(TimeSeriesMetricKindEnum = exports.TimeSeriesMetricKindEnum || (exports.TimeSeriesMetricKindEnum = {}));
/**
 * The value type of the time series. When listing time series, this value type might be different from the value type of the associated metric if this time series is an alignment or reduction of other time series.When creating a time series, this field is optional. If present, it must be the same as the type of the data in the points field.
 */
var TimeSeriesValueTypeEnum;
(function (TimeSeriesValueTypeEnum) {
    TimeSeriesValueTypeEnum["ValueTypeUnspecified"] = "VALUE_TYPE_UNSPECIFIED";
    TimeSeriesValueTypeEnum["Bool"] = "BOOL";
    TimeSeriesValueTypeEnum["Int64"] = "INT64";
    TimeSeriesValueTypeEnum["Double"] = "DOUBLE";
    TimeSeriesValueTypeEnum["String"] = "STRING";
    TimeSeriesValueTypeEnum["Distribution"] = "DISTRIBUTION";
    TimeSeriesValueTypeEnum["Money"] = "MONEY";
})(TimeSeriesValueTypeEnum = exports.TimeSeriesValueTypeEnum || (exports.TimeSeriesValueTypeEnum = {}));
/**
 * A collection of data points that describes the time-varying values of a metric. A time series is identified by a combination of a fully-specified monitored resource and a fully-specified metric. This type is used for both listing and creating time series.
 */
var TimeSeries = /** @class */ (function (_super) {
    __extends(TimeSeries, _super);
    function TimeSeries() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate([
        (0, utils_1.SpeakeasyMetadata)(),
        (0, class_transformer_1.Expose)({ name: "metadata" }),
        (0, class_transformer_1.Type)(function () { return monitoredresourcemetadata_1.MonitoredResourceMetadata; }),
        __metadata("design:type", monitoredresourcemetadata_1.MonitoredResourceMetadata)
    ], TimeSeries.prototype, "metadata", void 0);
    __decorate([
        (0, utils_1.SpeakeasyMetadata)(),
        (0, class_transformer_1.Expose)({ name: "metric" }),
        (0, class_transformer_1.Type)(function () { return metric_1.Metric; }),
        __metadata("design:type", metric_1.Metric)
    ], TimeSeries.prototype, "metric", void 0);
    __decorate([
        (0, utils_1.SpeakeasyMetadata)(),
        (0, class_transformer_1.Expose)({ name: "metricKind" }),
        __metadata("design:type", String)
    ], TimeSeries.prototype, "metricKind", void 0);
    __decorate([
        (0, utils_1.SpeakeasyMetadata)({ elemType: point_1.Point }),
        (0, class_transformer_1.Expose)({ name: "points" }),
        (0, class_transformer_1.Type)(function () { return point_1.Point; }),
        __metadata("design:type", Array)
    ], TimeSeries.prototype, "points", void 0);
    __decorate([
        (0, utils_1.SpeakeasyMetadata)(),
        (0, class_transformer_1.Expose)({ name: "resource" }),
        (0, class_transformer_1.Type)(function () { return monitoredresource_1.MonitoredResource; }),
        __metadata("design:type", monitoredresource_1.MonitoredResource)
    ], TimeSeries.prototype, "resource", void 0);
    __decorate([
        (0, utils_1.SpeakeasyMetadata)(),
        (0, class_transformer_1.Expose)({ name: "unit" }),
        __metadata("design:type", String)
    ], TimeSeries.prototype, "unit", void 0);
    __decorate([
        (0, utils_1.SpeakeasyMetadata)(),
        (0, class_transformer_1.Expose)({ name: "valueType" }),
        __metadata("design:type", String)
    ], TimeSeries.prototype, "valueType", void 0);
    return TimeSeries;
}(utils_1.SpeakeasyBase));
exports.TimeSeries = TimeSeries;
