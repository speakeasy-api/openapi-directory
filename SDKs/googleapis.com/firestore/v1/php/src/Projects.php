<?php

/**
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

declare(strict_types=1);

namespace OpenAPI\OpenAPI;

class Projects 
{

	// SDK private variables namespaced with _ to avoid conflicts with API models
	private \GuzzleHttp\ClientInterface $_defaultClient;
	private \GuzzleHttp\ClientInterface $_securityClient;
	private string $_serverUrl;
	private string $_language;
	private string $_sdkVersion;
	private string $_genVersion;	

	/**
	 * @param \GuzzleHttp\ClientInterface $defaultClient
	 * @param \GuzzleHttp\ClientInterface $securityClient
	 * @param string $serverUrl
	 * @param string $language
	 * @param string $sdkVersion
	 * @param string $genVersion
	 */
	public function __construct(\GuzzleHttp\ClientInterface $defaultClient, \GuzzleHttp\ClientInterface $securityClient, string $serverUrl, string $language, string $sdkVersion, string $genVersion)
	{
		$this->_defaultClient = $defaultClient;
		$this->_securityClient = $securityClient;
		$this->_serverUrl = $serverUrl;
		$this->_language = $language;
		$this->_sdkVersion = $sdkVersion;
		$this->_genVersion = $genVersion;
	}
	
    /**
     * Lists the field configuration and metadata for this database. Currently, FirestoreAdmin.ListFields only supports listing fields that have been explicitly overridden. To issue this query, call FirestoreAdmin.ListFields with the filter set to `indexConfig.usesAncestorConfig:false` .
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\FirestoreProjectsDatabasesCollectionGroupsFieldsListRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\FirestoreProjectsDatabasesCollectionGroupsFieldsListSecurity $security
     * @return \OpenAPI\OpenAPI\Models\Operations\FirestoreProjectsDatabasesCollectionGroupsFieldsListResponse
     */
	public function firestoreProjectsDatabasesCollectionGroupsFieldsList(
        \OpenAPI\OpenAPI\Models\Operations\FirestoreProjectsDatabasesCollectionGroupsFieldsListRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\FirestoreProjectsDatabasesCollectionGroupsFieldsListSecurity $security,
    ): \OpenAPI\OpenAPI\Models\Operations\FirestoreProjectsDatabasesCollectionGroupsFieldsListResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v1/{parent}/fields', \OpenAPI\OpenAPI\Models\Operations\FirestoreProjectsDatabasesCollectionGroupsFieldsListRequest::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\FirestoreProjectsDatabasesCollectionGroupsFieldsListRequest::class, $request, null));
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\FirestoreProjectsDatabasesCollectionGroupsFieldsListResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->googleFirestoreAdminV1ListFieldsResponse = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\GoogleFirestoreAdminV1ListFieldsResponse', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Creates a composite index. This returns a google.longrunning.Operation which may be used to track the status of the creation. The metadata for the operation will be the type IndexOperationMetadata.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\FirestoreProjectsDatabasesCollectionGroupsIndexesCreateRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\FirestoreProjectsDatabasesCollectionGroupsIndexesCreateSecurity $security
     * @return \OpenAPI\OpenAPI\Models\Operations\FirestoreProjectsDatabasesCollectionGroupsIndexesCreateResponse
     */
	public function firestoreProjectsDatabasesCollectionGroupsIndexesCreate(
        \OpenAPI\OpenAPI\Models\Operations\FirestoreProjectsDatabasesCollectionGroupsIndexesCreateRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\FirestoreProjectsDatabasesCollectionGroupsIndexesCreateSecurity $security,
    ): \OpenAPI\OpenAPI\Models\Operations\FirestoreProjectsDatabasesCollectionGroupsIndexesCreateResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v1/{parent}/indexes', \OpenAPI\OpenAPI\Models\Operations\FirestoreProjectsDatabasesCollectionGroupsIndexesCreateRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "googleFirestoreAdminV1Index", "json");
        $options = array_merge_recursive($options, $body);
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\FirestoreProjectsDatabasesCollectionGroupsIndexesCreateRequest::class, $request, null));
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\FirestoreProjectsDatabasesCollectionGroupsIndexesCreateResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->googleLongrunningOperation = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\GoogleLongrunningOperation', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Lists composite indexes.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\FirestoreProjectsDatabasesCollectionGroupsIndexesListRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\FirestoreProjectsDatabasesCollectionGroupsIndexesListSecurity $security
     * @return \OpenAPI\OpenAPI\Models\Operations\FirestoreProjectsDatabasesCollectionGroupsIndexesListResponse
     */
	public function firestoreProjectsDatabasesCollectionGroupsIndexesList(
        \OpenAPI\OpenAPI\Models\Operations\FirestoreProjectsDatabasesCollectionGroupsIndexesListRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\FirestoreProjectsDatabasesCollectionGroupsIndexesListSecurity $security,
    ): \OpenAPI\OpenAPI\Models\Operations\FirestoreProjectsDatabasesCollectionGroupsIndexesListResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v1/{parent}/indexes', \OpenAPI\OpenAPI\Models\Operations\FirestoreProjectsDatabasesCollectionGroupsIndexesListRequest::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\FirestoreProjectsDatabasesCollectionGroupsIndexesListRequest::class, $request, null));
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\FirestoreProjectsDatabasesCollectionGroupsIndexesListResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->googleFirestoreAdminV1ListIndexesResponse = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\GoogleFirestoreAdminV1ListIndexesResponse', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Create a database.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\FirestoreProjectsDatabasesCreateRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\FirestoreProjectsDatabasesCreateSecurity $security
     * @return \OpenAPI\OpenAPI\Models\Operations\FirestoreProjectsDatabasesCreateResponse
     */
	public function firestoreProjectsDatabasesCreate(
        \OpenAPI\OpenAPI\Models\Operations\FirestoreProjectsDatabasesCreateRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\FirestoreProjectsDatabasesCreateSecurity $security,
    ): \OpenAPI\OpenAPI\Models\Operations\FirestoreProjectsDatabasesCreateResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v1/{parent}/databases', \OpenAPI\OpenAPI\Models\Operations\FirestoreProjectsDatabasesCreateRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "googleFirestoreAdminV1DatabaseInput", "json");
        $options = array_merge_recursive($options, $body);
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\FirestoreProjectsDatabasesCreateRequest::class, $request, null));
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\FirestoreProjectsDatabasesCreateResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->googleLongrunningOperation = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\GoogleLongrunningOperation', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Gets multiple documents. Documents returned by this method are not guaranteed to be returned in the same order that they were requested.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\FirestoreProjectsDatabasesDocumentsBatchGetRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\FirestoreProjectsDatabasesDocumentsBatchGetSecurity $security
     * @return \OpenAPI\OpenAPI\Models\Operations\FirestoreProjectsDatabasesDocumentsBatchGetResponse
     */
	public function firestoreProjectsDatabasesDocumentsBatchGet(
        \OpenAPI\OpenAPI\Models\Operations\FirestoreProjectsDatabasesDocumentsBatchGetRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\FirestoreProjectsDatabasesDocumentsBatchGetSecurity $security,
    ): \OpenAPI\OpenAPI\Models\Operations\FirestoreProjectsDatabasesDocumentsBatchGetResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v1/{database}/documents:batchGet', \OpenAPI\OpenAPI\Models\Operations\FirestoreProjectsDatabasesDocumentsBatchGetRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "batchGetDocumentsRequest", "json");
        $options = array_merge_recursive($options, $body);
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\FirestoreProjectsDatabasesDocumentsBatchGetRequest::class, $request, null));
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\FirestoreProjectsDatabasesDocumentsBatchGetResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->batchGetDocumentsResponse = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\BatchGetDocumentsResponse', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Applies a batch of write operations. The BatchWrite method does not apply the write operations atomically and can apply them out of order. Method does not allow more than one write per document. Each write succeeds or fails independently. See the BatchWriteResponse for the success status of each write. If you require an atomically applied set of writes, use Commit instead.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\FirestoreProjectsDatabasesDocumentsBatchWriteRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\FirestoreProjectsDatabasesDocumentsBatchWriteSecurity $security
     * @return \OpenAPI\OpenAPI\Models\Operations\FirestoreProjectsDatabasesDocumentsBatchWriteResponse
     */
	public function firestoreProjectsDatabasesDocumentsBatchWrite(
        \OpenAPI\OpenAPI\Models\Operations\FirestoreProjectsDatabasesDocumentsBatchWriteRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\FirestoreProjectsDatabasesDocumentsBatchWriteSecurity $security,
    ): \OpenAPI\OpenAPI\Models\Operations\FirestoreProjectsDatabasesDocumentsBatchWriteResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v1/{database}/documents:batchWrite', \OpenAPI\OpenAPI\Models\Operations\FirestoreProjectsDatabasesDocumentsBatchWriteRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "batchWriteRequest", "json");
        $options = array_merge_recursive($options, $body);
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\FirestoreProjectsDatabasesDocumentsBatchWriteRequest::class, $request, null));
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\FirestoreProjectsDatabasesDocumentsBatchWriteResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->batchWriteResponse = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\BatchWriteResponse', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Starts a new transaction.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\FirestoreProjectsDatabasesDocumentsBeginTransactionRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\FirestoreProjectsDatabasesDocumentsBeginTransactionSecurity $security
     * @return \OpenAPI\OpenAPI\Models\Operations\FirestoreProjectsDatabasesDocumentsBeginTransactionResponse
     */
	public function firestoreProjectsDatabasesDocumentsBeginTransaction(
        \OpenAPI\OpenAPI\Models\Operations\FirestoreProjectsDatabasesDocumentsBeginTransactionRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\FirestoreProjectsDatabasesDocumentsBeginTransactionSecurity $security,
    ): \OpenAPI\OpenAPI\Models\Operations\FirestoreProjectsDatabasesDocumentsBeginTransactionResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v1/{database}/documents:beginTransaction', \OpenAPI\OpenAPI\Models\Operations\FirestoreProjectsDatabasesDocumentsBeginTransactionRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "beginTransactionRequest", "json");
        $options = array_merge_recursive($options, $body);
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\FirestoreProjectsDatabasesDocumentsBeginTransactionRequest::class, $request, null));
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\FirestoreProjectsDatabasesDocumentsBeginTransactionResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->beginTransactionResponse = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\BeginTransactionResponse', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Commits a transaction, while optionally updating documents.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\FirestoreProjectsDatabasesDocumentsCommitRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\FirestoreProjectsDatabasesDocumentsCommitSecurity $security
     * @return \OpenAPI\OpenAPI\Models\Operations\FirestoreProjectsDatabasesDocumentsCommitResponse
     */
	public function firestoreProjectsDatabasesDocumentsCommit(
        \OpenAPI\OpenAPI\Models\Operations\FirestoreProjectsDatabasesDocumentsCommitRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\FirestoreProjectsDatabasesDocumentsCommitSecurity $security,
    ): \OpenAPI\OpenAPI\Models\Operations\FirestoreProjectsDatabasesDocumentsCommitResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v1/{database}/documents:commit', \OpenAPI\OpenAPI\Models\Operations\FirestoreProjectsDatabasesDocumentsCommitRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "commitRequest", "json");
        $options = array_merge_recursive($options, $body);
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\FirestoreProjectsDatabasesDocumentsCommitRequest::class, $request, null));
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\FirestoreProjectsDatabasesDocumentsCommitResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->commitResponse = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\CommitResponse', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Creates a new document.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\FirestoreProjectsDatabasesDocumentsCreateDocumentRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\FirestoreProjectsDatabasesDocumentsCreateDocumentSecurity $security
     * @return \OpenAPI\OpenAPI\Models\Operations\FirestoreProjectsDatabasesDocumentsCreateDocumentResponse
     */
	public function firestoreProjectsDatabasesDocumentsCreateDocument(
        \OpenAPI\OpenAPI\Models\Operations\FirestoreProjectsDatabasesDocumentsCreateDocumentRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\FirestoreProjectsDatabasesDocumentsCreateDocumentSecurity $security,
    ): \OpenAPI\OpenAPI\Models\Operations\FirestoreProjectsDatabasesDocumentsCreateDocumentResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v1/{parent}/{collectionId}', \OpenAPI\OpenAPI\Models\Operations\FirestoreProjectsDatabasesDocumentsCreateDocumentRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "document", "json");
        $options = array_merge_recursive($options, $body);
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\FirestoreProjectsDatabasesDocumentsCreateDocumentRequest::class, $request, null));
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\FirestoreProjectsDatabasesDocumentsCreateDocumentResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->document = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\Document', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Lists all the collection IDs underneath a document.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\FirestoreProjectsDatabasesDocumentsListCollectionIdsRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\FirestoreProjectsDatabasesDocumentsListCollectionIdsSecurity $security
     * @return \OpenAPI\OpenAPI\Models\Operations\FirestoreProjectsDatabasesDocumentsListCollectionIdsResponse
     */
	public function firestoreProjectsDatabasesDocumentsListCollectionIds(
        \OpenAPI\OpenAPI\Models\Operations\FirestoreProjectsDatabasesDocumentsListCollectionIdsRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\FirestoreProjectsDatabasesDocumentsListCollectionIdsSecurity $security,
    ): \OpenAPI\OpenAPI\Models\Operations\FirestoreProjectsDatabasesDocumentsListCollectionIdsResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v1/{parent}:listCollectionIds', \OpenAPI\OpenAPI\Models\Operations\FirestoreProjectsDatabasesDocumentsListCollectionIdsRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "listCollectionIdsRequest", "json");
        $options = array_merge_recursive($options, $body);
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\FirestoreProjectsDatabasesDocumentsListCollectionIdsRequest::class, $request, null));
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\FirestoreProjectsDatabasesDocumentsListCollectionIdsResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->listCollectionIdsResponse = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\ListCollectionIdsResponse', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Lists documents.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\FirestoreProjectsDatabasesDocumentsListDocumentsRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\FirestoreProjectsDatabasesDocumentsListDocumentsSecurity $security
     * @return \OpenAPI\OpenAPI\Models\Operations\FirestoreProjectsDatabasesDocumentsListDocumentsResponse
     */
	public function firestoreProjectsDatabasesDocumentsListDocuments(
        \OpenAPI\OpenAPI\Models\Operations\FirestoreProjectsDatabasesDocumentsListDocumentsRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\FirestoreProjectsDatabasesDocumentsListDocumentsSecurity $security,
    ): \OpenAPI\OpenAPI\Models\Operations\FirestoreProjectsDatabasesDocumentsListDocumentsResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v1/{parent}/{collectionId}', \OpenAPI\OpenAPI\Models\Operations\FirestoreProjectsDatabasesDocumentsListDocumentsRequest::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\FirestoreProjectsDatabasesDocumentsListDocumentsRequest::class, $request, null));
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\FirestoreProjectsDatabasesDocumentsListDocumentsResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->listDocumentsResponse = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\ListDocumentsResponse', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Listens to changes. This method is only available via gRPC or WebChannel (not REST).
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\FirestoreProjectsDatabasesDocumentsListenRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\FirestoreProjectsDatabasesDocumentsListenSecurity $security
     * @return \OpenAPI\OpenAPI\Models\Operations\FirestoreProjectsDatabasesDocumentsListenResponse
     */
	public function firestoreProjectsDatabasesDocumentsListen(
        \OpenAPI\OpenAPI\Models\Operations\FirestoreProjectsDatabasesDocumentsListenRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\FirestoreProjectsDatabasesDocumentsListenSecurity $security,
    ): \OpenAPI\OpenAPI\Models\Operations\FirestoreProjectsDatabasesDocumentsListenResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v1/{database}/documents:listen', \OpenAPI\OpenAPI\Models\Operations\FirestoreProjectsDatabasesDocumentsListenRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "listenRequest", "json");
        $options = array_merge_recursive($options, $body);
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\FirestoreProjectsDatabasesDocumentsListenRequest::class, $request, null));
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\FirestoreProjectsDatabasesDocumentsListenResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->listenResponse = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\ListenResponse', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Partitions a query by returning partition cursors that can be used to run the query in parallel. The returned partition cursors are split points that can be used by RunQuery as starting/end points for the query results.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\FirestoreProjectsDatabasesDocumentsPartitionQueryRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\FirestoreProjectsDatabasesDocumentsPartitionQuerySecurity $security
     * @return \OpenAPI\OpenAPI\Models\Operations\FirestoreProjectsDatabasesDocumentsPartitionQueryResponse
     */
	public function firestoreProjectsDatabasesDocumentsPartitionQuery(
        \OpenAPI\OpenAPI\Models\Operations\FirestoreProjectsDatabasesDocumentsPartitionQueryRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\FirestoreProjectsDatabasesDocumentsPartitionQuerySecurity $security,
    ): \OpenAPI\OpenAPI\Models\Operations\FirestoreProjectsDatabasesDocumentsPartitionQueryResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v1/{parent}:partitionQuery', \OpenAPI\OpenAPI\Models\Operations\FirestoreProjectsDatabasesDocumentsPartitionQueryRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "partitionQueryRequest", "json");
        $options = array_merge_recursive($options, $body);
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\FirestoreProjectsDatabasesDocumentsPartitionQueryRequest::class, $request, null));
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\FirestoreProjectsDatabasesDocumentsPartitionQueryResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->partitionQueryResponse = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\PartitionQueryResponse', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Updates or inserts a document.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\FirestoreProjectsDatabasesDocumentsPatchRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\FirestoreProjectsDatabasesDocumentsPatchSecurity $security
     * @return \OpenAPI\OpenAPI\Models\Operations\FirestoreProjectsDatabasesDocumentsPatchResponse
     */
	public function firestoreProjectsDatabasesDocumentsPatch(
        \OpenAPI\OpenAPI\Models\Operations\FirestoreProjectsDatabasesDocumentsPatchRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\FirestoreProjectsDatabasesDocumentsPatchSecurity $security,
    ): \OpenAPI\OpenAPI\Models\Operations\FirestoreProjectsDatabasesDocumentsPatchResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v1/{name}', \OpenAPI\OpenAPI\Models\Operations\FirestoreProjectsDatabasesDocumentsPatchRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "document", "json");
        $options = array_merge_recursive($options, $body);
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\FirestoreProjectsDatabasesDocumentsPatchRequest::class, $request, null));
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('PATCH', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\FirestoreProjectsDatabasesDocumentsPatchResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->document = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\Document', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Rolls back a transaction.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\FirestoreProjectsDatabasesDocumentsRollbackRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\FirestoreProjectsDatabasesDocumentsRollbackSecurity $security
     * @return \OpenAPI\OpenAPI\Models\Operations\FirestoreProjectsDatabasesDocumentsRollbackResponse
     */
	public function firestoreProjectsDatabasesDocumentsRollback(
        \OpenAPI\OpenAPI\Models\Operations\FirestoreProjectsDatabasesDocumentsRollbackRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\FirestoreProjectsDatabasesDocumentsRollbackSecurity $security,
    ): \OpenAPI\OpenAPI\Models\Operations\FirestoreProjectsDatabasesDocumentsRollbackResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v1/{database}/documents:rollback', \OpenAPI\OpenAPI\Models\Operations\FirestoreProjectsDatabasesDocumentsRollbackRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "rollbackRequest", "json");
        $options = array_merge_recursive($options, $body);
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\FirestoreProjectsDatabasesDocumentsRollbackRequest::class, $request, null));
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\FirestoreProjectsDatabasesDocumentsRollbackResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->empty = $serializer->deserialize((string)$httpResponse->getBody(), 'array<string, mixed>', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Runs an aggregation query. Rather than producing Document results like Firestore.RunQuery, this API allows running an aggregation to produce a series of AggregationResult server-side. High-Level Example: ``` -- Return the number of documents in table given a filter. SELECT COUNT(*) FROM ( SELECT * FROM k where a = true ); ```
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\FirestoreProjectsDatabasesDocumentsRunAggregationQueryRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\FirestoreProjectsDatabasesDocumentsRunAggregationQuerySecurity $security
     * @return \OpenAPI\OpenAPI\Models\Operations\FirestoreProjectsDatabasesDocumentsRunAggregationQueryResponse
     */
	public function firestoreProjectsDatabasesDocumentsRunAggregationQuery(
        \OpenAPI\OpenAPI\Models\Operations\FirestoreProjectsDatabasesDocumentsRunAggregationQueryRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\FirestoreProjectsDatabasesDocumentsRunAggregationQuerySecurity $security,
    ): \OpenAPI\OpenAPI\Models\Operations\FirestoreProjectsDatabasesDocumentsRunAggregationQueryResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v1/{parent}:runAggregationQuery', \OpenAPI\OpenAPI\Models\Operations\FirestoreProjectsDatabasesDocumentsRunAggregationQueryRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "runAggregationQueryRequest", "json");
        $options = array_merge_recursive($options, $body);
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\FirestoreProjectsDatabasesDocumentsRunAggregationQueryRequest::class, $request, null));
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\FirestoreProjectsDatabasesDocumentsRunAggregationQueryResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->runAggregationQueryResponse = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\RunAggregationQueryResponse', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Runs a query.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\FirestoreProjectsDatabasesDocumentsRunQueryRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\FirestoreProjectsDatabasesDocumentsRunQuerySecurity $security
     * @return \OpenAPI\OpenAPI\Models\Operations\FirestoreProjectsDatabasesDocumentsRunQueryResponse
     */
	public function firestoreProjectsDatabasesDocumentsRunQuery(
        \OpenAPI\OpenAPI\Models\Operations\FirestoreProjectsDatabasesDocumentsRunQueryRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\FirestoreProjectsDatabasesDocumentsRunQuerySecurity $security,
    ): \OpenAPI\OpenAPI\Models\Operations\FirestoreProjectsDatabasesDocumentsRunQueryResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v1/{parent}:runQuery', \OpenAPI\OpenAPI\Models\Operations\FirestoreProjectsDatabasesDocumentsRunQueryRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "runQueryRequest", "json");
        $options = array_merge_recursive($options, $body);
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\FirestoreProjectsDatabasesDocumentsRunQueryRequest::class, $request, null));
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\FirestoreProjectsDatabasesDocumentsRunQueryResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->runQueryResponse = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\RunQueryResponse', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Streams batches of document updates and deletes, in order. This method is only available via gRPC or WebChannel (not REST).
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\FirestoreProjectsDatabasesDocumentsWriteRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\FirestoreProjectsDatabasesDocumentsWriteSecurity $security
     * @return \OpenAPI\OpenAPI\Models\Operations\FirestoreProjectsDatabasesDocumentsWriteResponse
     */
	public function firestoreProjectsDatabasesDocumentsWrite(
        \OpenAPI\OpenAPI\Models\Operations\FirestoreProjectsDatabasesDocumentsWriteRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\FirestoreProjectsDatabasesDocumentsWriteSecurity $security,
    ): \OpenAPI\OpenAPI\Models\Operations\FirestoreProjectsDatabasesDocumentsWriteResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v1/{database}/documents:write', \OpenAPI\OpenAPI\Models\Operations\FirestoreProjectsDatabasesDocumentsWriteRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "writeRequest", "json");
        $options = array_merge_recursive($options, $body);
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\FirestoreProjectsDatabasesDocumentsWriteRequest::class, $request, null));
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\FirestoreProjectsDatabasesDocumentsWriteResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->writeResponse = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\WriteResponse', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Exports a copy of all or a subset of documents from Google Cloud Firestore to another storage system, such as Google Cloud Storage. Recent updates to documents may not be reflected in the export. The export occurs in the background and its progress can be monitored and managed via the Operation resource that is created. The output of an export may only be used once the associated operation is done. If an export operation is cancelled before completion it may leave partial data behind in Google Cloud Storage. For more details on export behavior and output format, refer to: https://cloud.google.com/firestore/docs/manage-data/export-import
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\FirestoreProjectsDatabasesExportDocumentsRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\FirestoreProjectsDatabasesExportDocumentsSecurity $security
     * @return \OpenAPI\OpenAPI\Models\Operations\FirestoreProjectsDatabasesExportDocumentsResponse
     */
	public function firestoreProjectsDatabasesExportDocuments(
        \OpenAPI\OpenAPI\Models\Operations\FirestoreProjectsDatabasesExportDocumentsRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\FirestoreProjectsDatabasesExportDocumentsSecurity $security,
    ): \OpenAPI\OpenAPI\Models\Operations\FirestoreProjectsDatabasesExportDocumentsResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v1/{name}:exportDocuments', \OpenAPI\OpenAPI\Models\Operations\FirestoreProjectsDatabasesExportDocumentsRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "googleFirestoreAdminV1ExportDocumentsRequest", "json");
        $options = array_merge_recursive($options, $body);
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\FirestoreProjectsDatabasesExportDocumentsRequest::class, $request, null));
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\FirestoreProjectsDatabasesExportDocumentsResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->googleLongrunningOperation = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\GoogleLongrunningOperation', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Imports documents into Google Cloud Firestore. Existing documents with the same name are overwritten. The import occurs in the background and its progress can be monitored and managed via the Operation resource that is created. If an ImportDocuments operation is cancelled, it is possible that a subset of the data has already been imported to Cloud Firestore.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\FirestoreProjectsDatabasesImportDocumentsRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\FirestoreProjectsDatabasesImportDocumentsSecurity $security
     * @return \OpenAPI\OpenAPI\Models\Operations\FirestoreProjectsDatabasesImportDocumentsResponse
     */
	public function firestoreProjectsDatabasesImportDocuments(
        \OpenAPI\OpenAPI\Models\Operations\FirestoreProjectsDatabasesImportDocumentsRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\FirestoreProjectsDatabasesImportDocumentsSecurity $security,
    ): \OpenAPI\OpenAPI\Models\Operations\FirestoreProjectsDatabasesImportDocumentsResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v1/{name}:importDocuments', \OpenAPI\OpenAPI\Models\Operations\FirestoreProjectsDatabasesImportDocumentsRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "googleFirestoreAdminV1ImportDocumentsRequest", "json");
        $options = array_merge_recursive($options, $body);
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\FirestoreProjectsDatabasesImportDocumentsRequest::class, $request, null));
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\FirestoreProjectsDatabasesImportDocumentsResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->googleLongrunningOperation = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\GoogleLongrunningOperation', 'json');
            }
        }

        return $response;
    }
	
    /**
     * List all the databases in the project.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\FirestoreProjectsDatabasesListRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\FirestoreProjectsDatabasesListSecurity $security
     * @return \OpenAPI\OpenAPI\Models\Operations\FirestoreProjectsDatabasesListResponse
     */
	public function firestoreProjectsDatabasesList(
        \OpenAPI\OpenAPI\Models\Operations\FirestoreProjectsDatabasesListRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\FirestoreProjectsDatabasesListSecurity $security,
    ): \OpenAPI\OpenAPI\Models\Operations\FirestoreProjectsDatabasesListResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v1/{parent}/databases', \OpenAPI\OpenAPI\Models\Operations\FirestoreProjectsDatabasesListRequest::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\FirestoreProjectsDatabasesListRequest::class, $request, null));
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\FirestoreProjectsDatabasesListResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->googleFirestoreAdminV1ListDatabasesResponse = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\GoogleFirestoreAdminV1ListDatabasesResponse', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Starts asynchronous cancellation on a long-running operation. The server makes a best effort to cancel the operation, but success is not guaranteed. If the server doesn't support this method, it returns `google.rpc.Code.UNIMPLEMENTED`. Clients can use Operations.GetOperation or other methods to check whether the cancellation succeeded or whether the operation completed despite cancellation. On successful cancellation, the operation is not deleted; instead, it becomes an operation with an Operation.error value with a google.rpc.Status.code of 1, corresponding to `Code.CANCELLED`.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\FirestoreProjectsDatabasesOperationsCancelRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\FirestoreProjectsDatabasesOperationsCancelSecurity $security
     * @return \OpenAPI\OpenAPI\Models\Operations\FirestoreProjectsDatabasesOperationsCancelResponse
     */
	public function firestoreProjectsDatabasesOperationsCancel(
        \OpenAPI\OpenAPI\Models\Operations\FirestoreProjectsDatabasesOperationsCancelRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\FirestoreProjectsDatabasesOperationsCancelSecurity $security,
    ): \OpenAPI\OpenAPI\Models\Operations\FirestoreProjectsDatabasesOperationsCancelResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v1/{name}:cancel', \OpenAPI\OpenAPI\Models\Operations\FirestoreProjectsDatabasesOperationsCancelRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "requestBody", "json");
        $options = array_merge_recursive($options, $body);
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\FirestoreProjectsDatabasesOperationsCancelRequest::class, $request, null));
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\FirestoreProjectsDatabasesOperationsCancelResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->empty = $serializer->deserialize((string)$httpResponse->getBody(), 'array<string, mixed>', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Deletes a long-running operation. This method indicates that the client is no longer interested in the operation result. It does not cancel the operation. If the server doesn't support this method, it returns `google.rpc.Code.UNIMPLEMENTED`.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\FirestoreProjectsDatabasesOperationsDeleteRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\FirestoreProjectsDatabasesOperationsDeleteSecurity $security
     * @return \OpenAPI\OpenAPI\Models\Operations\FirestoreProjectsDatabasesOperationsDeleteResponse
     */
	public function firestoreProjectsDatabasesOperationsDelete(
        \OpenAPI\OpenAPI\Models\Operations\FirestoreProjectsDatabasesOperationsDeleteRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\FirestoreProjectsDatabasesOperationsDeleteSecurity $security,
    ): \OpenAPI\OpenAPI\Models\Operations\FirestoreProjectsDatabasesOperationsDeleteResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v1/{name}', \OpenAPI\OpenAPI\Models\Operations\FirestoreProjectsDatabasesOperationsDeleteRequest::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\FirestoreProjectsDatabasesOperationsDeleteRequest::class, $request, null));
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('DELETE', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\FirestoreProjectsDatabasesOperationsDeleteResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->empty = $serializer->deserialize((string)$httpResponse->getBody(), 'array<string, mixed>', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Lists operations that match the specified filter in the request. If the server doesn't support this method, it returns `UNIMPLEMENTED`.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\FirestoreProjectsDatabasesOperationsListRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\FirestoreProjectsDatabasesOperationsListSecurity $security
     * @return \OpenAPI\OpenAPI\Models\Operations\FirestoreProjectsDatabasesOperationsListResponse
     */
	public function firestoreProjectsDatabasesOperationsList(
        \OpenAPI\OpenAPI\Models\Operations\FirestoreProjectsDatabasesOperationsListRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\FirestoreProjectsDatabasesOperationsListSecurity $security,
    ): \OpenAPI\OpenAPI\Models\Operations\FirestoreProjectsDatabasesOperationsListResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v1/{name}/operations', \OpenAPI\OpenAPI\Models\Operations\FirestoreProjectsDatabasesOperationsListRequest::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\FirestoreProjectsDatabasesOperationsListRequest::class, $request, null));
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\FirestoreProjectsDatabasesOperationsListResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->googleLongrunningListOperationsResponse = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\GoogleLongrunningListOperationsResponse', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Gets information about a location.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\FirestoreProjectsLocationsGetRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\FirestoreProjectsLocationsGetSecurity $security
     * @return \OpenAPI\OpenAPI\Models\Operations\FirestoreProjectsLocationsGetResponse
     */
	public function firestoreProjectsLocationsGet(
        \OpenAPI\OpenAPI\Models\Operations\FirestoreProjectsLocationsGetRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\FirestoreProjectsLocationsGetSecurity $security,
    ): \OpenAPI\OpenAPI\Models\Operations\FirestoreProjectsLocationsGetResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v1/{name}', \OpenAPI\OpenAPI\Models\Operations\FirestoreProjectsLocationsGetRequest::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\FirestoreProjectsLocationsGetRequest::class, $request, null));
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\FirestoreProjectsLocationsGetResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->location = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\Location', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Lists information about the supported locations for this service.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\FirestoreProjectsLocationsListRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\FirestoreProjectsLocationsListSecurity $security
     * @return \OpenAPI\OpenAPI\Models\Operations\FirestoreProjectsLocationsListResponse
     */
	public function firestoreProjectsLocationsList(
        \OpenAPI\OpenAPI\Models\Operations\FirestoreProjectsLocationsListRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\FirestoreProjectsLocationsListSecurity $security,
    ): \OpenAPI\OpenAPI\Models\Operations\FirestoreProjectsLocationsListResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v1/{name}/locations', \OpenAPI\OpenAPI\Models\Operations\FirestoreProjectsLocationsListRequest::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\FirestoreProjectsLocationsListRequest::class, $request, null));
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\FirestoreProjectsLocationsListResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->listLocationsResponse = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\ListLocationsResponse', 'json');
            }
        }

        return $response;
    }
}