/*
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

import { SpeakeasyBase, SpeakeasyMetadata } from "../../../internal/utils";
import { Expose, Type } from "class-transformer";

/**
 * Object representing flags that potentialy modify this transaction
 */
export class IssueTokenRequestFlags extends SpeakeasyBase {
  /**
   * If true change will be split into 2 outputs, one for NEBL change and one for NTP1 change (recommended)
   */
  @SpeakeasyMetadata()
  @Expose({ name: "splitChange" })
  splitChange?: boolean;
}

export class IssueTokenRequestMetadataEncryptions extends SpeakeasyBase {
  /**
   * key format (pem or der)
   */
  @SpeakeasyMetadata()
  @Expose({ name: "format" })
  format?: string;

  /**
   * userData key to encrypt
   */
  @SpeakeasyMetadata()
  @Expose({ name: "key" })
  key?: string;

  /**
   * RSA public key used for encryption
   */
  @SpeakeasyMetadata()
  @Expose({ name: "pubkey" })
  pubkey?: string;

  /**
   * pkcs1 or pkcs8
   */
  @SpeakeasyMetadata()
  @Expose({ name: "type" })
  type?: string;
}

/**
 * Object describing expiration rules of the token
 */
export class IssueTokenRequestMetadataRulesExpiration extends SpeakeasyBase {
  /**
   * Whether this rule can be modified in future transactions
   */
  @SpeakeasyMetadata()
  @Expose({ name: "locked" })
  locked?: boolean;

  /**
   * Blockheight at wh
   */
  @SpeakeasyMetadata()
  @Expose({ name: "validUntil" })
  validUntil?: number;
}

export class IssueTokenRequestMetadataRulesFeesItems extends SpeakeasyBase {
  /**
   * Address fee is auto sent to
   */
  @SpeakeasyMetadata()
  @Expose({ name: "address" })
  address?: string;

  /**
   * How fee should be paid, either with a tokenId, or with NEBL if null
   */
  @SpeakeasyMetadata()
  @Expose({ name: "tokenId" })
  tokenId?: string;

  /**
   * Amount of NTP1 token, or NEBL (in satoshi) to pay as fee
   */
  @SpeakeasyMetadata()
  @Expose({ name: "value" })
  value?: string;
}

export class IssueTokenRequestMetadataRulesFees extends SpeakeasyBase {
  /**
   * Array of objects describing fee rules
   */
  @SpeakeasyMetadata({ elemType: IssueTokenRequestMetadataRulesFeesItems })
  @Expose({ name: "items" })
  @Type(() => IssueTokenRequestMetadataRulesFeesItems)
  items?: IssueTokenRequestMetadataRulesFeesItems[];

  /**
   * Whether this rule can be modified in future transactions
   */
  @SpeakeasyMetadata()
  @Expose({ name: "locked" })
  locked?: boolean;
}

export class IssueTokenRequestMetadataRulesHolders extends SpeakeasyBase {
  /**
   * Address that can hold the token
   */
  @SpeakeasyMetadata()
  @Expose({ name: "address" })
  address?: string;

  /**
   * Whether this rule can be modified in future transactions
   */
  @SpeakeasyMetadata()
  @Expose({ name: "locked" })
  locked?: boolean;
}

/**
 * Object describing token rules
 */
export class IssueTokenRequestMetadataRules extends SpeakeasyBase {
  /**
   * Object describing expiration rules of the token
   */
  @SpeakeasyMetadata()
  @Expose({ name: "expiration" })
  @Type(() => IssueTokenRequestMetadataRulesExpiration)
  expiration?: IssueTokenRequestMetadataRulesExpiration;

  @SpeakeasyMetadata()
  @Expose({ name: "fees" })
  @Type(() => IssueTokenRequestMetadataRulesFees)
  fees?: IssueTokenRequestMetadataRulesFees;

  /**
   * Array of objects describing what addresses can hold the token
   */
  @SpeakeasyMetadata({ elemType: IssueTokenRequestMetadataRulesHolders })
  @Expose({ name: "holders" })
  @Type(() => IssueTokenRequestMetadataRulesHolders)
  holders?: IssueTokenRequestMetadataRulesHolders[];
}

export class IssueTokenRequestMetadataUrls extends SpeakeasyBase {
  /**
   * Hash of data at the URL, used for verification
   */
  @SpeakeasyMetadata()
  @Expose({ name: "dataHash" })
  dataHash?: string;

  /**
   * mimeType of URL content
   */
  @SpeakeasyMetadata()
  @Expose({ name: "mimeType" })
  mimeType?: string;

  /**
   * Name of the URL
   */
  @SpeakeasyMetadata()
  @Expose({ name: "name" })
  name?: string;

  /**
   * Actual URL
   */
  @SpeakeasyMetadata()
  @Expose({ name: "url" })
  url?: string;
}

export class IssueTokenRequestMetadataUserDataMeta extends SpeakeasyBase {
  @SpeakeasyMetadata()
  @Expose({ name: "key" })
  key?: string;

  @SpeakeasyMetadata()
  @Expose({ name: "value" })
  value?: string;
}

/**
 * Metadata set by user on token
 */
export class IssueTokenRequestMetadataUserData extends SpeakeasyBase {
  @SpeakeasyMetadata({ elemType: IssueTokenRequestMetadataUserDataMeta })
  @Expose({ name: "meta" })
  @Type(() => IssueTokenRequestMetadataUserDataMeta)
  meta?: IssueTokenRequestMetadataUserDataMeta[];
}

/**
 * Object representing all metadata at token issuance
 */
export class IssueTokenRequestMetadata extends SpeakeasyBase {
  /**
   * Long name or description of token (ex. Nibble)
   */
  @SpeakeasyMetadata()
  @Expose({ name: "description" })
  description?: string;

  /**
   * Array of encryption instruction objects for encrypting userData
   */
  @SpeakeasyMetadata({ elemType: IssueTokenRequestMetadataEncryptions })
  @Expose({ name: "encryptions" })
  @Type(() => IssueTokenRequestMetadataEncryptions)
  encryptions?: IssueTokenRequestMetadataEncryptions[];

  /**
   * Name of token issuer
   */
  @SpeakeasyMetadata()
  @Expose({ name: "issuer" })
  issuer?: string;

  /**
   * Object describing token rules
   */
  @SpeakeasyMetadata()
  @Expose({ name: "rules" })
  @Type(() => IssueTokenRequestMetadataRules)
  rules?: IssueTokenRequestMetadataRules;

  /**
   * Token Symbol it will be identified by (ex. NIBBL)
   */
  @SpeakeasyMetadata()
  @Expose({ name: "tokenName" })
  tokenName?: string;

  @SpeakeasyMetadata({ elemType: IssueTokenRequestMetadataUrls })
  @Expose({ name: "urls" })
  @Type(() => IssueTokenRequestMetadataUrls)
  urls?: IssueTokenRequestMetadataUrls[];

  /**
   * Metadata set by user on token
   */
  @SpeakeasyMetadata()
  @Expose({ name: "userData" })
  @Type(() => IssueTokenRequestMetadataUserData)
  userData?: IssueTokenRequestMetadataUserData;
}

export class IssueTokenRequestTransfer extends SpeakeasyBase {
  /**
   * Address to send the amount of issued tokens to
   */
  @SpeakeasyMetadata()
  @Expose({ name: "address" })
  address?: string;

  @SpeakeasyMetadata()
  @Expose({ name: "amount" })
  amount?: number;
}

/**
 * Object representing the token to be created
 */
export class IssueTokenRequest extends SpeakeasyBase {
  /**
   * Number of tokens to issue
   */
  @SpeakeasyMetadata()
  @Expose({ name: "amount" })
  amount: number;

  /**
   * Number of decimal places the token should be divisble by (0-7)
   */
  @SpeakeasyMetadata()
  @Expose({ name: "divisibility" })
  divisibility: number;

  /**
   * Fee in satoshi to include in the issuance transaction min 1000000000 (10 NEBL)
   */
  @SpeakeasyMetadata()
  @Expose({ name: "fee" })
  fee: number;

  /**
   * Object representing flags that potentialy modify this transaction
   */
  @SpeakeasyMetadata()
  @Expose({ name: "flags" })
  @Type(() => IssueTokenRequestFlags)
  flags?: IssueTokenRequestFlags;

  /**
   * Address issuing the token
   */
  @SpeakeasyMetadata()
  @Expose({ name: "issueAddress" })
  issueAddress: string;

  /**
   * Object representing all metadata at token issuance
   */
  @SpeakeasyMetadata()
  @Expose({ name: "metadata" })
  @Type(() => IssueTokenRequestMetadata)
  metadata?: IssueTokenRequestMetadata;

  /**
   * whether the token should be reissuable
   */
  @SpeakeasyMetadata()
  @Expose({ name: "reissuable" })
  reissuable: boolean;

  @SpeakeasyMetadata({ elemType: IssueTokenRequestTransfer })
  @Expose({ name: "transfer" })
  @Type(() => IssueTokenRequestTransfer)
  transfer: IssueTokenRequestTransfer[];
}
