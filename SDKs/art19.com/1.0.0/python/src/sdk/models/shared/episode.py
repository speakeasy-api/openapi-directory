"""Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT."""

from __future__ import annotations
import dataclasses
import dateutil.parser
from ..shared import resourceidentifier as shared_resourceidentifier
from dataclasses_json import Undefined, dataclass_json
from datetime import datetime
from enum import Enum
from marshmallow import fields
from sdk import utils
from typing import Optional

class EpisodeAttributesItunesTypeEnum(str, Enum):
    r"""The type of the episode according to Apple's type categorization"""
    FULL = 'full'
    BONUS = 'bonus'
    TRAILER = 'trailer'

class EpisodeAttributesPremiumStatusEnum(str, Enum):
    r"""The current premium status of the episode"""
    ACTIVE = 'active'
    INACTIVE = 'inactive'
    FORCE_ACTIVE = 'force-active'
    FORCE_INACTIVE = 'force-inactive'

class EpisodeAttributesStatusEnum(str, Enum):
    r"""The status of an episode"""
    ACTIVE = 'active'
    INACTIVE = 'inactive'


@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class EpisodeAttributes:
    
    allow_user_comments: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('allow_user_comments'), 'exclude': lambda f: f is None }})
    r"""Only visible to credentials having write privileges for the series."""  
    cascaded_cover_image_id: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('cascaded_cover_image_id'), 'exclude': lambda f: f is None }})
    r"""This will be replaced by the relationship `cascaded_cover_image` in a future update.<br/>
    The image ID of the cover art for this episode. This is the preferred image ID to use.
    If there is no specific cover for the episode, the image ID of the season or the
    series will be returned, whichever has one defined.
    The `/images` endpoint provides details to the image.
    """  
    cover_image_id: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('cover_image_id'), 'exclude': lambda f: f is None }})
    r"""This will be replaced by the relationship `cover_image` in a future update.<br/>
    The image ID of the cover art for this episode, if an episode-specific image has been provided.
    The `/images` endpoint provideds details to the image.
    """  
    created_at: Optional[datetime] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('created_at'), 'encoder': utils.datetimeisoformat(True), 'decoder': dateutil.parser.isoparse, 'mm_field': fields.DateTime(format='iso'), 'exclude': lambda f: f is None }})  
    description: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('description'), 'exclude': lambda f: f is None }})
    r"""The description of the episode, possibly in HTML format"""  
    description_is_html: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('description_is_html'), 'exclude': lambda f: f is None }})
    r"""Determines whether `description` is in HTML format or plain."""  
    description_plain: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('description_plain'), 'exclude': lambda f: f is None }})
    r"""The description with all HTML markup removed. If the description does not contain markup,
    this is identical to `description`.
    """  
    file_name: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('file_name'), 'exclude': lambda f: f is None }})
    r"""The file name, without extension, to present users when downloading the episode"""  
    itunes_type: Optional[EpisodeAttributesItunesTypeEnum] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('itunes_type'), 'exclude': lambda f: f is None }})
    r"""The type of the episode according to Apple's type categorization"""  
    listen_count: Optional[int] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('listen_count'), 'exclude': lambda f: f is None }})
    r"""The number of total downloads all time for this episode.
    Only visible if the credential has the right privilege on the series.
    """  
    premium_status: Optional[EpisodeAttributesPremiumStatusEnum] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('premium_status'), 'exclude': lambda f: f is None }})
    r"""The current premium status of the episode"""  
    published: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('published'), 'exclude': lambda f: f is None }})
    r"""If `true`, the episode will be available for download and included in the feed as soon as its
    release time is reached, provided it has a valid media file, and `release_end_at` is in the future (if applicable).
    """  
    release_end_at: Optional[datetime] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('release_end_at'), 'encoder': utils.datetimeisoformat(True), 'decoder': dateutil.parser.isoparse, 'mm_field': fields.DateTime(format='iso'), 'exclude': lambda f: f is None }})
    r"""The date and time when an episode will no longer be included in the feed, or available for download.
    `Published` will remain `true` unless the episode is manually unpublished.
    """  
    release_immediately: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('release_immediately'), 'exclude': lambda f: f is None }})
    r"""If `true`, the episode's release time is set in a way it is considered released right away.
    Only visible if the credential has write privileges on the series.
    """  
    released_at: Optional[datetime] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('released_at'), 'encoder': utils.datetimeisoformat(True), 'decoder': dateutil.parser.isoparse, 'mm_field': fields.DateTime(format='iso'), 'exclude': lambda f: f is None }})
    r"""The date and time when an episode will be released. It will be available for download and included
    in the feed if this time is reached, `published` is set to `true`, and the episode has a media file.
    """  
    rss_guid: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('rss_guid'), 'exclude': lambda f: f is None }})
    r"""A globally unique identifier describing the episode. This ID is commonly used by podcast applications
    to determine whether an episode has already been downloaded or not.
    """  
    season_id: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('season_id'), 'exclude': lambda f: f is None }})
    r"""Use the relationship `season` instead.<br />
    The ID of the season an episode belongs to. This can be `null`. A series can have episodes with and
    without seasons at the same time.
    """  
    series_id: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('series_id'), 'exclude': lambda f: f is None }})
    r"""Use the relationship `series` instead.<br />
    The ID of the series an episode belongs to.
    """  
    sort_title: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('sort_title'), 'exclude': lambda f: f is None }})
    r"""The title of the episode modified for sorting. This converts all characters to
    lower case, removes an eventually leading `The` as well as leading and trailling whitespace characters.
    """  
    status: Optional[EpisodeAttributesStatusEnum] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('status'), 'exclude': lambda f: f is None }})
    r"""The status of an episode"""  
    title: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('title'), 'exclude': lambda f: f is None }})
    r"""The title of the episode"""  
    updated_at: Optional[datetime] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('updated_at'), 'encoder': utils.datetimeisoformat(True), 'decoder': dateutil.parser.isoparse, 'mm_field': fields.DateTime(format='iso'), 'exclude': lambda f: f is None }})  
    

@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class EpisodeRelationshipsCascadedCoverImage:
    r"""The cover art for this episode. This is the preferred image to use.
    If there is no specific cover image for the episode, the cover of the season or the
    series will be returned, whichever has one defined.
    The `/images` endpoint provides details to the image.
    """
    
    data: Optional[shared_resourceidentifier.ResourceIdentifier] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('data'), 'exclude': lambda f: f is None }})  
    

@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class EpisodeRelationshipsAListOfClassificationsAssociatedWithTheEpisode:
    
    data: Optional[list[shared_resourceidentifier.ResourceIdentifier]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('data'), 'exclude': lambda f: f is None }})  
    

@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class EpisodeRelationshipsCoverImage:
    r"""The cover art for this episode, if an episode-specific image has been provided.
    The `/images` endpoint provideds details to the image.
    """
    
    data: Optional[shared_resourceidentifier.ResourceIdentifier] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('data'), 'exclude': lambda f: f is None }})  
    

@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class EpisodeRelationshipsAListOfCreditsGivenToPeopleInTheEpisode:
    
    data: Optional[list[shared_resourceidentifier.ResourceIdentifier]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('data'), 'exclude': lambda f: f is None }})  
    

@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class EpisodeRelationshipsAListOfDefaultWarpFeedMarkerPoints:
    r"""Only visible if the credential has write privileges on the series"""
    
    data: Optional[list[shared_resourceidentifier.ResourceIdentifier]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('data'), 'exclude': lambda f: f is None }})  
    

@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class EpisodeRelationshipsAListOfEpisodeVersionsForThisEpisode:
    r"""Only visible if the credential has write privileges on the series"""
    
    data: Optional[list[shared_resourceidentifier.ResourceIdentifier]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('data'), 'exclude': lambda f: f is None }})  
    

@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class EpisodeRelationshipsBothTheCoverImageAndTheCascadedCoverImageForTheSeason:
    
    data: Optional[list[shared_resourceidentifier.ResourceIdentifier]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('data'), 'exclude': lambda f: f is None }})  
    

@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class EpisodeRelationshipsTheSeasonTheEpisodeBelongsTo:
    
    data: Optional[shared_resourceidentifier.ResourceIdentifier] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('data'), 'exclude': lambda f: f is None }})  
    

@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class EpisodeRelationshipsAListOfSegmentListsDirectlyAttachedToTheEpisode:
    r"""Only visible if the credential has write privileges on the series"""
    
    data: Optional[list[shared_resourceidentifier.ResourceIdentifier]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('data'), 'exclude': lambda f: f is None }})  
    

@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class EpisodeRelationshipsTheSeriesAnEpisodeBelongsTo:
    
    data: Optional[shared_resourceidentifier.ResourceIdentifier] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('data'), 'exclude': lambda f: f is None }})  
    

@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class EpisodeRelationshipsAListOfAssociationsLinkingTagsToTheEpisodes:
    
    data: Optional[list[shared_resourceidentifier.ResourceIdentifier]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('data'), 'exclude': lambda f: f is None }})  
    

@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class EpisodeRelationshipsAListOfTagsAssociatedWithTheEpisodes:
    
    data: Optional[list[shared_resourceidentifier.ResourceIdentifier]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('data'), 'exclude': lambda f: f is None }})  
    

@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class EpisodeRelationships:
    
    cascaded_cover_image: Optional[EpisodeRelationshipsCascadedCoverImage] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('cascaded_cover_image'), 'exclude': lambda f: f is None }})
    r"""The cover art for this episode. This is the preferred image to use.
    If there is no specific cover image for the episode, the cover of the season or the
    series will be returned, whichever has one defined.
    The `/images` endpoint provides details to the image.
    """  
    classification_inclusions: Optional[EpisodeRelationshipsAListOfClassificationsAssociatedWithTheEpisode] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('classification_inclusions'), 'exclude': lambda f: f is None }})  
    cover_image: Optional[EpisodeRelationshipsCoverImage] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('cover_image'), 'exclude': lambda f: f is None }})
    r"""The cover art for this episode, if an episode-specific image has been provided.
    The `/images` endpoint provideds details to the image.
    """  
    credits: Optional[EpisodeRelationshipsAListOfCreditsGivenToPeopleInTheEpisode] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('credits'), 'exclude': lambda f: f is None }})  
    default_marker_points: Optional[EpisodeRelationshipsAListOfDefaultWarpFeedMarkerPoints] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('default_marker_points'), 'exclude': lambda f: f is None }})
    r"""Only visible if the credential has write privileges on the series"""  
    episode_versions: Optional[EpisodeRelationshipsAListOfEpisodeVersionsForThisEpisode] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('episode_versions'), 'exclude': lambda f: f is None }})
    r"""Only visible if the credential has write privileges on the series"""  
    images: Optional[EpisodeRelationshipsBothTheCoverImageAndTheCascadedCoverImageForTheSeason] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('images'), 'exclude': lambda f: f is None }})  
    season: Optional[EpisodeRelationshipsTheSeasonTheEpisodeBelongsTo] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('season'), 'exclude': lambda f: f is None }})  
    segment_lists: Optional[EpisodeRelationshipsAListOfSegmentListsDirectlyAttachedToTheEpisode] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('segment_lists'), 'exclude': lambda f: f is None }})
    r"""Only visible if the credential has write privileges on the series"""  
    series: Optional[EpisodeRelationshipsTheSeriesAnEpisodeBelongsTo] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('series'), 'exclude': lambda f: f is None }})  
    taggings: Optional[EpisodeRelationshipsAListOfAssociationsLinkingTagsToTheEpisodes] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('taggings'), 'exclude': lambda f: f is None }})  
    tags: Optional[EpisodeRelationshipsAListOfTagsAssociatedWithTheEpisodes] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('tags'), 'exclude': lambda f: f is None }})  
    

@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class Episode:
    
    attributes: Optional[EpisodeAttributes] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('attributes'), 'exclude': lambda f: f is None }})  
    id: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('id'), 'exclude': lambda f: f is None }})  
    relationships: Optional[EpisodeRelationships] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('relationships'), 'exclude': lambda f: f is None }})  
    type: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('type'), 'exclude': lambda f: f is None }})
    r"""The type of resource. This is always `episodes`"""  
    