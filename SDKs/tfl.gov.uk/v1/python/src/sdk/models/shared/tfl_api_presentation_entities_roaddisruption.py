"""Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT."""

from __future__ import annotations
import dataclasses
import dateutil.parser
from ..shared import system_data_spatial_dbgeography as shared_system_data_spatial_dbgeography
from ..shared import tfl_api_presentation_entities_roaddisruptionimpactarea as shared_tfl_api_presentation_entities_roaddisruptionimpactarea
from ..shared import tfl_api_presentation_entities_roaddisruptionline as shared_tfl_api_presentation_entities_roaddisruptionline
from ..shared import tfl_api_presentation_entities_roaddisruptionschedule as shared_tfl_api_presentation_entities_roaddisruptionschedule
from ..shared import tfl_api_presentation_entities_roadproject as shared_tfl_api_presentation_entities_roadproject
from ..shared import tfl_api_presentation_entities_street as shared_tfl_api_presentation_entities_street
from dataclasses_json import Undefined, dataclass_json
from datetime import datetime
from marshmallow import fields
from sdk import utils
from typing import Optional


@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class TflAPIPresentationEntitiesRoadDisruption:
    r"""OK"""
    
    category: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('category'), 'exclude': lambda f: f is None }})
    r"""Describes the nature of disruption e.g. Traffic Incidents, Works"""  
    comments: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('comments'), 'exclude': lambda f: f is None }})
    r"""Full text of comments describing the disruption, including details of any road closures and diversions, where appropriate."""  
    corridor_ids: Optional[list[str]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('corridorIds'), 'exclude': lambda f: f is None }})
    r"""The Ids of affected corridors, if any."""  
    current_update: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('currentUpdate'), 'exclude': lambda f: f is None }})
    r"""Text of the most recent update from the LSTCC on the state of the
                 disruption, including the current traffic impact and any advice to
                 road users.
    """  
    current_update_date_time: Optional[datetime] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('currentUpdateDateTime'), 'encoder': utils.datetimeisoformat(True), 'decoder': dateutil.parser.isoparse, 'mm_field': fields.DateTime(format='iso'), 'exclude': lambda f: f is None }})
    r"""The time when the last CurrentUpdate description was recorded,
                or null if no CurrentUpdate has been applied.
    """  
    end_date_time: Optional[datetime] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('endDateTime'), 'encoder': utils.datetimeisoformat(True), 'decoder': dateutil.parser.isoparse, 'mm_field': fields.DateTime(format='iso'), 'exclude': lambda f: f is None }})
    r"""The date and time on which the disruption ended. For planned disruptions, this date will have a valid value. For unplanned
                disruptions in progress, this field will be omitted.
    """  
    geography: Optional[shared_system_data_spatial_dbgeography.SystemDataSpatialDbGeography] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('geography'), 'exclude': lambda f: f is None }})  
    geometry: Optional[shared_system_data_spatial_dbgeography.SystemDataSpatialDbGeography] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('geometry'), 'exclude': lambda f: f is None }})  
    has_closures: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('hasClosures'), 'exclude': lambda f: f is None }})
    r"""True if any of the affected Streets have a \\"Full Closure\\" status, false otherwise. A RoadDisruption that has HasClosures is considered a
                Severe or Serious disruption for severity filtering purposes.
    """  
    id: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('id'), 'exclude': lambda f: f is None }})
    r"""Unique identifier for the road disruption"""  
    is_provisional: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('isProvisional'), 'exclude': lambda f: f is None }})
    r"""True if the disruption is planned on a future date that is open to change"""  
    last_modified_time: Optional[datetime] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('lastModifiedTime'), 'encoder': utils.datetimeisoformat(True), 'decoder': dateutil.parser.isoparse, 'mm_field': fields.DateTime(format='iso'), 'exclude': lambda f: f is None }})
    r"""The date and time on which the disruption was last modified in the system. This information can reliably be used by a developer to quickly
                compare two instances of the same disruption to determine if it has been changed.
    """  
    level_of_interest: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('levelOfInterest'), 'exclude': lambda f: f is None }})
    r"""This describes the level of potential impact on traffic operations of the disruption.
                High = e.g. a one-off disruption on a major or high profile route which will require a high level of operational attention 
                Medium = This is the default value 
                Low = e.g. a frequently occurring disruption which is well known
    """  
    link_text: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('linkText'), 'exclude': lambda f: f is None }})
    r"""The text of any associated link"""  
    link_url: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('linkUrl'), 'exclude': lambda f: f is None }})
    r"""The url of any associated link"""  
    location: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('location'), 'exclude': lambda f: f is None }})
    r"""Main road name / number (borough) or preset area name where the disruption is located. This might be useful for a map popup where space is limited."""  
    ordinal: Optional[int] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('ordinal'), 'exclude': lambda f: f is None }})
    r"""An ordinal of the disruption based on severity, level of interest and corridor."""  
    point: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('point'), 'exclude': lambda f: f is None }})
    r"""Latitude and longitude (WGS84) of the centroid of the disruption, stored in a geoJSON-formatted string."""  
    publish_end_date: Optional[datetime] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('publishEndDate'), 'encoder': utils.datetimeisoformat(True), 'decoder': dateutil.parser.isoparse, 'mm_field': fields.DateTime(format='iso'), 'exclude': lambda f: f is None }})  
    publish_start_date: Optional[datetime] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('publishStartDate'), 'encoder': utils.datetimeisoformat(True), 'decoder': dateutil.parser.isoparse, 'mm_field': fields.DateTime(format='iso'), 'exclude': lambda f: f is None }})
    r"""TDM Additional properties"""  
    recurring_schedules: Optional[list[shared_tfl_api_presentation_entities_roaddisruptionschedule.TflAPIPresentationEntitiesRoadDisruptionSchedule]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('recurringSchedules'), 'exclude': lambda f: f is None }})  
    road_disruption_impact_areas: Optional[list[shared_tfl_api_presentation_entities_roaddisruptionimpactarea.TflAPIPresentationEntitiesRoadDisruptionImpactArea]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('roadDisruptionImpactAreas'), 'exclude': lambda f: f is None }})  
    road_disruption_lines: Optional[list[shared_tfl_api_presentation_entities_roaddisruptionline.TflAPIPresentationEntitiesRoadDisruptionLine]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('roadDisruptionLines'), 'exclude': lambda f: f is None }})  
    road_project: Optional[shared_tfl_api_presentation_entities_roadproject.TflAPIPresentationEntitiesRoadProject] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('roadProject'), 'exclude': lambda f: f is None }})  
    severity: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('severity'), 'exclude': lambda f: f is None }})
    r"""A description of the severity of the disruption."""  
    start_date_time: Optional[datetime] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('startDateTime'), 'encoder': utils.datetimeisoformat(True), 'decoder': dateutil.parser.isoparse, 'mm_field': fields.DateTime(format='iso'), 'exclude': lambda f: f is None }})
    r"""The date and time which the disruption started. For a planned disruption (i.e. planned road works) this date will be in the future.
                For unplanned disruptions, this will default to the date on which the disruption was first recorded, but may be adjusted by the operator.
    """  
    status: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('status'), 'exclude': lambda f: f is None }})
    r"""This describes the status of the disruption.
                Active = currently in progress 
                Active Long Term = currently in progress and long term
                Scheduled = scheduled to start within the next 180 days
                Recurring Works = planned maintenance works that follow a regular routine or pattern and whose next occurrence is to start within the next 180 days.
                Recently Cleared = recently cleared in the last 24 hours
                Note that the status of Scheduled or Recurring Works disruptions will change to Active when they start, and will change status again when they end.
    """  
    streets: Optional[list[shared_tfl_api_presentation_entities_street.TflAPIPresentationEntitiesStreet]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('streets'), 'exclude': lambda f: f is None }})
    r"""A collection of zero or more streets affected by the disruption."""  
    sub_category: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('subCategory'), 'exclude': lambda f: f is None }})
    r"""Describes the sub-category of disruption e.g. Collapsed Manhole, Abnormal Load"""  
    time_frame: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('timeFrame'), 'exclude': lambda f: f is None }})  
    url: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('url'), 'exclude': lambda f: f is None }})
    r"""URL to retrieve this road disruption"""  
    