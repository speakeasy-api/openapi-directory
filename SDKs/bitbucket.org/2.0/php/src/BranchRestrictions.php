<?php

/**
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

declare(strict_types=1);

namespace OpenAPI\OpenAPI;

class BranchRestrictions 
{

	// SDK private variables namespaced with _ to avoid conflicts with API models
	private \GuzzleHttp\ClientInterface $_defaultClient;
	private \GuzzleHttp\ClientInterface $_securityClient;
	private string $_serverUrl;
	private string $_language;
	private string $_sdkVersion;
	private string $_genVersion;	

	/**
	 * @param \GuzzleHttp\ClientInterface $defaultClient
	 * @param \GuzzleHttp\ClientInterface $securityClient
	 * @param string $serverUrl
	 * @param string $language
	 * @param string $sdkVersion
	 * @param string $genVersion
	 */
	public function __construct(\GuzzleHttp\ClientInterface $defaultClient, \GuzzleHttp\ClientInterface $securityClient, string $serverUrl, string $language, string $sdkVersion, string $genVersion)
	{
		$this->_defaultClient = $defaultClient;
		$this->_securityClient = $securityClient;
		$this->_serverUrl = $serverUrl;
		$this->_language = $language;
		$this->_sdkVersion = $sdkVersion;
		$this->_genVersion = $genVersion;
	}
	
    /**
     * Delete a branch restriction rule
     * 
     * Deletes an existing branch restriction rule.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\DeleteRepositoriesWorkspaceRepoSlugBranchRestrictionsIdRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\DeleteRepositoriesWorkspaceRepoSlugBranchRestrictionsIdSecurity $security
     * @return \OpenAPI\OpenAPI\Models\Operations\DeleteRepositoriesWorkspaceRepoSlugBranchRestrictionsIdResponse
     */
	public function deleteRepositoriesWorkspaceRepoSlugBranchRestrictionsId(
        \OpenAPI\OpenAPI\Models\Operations\DeleteRepositoriesWorkspaceRepoSlugBranchRestrictionsIdRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\DeleteRepositoriesWorkspaceRepoSlugBranchRestrictionsIdSecurity $security,
    ): \OpenAPI\OpenAPI\Models\Operations\DeleteRepositoriesWorkspaceRepoSlugBranchRestrictionsIdResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/repositories/{workspace}/{repo_slug}/branch-restrictions/{id}', \OpenAPI\OpenAPI\Models\Operations\DeleteRepositoriesWorkspaceRepoSlugBranchRestrictionsIdRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('DELETE', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\DeleteRepositoriesWorkspaceRepoSlugBranchRestrictionsIdResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 204) {
        }
        else if ($httpResponse->getStatusCode() === 401 or $httpResponse->getStatusCode() === 403 or $httpResponse->getStatusCode() === 404) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->error = $serializer->deserialize((string)$httpResponse->getBody(), 'array<string, mixed>', 'json');
            }
        }

        return $response;
    }
	
    /**
     * List branch restrictions
     * 
     * Returns a paginated list of all branch restrictions on the
     * repository.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetRepositoriesWorkspaceRepoSlugBranchRestrictionsRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\GetRepositoriesWorkspaceRepoSlugBranchRestrictionsSecurity $security
     * @return \OpenAPI\OpenAPI\Models\Operations\GetRepositoriesWorkspaceRepoSlugBranchRestrictionsResponse
     */
	public function getRepositoriesWorkspaceRepoSlugBranchRestrictions(
        \OpenAPI\OpenAPI\Models\Operations\GetRepositoriesWorkspaceRepoSlugBranchRestrictionsRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\GetRepositoriesWorkspaceRepoSlugBranchRestrictionsSecurity $security,
    ): \OpenAPI\OpenAPI\Models\Operations\GetRepositoriesWorkspaceRepoSlugBranchRestrictionsResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/repositories/{workspace}/{repo_slug}/branch-restrictions', \OpenAPI\OpenAPI\Models\Operations\GetRepositoriesWorkspaceRepoSlugBranchRestrictionsRequest::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\GetRepositoriesWorkspaceRepoSlugBranchRestrictionsRequest::class, $request, null));
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetRepositoriesWorkspaceRepoSlugBranchRestrictionsResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->paginatedBranchrestrictions = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\PaginatedBranchrestrictions', 'json');
            }
        }
        else if ($httpResponse->getStatusCode() === 401 or $httpResponse->getStatusCode() === 403 or $httpResponse->getStatusCode() === 404) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->error = $serializer->deserialize((string)$httpResponse->getBody(), 'array<string, mixed>', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Get a branch restriction rule
     * 
     * Returns a specific branch restriction rule.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetRepositoriesWorkspaceRepoSlugBranchRestrictionsIdRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\GetRepositoriesWorkspaceRepoSlugBranchRestrictionsIdSecurity $security
     * @return \OpenAPI\OpenAPI\Models\Operations\GetRepositoriesWorkspaceRepoSlugBranchRestrictionsIdResponse
     */
	public function getRepositoriesWorkspaceRepoSlugBranchRestrictionsId(
        \OpenAPI\OpenAPI\Models\Operations\GetRepositoriesWorkspaceRepoSlugBranchRestrictionsIdRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\GetRepositoriesWorkspaceRepoSlugBranchRestrictionsIdSecurity $security,
    ): \OpenAPI\OpenAPI\Models\Operations\GetRepositoriesWorkspaceRepoSlugBranchRestrictionsIdResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/repositories/{workspace}/{repo_slug}/branch-restrictions/{id}', \OpenAPI\OpenAPI\Models\Operations\GetRepositoriesWorkspaceRepoSlugBranchRestrictionsIdRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetRepositoriesWorkspaceRepoSlugBranchRestrictionsIdResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->branchrestriction = $serializer->deserialize((string)$httpResponse->getBody(), 'array<string, mixed>', 'json');
            }
        }
        else if ($httpResponse->getStatusCode() === 401 or $httpResponse->getStatusCode() === 403 or $httpResponse->getStatusCode() === 404) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->error = $serializer->deserialize((string)$httpResponse->getBody(), 'array<string, mixed>', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Create a branch restriction rule
     * 
     * Creates a new branch restriction rule for a repository.
     * 
     * `kind` describes what will be restricted. Allowed values include:
     * `push`, `force`, `delete` and `restrict_merges`.
     * 
     * Different kinds of branch restrictions have different requirements:
     * 
     * * `push` and `restrict_merges` require `users` and `groups` to be
     *   specified. Empty lists are allowed, in which case permission is
     *   denied for everybody.
     * 
     * The restriction applies to all branches that match. There are
     * two ways to match a branch. It is configured in `branch_match_kind`:
     * 
     * 1. `glob`: Matches a branch against the `pattern`. A `'*'` in
     *    `pattern` will expand to match zero or more characters, and every
     *    other character matches itself. For example, `'foo*'` will match
     *    `'foo'` and `'foobar'`, but not `'barfoo'`. `'*'` will match all
     *    branches.
     * 2. `branching_model`: Matches a branch against the repository's
     *    branching model. The `branch_type` controls the type of branch
     *    to match. Allowed values include: `production`, `development`,
     *    `bugfix`, `release`, `feature` and `hotfix`.
     * 
     * The combination of `kind` and match must be unique. This means that
     * two `glob` restrictions in a repository cannot have the same `kind` and
     * `pattern`. Additionally, two `branching_model` restrictions in a
     * repository cannot have the same `kind` and `branch_type`.
     * 
     * `users` and `groups` are lists of users and groups that are except from
     * the restriction. They can only be configured in `push` and
     * `restrict_merges` restrictions. The `push` restriction stops a user
     * pushing to matching branches unless that user is in `users` or is a
     * member of a group in `groups`. The `restrict_merges` stops a user
     * merging pull requests to matching branches unless that user is in
     * `users` or is a member of a group in `groups`. Adding new users or
     * groups to an existing restriction should be done via `PUT`.
     * 
     * Note that branch restrictions with overlapping matchers is allowed,
     * but the resulting behavior may be surprising.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\PostRepositoriesWorkspaceRepoSlugBranchRestrictionsRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\PostRepositoriesWorkspaceRepoSlugBranchRestrictionsSecurity $security
     * @return \OpenAPI\OpenAPI\Models\Operations\PostRepositoriesWorkspaceRepoSlugBranchRestrictionsResponse
     */
	public function postRepositoriesWorkspaceRepoSlugBranchRestrictions(
        \OpenAPI\OpenAPI\Models\Operations\PostRepositoriesWorkspaceRepoSlugBranchRestrictionsRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\PostRepositoriesWorkspaceRepoSlugBranchRestrictionsSecurity $security,
    ): \OpenAPI\OpenAPI\Models\Operations\PostRepositoriesWorkspaceRepoSlugBranchRestrictionsResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/repositories/{workspace}/{repo_slug}/branch-restrictions', \OpenAPI\OpenAPI\Models\Operations\PostRepositoriesWorkspaceRepoSlugBranchRestrictionsRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "requestBody", "json");
        if ($body === null) {
            throw new \Exception('Request body is required');
        }
        $options = array_merge_recursive($options, $body);
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\PostRepositoriesWorkspaceRepoSlugBranchRestrictionsResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 201) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->branchrestriction = $serializer->deserialize((string)$httpResponse->getBody(), 'array<string, mixed>', 'json');
            }
        }
        else if ($httpResponse->getStatusCode() === 401 or $httpResponse->getStatusCode() === 403 or $httpResponse->getStatusCode() === 404) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->error = $serializer->deserialize((string)$httpResponse->getBody(), 'array<string, mixed>', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Update a branch restriction rule
     * 
     * Updates an existing branch restriction rule.
     * 
     * Fields not present in the request body are ignored.
     * 
     * See [`POST`](/cloud/bitbucket/rest/api-group-branch-restrictions/#api-repositories-workspace-repo-slug-branch-restrictions-post) for details.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\PutRepositoriesWorkspaceRepoSlugBranchRestrictionsIdRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\PutRepositoriesWorkspaceRepoSlugBranchRestrictionsIdSecurity $security
     * @return \OpenAPI\OpenAPI\Models\Operations\PutRepositoriesWorkspaceRepoSlugBranchRestrictionsIdResponse
     */
	public function putRepositoriesWorkspaceRepoSlugBranchRestrictionsId(
        \OpenAPI\OpenAPI\Models\Operations\PutRepositoriesWorkspaceRepoSlugBranchRestrictionsIdRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\PutRepositoriesWorkspaceRepoSlugBranchRestrictionsIdSecurity $security,
    ): \OpenAPI\OpenAPI\Models\Operations\PutRepositoriesWorkspaceRepoSlugBranchRestrictionsIdResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/repositories/{workspace}/{repo_slug}/branch-restrictions/{id}', \OpenAPI\OpenAPI\Models\Operations\PutRepositoriesWorkspaceRepoSlugBranchRestrictionsIdRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "requestBody", "json");
        if ($body === null) {
            throw new \Exception('Request body is required');
        }
        $options = array_merge_recursive($options, $body);
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('PUT', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\PutRepositoriesWorkspaceRepoSlugBranchRestrictionsIdResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->branchrestriction = $serializer->deserialize((string)$httpResponse->getBody(), 'array<string, mixed>', 'json');
            }
        }
        else if ($httpResponse->getStatusCode() === 401 or $httpResponse->getStatusCode() === 403 or $httpResponse->getStatusCode() === 404) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->error = $serializer->deserialize((string)$httpResponse->getBody(), 'array<string, mixed>', 'json');
            }
        }

        return $response;
    }
}