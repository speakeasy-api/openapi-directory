<?php

/**
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

declare(strict_types=1);

namespace OpenAPI\OpenAPI;

class Content 
{

	// SDK private variables namespaced with _ to avoid conflicts with API models
	private \GuzzleHttp\ClientInterface $_defaultClient;
	private \GuzzleHttp\ClientInterface $_securityClient;
	private string $_serverUrl;
	private string $_language;
	private string $_sdkVersion;
	private string $_genVersion;	

	/**
	 * @param \GuzzleHttp\ClientInterface $defaultClient
	 * @param \GuzzleHttp\ClientInterface $securityClient
	 * @param string $serverUrl
	 * @param string $language
	 * @param string $sdkVersion
	 * @param string $genVersion
	 */
	public function __construct(\GuzzleHttp\ClientInterface $defaultClient, \GuzzleHttp\ClientInterface $securityClient, string $serverUrl, string $language, string $sdkVersion, string $genVersion)
	{
		$this->_defaultClient = $defaultClient;
		$this->_securityClient = $securityClient;
		$this->_serverUrl = $serverUrl;
		$this->_language = $language;
		$this->_sdkVersion = $sdkVersion;
		$this->_genVersion = $genVersion;
	}
	
    /**
     * Identical to GET /account/profile/items/{itemId}/next route but for users
     * that are not logged in i.e. this endpoint does not require authorisation
     * 
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetAnonNextPlaybackItemRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\GetAnonNextPlaybackItemResponse
     */
	public function getAnonNextPlaybackItem(
        \OpenAPI\OpenAPI\Models\Operations\GetAnonNextPlaybackItemRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\GetAnonNextPlaybackItemResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/items/{itemId}/next', \OpenAPI\OpenAPI\Models\Operations\GetAnonNextPlaybackItemRequest::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\GetAnonNextPlaybackItemRequest::class, $request, null));
        
        $httpResponse = $this->_defaultClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetAnonNextPlaybackItemResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->nextPlaybackItem = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\NextPlaybackItem', 'json');
            }
        }
        else {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->serviceError = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\ServiceError', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Returns the details of an item with the specified id.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetItemRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\GetItemResponse
     */
	public function getItem(
        \OpenAPI\OpenAPI\Models\Operations\GetItemRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\GetItemResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/items/{id}', \OpenAPI\OpenAPI\Models\Operations\GetItemRequest::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\GetItemRequest::class, $request, null));
        
        $httpResponse = $this->_defaultClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetItemResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->itemDetail = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\ItemDetail', 'json');
            }
        }
        else {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->serviceError = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\ServiceError', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Returns the List of child summary items under an item.
     * 
     * If the item is a Season then the children will be episodes and ordered by episode number.
     * 
     * If the item is a Show then the children will be Seasons and ordered by season number.
     * 
     * Returns 404 if no children found.
     * 
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetItemChildrenListRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\GetItemChildrenListResponse
     */
	public function getItemChildrenList(
        \OpenAPI\OpenAPI\Models\Operations\GetItemChildrenListRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\GetItemChildrenListResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/items/{id}/children', \OpenAPI\OpenAPI\Models\Operations\GetItemChildrenListRequest::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\GetItemChildrenListRequest::class, $request, null));
        
        $httpResponse = $this->_defaultClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetItemChildrenListResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->itemList = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\ItemList', 'json');
            }
        }
        else {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->serviceError = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\ServiceError', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Returns the details of an item with the specified id.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetItemDownloadablesRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\GetItemDownloadablesResponse
     */
	public function getItemDownloadables(
        \OpenAPI\OpenAPI\Models\Operations\GetItemDownloadablesRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\GetItemDownloadablesResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/itv/items/downloadable');
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "itemDownloadableRequest", "json");
        if ($body === null) {
            throw new \Exception('Request body is required');
        }
        $options = array_merge_recursive($options, $body);
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\GetItemDownloadablesRequest::class, $request, null));
        
        $httpResponse = $this->_defaultClient->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetItemDownloadablesResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->itemDownloadableList = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\ItemDownloadableList', 'json');
            }
        }
        else {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->serviceError = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\ServiceError', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Returns the list of items related to the parent item.
     * 
     * Note for now, due to the size of the list being unknown, only a single page will be returned.
     * 
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetItemRelatedListRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\GetItemRelatedListResponse
     */
	public function getItemRelatedList(
        \OpenAPI\OpenAPI\Models\Operations\GetItemRelatedListRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\GetItemRelatedListResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/items/{id}/related', \OpenAPI\OpenAPI\Models\Operations\GetItemRelatedListRequest::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\GetItemRelatedListRequest::class, $request, null));
        
        $httpResponse = $this->_defaultClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetItemRelatedListResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->itemList = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\ItemList', 'json');
            }
        }
        else {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->serviceError = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\ServiceError', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Get the media clip files associated with items.
     * 
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetItemsMediaClipFilesRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\GetItemsMediaClipFilesResponse
     */
	public function getItemsMediaClipFiles(
        \OpenAPI\OpenAPI\Models\Operations\GetItemsMediaClipFilesRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\GetItemsMediaClipFilesResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/itv/items/clips');
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "itemDownloadableRequest", "json");
        if ($body === null) {
            throw new \Exception('Request body is required');
        }
        $options = array_merge_recursive($options, $body);
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\GetItemsMediaClipFilesRequest::class, $request, null));
        
        $httpResponse = $this->_defaultClient->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetItemsMediaClipFilesResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->itemClipFilesList = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\ItemClipFilesList', 'json');
            }
        }
        else {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->serviceError = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\ServiceError', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Returns a list of items under the specified item list
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetListRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\GetListResponse
     */
	public function getList(
        \OpenAPI\OpenAPI\Models\Operations\GetListRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\GetListResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/lists/{id}', \OpenAPI\OpenAPI\Models\Operations\GetListRequest::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\GetListRequest::class, $request, null));
        
        $httpResponse = $this->_defaultClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetListResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->itemList = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\ItemList', 'json');
            }
        }
        else {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->serviceError = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\ServiceError', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Returns an array of item lists with their first page of content resolved.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetListsRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\GetListsResponse
     */
	public function getLists(
        \OpenAPI\OpenAPI\Models\Operations\GetListsRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\GetListsResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/lists');
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\GetListsRequest::class, $request, null));
        
        $httpResponse = $this->_defaultClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetListsResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->itemLists = $serializer->deserialize((string)$httpResponse->getBody(), 'array<OpenAPI\OpenAPI\Models\Shared\ItemList>', 'json');
            }
        }
        else {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->serviceError = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\ServiceError', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Get the free / public video files associated with an item given maximum resolution,
     * device type and one or more delivery types.
     * 
     * Returns an array of video file objects which each include a url to a video.
     * 
     * The first entry in the array contains what is predicted to be the best match.
     * The remainder of the entries, if any, may contain resolutions below what was
     * requests. For example if you request HD-720 the response may also contain
     * SD entries.
     * 
     * If you specify multiple delivery types, then the response array will insert
     * types in the order you specify them in the query. For example `stream,progressive`
     * would return an array with 0 or more stream files followed by 0 or more progressive files.
     * 
     * If no files are found a 404 is returned.
     * 
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetPublicItemMediaFilesRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\GetPublicItemMediaFilesResponse
     */
	public function getPublicItemMediaFiles(
        \OpenAPI\OpenAPI\Models\Operations\GetPublicItemMediaFilesRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\GetPublicItemMediaFilesResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/items/{id}/videos', \OpenAPI\OpenAPI\Models\Operations\GetPublicItemMediaFilesRequest::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\GetPublicItemMediaFilesRequest::class, $request, null));
        
        $httpResponse = $this->_defaultClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetPublicItemMediaFilesResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->mediaFiles = $serializer->deserialize((string)$httpResponse->getBody(), 'array<OpenAPI\OpenAPI\Models\Shared\MediaFile>', 'json');
            }
        }
        else {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->serviceError = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\ServiceError', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Returns schedules for a defined set of channels over a requested period.
     * 
     * Schedules are requested in hour blocks and returned grouped by the channel
     * they belong to.
     * 
     * For example, to load 12 hours of schedules for channels `4343` and `5234`,
     * on 21/2/2017 starting from 08:00.
     * 
     * ```
     * channels=4343,5234
     * date=2017-02-21
     * hour=8
     * duration=12
     * ```
     * 
     * Please remember that `date` and `hour` combined represent a normal datetime, 
     * so they should be converted to UTC on the client - this will help to avoid 
     * issues with EPG schedules near midnight.
     * 
     * If a channel id is passed which doesn't exist then this endpoint will
     * return an empty schedule list for it. If instead we returned 404,
     * this would invalidate all other channel schedules in the same request
     * which would be unfriendly for clients presenting these channel schedules.
     * 
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetSchedulesRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\GetSchedulesResponse
     */
	public function getSchedules(
        \OpenAPI\OpenAPI\Models\Operations\GetSchedulesRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\GetSchedulesResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/schedules');
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\GetSchedulesRequest::class, $request, null));
        
        $httpResponse = $this->_defaultClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetSchedulesResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->itemScheduleLists = $serializer->deserialize((string)$httpResponse->getBody(), 'array<OpenAPI\OpenAPI\Models\Shared\ItemScheduleList>', 'json');
            }
        }
        else {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->serviceError = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\ServiceError', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Returns the details of a Plan with the specified id.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetPlansIdRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\GetPlansIdResponse
     */
	public function getPlansId(
        \OpenAPI\OpenAPI\Models\Operations\GetPlansIdRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\GetPlansIdResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/plans/{id}', \OpenAPI\OpenAPI\Models\Operations\GetPlansIdRequest::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\GetPlansIdRequest::class, $request, null));
        
        $httpResponse = $this->_defaultClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetPlansIdResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->plan = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\Plan', 'json');
            }
        }
        else {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->serviceError = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\ServiceError', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Search the catalog of items and people.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\SearchRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\SearchResponse
     */
	public function search(
        \OpenAPI\OpenAPI\Models\Operations\SearchRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\SearchResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/search');
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\SearchRequest::class, $request, null));
        
        $httpResponse = $this->_defaultClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\SearchResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->searchResults = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\SearchResults', 'json');
            }
        }
        else {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->serviceError = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\ServiceError', 'json');
            }
        }

        return $response;
    }
}