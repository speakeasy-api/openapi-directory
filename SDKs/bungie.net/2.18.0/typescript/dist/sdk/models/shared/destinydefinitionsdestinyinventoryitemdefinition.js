"use strict";
/*
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.DestinyDefinitionsDestinyInventoryItemDefinition = exports.DestinyDefinitionsDestinyInventoryItemDefinitionValue = exports.DestinyDefinitionsDestinyInventoryItemDefinitionTranslationBlock = exports.DestinyDefinitionsDestinyInventoryItemDefinitionTalentGrid = exports.DestinyDefinitionsDestinyInventoryItemDefinitionSummary = exports.DestinyDefinitionsDestinyInventoryItemDefinitionStats = exports.DestinyDefinitionsDestinyInventoryItemDefinitionSourceData = exports.DestinyDefinitionsDestinyInventoryItemDefinitionSockets = exports.DestinyDefinitionsDestinyInventoryItemDefinitionSetData = exports.DestinyDefinitionsDestinyInventoryItemDefinitionSack = exports.DestinyDefinitionsDestinyInventoryItemDefinitionQuality = exports.DestinyDefinitionsDestinyInventoryItemDefinitionPreview = exports.DestinyDefinitionsDestinyInventoryItemDefinitionPlug = exports.DestinyDefinitionsDestinyInventoryItemDefinitionPlugParentItemOverride = exports.DestinyDefinitionsDestinyInventoryItemDefinitionPlugEnergyCost = exports.DestinyDefinitionsDestinyInventoryItemDefinitionPlugEnergyCapacity = exports.DestinyDefinitionsDestinyInventoryItemDefinitionObjectives = exports.DestinyDefinitionsDestinyInventoryItemDefinitionMetrics = exports.DestinyDefinitionsDestinyInventoryItemDefinitionInventory = exports.DestinyDefinitionsDestinyInventoryItemDefinitionGearset = exports.DestinyDefinitionsDestinyInventoryItemDefinitionEquippingBlock = exports.DestinyDefinitionsDestinyInventoryItemDefinitionCrafting = exports.DestinyDefinitionsDestinyInventoryItemDefinitionBackgroundColor = exports.DestinyDefinitionsDestinyInventoryItemDefinitionAction = void 0;
var utils_1 = require("../../../internal/utils");
var destinydefinitionsanimationsdestinyanimationreference_1 = require("./destinydefinitionsanimationsdestinyanimationreference");
var destinydefinitionscommondestinydisplaypropertiesdefinition_1 = require("./destinydefinitionscommondestinydisplaypropertiesdefinition");
var destinydefinitionsdestinygearartarrangementreference_1 = require("./destinydefinitionsdestinygearartarrangementreference");
var destinydefinitionsdestinyinventoryitemstatdefinition_1 = require("./destinydefinitionsdestinyinventoryitemstatdefinition");
var destinydefinitionsdestinyitemactionrequireditemdefinition_1 = require("./destinydefinitionsdestinyitemactionrequireditemdefinition");
var destinydefinitionsdestinyitemcraftingblockbonusplugdefinition_1 = require("./destinydefinitionsdestinyitemcraftingblockbonusplugdefinition");
var destinydefinitionsdestinyitemintrinsicsocketentrydefinition_1 = require("./destinydefinitionsdestinyitemintrinsicsocketentrydefinition");
var destinydefinitionsdestinyiteminvestmentstatdefinition_1 = require("./destinydefinitionsdestinyiteminvestmentstatdefinition");
var destinydefinitionsdestinyitemperkentrydefinition_1 = require("./destinydefinitionsdestinyitemperkentrydefinition");
var destinydefinitionsdestinyitemsetblockentrydefinition_1 = require("./destinydefinitionsdestinyitemsetblockentrydefinition");
var destinydefinitionsdestinyitemsocketcategorydefinition_1 = require("./destinydefinitionsdestinyitemsocketcategorydefinition");
var destinydefinitionsdestinyitemsocketentrydefinition_1 = require("./destinydefinitionsdestinyitemsocketentrydefinition");
var destinydefinitionsdestinyitemtooltipnotification_1 = require("./destinydefinitionsdestinyitemtooltipnotification");
var destinydefinitionsdestinyitemvendorsourcereference_1 = require("./destinydefinitionsdestinyitemvendorsourcereference");
var destinydefinitionsdestinyitemversiondefinition_1 = require("./destinydefinitionsdestinyitemversiondefinition");
var destinydefinitionsdestinyobjectivedisplayproperties_1 = require("./destinydefinitionsdestinyobjectivedisplayproperties");
var destinydefinitionsdestinyprogressionrewarddefinition_1 = require("./destinydefinitionsdestinyprogressionrewarddefinition");
var destinydefinitionsitemsdestinyderiveditemcategorydefinition_1 = require("./destinydefinitionsitemsdestinyderiveditemcategorydefinition");
var destinydefinitionsitemsdestinyplugruledefinition_1 = require("./destinydefinitionsitemsdestinyplugruledefinition");
var destinydefinitionssourcesdestinyitemsourcedefinition_1 = require("./destinydefinitionssourcesdestinyitemsourcedefinition");
var destinydestinyitemquantity_1 = require("./destinydestinyitemquantity");
var destinydyereference_1 = require("./destinydyereference");
var linkshyperlinkreference_1 = require("./linkshyperlinkreference");
/**
 * If an item can have an action performed on it (like "Dismantle"), it will be defined here if you care.
 */
var DestinyDefinitionsDestinyInventoryItemDefinitionAction = /** @class */ (function (_super) {
    __extends(DestinyDefinitionsDestinyInventoryItemDefinitionAction, _super);
    function DestinyDefinitionsDestinyInventoryItemDefinitionAction() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate([
        (0, utils_1.SpeakeasyMetadata)(),
        __metadata("design:type", String)
    ], DestinyDefinitionsDestinyInventoryItemDefinitionAction.prototype, "actionTypeLabel", void 0);
    __decorate([
        (0, utils_1.SpeakeasyMetadata)(),
        __metadata("design:type", Boolean)
    ], DestinyDefinitionsDestinyInventoryItemDefinitionAction.prototype, "consumeEntireStack", void 0);
    __decorate([
        (0, utils_1.SpeakeasyMetadata)(),
        __metadata("design:type", Boolean)
    ], DestinyDefinitionsDestinyInventoryItemDefinitionAction.prototype, "deleteOnAction", void 0);
    __decorate([
        (0, utils_1.SpeakeasyMetadata)(),
        __metadata("design:type", Boolean)
    ], DestinyDefinitionsDestinyInventoryItemDefinitionAction.prototype, "isPositive", void 0);
    __decorate([
        (0, utils_1.SpeakeasyMetadata)(),
        __metadata("design:type", String)
    ], DestinyDefinitionsDestinyInventoryItemDefinitionAction.prototype, "overlayIcon", void 0);
    __decorate([
        (0, utils_1.SpeakeasyMetadata)(),
        __metadata("design:type", String)
    ], DestinyDefinitionsDestinyInventoryItemDefinitionAction.prototype, "overlayScreenName", void 0);
    __decorate([
        (0, utils_1.SpeakeasyMetadata)({
            elemType: destinydefinitionsdestinyprogressionrewarddefinition_1.DestinyDefinitionsDestinyProgressionRewardDefinition,
        }),
        __metadata("design:type", Array)
    ], DestinyDefinitionsDestinyInventoryItemDefinitionAction.prototype, "progressionRewards", void 0);
    __decorate([
        (0, utils_1.SpeakeasyMetadata)(),
        __metadata("design:type", Number)
    ], DestinyDefinitionsDestinyInventoryItemDefinitionAction.prototype, "requiredCooldownHash", void 0);
    __decorate([
        (0, utils_1.SpeakeasyMetadata)(),
        __metadata("design:type", Number)
    ], DestinyDefinitionsDestinyInventoryItemDefinitionAction.prototype, "requiredCooldownSeconds", void 0);
    __decorate([
        (0, utils_1.SpeakeasyMetadata)({
            elemType: destinydefinitionsdestinyitemactionrequireditemdefinition_1.DestinyDefinitionsDestinyItemActionRequiredItemDefinition,
        }),
        __metadata("design:type", Array)
    ], DestinyDefinitionsDestinyInventoryItemDefinitionAction.prototype, "requiredItems", void 0);
    __decorate([
        (0, utils_1.SpeakeasyMetadata)(),
        __metadata("design:type", String)
    ], DestinyDefinitionsDestinyInventoryItemDefinitionAction.prototype, "requiredLocation", void 0);
    __decorate([
        (0, utils_1.SpeakeasyMetadata)(),
        __metadata("design:type", Boolean)
    ], DestinyDefinitionsDestinyInventoryItemDefinitionAction.prototype, "useOnAcquire", void 0);
    __decorate([
        (0, utils_1.SpeakeasyMetadata)(),
        __metadata("design:type", String)
    ], DestinyDefinitionsDestinyInventoryItemDefinitionAction.prototype, "verbDescription", void 0);
    __decorate([
        (0, utils_1.SpeakeasyMetadata)(),
        __metadata("design:type", String)
    ], DestinyDefinitionsDestinyInventoryItemDefinitionAction.prototype, "verbName", void 0);
    return DestinyDefinitionsDestinyInventoryItemDefinitionAction;
}(utils_1.SpeakeasyBase));
exports.DestinyDefinitionsDestinyInventoryItemDefinitionAction = DestinyDefinitionsDestinyInventoryItemDefinitionAction;
/**
 * Represents a color whose RGBA values are all represented as values between 0 and 255.
 */
var DestinyDefinitionsDestinyInventoryItemDefinitionBackgroundColor = /** @class */ (function (_super) {
    __extends(DestinyDefinitionsDestinyInventoryItemDefinitionBackgroundColor, _super);
    function DestinyDefinitionsDestinyInventoryItemDefinitionBackgroundColor() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate([
        (0, utils_1.SpeakeasyMetadata)(),
        __metadata("design:type", String)
    ], DestinyDefinitionsDestinyInventoryItemDefinitionBackgroundColor.prototype, "alpha", void 0);
    __decorate([
        (0, utils_1.SpeakeasyMetadata)(),
        __metadata("design:type", String)
    ], DestinyDefinitionsDestinyInventoryItemDefinitionBackgroundColor.prototype, "blue", void 0);
    __decorate([
        (0, utils_1.SpeakeasyMetadata)(),
        __metadata("design:type", String)
    ], DestinyDefinitionsDestinyInventoryItemDefinitionBackgroundColor.prototype, "green", void 0);
    __decorate([
        (0, utils_1.SpeakeasyMetadata)(),
        __metadata("design:type", String)
    ], DestinyDefinitionsDestinyInventoryItemDefinitionBackgroundColor.prototype, "red", void 0);
    return DestinyDefinitionsDestinyInventoryItemDefinitionBackgroundColor;
}(utils_1.SpeakeasyBase));
exports.DestinyDefinitionsDestinyInventoryItemDefinitionBackgroundColor = DestinyDefinitionsDestinyInventoryItemDefinitionBackgroundColor;
/**
 * If an item can have an action performed on it (like "Dismantle"), it will be defined here if you care.
 */
var DestinyDefinitionsDestinyInventoryItemDefinitionCrafting = /** @class */ (function (_super) {
    __extends(DestinyDefinitionsDestinyInventoryItemDefinitionCrafting, _super);
    function DestinyDefinitionsDestinyInventoryItemDefinitionCrafting() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate([
        (0, utils_1.SpeakeasyMetadata)(),
        __metadata("design:type", Number)
    ], DestinyDefinitionsDestinyInventoryItemDefinitionCrafting.prototype, "baseMaterialRequirements", void 0);
    __decorate([
        (0, utils_1.SpeakeasyMetadata)({
            elemType: destinydefinitionsdestinyitemcraftingblockbonusplugdefinition_1.DestinyDefinitionsDestinyItemCraftingBlockBonusPlugDefinition,
        }),
        __metadata("design:type", Array)
    ], DestinyDefinitionsDestinyInventoryItemDefinitionCrafting.prototype, "bonusPlugs", void 0);
    __decorate([
        (0, utils_1.SpeakeasyMetadata)(),
        __metadata("design:type", Array)
    ], DestinyDefinitionsDestinyInventoryItemDefinitionCrafting.prototype, "failedRequirementStrings", void 0);
    __decorate([
        (0, utils_1.SpeakeasyMetadata)(),
        __metadata("design:type", Number)
    ], DestinyDefinitionsDestinyInventoryItemDefinitionCrafting.prototype, "outputItemHash", void 0);
    __decorate([
        (0, utils_1.SpeakeasyMetadata)(),
        __metadata("design:type", Array)
    ], DestinyDefinitionsDestinyInventoryItemDefinitionCrafting.prototype, "requiredSocketTypeHashes", void 0);
    return DestinyDefinitionsDestinyInventoryItemDefinitionCrafting;
}(utils_1.SpeakeasyBase));
exports.DestinyDefinitionsDestinyInventoryItemDefinitionCrafting = DestinyDefinitionsDestinyInventoryItemDefinitionCrafting;
/**
 * Items that can be equipped define this block. It contains information we need to understand how and when the item can be equipped.
 */
var DestinyDefinitionsDestinyInventoryItemDefinitionEquippingBlock = /** @class */ (function (_super) {
    __extends(DestinyDefinitionsDestinyInventoryItemDefinitionEquippingBlock, _super);
    function DestinyDefinitionsDestinyInventoryItemDefinitionEquippingBlock() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate([
        (0, utils_1.SpeakeasyMetadata)(),
        __metadata("design:type", Number)
    ], DestinyDefinitionsDestinyInventoryItemDefinitionEquippingBlock.prototype, "ammoType", void 0);
    __decorate([
        (0, utils_1.SpeakeasyMetadata)(),
        __metadata("design:type", Number)
    ], DestinyDefinitionsDestinyInventoryItemDefinitionEquippingBlock.prototype, "attributes", void 0);
    __decorate([
        (0, utils_1.SpeakeasyMetadata)(),
        __metadata("design:type", Array)
    ], DestinyDefinitionsDestinyInventoryItemDefinitionEquippingBlock.prototype, "displayStrings", void 0);
    __decorate([
        (0, utils_1.SpeakeasyMetadata)(),
        __metadata("design:type", Number)
    ], DestinyDefinitionsDestinyInventoryItemDefinitionEquippingBlock.prototype, "equipmentSlotTypeHash", void 0);
    __decorate([
        (0, utils_1.SpeakeasyMetadata)(),
        __metadata("design:type", Number)
    ], DestinyDefinitionsDestinyInventoryItemDefinitionEquippingBlock.prototype, "gearsetItemHash", void 0);
    __decorate([
        (0, utils_1.SpeakeasyMetadata)(),
        __metadata("design:type", String)
    ], DestinyDefinitionsDestinyInventoryItemDefinitionEquippingBlock.prototype, "uniqueLabel", void 0);
    __decorate([
        (0, utils_1.SpeakeasyMetadata)(),
        __metadata("design:type", Number)
    ], DestinyDefinitionsDestinyInventoryItemDefinitionEquippingBlock.prototype, "uniqueLabelHash", void 0);
    return DestinyDefinitionsDestinyInventoryItemDefinitionEquippingBlock;
}(utils_1.SpeakeasyBase));
exports.DestinyDefinitionsDestinyInventoryItemDefinitionEquippingBlock = DestinyDefinitionsDestinyInventoryItemDefinitionEquippingBlock;
/**
 * If an item has a related gearset, this is the list of items in that set, and an unlock expression that evaluates to a number representing the progress toward gearset completion (a very rare use for unlock expressions!)
 */
var DestinyDefinitionsDestinyInventoryItemDefinitionGearset = /** @class */ (function (_super) {
    __extends(DestinyDefinitionsDestinyInventoryItemDefinitionGearset, _super);
    function DestinyDefinitionsDestinyInventoryItemDefinitionGearset() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate([
        (0, utils_1.SpeakeasyMetadata)(),
        __metadata("design:type", Array)
    ], DestinyDefinitionsDestinyInventoryItemDefinitionGearset.prototype, "itemList", void 0);
    __decorate([
        (0, utils_1.SpeakeasyMetadata)(),
        __metadata("design:type", Number)
    ], DestinyDefinitionsDestinyInventoryItemDefinitionGearset.prototype, "trackingValueMax", void 0);
    return DestinyDefinitionsDestinyInventoryItemDefinitionGearset;
}(utils_1.SpeakeasyBase));
exports.DestinyDefinitionsDestinyInventoryItemDefinitionGearset = DestinyDefinitionsDestinyInventoryItemDefinitionGearset;
/**
 * If the item can exist in an inventory - the overwhelming majority of them can and do - then this is the basic properties regarding the item's relationship with the inventory.
 */
var DestinyDefinitionsDestinyInventoryItemDefinitionInventory = /** @class */ (function (_super) {
    __extends(DestinyDefinitionsDestinyInventoryItemDefinitionInventory, _super);
    function DestinyDefinitionsDestinyInventoryItemDefinitionInventory() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate([
        (0, utils_1.SpeakeasyMetadata)(),
        __metadata("design:type", Number)
    ], DestinyDefinitionsDestinyInventoryItemDefinitionInventory.prototype, "bucketTypeHash", void 0);
    __decorate([
        (0, utils_1.SpeakeasyMetadata)(),
        __metadata("design:type", String)
    ], DestinyDefinitionsDestinyInventoryItemDefinitionInventory.prototype, "expirationTooltip", void 0);
    __decorate([
        (0, utils_1.SpeakeasyMetadata)(),
        __metadata("design:type", String)
    ], DestinyDefinitionsDestinyInventoryItemDefinitionInventory.prototype, "expiredInActivityMessage", void 0);
    __decorate([
        (0, utils_1.SpeakeasyMetadata)(),
        __metadata("design:type", String)
    ], DestinyDefinitionsDestinyInventoryItemDefinitionInventory.prototype, "expiredInOrbitMessage", void 0);
    __decorate([
        (0, utils_1.SpeakeasyMetadata)(),
        __metadata("design:type", Boolean)
    ], DestinyDefinitionsDestinyInventoryItemDefinitionInventory.prototype, "isInstanceItem", void 0);
    __decorate([
        (0, utils_1.SpeakeasyMetadata)(),
        __metadata("design:type", Number)
    ], DestinyDefinitionsDestinyInventoryItemDefinitionInventory.prototype, "maxStackSize", void 0);
    __decorate([
        (0, utils_1.SpeakeasyMetadata)(),
        __metadata("design:type", Number)
    ], DestinyDefinitionsDestinyInventoryItemDefinitionInventory.prototype, "recipeItemHash", void 0);
    __decorate([
        (0, utils_1.SpeakeasyMetadata)(),
        __metadata("design:type", Number)
    ], DestinyDefinitionsDestinyInventoryItemDefinitionInventory.prototype, "recoveryBucketTypeHash", void 0);
    __decorate([
        (0, utils_1.SpeakeasyMetadata)(),
        __metadata("design:type", String)
    ], DestinyDefinitionsDestinyInventoryItemDefinitionInventory.prototype, "stackUniqueLabel", void 0);
    __decorate([
        (0, utils_1.SpeakeasyMetadata)(),
        __metadata("design:type", Boolean)
    ], DestinyDefinitionsDestinyInventoryItemDefinitionInventory.prototype, "suppressExpirationWhenObjectivesComplete", void 0);
    __decorate([
        (0, utils_1.SpeakeasyMetadata)(),
        __metadata("design:type", Number)
    ], DestinyDefinitionsDestinyInventoryItemDefinitionInventory.prototype, "tierType", void 0);
    __decorate([
        (0, utils_1.SpeakeasyMetadata)(),
        __metadata("design:type", Number)
    ], DestinyDefinitionsDestinyInventoryItemDefinitionInventory.prototype, "tierTypeHash", void 0);
    __decorate([
        (0, utils_1.SpeakeasyMetadata)(),
        __metadata("design:type", String)
    ], DestinyDefinitionsDestinyInventoryItemDefinitionInventory.prototype, "tierTypeName", void 0);
    return DestinyDefinitionsDestinyInventoryItemDefinitionInventory;
}(utils_1.SpeakeasyBase));
exports.DestinyDefinitionsDestinyInventoryItemDefinitionInventory = DestinyDefinitionsDestinyInventoryItemDefinitionInventory;
/**
 * The metrics available for display and selection on an item.
 */
var DestinyDefinitionsDestinyInventoryItemDefinitionMetrics = /** @class */ (function (_super) {
    __extends(DestinyDefinitionsDestinyInventoryItemDefinitionMetrics, _super);
    function DestinyDefinitionsDestinyInventoryItemDefinitionMetrics() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate([
        (0, utils_1.SpeakeasyMetadata)(),
        __metadata("design:type", Array)
    ], DestinyDefinitionsDestinyInventoryItemDefinitionMetrics.prototype, "availableMetricCategoryNodeHashes", void 0);
    return DestinyDefinitionsDestinyInventoryItemDefinitionMetrics;
}(utils_1.SpeakeasyBase));
exports.DestinyDefinitionsDestinyInventoryItemDefinitionMetrics = DestinyDefinitionsDestinyInventoryItemDefinitionMetrics;
/**
 * An item can have objectives on it. In practice, these are the exclusive purview of "Quest Step" items: DestinyInventoryItemDefinitions that represent a specific step in a Quest.
 *
 * @remarks
 * Quest steps have 1:M objectives that we end up processing and returning in live data as DestinyQuestStatus data, and other useful information.
 */
var DestinyDefinitionsDestinyInventoryItemDefinitionObjectives = /** @class */ (function (_super) {
    __extends(DestinyDefinitionsDestinyInventoryItemDefinitionObjectives, _super);
    function DestinyDefinitionsDestinyInventoryItemDefinitionObjectives() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate([
        (0, utils_1.SpeakeasyMetadata)(),
        __metadata("design:type", Array)
    ], DestinyDefinitionsDestinyInventoryItemDefinitionObjectives.prototype, "displayActivityHashes", void 0);
    __decorate([
        (0, utils_1.SpeakeasyMetadata)(),
        __metadata("design:type", Boolean)
    ], DestinyDefinitionsDestinyInventoryItemDefinitionObjectives.prototype, "displayAsStatTracker", void 0);
    __decorate([
        (0, utils_1.SpeakeasyMetadata)(),
        __metadata("design:type", String)
    ], DestinyDefinitionsDestinyInventoryItemDefinitionObjectives.prototype, "narrative", void 0);
    __decorate([
        (0, utils_1.SpeakeasyMetadata)(),
        __metadata("design:type", Array)
    ], DestinyDefinitionsDestinyInventoryItemDefinitionObjectives.prototype, "objectiveHashes", void 0);
    __decorate([
        (0, utils_1.SpeakeasyMetadata)(),
        __metadata("design:type", String)
    ], DestinyDefinitionsDestinyInventoryItemDefinitionObjectives.prototype, "objectiveVerbName", void 0);
    __decorate([
        (0, utils_1.SpeakeasyMetadata)({
            elemType: destinydefinitionsdestinyobjectivedisplayproperties_1.DestinyDefinitionsDestinyObjectiveDisplayProperties,
        }),
        __metadata("design:type", Array)
    ], DestinyDefinitionsDestinyInventoryItemDefinitionObjectives.prototype, "perObjectiveDisplayProperties", void 0);
    __decorate([
        (0, utils_1.SpeakeasyMetadata)(),
        __metadata("design:type", Number)
    ], DestinyDefinitionsDestinyInventoryItemDefinitionObjectives.prototype, "questTypeHash", void 0);
    __decorate([
        (0, utils_1.SpeakeasyMetadata)(),
        __metadata("design:type", String)
    ], DestinyDefinitionsDestinyInventoryItemDefinitionObjectives.prototype, "questTypeIdentifier", void 0);
    __decorate([
        (0, utils_1.SpeakeasyMetadata)(),
        __metadata("design:type", Number)
    ], DestinyDefinitionsDestinyInventoryItemDefinitionObjectives.prototype, "questlineItemHash", void 0);
    __decorate([
        (0, utils_1.SpeakeasyMetadata)(),
        __metadata("design:type", Boolean)
    ], DestinyDefinitionsDestinyInventoryItemDefinitionObjectives.prototype, "requireFullObjectiveCompletion", void 0);
    return DestinyDefinitionsDestinyInventoryItemDefinitionObjectives;
}(utils_1.SpeakeasyBase));
exports.DestinyDefinitionsDestinyInventoryItemDefinitionObjectives = DestinyDefinitionsDestinyInventoryItemDefinitionObjectives;
/**
 * Items can have Energy Capacity, and plugs can provide that capacity such as on a piece of Armor in Armor 2.0. This is how much "Energy" can be spent on activating plugs for this item.
 */
var DestinyDefinitionsDestinyInventoryItemDefinitionPlugEnergyCapacity = /** @class */ (function (_super) {
    __extends(DestinyDefinitionsDestinyInventoryItemDefinitionPlugEnergyCapacity, _super);
    function DestinyDefinitionsDestinyInventoryItemDefinitionPlugEnergyCapacity() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate([
        (0, utils_1.SpeakeasyMetadata)(),
        __metadata("design:type", Number)
    ], DestinyDefinitionsDestinyInventoryItemDefinitionPlugEnergyCapacity.prototype, "capacityValue", void 0);
    __decorate([
        (0, utils_1.SpeakeasyMetadata)(),
        __metadata("design:type", Number)
    ], DestinyDefinitionsDestinyInventoryItemDefinitionPlugEnergyCapacity.prototype, "energyType", void 0);
    __decorate([
        (0, utils_1.SpeakeasyMetadata)(),
        __metadata("design:type", Number)
    ], DestinyDefinitionsDestinyInventoryItemDefinitionPlugEnergyCapacity.prototype, "energyTypeHash", void 0);
    return DestinyDefinitionsDestinyInventoryItemDefinitionPlugEnergyCapacity;
}(utils_1.SpeakeasyBase));
exports.DestinyDefinitionsDestinyInventoryItemDefinitionPlugEnergyCapacity = DestinyDefinitionsDestinyInventoryItemDefinitionPlugEnergyCapacity;
/**
 * Some plugs cost Energy, which is a stat on the item that can be increased by other plugs (that, at least in Armor 2.0, have a "masterworks-like" mechanic for upgrading). If a plug has costs, the details of that cost are defined here.
 */
var DestinyDefinitionsDestinyInventoryItemDefinitionPlugEnergyCost = /** @class */ (function (_super) {
    __extends(DestinyDefinitionsDestinyInventoryItemDefinitionPlugEnergyCost, _super);
    function DestinyDefinitionsDestinyInventoryItemDefinitionPlugEnergyCost() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate([
        (0, utils_1.SpeakeasyMetadata)(),
        __metadata("design:type", Number)
    ], DestinyDefinitionsDestinyInventoryItemDefinitionPlugEnergyCost.prototype, "energyCost", void 0);
    __decorate([
        (0, utils_1.SpeakeasyMetadata)(),
        __metadata("design:type", Number)
    ], DestinyDefinitionsDestinyInventoryItemDefinitionPlugEnergyCost.prototype, "energyType", void 0);
    __decorate([
        (0, utils_1.SpeakeasyMetadata)(),
        __metadata("design:type", Number)
    ], DestinyDefinitionsDestinyInventoryItemDefinitionPlugEnergyCost.prototype, "energyTypeHash", void 0);
    return DestinyDefinitionsDestinyInventoryItemDefinitionPlugEnergyCost;
}(utils_1.SpeakeasyBase));
exports.DestinyDefinitionsDestinyInventoryItemDefinitionPlugEnergyCost = DestinyDefinitionsDestinyInventoryItemDefinitionPlugEnergyCost;
/**
 * Do you ever get the feeling that a system has become so overburdened by edge cases that it probably should have become some other system entirely? So do I!
 *
 * @remarks
 * In totally unrelated news, Plugs can now override properties of their parent items. This is some of the relevant definition data for those overrides.
 * If this is populated, it will have the override data to be applied when this plug is applied to an item.
 */
var DestinyDefinitionsDestinyInventoryItemDefinitionPlugParentItemOverride = /** @class */ (function (_super) {
    __extends(DestinyDefinitionsDestinyInventoryItemDefinitionPlugParentItemOverride, _super);
    function DestinyDefinitionsDestinyInventoryItemDefinitionPlugParentItemOverride() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate([
        (0, utils_1.SpeakeasyMetadata)(),
        __metadata("design:type", Array)
    ], DestinyDefinitionsDestinyInventoryItemDefinitionPlugParentItemOverride.prototype, "additionalEquipRequirementsDisplayStrings", void 0);
    __decorate([
        (0, utils_1.SpeakeasyMetadata)(),
        __metadata("design:type", String)
    ], DestinyDefinitionsDestinyInventoryItemDefinitionPlugParentItemOverride.prototype, "pipIcon", void 0);
    return DestinyDefinitionsDestinyInventoryItemDefinitionPlugParentItemOverride;
}(utils_1.SpeakeasyBase));
exports.DestinyDefinitionsDestinyInventoryItemDefinitionPlugParentItemOverride = DestinyDefinitionsDestinyInventoryItemDefinitionPlugParentItemOverride;
/**
 * If an item is a Plug, its DestinyInventoryItemDefinition.plug property will be populated with an instance of one of these bad boys.
 *
 * @remarks
 * This gives information about when it can be inserted, what the plug's category is (and thus whether it is compatible with a socket... see DestinySocketTypeDefinition for information about Plug Categories and socket compatibility), whether it is enabled and other Plug info.
 */
var DestinyDefinitionsDestinyInventoryItemDefinitionPlug = /** @class */ (function (_super) {
    __extends(DestinyDefinitionsDestinyInventoryItemDefinitionPlug, _super);
    function DestinyDefinitionsDestinyInventoryItemDefinitionPlug() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate([
        (0, utils_1.SpeakeasyMetadata)(),
        __metadata("design:type", Number)
    ], DestinyDefinitionsDestinyInventoryItemDefinitionPlug.prototype, "alternatePlugStyle", void 0);
    __decorate([
        (0, utils_1.SpeakeasyMetadata)(),
        __metadata("design:type", String)
    ], DestinyDefinitionsDestinyInventoryItemDefinitionPlug.prototype, "alternateUiPlugLabel", void 0);
    __decorate([
        (0, utils_1.SpeakeasyMetadata)(),
        __metadata("design:type", Number)
    ], DestinyDefinitionsDestinyInventoryItemDefinitionPlug.prototype, "enabledMaterialRequirementHash", void 0);
    __decorate([
        (0, utils_1.SpeakeasyMetadata)({
            elemType: destinydefinitionsitemsdestinyplugruledefinition_1.DestinyDefinitionsItemsDestinyPlugRuleDefinition,
        }),
        __metadata("design:type", Array)
    ], DestinyDefinitionsDestinyInventoryItemDefinitionPlug.prototype, "enabledRules", void 0);
    __decorate([
        (0, utils_1.SpeakeasyMetadata)(),
        __metadata("design:type", DestinyDefinitionsDestinyInventoryItemDefinitionPlugEnergyCapacity)
    ], DestinyDefinitionsDestinyInventoryItemDefinitionPlug.prototype, "energyCapacity", void 0);
    __decorate([
        (0, utils_1.SpeakeasyMetadata)(),
        __metadata("design:type", DestinyDefinitionsDestinyInventoryItemDefinitionPlugEnergyCost)
    ], DestinyDefinitionsDestinyInventoryItemDefinitionPlug.prototype, "energyCost", void 0);
    __decorate([
        (0, utils_1.SpeakeasyMetadata)(),
        __metadata("design:type", Number)
    ], DestinyDefinitionsDestinyInventoryItemDefinitionPlug.prototype, "insertionMaterialRequirementHash", void 0);
    __decorate([
        (0, utils_1.SpeakeasyMetadata)({
            elemType: destinydefinitionsitemsdestinyplugruledefinition_1.DestinyDefinitionsItemsDestinyPlugRuleDefinition,
        }),
        __metadata("design:type", Array)
    ], DestinyDefinitionsDestinyInventoryItemDefinitionPlug.prototype, "insertionRules", void 0);
    __decorate([
        (0, utils_1.SpeakeasyMetadata)(),
        __metadata("design:type", Boolean)
    ], DestinyDefinitionsDestinyInventoryItemDefinitionPlug.prototype, "isDummyPlug", void 0);
    __decorate([
        (0, utils_1.SpeakeasyMetadata)(),
        __metadata("design:type", Boolean)
    ], DestinyDefinitionsDestinyInventoryItemDefinitionPlug.prototype, "onActionRecreateSelf", void 0);
    __decorate([
        (0, utils_1.SpeakeasyMetadata)(),
        __metadata("design:type", DestinyDefinitionsDestinyInventoryItemDefinitionPlugParentItemOverride)
    ], DestinyDefinitionsDestinyInventoryItemDefinitionPlug.prototype, "parentItemOverride", void 0);
    __decorate([
        (0, utils_1.SpeakeasyMetadata)(),
        __metadata("design:type", Number)
    ], DestinyDefinitionsDestinyInventoryItemDefinitionPlug.prototype, "plugAvailability", void 0);
    __decorate([
        (0, utils_1.SpeakeasyMetadata)(),
        __metadata("design:type", Number)
    ], DestinyDefinitionsDestinyInventoryItemDefinitionPlug.prototype, "plugCategoryHash", void 0);
    __decorate([
        (0, utils_1.SpeakeasyMetadata)(),
        __metadata("design:type", String)
    ], DestinyDefinitionsDestinyInventoryItemDefinitionPlug.prototype, "plugCategoryIdentifier", void 0);
    __decorate([
        (0, utils_1.SpeakeasyMetadata)(),
        __metadata("design:type", Number)
    ], DestinyDefinitionsDestinyInventoryItemDefinitionPlug.prototype, "plugStyle", void 0);
    __decorate([
        (0, utils_1.SpeakeasyMetadata)(),
        __metadata("design:type", Number)
    ], DestinyDefinitionsDestinyInventoryItemDefinitionPlug.prototype, "previewItemOverrideHash", void 0);
    __decorate([
        (0, utils_1.SpeakeasyMetadata)(),
        __metadata("design:type", String)
    ], DestinyDefinitionsDestinyInventoryItemDefinitionPlug.prototype, "uiPlugLabel", void 0);
    return DestinyDefinitionsDestinyInventoryItemDefinitionPlug;
}(utils_1.SpeakeasyBase));
exports.DestinyDefinitionsDestinyInventoryItemDefinitionPlug = DestinyDefinitionsDestinyInventoryItemDefinitionPlug;
/**
 * Items like Sacks or Boxes can have items that it shows in-game when you view details that represent the items you can obtain if you use or acquire the item.
 *
 * @remarks
 * This defines those categories, and gives some insights into that data's source.
 */
var DestinyDefinitionsDestinyInventoryItemDefinitionPreview = /** @class */ (function (_super) {
    __extends(DestinyDefinitionsDestinyInventoryItemDefinitionPreview, _super);
    function DestinyDefinitionsDestinyInventoryItemDefinitionPreview() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate([
        (0, utils_1.SpeakeasyMetadata)(),
        __metadata("design:type", Number)
    ], DestinyDefinitionsDestinyInventoryItemDefinitionPreview.prototype, "artifactHash", void 0);
    __decorate([
        (0, utils_1.SpeakeasyMetadata)({
            elemType: destinydefinitionsitemsdestinyderiveditemcategorydefinition_1.DestinyDefinitionsItemsDestinyDerivedItemCategoryDefinition,
        }),
        __metadata("design:type", Array)
    ], DestinyDefinitionsDestinyInventoryItemDefinitionPreview.prototype, "derivedItemCategories", void 0);
    __decorate([
        (0, utils_1.SpeakeasyMetadata)(),
        __metadata("design:type", String)
    ], DestinyDefinitionsDestinyInventoryItemDefinitionPreview.prototype, "previewActionString", void 0);
    __decorate([
        (0, utils_1.SpeakeasyMetadata)(),
        __metadata("design:type", Number)
    ], DestinyDefinitionsDestinyInventoryItemDefinitionPreview.prototype, "previewVendorHash", void 0);
    __decorate([
        (0, utils_1.SpeakeasyMetadata)(),
        __metadata("design:type", String)
    ], DestinyDefinitionsDestinyInventoryItemDefinitionPreview.prototype, "screenStyle", void 0);
    return DestinyDefinitionsDestinyInventoryItemDefinitionPreview;
}(utils_1.SpeakeasyBase));
exports.DestinyDefinitionsDestinyInventoryItemDefinitionPreview = DestinyDefinitionsDestinyInventoryItemDefinitionPreview;
/**
 * An item's "Quality" determines its calculated stats. The Level at which the item spawns is combined with its "qualityLevel" along with some additional calculations to determine the value of those stats.
 *
 * @remarks
 * In Destiny 2, most items don't have default item levels and quality, making this property less useful: these apparently are almost always determined by the complex mechanisms of the Reward system rather than statically. They are still provided here in case they are still useful for people. This also contains some information about Infusion.
 */
var DestinyDefinitionsDestinyInventoryItemDefinitionQuality = /** @class */ (function (_super) {
    __extends(DestinyDefinitionsDestinyInventoryItemDefinitionQuality, _super);
    function DestinyDefinitionsDestinyInventoryItemDefinitionQuality() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate([
        (0, utils_1.SpeakeasyMetadata)(),
        __metadata("design:type", Number)
    ], DestinyDefinitionsDestinyInventoryItemDefinitionQuality.prototype, "currentVersion", void 0);
    __decorate([
        (0, utils_1.SpeakeasyMetadata)(),
        __metadata("design:type", Array)
    ], DestinyDefinitionsDestinyInventoryItemDefinitionQuality.prototype, "displayVersionWatermarkIcons", void 0);
    __decorate([
        (0, utils_1.SpeakeasyMetadata)(),
        __metadata("design:type", Number)
    ], DestinyDefinitionsDestinyInventoryItemDefinitionQuality.prototype, "infusionCategoryHash", void 0);
    __decorate([
        (0, utils_1.SpeakeasyMetadata)(),
        __metadata("design:type", Array)
    ], DestinyDefinitionsDestinyInventoryItemDefinitionQuality.prototype, "infusionCategoryHashes", void 0);
    __decorate([
        (0, utils_1.SpeakeasyMetadata)(),
        __metadata("design:type", String)
    ], DestinyDefinitionsDestinyInventoryItemDefinitionQuality.prototype, "infusionCategoryName", void 0);
    __decorate([
        (0, utils_1.SpeakeasyMetadata)(),
        __metadata("design:type", Array)
    ], DestinyDefinitionsDestinyInventoryItemDefinitionQuality.prototype, "itemLevels", void 0);
    __decorate([
        (0, utils_1.SpeakeasyMetadata)(),
        __metadata("design:type", Number)
    ], DestinyDefinitionsDestinyInventoryItemDefinitionQuality.prototype, "progressionLevelRequirementHash", void 0);
    __decorate([
        (0, utils_1.SpeakeasyMetadata)(),
        __metadata("design:type", Number)
    ], DestinyDefinitionsDestinyInventoryItemDefinitionQuality.prototype, "qualityLevel", void 0);
    __decorate([
        (0, utils_1.SpeakeasyMetadata)({
            elemType: destinydefinitionsdestinyitemversiondefinition_1.DestinyDefinitionsDestinyItemVersionDefinition,
        }),
        __metadata("design:type", Array)
    ], DestinyDefinitionsDestinyInventoryItemDefinitionQuality.prototype, "versions", void 0);
    return DestinyDefinitionsDestinyInventoryItemDefinitionQuality;
}(utils_1.SpeakeasyBase));
exports.DestinyDefinitionsDestinyInventoryItemDefinitionQuality = DestinyDefinitionsDestinyInventoryItemDefinitionQuality;
/**
 * Some items are "sacks" - they can be "opened" to produce other items. This is information related to its sack status, mostly UI strings. Engrams are an example of items that are considered to be "Sacks".
 */
var DestinyDefinitionsDestinyInventoryItemDefinitionSack = /** @class */ (function (_super) {
    __extends(DestinyDefinitionsDestinyInventoryItemDefinitionSack, _super);
    function DestinyDefinitionsDestinyInventoryItemDefinitionSack() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate([
        (0, utils_1.SpeakeasyMetadata)(),
        __metadata("design:type", String)
    ], DestinyDefinitionsDestinyInventoryItemDefinitionSack.prototype, "detailAction", void 0);
    __decorate([
        (0, utils_1.SpeakeasyMetadata)(),
        __metadata("design:type", String)
    ], DestinyDefinitionsDestinyInventoryItemDefinitionSack.prototype, "openAction", void 0);
    __decorate([
        (0, utils_1.SpeakeasyMetadata)(),
        __metadata("design:type", Boolean)
    ], DestinyDefinitionsDestinyInventoryItemDefinitionSack.prototype, "openOnAcquire", void 0);
    __decorate([
        (0, utils_1.SpeakeasyMetadata)(),
        __metadata("design:type", Number)
    ], DestinyDefinitionsDestinyInventoryItemDefinitionSack.prototype, "selectItemCount", void 0);
    __decorate([
        (0, utils_1.SpeakeasyMetadata)(),
        __metadata("design:type", String)
    ], DestinyDefinitionsDestinyInventoryItemDefinitionSack.prototype, "vendorSackType", void 0);
    return DestinyDefinitionsDestinyInventoryItemDefinitionSack;
}(utils_1.SpeakeasyBase));
exports.DestinyDefinitionsDestinyInventoryItemDefinitionSack = DestinyDefinitionsDestinyInventoryItemDefinitionSack;
/**
 * Primarily for Quests, this is the definition of properties related to the item if it is a quest and its various quest steps.
 */
var DestinyDefinitionsDestinyInventoryItemDefinitionSetData = /** @class */ (function (_super) {
    __extends(DestinyDefinitionsDestinyInventoryItemDefinitionSetData, _super);
    function DestinyDefinitionsDestinyInventoryItemDefinitionSetData() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate([
        (0, utils_1.SpeakeasyMetadata)({
            elemType: destinydefinitionsdestinyitemsetblockentrydefinition_1.DestinyDefinitionsDestinyItemSetBlockEntryDefinition,
        }),
        __metadata("design:type", Array)
    ], DestinyDefinitionsDestinyInventoryItemDefinitionSetData.prototype, "itemList", void 0);
    __decorate([
        (0, utils_1.SpeakeasyMetadata)(),
        __metadata("design:type", String)
    ], DestinyDefinitionsDestinyInventoryItemDefinitionSetData.prototype, "questLineDescription", void 0);
    __decorate([
        (0, utils_1.SpeakeasyMetadata)(),
        __metadata("design:type", String)
    ], DestinyDefinitionsDestinyInventoryItemDefinitionSetData.prototype, "questLineName", void 0);
    __decorate([
        (0, utils_1.SpeakeasyMetadata)(),
        __metadata("design:type", String)
    ], DestinyDefinitionsDestinyInventoryItemDefinitionSetData.prototype, "questStepSummary", void 0);
    __decorate([
        (0, utils_1.SpeakeasyMetadata)(),
        __metadata("design:type", Boolean)
    ], DestinyDefinitionsDestinyInventoryItemDefinitionSetData.prototype, "requireOrderedSetItemAdd", void 0);
    __decorate([
        (0, utils_1.SpeakeasyMetadata)(),
        __metadata("design:type", Boolean)
    ], DestinyDefinitionsDestinyInventoryItemDefinitionSetData.prototype, "setIsFeatured", void 0);
    __decorate([
        (0, utils_1.SpeakeasyMetadata)(),
        __metadata("design:type", String)
    ], DestinyDefinitionsDestinyInventoryItemDefinitionSetData.prototype, "setType", void 0);
    return DestinyDefinitionsDestinyInventoryItemDefinitionSetData;
}(utils_1.SpeakeasyBase));
exports.DestinyDefinitionsDestinyInventoryItemDefinitionSetData = DestinyDefinitionsDestinyInventoryItemDefinitionSetData;
/**
 * If defined, the item has at least one socket.
 */
var DestinyDefinitionsDestinyInventoryItemDefinitionSockets = /** @class */ (function (_super) {
    __extends(DestinyDefinitionsDestinyInventoryItemDefinitionSockets, _super);
    function DestinyDefinitionsDestinyInventoryItemDefinitionSockets() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate([
        (0, utils_1.SpeakeasyMetadata)(),
        __metadata("design:type", String)
    ], DestinyDefinitionsDestinyInventoryItemDefinitionSockets.prototype, "detail", void 0);
    __decorate([
        (0, utils_1.SpeakeasyMetadata)({
            elemType: destinydefinitionsdestinyitemintrinsicsocketentrydefinition_1.DestinyDefinitionsDestinyItemIntrinsicSocketEntryDefinition,
        }),
        __metadata("design:type", Array)
    ], DestinyDefinitionsDestinyInventoryItemDefinitionSockets.prototype, "intrinsicSockets", void 0);
    __decorate([
        (0, utils_1.SpeakeasyMetadata)({
            elemType: destinydefinitionsdestinyitemsocketcategorydefinition_1.DestinyDefinitionsDestinyItemSocketCategoryDefinition,
        }),
        __metadata("design:type", Array)
    ], DestinyDefinitionsDestinyInventoryItemDefinitionSockets.prototype, "socketCategories", void 0);
    __decorate([
        (0, utils_1.SpeakeasyMetadata)({
            elemType: destinydefinitionsdestinyitemsocketentrydefinition_1.DestinyDefinitionsDestinyItemSocketEntryDefinition,
        }),
        __metadata("design:type", Array)
    ], DestinyDefinitionsDestinyInventoryItemDefinitionSockets.prototype, "socketEntries", void 0);
    return DestinyDefinitionsDestinyInventoryItemDefinitionSockets;
}(utils_1.SpeakeasyBase));
exports.DestinyDefinitionsDestinyInventoryItemDefinitionSockets = DestinyDefinitionsDestinyInventoryItemDefinitionSockets;
/**
 * Data about an item's "sources": ways that the item can be obtained.
 */
var DestinyDefinitionsDestinyInventoryItemDefinitionSourceData = /** @class */ (function (_super) {
    __extends(DestinyDefinitionsDestinyInventoryItemDefinitionSourceData, _super);
    function DestinyDefinitionsDestinyInventoryItemDefinitionSourceData() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate([
        (0, utils_1.SpeakeasyMetadata)(),
        __metadata("design:type", Number)
    ], DestinyDefinitionsDestinyInventoryItemDefinitionSourceData.prototype, "exclusive", void 0);
    __decorate([
        (0, utils_1.SpeakeasyMetadata)(),
        __metadata("design:type", Array)
    ], DestinyDefinitionsDestinyInventoryItemDefinitionSourceData.prototype, "sourceHashes", void 0);
    __decorate([
        (0, utils_1.SpeakeasyMetadata)({
            elemType: destinydefinitionssourcesdestinyitemsourcedefinition_1.DestinyDefinitionsSourcesDestinyItemSourceDefinition,
        }),
        __metadata("design:type", Array)
    ], DestinyDefinitionsDestinyInventoryItemDefinitionSourceData.prototype, "sources", void 0);
    __decorate([
        (0, utils_1.SpeakeasyMetadata)({
            elemType: destinydefinitionsdestinyitemvendorsourcereference_1.DestinyDefinitionsDestinyItemVendorSourceReference,
        }),
        __metadata("design:type", Array)
    ], DestinyDefinitionsDestinyInventoryItemDefinitionSourceData.prototype, "vendorSources", void 0);
    return DestinyDefinitionsDestinyInventoryItemDefinitionSourceData;
}(utils_1.SpeakeasyBase));
exports.DestinyDefinitionsDestinyInventoryItemDefinitionSourceData = DestinyDefinitionsDestinyInventoryItemDefinitionSourceData;
/**
 * Information about the item's calculated stats, with as much data as we can find for the stats without having an actual instance of the item.
 *
 * @remarks
 * Note that this means the entire concept of providing these stats is fundamentally insufficient: we cannot predict with 100% accuracy the conditions under which an item can spawn, so we use various heuristics to attempt to simulate the conditions as accurately as possible. Actual stats for items in-game can and will vary, but these should at least be useful base points for comparison and display.
 * It is also worth noting that some stats, like Magazine size, have further calculations performed on them by scripts in-game and on the game servers that BNet does not have access to. We cannot know how those stats are further transformed, and thus some stats will be inaccurate even on instances of items in BNet vs. how they appear in-game. This is a known limitation of our item statistics, without any planned fix.
 */
var DestinyDefinitionsDestinyInventoryItemDefinitionStats = /** @class */ (function (_super) {
    __extends(DestinyDefinitionsDestinyInventoryItemDefinitionStats, _super);
    function DestinyDefinitionsDestinyInventoryItemDefinitionStats() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate([
        (0, utils_1.SpeakeasyMetadata)(),
        __metadata("design:type", Boolean)
    ], DestinyDefinitionsDestinyInventoryItemDefinitionStats.prototype, "disablePrimaryStatDisplay", void 0);
    __decorate([
        (0, utils_1.SpeakeasyMetadata)(),
        __metadata("design:type", Boolean)
    ], DestinyDefinitionsDestinyInventoryItemDefinitionStats.prototype, "hasDisplayableStats", void 0);
    __decorate([
        (0, utils_1.SpeakeasyMetadata)(),
        __metadata("design:type", Number)
    ], DestinyDefinitionsDestinyInventoryItemDefinitionStats.prototype, "primaryBaseStatHash", void 0);
    __decorate([
        (0, utils_1.SpeakeasyMetadata)(),
        __metadata("design:type", Number)
    ], DestinyDefinitionsDestinyInventoryItemDefinitionStats.prototype, "statGroupHash", void 0);
    __decorate([
        (0, utils_1.SpeakeasyMetadata)({
            elemType: destinydefinitionsdestinyinventoryitemstatdefinition_1.DestinyDefinitionsDestinyInventoryItemStatDefinition,
        }),
        __metadata("design:type", Object)
    ], DestinyDefinitionsDestinyInventoryItemDefinitionStats.prototype, "stats", void 0);
    return DestinyDefinitionsDestinyInventoryItemDefinitionStats;
}(utils_1.SpeakeasyBase));
exports.DestinyDefinitionsDestinyInventoryItemDefinitionStats = DestinyDefinitionsDestinyInventoryItemDefinitionStats;
/**
 * This appears to be information used when rendering rewards. We don't currently use it on BNet.
 */
var DestinyDefinitionsDestinyInventoryItemDefinitionSummary = /** @class */ (function (_super) {
    __extends(DestinyDefinitionsDestinyInventoryItemDefinitionSummary, _super);
    function DestinyDefinitionsDestinyInventoryItemDefinitionSummary() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate([
        (0, utils_1.SpeakeasyMetadata)(),
        __metadata("design:type", Number)
    ], DestinyDefinitionsDestinyInventoryItemDefinitionSummary.prototype, "sortPriority", void 0);
    return DestinyDefinitionsDestinyInventoryItemDefinitionSummary;
}(utils_1.SpeakeasyBase));
exports.DestinyDefinitionsDestinyInventoryItemDefinitionSummary = DestinyDefinitionsDestinyInventoryItemDefinitionSummary;
/**
 * This defines information that can only come from a talent grid on an item. Items mostly have negligible talent grid data these days, but instanced items still retain grids as a source for some of this common information.
 *
 * @remarks
 * Builds/Subclasses are the only items left that still have talent grids with meaningful Nodes.
 */
var DestinyDefinitionsDestinyInventoryItemDefinitionTalentGrid = /** @class */ (function (_super) {
    __extends(DestinyDefinitionsDestinyInventoryItemDefinitionTalentGrid, _super);
    function DestinyDefinitionsDestinyInventoryItemDefinitionTalentGrid() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate([
        (0, utils_1.SpeakeasyMetadata)(),
        __metadata("design:type", String)
    ], DestinyDefinitionsDestinyInventoryItemDefinitionTalentGrid.prototype, "buildName", void 0);
    __decorate([
        (0, utils_1.SpeakeasyMetadata)(),
        __metadata("design:type", Number)
    ], DestinyDefinitionsDestinyInventoryItemDefinitionTalentGrid.prototype, "hudDamageType", void 0);
    __decorate([
        (0, utils_1.SpeakeasyMetadata)(),
        __metadata("design:type", String)
    ], DestinyDefinitionsDestinyInventoryItemDefinitionTalentGrid.prototype, "hudIcon", void 0);
    __decorate([
        (0, utils_1.SpeakeasyMetadata)(),
        __metadata("design:type", String)
    ], DestinyDefinitionsDestinyInventoryItemDefinitionTalentGrid.prototype, "itemDetailString", void 0);
    __decorate([
        (0, utils_1.SpeakeasyMetadata)(),
        __metadata("design:type", Number)
    ], DestinyDefinitionsDestinyInventoryItemDefinitionTalentGrid.prototype, "talentGridHash", void 0);
    return DestinyDefinitionsDestinyInventoryItemDefinitionTalentGrid;
}(utils_1.SpeakeasyBase));
exports.DestinyDefinitionsDestinyInventoryItemDefinitionTalentGrid = DestinyDefinitionsDestinyInventoryItemDefinitionTalentGrid;
/**
 * This Block defines the rendering data associated with the item, if any.
 */
var DestinyDefinitionsDestinyInventoryItemDefinitionTranslationBlock = /** @class */ (function (_super) {
    __extends(DestinyDefinitionsDestinyInventoryItemDefinitionTranslationBlock, _super);
    function DestinyDefinitionsDestinyInventoryItemDefinitionTranslationBlock() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate([
        (0, utils_1.SpeakeasyMetadata)({
            elemType: destinydefinitionsdestinygearartarrangementreference_1.DestinyDefinitionsDestinyGearArtArrangementReference,
        }),
        __metadata("design:type", Array)
    ], DestinyDefinitionsDestinyInventoryItemDefinitionTranslationBlock.prototype, "arrangements", void 0);
    __decorate([
        (0, utils_1.SpeakeasyMetadata)({ elemType: destinydyereference_1.DestinyDyeReference }),
        __metadata("design:type", Array)
    ], DestinyDefinitionsDestinyInventoryItemDefinitionTranslationBlock.prototype, "customDyes", void 0);
    __decorate([
        (0, utils_1.SpeakeasyMetadata)({ elemType: destinydyereference_1.DestinyDyeReference }),
        __metadata("design:type", Array)
    ], DestinyDefinitionsDestinyInventoryItemDefinitionTranslationBlock.prototype, "defaultDyes", void 0);
    __decorate([
        (0, utils_1.SpeakeasyMetadata)(),
        __metadata("design:type", Boolean)
    ], DestinyDefinitionsDestinyInventoryItemDefinitionTranslationBlock.prototype, "hasGeometry", void 0);
    __decorate([
        (0, utils_1.SpeakeasyMetadata)({ elemType: destinydyereference_1.DestinyDyeReference }),
        __metadata("design:type", Array)
    ], DestinyDefinitionsDestinyInventoryItemDefinitionTranslationBlock.prototype, "lockedDyes", void 0);
    __decorate([
        (0, utils_1.SpeakeasyMetadata)(),
        __metadata("design:type", Number)
    ], DestinyDefinitionsDestinyInventoryItemDefinitionTranslationBlock.prototype, "weaponPatternHash", void 0);
    __decorate([
        (0, utils_1.SpeakeasyMetadata)(),
        __metadata("design:type", String)
    ], DestinyDefinitionsDestinyInventoryItemDefinitionTranslationBlock.prototype, "weaponPatternIdentifier", void 0);
    return DestinyDefinitionsDestinyInventoryItemDefinitionTranslationBlock;
}(utils_1.SpeakeasyBase));
exports.DestinyDefinitionsDestinyInventoryItemDefinitionTranslationBlock = DestinyDefinitionsDestinyInventoryItemDefinitionTranslationBlock;
/**
 * This defines an item's "Value". Unfortunately, this appears to be used in different ways depending on the way that the item itself is used.
 *
 * @remarks
 * For items being sold at a Vendor, this is the default "sale price" of the item. These days, the vendor itself almost always sets the price, but it still possible for the price to fall back to this value. For quests, it is a preview of rewards you can gain by completing the quest. For dummy items, if the itemValue refers to an Emblem, it is the emblem that should be shown as the reward. (jeez louise)
 * It will likely be used in a number of other ways in the future, it appears to be a bucket where they put arbitrary items and quantities into the item.
 */
var DestinyDefinitionsDestinyInventoryItemDefinitionValue = /** @class */ (function (_super) {
    __extends(DestinyDefinitionsDestinyInventoryItemDefinitionValue, _super);
    function DestinyDefinitionsDestinyInventoryItemDefinitionValue() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate([
        (0, utils_1.SpeakeasyMetadata)({ elemType: destinydestinyitemquantity_1.DestinyDestinyItemQuantity }),
        __metadata("design:type", Array)
    ], DestinyDefinitionsDestinyInventoryItemDefinitionValue.prototype, "itemValue", void 0);
    __decorate([
        (0, utils_1.SpeakeasyMetadata)(),
        __metadata("design:type", String)
    ], DestinyDefinitionsDestinyInventoryItemDefinitionValue.prototype, "valueDescription", void 0);
    return DestinyDefinitionsDestinyInventoryItemDefinitionValue;
}(utils_1.SpeakeasyBase));
exports.DestinyDefinitionsDestinyInventoryItemDefinitionValue = DestinyDefinitionsDestinyInventoryItemDefinitionValue;
/**
 * So much of what you see in Destiny is actually an Item used in a new and creative way. This is the definition for Items in Destiny, which started off as just entities that could exist in your Inventory but ended up being the backing data for so much more: quests, reward previews, slots, and subclasses.
 *
 * @remarks
 * In practice, you will want to associate this data with "live" item data from a Bungie.Net Platform call: these definitions describe the item in generic, non-instanced terms: but an actual instance of an item can vary widely from these generic definitions.
 */
var DestinyDefinitionsDestinyInventoryItemDefinition = /** @class */ (function (_super) {
    __extends(DestinyDefinitionsDestinyInventoryItemDefinition, _super);
    function DestinyDefinitionsDestinyInventoryItemDefinition() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate([
        (0, utils_1.SpeakeasyMetadata)(),
        __metadata("design:type", DestinyDefinitionsDestinyInventoryItemDefinitionAction)
    ], DestinyDefinitionsDestinyInventoryItemDefinition.prototype, "action", void 0);
    __decorate([
        (0, utils_1.SpeakeasyMetadata)(),
        __metadata("design:type", Boolean)
    ], DestinyDefinitionsDestinyInventoryItemDefinition.prototype, "allowActions", void 0);
    __decorate([
        (0, utils_1.SpeakeasyMetadata)({
            elemType: destinydefinitionsanimationsdestinyanimationreference_1.DestinyDefinitionsAnimationsDestinyAnimationReference,
        }),
        __metadata("design:type", Array)
    ], DestinyDefinitionsDestinyInventoryItemDefinition.prototype, "animations", void 0);
    __decorate([
        (0, utils_1.SpeakeasyMetadata)(),
        __metadata("design:type", DestinyDefinitionsDestinyInventoryItemDefinitionBackgroundColor)
    ], DestinyDefinitionsDestinyInventoryItemDefinition.prototype, "backgroundColor", void 0);
    __decorate([
        (0, utils_1.SpeakeasyMetadata)(),
        __metadata("design:type", Number)
    ], DestinyDefinitionsDestinyInventoryItemDefinition.prototype, "breakerType", void 0);
    __decorate([
        (0, utils_1.SpeakeasyMetadata)(),
        __metadata("design:type", Number)
    ], DestinyDefinitionsDestinyInventoryItemDefinition.prototype, "breakerTypeHash", void 0);
    __decorate([
        (0, utils_1.SpeakeasyMetadata)(),
        __metadata("design:type", Number)
    ], DestinyDefinitionsDestinyInventoryItemDefinition.prototype, "classType", void 0);
    __decorate([
        (0, utils_1.SpeakeasyMetadata)(),
        __metadata("design:type", Number)
    ], DestinyDefinitionsDestinyInventoryItemDefinition.prototype, "collectibleHash", void 0);
    __decorate([
        (0, utils_1.SpeakeasyMetadata)(),
        __metadata("design:type", DestinyDefinitionsDestinyInventoryItemDefinitionCrafting)
    ], DestinyDefinitionsDestinyInventoryItemDefinition.prototype, "crafting", void 0);
    __decorate([
        (0, utils_1.SpeakeasyMetadata)(),
        __metadata("design:type", Array)
    ], DestinyDefinitionsDestinyInventoryItemDefinition.prototype, "damageTypeHashes", void 0);
    __decorate([
        (0, utils_1.SpeakeasyMetadata)(),
        __metadata("design:type", Array)
    ], DestinyDefinitionsDestinyInventoryItemDefinition.prototype, "damageTypes", void 0);
    __decorate([
        (0, utils_1.SpeakeasyMetadata)(),
        __metadata("design:type", Number)
    ], DestinyDefinitionsDestinyInventoryItemDefinition.prototype, "defaultDamageType", void 0);
    __decorate([
        (0, utils_1.SpeakeasyMetadata)(),
        __metadata("design:type", Number)
    ], DestinyDefinitionsDestinyInventoryItemDefinition.prototype, "defaultDamageTypeHash", void 0);
    __decorate([
        (0, utils_1.SpeakeasyMetadata)(),
        __metadata("design:type", destinydefinitionscommondestinydisplaypropertiesdefinition_1.DestinyDefinitionsCommonDestinyDisplayPropertiesDefinition)
    ], DestinyDefinitionsDestinyInventoryItemDefinition.prototype, "displayProperties", void 0);
    __decorate([
        (0, utils_1.SpeakeasyMetadata)(),
        __metadata("design:type", String)
    ], DestinyDefinitionsDestinyInventoryItemDefinition.prototype, "displaySource", void 0);
    __decorate([
        (0, utils_1.SpeakeasyMetadata)(),
        __metadata("design:type", Boolean)
    ], DestinyDefinitionsDestinyInventoryItemDefinition.prototype, "doesPostmasterPullHaveSideEffects", void 0);
    __decorate([
        (0, utils_1.SpeakeasyMetadata)(),
        __metadata("design:type", Number)
    ], DestinyDefinitionsDestinyInventoryItemDefinition.prototype, "emblemObjectiveHash", void 0);
    __decorate([
        (0, utils_1.SpeakeasyMetadata)(),
        __metadata("design:type", Boolean)
    ], DestinyDefinitionsDestinyInventoryItemDefinition.prototype, "equippable", void 0);
    __decorate([
        (0, utils_1.SpeakeasyMetadata)(),
        __metadata("design:type", DestinyDefinitionsDestinyInventoryItemDefinitionEquippingBlock)
    ], DestinyDefinitionsDestinyInventoryItemDefinition.prototype, "equippingBlock", void 0);
    __decorate([
        (0, utils_1.SpeakeasyMetadata)(),
        __metadata("design:type", String)
    ], DestinyDefinitionsDestinyInventoryItemDefinition.prototype, "flavorText", void 0);
    __decorate([
        (0, utils_1.SpeakeasyMetadata)(),
        __metadata("design:type", DestinyDefinitionsDestinyInventoryItemDefinitionGearset)
    ], DestinyDefinitionsDestinyInventoryItemDefinition.prototype, "gearset", void 0);
    __decorate([
        (0, utils_1.SpeakeasyMetadata)(),
        __metadata("design:type", Number)
    ], DestinyDefinitionsDestinyInventoryItemDefinition.prototype, "hash", void 0);
    __decorate([
        (0, utils_1.SpeakeasyMetadata)(),
        __metadata("design:type", String)
    ], DestinyDefinitionsDestinyInventoryItemDefinition.prototype, "iconWatermark", void 0);
    __decorate([
        (0, utils_1.SpeakeasyMetadata)(),
        __metadata("design:type", String)
    ], DestinyDefinitionsDestinyInventoryItemDefinition.prototype, "iconWatermarkShelved", void 0);
    __decorate([
        (0, utils_1.SpeakeasyMetadata)(),
        __metadata("design:type", Number)
    ], DestinyDefinitionsDestinyInventoryItemDefinition.prototype, "index", void 0);
    __decorate([
        (0, utils_1.SpeakeasyMetadata)(),
        __metadata("design:type", DestinyDefinitionsDestinyInventoryItemDefinitionInventory)
    ], DestinyDefinitionsDestinyInventoryItemDefinition.prototype, "inventory", void 0);
    __decorate([
        (0, utils_1.SpeakeasyMetadata)({
            elemType: destinydefinitionsdestinyiteminvestmentstatdefinition_1.DestinyDefinitionsDestinyItemInvestmentStatDefinition,
        }),
        __metadata("design:type", Array)
    ], DestinyDefinitionsDestinyInventoryItemDefinition.prototype, "investmentStats", void 0);
    __decorate([
        (0, utils_1.SpeakeasyMetadata)(),
        __metadata("design:type", Boolean)
    ], DestinyDefinitionsDestinyInventoryItemDefinition.prototype, "isWrapper", void 0);
    __decorate([
        (0, utils_1.SpeakeasyMetadata)(),
        __metadata("design:type", Array)
    ], DestinyDefinitionsDestinyInventoryItemDefinition.prototype, "itemCategoryHashes", void 0);
    __decorate([
        (0, utils_1.SpeakeasyMetadata)(),
        __metadata("design:type", Number)
    ], DestinyDefinitionsDestinyInventoryItemDefinition.prototype, "itemSubType", void 0);
    __decorate([
        (0, utils_1.SpeakeasyMetadata)(),
        __metadata("design:type", Number)
    ], DestinyDefinitionsDestinyInventoryItemDefinition.prototype, "itemType", void 0);
    __decorate([
        (0, utils_1.SpeakeasyMetadata)(),
        __metadata("design:type", String)
    ], DestinyDefinitionsDestinyInventoryItemDefinition.prototype, "itemTypeAndTierDisplayName", void 0);
    __decorate([
        (0, utils_1.SpeakeasyMetadata)(),
        __metadata("design:type", String)
    ], DestinyDefinitionsDestinyInventoryItemDefinition.prototype, "itemTypeDisplayName", void 0);
    __decorate([
        (0, utils_1.SpeakeasyMetadata)({ elemType: linkshyperlinkreference_1.LinksHyperlinkReference }),
        __metadata("design:type", Array)
    ], DestinyDefinitionsDestinyInventoryItemDefinition.prototype, "links", void 0);
    __decorate([
        (0, utils_1.SpeakeasyMetadata)(),
        __metadata("design:type", Number)
    ], DestinyDefinitionsDestinyInventoryItemDefinition.prototype, "loreHash", void 0);
    __decorate([
        (0, utils_1.SpeakeasyMetadata)(),
        __metadata("design:type", DestinyDefinitionsDestinyInventoryItemDefinitionMetrics)
    ], DestinyDefinitionsDestinyInventoryItemDefinition.prototype, "metrics", void 0);
    __decorate([
        (0, utils_1.SpeakeasyMetadata)(),
        __metadata("design:type", Boolean)
    ], DestinyDefinitionsDestinyInventoryItemDefinition.prototype, "nonTransferrable", void 0);
    __decorate([
        (0, utils_1.SpeakeasyMetadata)(),
        __metadata("design:type", DestinyDefinitionsDestinyInventoryItemDefinitionObjectives)
    ], DestinyDefinitionsDestinyInventoryItemDefinition.prototype, "objectives", void 0);
    __decorate([
        (0, utils_1.SpeakeasyMetadata)({
            elemType: destinydefinitionsdestinyitemperkentrydefinition_1.DestinyDefinitionsDestinyItemPerkEntryDefinition,
        }),
        __metadata("design:type", Array)
    ], DestinyDefinitionsDestinyInventoryItemDefinition.prototype, "perks", void 0);
    __decorate([
        (0, utils_1.SpeakeasyMetadata)(),
        __metadata("design:type", DestinyDefinitionsDestinyInventoryItemDefinitionPlug)
    ], DestinyDefinitionsDestinyInventoryItemDefinition.prototype, "plug", void 0);
    __decorate([
        (0, utils_1.SpeakeasyMetadata)(),
        __metadata("design:type", DestinyDefinitionsDestinyInventoryItemDefinitionPreview)
    ], DestinyDefinitionsDestinyInventoryItemDefinition.prototype, "preview", void 0);
    __decorate([
        (0, utils_1.SpeakeasyMetadata)(),
        __metadata("design:type", DestinyDefinitionsDestinyInventoryItemDefinitionQuality)
    ], DestinyDefinitionsDestinyInventoryItemDefinition.prototype, "quality", void 0);
    __decorate([
        (0, utils_1.SpeakeasyMetadata)(),
        __metadata("design:type", Boolean)
    ], DestinyDefinitionsDestinyInventoryItemDefinition.prototype, "redacted", void 0);
    __decorate([
        (0, utils_1.SpeakeasyMetadata)(),
        __metadata("design:type", DestinyDefinitionsDestinyInventoryItemDefinitionSack)
    ], DestinyDefinitionsDestinyInventoryItemDefinition.prototype, "sack", void 0);
    __decorate([
        (0, utils_1.SpeakeasyMetadata)(),
        __metadata("design:type", String)
    ], DestinyDefinitionsDestinyInventoryItemDefinition.prototype, "screenshot", void 0);
    __decorate([
        (0, utils_1.SpeakeasyMetadata)(),
        __metadata("design:type", Number)
    ], DestinyDefinitionsDestinyInventoryItemDefinition.prototype, "seasonHash", void 0);
    __decorate([
        (0, utils_1.SpeakeasyMetadata)(),
        __metadata("design:type", String)
    ], DestinyDefinitionsDestinyInventoryItemDefinition.prototype, "secondaryIcon", void 0);
    __decorate([
        (0, utils_1.SpeakeasyMetadata)(),
        __metadata("design:type", String)
    ], DestinyDefinitionsDestinyInventoryItemDefinition.prototype, "secondaryOverlay", void 0);
    __decorate([
        (0, utils_1.SpeakeasyMetadata)(),
        __metadata("design:type", String)
    ], DestinyDefinitionsDestinyInventoryItemDefinition.prototype, "secondarySpecial", void 0);
    __decorate([
        (0, utils_1.SpeakeasyMetadata)(),
        __metadata("design:type", DestinyDefinitionsDestinyInventoryItemDefinitionSetData)
    ], DestinyDefinitionsDestinyInventoryItemDefinition.prototype, "setData", void 0);
    __decorate([
        (0, utils_1.SpeakeasyMetadata)(),
        __metadata("design:type", DestinyDefinitionsDestinyInventoryItemDefinitionSockets)
    ], DestinyDefinitionsDestinyInventoryItemDefinition.prototype, "sockets", void 0);
    __decorate([
        (0, utils_1.SpeakeasyMetadata)(),
        __metadata("design:type", DestinyDefinitionsDestinyInventoryItemDefinitionSourceData)
    ], DestinyDefinitionsDestinyInventoryItemDefinition.prototype, "sourceData", void 0);
    __decorate([
        (0, utils_1.SpeakeasyMetadata)(),
        __metadata("design:type", Number)
    ], DestinyDefinitionsDestinyInventoryItemDefinition.prototype, "specialItemType", void 0);
    __decorate([
        (0, utils_1.SpeakeasyMetadata)(),
        __metadata("design:type", DestinyDefinitionsDestinyInventoryItemDefinitionStats)
    ], DestinyDefinitionsDestinyInventoryItemDefinition.prototype, "stats", void 0);
    __decorate([
        (0, utils_1.SpeakeasyMetadata)(),
        __metadata("design:type", DestinyDefinitionsDestinyInventoryItemDefinitionSummary)
    ], DestinyDefinitionsDestinyInventoryItemDefinition.prototype, "summary", void 0);
    __decorate([
        (0, utils_1.SpeakeasyMetadata)(),
        __metadata("design:type", Number)
    ], DestinyDefinitionsDestinyInventoryItemDefinition.prototype, "summaryItemHash", void 0);
    __decorate([
        (0, utils_1.SpeakeasyMetadata)(),
        __metadata("design:type", DestinyDefinitionsDestinyInventoryItemDefinitionTalentGrid)
    ], DestinyDefinitionsDestinyInventoryItemDefinition.prototype, "talentGrid", void 0);
    __decorate([
        (0, utils_1.SpeakeasyMetadata)({
            elemType: destinydefinitionsdestinyitemtooltipnotification_1.DestinyDefinitionsDestinyItemTooltipNotification,
        }),
        __metadata("design:type", Array)
    ], DestinyDefinitionsDestinyInventoryItemDefinition.prototype, "tooltipNotifications", void 0);
    __decorate([
        (0, utils_1.SpeakeasyMetadata)(),
        __metadata("design:type", String)
    ], DestinyDefinitionsDestinyInventoryItemDefinition.prototype, "tooltipStyle", void 0);
    __decorate([
        (0, utils_1.SpeakeasyMetadata)(),
        __metadata("design:type", Array)
    ], DestinyDefinitionsDestinyInventoryItemDefinition.prototype, "traitHashes", void 0);
    __decorate([
        (0, utils_1.SpeakeasyMetadata)(),
        __metadata("design:type", Array)
    ], DestinyDefinitionsDestinyInventoryItemDefinition.prototype, "traitIds", void 0);
    __decorate([
        (0, utils_1.SpeakeasyMetadata)(),
        __metadata("design:type", DestinyDefinitionsDestinyInventoryItemDefinitionTranslationBlock)
    ], DestinyDefinitionsDestinyInventoryItemDefinition.prototype, "translationBlock", void 0);
    __decorate([
        (0, utils_1.SpeakeasyMetadata)(),
        __metadata("design:type", String)
    ], DestinyDefinitionsDestinyInventoryItemDefinition.prototype, "uiItemDisplayStyle", void 0);
    __decorate([
        (0, utils_1.SpeakeasyMetadata)(),
        __metadata("design:type", DestinyDefinitionsDestinyInventoryItemDefinitionValue)
    ], DestinyDefinitionsDestinyInventoryItemDefinition.prototype, "value", void 0);
    return DestinyDefinitionsDestinyInventoryItemDefinition;
}(utils_1.SpeakeasyBase));
exports.DestinyDefinitionsDestinyInventoryItemDefinition = DestinyDefinitionsDestinyInventoryItemDefinition;
