// Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.

package sdk

import (
	"context"
	"fmt"
	"net/http"
	"openapi/pkg/models/operations"
	"openapi/pkg/models/shared"
	"openapi/pkg/utils"
	"strings"
)

// rootVcdVapp - vCloud Director vApps.
type rootVcdVapp struct {
	defaultClient  HTTPClient
	securityClient HTTPClient
	serverURL      string
	language       string
	sdkVersion     string
	genVersion     string
}

func newRootVcdVapp(defaultClient, securityClient HTTPClient, serverURL, language, sdkVersion, genVersion string) *rootVcdVapp {
	return &rootVcdVapp{
		defaultClient:  defaultClient,
		securityClient: securityClient,
		serverURL:      serverURL,
		language:       language,
		sdkVersion:     sdkVersion,
		genVersion:     genVersion,
	}
}

// CreateOnDemandSnapshotV1 - Create an on-demand snapshot for a vApp
// Start an asynchronous job to create an on-demand snapshot for a specified vApp object.
func (s *rootVcdVapp) CreateOnDemandSnapshotV1(ctx context.Context, request operations.CreateOnDemandSnapshotV1Request) (*operations.CreateOnDemandSnapshotV1Response, error) {
	baseURL := s.serverURL
	url, err := utils.GenerateURL(ctx, baseURL, "/vcd/vapp/{id}/snapshot", request, nil)
	if err != nil {
		return nil, fmt.Errorf("error generating URL: %w", err)
	}

	bodyReader, reqContentType, err := utils.SerializeRequestBody(ctx, request, "BaseOnDemandSnapshotConfig", "json")
	if err != nil {
		return nil, fmt.Errorf("error serializing request body: %w", err)
	}

	req, err := http.NewRequestWithContext(ctx, "POST", url, bodyReader)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	req.Header.Set("Content-Type", reqContentType)

	client := s.securityClient

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.CreateOnDemandSnapshotV1Response{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 202:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *shared.AsyncRequestStatus
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.AsyncRequestStatus = out
		}
	}

	return res, nil
}

// CreateVappExportV1 - Export vApp snapshot
// Export the specified vApp snapshot into a new vApp or an existing vApp.
func (s *rootVcdVapp) CreateVappExportV1(ctx context.Context, request operations.CreateVappExportV1Request) (*operations.CreateVappExportV1Response, error) {
	baseURL := s.serverURL
	url, err := utils.GenerateURL(ctx, baseURL, "/vcd/vapp/snapshot/{snapshot_id}/export", request, nil)
	if err != nil {
		return nil, fmt.Errorf("error generating URL: %w", err)
	}

	bodyReader, reqContentType, err := utils.SerializeRequestBody(ctx, request, "VappExportSnapshotJobConfig", "json")
	if err != nil {
		return nil, fmt.Errorf("error serializing request body: %w", err)
	}
	if bodyReader == nil {
		return nil, fmt.Errorf("request body is required")
	}

	req, err := http.NewRequestWithContext(ctx, "POST", url, bodyReader)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	req.Header.Set("Content-Type", reqContentType)

	client := s.securityClient

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.CreateVappExportV1Response{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 202:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *shared.AsyncRequestStatus
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.AsyncRequestStatus = out
		}
	}

	return res, nil
}

// CreateVappInstantRecoveryV1 - Instant Recovery of vApp virtual machines
// Use Instant Recovery to recover specified vApp virtual machines.
func (s *rootVcdVapp) CreateVappInstantRecoveryV1(ctx context.Context, request operations.CreateVappInstantRecoveryV1Request) (*operations.CreateVappInstantRecoveryV1Response, error) {
	baseURL := s.serverURL
	url, err := utils.GenerateURL(ctx, baseURL, "/vcd/vapp/snapshot/{snapshot_id}/instant_recover", request, nil)
	if err != nil {
		return nil, fmt.Errorf("error generating URL: %w", err)
	}

	bodyReader, reqContentType, err := utils.SerializeRequestBody(ctx, request, "VappInstantRecoveryJobConfig", "json")
	if err != nil {
		return nil, fmt.Errorf("error serializing request body: %w", err)
	}
	if bodyReader == nil {
		return nil, fmt.Errorf("request body is required")
	}

	req, err := http.NewRequestWithContext(ctx, "POST", url, bodyReader)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	req.Header.Set("Content-Type", reqContentType)

	client := s.securityClient

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.CreateVappInstantRecoveryV1Response{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 202:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *shared.AsyncRequestStatus
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.AsyncRequestStatus = out
		}
	}

	return res, nil
}

// CreateVappTemplateSnapshotExport - Export of a vApp template snapshot
// Export a vApp template snapashot to a catalog. Use the options endpoint to confirm that exporting to the catalog defaults or the original organization vDC storage profile is possible.
func (s *rootVcdVapp) CreateVappTemplateSnapshotExport(ctx context.Context, request operations.CreateVappTemplateSnapshotExportRequest) (*operations.CreateVappTemplateSnapshotExportResponse, error) {
	baseURL := s.serverURL
	url, err := utils.GenerateURL(ctx, baseURL, "/vcd/vapp/template/snapshot/{snapshot_id}/export", request, nil)
	if err != nil {
		return nil, fmt.Errorf("error generating URL: %w", err)
	}

	bodyReader, reqContentType, err := utils.SerializeRequestBody(ctx, request, "VappTemplateExportJobConfig", "json")
	if err != nil {
		return nil, fmt.Errorf("error serializing request body: %w", err)
	}
	if bodyReader == nil {
		return nil, fmt.Errorf("request body is required")
	}

	req, err := http.NewRequestWithContext(ctx, "POST", url, bodyReader)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	req.Header.Set("Content-Type", reqContentType)

	client := s.securityClient

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.CreateVappTemplateSnapshotExportResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 202:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *shared.AsyncRequestStatus
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.AsyncRequestStatus = out
		}
	}

	return res, nil
}

// CreateVcdVappDownloadSnapshotFromCloudV1 - Download snapshot from archive
// Provides a method for retrieving a snapshot that is not available locally, from an archival location.
func (s *rootVcdVapp) CreateVcdVappDownloadSnapshotFromCloudV1(ctx context.Context, request operations.CreateVcdVappDownloadSnapshotFromCloudV1Request) (*operations.CreateVcdVappDownloadSnapshotFromCloudV1Response, error) {
	baseURL := s.serverURL
	url, err := utils.GenerateURL(ctx, baseURL, "/vcd/vapp/snapshot/{id}/download", request, nil)
	if err != nil {
		return nil, fmt.Errorf("error generating URL: %w", err)
	}

	req, err := http.NewRequestWithContext(ctx, "POST", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	client := s.securityClient

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.CreateVcdVappDownloadSnapshotFromCloudV1Response{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 202:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *shared.AsyncRequestStatus
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.AsyncRequestStatus = out
		}
	}

	return res, nil
}

// DeleteVappSnapshotV1 - Delete a vApp snapshot
// Designate a vApp snapshot as expired and available for garbage collection. The snapshot must be an on-demand snapshot or a snapshot from a vApp that is not assigned to an SLA Domain.
func (s *rootVcdVapp) DeleteVappSnapshotV1(ctx context.Context, request operations.DeleteVappSnapshotV1Request) (*operations.DeleteVappSnapshotV1Response, error) {
	baseURL := s.serverURL
	url, err := utils.GenerateURL(ctx, baseURL, "/vcd/vapp/snapshot/{id}", request, nil)
	if err != nil {
		return nil, fmt.Errorf("error generating URL: %w", err)
	}

	req, err := http.NewRequestWithContext(ctx, "DELETE", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	if err := utils.PopulateQueryParams(ctx, req, request, nil); err != nil {
		return nil, fmt.Errorf("error populating query params: %w", err)
	}

	client := s.securityClient

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.DeleteVappSnapshotV1Response{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 204:
	}

	return res, nil
}

// DeleteVappSnapshotsV1 - Delete all snapshots of vApp
// Delete all snapshots for a specified vApp object.
func (s *rootVcdVapp) DeleteVappSnapshotsV1(ctx context.Context, request operations.DeleteVappSnapshotsV1Request) (*operations.DeleteVappSnapshotsV1Response, error) {
	baseURL := s.serverURL
	url, err := utils.GenerateURL(ctx, baseURL, "/vcd/vapp/{id}/snapshot", request, nil)
	if err != nil {
		return nil, fmt.Errorf("error generating URL: %w", err)
	}

	req, err := http.NewRequestWithContext(ctx, "DELETE", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	client := s.securityClient

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.DeleteVappSnapshotsV1Response{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 204:
	}

	return res, nil
}

// GetVappAsyncRequestStatusV1 - Get vApp job status
// Retrieve the details of a specified asynchronous job for a vApp.
func (s *rootVcdVapp) GetVappAsyncRequestStatusV1(ctx context.Context, request operations.GetVappAsyncRequestStatusV1Request) (*operations.GetVappAsyncRequestStatusV1Response, error) {
	baseURL := s.serverURL
	url, err := utils.GenerateURL(ctx, baseURL, "/vcd/vapp/request/{id}", request, nil)
	if err != nil {
		return nil, fmt.Errorf("error generating URL: %w", err)
	}

	req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	client := s.securityClient

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.GetVappAsyncRequestStatusV1Response{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 202:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *shared.AsyncRequestStatus
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.AsyncRequestStatus = out
		}
	}

	return res, nil
}

// GetVappSnapshotExportOptionsV1 - Get exportable network configurations
// Retrieve summary information for the vApp networks that are available for network connections from the virtual machines in the exported vApp snapshot. The summary also specifies the default vApp network for each virtual machine network connection.
func (s *rootVcdVapp) GetVappSnapshotExportOptionsV1(ctx context.Context, request operations.GetVappSnapshotExportOptionsV1Request) (*operations.GetVappSnapshotExportOptionsV1Response, error) {
	baseURL := s.serverURL
	url, err := utils.GenerateURL(ctx, baseURL, "/vcd/vapp/snapshot/{snapshot_id}/export/options", request, nil)
	if err != nil {
		return nil, fmt.Errorf("error generating URL: %w", err)
	}

	req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	if err := utils.PopulateQueryParams(ctx, req, request, nil); err != nil {
		return nil, fmt.Errorf("error populating query params: %w", err)
	}

	client := s.securityClient

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.GetVappSnapshotExportOptionsV1Response{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *shared.VappExportOptions
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.VappExportOptions = out
		}
	}

	return res, nil
}

// GetVappSnapshotInstantRecoveryOptionsV1 - Get Instant Recovery information
// Retrieve the available vApp network connections and the default vApp network connection for the virtual machines in a vApp snapshot. Use this information to configure an Instant Recovery of specified virtual machines in the vApp snapshot.
func (s *rootVcdVapp) GetVappSnapshotInstantRecoveryOptionsV1(ctx context.Context, request operations.GetVappSnapshotInstantRecoveryOptionsV1Request) (*operations.GetVappSnapshotInstantRecoveryOptionsV1Response, error) {
	baseURL := s.serverURL
	url, err := utils.GenerateURL(ctx, baseURL, "/vcd/vapp/snapshot/{snapshot_id}/instant_recover/options", request, nil)
	if err != nil {
		return nil, fmt.Errorf("error generating URL: %w", err)
	}

	req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	client := s.securityClient

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.GetVappSnapshotInstantRecoveryOptionsV1Response{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *shared.VappInstantRecoveryOptions
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.VappInstantRecoveryOptions = out
		}
	}

	return res, nil
}

// GetVappSnapshotV1 - Get vApp snapshot details
// Retrieve detailed information about a specified snapshot for a vApp object.
func (s *rootVcdVapp) GetVappSnapshotV1(ctx context.Context, request operations.GetVappSnapshotV1Request) (*operations.GetVappSnapshotV1Response, error) {
	baseURL := s.serverURL
	url, err := utils.GenerateURL(ctx, baseURL, "/vcd/vapp/snapshot/{id}", request, nil)
	if err != nil {
		return nil, fmt.Errorf("error generating URL: %w", err)
	}

	req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	client := s.securityClient

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.GetVappSnapshotV1Response{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *shared.VcdVappSnapshotDetail
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.VcdVappSnapshotDetail = out
		}
	}

	return res, nil
}

// GetVappTemplateSnapshotExportOptions - Get Export information for a vApp template snapshot
// Retrieve the available choices vApp template storage profile and organization vDC choices in case of exporting to either original organization vDC defaults of the target catalog. In case advanced option of manually deciding org vdc is preferred, this also provides available storage profile choices.
func (s *rootVcdVapp) GetVappTemplateSnapshotExportOptions(ctx context.Context, request operations.GetVappTemplateSnapshotExportOptionsRequest) (*operations.GetVappTemplateSnapshotExportOptionsResponse, error) {
	baseURL := s.serverURL
	url, err := utils.GenerateURL(ctx, baseURL, "/vcd/vapp/template/snapshot/{snapshot_id}/export/options", request, nil)
	if err != nil {
		return nil, fmt.Errorf("error generating URL: %w", err)
	}

	req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	if err := utils.PopulateQueryParams(ctx, req, request, nil); err != nil {
		return nil, fmt.Errorf("error populating query params: %w", err)
	}

	client := s.securityClient

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.GetVappTemplateSnapshotExportOptionsResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *shared.VappTemplateExportOptionsUnion
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.VappTemplateExportOptionsUnion = out
		}
	}

	return res, nil
}

// GetVcdVappV1 - Get details of a specific vApp
// Retrieve detailed information for a specified vApp.
func (s *rootVcdVapp) GetVcdVappV1(ctx context.Context, request operations.GetVcdVappV1Request) (*operations.GetVcdVappV1Response, error) {
	baseURL := s.serverURL
	url, err := utils.GenerateURL(ctx, baseURL, "/vcd/vapp/{id}", request, nil)
	if err != nil {
		return nil, fmt.Errorf("error generating URL: %w", err)
	}

	req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	client := s.securityClient

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.GetVcdVappV1Response{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *shared.VcdVappDetail
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.VcdVappDetail = out
		}
	}

	return res, nil
}

// QueryVappSnapshotV1 - Get list of snapshots of vApp
// Retrieve summary information for each of the snapshot objects of a specified vApp object.
func (s *rootVcdVapp) QueryVappSnapshotV1(ctx context.Context, request operations.QueryVappSnapshotV1Request) (*operations.QueryVappSnapshotV1Response, error) {
	baseURL := s.serverURL
	url, err := utils.GenerateURL(ctx, baseURL, "/vcd/vapp/{id}/snapshot", request, nil)
	if err != nil {
		return nil, fmt.Errorf("error generating URL: %w", err)
	}

	req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	client := s.securityClient

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.QueryVappSnapshotV1Response{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *shared.VcdVappSnapshotSummaryListResponse
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.VcdVappSnapshotSummaryListResponse = out
		}
	}

	return res, nil
}

// QueryVcdVappsV1 - Get summary for vApps
// Retrieve summary information for all vCD vApp objects.
func (s *rootVcdVapp) QueryVcdVappsV1(ctx context.Context, request operations.QueryVcdVappsV1Request) (*operations.QueryVcdVappsV1Response, error) {
	baseURL := s.serverURL
	url := strings.TrimSuffix(baseURL, "/") + "/vcd/vapp"

	req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	if err := utils.PopulateQueryParams(ctx, req, request, nil); err != nil {
		return nil, fmt.Errorf("error populating query params: %w", err)
	}

	client := s.securityClient

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.QueryVcdVappsV1Response{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *shared.VcdVappSummaryListResponse
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.VcdVappSummaryListResponse = out
		}
	}

	return res, nil
}

// SearchVappV1 - Search for a file in a vApp
// Aggregated search for a file through snapshots of all virtual machines that are presently part of the vApp. Specify the file using a full path prefix or a filename prefix.
func (s *rootVcdVapp) SearchVappV1(ctx context.Context, request operations.SearchVappV1Request) (*operations.SearchVappV1Response, error) {
	baseURL := s.serverURL
	url, err := utils.GenerateURL(ctx, baseURL, "/vcd/vapp/{id}/search", request, nil)
	if err != nil {
		return nil, fmt.Errorf("error generating URL: %w", err)
	}

	req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	if err := utils.PopulateQueryParams(ctx, req, request, nil); err != nil {
		return nil, fmt.Errorf("error populating query params: %w", err)
	}

	client := s.securityClient

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.SearchVappV1Response{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *shared.AppSearchResponseListResponse
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.AppSearchResponseListResponse = out
		}
	}

	return res, nil
}

// UpdateVcdVappV1 - Update vApp
// Make changes to the parameters of a specified vApp object.
func (s *rootVcdVapp) UpdateVcdVappV1(ctx context.Context, request operations.UpdateVcdVappV1Request) (*operations.UpdateVcdVappV1Response, error) {
	baseURL := s.serverURL
	url, err := utils.GenerateURL(ctx, baseURL, "/vcd/vapp/{id}", request, nil)
	if err != nil {
		return nil, fmt.Errorf("error generating URL: %w", err)
	}

	bodyReader, reqContentType, err := utils.SerializeRequestBody(ctx, request, "VcdVappPatch", "json")
	if err != nil {
		return nil, fmt.Errorf("error serializing request body: %w", err)
	}
	if bodyReader == nil {
		return nil, fmt.Errorf("request body is required")
	}

	req, err := http.NewRequestWithContext(ctx, "PATCH", url, bodyReader)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	req.Header.Set("Content-Type", reqContentType)

	client := s.securityClient

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.UpdateVcdVappV1Response{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *shared.VcdVappDetail
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.VcdVappDetail = out
		}
	}

	return res, nil
}

// VcdMissedSnapshotsV1 - Get details about missed snapshots for a vApp
// Retrieve the timestamp for each missed snapshot for a specified vApp.
func (s *rootVcdVapp) VcdMissedSnapshotsV1(ctx context.Context, request operations.VcdMissedSnapshotsV1Request) (*operations.VcdMissedSnapshotsV1Response, error) {
	baseURL := s.serverURL
	url, err := utils.GenerateURL(ctx, baseURL, "/vcd/vapp/{id}/missed_snapshot", request, nil)
	if err != nil {
		return nil, fmt.Errorf("error generating URL: %w", err)
	}

	req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	client := s.securityClient

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.VcdMissedSnapshotsV1Response{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *shared.MissedSnapshotListResponse
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.MissedSnapshotListResponse = out
		}
	}

	return res, nil
}
