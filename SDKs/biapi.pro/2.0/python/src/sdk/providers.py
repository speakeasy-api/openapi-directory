"""Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT."""

import requests as requests_http
from . import utils
from sdk.models import operations, shared
from typing import Optional

class Providers:
    _client: requests_http.Session
    _security_client: requests_http.Session
    _server_url: str
    _language: str
    _sdk_version: str
    _gen_version: str

    def __init__(self, client: requests_http.Session, security_client: requests_http.Session, server_url: str, language: str, sdk_version: str, gen_version: str) -> None:
        self._client = client
        self._security_client = security_client
        self._server_url = server_url
        self._language = language
        self._sdk_version = sdk_version
        self._gen_version = gen_version
        
    def delete_connections_id_connection_sources_id_source_(self, request: operations.DeleteConnectionsIDConnectionSourcesIDSourceRequest) -> operations.DeleteConnectionsIDConnectionSourcesIDSourceResponse:
        r"""Disable a connection source
        This will make it so the specified source will not be synchronized anymore.<br><br>
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.DeleteConnectionsIDConnectionSourcesIDSourceRequest, base_url, '/connections/{id_connection}/sources/{id_source}', request)
        
        query_params = utils.get_query_params(operations.DeleteConnectionsIDConnectionSourcesIDSourceRequest, request)
        
        client = self._client
        
        http_res = client.request('DELETE', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DeleteConnectionsIDConnectionSourcesIDSourceResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ConnectionSource])
                res.connection_source = out

        return res

    def delete_connectors_id_connector_logos_id_logo_(self, request: operations.DeleteConnectorsIDConnectorLogosIDLogoRequest) -> operations.DeleteConnectorsIDConnectorLogosIDLogoResponse:
        r"""Delete a single Logo object."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.DeleteConnectorsIDConnectorLogosIDLogoRequest, base_url, '/connectors/{id_connector}/logos/{id_logo}', request)
        
        query_params = utils.get_query_params(operations.DeleteConnectorsIDConnectorLogosIDLogoRequest, request)
        
        client = self._client
        
        http_res = client.request('DELETE', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DeleteConnectorsIDConnectorLogosIDLogoResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ConnectorLogo])
                res.connector_logo = out

        return res

    def delete_users_id_user_connections(self, request: operations.DeleteUsersIDUserConnectionsRequest) -> operations.DeleteUsersIDUserConnectionsResponse:
        r"""Delete all connections"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.DeleteUsersIDUserConnectionsRequest, base_url, '/users/{id_user}/connections', request)
        
        query_params = utils.get_query_params(operations.DeleteUsersIDUserConnectionsRequest, request)
        
        client = self._client
        
        http_res = client.request('DELETE', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DeleteUsersIDUserConnectionsResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Connection])
                res.connection = out

        return res

    def delete_users_id_user_connections_id_connection_(self, request: operations.DeleteUsersIDUserConnectionsIDConnectionRequest) -> operations.DeleteUsersIDUserConnectionsIDConnectionResponse:
        r"""Delete a connection.
        This endpoint deletes a connection and all related accounts and transactions.<br><br>
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.DeleteUsersIDUserConnectionsIDConnectionRequest, base_url, '/users/{id_user}/connections/{id_connection}', request)
        
        query_params = utils.get_query_params(operations.DeleteUsersIDUserConnectionsIDConnectionRequest, request)
        
        client = self._client
        
        http_res = client.request('DELETE', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DeleteUsersIDUserConnectionsIDConnectionResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Connection])
                res.connection = out

        return res

    def delete_users_id_user_connections_id_connection_sources_id_source_(self, request: operations.DeleteUsersIDUserConnectionsIDConnectionSourcesIDSourceRequest) -> operations.DeleteUsersIDUserConnectionsIDConnectionSourcesIDSourceResponse:
        r"""Disable a connection source
        This will make it so the specified source will not be synchronized anymore.<br><br>
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.DeleteUsersIDUserConnectionsIDConnectionSourcesIDSourceRequest, base_url, '/users/{id_user}/connections/{id_connection}/sources/{id_source}', request)
        
        query_params = utils.get_query_params(operations.DeleteUsersIDUserConnectionsIDConnectionSourcesIDSourceRequest, request)
        
        client = self._client
        
        http_res = client.request('DELETE', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DeleteUsersIDUserConnectionsIDConnectionSourcesIDSourceResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ConnectionSource])
                res.connection_source = out

        return res

    def get_banks(self, request: operations.GetBanksRequest) -> operations.GetBanksResponse:
        r"""Get list of connectors"""
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/banks'
        
        query_params = utils.get_query_params(operations.GetBanksRequest, request)
        
        client = self._client
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetBanksResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.GetBanks200ApplicationJSON])
                res.get_banks_200_application_json_object = out

        return res

    def get_banks_id_bank_(self, request: operations.GetBanksIDBankRequest) -> operations.GetBanksIDBankResponse:
        r"""Get a connector"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.GetBanksIDBankRequest, base_url, '/banks/{id_bank}', request)
        
        query_params = utils.get_query_params(operations.GetBanksIDBankRequest, request)
        
        client = self._client
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetBanksIDBankResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Connector])
                res.connector = out

        return res

    def get_banks_id_connector_logos(self, request: operations.GetBanksIDConnectorLogosRequest) -> operations.GetBanksIDConnectorLogosResponse:
        r"""Get all links to the files associated with this connector.
        This endpoint returns all links to files associated with this connector.<br><br>
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.GetBanksIDConnectorLogosRequest, base_url, '/banks/{id_connector}/logos', request)
        
        query_params = utils.get_query_params(operations.GetBanksIDConnectorLogosRequest, request)
        
        client = self._client
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetBanksIDConnectorLogosResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.GetBanksIDConnectorLogos200ApplicationJSON])
                res.get_banks_id_connector_logos_200_application_json_object = out

        return res

    def get_banks_id_connector_logos_main(self, request: operations.GetBanksIDConnectorLogosMainRequest) -> operations.GetBanksIDConnectorLogosMainResponse:
        r"""Get all links to the files associated with this connector.
        This endpoint returns all links to files associated with this connector.<br><br>
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.GetBanksIDConnectorLogosMainRequest, base_url, '/banks/{id_connector}/logos/main', request)
        
        query_params = utils.get_query_params(operations.GetBanksIDConnectorLogosMainRequest, request)
        
        client = self._client
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetBanksIDConnectorLogosMainResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.GetBanksIDConnectorLogosMain200ApplicationJSON])
                res.get_banks_id_connector_logos_main_200_application_json_object = out

        return res

    def get_banks_id_connector_logos_thumbnail(self, request: operations.GetBanksIDConnectorLogosThumbnailRequest) -> operations.GetBanksIDConnectorLogosThumbnailResponse:
        r"""Get all links to the files associated with this connector.
        This endpoint returns all links to files associated with this connector.<br><br>
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.GetBanksIDConnectorLogosThumbnailRequest, base_url, '/banks/{id_connector}/logos/thumbnail', request)
        
        query_params = utils.get_query_params(operations.GetBanksIDConnectorLogosThumbnailRequest, request)
        
        client = self._client
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetBanksIDConnectorLogosThumbnailResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.GetBanksIDConnectorLogosThumbnail200ApplicationJSON])
                res.get_banks_id_connector_logos_thumbnail_200_application_json_object = out

        return res

    def get_banks_id_connector_sources(self, request: operations.GetBanksIDConnectorSourcesRequest) -> operations.GetBanksIDConnectorSourcesResponse:
        r"""Get list of connector sources"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.GetBanksIDConnectorSourcesRequest, base_url, '/banks/{id_connector}/sources', request)
        
        query_params = utils.get_query_params(operations.GetBanksIDConnectorSourcesRequest, request)
        
        client = self._client
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetBanksIDConnectorSourcesResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.GetBanksIDConnectorSources200ApplicationJSON])
                res.get_banks_id_connector_sources_200_application_json_object = out

        return res

    def get_banks_id_connector_sources_id_source_(self, request: operations.GetBanksIDConnectorSourcesIDSourceRequest) -> operations.GetBanksIDConnectorSourcesIDSourceResponse:
        r"""Get the connector source"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.GetBanksIDConnectorSourcesIDSourceRequest, base_url, '/banks/{id_connector}/sources/{id_source}', request)
        
        query_params = utils.get_query_params(operations.GetBanksIDConnectorSourcesIDSourceRequest, request)
        
        client = self._client
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetBanksIDConnectorSourcesIDSourceResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ConnectorSource])
                res.connector_source = out

        return res

    def get_connections(self, request: operations.GetConnectionsRequest) -> operations.GetConnectionsResponse:
        r"""Get connections without a user"""
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/connections'
        
        query_params = utils.get_query_params(operations.GetConnectionsRequest, request)
        
        client = self._client
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetConnectionsResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.GetConnections200ApplicationJSON])
                res.get_connections_200_application_json_object = out

        return res

    def get_connections_id_connection_logs(self, request: operations.GetConnectionsIDConnectionLogsRequest) -> operations.GetConnectionsIDConnectionLogsResponse:
        r"""Get connection logs
        Get logs about connections.<br><br>
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.GetConnectionsIDConnectionLogsRequest, base_url, '/connections/{id_connection}/logs', request)
        
        query_params = utils.get_query_params(operations.GetConnectionsIDConnectionLogsRequest, request)
        
        client = self._client
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetConnectionsIDConnectionLogsResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.GetConnectionsIDConnectionLogs200ApplicationJSON])
                res.get_connections_id_connection_logs_200_application_json_object = out

        return res

    def get_connections_id_connection_sources(self, request: operations.GetConnectionsIDConnectionSourcesRequest) -> operations.GetConnectionsIDConnectionSourcesResponse:
        r"""Get connection sources"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.GetConnectionsIDConnectionSourcesRequest, base_url, '/connections/{id_connection}/sources', request)
        
        query_params = utils.get_query_params(operations.GetConnectionsIDConnectionSourcesRequest, request)
        
        client = self._client
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetConnectionsIDConnectionSourcesResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.GetConnectionsIDConnectionSources200ApplicationJSON])
                res.get_connections_id_connection_sources_200_application_json_object = out

        return res

    def get_connectors(self, request: operations.GetConnectorsRequest) -> operations.GetConnectorsResponse:
        r"""Get list of connectors"""
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/connectors'
        
        query_params = utils.get_query_params(operations.GetConnectorsRequest, request)
        
        client = self._client
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetConnectorsResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.GetConnectors200ApplicationJSON])
                res.get_connectors_200_application_json_object = out

        return res

    def get_connectors_id_connector_(self, request: operations.GetConnectorsIDConnectorRequest) -> operations.GetConnectorsIDConnectorResponse:
        r"""Get a connector"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.GetConnectorsIDConnectorRequest, base_url, '/connectors/{id_connector}', request)
        
        query_params = utils.get_query_params(operations.GetConnectorsIDConnectorRequest, request)
        
        client = self._client
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetConnectorsIDConnectorResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Connector])
                res.connector = out

        return res

    def get_connectors_id_connector_logos(self, request: operations.GetConnectorsIDConnectorLogosRequest) -> operations.GetConnectorsIDConnectorLogosResponse:
        r"""Get all links to the files associated with this connector.
        This endpoint returns all links to files associated with this connector.<br><br>
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.GetConnectorsIDConnectorLogosRequest, base_url, '/connectors/{id_connector}/logos', request)
        
        query_params = utils.get_query_params(operations.GetConnectorsIDConnectorLogosRequest, request)
        
        client = self._client
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetConnectorsIDConnectorLogosResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.GetConnectorsIDConnectorLogos200ApplicationJSON])
                res.get_connectors_id_connector_logos_200_application_json_object = out

        return res

    def get_connectors_id_connector_logos_main(self, request: operations.GetConnectorsIDConnectorLogosMainRequest) -> operations.GetConnectorsIDConnectorLogosMainResponse:
        r"""Get all links to the files associated with this connector.
        This endpoint returns all links to files associated with this connector.<br><br>
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.GetConnectorsIDConnectorLogosMainRequest, base_url, '/connectors/{id_connector}/logos/main', request)
        
        query_params = utils.get_query_params(operations.GetConnectorsIDConnectorLogosMainRequest, request)
        
        client = self._client
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetConnectorsIDConnectorLogosMainResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.GetConnectorsIDConnectorLogosMain200ApplicationJSON])
                res.get_connectors_id_connector_logos_main_200_application_json_object = out

        return res

    def get_connectors_id_connector_logos_thumbnail(self, request: operations.GetConnectorsIDConnectorLogosThumbnailRequest) -> operations.GetConnectorsIDConnectorLogosThumbnailResponse:
        r"""Get all links to the files associated with this connector.
        This endpoint returns all links to files associated with this connector.<br><br>
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.GetConnectorsIDConnectorLogosThumbnailRequest, base_url, '/connectors/{id_connector}/logos/thumbnail', request)
        
        query_params = utils.get_query_params(operations.GetConnectorsIDConnectorLogosThumbnailRequest, request)
        
        client = self._client
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetConnectorsIDConnectorLogosThumbnailResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.GetConnectorsIDConnectorLogosThumbnail200ApplicationJSON])
                res.get_connectors_id_connector_logos_thumbnail_200_application_json_object = out

        return res

    def get_connectors_id_connector_sources(self, request: operations.GetConnectorsIDConnectorSourcesRequest) -> operations.GetConnectorsIDConnectorSourcesResponse:
        r"""Get list of connector sources"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.GetConnectorsIDConnectorSourcesRequest, base_url, '/connectors/{id_connector}/sources', request)
        
        query_params = utils.get_query_params(operations.GetConnectorsIDConnectorSourcesRequest, request)
        
        client = self._client
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetConnectorsIDConnectorSourcesResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.GetConnectorsIDConnectorSources200ApplicationJSON])
                res.get_connectors_id_connector_sources_200_application_json_object = out

        return res

    def get_connectors_id_connector_sources_id_source_(self, request: operations.GetConnectorsIDConnectorSourcesIDSourceRequest) -> operations.GetConnectorsIDConnectorSourcesIDSourceResponse:
        r"""Get the connector source"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.GetConnectorsIDConnectorSourcesIDSourceRequest, base_url, '/connectors/{id_connector}/sources/{id_source}', request)
        
        query_params = utils.get_query_params(operations.GetConnectorsIDConnectorSourcesIDSourceRequest, request)
        
        client = self._client
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetConnectorsIDConnectorSourcesIDSourceResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ConnectorSource])
                res.connector_source = out

        return res

    def get_logs(self, request: operations.GetLogsRequest) -> operations.GetLogsResponse:
        r"""Get connection logs
        Get logs about connections.<br><br>
        """
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/logs'
        
        query_params = utils.get_query_params(operations.GetLogsRequest, request)
        
        client = self._client
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetLogsResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.GetLogs200ApplicationJSON])
                res.get_logs_200_application_json_object = out

        return res

    def get_providers(self, request: operations.GetProvidersRequest) -> operations.GetProvidersResponse:
        r"""Get list of connectors"""
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/providers'
        
        query_params = utils.get_query_params(operations.GetProvidersRequest, request)
        
        client = self._client
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetProvidersResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.GetProviders200ApplicationJSON])
                res.get_providers_200_application_json_object = out

        return res

    def get_providers_id_connector_logos(self, request: operations.GetProvidersIDConnectorLogosRequest) -> operations.GetProvidersIDConnectorLogosResponse:
        r"""Get all links to the files associated with this connector.
        This endpoint returns all links to files associated with this connector.<br><br>
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.GetProvidersIDConnectorLogosRequest, base_url, '/providers/{id_connector}/logos', request)
        
        query_params = utils.get_query_params(operations.GetProvidersIDConnectorLogosRequest, request)
        
        client = self._client
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetProvidersIDConnectorLogosResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.GetProvidersIDConnectorLogos200ApplicationJSON])
                res.get_providers_id_connector_logos_200_application_json_object = out

        return res

    def get_providers_id_connector_logos_main(self, request: operations.GetProvidersIDConnectorLogosMainRequest) -> operations.GetProvidersIDConnectorLogosMainResponse:
        r"""Get all links to the files associated with this connector.
        This endpoint returns all links to files associated with this connector.<br><br>
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.GetProvidersIDConnectorLogosMainRequest, base_url, '/providers/{id_connector}/logos/main', request)
        
        query_params = utils.get_query_params(operations.GetProvidersIDConnectorLogosMainRequest, request)
        
        client = self._client
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetProvidersIDConnectorLogosMainResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.GetProvidersIDConnectorLogosMain200ApplicationJSON])
                res.get_providers_id_connector_logos_main_200_application_json_object = out

        return res

    def get_providers_id_connector_logos_thumbnail(self, request: operations.GetProvidersIDConnectorLogosThumbnailRequest) -> operations.GetProvidersIDConnectorLogosThumbnailResponse:
        r"""Get all links to the files associated with this connector.
        This endpoint returns all links to files associated with this connector.<br><br>
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.GetProvidersIDConnectorLogosThumbnailRequest, base_url, '/providers/{id_connector}/logos/thumbnail', request)
        
        query_params = utils.get_query_params(operations.GetProvidersIDConnectorLogosThumbnailRequest, request)
        
        client = self._client
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetProvidersIDConnectorLogosThumbnailResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.GetProvidersIDConnectorLogosThumbnail200ApplicationJSON])
                res.get_providers_id_connector_logos_thumbnail_200_application_json_object = out

        return res

    def get_providers_id_connector_sources(self, request: operations.GetProvidersIDConnectorSourcesRequest) -> operations.GetProvidersIDConnectorSourcesResponse:
        r"""Get list of connector sources"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.GetProvidersIDConnectorSourcesRequest, base_url, '/providers/{id_connector}/sources', request)
        
        query_params = utils.get_query_params(operations.GetProvidersIDConnectorSourcesRequest, request)
        
        client = self._client
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetProvidersIDConnectorSourcesResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.GetProvidersIDConnectorSources200ApplicationJSON])
                res.get_providers_id_connector_sources_200_application_json_object = out

        return res

    def get_providers_id_connector_sources_id_source_(self, request: operations.GetProvidersIDConnectorSourcesIDSourceRequest) -> operations.GetProvidersIDConnectorSourcesIDSourceResponse:
        r"""Get the connector source"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.GetProvidersIDConnectorSourcesIDSourceRequest, base_url, '/providers/{id_connector}/sources/{id_source}', request)
        
        query_params = utils.get_query_params(operations.GetProvidersIDConnectorSourcesIDSourceRequest, request)
        
        client = self._client
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetProvidersIDConnectorSourcesIDSourceResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ConnectorSource])
                res.connector_source = out

        return res

    def get_providers_id_provider_(self, request: operations.GetProvidersIDProviderRequest) -> operations.GetProvidersIDProviderResponse:
        r"""Get a connector"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.GetProvidersIDProviderRequest, base_url, '/providers/{id_provider}', request)
        
        query_params = utils.get_query_params(operations.GetProvidersIDProviderRequest, request)
        
        client = self._client
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetProvidersIDProviderResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Connector])
                res.connector = out

        return res

    def get_users_id_user_connections(self, request: operations.GetUsersIDUserConnectionsRequest) -> operations.GetUsersIDUserConnectionsResponse:
        r"""Get connections"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.GetUsersIDUserConnectionsRequest, base_url, '/users/{id_user}/connections', request)
        
        query_params = utils.get_query_params(operations.GetUsersIDUserConnectionsRequest, request)
        
        client = self._client
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetUsersIDUserConnectionsResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.GetUsersIDUserConnections200ApplicationJSON])
                res.get_users_id_user_connections_200_application_json_object = out

        return res

    def get_users_id_user_connections_id_connection_informations(self, request: operations.GetUsersIDUserConnectionsIDConnectionInformationsRequest) -> operations.GetUsersIDUserConnectionsIDConnectionInformationsResponse:
        r"""Get connection additionnal informations
        <br><br>
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.GetUsersIDUserConnectionsIDConnectionInformationsRequest, base_url, '/users/{id_user}/connections/{id_connection}/informations', request)
        
        query_params = utils.get_query_params(operations.GetUsersIDUserConnectionsIDConnectionInformationsRequest, request)
        
        client = self._client
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetUsersIDUserConnectionsIDConnectionInformationsResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.GetUsersIDUserConnectionsIDConnectionInformations200ApplicationJSON])
                res.get_users_id_user_connections_id_connection_informations_200_application_json_object = out

        return res

    def get_users_id_user_connections_id_connection_logs(self, request: operations.GetUsersIDUserConnectionsIDConnectionLogsRequest) -> operations.GetUsersIDUserConnectionsIDConnectionLogsResponse:
        r"""Get connection logs
        Get logs about connections.<br><br>
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.GetUsersIDUserConnectionsIDConnectionLogsRequest, base_url, '/users/{id_user}/connections/{id_connection}/logs', request)
        
        query_params = utils.get_query_params(operations.GetUsersIDUserConnectionsIDConnectionLogsRequest, request)
        
        client = self._client
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetUsersIDUserConnectionsIDConnectionLogsResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.GetUsersIDUserConnectionsIDConnectionLogs200ApplicationJSON])
                res.get_users_id_user_connections_id_connection_logs_200_application_json_object = out

        return res

    def get_users_id_user_connections_id_connection_sources(self, request: operations.GetUsersIDUserConnectionsIDConnectionSourcesRequest) -> operations.GetUsersIDUserConnectionsIDConnectionSourcesResponse:
        r"""Get connection sources"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.GetUsersIDUserConnectionsIDConnectionSourcesRequest, base_url, '/users/{id_user}/connections/{id_connection}/sources', request)
        
        query_params = utils.get_query_params(operations.GetUsersIDUserConnectionsIDConnectionSourcesRequest, request)
        
        client = self._client
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetUsersIDUserConnectionsIDConnectionSourcesResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.GetUsersIDUserConnectionsIDConnectionSources200ApplicationJSON])
                res.get_users_id_user_connections_id_connection_sources_200_application_json_object = out

        return res

    def get_users_id_user_logs(self, request: operations.GetUsersIDUserLogsRequest) -> operations.GetUsersIDUserLogsResponse:
        r"""Get connection logs
        Get logs about connections.<br><br>
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.GetUsersIDUserLogsRequest, base_url, '/users/{id_user}/logs', request)
        
        query_params = utils.get_query_params(operations.GetUsersIDUserLogsRequest, request)
        
        client = self._client
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetUsersIDUserLogsResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.GetUsersIDUserLogs200ApplicationJSON])
                res.get_users_id_user_logs_200_application_json_object = out

        return res

    def post_connections_id_connection_sources_id_source_(self, request: operations.PostConnectionsIDConnectionSourcesIDSourceRequest) -> operations.PostConnectionsIDConnectionSourcesIDSourceResponse:
        r"""\\" 
        This endpoint is used to enable a source or force a synchronization on it.<br><br>
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.PostConnectionsIDConnectionSourcesIDSourceRequest, base_url, '/connections/{id_connection}/sources/{id_source}', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'multipart')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        query_params = utils.get_query_params(operations.PostConnectionsIDConnectionSourcesIDSourceRequest, request)
        
        client = self._client
        
        http_res = client.request('POST', url, params=query_params, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.PostConnectionsIDConnectionSourcesIDSourceResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ConnectionSource])
                res.connection_source = out

        return res

    def post_connectors(self, request: operations.PostConnectorsRequest) -> operations.PostConnectorsResponse:
        r"""Request a new connector
        Send a request to add a new connector<br><br>
        """
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/connectors'
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'multipart')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        query_params = utils.get_query_params(operations.PostConnectorsRequest, request)
        
        client = self._client
        
        http_res = client.request('POST', url, params=query_params, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.PostConnectorsResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Connector])
                res.connector = out

        return res

    def post_connectors_id_connector_logos(self, request: operations.PostConnectorsIDConnectorLogosRequest) -> operations.PostConnectorsIDConnectorLogosResponse:
        r"""Create a connector Logo
        This endpoint creates a connector logo. You can either pass a file to as a parameter to insert and link it with the connector or pass an id_file to link a connector with an existing file. Will fail if the file is already linked with that connector.<br><br>Form params: - id_file (integer): The id of the file to link with that connector. - img (string): Path to the image to link with that connector.<br><br>
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.PostConnectorsIDConnectorLogosRequest, base_url, '/connectors/{id_connector}/logos', request)
        
        query_params = utils.get_query_params(operations.PostConnectorsIDConnectorLogosRequest, request)
        
        client = self._client
        
        http_res = client.request('POST', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.PostConnectorsIDConnectorLogosResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ConnectorLogo])
                res.connector_logo = out

        return res

    def post_users_id_user_connections(self, request: operations.PostUsersIDUserConnectionsRequest) -> operations.PostUsersIDUserConnectionsResponse:
        r"""Add a new connection.
        Create a new connection to a given bank or provider. You have to give all needed parameters (use /banks/ID/fields or /providers/ID/fields to get them).<br><br>
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.PostUsersIDUserConnectionsRequest, base_url, '/users/{id_user}/connections', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'multipart')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        query_params = utils.get_query_params(operations.PostUsersIDUserConnectionsRequest, request)
        
        client = self._client
        
        http_res = client.request('POST', url, params=query_params, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.PostUsersIDUserConnectionsResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Connection])
                res.connection = out

        return res

    def post_users_id_user_connections_id_connection_(self, request: operations.PostUsersIDUserConnectionsIDConnectionRequest) -> operations.PostUsersIDUserConnectionsIDConnectionResponse:
        r"""Update a connection.
        Give new parameters to change on the configuration of this connection (for example \"password\").<br><br>It tests connection to website, and if it fails, a 400 response is given with the error code \"wrongpass\" or \"websiteUnavailable\".<br><br>You can also supply meta-parameters on connection, like 'active' or 'expire'.<br><br>It's possible to execute the update/synchronization in the background with a query parameter. If done in background this endpoint will respond with data that is not yet updated. To obtain updated data, polling is required as the the data will be filled in the background.<br><br>
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.PostUsersIDUserConnectionsIDConnectionRequest, base_url, '/users/{id_user}/connections/{id_connection}', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'multipart')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        query_params = utils.get_query_params(operations.PostUsersIDUserConnectionsIDConnectionRequest, request)
        
        client = self._client
        
        http_res = client.request('POST', url, params=query_params, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.PostUsersIDUserConnectionsIDConnectionResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Connection])
                res.connection = out

        return res

    def post_users_id_user_connections_id_connection_sources_id_source_(self, request: operations.PostUsersIDUserConnectionsIDConnectionSourcesIDSourceRequest) -> operations.PostUsersIDUserConnectionsIDConnectionSourcesIDSourceResponse:
        r"""\\" 
        This endpoint is used to enable a source or force a synchronization on it.<br><br>
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.PostUsersIDUserConnectionsIDConnectionSourcesIDSourceRequest, base_url, '/users/{id_user}/connections/{id_connection}/sources/{id_source}', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'multipart')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        query_params = utils.get_query_params(operations.PostUsersIDUserConnectionsIDConnectionSourcesIDSourceRequest, request)
        
        client = self._client
        
        http_res = client.request('POST', url, params=query_params, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.PostUsersIDUserConnectionsIDConnectionSourcesIDSourceResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ConnectionSource])
                res.connection_source = out

        return res

    def put_connections_id_connection_sources_id_source_(self, request: operations.PutConnectionsIDConnectionSourcesIDSourceRequest) -> operations.PutConnectionsIDConnectionSourcesIDSourceResponse:
        r"""Update connection source
        This endpoint is used to enable a source or force a synchronization on it.<br><br>
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.PutConnectionsIDConnectionSourcesIDSourceRequest, base_url, '/connections/{id_connection}/sources/{id_source}', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'multipart')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        query_params = utils.get_query_params(operations.PutConnectionsIDConnectionSourcesIDSourceRequest, request)
        
        client = self._client
        
        http_res = client.request('PUT', url, params=query_params, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.PutConnectionsIDConnectionSourcesIDSourceResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ConnectionSource])
                res.connection_source = out

        return res

    def put_connectors_id_connector_logos(self, request: operations.PutConnectorsIDConnectorLogosRequest) -> operations.PutConnectorsIDConnectorLogosResponse:
        r"""Create or Update a connector Logo
        This endpoint creates or update a connector logo. This logo is a mapping between a file (/file route) and a connector (/connectors route) or a provider (/providers route).<br><br>Form params: - id_file (integer): The id of the file to link with that connector.<br><br>
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.PutConnectorsIDConnectorLogosRequest, base_url, '/connectors/{id_connector}/logos', request)
        
        query_params = utils.get_query_params(operations.PutConnectorsIDConnectorLogosRequest, request)
        
        client = self._client
        
        http_res = client.request('PUT', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.PutConnectorsIDConnectorLogosResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ConnectorLogo])
                res.connector_logo = out

        return res

    def put_connectors_id_connector_logos_id_logo_(self, request: operations.PutConnectorsIDConnectorLogosIDLogoRequest) -> operations.PutConnectorsIDConnectorLogosIDLogoResponse:
        r"""Create or Update a connector Logo.
        This endpoint creates or update a connector logo. This logo is a mapping between a file (/file route) and a connector (/connectors route) or a provider (/providers route).<br><br>Form params: - id_file (integer): The id of the file to link with that connector.<br><br>
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.PutConnectorsIDConnectorLogosIDLogoRequest, base_url, '/connectors/{id_connector}/logos/{id_logo}', request)
        
        query_params = utils.get_query_params(operations.PutConnectorsIDConnectorLogosIDLogoRequest, request)
        
        client = self._client
        
        http_res = client.request('PUT', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.PutConnectorsIDConnectorLogosIDLogoResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ConnectorLogo])
                res.connector_logo = out

        return res

    def put_connectors_id_connector_sources(self, request: operations.PutConnectorsIDConnectorSourcesRequest) -> operations.PutConnectorsIDConnectorSourcesResponse:
        r"""Edit several connector sources"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.PutConnectorsIDConnectorSourcesRequest, base_url, '/connectors/{id_connector}/sources', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'multipart')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        query_params = utils.get_query_params(operations.PutConnectorsIDConnectorSourcesRequest, request)
        
        client = self._client
        
        http_res = client.request('PUT', url, params=query_params, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.PutConnectorsIDConnectorSourcesResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ConnectorSource])
                res.connector_source = out

        return res

    def put_connectors_id_connector_sources_id_source_(self, request: operations.PutConnectorsIDConnectorSourcesIDSourceRequest) -> operations.PutConnectorsIDConnectorSourcesIDSourceResponse:
        r"""Edit the provided connector source"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.PutConnectorsIDConnectorSourcesIDSourceRequest, base_url, '/connectors/{id_connector}/sources/{id_source}', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'multipart')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        query_params = utils.get_query_params(operations.PutConnectorsIDConnectorSourcesIDSourceRequest, request)
        
        client = self._client
        
        http_res = client.request('PUT', url, params=query_params, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.PutConnectorsIDConnectorSourcesIDSourceResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ConnectorSource])
                res.connector_source = out

        return res

    def put_users_id_user_connections_id_connection_(self, request: operations.PutUsersIDUserConnectionsIDConnectionRequest) -> operations.PutUsersIDUserConnectionsIDConnectionResponse:
        r"""Force synchronisation of a connection.
        We suggest to pass parameter expand=accounts[transactions] to get all *new* and *updated* transactions.<br><br>
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.PutUsersIDUserConnectionsIDConnectionRequest, base_url, '/users/{id_user}/connections/{id_connection}', request)
        
        query_params = utils.get_query_params(operations.PutUsersIDUserConnectionsIDConnectionRequest, request)
        
        client = self._client
        
        http_res = client.request('PUT', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.PutUsersIDUserConnectionsIDConnectionResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Connection])
                res.connection = out

        return res

    def put_users_id_user_connections_id_connection_sources_id_source_(self, request: operations.PutUsersIDUserConnectionsIDConnectionSourcesIDSourceRequest) -> operations.PutUsersIDUserConnectionsIDConnectionSourcesIDSourceResponse:
        r"""Update connection source
        This endpoint is used to enable a source or force a synchronization on it.<br><br>
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.PutUsersIDUserConnectionsIDConnectionSourcesIDSourceRequest, base_url, '/users/{id_user}/connections/{id_connection}/sources/{id_source}', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'multipart')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        query_params = utils.get_query_params(operations.PutUsersIDUserConnectionsIDConnectionSourcesIDSourceRequest, request)
        
        client = self._client
        
        http_res = client.request('PUT', url, params=query_params, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.PutUsersIDUserConnectionsIDConnectionSourcesIDSourceResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ConnectionSource])
                res.connection_source = out

        return res

    