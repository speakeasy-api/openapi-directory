"""Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT."""

import requests as requests_http
from . import utils
from sdk.models import operations, shared
from typing import Optional

class Audio:
    _client: requests_http.Session
    _security_client: requests_http.Session
    _server_url: str
    _language: str
    _sdk_version: str
    _gen_version: str

    def __init__(self, client: requests_http.Session, security_client: requests_http.Session, server_url: str, language: str, sdk_version: str, gen_version: str) -> None:
        self._client = client
        self._security_client = security_client
        self._server_url = server_url
        self._language = language
        self._sdk_version = sdk_version
        self._gen_version = gen_version
        
    def add_track_collection_items(self, request: operations.AddTrackCollectionItemsRequest, security: operations.AddTrackCollectionItemsSecurity) -> operations.AddTrackCollectionItemsResponse:
        r"""Add audio tracks to collections
        This endpoint adds one or more tracks to a collection by track IDs.
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.AddTrackCollectionItemsRequest, base_url, '/v2/audio/collections/{id}/items', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "collection_item_request", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.AddTrackCollectionItemsResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        

        return res

    def create_track_collection(self, request: shared.CollectionCreateRequest, security: operations.CreateTrackCollectionSecurity) -> operations.CreateTrackCollectionResponse:
        r"""Create audio collections
        This endpoint creates one or more collections (soundboxes). To add tracks, use `POST /v2/audio/collections/{id}/items`.
        """
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/v2/audio/collections'
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.CreateTrackCollectionResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 201:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.CollectionCreateResponse])
                res.collection_create_response = out
        elif http_res.status_code in [400, 401, 403]:
            pass

        return res

    def delete_track_collection(self, request: operations.DeleteTrackCollectionRequest, security: operations.DeleteTrackCollectionSecurity) -> operations.DeleteTrackCollectionResponse:
        r"""Delete audio collections
        This endpoint deletes a collection.
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.DeleteTrackCollectionRequest, base_url, '/v2/audio/collections/{id}', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('DELETE', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DeleteTrackCollectionResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        

        return res

    def delete_track_collection_items(self, request: operations.DeleteTrackCollectionItemsRequest, security: operations.DeleteTrackCollectionItemsSecurity) -> operations.DeleteTrackCollectionItemsResponse:
        r"""Remove audio tracks from collections
        This endpoint removes one or more tracks from a collection.
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.DeleteTrackCollectionItemsRequest, base_url, '/v2/audio/collections/{id}/items', request)
        
        query_params = utils.get_query_params(operations.DeleteTrackCollectionItemsRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('DELETE', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DeleteTrackCollectionItemsResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        

        return res

    def download_tracks(self, request: operations.DownloadTracksRequest, security: operations.DownloadTracksSecurity) -> operations.DownloadTracksResponse:
        r"""Download audio tracks
        This endpoint redownloads tracks that you have already received a license for. The download links in the response are valid for 8 hours.
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.DownloadTracksRequest, base_url, '/v2/audio/licenses/{id}/downloads', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DownloadTracksResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.AudioURL])
                res.audio_url = out
        elif http_res.status_code in [400, 401, 403]:
            pass

        return res

    def get_track(self, request: operations.GetTrackRequest, security: operations.GetTrackSecurity) -> operations.GetTrackResponse:
        r"""Get details about audio tracks
        This endpoint shows information about a track, including its genres, instruments, and other attributes.
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.GetTrackRequest, base_url, '/v2/audio/{id}', request)
        
        query_params = utils.get_query_params(operations.GetTrackRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetTrackResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Audio])
                res.audio = out
        elif http_res.status_code in [400, 401, 403]:
            pass

        return res

    def get_track_collection(self, request: operations.GetTrackCollectionRequest, security: operations.GetTrackCollectionSecurity) -> operations.GetTrackCollectionResponse:
        r"""Get the details of audio collections
        This endpoint gets more detailed information about a collection, including the number of items in it and when it was last updated. To get the tracks in collections, use `GET /v2/audio/collections/{id}/items`.
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.GetTrackCollectionRequest, base_url, '/v2/audio/collections/{id}', request)
        
        query_params = utils.get_query_params(operations.GetTrackCollectionRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetTrackCollectionResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Collection])
                res.collection = out
        elif http_res.status_code in [400, 401, 403, 404]:
            pass

        return res

    def get_track_collection_items(self, request: operations.GetTrackCollectionItemsRequest, security: operations.GetTrackCollectionItemsSecurity) -> operations.GetTrackCollectionItemsResponse:
        r"""Get the contents of audio collections
        This endpoint lists the IDs of tracks in a collection and the date that each was added.
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.GetTrackCollectionItemsRequest, base_url, '/v2/audio/collections/{id}/items', request)
        
        query_params = utils.get_query_params(operations.GetTrackCollectionItemsRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetTrackCollectionItemsResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.CollectionItemDataList])
                res.collection_item_data_list = out
        elif http_res.status_code in [400, 401, 403, 404]:
            pass

        return res

    def get_track_collection_list(self, request: operations.GetTrackCollectionListRequest, security: operations.GetTrackCollectionListSecurity) -> operations.GetTrackCollectionListResponse:
        r"""List audio collections
        This endpoint lists your collections of audio tracks and their basic attributes.
        """
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/v2/audio/collections'
        
        query_params = utils.get_query_params(operations.GetTrackCollectionListRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetTrackCollectionListResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.CollectionDataList])
                res.collection_data_list = out
        elif http_res.status_code in [400, 401, 403]:
            pass

        return res

    def get_track_license_list(self, request: operations.GetTrackLicenseListRequest, security: operations.GetTrackLicenseListSecurity) -> operations.GetTrackLicenseListResponse:
        r"""List audio licenses
        This endpoint lists existing licenses. You can filter the results according to the track ID to see if you have an existing license for a specific track.
        """
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/v2/audio/licenses'
        
        query_params = utils.get_query_params(operations.GetTrackLicenseListRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetTrackLicenseListResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.DownloadHistoryDataList])
                res.download_history_data_list = out
        elif http_res.status_code in [400, 401, 403]:
            pass

        return res

    def get_track_list(self, request: operations.GetTrackListRequest, security: operations.GetTrackListSecurity) -> operations.GetTrackListResponse:
        r"""List audio tracks
        This endpoint lists information about one or more audio tracks, including the description and publication date.
        """
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/v2/audio'
        
        query_params = utils.get_query_params(operations.GetTrackListRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetTrackListResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.AudioDataList])
                res.audio_data_list = out
        elif http_res.status_code in [400, 401, 403]:
            pass

        return res

    def license_track(self, request: operations.LicenseTrackRequest, security: operations.LicenseTrackSecurity) -> operations.LicenseTrackResponse:
        r"""License audio tracks
        This endpoint gets licenses for one or more tracks. The download links in the response are valid for 8 hours.
        """
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/v2/audio/licenses'
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "license_audio_request", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        query_params = utils.get_query_params(operations.LicenseTrackRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, params=query_params, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.LicenseTrackResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.LicenseAudioResultDataList])
                res.license_audio_result_data_list = out
        elif http_res.status_code in [400, 401, 403]:
            pass

        return res

    def list_genres(self, request: operations.ListGenresRequest, security: operations.ListGenresSecurity) -> operations.ListGenresResponse:
        r"""List audio genres
        This endpoint returns a list of all audio genres.
        """
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/v2/audio/genres'
        
        query_params = utils.get_query_params(operations.ListGenresRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ListGenresResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.GenreList])
                res.genre_list = out

        return res

    def list_instruments(self, request: operations.ListInstrumentsRequest, security: operations.ListInstrumentsSecurity) -> operations.ListInstrumentsResponse:
        r"""List audio instruments
        This endpoint returns a list of all audio instruments.
        """
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/v2/audio/instruments'
        
        query_params = utils.get_query_params(operations.ListInstrumentsRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ListInstrumentsResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.InstrumentList])
                res.instrument_list = out

        return res

    def list_moods(self, request: operations.ListMoodsRequest, security: operations.ListMoodsSecurity) -> operations.ListMoodsResponse:
        r"""List audio moods
        This endpoint returns a list of all audio moods.
        """
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/v2/audio/moods'
        
        query_params = utils.get_query_params(operations.ListMoodsRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ListMoodsResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.MoodList])
                res.mood_list = out

        return res

    def rename_track_collection(self, request: operations.RenameTrackCollectionRequest, security: operations.RenameTrackCollectionSecurity) -> operations.RenameTrackCollectionResponse:
        r"""Rename audio collections
        This endpoint sets a new name for a collection.
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.RenameTrackCollectionRequest, base_url, '/v2/audio/collections/{id}', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "collection_update_request", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.RenameTrackCollectionResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        

        return res

    def search_tracks(self, request: operations.SearchTracksRequest, security: operations.SearchTracksSecurity) -> operations.SearchTracksResponse:
        r"""Search for tracks
        This endpoint searches for tracks. If you specify more than one search parameter, the API uses an AND condition. Array parameters can be specified multiple times; in this case, the API uses an AND or an OR condition with those values, depending on the parameter.
        """
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/v2/audio/search'
        
        query_params = utils.get_query_params(operations.SearchTracksRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.SearchTracksResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.AudioSearchResults])
                res.audio_search_results = out
        elif http_res.status_code in [400, 401, 403]:
            pass

        return res

    