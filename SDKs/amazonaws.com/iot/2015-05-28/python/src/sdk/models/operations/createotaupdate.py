"""Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT."""

from __future__ import annotations
import dataclasses
import requests as requests_http
from ..shared import awsjobabortcriteria as shared_awsjobabortcriteria
from ..shared import awsjobexponentialrolloutrate as shared_awsjobexponentialrolloutrate
from ..shared import createotaupdateresponse as shared_createotaupdateresponse
from ..shared import otaupdatefile as shared_otaupdatefile
from ..shared import protocol_enum as shared_protocol_enum
from ..shared import tag as shared_tag
from dataclasses_json import Undefined, dataclass_json
from enum import Enum
from sdk import utils
from typing import Any, Optional


@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class CreateOTAUpdateRequestBodyAwsJobAbortConfig:
    r"""The criteria that determine when and how a job abort takes place."""
    
    abort_criteria_list: Optional[list[shared_awsjobabortcriteria.AwsJobAbortCriteria]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('abortCriteriaList'), 'exclude': lambda f: f is None }})  
    

@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class CreateOTAUpdateRequestBodyAwsJobExecutionsRolloutConfig:
    r"""Configuration for the rollout of OTA updates."""
    
    exponential_rate: Optional[shared_awsjobexponentialrolloutrate.AwsJobExponentialRolloutRate] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('exponentialRate'), 'exclude': lambda f: f is None }})  
    maximum_per_minute: Optional[int] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('maximumPerMinute'), 'exclude': lambda f: f is None }})  
    

@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class CreateOTAUpdateRequestBodyAwsJobPresignedURLConfig:
    r"""Configuration information for pre-signed URLs. Valid when <code>protocols</code> contains HTTP."""
    
    expires_in_sec: Optional[int] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('expiresInSec'), 'exclude': lambda f: f is None }})  
    

@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class CreateOTAUpdateRequestBodyAwsJobTimeoutConfig:
    r"""Specifies the amount of time each device has to finish its execution of the job. A timer is started when the job execution status is set to <code>IN_PROGRESS</code>. If the job execution status is not set to another terminal state before the timer expires, it will be automatically set to <code>TIMED_OUT</code>."""
    
    in_progress_timeout_in_minutes: Optional[int] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('inProgressTimeoutInMinutes'), 'exclude': lambda f: f is None }})  
    
class CreateOTAUpdateRequestBodyTargetSelectionEnum(str, Enum):
    r"""Specifies whether the update will continue to run (CONTINUOUS), or will be complete after all the things specified as targets have completed the update (SNAPSHOT). If continuous, the update may also be run on a thing when a change is detected in a target. For example, an update will run on a thing when the thing is added to a target group, even after the update was completed by all things originally in the group. Valid values: CONTINUOUS | SNAPSHOT."""
    CONTINUOUS = 'CONTINUOUS'
    SNAPSHOT = 'SNAPSHOT'


@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class CreateOTAUpdateRequestBody:
    
    files: list[shared_otaupdatefile.OTAUpdateFile] = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('files') }})
    r"""The files to be streamed by the OTA update."""  
    role_arn: str = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('roleArn') }})
    r"""The IAM role that grants Amazon Web Services IoT Core access to the Amazon S3, IoT jobs and Amazon Web Services Code Signing resources to create an OTA update job."""  
    targets: list[str] = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('targets') }})
    r"""The devices targeted to receive OTA updates."""  
    additional_parameters: Optional[dict[str, str]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('additionalParameters'), 'exclude': lambda f: f is None }})
    r"""A list of additional OTA update parameters which are name-value pairs."""  
    aws_job_abort_config: Optional[CreateOTAUpdateRequestBodyAwsJobAbortConfig] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('awsJobAbortConfig'), 'exclude': lambda f: f is None }})
    r"""The criteria that determine when and how a job abort takes place."""  
    aws_job_executions_rollout_config: Optional[CreateOTAUpdateRequestBodyAwsJobExecutionsRolloutConfig] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('awsJobExecutionsRolloutConfig'), 'exclude': lambda f: f is None }})
    r"""Configuration for the rollout of OTA updates."""  
    aws_job_presigned_url_config: Optional[CreateOTAUpdateRequestBodyAwsJobPresignedURLConfig] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('awsJobPresignedUrlConfig'), 'exclude': lambda f: f is None }})
    r"""Configuration information for pre-signed URLs. Valid when <code>protocols</code> contains HTTP."""  
    aws_job_timeout_config: Optional[CreateOTAUpdateRequestBodyAwsJobTimeoutConfig] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('awsJobTimeoutConfig'), 'exclude': lambda f: f is None }})
    r"""Specifies the amount of time each device has to finish its execution of the job. A timer is started when the job execution status is set to <code>IN_PROGRESS</code>. If the job execution status is not set to another terminal state before the timer expires, it will be automatically set to <code>TIMED_OUT</code>."""  
    description: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('description'), 'exclude': lambda f: f is None }})
    r"""The description of the OTA update."""  
    protocols: Optional[list[shared_protocol_enum.ProtocolEnum]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('protocols'), 'exclude': lambda f: f is None }})
    r"""The protocol used to transfer the OTA update image. Valid values are [HTTP], [MQTT], [HTTP, MQTT]. When both HTTP and MQTT are specified, the target device can choose the protocol."""  
    tags: Optional[list[shared_tag.Tag]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('tags'), 'exclude': lambda f: f is None }})
    r"""Metadata which can be used to manage updates."""  
    target_selection: Optional[CreateOTAUpdateRequestBodyTargetSelectionEnum] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('targetSelection'), 'exclude': lambda f: f is None }})
    r"""Specifies whether the update will continue to run (CONTINUOUS), or will be complete after all the things specified as targets have completed the update (SNAPSHOT). If continuous, the update may also be run on a thing when a change is detected in a target. For example, an update will run on a thing when the thing is added to a target group, even after the update was completed by all things originally in the group. Valid values: CONTINUOUS | SNAPSHOT."""  
    

@dataclasses.dataclass
class CreateOTAUpdateRequest:
    
    ota_update_id: str = dataclasses.field(metadata={'path_param': { 'field_name': 'otaUpdateId', 'style': 'simple', 'explode': False }})
    r"""The ID of the OTA update to be created."""  
    request_body: CreateOTAUpdateRequestBody = dataclasses.field(metadata={'request': { 'media_type': 'application/json' }})  
    x_amz_algorithm: Optional[str] = dataclasses.field(default=None, metadata={'header': { 'field_name': 'X-Amz-Algorithm', 'style': 'simple', 'explode': False }})  
    x_amz_content_sha256: Optional[str] = dataclasses.field(default=None, metadata={'header': { 'field_name': 'X-Amz-Content-Sha256', 'style': 'simple', 'explode': False }})  
    x_amz_credential: Optional[str] = dataclasses.field(default=None, metadata={'header': { 'field_name': 'X-Amz-Credential', 'style': 'simple', 'explode': False }})  
    x_amz_date: Optional[str] = dataclasses.field(default=None, metadata={'header': { 'field_name': 'X-Amz-Date', 'style': 'simple', 'explode': False }})  
    x_amz_security_token: Optional[str] = dataclasses.field(default=None, metadata={'header': { 'field_name': 'X-Amz-Security-Token', 'style': 'simple', 'explode': False }})  
    x_amz_signature: Optional[str] = dataclasses.field(default=None, metadata={'header': { 'field_name': 'X-Amz-Signature', 'style': 'simple', 'explode': False }})  
    x_amz_signed_headers: Optional[str] = dataclasses.field(default=None, metadata={'header': { 'field_name': 'X-Amz-SignedHeaders', 'style': 'simple', 'explode': False }})  
    

@dataclasses.dataclass
class CreateOTAUpdateResponse:
    
    content_type: str = dataclasses.field()  
    status_code: int = dataclasses.field()  
    create_ota_update_response: Optional[shared_createotaupdateresponse.CreateOTAUpdateResponse] = dataclasses.field(default=None)
    r"""Success"""  
    internal_failure_exception: Optional[Any] = dataclasses.field(default=None)
    r"""InternalFailureException"""  
    invalid_request_exception: Optional[Any] = dataclasses.field(default=None)
    r"""InvalidRequestException"""  
    limit_exceeded_exception: Optional[Any] = dataclasses.field(default=None)
    r"""LimitExceededException"""  
    raw_response: Optional[requests_http.Response] = dataclasses.field(default=None)  
    resource_already_exists_exception: Optional[Any] = dataclasses.field(default=None)
    r"""ResourceAlreadyExistsException"""  
    resource_not_found_exception: Optional[Any] = dataclasses.field(default=None)
    r"""ResourceNotFoundException"""  
    service_unavailable_exception: Optional[Any] = dataclasses.field(default=None)
    r"""ServiceUnavailableException"""  
    throttling_exception: Optional[Any] = dataclasses.field(default=None)
    r"""ThrottlingException"""  
    unauthorized_exception: Optional[Any] = dataclasses.field(default=None)
    r"""UnauthorizedException"""  
    