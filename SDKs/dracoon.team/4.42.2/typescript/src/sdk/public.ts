/*
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

import * as utils from "../internal/utils";
import * as operations from "./models/operations";
import * as shared from "./models/shared";
import { AxiosInstance, AxiosRequestConfig, AxiosResponse } from "axios";

/**
 * Public API (upload / download shares, software information)
 */
export class Public {
  _defaultClient: AxiosInstance;
  _securityClient: AxiosInstance;
  _serverURL: string;
  _language: string;
  _sdkVersion: string;
  _genVersion: string;

  constructor(
    defaultClient: AxiosInstance,
    securityClient: AxiosInstance,
    serverURL: string,
    language: string,
    sdkVersion: string,
    genVersion: string
  ) {
    this._defaultClient = defaultClient;
    this._securityClient = securityClient;
    this._serverURL = serverURL;
    this._language = language;
    this._sdkVersion = sdkVersion;
    this._genVersion = genVersion;
  }

  /**
   * Cancel file upload
   *
   * @remarks
   * ### Description:
   * Abort (chunked) upload via Upload Share.
   *
   * ### Precondition:
   * Valid Upload ID.
   *
   * ### Postcondition:
   * Aborts upload and invalidates upload ID / token.
   *
   * ### Further Information:
   * None.
   */
  cancelFileUploadViaShare(
    req: operations.CancelFileUploadViaShareRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.CancelFileUploadViaShareResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CancelFileUploadViaShareRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v4/public/shares/uploads/{access_key}/{upload_id}",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CancelFileUploadViaShareResponse =
        new operations.CancelFileUploadViaShareResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
        case [400, 404, 406, 504, 507].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorResponse = utils.objectToClass(
              httpRes?.data,
              shared.ErrorResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Check public Download Share password
   *
   * @remarks
   * <h3 style='padding: 5px; background-color: #F6F7F8; border: 1px solid #AAA; border-radius: 5px; display: table-cell;'>&#128640; Since v4.36.0</h3>
   *
   * ### Description:
   * Check password for a public Download Share
   *
   * ### Precondition:
   * None.
   *
   * ### Postcondition:
   * None.
   *
   * ### Further Information:
   * None.
   */
  checkPublicDownloadSharePassword(
    req: operations.CheckPublicDownloadSharePasswordRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.CheckPublicDownloadSharePasswordResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CheckPublicDownloadSharePasswordRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v4/public/shares/downloads/{access_key}",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "head",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CheckPublicDownloadSharePasswordResponse =
        new operations.CheckPublicDownloadSharePasswordResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case [200, 400, 401, 403, 404, 406].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Complete file upload
   *
   * @remarks
   * ### Description:
   * Finalize (chunked) upload via Upload Share.
   *
   * ### Precondition:
   * Valid upload ID.
   * Only returns users that owns one of the following permissions: <span style='padding: 3px; background-color: #F6F7F8; border: 1px solid #000; border-radius: 5px; display: inline;'>&#128275; manage</span>, <span style='padding: 3px; background-color: #F6F7F8; border: 1px solid #000; border-radius: 5px; display: inline;'>&#128275; read</span>, <span style='padding: 3px; background-color: #F6F7F8; border: 1px solid #000; border-radius: 5px; display: inline;'>&#128275; manage download share</span>, <span style='padding: 3px; background-color: #F6F7F8; border: 1px solid #000; border-radius: 5px; display: inline;'>&#128275; manage upload share</span>
   *
   * ### Postcondition:
   * Finalizes upload.
   *
   * ### Further Information:
   * Chunked uploads (range requests) are supported.
   *
   * Please ensure that all chunks have been transferred correctly before finishing the upload.
   * If file hash has been created in time a `201 Created` will be responded and hash will be part of response, otherwise it will be a `202 Accepted` without it.
   *
   *
   * @see {@link https://tools.ietf.org/html/rfc7233} - Range Requests
   */
  completeFileUploadViaShare(
    req: operations.CompleteFileUploadViaShareRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.CompleteFileUploadViaShareResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CompleteFileUploadViaShareRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v4/public/shares/uploads/{access_key}/{upload_id}",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "userFileKeyList",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };

    const r = client.request({
      url: url,
      method: "put",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CompleteFileUploadViaShareResponse =
        new operations.CompleteFileUploadViaShareResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case [201, 202].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.publicUploadedFileData = utils.objectToClass(
              httpRes?.data,
              shared.PublicUploadedFileData
            );
          }
          break;
        case [400, 403, 404, 406, 412, 504, 507].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorResponse = utils.objectToClass(
              httpRes?.data,
              shared.ErrorResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Complete S3 file upload
   *
   * @remarks
   * <h3 style='padding: 5px; background-color: #F6F7F8; border: 1px solid #AAA; border-radius: 5px; display: table-cell;'>&#128640; Since v4.15.0</h3>
   *
   * ### Description:
   * Finishes a S3 file upload and closes the corresponding upload channel.
   *
   * ### Precondition:
   * Valid upload ID.
   * Only returns users that owns one of the following permissions: <span style='padding: 3px; background-color: #F6F7F8; border: 1px solid #000; border-radius: 5px; display: inline;'>&#128275; manage</span>, <span style='padding: 3px; background-color: #F6F7F8; border: 1px solid #000; border-radius: 5px; display: inline;'>&#128275; read</span>, <span style='padding: 3px; background-color: #F6F7F8; border: 1px solid #000; border-radius: 5px; display: inline;'>&#128275; manage download share</span>, <span style='padding: 3px; background-color: #F6F7F8; border: 1px solid #000; border-radius: 5px; display: inline;'>&#128275; manage upload share</span>
   *
   * ### Postcondition:
   * Upload channel is closed. S3 multipart upload request is completed.
   *
   * ### Further Information:
   * None.
   *
   */
  completeS3FileUploadViaShare(
    req: operations.CompleteS3FileUploadViaShareRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.CompleteS3FileUploadViaShareResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CompleteS3FileUploadViaShareRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v4/public/shares/uploads/{access_key}/{upload_id}/s3",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "completeS3ShareUploadRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "put",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CompleteS3FileUploadViaShareResponse =
        new operations.CompleteS3FileUploadViaShareResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 202:
          break;
        case [400, 404, 406, 412].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorResponse = utils.objectToClass(
              httpRes?.data,
              shared.ErrorResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Create new file upload channel
   *
   * @remarks
   * ### Description:
   * Create a new upload channel.
   *
   * ### Precondition:
   * None.
   *
   * ### Postcondition:
   * Upload channel is created and corresponding upload URL, token & upload ID are returned.
   *
   * ### Further Information:
   * Use `uploadUrl` the upload `token` is deprecated.
   *
   * Please provide the size of the intended upload so that the quota can be checked in advanced and no data is transferred unnecessarily.
   *
   * ### Node naming convention:
   * * Node (room, folder, file) names are limited to **150** characters.
   * * Illegal names:
   * `'CON', 'PRN', 'AUX', 'NUL', 'COM1', 'COM2', 'COM3', 'COM4', 'COM5', 'COM6', 'COM7', 'COM8', 'COM9', 'LPT1', 'LPT2', 'LPT3', 'LPT4', 'LPT5', 'LPT6', 'LPT7', 'LPT8', 'LPT9', (and any of those with an extension)`
   * * Illegal characters in names:
   * `'\\', '<','>', ':', '\"', '|', '?', '*', '/', leading '-', trailing '.' `
   *
   */
  createShareUploadChannel(
    req: operations.CreateShareUploadChannelRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.CreateShareUploadChannelResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CreateShareUploadChannelRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v4/public/shares/uploads/{access_key}",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "createShareUploadChannelRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CreateShareUploadChannelResponse =
        new operations.CreateShareUploadChannelResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.createShareUploadChannelResponse = utils.objectToClass(
              httpRes?.data,
              shared.CreateShareUploadChannelResponse
            );
          }
          break;
        case [400, 401, 403, 404, 406, 412, 504, 507].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorResponse = utils.objectToClass(
              httpRes?.data,
              shared.ErrorResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Download file with token
   *
   * @remarks
   * ### Description:
   * Download a file (or zip archive if target is a folder or room).
   *
   * ### Precondition:
   * Valid download token.
   *
   * ### Postcondition:
   * Stream is returned.
   *
   * ### Further Information:
   * Range requests are supported.
   * Range requests are illegal for zip archive download.
   *
   * @see {@link https://tools.ietf.org/html/rfc7233} - Range Requests
   */
  downloadFileViaTokenPublic(
    req: operations.DownloadFileViaTokenPublicRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.DownloadFileViaTokenPublicResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DownloadFileViaTokenPublicRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v4/public/shares/downloads/{access_key}/{token}",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      headers: headers,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DownloadFileViaTokenPublicResponse =
        new operations.DownloadFileViaTokenPublicResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case [200, 206].includes(httpRes?.status):
          break;
        case [400, 404, 406, 416].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/octet-stream`)) {
            const resBody: string = JSON.stringify(httpRes?.data, null, 0);
            const out: Uint8Array = new Uint8Array(resBody.length);
            for (let i = 0; i < resBody.length; i++)
              out[i] = resBody.charCodeAt(i);
            res.body = out;
          }
          break;
      }

      return res;
    });
  }

  /**
   * Download file with token
   *
   * @remarks
   * ### Description:
   * Download a file (or zip archive if target is a folder or room).
   *
   * ### Precondition:
   * Valid download token.
   *
   * ### Postcondition:
   * Stream is returned.
   *
   * ### Further Information:
   * Range requests are supported.
   * Range requests are illegal for zip archive download.
   *
   * @see {@link https://tools.ietf.org/html/rfc7233} - Range Requests
   */
  downloadFileViaTokenPublic1(
    req: operations.DownloadFileViaTokenPublic1Request,
    config?: AxiosRequestConfig
  ): Promise<operations.DownloadFileViaTokenPublic1Response> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DownloadFileViaTokenPublic1Request(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v4/public/shares/downloads/{access_key}/{token}",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "head",
      headers: headers,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DownloadFileViaTokenPublic1Response =
        new operations.DownloadFileViaTokenPublic1Response({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case [200, 206].includes(httpRes?.status):
          break;
        case [400, 404, 406, 416].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/octet-stream`)) {
            const resBody: string = JSON.stringify(httpRes?.data, null, 0);
            const out: Uint8Array = new Uint8Array(resBody.length);
            for (let i = 0; i < resBody.length; i++)
              out[i] = resBody.charCodeAt(i);
            res.body = out;
          }
          break;
      }

      return res;
    });
  }

  /**
   * Generate download URL
   *
   * @remarks
   * ### Description:
   * Generate a download URL to retrieve a shared file.
   *
   * ### Precondition:
   * None.
   *
   * ### Postcondition:
   * Download URL and token are generated and returned.
   *
   * ### Further Information:
   * Use `downloadUrl` the download `token` is deprecated.
   */
  generateDownloadUrlPublic(
    req: operations.GenerateDownloadUrlPublicRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GenerateDownloadUrlPublicResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GenerateDownloadUrlPublicRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v4/public/shares/downloads/{access_key}",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "publicDownloadTokenGenerateRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GenerateDownloadUrlPublicResponse =
        new operations.GenerateDownloadUrlPublicResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.publicDownloadTokenGenerateResponse = utils.objectToClass(
              httpRes?.data,
              shared.PublicDownloadTokenGenerateResponse
            );
          }
          break;
        case [400, 401, 403, 404, 406].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorResponse = utils.objectToClass(
              httpRes?.data,
              shared.ErrorResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Generate presigned URLs for S3 file upload
   *
   * @remarks
   * <h3 style='padding: 5px; background-color: #F6F7F8; border: 1px solid #AAA; border-radius: 5px; display: table-cell;'>&#128640; Since v4.15.0</h3>
   *
   * ### Description:
   * Generate presigned URLs for S3 file upload.
   *
   * ### Precondition:
   * Valid upload ID
   *
   * ### Postcondition:
   * List of presigned URLs is returned.
   *
   * ### Further Information:
   * The size for each part must be >= 5 MB, except for the last part.
   * The part number of the first part in S3 is 1 (not 0).
   * Use HTTP method `PUT` for uploading bytes via presigned URL.
   */
  generatePresignedUrlsPublic(
    req: operations.GeneratePresignedUrlsPublicRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GeneratePresignedUrlsPublicResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GeneratePresignedUrlsPublicRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v4/public/shares/uploads/{access_key}/{upload_id}/s3_urls",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "generatePresignedUrlsRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GeneratePresignedUrlsPublicResponse =
        new operations.GeneratePresignedUrlsPublicResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.presignedUrlList = utils.objectToClass(
              httpRes?.data,
              shared.PresignedUrlList
            );
          }
          break;
        case [400, 403, 404, 406, 412, 504, 507].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorResponse = utils.objectToClass(
              httpRes?.data,
              shared.ErrorResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Request Active Directory authentication information
   *
   * @remarks
   * ### Description:
   * Provides information about Active Directory authentication options.
   *
   * ### Precondition:
   * None.
   *
   * ### Postcondition:
   * Active Directory authentication options information is returned.
   *
   * ### Further Information:
   * None.
   */
  requestActiveDirectoryAuthInfo(
    req: operations.RequestActiveDirectoryAuthInfoRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.RequestActiveDirectoryAuthInfoResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.RequestActiveDirectoryAuthInfoRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/v4/public/system/info/auth/ad";

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.RequestActiveDirectoryAuthInfoResponse =
        new operations.RequestActiveDirectoryAuthInfoResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.activeDirectoryAuthInfo = utils.objectToClass(
              httpRes?.data,
              shared.ActiveDirectoryAuthInfo
            );
          }
          break;
        case [400, 406].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorResponse = utils.objectToClass(
              httpRes?.data,
              shared.ErrorResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Request OpenID Connect provider authentication information
   *
   * @remarks
   * ### Description:
   * Provides information about OpenID Connect authentication options.
   *
   * ### Precondition:
   * None.
   *
   * ### Postcondition:
   * OpenID Connect authentication options information is returned.
   *
   * ### Further Information:
   * None.
   */
  requestOpenIdAuthInfo(
    req: operations.RequestOpenIdAuthInfoRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.RequestOpenIdAuthInfoResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.RequestOpenIdAuthInfoRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/v4/public/system/info/auth/openid";

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.RequestOpenIdAuthInfoResponse =
        new operations.RequestOpenIdAuthInfoResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.openIdAuthInfo = utils.objectToClass(
              httpRes?.data,
              shared.OpenIdAuthInfo
            );
          }
          break;
        case [400, 406].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorResponse = utils.objectToClass(
              httpRes?.data,
              shared.ErrorResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Request public Download Share information
   *
   * @remarks
   * ### Description:
   * Retrieve the public information of a Download Share.
   *
   * ### Precondition:
   * None.
   *
   * ### Postcondition:
   * Download Share information is returned.
   *
   * ### Further Information:
   * None.
   */
  requestPublicDownloadShareInfo(
    req: operations.RequestPublicDownloadShareInfoRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.RequestPublicDownloadShareInfoResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.RequestPublicDownloadShareInfoRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v4/public/shares/downloads/{access_key}",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };

    const r = client.request({
      url: url,
      method: "get",
      headers: headers,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.RequestPublicDownloadShareInfoResponse =
        new operations.RequestPublicDownloadShareInfoResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.publicDownloadShare = utils.objectToClass(
              httpRes?.data,
              shared.PublicDownloadShare
            );
          }
          break;
        case [400, 404, 406].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorResponse = utils.objectToClass(
              httpRes?.data,
              shared.ErrorResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Request public Upload Share information
   *
   * @remarks
   * ### Description:
   * Provides information about the desired Upload Share.
   *
   * ### Precondition:
   * Only `userUserPublicKeyList` is returned to the users who owns one of the following permissions: <span style='padding: 3px; background-color: #F6F7F8; border: 1px solid #000; border-radius: 5px; display: inline;'>&#128275; manage</span>, <span style='padding: 3px; background-color: #F6F7F8; border: 1px solid #000; border-radius: 5px; display: inline;'>&#128275; read</span>, <span style='padding: 3px; background-color: #F6F7F8; border: 1px solid #000; border-radius: 5px; display: inline;'>&#128275; manage download share</span>, <span style='padding: 3px; background-color: #F6F7F8; border: 1px solid #000; border-radius: 5px; display: inline;'>&#128275; manage upload share</span>
   *
   * ### Postcondition:
   * None.
   *
   * ### Further Information:
   * If no password is set, the returned information is reduced to the following attributes (if available):
   *
   * * `name`
   * * `createdAt`
   * * `isProtected`
   * * `isEncrypted`
   * * `showUploadedFiles`
   * * `userUserPublicKeyList` (if parent is end-to-end encrypted)
   *
   * Only if the password is transmitted as `X-Sds-Share-Password` header, all values are returned.
   *
   */
  requestPublicUploadShareInfo(
    req: operations.RequestPublicUploadShareInfoRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.RequestPublicUploadShareInfoResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.RequestPublicUploadShareInfoRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v4/public/shares/uploads/{access_key}",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };

    const r = client.request({
      url: url,
      method: "get",
      headers: headers,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.RequestPublicUploadShareInfoResponse =
        new operations.RequestPublicUploadShareInfoResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.publicUploadShare = utils.objectToClass(
              httpRes?.data,
              shared.PublicUploadShare
            );
          }
          break;
        case [400, 401, 404, 406].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorResponse = utils.objectToClass(
              httpRes?.data,
              shared.ErrorResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Request software version information
   *
   * @remarks
   * ### Description:
   * Public software version information.
   *
   * ### Precondition:
   * None.
   *
   * ### Postcondition:
   * Sofware version information is returned.
   *
   * ### Further Information:
   * The version of DRACOON Server consists of two components:
   * * **API**
   * * **Core** (referred to as _"Server"_)
   *
   * which are versioned individually.
   */
  requestSoftwareVersion(
    req: operations.RequestSoftwareVersionRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.RequestSoftwareVersionResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.RequestSoftwareVersionRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/v4/public/software/version";

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };

    const r = client.request({
      url: url,
      method: "get",
      headers: headers,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.RequestSoftwareVersionResponse =
        new operations.RequestSoftwareVersionResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.softwareVersionData = utils.objectToClass(
              httpRes?.data,
              shared.SoftwareVersionData
            );
          }
          break;
        case httpRes?.status == 406:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorResponse = utils.objectToClass(
              httpRes?.data,
              shared.ErrorResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Request system information
   *
   * @remarks
   * ### Description:
   * Provides information about system.
   *
   * ### Precondition:
   * None.
   *
   * ### Postcondition:
   * System information is returned.
   *
   * ### Further Information:
   * Authentication methods are sorted by **priority** attribute.
   * Smaller values have higher priority.
   * Authentication method with highest priority is considered as default.
   *
   * ### System information:
   * <details style="padding: 10px; background-color: #F6F7F8; border: 1px solid #AAA; border-radius: 5px;">
   * <summary style="cursor: pointer; outline: none"><strong>Expand</strong></summary>
   *
   * | Setting | Description | Value |
   * | :--- | :--- | :--- |
   * | `languageDefault` | Defines which language should be default. | `ISO 639-1 code` |
   * | `hideLoginInputFields` | Defines if login fields should be hidden. | `true or false` |
   * | `s3Hosts` | List of available S3 hosts. | `String array` |
   * | `s3EnforceDirectUpload` | Determines whether S3 direct upload is enforced or not. | `true or false` |
   * | `useS3Storage` | Determines whether S3 Storage enabled and used. | `true or false` |
   *
   * </details>
   *
   * ### Authentication methods:
   * <details style="padding: 10px; background-color: #F6F7F8; border: 1px solid #AAA; border-radius: 5px;">
   * <summary style="cursor: pointer; outline: none"><strong>Expand</strong></summary>
   *
   * | Authentication Method | Description |
   * | :--- | :--- |
   * | `basic` | **Basic** authentication globally allowed.<br>This option **MUST** be activated to allow users to log in with their credentials stored in the database.<br>Formerly known as `sql`. |
   * | `active_directory` | **Active Directory** authentication globally allowed.<br>This option **MUST** be activated to allow users to log in with their Active Directory credentials. |
   * | `radius` | **RADIUS** authentication globally allowed.<br>This option **MUST** be activated to allow users to log in with their RADIUS username, their PIN and a token password. |
   * | `openid` | **OpenID Connect** authentication globally allowed.This option **MUST** be activated to allow users to log in with their OpenID Connect identity. |
   * | `hideLoginInputFields` | Determines whether input fields for login should be enabled | `true or false` |
   *
   * </details>
   *
   * @see {@link https://tools.ietf.org/html/rfc5646} - Tags for Identifying Languages
   */
  requestSystemInfo(
    req: operations.RequestSystemInfoRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.RequestSystemInfoResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.RequestSystemInfoRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/v4/public/system/info";

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.RequestSystemInfoResponse =
        new operations.RequestSystemInfoResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.systemInfo = utils.objectToClass(
              httpRes?.data,
              shared.SystemInfo
            );
          }
          break;
        case [400, 406].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorResponse = utils.objectToClass(
              httpRes?.data,
              shared.ErrorResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Request system time
   *
   * @remarks
   * ### Description:
   * Retrieve the actual server time.
   *
   * ### Precondition:
   * None.
   *
   * ### Postcondition:
   * Server time is returned.
   *
   * ### Further Information:
   * None.
   */
  requestSystemTime(
    req: operations.RequestSystemTimeRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.RequestSystemTimeResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.RequestSystemTimeRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/v4/public/time";

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };

    const r = client.request({
      url: url,
      method: "get",
      headers: headers,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.RequestSystemTimeResponse =
        new operations.RequestSystemTimeResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.sdsServerTime = utils.objectToClass(
              httpRes?.data,
              shared.SdsServerTime
            );
          }
          break;
        case httpRes?.status == 406:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorResponse = utils.objectToClass(
              httpRes?.data,
              shared.ErrorResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Request third-party software dependencies
   *
   * @remarks
   * <h3 style='padding: 5px; background-color: #F6F7F8; border: 1px solid #AAA; border-radius: 5px; display: table-cell;'>&#128640; Since v4.9.0</h3>
   *
   * ### Description:
   * Provides information about used third-party software dependencies.
   *
   * ### Precondition:
   * None.
   *
   * ### Postcondition:
   * List of the third-party software dependencies used by **DRACOON Core** (referred to as _"Server"_) is returned.
   *
   * ### Further Information:
   * None.
   *
   *
   */
  requestThirdPartyDependencies(
    config?: AxiosRequestConfig
  ): Promise<operations.RequestThirdPartyDependenciesResponse> {
    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") +
      "/v4/public/software/third_party_dependencies";

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.RequestThirdPartyDependenciesResponse =
        new operations.RequestThirdPartyDependenciesResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.thirdPartyDependenciesData = [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.thirdPartyDependenciesData = utils.objectToClass(
              httpRes?.data,
              shared.ThirdPartyDependenciesData,
              resFieldDepth
            );
          }
          break;
        case httpRes?.status == 406:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorResponse = utils.objectToClass(
              httpRes?.data,
              shared.ErrorResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Request status of S3 file upload
   *
   * @remarks
   * <h3 style='padding: 5px; background-color: #F6F7F8; border: 1px solid #AAA; border-radius: 5px; display: table-cell;'>&#128640; Since v4.15.0</h3>
   *
   * ### Description:
   * Request status of a S3 file upload.
   *
   * ### Precondition:
   * An upload channel has been created and the user has <span style='padding: 3px; background-color: #F6F7F8; border: 1px solid #000; border-radius: 5px; display: inline;'>&#128275; create</span> permissions in the parent container (room or folder).
   *
   * ### Postcondition:
   * Status of S3 multipart upload request is returned.
   *
   * ### Further Information:
   * None.
   *
   * ### Possible errors:
   * <details style="padding: 10px; background-color: #F6F7F8; border: 1px solid #AAA; border-radius: 5px;">
   * <summary style="cursor: pointer; outline: none"><strong>Expand</strong></summary>
   *
   * | Http Status | Error Code | Description |
   * | :--- | :--- | :--- |
   * | `400 Bad Request` | `-80000` | Mandatory fields cannot be empty |
   * | `400 Bad Request` | `-80001` | Invalid positive number |
   * | `400 Bad Request` | `-80002` | Invalid number |
   * | `400 Bad Request` | `-40001` | (Target) room is not encrypted |
   * | `400 Bad Request` | `-40755` | Bad file name |
   * | `400 Bad Request` | `-40763` | File key must be set for an upload into encrypted room |
   * | `400 Bad Request` | `-50506` | Exceeds the number of files for this Upload Share |
   * | `403 Forbidden` |  | Access denied |
   * | `404 Not Found` | `-20501` | Upload not found |
   * | `404 Not Found` | `-40000` | Container not found |
   * | `404 Not Found` | `-41000` | Node not found |
   * | `404 Not Found` | `-70501` | User not found |
   * | `409 Conflict` | `-40010` | Container cannot be overwritten |
   * | `409 Conflict` |  | File cannot be overwritten |
   * | `500 Internal Server Error` |  | System Error |
   * | `502 Bad Gateway` |  | S3 Error |
   * | `502 Insufficient Storage` | `-50504` | Exceeds the quota for this Upload Share |
   * | `502 Insufficient Storage` | `-40200` | Exceeds the free node quota in room |
   * | `502 Insufficient Storage` | `-90200` | Exceeds the free customer quota |
   * | `502 Insufficient Storage` | `-90201` | Exceeds the free customer physical disk space |
   *
   * </details>
   */
  requestUploadStatusPublic(
    req: operations.RequestUploadStatusPublicRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.RequestUploadStatusPublicResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.RequestUploadStatusPublicRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v4/public/shares/uploads/{access_key}/{upload_id}",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.RequestUploadStatusPublicResponse =
        new operations.RequestUploadStatusPublicResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.s3ShareUploadStatus = utils.objectToClass(
              httpRes?.data,
              shared.S3ShareUploadStatus
            );
          }
          break;
        case [400, 404, 406, 412].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorResponse = utils.objectToClass(
              httpRes?.data,
              shared.ErrorResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Upload file
   *
   * @remarks
   * ### Description:
   * Chunked upload of files via Upload Share.
   *
   * ### Precondition:
   * Valid upload ID.
   *
   * ### Postcondition:
   * Chunk of file is uploaded.
   *
   * ### Further Information:
   * Chunked uploads (range requests) are supported.
   *
   * Following `Content-Types` are supported by this API:
   * * `multipart/form-data`
   * * provided `Content-Type`
   *
   * For both file upload types set the correct `Content-Type` header and body.
   *
   * ### Examples:
   *
   * * `multipart/form-data`
   * ```
   * POST /api/v4/public/shares/uploads/{access_key}{upload_id} HTTP/1.1
   *
   * Header:
   * ...
   * Content-Type: multipart/form-data; boundary=----WebKitFormBoundary7MA4YWxkTrZu0gW
   * ...
   *
   * Body:
   * ------WebKitFormBoundary7MA4YWxkTrZu0gW
   * Content-Disposition: form-data; name="file"; filename="file.txt"
   * Content-Type: text/plain
   *
   * Content of file.txt
   * ------WebKitFormBoundary7MA4YWxkTrZu0gW--
   * ```
   *
   * * any other `Content-Type`
   * ```
   * POST /api/v4/public/shares/uploads/{access_key}{upload_id} HTTP/1.1
   *
   * Header:
   * ...
   * Content-Type: { ... }
   * ...
   *
   * Body:
   * raw content
   * ```
   *
   * @see {@link https://tools.ietf.org/html/rfc7233} - Range Requests
   */
  uploadFileAsMultipartPublic1(
    req: operations.UploadFileAsMultipartPublic1Request,
    config?: AxiosRequestConfig
  ): Promise<operations.UploadFileAsMultipartPublic1Response> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.UploadFileAsMultipartPublic1Request(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v4/public/shares/uploads/{access_key}/{upload_id}",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "multipart"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UploadFileAsMultipartPublic1Response =
        new operations.UploadFileAsMultipartPublic1Response({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case [200, 201].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.chunkUploadResponse = utils.objectToClass(
              httpRes?.data,
              shared.ChunkUploadResponse
            );
          }
          break;
        case [400, 404, 406, 412, 507].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorResponse = utils.objectToClass(
              httpRes?.data,
              shared.ErrorResponse
            );
          }
          break;
      }

      return res;
    });
  }
}
