"""Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT."""

import requests as requests_http
from . import utils
from sdk.models import operations, shared
from typing import Optional

class Document:
    r"""Document object represents your invoice."""
    _client: requests_http.Session
    _security_client: requests_http.Session
    _server_url: str
    _language: str
    _sdk_version: str
    _gen_version: str

    def __init__(self, client: requests_http.Session, security_client: requests_http.Session, server_url: str, language: str, sdk_version: str, gen_version: str) -> None:
        self._client = client
        self._security_client = security_client
        self._server_url = server_url
        self._language = language
        self._sdk_version = sdk_version
        self._gen_version = gen_version
        
    def cancel_document(self, request: operations.CancelDocumentRequest) -> operations.CancelDocumentResponse:
        r"""Cancel a document
        Cancel a document. Returns a cancellation document object if the cancellation is succeded.
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.CancelDocumentRequest, base_url, '/documents/{id}/cancel', request)
        
        
        client = self._security_client
        
        http_res = client.request('POST', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.CancelDocumentResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            res.headers = http_res.headers
            
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Document])
                res.document = out
        elif http_res.status_code in [400, 401, 403, 404]:
            res.headers = http_res.headers
            
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ClientErrorResponse])
                res.client_error_response = out
        elif http_res.status_code == 422:
            res.headers = http_res.headers
            
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ValidationErrorResponse])
                res.validation_error_response = out
        elif http_res.status_code == 500:
            res.headers = http_res.headers
            
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ServerErrorResponse])
                res.server_error_response = out

        return res

    def create_document(self, request: shared.DocumentInsert) -> operations.CreateDocumentResponse:
        r"""Create a document
        Create a new document. Returns a document object if the create is succeded.
        """
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/documents'
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = self._security_client
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.CreateDocumentResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 201:
            res.headers = http_res.headers
            
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Document])
                res.document = out
        elif http_res.status_code in [400, 401, 403]:
            res.headers = http_res.headers
            
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ClientErrorResponse])
                res.client_error_response = out
        elif http_res.status_code == 422:
            res.headers = http_res.headers
            
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ValidationErrorResponse])
                res.validation_error_response = out
        elif http_res.status_code == 500:
            res.headers = http_res.headers
            
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ServerErrorResponse])
                res.server_error_response = out

        return res

    def create_document_from_proforma(self, request: operations.CreateDocumentFromProformaRequest) -> operations.CreateDocumentFromProformaResponse:
        r"""Create a document from proforma.
        Create a new document from proforma. Returns a document object if the create is succeded.
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.CreateDocumentFromProformaRequest, base_url, '/documents/{id}/create-from-proforma', request)
        
        
        client = self._security_client
        
        http_res = client.request('POST', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.CreateDocumentFromProformaResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 201:
            res.headers = http_res.headers
            
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Document])
                res.document = out
        elif http_res.status_code in [400, 401, 403, 404]:
            res.headers = http_res.headers
            
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ClientErrorResponse])
                res.client_error_response = out
        elif http_res.status_code == 422:
            res.headers = http_res.headers
            
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ValidationErrorResponse])
                res.validation_error_response = out
        elif http_res.status_code == 500:
            res.headers = http_res.headers
            
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ServerErrorResponse])
                res.server_error_response = out

        return res

    def delete_payment(self, request: operations.DeletePaymentRequest) -> operations.DeletePaymentResponse:
        r"""Delete all payment history on document
        Delete all exist payment history on document.
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.DeletePaymentRequest, base_url, '/documents/{id}/payments', request)
        
        
        client = self._security_client
        
        http_res = client.request('DELETE', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DeletePaymentResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            res.headers = http_res.headers
            
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[list[shared.PaymentHistory]])
                res.payment_histories = out
        elif http_res.status_code in [400, 401, 403, 404]:
            res.headers = http_res.headers
            
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ClientErrorResponse])
                res.client_error_response = out
        elif http_res.status_code == 500:
            res.headers = http_res.headers
            
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ServerErrorResponse])
                res.server_error_response = out

        return res

    def download_document(self, request: operations.DownloadDocumentRequest) -> operations.DownloadDocumentResponse:
        r"""Download a document in PDF format.
        Download a document. Returns a document in PDF format.
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.DownloadDocumentRequest, base_url, '/documents/{id}/download', request)
        
        
        client = self._security_client
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DownloadDocumentResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            res.headers = http_res.headers
            
            if utils.match_content_type(content_type, 'application/pdf'):
                res.download_document_200_application_pdf_binary_string = http_res.content
        elif http_res.status_code == 202:
            res.headers = http_res.headers
            
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ClientError])
                res.client_error = out
        elif http_res.status_code in [400, 401, 404]:
            res.headers = http_res.headers
            
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ClientErrorResponse])
                res.client_error_response = out
        elif http_res.status_code == 422:
            res.headers = http_res.headers
            
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ValidationErrorResponse])
                res.validation_error_response = out
        elif http_res.status_code == 500:
            res.headers = http_res.headers
            
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ServerErrorResponse])
                res.server_error_response = out

        return res

    def get_document(self, request: operations.GetDocumentRequest) -> operations.GetDocumentResponse:
        r"""Retrieve a document
        Retrieves the details of an existing document.
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.GetDocumentRequest, base_url, '/documents/{id}', request)
        
        
        client = self._security_client
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetDocumentResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            res.headers = http_res.headers
            
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Document])
                res.document = out
        elif http_res.status_code in [400, 401, 404]:
            res.headers = http_res.headers
            
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ClientErrorResponse])
                res.client_error_response = out
        elif http_res.status_code == 422:
            res.headers = http_res.headers
            
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ValidationErrorResponse])
                res.validation_error_response = out
        elif http_res.status_code == 500:
            res.headers = http_res.headers
            
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ServerErrorResponse])
                res.server_error_response = out

        return res

    def get_online_szamla_status(self, request: operations.GetOnlineSzamlaStatusRequest) -> operations.GetOnlineSzamlaStatusResponse:
        r"""Retrieve a document Online SzÃ¡mla status
        Retrieves the details of an existing document status.
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.GetOnlineSzamlaStatusRequest, base_url, '/documents/{id}/online-szamla', request)
        
        
        client = self._security_client
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetOnlineSzamlaStatusResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            res.headers = http_res.headers
            
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.OnlineSzamlaStatus])
                res.online_szamla_status = out
        elif http_res.status_code in [400, 401, 404]:
            res.headers = http_res.headers
            
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ClientErrorResponse])
                res.client_error_response = out
        elif http_res.status_code == 422:
            res.headers = http_res.headers
            
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ValidationErrorResponse])
                res.validation_error_response = out
        elif http_res.status_code == 500:
            res.headers = http_res.headers
            
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ServerErrorResponse])
                res.server_error_response = out

        return res

    def get_payment(self, request: operations.GetPaymentRequest) -> operations.GetPaymentResponse:
        r"""Retrieve a payment histroy
        Retrieves the details of payment history an existing document.
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.GetPaymentRequest, base_url, '/documents/{id}/payments', request)
        
        
        client = self._security_client
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetPaymentResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            res.headers = http_res.headers
            
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[list[shared.PaymentHistory]])
                res.payment_histories = out
        elif http_res.status_code in [400, 401, 404]:
            res.headers = http_res.headers
            
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ClientErrorResponse])
                res.client_error_response = out
        elif http_res.status_code == 422:
            res.headers = http_res.headers
            
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ValidationErrorResponse])
                res.validation_error_response = out
        elif http_res.status_code == 500:
            res.headers = http_res.headers
            
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ServerErrorResponse])
                res.server_error_response = out

        return res

    def get_public_url(self, request: operations.GetPublicURLRequest) -> operations.GetPublicURLResponse:
        r"""Retrieve a document download public url.
        Retrieves public url to download an existing document.
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.GetPublicURLRequest, base_url, '/documents/{id}/public-url', request)
        
        
        client = self._security_client
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetPublicURLResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            res.headers = http_res.headers
            
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.DocumentPublicURL])
                res.document_public_url = out
        elif http_res.status_code in [400, 401, 404]:
            res.headers = http_res.headers
            
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ClientErrorResponse])
                res.client_error_response = out
        elif http_res.status_code == 422:
            res.headers = http_res.headers
            
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ValidationErrorResponse])
                res.validation_error_response = out
        elif http_res.status_code == 500:
            res.headers = http_res.headers
            
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ServerErrorResponse])
                res.server_error_response = out

        return res

    def list_document(self, request: operations.ListDocumentRequest) -> operations.ListDocumentResponse:
        r"""List all documents
        Returns a list of your documents. The documents are returned sorted by creation date, with the most recent documents appearing first.
        """
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/documents'
        
        query_params = utils.get_query_params(operations.ListDocumentRequest, request)
        
        client = self._security_client
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ListDocumentResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            res.headers = http_res.headers
            
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.DocumentList])
                res.document_list = out
        elif http_res.status_code in [400, 401]:
            res.headers = http_res.headers
            
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ClientErrorResponse])
                res.client_error_response = out
        elif http_res.status_code == 422:
            res.headers = http_res.headers
            
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ValidationErrorResponse])
                res.validation_error_response = out
        elif http_res.status_code == 500:
            res.headers = http_res.headers
            
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ServerErrorResponse])
                res.server_error_response = out

        return res

    def send_document(self, request: operations.SendDocumentRequest) -> operations.SendDocumentResponse:
        r"""Send invoice to given email adresses.
        Returns a list of emails, where the invoice is sent.
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.SendDocumentRequest, base_url, '/documents/{id}/send', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "send_document", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        
        client = self._security_client
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.SendDocumentResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            res.headers = http_res.headers
            
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.SendDocument])
                res.send_document = out
        elif http_res.status_code in [400, 401, 403, 404]:
            res.headers = http_res.headers
            
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ClientErrorResponse])
                res.client_error_response = out
        elif http_res.status_code == 422:
            res.headers = http_res.headers
            
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ValidationErrorResponse])
                res.validation_error_response = out
        elif http_res.status_code == 500:
            res.headers = http_res.headers
            
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ServerErrorResponse])
                res.server_error_response = out

        return res

    def update_payment(self, request: operations.UpdatePaymentRequest) -> operations.UpdatePaymentResponse:
        r"""Update payment history
        Update payment history an existing document. Returns a payment history object if the update is succeded.
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.UpdatePaymentRequest, base_url, '/documents/{id}/payments', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = self._security_client
        
        http_res = client.request('PUT', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.UpdatePaymentResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            res.headers = http_res.headers
            
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[list[shared.PaymentHistory]])
                res.payment_histories = out
        elif http_res.status_code in [400, 401, 403, 404]:
            res.headers = http_res.headers
            
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ClientErrorResponse])
                res.client_error_response = out
        elif http_res.status_code == 422:
            res.headers = http_res.headers
            
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ValidationErrorResponse])
                res.validation_error_response = out
        elif http_res.status_code == 500:
            res.headers = http_res.headers
            
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ServerErrorResponse])
                res.server_error_response = out

        return res

    