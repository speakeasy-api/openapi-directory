<?php

/**
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

declare(strict_types=1);

namespace OpenAPI\OpenAPI;

class Files 
{

	// SDK private variables namespaced with _ to avoid conflicts with API models
	private \GuzzleHttp\ClientInterface $_defaultClient;
	private \GuzzleHttp\ClientInterface $_securityClient;
	private string $_serverUrl;
	private string $_language;
	private string $_sdkVersion;
	private string $_genVersion;	

	/**
	 * @param \GuzzleHttp\ClientInterface $defaultClient
	 * @param \GuzzleHttp\ClientInterface $securityClient
	 * @param string $serverUrl
	 * @param string $language
	 * @param string $sdkVersion
	 * @param string $genVersion
	 */
	public function __construct(\GuzzleHttp\ClientInterface $defaultClient, \GuzzleHttp\ClientInterface $securityClient, string $serverUrl, string $language, string $sdkVersion, string $genVersion)
	{
		$this->_defaultClient = $defaultClient;
		$this->_securityClient = $securityClient;
		$this->_serverUrl = $serverUrl;
		$this->_language = $language;
		$this->_sdkVersion = $sdkVersion;
		$this->_genVersion = $genVersion;
	}
	
    /**
     * Creates a copy of the specified file. Folders cannot be copied.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\DriveFilesCopyRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\DriveFilesCopySecurity $security
     * @return \OpenAPI\OpenAPI\Models\Operations\DriveFilesCopyResponse
     */
	public function driveFilesCopy(
        \OpenAPI\OpenAPI\Models\Operations\DriveFilesCopyRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\DriveFilesCopySecurity $security,
    ): \OpenAPI\OpenAPI\Models\Operations\DriveFilesCopyResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/files/{fileId}/copy', \OpenAPI\OpenAPI\Models\Operations\DriveFilesCopyRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "fileInput", "json");
        $options = array_merge_recursive($options, $body);
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\DriveFilesCopyRequest::class, $request, null));
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\DriveFilesCopyResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->file = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\File', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Permanently deletes a file by ID. Skips the trash. The currently authenticated user must own the file or be an organizer on the parent for shared drive files.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\DriveFilesDeleteRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\DriveFilesDeleteSecurity $security
     * @return \OpenAPI\OpenAPI\Models\Operations\DriveFilesDeleteResponse
     */
	public function driveFilesDelete(
        \OpenAPI\OpenAPI\Models\Operations\DriveFilesDeleteRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\DriveFilesDeleteSecurity $security,
    ): \OpenAPI\OpenAPI\Models\Operations\DriveFilesDeleteResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/files/{fileId}', \OpenAPI\OpenAPI\Models\Operations\DriveFilesDeleteRequest::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\DriveFilesDeleteRequest::class, $request, null));
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('DELETE', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\DriveFilesDeleteResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
        }

        return $response;
    }
	
    /**
     * Permanently deletes all trashed files of a user or shared drive.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\DriveFilesEmptyTrashRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\DriveFilesEmptyTrashSecurity $security
     * @return \OpenAPI\OpenAPI\Models\Operations\DriveFilesEmptyTrashResponse
     */
	public function driveFilesEmptyTrash(
        \OpenAPI\OpenAPI\Models\Operations\DriveFilesEmptyTrashRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\DriveFilesEmptyTrashSecurity $security,
    ): \OpenAPI\OpenAPI\Models\Operations\DriveFilesEmptyTrashResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/files/trash');
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\DriveFilesEmptyTrashRequest::class, $request, null));
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('DELETE', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\DriveFilesEmptyTrashResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
        }

        return $response;
    }
	
    /**
     * Exports a Google Workspace document to the requested MIME type and returns exported byte content. Note that the exported content is limited to 10MB.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\DriveFilesExportRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\DriveFilesExportSecurity $security
     * @return \OpenAPI\OpenAPI\Models\Operations\DriveFilesExportResponse
     */
	public function driveFilesExport(
        \OpenAPI\OpenAPI\Models\Operations\DriveFilesExportRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\DriveFilesExportSecurity $security,
    ): \OpenAPI\OpenAPI\Models\Operations\DriveFilesExportResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/files/{fileId}/export', \OpenAPI\OpenAPI\Models\Operations\DriveFilesExportRequest::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\DriveFilesExportRequest::class, $request, null));
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\DriveFilesExportResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
        }

        return $response;
    }
	
    /**
     * Generates a set of file IDs which can be provided in insert or copy requests.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\DriveFilesGenerateIdsRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\DriveFilesGenerateIdsSecurity $security
     * @return \OpenAPI\OpenAPI\Models\Operations\DriveFilesGenerateIdsResponse
     */
	public function driveFilesGenerateIds(
        \OpenAPI\OpenAPI\Models\Operations\DriveFilesGenerateIdsRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\DriveFilesGenerateIdsSecurity $security,
    ): \OpenAPI\OpenAPI\Models\Operations\DriveFilesGenerateIdsResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/files/generateIds');
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\DriveFilesGenerateIdsRequest::class, $request, null));
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\DriveFilesGenerateIdsResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->generatedIds = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\GeneratedIds', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Gets a file's metadata or content by ID.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\DriveFilesGetRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\DriveFilesGetSecurity $security
     * @return \OpenAPI\OpenAPI\Models\Operations\DriveFilesGetResponse
     */
	public function driveFilesGet(
        \OpenAPI\OpenAPI\Models\Operations\DriveFilesGetRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\DriveFilesGetSecurity $security,
    ): \OpenAPI\OpenAPI\Models\Operations\DriveFilesGetResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/files/{fileId}', \OpenAPI\OpenAPI\Models\Operations\DriveFilesGetRequest::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\DriveFilesGetRequest::class, $request, null));
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\DriveFilesGetResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->file = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\File', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Insert a new file.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\DriveFilesInsertRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\DriveFilesInsertSecurity $security
     * @return \OpenAPI\OpenAPI\Models\Operations\DriveFilesInsertResponse
     */
	public function driveFilesInsert(
        \OpenAPI\OpenAPI\Models\Operations\DriveFilesInsertRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\DriveFilesInsertSecurity $security,
    ): \OpenAPI\OpenAPI\Models\Operations\DriveFilesInsertResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/files');
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "requestBody", "raw");
        $options = array_merge_recursive($options, $body);
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\DriveFilesInsertRequest::class, $request, null));
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\DriveFilesInsertResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->file = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\File', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Lists the user's files.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\DriveFilesListRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\DriveFilesListSecurity $security
     * @return \OpenAPI\OpenAPI\Models\Operations\DriveFilesListResponse
     */
	public function driveFilesList(
        \OpenAPI\OpenAPI\Models\Operations\DriveFilesListRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\DriveFilesListSecurity $security,
    ): \OpenAPI\OpenAPI\Models\Operations\DriveFilesListResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/files');
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\DriveFilesListRequest::class, $request, null));
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\DriveFilesListResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->fileList = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\FileList', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Lists the labels on a file.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\DriveFilesListLabelsRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\DriveFilesListLabelsSecurity $security
     * @return \OpenAPI\OpenAPI\Models\Operations\DriveFilesListLabelsResponse
     */
	public function driveFilesListLabels(
        \OpenAPI\OpenAPI\Models\Operations\DriveFilesListLabelsRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\DriveFilesListLabelsSecurity $security,
    ): \OpenAPI\OpenAPI\Models\Operations\DriveFilesListLabelsResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/files/{fileId}/listLabels', \OpenAPI\OpenAPI\Models\Operations\DriveFilesListLabelsRequest::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\DriveFilesListLabelsRequest::class, $request, null));
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\DriveFilesListLabelsResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->labelList = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\LabelList', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Modifies the set of labels on a file.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\DriveFilesModifyLabelsRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\DriveFilesModifyLabelsSecurity $security
     * @return \OpenAPI\OpenAPI\Models\Operations\DriveFilesModifyLabelsResponse
     */
	public function driveFilesModifyLabels(
        \OpenAPI\OpenAPI\Models\Operations\DriveFilesModifyLabelsRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\DriveFilesModifyLabelsSecurity $security,
    ): \OpenAPI\OpenAPI\Models\Operations\DriveFilesModifyLabelsResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/files/{fileId}/modifyLabels', \OpenAPI\OpenAPI\Models\Operations\DriveFilesModifyLabelsRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "modifyLabelsRequest", "json");
        $options = array_merge_recursive($options, $body);
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\DriveFilesModifyLabelsRequest::class, $request, null));
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\DriveFilesModifyLabelsResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->modifyLabelsResponse = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\ModifyLabelsResponse', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Updates a file's metadata and/or content. When calling this method, only populate fields in the request that you want to modify. When updating fields, some fields might change automatically, such as modifiedDate. This method supports patch semantics.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\DriveFilesPatchRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\DriveFilesPatchSecurity $security
     * @return \OpenAPI\OpenAPI\Models\Operations\DriveFilesPatchResponse
     */
	public function driveFilesPatch(
        \OpenAPI\OpenAPI\Models\Operations\DriveFilesPatchRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\DriveFilesPatchSecurity $security,
    ): \OpenAPI\OpenAPI\Models\Operations\DriveFilesPatchResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/files/{fileId}', \OpenAPI\OpenAPI\Models\Operations\DriveFilesPatchRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "fileInput", "json");
        $options = array_merge_recursive($options, $body);
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\DriveFilesPatchRequest::class, $request, null));
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('PATCH', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\DriveFilesPatchResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->file = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\File', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Set the file's updated time to the current server time.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\DriveFilesTouchRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\DriveFilesTouchSecurity $security
     * @return \OpenAPI\OpenAPI\Models\Operations\DriveFilesTouchResponse
     */
	public function driveFilesTouch(
        \OpenAPI\OpenAPI\Models\Operations\DriveFilesTouchRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\DriveFilesTouchSecurity $security,
    ): \OpenAPI\OpenAPI\Models\Operations\DriveFilesTouchResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/files/{fileId}/touch', \OpenAPI\OpenAPI\Models\Operations\DriveFilesTouchRequest::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\DriveFilesTouchRequest::class, $request, null));
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\DriveFilesTouchResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->file = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\File', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Moves a file to the trash. The currently authenticated user must own the file or be at least a fileOrganizer on the parent for shared drive files. Only the owner may trash a file. The trashed item is excluded from all files.list responses returned for any user who does not own the file. However, all users with access to the file can see the trashed item metadata in an API response. All users with access can copy, download, export, and share the file.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\DriveFilesTrashRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\DriveFilesTrashSecurity $security
     * @return \OpenAPI\OpenAPI\Models\Operations\DriveFilesTrashResponse
     */
	public function driveFilesTrash(
        \OpenAPI\OpenAPI\Models\Operations\DriveFilesTrashRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\DriveFilesTrashSecurity $security,
    ): \OpenAPI\OpenAPI\Models\Operations\DriveFilesTrashResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/files/{fileId}/trash', \OpenAPI\OpenAPI\Models\Operations\DriveFilesTrashRequest::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\DriveFilesTrashRequest::class, $request, null));
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\DriveFilesTrashResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->file = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\File', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Restores a file from the trash. The currently authenticated user must own the file or be at least a fileOrganizer on the parent for shared drive files. Only the owner may untrash a file.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\DriveFilesUntrashRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\DriveFilesUntrashSecurity $security
     * @return \OpenAPI\OpenAPI\Models\Operations\DriveFilesUntrashResponse
     */
	public function driveFilesUntrash(
        \OpenAPI\OpenAPI\Models\Operations\DriveFilesUntrashRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\DriveFilesUntrashSecurity $security,
    ): \OpenAPI\OpenAPI\Models\Operations\DriveFilesUntrashResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/files/{fileId}/untrash', \OpenAPI\OpenAPI\Models\Operations\DriveFilesUntrashRequest::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\DriveFilesUntrashRequest::class, $request, null));
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\DriveFilesUntrashResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->file = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\File', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Updates a file's metadata and/or content. When calling this method, only populate fields in the request that you want to modify. When updating fields, some fields might be changed automatically, such as modifiedDate. This method supports patch semantics.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\DriveFilesUpdateRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\DriveFilesUpdateSecurity $security
     * @return \OpenAPI\OpenAPI\Models\Operations\DriveFilesUpdateResponse
     */
	public function driveFilesUpdate(
        \OpenAPI\OpenAPI\Models\Operations\DriveFilesUpdateRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\DriveFilesUpdateSecurity $security,
    ): \OpenAPI\OpenAPI\Models\Operations\DriveFilesUpdateResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/files/{fileId}', \OpenAPI\OpenAPI\Models\Operations\DriveFilesUpdateRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "requestBody", "raw");
        $options = array_merge_recursive($options, $body);
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\DriveFilesUpdateRequest::class, $request, null));
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('PUT', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\DriveFilesUpdateResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->file = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\File', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Subscribe to changes on a file.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\DriveFilesWatchRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\DriveFilesWatchSecurity $security
     * @return \OpenAPI\OpenAPI\Models\Operations\DriveFilesWatchResponse
     */
	public function driveFilesWatch(
        \OpenAPI\OpenAPI\Models\Operations\DriveFilesWatchRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\DriveFilesWatchSecurity $security,
    ): \OpenAPI\OpenAPI\Models\Operations\DriveFilesWatchResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/files/{fileId}/watch', \OpenAPI\OpenAPI\Models\Operations\DriveFilesWatchRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "channel", "json");
        $options = array_merge_recursive($options, $body);
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\DriveFilesWatchRequest::class, $request, null));
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\DriveFilesWatchResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->channel = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\Channel', 'json');
            }
        }

        return $response;
    }
}