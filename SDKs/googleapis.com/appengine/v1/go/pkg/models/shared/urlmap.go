// Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.

package shared

import (
	"encoding/json"
	"fmt"
)

// URLMapAuthFailActionEnum - Action to take when users access resources that require authentication. Defaults to redirect.
type URLMapAuthFailActionEnum string

const (
	URLMapAuthFailActionEnumAuthFailActionUnspecified  URLMapAuthFailActionEnum = "AUTH_FAIL_ACTION_UNSPECIFIED"
	URLMapAuthFailActionEnumAuthFailActionRedirect     URLMapAuthFailActionEnum = "AUTH_FAIL_ACTION_REDIRECT"
	URLMapAuthFailActionEnumAuthFailActionUnauthorized URLMapAuthFailActionEnum = "AUTH_FAIL_ACTION_UNAUTHORIZED"
)

func (e URLMapAuthFailActionEnum) ToPointer() *URLMapAuthFailActionEnum {
	return &e
}

func (e *URLMapAuthFailActionEnum) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "AUTH_FAIL_ACTION_UNSPECIFIED":
		fallthrough
	case "AUTH_FAIL_ACTION_REDIRECT":
		fallthrough
	case "AUTH_FAIL_ACTION_UNAUTHORIZED":
		*e = URLMapAuthFailActionEnum(v)
		return nil
	default:
		return fmt.Errorf("invalid value for URLMapAuthFailActionEnum: %v", v)
	}
}

// URLMapLoginEnum - Level of login required to access this resource. Not supported for Node.js in the App Engine standard environment.
type URLMapLoginEnum string

const (
	URLMapLoginEnumLoginUnspecified URLMapLoginEnum = "LOGIN_UNSPECIFIED"
	URLMapLoginEnumLoginOptional    URLMapLoginEnum = "LOGIN_OPTIONAL"
	URLMapLoginEnumLoginAdmin       URLMapLoginEnum = "LOGIN_ADMIN"
	URLMapLoginEnumLoginRequired    URLMapLoginEnum = "LOGIN_REQUIRED"
)

func (e URLMapLoginEnum) ToPointer() *URLMapLoginEnum {
	return &e
}

func (e *URLMapLoginEnum) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "LOGIN_UNSPECIFIED":
		fallthrough
	case "LOGIN_OPTIONAL":
		fallthrough
	case "LOGIN_ADMIN":
		fallthrough
	case "LOGIN_REQUIRED":
		*e = URLMapLoginEnum(v)
		return nil
	default:
		return fmt.Errorf("invalid value for URLMapLoginEnum: %v", v)
	}
}

// URLMapRedirectHTTPResponseCodeEnum - 30x code to use when performing redirects for the secure field. Defaults to 302.
type URLMapRedirectHTTPResponseCodeEnum string

const (
	URLMapRedirectHTTPResponseCodeEnumRedirectHTTPResponseCodeUnspecified URLMapRedirectHTTPResponseCodeEnum = "REDIRECT_HTTP_RESPONSE_CODE_UNSPECIFIED"
	URLMapRedirectHTTPResponseCodeEnumRedirectHTTPResponseCode301         URLMapRedirectHTTPResponseCodeEnum = "REDIRECT_HTTP_RESPONSE_CODE_301"
	URLMapRedirectHTTPResponseCodeEnumRedirectHTTPResponseCode302         URLMapRedirectHTTPResponseCodeEnum = "REDIRECT_HTTP_RESPONSE_CODE_302"
	URLMapRedirectHTTPResponseCodeEnumRedirectHTTPResponseCode303         URLMapRedirectHTTPResponseCodeEnum = "REDIRECT_HTTP_RESPONSE_CODE_303"
	URLMapRedirectHTTPResponseCodeEnumRedirectHTTPResponseCode307         URLMapRedirectHTTPResponseCodeEnum = "REDIRECT_HTTP_RESPONSE_CODE_307"
)

func (e URLMapRedirectHTTPResponseCodeEnum) ToPointer() *URLMapRedirectHTTPResponseCodeEnum {
	return &e
}

func (e *URLMapRedirectHTTPResponseCodeEnum) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "REDIRECT_HTTP_RESPONSE_CODE_UNSPECIFIED":
		fallthrough
	case "REDIRECT_HTTP_RESPONSE_CODE_301":
		fallthrough
	case "REDIRECT_HTTP_RESPONSE_CODE_302":
		fallthrough
	case "REDIRECT_HTTP_RESPONSE_CODE_303":
		fallthrough
	case "REDIRECT_HTTP_RESPONSE_CODE_307":
		*e = URLMapRedirectHTTPResponseCodeEnum(v)
		return nil
	default:
		return fmt.Errorf("invalid value for URLMapRedirectHTTPResponseCodeEnum: %v", v)
	}
}

// URLMapSecurityLevelEnum - Security (HTTPS) enforcement for this URL.
type URLMapSecurityLevelEnum string

const (
	URLMapSecurityLevelEnumSecureUnspecified URLMapSecurityLevelEnum = "SECURE_UNSPECIFIED"
	URLMapSecurityLevelEnumSecureDefault     URLMapSecurityLevelEnum = "SECURE_DEFAULT"
	URLMapSecurityLevelEnumSecureNever       URLMapSecurityLevelEnum = "SECURE_NEVER"
	URLMapSecurityLevelEnumSecureOptional    URLMapSecurityLevelEnum = "SECURE_OPTIONAL"
	URLMapSecurityLevelEnumSecureAlways      URLMapSecurityLevelEnum = "SECURE_ALWAYS"
)

func (e URLMapSecurityLevelEnum) ToPointer() *URLMapSecurityLevelEnum {
	return &e
}

func (e *URLMapSecurityLevelEnum) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "SECURE_UNSPECIFIED":
		fallthrough
	case "SECURE_DEFAULT":
		fallthrough
	case "SECURE_NEVER":
		fallthrough
	case "SECURE_OPTIONAL":
		fallthrough
	case "SECURE_ALWAYS":
		*e = URLMapSecurityLevelEnum(v)
		return nil
	default:
		return fmt.Errorf("invalid value for URLMapSecurityLevelEnum: %v", v)
	}
}

// URLMap - URL pattern and description of how the URL should be handled. App Engine can handle URLs by executing application code or by serving static files uploaded with the version, such as images, CSS, or JavaScript.
type URLMap struct {
	// Uses Google Cloud Endpoints to handle requests.
	APIEndpoint *APIEndpointHandler `json:"apiEndpoint,omitempty"`
	// Action to take when users access resources that require authentication. Defaults to redirect.
	AuthFailAction *URLMapAuthFailActionEnum `json:"authFailAction,omitempty"`
	// Level of login required to access this resource. Not supported for Node.js in the App Engine standard environment.
	Login *URLMapLoginEnum `json:"login,omitempty"`
	// 30x code to use when performing redirects for the secure field. Defaults to 302.
	RedirectHTTPResponseCode *URLMapRedirectHTTPResponseCodeEnum `json:"redirectHttpResponseCode,omitempty"`
	// Executes a script to handle the request that matches the URL pattern.
	Script *ScriptHandler `json:"script,omitempty"`
	// Security (HTTPS) enforcement for this URL.
	SecurityLevel *URLMapSecurityLevelEnum `json:"securityLevel,omitempty"`
	// Files served directly to the user for a given URL, such as images, CSS stylesheets, or JavaScript source files. Static file handlers describe which files in the application directory are static files, and which URLs serve them.
	StaticFiles *StaticFilesHandler `json:"staticFiles,omitempty"`
	// URL prefix. Uses regular expression syntax, which means regexp special characters must be escaped, but should not contain groupings. All URLs that begin with this prefix are handled by this handler, using the portion of the URL after the prefix as part of the file path.
	URLRegex *string `json:"urlRegex,omitempty"`
}
