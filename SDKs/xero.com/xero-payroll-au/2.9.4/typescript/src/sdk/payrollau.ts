/*
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

import * as utils from "../internal/utils";
import * as operations from "./models/operations";
import * as shared from "./models/shared";
import { AxiosInstance, AxiosRequestConfig, AxiosResponse } from "axios";

/**
 * Operations available to regular developers
 */
export class PayrollAu {
  _defaultClient: AxiosInstance;
  _securityClient: AxiosInstance;
  _serverURL: string;
  _language: string;
  _sdkVersion: string;
  _genVersion: string;

  constructor(
    defaultClient: AxiosInstance,
    securityClient: AxiosInstance,
    serverURL: string,
    language: string,
    sdkVersion: string,
    genVersion: string
  ) {
    this._defaultClient = defaultClient;
    this._securityClient = securityClient;
    this._serverURL = serverURL;
    this._language = language;
    this._sdkVersion = sdkVersion;
    this._genVersion = genVersion;
  }

  /**
   * Creates a payroll employee
   */
  createEmployee(
    req: operations.CreateEmployeeRequest,
    security: operations.CreateEmployeeSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.CreateEmployeeResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CreateEmployeeRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/Employees";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.CreateEmployeeSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CreateEmployeeResponse =
        new operations.CreateEmployeeResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.employees = utils.objectToClass(
              httpRes?.data,
              shared.Employees
            );
          }
          break;
        case httpRes?.status == 400:
          break;
      }

      return res;
    });
  }

  /**
   * Creates a leave application
   */
  createLeaveApplication(
    req: operations.CreateLeaveApplicationRequest,
    security: operations.CreateLeaveApplicationSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.CreateLeaveApplicationResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CreateLeaveApplicationRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/LeaveApplications";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.CreateLeaveApplicationSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CreateLeaveApplicationResponse =
        new operations.CreateLeaveApplicationResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.leaveApplications = utils.objectToClass(
              httpRes?.data,
              shared.LeaveApplications
            );
          }
          break;
        case httpRes?.status == 400:
          break;
      }

      return res;
    });
  }

  /**
   * Creates a pay item
   */
  createPayItem(
    req: operations.CreatePayItemRequest,
    security: operations.CreatePayItemSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.CreatePayItemResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CreatePayItemRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/PayItems";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "payItemInput",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.CreatePayItemSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CreatePayItemResponse =
        new operations.CreatePayItemResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.payItems = utils.objectToClass(httpRes?.data, shared.PayItems);
          }
          break;
        case httpRes?.status == 400:
          break;
      }

      return res;
    });
  }

  /**
   * Creates a pay run
   */
  createPayRun(
    req: operations.CreatePayRunRequest,
    security: operations.CreatePayRunSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.CreatePayRunResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CreatePayRunRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/PayRuns";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.CreatePayRunSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CreatePayRunResponse =
        new operations.CreatePayRunResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.payRuns = utils.objectToClass(httpRes?.data, shared.PayRuns);
          }
          break;
        case httpRes?.status == 400:
          break;
      }

      return res;
    });
  }

  /**
   * Creates a Payroll Calendar
   */
  createPayrollCalendar(
    req: operations.CreatePayrollCalendarRequest,
    security: operations.CreatePayrollCalendarSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.CreatePayrollCalendarResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CreatePayrollCalendarRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/PayrollCalendars";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.CreatePayrollCalendarSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CreatePayrollCalendarResponse =
        new operations.CreatePayrollCalendarResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.payrollCalendars = utils.objectToClass(
              httpRes?.data,
              shared.PayrollCalendars
            );
          }
          break;
        case httpRes?.status == 400:
          break;
      }

      return res;
    });
  }

  /**
   * Creates a superfund
   */
  createSuperfund(
    req: operations.CreateSuperfundRequest,
    security: operations.CreateSuperfundSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.CreateSuperfundResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CreateSuperfundRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/Superfunds";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.CreateSuperfundSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CreateSuperfundResponse =
        new operations.CreateSuperfundResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.superFunds = utils.objectToClass(
              httpRes?.data,
              shared.SuperFunds
            );
          }
          break;
        case httpRes?.status == 400:
          break;
      }

      return res;
    });
  }

  /**
   * Creates a timesheet
   */
  createTimesheet(
    req: operations.CreateTimesheetRequest,
    security: operations.CreateTimesheetSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.CreateTimesheetResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CreateTimesheetRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/Timesheets";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.CreateTimesheetSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CreateTimesheetResponse =
        new operations.CreateTimesheetResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.timesheets = utils.objectToClass(
              httpRes?.data,
              shared.Timesheets
            );
          }
          break;
        case httpRes?.status == 400:
          break;
      }

      return res;
    });
  }

  /**
   * Retrieves an employee's detail by unique employee id
   */
  getEmployee(
    req: operations.GetEmployeeRequest,
    security: operations.GetEmployeeSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.GetEmployeeResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetEmployeeRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/Employees/{EmployeeID}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.GetEmployeeSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };

    const r = client.request({
      url: url,
      method: "get",
      headers: headers,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetEmployeeResponse =
        new operations.GetEmployeeResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.employees = utils.objectToClass(
              httpRes?.data,
              shared.Employees
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Searches payroll employees
   */
  getEmployees(
    req: operations.GetEmployeesRequest,
    security: operations.GetEmployeesSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.GetEmployeesResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetEmployeesRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/Employees";
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.GetEmployeesSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      headers: headers,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetEmployeesResponse =
        new operations.GetEmployeesResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.employees = utils.objectToClass(
              httpRes?.data,
              shared.Employees
            );
          }
          break;
        case httpRes?.status == 400:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.apiException = utils.objectToClass(
              httpRes?.data,
              shared.APIException
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Retrieves a leave application by a unique leave application id
   */
  getLeaveApplication(
    req: operations.GetLeaveApplicationRequest,
    security: operations.GetLeaveApplicationSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.GetLeaveApplicationResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetLeaveApplicationRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/LeaveApplications/{LeaveApplicationID}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.GetLeaveApplicationSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };

    const r = client.request({
      url: url,
      method: "get",
      headers: headers,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetLeaveApplicationResponse =
        new operations.GetLeaveApplicationResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.leaveApplications = utils.objectToClass(
              httpRes?.data,
              shared.LeaveApplications
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Retrieves leave applications
   */
  getLeaveApplications(
    req: operations.GetLeaveApplicationsRequest,
    security: operations.GetLeaveApplicationsSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.GetLeaveApplicationsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetLeaveApplicationsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/LeaveApplications";
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.GetLeaveApplicationsSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      headers: headers,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetLeaveApplicationsResponse =
        new operations.GetLeaveApplicationsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.leaveApplications = utils.objectToClass(
              httpRes?.data,
              shared.LeaveApplications
            );
          }
          break;
        case httpRes?.status == 400:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.apiException = utils.objectToClass(
              httpRes?.data,
              shared.APIException
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Retrieves pay items
   */
  getPayItems(
    req: operations.GetPayItemsRequest,
    security: operations.GetPayItemsSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.GetPayItemsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetPayItemsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/PayItems";
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.GetPayItemsSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      headers: headers,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetPayItemsResponse =
        new operations.GetPayItemsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.payItems = utils.objectToClass(httpRes?.data, shared.PayItems);
          }
          break;
        case httpRes?.status == 400:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.apiException = utils.objectToClass(
              httpRes?.data,
              shared.APIException
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Retrieves a pay run by using a unique pay run id
   */
  getPayRun(
    req: operations.GetPayRunRequest,
    security: operations.GetPayRunSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.GetPayRunResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetPayRunRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(baseURL, "/PayRuns/{PayRunID}", req);
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.GetPayRunSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };

    const r = client.request({
      url: url,
      method: "get",
      headers: headers,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetPayRunResponse =
        new operations.GetPayRunResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.payRuns = utils.objectToClass(httpRes?.data, shared.PayRuns);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Retrieves pay runs
   */
  getPayRuns(
    req: operations.GetPayRunsRequest,
    security: operations.GetPayRunsSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.GetPayRunsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetPayRunsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/PayRuns";
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.GetPayRunsSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      headers: headers,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetPayRunsResponse =
        new operations.GetPayRunsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.payRuns = utils.objectToClass(httpRes?.data, shared.PayRuns);
          }
          break;
        case httpRes?.status == 400:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.apiException = utils.objectToClass(
              httpRes?.data,
              shared.APIException
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Retrieves payroll calendar by using a unique payroll calendar ID
   */
  getPayrollCalendar(
    req: operations.GetPayrollCalendarRequest,
    security: operations.GetPayrollCalendarSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.GetPayrollCalendarResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetPayrollCalendarRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/PayrollCalendars/{PayrollCalendarID}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.GetPayrollCalendarSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };

    const r = client.request({
      url: url,
      method: "get",
      headers: headers,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetPayrollCalendarResponse =
        new operations.GetPayrollCalendarResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.payrollCalendars = utils.objectToClass(
              httpRes?.data,
              shared.PayrollCalendars
            );
          }
          break;
        case httpRes?.status == 400:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.apiException = utils.objectToClass(
              httpRes?.data,
              shared.APIException
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Retrieves payroll calendars
   */
  getPayrollCalendars(
    req: operations.GetPayrollCalendarsRequest,
    security: operations.GetPayrollCalendarsSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.GetPayrollCalendarsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetPayrollCalendarsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/PayrollCalendars";
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.GetPayrollCalendarsSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      headers: headers,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetPayrollCalendarsResponse =
        new operations.GetPayrollCalendarsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.payrollCalendars = utils.objectToClass(
              httpRes?.data,
              shared.PayrollCalendars
            );
          }
          break;
        case httpRes?.status == 400:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.apiException = utils.objectToClass(
              httpRes?.data,
              shared.APIException
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Retrieves for a payslip by a unique payslip id
   */
  getPayslip(
    req: operations.GetPayslipRequest,
    security: operations.GetPayslipSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.GetPayslipResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetPayslipRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(baseURL, "/Payslip/{PayslipID}", req);
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.GetPayslipSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };

    const r = client.request({
      url: url,
      method: "get",
      headers: headers,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetPayslipResponse =
        new operations.GetPayslipResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.payslipObject = utils.objectToClass(
              httpRes?.data,
              shared.PayslipObject
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Retrieves payroll settings
   */
  getSettings(
    req: operations.GetSettingsRequest,
    security: operations.GetSettingsSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.GetSettingsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetSettingsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/Settings";
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.GetSettingsSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };

    const r = client.request({
      url: url,
      method: "get",
      headers: headers,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetSettingsResponse =
        new operations.GetSettingsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.settingsObject = utils.objectToClass(
              httpRes?.data,
              shared.SettingsObject
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Retrieves a superfund by using a unique superfund ID
   */
  getSuperfund(
    req: operations.GetSuperfundRequest,
    security: operations.GetSuperfundSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.GetSuperfundResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetSuperfundRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/Superfunds/{SuperFundID}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.GetSuperfundSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };

    const r = client.request({
      url: url,
      method: "get",
      headers: headers,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetSuperfundResponse =
        new operations.GetSuperfundResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.superFunds = utils.objectToClass(
              httpRes?.data,
              shared.SuperFunds
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Retrieves superfund products
   */
  getSuperfundProducts(
    req: operations.GetSuperfundProductsRequest,
    security: operations.GetSuperfundProductsSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.GetSuperfundProductsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetSuperfundProductsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/SuperfundProducts";
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.GetSuperfundProductsSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      headers: headers,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetSuperfundProductsResponse =
        new operations.GetSuperfundProductsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.superFundProducts = utils.objectToClass(
              httpRes?.data,
              shared.SuperFundProducts
            );
          }
          break;
        case httpRes?.status == 400:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.apiException = utils.objectToClass(
              httpRes?.data,
              shared.APIException
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Retrieves superfunds
   */
  getSuperfunds(
    req: operations.GetSuperfundsRequest,
    security: operations.GetSuperfundsSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.GetSuperfundsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetSuperfundsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/Superfunds";
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.GetSuperfundsSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      headers: headers,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetSuperfundsResponse =
        new operations.GetSuperfundsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.superFunds = utils.objectToClass(
              httpRes?.data,
              shared.SuperFunds
            );
          }
          break;
        case httpRes?.status == 400:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.apiException = utils.objectToClass(
              httpRes?.data,
              shared.APIException
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Retrieves a timesheet by using a unique timesheet id
   */
  getTimesheet(
    req: operations.GetTimesheetRequest,
    security: operations.GetTimesheetSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.GetTimesheetResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetTimesheetRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/Timesheets/{TimesheetID}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.GetTimesheetSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };

    const r = client.request({
      url: url,
      method: "get",
      headers: headers,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetTimesheetResponse =
        new operations.GetTimesheetResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.timesheetObject = utils.objectToClass(
              httpRes?.data,
              shared.TimesheetObject
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Retrieves timesheets
   */
  getTimesheets(
    req: operations.GetTimesheetsRequest,
    security: operations.GetTimesheetsSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.GetTimesheetsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetTimesheetsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/Timesheets";
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.GetTimesheetsSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      headers: headers,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetTimesheetsResponse =
        new operations.GetTimesheetsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.timesheets = utils.objectToClass(
              httpRes?.data,
              shared.Timesheets
            );
          }
          break;
        case httpRes?.status == 400:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.apiException = utils.objectToClass(
              httpRes?.data,
              shared.APIException
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Updates an employee's detail
   *
   * @remarks
   * Update properties on a single employee
   */
  updateEmployee(
    req: operations.UpdateEmployeeRequest,
    security: operations.UpdateEmployeeSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.UpdateEmployeeResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.UpdateEmployeeRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/Employees/{EmployeeID}",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.UpdateEmployeeSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UpdateEmployeeResponse =
        new operations.UpdateEmployeeResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.employees = utils.objectToClass(
              httpRes?.data,
              shared.Employees
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Updates a specific leave application
   */
  updateLeaveApplication(
    req: operations.UpdateLeaveApplicationRequest,
    security: operations.UpdateLeaveApplicationSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.UpdateLeaveApplicationResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.UpdateLeaveApplicationRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/LeaveApplications/{LeaveApplicationID}",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.UpdateLeaveApplicationSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UpdateLeaveApplicationResponse =
        new operations.UpdateLeaveApplicationResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.leaveApplications = utils.objectToClass(
              httpRes?.data,
              shared.LeaveApplications
            );
          }
          break;
        case httpRes?.status == 400:
          break;
      }

      return res;
    });
  }

  /**
   * Updates a pay run
   *
   * @remarks
   * Update properties on a single PayRun
   */
  updatePayRun(
    req: operations.UpdatePayRunRequest,
    security: operations.UpdatePayRunSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.UpdatePayRunResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.UpdatePayRunRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(baseURL, "/PayRuns/{PayRunID}", req);

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.UpdatePayRunSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UpdatePayRunResponse =
        new operations.UpdatePayRunResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.payRuns = utils.objectToClass(httpRes?.data, shared.PayRuns);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Updates a payslip
   *
   * @remarks
   * Update lines on a single payslips
   */
  updatePayslip(
    req: operations.UpdatePayslipRequest,
    security: operations.UpdatePayslipSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.UpdatePayslipResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.UpdatePayslipRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(baseURL, "/Payslip/{PayslipID}", req);

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.UpdatePayslipSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UpdatePayslipResponse =
        new operations.UpdatePayslipResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.payslips = utils.objectToClass(httpRes?.data, shared.Payslips);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Updates a superfund
   *
   * @remarks
   * Update properties on a single Superfund
   */
  updateSuperfund(
    req: operations.UpdateSuperfundRequest,
    security: operations.UpdateSuperfundSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.UpdateSuperfundResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.UpdateSuperfundRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/Superfunds/{SuperFundID}",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.UpdateSuperfundSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UpdateSuperfundResponse =
        new operations.UpdateSuperfundResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.superFunds = utils.objectToClass(
              httpRes?.data,
              shared.SuperFunds
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Updates a timesheet
   *
   * @remarks
   * Update properties on a single timesheet
   */
  updateTimesheet(
    req: operations.UpdateTimesheetRequest,
    security: operations.UpdateTimesheetSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.UpdateTimesheetResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.UpdateTimesheetRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/Timesheets/{TimesheetID}",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.UpdateTimesheetSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UpdateTimesheetResponse =
        new operations.UpdateTimesheetResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.timesheets = utils.objectToClass(
              httpRes?.data,
              shared.Timesheets
            );
          }
          break;
      }

      return res;
    });
  }
}
