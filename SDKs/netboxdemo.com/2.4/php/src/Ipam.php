<?php

/**
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

declare(strict_types=1);

namespace OpenAPI\OpenAPI;

class Ipam 
{

	// SDK private variables namespaced with _ to avoid conflicts with API models
	private \GuzzleHttp\ClientInterface $_defaultClient;
	private \GuzzleHttp\ClientInterface $_securityClient;
	private string $_serverUrl;
	private string $_language;
	private string $_sdkVersion;
	private string $_genVersion;	

	/**
	 * @param \GuzzleHttp\ClientInterface $defaultClient
	 * @param \GuzzleHttp\ClientInterface $securityClient
	 * @param string $serverUrl
	 * @param string $language
	 * @param string $sdkVersion
	 * @param string $genVersion
	 */
	public function __construct(\GuzzleHttp\ClientInterface $defaultClient, \GuzzleHttp\ClientInterface $securityClient, string $serverUrl, string $language, string $sdkVersion, string $genVersion)
	{
		$this->_defaultClient = $defaultClient;
		$this->_securityClient = $securityClient;
		$this->_serverUrl = $serverUrl;
		$this->_language = $language;
		$this->_sdkVersion = $sdkVersion;
		$this->_genVersion = $genVersion;
	}
	
    /**
     * ipamChoicesList
     * 
     * @return \OpenAPI\OpenAPI\Models\Operations\IpamChoicesListResponse
     */
	public function ipamChoicesList(
    ): \OpenAPI\OpenAPI\Models\Operations\IpamChoicesListResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/ipam/_choices/');
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\IpamChoicesListResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
        }

        return $response;
    }
	
    /**
     * ipamChoicesRead
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\IpamChoicesReadRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\IpamChoicesReadResponse
     */
	public function ipamChoicesRead(
        \OpenAPI\OpenAPI\Models\Operations\IpamChoicesReadRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\IpamChoicesReadResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/ipam/_choices/{id}/', \OpenAPI\OpenAPI\Models\Operations\IpamChoicesReadRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\IpamChoicesReadResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
        }

        return $response;
    }
	
    /**
     * ipamAggregatesCreate
     * 
     * @param \OpenAPI\OpenAPI\Models\Shared\WritableAggregateInput $request
     * @return \OpenAPI\OpenAPI\Models\Operations\IpamAggregatesCreateResponse
     */
	public function ipamAggregatesCreate(
        \OpenAPI\OpenAPI\Models\Shared\WritableAggregateInput $request,
    ): \OpenAPI\OpenAPI\Models\Operations\IpamAggregatesCreateResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/ipam/aggregates/');
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "request", "json");
        if ($body === null) {
            throw new \Exception('Request body is required');
        }
        $options = array_merge_recursive($options, $body);
        
        $httpResponse = $this->_securityClient->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\IpamAggregatesCreateResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 201) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->aggregate = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\Aggregate', 'json');
            }
        }

        return $response;
    }
	
    /**
     * ipamAggregatesDelete
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\IpamAggregatesDeleteRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\IpamAggregatesDeleteResponse
     */
	public function ipamAggregatesDelete(
        \OpenAPI\OpenAPI\Models\Operations\IpamAggregatesDeleteRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\IpamAggregatesDeleteResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/ipam/aggregates/{id}/', \OpenAPI\OpenAPI\Models\Operations\IpamAggregatesDeleteRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_securityClient->request('DELETE', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\IpamAggregatesDeleteResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 204) {
        }

        return $response;
    }
	
    /**
     * ipamAggregatesList
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\IpamAggregatesListRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\IpamAggregatesListResponse
     */
	public function ipamAggregatesList(
        \OpenAPI\OpenAPI\Models\Operations\IpamAggregatesListRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\IpamAggregatesListResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/ipam/aggregates/');
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\IpamAggregatesListRequest::class, $request, null));
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\IpamAggregatesListResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->ipamAggregatesList200ApplicationJSONObject = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Operations\IpamAggregatesList200ApplicationJSON', 'json');
            }
        }

        return $response;
    }
	
    /**
     * ipamAggregatesPartialUpdate
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\IpamAggregatesPartialUpdateRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\IpamAggregatesPartialUpdateResponse
     */
	public function ipamAggregatesPartialUpdate(
        \OpenAPI\OpenAPI\Models\Operations\IpamAggregatesPartialUpdateRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\IpamAggregatesPartialUpdateResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/ipam/aggregates/{id}/', \OpenAPI\OpenAPI\Models\Operations\IpamAggregatesPartialUpdateRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "writableAggregateInput", "json");
        if ($body === null) {
            throw new \Exception('Request body is required');
        }
        $options = array_merge_recursive($options, $body);
        
        $httpResponse = $this->_securityClient->request('PATCH', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\IpamAggregatesPartialUpdateResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->aggregate = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\Aggregate', 'json');
            }
        }

        return $response;
    }
	
    /**
     * ipamAggregatesRead
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\IpamAggregatesReadRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\IpamAggregatesReadResponse
     */
	public function ipamAggregatesRead(
        \OpenAPI\OpenAPI\Models\Operations\IpamAggregatesReadRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\IpamAggregatesReadResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/ipam/aggregates/{id}/', \OpenAPI\OpenAPI\Models\Operations\IpamAggregatesReadRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\IpamAggregatesReadResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->aggregate = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\Aggregate', 'json');
            }
        }

        return $response;
    }
	
    /**
     * ipamAggregatesUpdate
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\IpamAggregatesUpdateRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\IpamAggregatesUpdateResponse
     */
	public function ipamAggregatesUpdate(
        \OpenAPI\OpenAPI\Models\Operations\IpamAggregatesUpdateRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\IpamAggregatesUpdateResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/ipam/aggregates/{id}/', \OpenAPI\OpenAPI\Models\Operations\IpamAggregatesUpdateRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "writableAggregateInput", "json");
        if ($body === null) {
            throw new \Exception('Request body is required');
        }
        $options = array_merge_recursive($options, $body);
        
        $httpResponse = $this->_securityClient->request('PUT', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\IpamAggregatesUpdateResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->aggregate = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\Aggregate', 'json');
            }
        }

        return $response;
    }
	
    /**
     * ipamIpAddressesCreate
     * 
     * @param \OpenAPI\OpenAPI\Models\Shared\WritableIPAddressInput $request
     * @return \OpenAPI\OpenAPI\Models\Operations\IpamIpAddressesCreateResponse
     */
	public function ipamIpAddressesCreate(
        \OpenAPI\OpenAPI\Models\Shared\WritableIPAddressInput $request,
    ): \OpenAPI\OpenAPI\Models\Operations\IpamIpAddressesCreateResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/ipam/ip-addresses/');
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "request", "json");
        if ($body === null) {
            throw new \Exception('Request body is required');
        }
        $options = array_merge_recursive($options, $body);
        
        $httpResponse = $this->_securityClient->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\IpamIpAddressesCreateResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 201) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->ipAddress = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\IPAddress', 'json');
            }
        }

        return $response;
    }
	
    /**
     * ipamIpAddressesDelete
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\IpamIpAddressesDeleteRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\IpamIpAddressesDeleteResponse
     */
	public function ipamIpAddressesDelete(
        \OpenAPI\OpenAPI\Models\Operations\IpamIpAddressesDeleteRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\IpamIpAddressesDeleteResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/ipam/ip-addresses/{id}/', \OpenAPI\OpenAPI\Models\Operations\IpamIpAddressesDeleteRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_securityClient->request('DELETE', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\IpamIpAddressesDeleteResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 204) {
        }

        return $response;
    }
	
    /**
     * ipamIpAddressesList
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\IpamIpAddressesListRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\IpamIpAddressesListResponse
     */
	public function ipamIpAddressesList(
        \OpenAPI\OpenAPI\Models\Operations\IpamIpAddressesListRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\IpamIpAddressesListResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/ipam/ip-addresses/');
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\IpamIpAddressesListRequest::class, $request, null));
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\IpamIpAddressesListResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->ipamIpAddressesList200ApplicationJSONObject = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Operations\IpamIpAddressesList200ApplicationJSON', 'json');
            }
        }

        return $response;
    }
	
    /**
     * ipamIpAddressesPartialUpdate
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\IpamIpAddressesPartialUpdateRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\IpamIpAddressesPartialUpdateResponse
     */
	public function ipamIpAddressesPartialUpdate(
        \OpenAPI\OpenAPI\Models\Operations\IpamIpAddressesPartialUpdateRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\IpamIpAddressesPartialUpdateResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/ipam/ip-addresses/{id}/', \OpenAPI\OpenAPI\Models\Operations\IpamIpAddressesPartialUpdateRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "writableIPAddressInput", "json");
        if ($body === null) {
            throw new \Exception('Request body is required');
        }
        $options = array_merge_recursive($options, $body);
        
        $httpResponse = $this->_securityClient->request('PATCH', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\IpamIpAddressesPartialUpdateResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->ipAddress = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\IPAddress', 'json');
            }
        }

        return $response;
    }
	
    /**
     * ipamIpAddressesRead
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\IpamIpAddressesReadRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\IpamIpAddressesReadResponse
     */
	public function ipamIpAddressesRead(
        \OpenAPI\OpenAPI\Models\Operations\IpamIpAddressesReadRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\IpamIpAddressesReadResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/ipam/ip-addresses/{id}/', \OpenAPI\OpenAPI\Models\Operations\IpamIpAddressesReadRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\IpamIpAddressesReadResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->ipAddress = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\IPAddress', 'json');
            }
        }

        return $response;
    }
	
    /**
     * ipamIpAddressesUpdate
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\IpamIpAddressesUpdateRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\IpamIpAddressesUpdateResponse
     */
	public function ipamIpAddressesUpdate(
        \OpenAPI\OpenAPI\Models\Operations\IpamIpAddressesUpdateRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\IpamIpAddressesUpdateResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/ipam/ip-addresses/{id}/', \OpenAPI\OpenAPI\Models\Operations\IpamIpAddressesUpdateRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "writableIPAddressInput", "json");
        if ($body === null) {
            throw new \Exception('Request body is required');
        }
        $options = array_merge_recursive($options, $body);
        
        $httpResponse = $this->_securityClient->request('PUT', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\IpamIpAddressesUpdateResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->ipAddress = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\IPAddress', 'json');
            }
        }

        return $response;
    }
	
    /**
     * A convenience method for returning available IP addresses within a prefix. By default, the number of IPs
     * returned will be equivalent to PAGINATE_COUNT. An arbitrary limit (up to MAX_PAGE_SIZE, if set) may be passed,
     * however results will not be paginated.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\IpamPrefixesAvailableIpsCreateRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\IpamPrefixesAvailableIpsCreateResponse
     */
	public function ipamPrefixesAvailableIpsCreate(
        \OpenAPI\OpenAPI\Models\Operations\IpamPrefixesAvailableIpsCreateRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\IpamPrefixesAvailableIpsCreateResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/ipam/prefixes/{id}/available-ips/', \OpenAPI\OpenAPI\Models\Operations\IpamPrefixesAvailableIpsCreateRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "writablePrefixInput", "json");
        if ($body === null) {
            throw new \Exception('Request body is required');
        }
        $options = array_merge_recursive($options, $body);
        
        $httpResponse = $this->_securityClient->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\IpamPrefixesAvailableIpsCreateResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 201) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->prefix = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\Prefix', 'json');
            }
        }

        return $response;
    }
	
    /**
     * A convenience method for returning available IP addresses within a prefix. By default, the number of IPs
     * returned will be equivalent to PAGINATE_COUNT. An arbitrary limit (up to MAX_PAGE_SIZE, if set) may be passed,
     * however results will not be paginated.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\IpamPrefixesAvailableIpsReadRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\IpamPrefixesAvailableIpsReadResponse
     */
	public function ipamPrefixesAvailableIpsRead(
        \OpenAPI\OpenAPI\Models\Operations\IpamPrefixesAvailableIpsReadRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\IpamPrefixesAvailableIpsReadResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/ipam/prefixes/{id}/available-ips/', \OpenAPI\OpenAPI\Models\Operations\IpamPrefixesAvailableIpsReadRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\IpamPrefixesAvailableIpsReadResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->prefix = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\Prefix', 'json');
            }
        }

        return $response;
    }
	
    /**
     * A convenience method for returning available child prefixes within a parent.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\IpamPrefixesAvailablePrefixesCreateRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\IpamPrefixesAvailablePrefixesCreateResponse
     */
	public function ipamPrefixesAvailablePrefixesCreate(
        \OpenAPI\OpenAPI\Models\Operations\IpamPrefixesAvailablePrefixesCreateRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\IpamPrefixesAvailablePrefixesCreateResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/ipam/prefixes/{id}/available-prefixes/', \OpenAPI\OpenAPI\Models\Operations\IpamPrefixesAvailablePrefixesCreateRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "writablePrefixInput", "json");
        if ($body === null) {
            throw new \Exception('Request body is required');
        }
        $options = array_merge_recursive($options, $body);
        
        $httpResponse = $this->_securityClient->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\IpamPrefixesAvailablePrefixesCreateResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 201) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->prefix = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\Prefix', 'json');
            }
        }

        return $response;
    }
	
    /**
     * A convenience method for returning available child prefixes within a parent.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\IpamPrefixesAvailablePrefixesReadRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\IpamPrefixesAvailablePrefixesReadResponse
     */
	public function ipamPrefixesAvailablePrefixesRead(
        \OpenAPI\OpenAPI\Models\Operations\IpamPrefixesAvailablePrefixesReadRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\IpamPrefixesAvailablePrefixesReadResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/ipam/prefixes/{id}/available-prefixes/', \OpenAPI\OpenAPI\Models\Operations\IpamPrefixesAvailablePrefixesReadRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\IpamPrefixesAvailablePrefixesReadResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->prefix = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\Prefix', 'json');
            }
        }

        return $response;
    }
	
    /**
     * ipamPrefixesCreate
     * 
     * @param \OpenAPI\OpenAPI\Models\Shared\WritablePrefixInput $request
     * @return \OpenAPI\OpenAPI\Models\Operations\IpamPrefixesCreateResponse
     */
	public function ipamPrefixesCreate(
        \OpenAPI\OpenAPI\Models\Shared\WritablePrefixInput $request,
    ): \OpenAPI\OpenAPI\Models\Operations\IpamPrefixesCreateResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/ipam/prefixes/');
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "request", "json");
        if ($body === null) {
            throw new \Exception('Request body is required');
        }
        $options = array_merge_recursive($options, $body);
        
        $httpResponse = $this->_securityClient->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\IpamPrefixesCreateResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 201) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->prefix = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\Prefix', 'json');
            }
        }

        return $response;
    }
	
    /**
     * ipamPrefixesDelete
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\IpamPrefixesDeleteRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\IpamPrefixesDeleteResponse
     */
	public function ipamPrefixesDelete(
        \OpenAPI\OpenAPI\Models\Operations\IpamPrefixesDeleteRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\IpamPrefixesDeleteResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/ipam/prefixes/{id}/', \OpenAPI\OpenAPI\Models\Operations\IpamPrefixesDeleteRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_securityClient->request('DELETE', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\IpamPrefixesDeleteResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 204) {
        }

        return $response;
    }
	
    /**
     * ipamPrefixesList
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\IpamPrefixesListRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\IpamPrefixesListResponse
     */
	public function ipamPrefixesList(
        \OpenAPI\OpenAPI\Models\Operations\IpamPrefixesListRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\IpamPrefixesListResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/ipam/prefixes/');
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\IpamPrefixesListRequest::class, $request, null));
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\IpamPrefixesListResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->ipamPrefixesList200ApplicationJSONObject = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Operations\IpamPrefixesList200ApplicationJSON', 'json');
            }
        }

        return $response;
    }
	
    /**
     * ipamPrefixesPartialUpdate
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\IpamPrefixesPartialUpdateRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\IpamPrefixesPartialUpdateResponse
     */
	public function ipamPrefixesPartialUpdate(
        \OpenAPI\OpenAPI\Models\Operations\IpamPrefixesPartialUpdateRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\IpamPrefixesPartialUpdateResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/ipam/prefixes/{id}/', \OpenAPI\OpenAPI\Models\Operations\IpamPrefixesPartialUpdateRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "writablePrefixInput", "json");
        if ($body === null) {
            throw new \Exception('Request body is required');
        }
        $options = array_merge_recursive($options, $body);
        
        $httpResponse = $this->_securityClient->request('PATCH', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\IpamPrefixesPartialUpdateResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->prefix = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\Prefix', 'json');
            }
        }

        return $response;
    }
	
    /**
     * ipamPrefixesRead
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\IpamPrefixesReadRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\IpamPrefixesReadResponse
     */
	public function ipamPrefixesRead(
        \OpenAPI\OpenAPI\Models\Operations\IpamPrefixesReadRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\IpamPrefixesReadResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/ipam/prefixes/{id}/', \OpenAPI\OpenAPI\Models\Operations\IpamPrefixesReadRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\IpamPrefixesReadResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->prefix = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\Prefix', 'json');
            }
        }

        return $response;
    }
	
    /**
     * ipamPrefixesUpdate
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\IpamPrefixesUpdateRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\IpamPrefixesUpdateResponse
     */
	public function ipamPrefixesUpdate(
        \OpenAPI\OpenAPI\Models\Operations\IpamPrefixesUpdateRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\IpamPrefixesUpdateResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/ipam/prefixes/{id}/', \OpenAPI\OpenAPI\Models\Operations\IpamPrefixesUpdateRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "writablePrefixInput", "json");
        if ($body === null) {
            throw new \Exception('Request body is required');
        }
        $options = array_merge_recursive($options, $body);
        
        $httpResponse = $this->_securityClient->request('PUT', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\IpamPrefixesUpdateResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->prefix = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\Prefix', 'json');
            }
        }

        return $response;
    }
	
    /**
     * ipamRirsCreate
     * 
     * @param \OpenAPI\OpenAPI\Models\Shared\RIRInput $request
     * @return \OpenAPI\OpenAPI\Models\Operations\IpamRirsCreateResponse
     */
	public function ipamRirsCreate(
        \OpenAPI\OpenAPI\Models\Shared\RIRInput $request,
    ): \OpenAPI\OpenAPI\Models\Operations\IpamRirsCreateResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/ipam/rirs/');
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "request", "json");
        if ($body === null) {
            throw new \Exception('Request body is required');
        }
        $options = array_merge_recursive($options, $body);
        
        $httpResponse = $this->_securityClient->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\IpamRirsCreateResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 201) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->rir = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\Rir', 'json');
            }
        }

        return $response;
    }
	
    /**
     * ipamRirsDelete
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\IpamRirsDeleteRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\IpamRirsDeleteResponse
     */
	public function ipamRirsDelete(
        \OpenAPI\OpenAPI\Models\Operations\IpamRirsDeleteRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\IpamRirsDeleteResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/ipam/rirs/{id}/', \OpenAPI\OpenAPI\Models\Operations\IpamRirsDeleteRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_securityClient->request('DELETE', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\IpamRirsDeleteResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 204) {
        }

        return $response;
    }
	
    /**
     * ipamRirsList
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\IpamRirsListRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\IpamRirsListResponse
     */
	public function ipamRirsList(
        \OpenAPI\OpenAPI\Models\Operations\IpamRirsListRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\IpamRirsListResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/ipam/rirs/');
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\IpamRirsListRequest::class, $request, null));
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\IpamRirsListResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->ipamRirsList200ApplicationJSONObject = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Operations\IpamRirsList200ApplicationJSON', 'json');
            }
        }

        return $response;
    }
	
    /**
     * ipamRirsPartialUpdate
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\IpamRirsPartialUpdateRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\IpamRirsPartialUpdateResponse
     */
	public function ipamRirsPartialUpdate(
        \OpenAPI\OpenAPI\Models\Operations\IpamRirsPartialUpdateRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\IpamRirsPartialUpdateResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/ipam/rirs/{id}/', \OpenAPI\OpenAPI\Models\Operations\IpamRirsPartialUpdateRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "rirInput", "json");
        if ($body === null) {
            throw new \Exception('Request body is required');
        }
        $options = array_merge_recursive($options, $body);
        
        $httpResponse = $this->_securityClient->request('PATCH', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\IpamRirsPartialUpdateResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->rir = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\Rir', 'json');
            }
        }

        return $response;
    }
	
    /**
     * ipamRirsRead
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\IpamRirsReadRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\IpamRirsReadResponse
     */
	public function ipamRirsRead(
        \OpenAPI\OpenAPI\Models\Operations\IpamRirsReadRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\IpamRirsReadResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/ipam/rirs/{id}/', \OpenAPI\OpenAPI\Models\Operations\IpamRirsReadRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\IpamRirsReadResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->rir = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\Rir', 'json');
            }
        }

        return $response;
    }
	
    /**
     * ipamRirsUpdate
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\IpamRirsUpdateRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\IpamRirsUpdateResponse
     */
	public function ipamRirsUpdate(
        \OpenAPI\OpenAPI\Models\Operations\IpamRirsUpdateRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\IpamRirsUpdateResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/ipam/rirs/{id}/', \OpenAPI\OpenAPI\Models\Operations\IpamRirsUpdateRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "rirInput", "json");
        if ($body === null) {
            throw new \Exception('Request body is required');
        }
        $options = array_merge_recursive($options, $body);
        
        $httpResponse = $this->_securityClient->request('PUT', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\IpamRirsUpdateResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->rir = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\Rir', 'json');
            }
        }

        return $response;
    }
	
    /**
     * ipamRolesCreate
     * 
     * @param \OpenAPI\OpenAPI\Models\Shared\RoleInput $request
     * @return \OpenAPI\OpenAPI\Models\Operations\IpamRolesCreateResponse
     */
	public function ipamRolesCreate(
        \OpenAPI\OpenAPI\Models\Shared\RoleInput $request,
    ): \OpenAPI\OpenAPI\Models\Operations\IpamRolesCreateResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/ipam/roles/');
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "request", "json");
        if ($body === null) {
            throw new \Exception('Request body is required');
        }
        $options = array_merge_recursive($options, $body);
        
        $httpResponse = $this->_securityClient->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\IpamRolesCreateResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 201) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->role = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\Role', 'json');
            }
        }

        return $response;
    }
	
    /**
     * ipamRolesDelete
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\IpamRolesDeleteRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\IpamRolesDeleteResponse
     */
	public function ipamRolesDelete(
        \OpenAPI\OpenAPI\Models\Operations\IpamRolesDeleteRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\IpamRolesDeleteResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/ipam/roles/{id}/', \OpenAPI\OpenAPI\Models\Operations\IpamRolesDeleteRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_securityClient->request('DELETE', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\IpamRolesDeleteResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 204) {
        }

        return $response;
    }
	
    /**
     * ipamRolesList
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\IpamRolesListRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\IpamRolesListResponse
     */
	public function ipamRolesList(
        \OpenAPI\OpenAPI\Models\Operations\IpamRolesListRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\IpamRolesListResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/ipam/roles/');
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\IpamRolesListRequest::class, $request, null));
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\IpamRolesListResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->ipamRolesList200ApplicationJSONObject = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Operations\IpamRolesList200ApplicationJSON', 'json');
            }
        }

        return $response;
    }
	
    /**
     * ipamRolesPartialUpdate
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\IpamRolesPartialUpdateRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\IpamRolesPartialUpdateResponse
     */
	public function ipamRolesPartialUpdate(
        \OpenAPI\OpenAPI\Models\Operations\IpamRolesPartialUpdateRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\IpamRolesPartialUpdateResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/ipam/roles/{id}/', \OpenAPI\OpenAPI\Models\Operations\IpamRolesPartialUpdateRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "roleInput", "json");
        if ($body === null) {
            throw new \Exception('Request body is required');
        }
        $options = array_merge_recursive($options, $body);
        
        $httpResponse = $this->_securityClient->request('PATCH', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\IpamRolesPartialUpdateResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->role = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\Role', 'json');
            }
        }

        return $response;
    }
	
    /**
     * ipamRolesRead
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\IpamRolesReadRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\IpamRolesReadResponse
     */
	public function ipamRolesRead(
        \OpenAPI\OpenAPI\Models\Operations\IpamRolesReadRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\IpamRolesReadResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/ipam/roles/{id}/', \OpenAPI\OpenAPI\Models\Operations\IpamRolesReadRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\IpamRolesReadResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->role = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\Role', 'json');
            }
        }

        return $response;
    }
	
    /**
     * ipamRolesUpdate
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\IpamRolesUpdateRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\IpamRolesUpdateResponse
     */
	public function ipamRolesUpdate(
        \OpenAPI\OpenAPI\Models\Operations\IpamRolesUpdateRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\IpamRolesUpdateResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/ipam/roles/{id}/', \OpenAPI\OpenAPI\Models\Operations\IpamRolesUpdateRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "roleInput", "json");
        if ($body === null) {
            throw new \Exception('Request body is required');
        }
        $options = array_merge_recursive($options, $body);
        
        $httpResponse = $this->_securityClient->request('PUT', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\IpamRolesUpdateResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->role = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\Role', 'json');
            }
        }

        return $response;
    }
	
    /**
     * ipamServicesCreate
     * 
     * @param \OpenAPI\OpenAPI\Models\Shared\WritableServiceInput $request
     * @return \OpenAPI\OpenAPI\Models\Operations\IpamServicesCreateResponse
     */
	public function ipamServicesCreate(
        \OpenAPI\OpenAPI\Models\Shared\WritableServiceInput $request,
    ): \OpenAPI\OpenAPI\Models\Operations\IpamServicesCreateResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/ipam/services/');
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "request", "json");
        if ($body === null) {
            throw new \Exception('Request body is required');
        }
        $options = array_merge_recursive($options, $body);
        
        $httpResponse = $this->_securityClient->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\IpamServicesCreateResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 201) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->service = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\Service', 'json');
            }
        }

        return $response;
    }
	
    /**
     * ipamServicesDelete
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\IpamServicesDeleteRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\IpamServicesDeleteResponse
     */
	public function ipamServicesDelete(
        \OpenAPI\OpenAPI\Models\Operations\IpamServicesDeleteRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\IpamServicesDeleteResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/ipam/services/{id}/', \OpenAPI\OpenAPI\Models\Operations\IpamServicesDeleteRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_securityClient->request('DELETE', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\IpamServicesDeleteResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 204) {
        }

        return $response;
    }
	
    /**
     * ipamServicesList
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\IpamServicesListRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\IpamServicesListResponse
     */
	public function ipamServicesList(
        \OpenAPI\OpenAPI\Models\Operations\IpamServicesListRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\IpamServicesListResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/ipam/services/');
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\IpamServicesListRequest::class, $request, null));
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\IpamServicesListResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->ipamServicesList200ApplicationJSONObject = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Operations\IpamServicesList200ApplicationJSON', 'json');
            }
        }

        return $response;
    }
	
    /**
     * ipamServicesPartialUpdate
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\IpamServicesPartialUpdateRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\IpamServicesPartialUpdateResponse
     */
	public function ipamServicesPartialUpdate(
        \OpenAPI\OpenAPI\Models\Operations\IpamServicesPartialUpdateRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\IpamServicesPartialUpdateResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/ipam/services/{id}/', \OpenAPI\OpenAPI\Models\Operations\IpamServicesPartialUpdateRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "writableServiceInput", "json");
        if ($body === null) {
            throw new \Exception('Request body is required');
        }
        $options = array_merge_recursive($options, $body);
        
        $httpResponse = $this->_securityClient->request('PATCH', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\IpamServicesPartialUpdateResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->service = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\Service', 'json');
            }
        }

        return $response;
    }
	
    /**
     * ipamServicesRead
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\IpamServicesReadRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\IpamServicesReadResponse
     */
	public function ipamServicesRead(
        \OpenAPI\OpenAPI\Models\Operations\IpamServicesReadRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\IpamServicesReadResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/ipam/services/{id}/', \OpenAPI\OpenAPI\Models\Operations\IpamServicesReadRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\IpamServicesReadResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->service = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\Service', 'json');
            }
        }

        return $response;
    }
	
    /**
     * ipamServicesUpdate
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\IpamServicesUpdateRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\IpamServicesUpdateResponse
     */
	public function ipamServicesUpdate(
        \OpenAPI\OpenAPI\Models\Operations\IpamServicesUpdateRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\IpamServicesUpdateResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/ipam/services/{id}/', \OpenAPI\OpenAPI\Models\Operations\IpamServicesUpdateRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "writableServiceInput", "json");
        if ($body === null) {
            throw new \Exception('Request body is required');
        }
        $options = array_merge_recursive($options, $body);
        
        $httpResponse = $this->_securityClient->request('PUT', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\IpamServicesUpdateResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->service = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\Service', 'json');
            }
        }

        return $response;
    }
	
    /**
     * ipamVlanGroupsCreate
     * 
     * @param \OpenAPI\OpenAPI\Models\Shared\WritableVLANGroupInput $request
     * @return \OpenAPI\OpenAPI\Models\Operations\IpamVlanGroupsCreateResponse
     */
	public function ipamVlanGroupsCreate(
        \OpenAPI\OpenAPI\Models\Shared\WritableVLANGroupInput $request,
    ): \OpenAPI\OpenAPI\Models\Operations\IpamVlanGroupsCreateResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/ipam/vlan-groups/');
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "request", "json");
        if ($body === null) {
            throw new \Exception('Request body is required');
        }
        $options = array_merge_recursive($options, $body);
        
        $httpResponse = $this->_securityClient->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\IpamVlanGroupsCreateResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 201) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->vlanGroup = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\VLANGroup', 'json');
            }
        }

        return $response;
    }
	
    /**
     * ipamVlanGroupsDelete
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\IpamVlanGroupsDeleteRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\IpamVlanGroupsDeleteResponse
     */
	public function ipamVlanGroupsDelete(
        \OpenAPI\OpenAPI\Models\Operations\IpamVlanGroupsDeleteRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\IpamVlanGroupsDeleteResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/ipam/vlan-groups/{id}/', \OpenAPI\OpenAPI\Models\Operations\IpamVlanGroupsDeleteRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_securityClient->request('DELETE', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\IpamVlanGroupsDeleteResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 204) {
        }

        return $response;
    }
	
    /**
     * ipamVlanGroupsList
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\IpamVlanGroupsListRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\IpamVlanGroupsListResponse
     */
	public function ipamVlanGroupsList(
        \OpenAPI\OpenAPI\Models\Operations\IpamVlanGroupsListRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\IpamVlanGroupsListResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/ipam/vlan-groups/');
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\IpamVlanGroupsListRequest::class, $request, null));
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\IpamVlanGroupsListResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->ipamVlanGroupsList200ApplicationJSONObject = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Operations\IpamVlanGroupsList200ApplicationJSON', 'json');
            }
        }

        return $response;
    }
	
    /**
     * ipamVlanGroupsPartialUpdate
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\IpamVlanGroupsPartialUpdateRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\IpamVlanGroupsPartialUpdateResponse
     */
	public function ipamVlanGroupsPartialUpdate(
        \OpenAPI\OpenAPI\Models\Operations\IpamVlanGroupsPartialUpdateRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\IpamVlanGroupsPartialUpdateResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/ipam/vlan-groups/{id}/', \OpenAPI\OpenAPI\Models\Operations\IpamVlanGroupsPartialUpdateRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "writableVLANGroupInput", "json");
        if ($body === null) {
            throw new \Exception('Request body is required');
        }
        $options = array_merge_recursive($options, $body);
        
        $httpResponse = $this->_securityClient->request('PATCH', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\IpamVlanGroupsPartialUpdateResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->vlanGroup = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\VLANGroup', 'json');
            }
        }

        return $response;
    }
	
    /**
     * ipamVlanGroupsRead
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\IpamVlanGroupsReadRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\IpamVlanGroupsReadResponse
     */
	public function ipamVlanGroupsRead(
        \OpenAPI\OpenAPI\Models\Operations\IpamVlanGroupsReadRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\IpamVlanGroupsReadResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/ipam/vlan-groups/{id}/', \OpenAPI\OpenAPI\Models\Operations\IpamVlanGroupsReadRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\IpamVlanGroupsReadResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->vlanGroup = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\VLANGroup', 'json');
            }
        }

        return $response;
    }
	
    /**
     * ipamVlanGroupsUpdate
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\IpamVlanGroupsUpdateRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\IpamVlanGroupsUpdateResponse
     */
	public function ipamVlanGroupsUpdate(
        \OpenAPI\OpenAPI\Models\Operations\IpamVlanGroupsUpdateRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\IpamVlanGroupsUpdateResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/ipam/vlan-groups/{id}/', \OpenAPI\OpenAPI\Models\Operations\IpamVlanGroupsUpdateRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "writableVLANGroupInput", "json");
        if ($body === null) {
            throw new \Exception('Request body is required');
        }
        $options = array_merge_recursive($options, $body);
        
        $httpResponse = $this->_securityClient->request('PUT', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\IpamVlanGroupsUpdateResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->vlanGroup = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\VLANGroup', 'json');
            }
        }

        return $response;
    }
	
    /**
     * ipamVlansCreate
     * 
     * @param \OpenAPI\OpenAPI\Models\Shared\WritableVLANInput $request
     * @return \OpenAPI\OpenAPI\Models\Operations\IpamVlansCreateResponse
     */
	public function ipamVlansCreate(
        \OpenAPI\OpenAPI\Models\Shared\WritableVLANInput $request,
    ): \OpenAPI\OpenAPI\Models\Operations\IpamVlansCreateResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/ipam/vlans/');
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "request", "json");
        if ($body === null) {
            throw new \Exception('Request body is required');
        }
        $options = array_merge_recursive($options, $body);
        
        $httpResponse = $this->_securityClient->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\IpamVlansCreateResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 201) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->vlan = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\Vlan', 'json');
            }
        }

        return $response;
    }
	
    /**
     * ipamVlansDelete
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\IpamVlansDeleteRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\IpamVlansDeleteResponse
     */
	public function ipamVlansDelete(
        \OpenAPI\OpenAPI\Models\Operations\IpamVlansDeleteRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\IpamVlansDeleteResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/ipam/vlans/{id}/', \OpenAPI\OpenAPI\Models\Operations\IpamVlansDeleteRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_securityClient->request('DELETE', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\IpamVlansDeleteResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 204) {
        }

        return $response;
    }
	
    /**
     * ipamVlansList
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\IpamVlansListRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\IpamVlansListResponse
     */
	public function ipamVlansList(
        \OpenAPI\OpenAPI\Models\Operations\IpamVlansListRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\IpamVlansListResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/ipam/vlans/');
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\IpamVlansListRequest::class, $request, null));
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\IpamVlansListResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->ipamVlansList200ApplicationJSONObject = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Operations\IpamVlansList200ApplicationJSON', 'json');
            }
        }

        return $response;
    }
	
    /**
     * ipamVlansPartialUpdate
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\IpamVlansPartialUpdateRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\IpamVlansPartialUpdateResponse
     */
	public function ipamVlansPartialUpdate(
        \OpenAPI\OpenAPI\Models\Operations\IpamVlansPartialUpdateRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\IpamVlansPartialUpdateResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/ipam/vlans/{id}/', \OpenAPI\OpenAPI\Models\Operations\IpamVlansPartialUpdateRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "writableVLANInput", "json");
        if ($body === null) {
            throw new \Exception('Request body is required');
        }
        $options = array_merge_recursive($options, $body);
        
        $httpResponse = $this->_securityClient->request('PATCH', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\IpamVlansPartialUpdateResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->vlan = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\Vlan', 'json');
            }
        }

        return $response;
    }
	
    /**
     * ipamVlansRead
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\IpamVlansReadRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\IpamVlansReadResponse
     */
	public function ipamVlansRead(
        \OpenAPI\OpenAPI\Models\Operations\IpamVlansReadRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\IpamVlansReadResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/ipam/vlans/{id}/', \OpenAPI\OpenAPI\Models\Operations\IpamVlansReadRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\IpamVlansReadResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->vlan = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\Vlan', 'json');
            }
        }

        return $response;
    }
	
    /**
     * ipamVlansUpdate
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\IpamVlansUpdateRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\IpamVlansUpdateResponse
     */
	public function ipamVlansUpdate(
        \OpenAPI\OpenAPI\Models\Operations\IpamVlansUpdateRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\IpamVlansUpdateResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/ipam/vlans/{id}/', \OpenAPI\OpenAPI\Models\Operations\IpamVlansUpdateRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "writableVLANInput", "json");
        if ($body === null) {
            throw new \Exception('Request body is required');
        }
        $options = array_merge_recursive($options, $body);
        
        $httpResponse = $this->_securityClient->request('PUT', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\IpamVlansUpdateResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->vlan = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\Vlan', 'json');
            }
        }

        return $response;
    }
	
    /**
     * ipamVrfsCreate
     * 
     * @param \OpenAPI\OpenAPI\Models\Shared\WritableVRFInput $request
     * @return \OpenAPI\OpenAPI\Models\Operations\IpamVrfsCreateResponse
     */
	public function ipamVrfsCreate(
        \OpenAPI\OpenAPI\Models\Shared\WritableVRFInput $request,
    ): \OpenAPI\OpenAPI\Models\Operations\IpamVrfsCreateResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/ipam/vrfs/');
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "request", "json");
        if ($body === null) {
            throw new \Exception('Request body is required');
        }
        $options = array_merge_recursive($options, $body);
        
        $httpResponse = $this->_securityClient->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\IpamVrfsCreateResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 201) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->vrf = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\Vrf', 'json');
            }
        }

        return $response;
    }
	
    /**
     * ipamVrfsDelete
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\IpamVrfsDeleteRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\IpamVrfsDeleteResponse
     */
	public function ipamVrfsDelete(
        \OpenAPI\OpenAPI\Models\Operations\IpamVrfsDeleteRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\IpamVrfsDeleteResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/ipam/vrfs/{id}/', \OpenAPI\OpenAPI\Models\Operations\IpamVrfsDeleteRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_securityClient->request('DELETE', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\IpamVrfsDeleteResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 204) {
        }

        return $response;
    }
	
    /**
     * ipamVrfsList
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\IpamVrfsListRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\IpamVrfsListResponse
     */
	public function ipamVrfsList(
        \OpenAPI\OpenAPI\Models\Operations\IpamVrfsListRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\IpamVrfsListResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/ipam/vrfs/');
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\IpamVrfsListRequest::class, $request, null));
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\IpamVrfsListResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->ipamVrfsList200ApplicationJSONObject = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Operations\IpamVrfsList200ApplicationJSON', 'json');
            }
        }

        return $response;
    }
	
    /**
     * ipamVrfsPartialUpdate
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\IpamVrfsPartialUpdateRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\IpamVrfsPartialUpdateResponse
     */
	public function ipamVrfsPartialUpdate(
        \OpenAPI\OpenAPI\Models\Operations\IpamVrfsPartialUpdateRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\IpamVrfsPartialUpdateResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/ipam/vrfs/{id}/', \OpenAPI\OpenAPI\Models\Operations\IpamVrfsPartialUpdateRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "writableVRFInput", "json");
        if ($body === null) {
            throw new \Exception('Request body is required');
        }
        $options = array_merge_recursive($options, $body);
        
        $httpResponse = $this->_securityClient->request('PATCH', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\IpamVrfsPartialUpdateResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->vrf = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\Vrf', 'json');
            }
        }

        return $response;
    }
	
    /**
     * ipamVrfsRead
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\IpamVrfsReadRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\IpamVrfsReadResponse
     */
	public function ipamVrfsRead(
        \OpenAPI\OpenAPI\Models\Operations\IpamVrfsReadRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\IpamVrfsReadResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/ipam/vrfs/{id}/', \OpenAPI\OpenAPI\Models\Operations\IpamVrfsReadRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\IpamVrfsReadResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->vrf = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\Vrf', 'json');
            }
        }

        return $response;
    }
	
    /**
     * ipamVrfsUpdate
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\IpamVrfsUpdateRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\IpamVrfsUpdateResponse
     */
	public function ipamVrfsUpdate(
        \OpenAPI\OpenAPI\Models\Operations\IpamVrfsUpdateRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\IpamVrfsUpdateResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/ipam/vrfs/{id}/', \OpenAPI\OpenAPI\Models\Operations\IpamVrfsUpdateRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "writableVRFInput", "json");
        if ($body === null) {
            throw new \Exception('Request body is required');
        }
        $options = array_merge_recursive($options, $body);
        
        $httpResponse = $this->_securityClient->request('PUT', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\IpamVrfsUpdateResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->vrf = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\Vrf', 'json');
            }
        }

        return $response;
    }
}