/*
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

import * as utils from "../internal/utils";
import * as operations from "./models/operations";
import * as shared from "./models/shared";
import { AxiosInstance, AxiosRequestConfig, AxiosResponse } from "axios";

export class PricesAndFixedPrices {
  _defaultClient: AxiosInstance;
  _securityClient: AxiosInstance;
  _serverURL: string;
  _language: string;
  _sdkVersion: string;
  _genVersion: string;

  constructor(
    defaultClient: AxiosInstance,
    securityClient: AxiosInstance,
    serverURL: string,
    language: string,
    sdkVersion: string,
    genVersion: string
  ) {
    this._defaultClient = defaultClient;
    this._securityClient = securityClient;
    this._serverURL = serverURL;
    this._language = language;
    this._sdkVersion = sdkVersion;
    this._genVersion = genVersion;
  }

  /**
   * Create or Update Base Price or Fixed Prices
   *
   * @remarks
   * Creates or updates an SKU Base Price or Fixed Prices. The **base price** is the basic selling price of a product, it comprises the cost price and the markup wanted in the sale of the product. The **fixed price** is an optional price of the SKU for a specific trade policy with a specific minimum quantity to be activated.
   *
   *  <p> You may optionally set a list price. Additionally, you may set either a cost price or a markup value. By defining either one of them, the other will be calculated to conform to the formula <code>costPrice * (1 + markup) = basePrice</code>.</p> <h2>Request body example</h2>
   *
   * ```json
   * {
   *     "markup": 30,
   *     "basePrice": 100,
   *     "listPrice": 35,
   *     "fixedPrices": [
   *         {
   *             "tradePolicyId": "1",
   *             "value": 31,
   *             "listPrice": 32,
   *             "minQuantity": 1,
   *             "dateRange": {
   *                 "from": "2022-05-21T22:00:00Z",
   *                 "to": "2023-05-28T22:00:00Z"
   *             }
   *         },
   *         {
   *             "tradePolicyId": "1",
   *             "value": 31.5,
   *             "listPrice": 33,
   *             "minQuantity": 2
   *         }
   *     ]
   * }
   * ```
   */
  createUpdatePriceOrFixedPrice(
    req: operations.CreateUpdatePriceOrFixedPriceRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.CreateUpdatePriceOrFixedPriceResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CreateUpdatePriceOrFixedPriceRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/pricing/prices/{itemId}",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };

    const r = client.request({
      url: url,
      method: "put",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CreateUpdatePriceOrFixedPriceResponse =
        new operations.CreateUpdatePriceOrFixedPriceResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          break;
      }

      return res;
    });
  }

  /**
   * Delete Price
   *
   * @remarks
   * Deletes the Base Price and all available Fixed Prices for an SKU in all trade policies.
   */
  deletePrice(
    req: operations.DeletePriceRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.DeletePriceResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DeletePriceRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/pricing/prices/{itemId}",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };

    const r = client.request({
      url: url,
      method: "delete",
      headers: headers,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DeletePriceResponse =
        new operations.DeletePriceResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          break;
      }

      return res;
    });
  }

  /**
   * Delete Fixed Prices on a price table or trade policy
   *
   * @remarks
   * Deletes all Fixed Prices of an SKU in a specific Price Table or Trade Policy.
   */
  deletefixedpricesonapricetableortradepolicy(
    req: operations.DeletefixedpricesonapricetableortradepolicyRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.DeletefixedpricesonapricetableortradepolicyResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DeletefixedpricesonapricetableortradepolicyRequest(
        req
      );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/pricing/prices/{itemId}/fixed/{priceTableId}",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };

    const r = client.request({
      url: url,
      method: "delete",
      headers: headers,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DeletefixedpricesonapricetableortradepolicyResponse =
        new operations.DeletefixedpricesonapricetableortradepolicyResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          break;
      }

      return res;
    });
  }

  /**
   * Get Computed Price by price table or trade policy
   *
   * @remarks
   * Gets the Computed Price, which is the price after all the steps in the Pricing pipeline, for an SKU in a specific price table or trade policy.
   *
   * ## Response body example
   *
   * ```json
   * {
   *     "tradePolicyId": "1",
   *     "listPrice": 30,
   *     "costPrice": 76.92,
   *     "sellingPrice": 18.9,
   *     "priceValidUntil": "2018-12-20T18:12:14Z"
   * }
   * ```
   */
  getComputedPricebypricetable(
    req: operations.GetComputedPricebypricetableRequest,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.GetComputedPricebypricetableResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetComputedPricebypricetableRequest(req);
    }

    let baseURL: string = operations.GetComputedPricebypricetableServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/pricing/prices/{itemId}/computed/{priceTableId}",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      headers: headers,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetComputedPricebypricetableResponse =
        new operations.GetComputedPricebypricetableResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (
            utils.matchContentType(
              contentType,
              `application/json; charset=utf-8`
            )
          ) {
            res.getcomputedprice = utils.objectToClass(
              httpRes?.data,
              shared.Getcomputedprice
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Get Fixed Prices
   *
   * @remarks
   * The **fixed price** is an optional price of the SKU for a specific trade policy with a specific minimum quantity to be activated. This method retrieves an array of Fixed Prices for an SKU in a Trade Policy with Minimum Quantities.
   *
   *  The default value for a Minimum Quantity is `1`. This means a Fixed Price will be valid for a SKU in a Trade Policy for orders containing the specified number of Minimum Quantity or above, unless a higher Minimum Quantity is specified.
   *
   *  Fixed prices may, optionally, be scheduled. If so, these objects will contain the `dateRange` object with `from` and `to` properties, indicating the start and end time of the scheduled fixed price in the RFC3339 timestamp format (`YYYY-MM-DDT23:59:60Z`).
   *
   *  Note that the 'Z', at the end, represents the UTC time (GMT+00:00). If it was in GMT-03:00, for example, it would be (`YYYY-MM-DDT23:59:60-03:00`).
   *
   *  ## Response body example
   *
   * ```json
   * [
   *     {
   *         "tradePolicyId": "6",
   *         "value": 20.9,
   *         "listPrice": 22.9,
   *         "minQuantity": 1,
   *         "dateRange": {
   *             "from": "2021-12-30T22:00:00-03:00",
   *             "to": "2021-12-30T22:00:00-03:00"
   *         }
   *     },
   *     {
   *         "tradePolicyId": "1",
   *         "value": 18.9,
   *         "listPrice": null,
   *         "minQuantity": 1,
   *         "dateRange": {
   *             "from": "2021-12-30T22:00:00-03:00",
   *             "to": "2021-12-30T22:00:00-03:00"
   *         }
   *     }
   * ]
   * ```
   */
  getFixedPrices(
    req: operations.GetFixedPricesRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetFixedPricesResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetFixedPricesRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/pricing/prices/{itemId}/fixed",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };

    const r = client.request({
      url: url,
      method: "get",
      headers: headers,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetFixedPricesResponse =
        new operations.GetFixedPricesResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (
            utils.matchContentType(
              contentType,
              `application/json; charset=utf-8`
            )
          ) {
            res.fixedPrices = [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.fixedPrices = utils.objectToClass(
              httpRes?.data,
              shared.FixedPrice,
              resFieldDepth
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Get Fixed Prices on a price table or trade policy
   *
   * @remarks
   * Retrieves all Fixed Prices on a price table or trade policy.
   *
   * ## Response body example
   *
   * ```json
   * [
   *     {
   *         "tradePolicyId": "6",
   *         "value": 20.9,
   *         "listPrice": 22.9,
   *         "minQuantity": 1,
   *         "dateRange": {
   *             "from": "2021-12-30T22:00:00-03:00",
   *             "to": "2021-12-30T22:00:00-04:00"
   *         }
   *     },
   *     {
   *         "tradePolicyId": "1",
   *         "value": 18.9,
   *         "listPrice": null,
   *         "minQuantity": 1
   *     }
   * ]
   * ```
   */
  getFixedPricesonapricetable(
    req: operations.GetFixedPricesonapricetableRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetFixedPricesonapricetableResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetFixedPricesonapricetableRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/pricing/prices/{itemId}/fixed/{priceTableId}",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };

    const r = client.request({
      url: url,
      method: "get",
      headers: headers,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetFixedPricesonapricetableResponse =
        new operations.GetFixedPricesonapricetableResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (
            utils.matchContentType(
              contentType,
              `application/json; charset=utf-8`
            )
          ) {
            res.fixedPrices = [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.fixedPrices = utils.objectToClass(
              httpRes?.data,
              shared.FixedPrice,
              resFieldDepth
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Get Price
   *
   * @remarks
   * Retrieves price data given a specific SKU ID. Within the `fixedPrices` object, there might be a list of prices for specific Trade Policies and Minimium Quantities of the SKU. Fixed Prices may also be scheduled.
   *
   *  ## Response body example
   *
   * ```json
   * {
   *     "itemId": "1",
   *     "listPrice": 50,
   *     "costPrice": 90,
   *     "markup": 30,
   *     "basePrice": 117,
   *     "fixedPrices": [
   *         {
   *             "tradePolicyId": "1",
   *             "value": 50.5,
   *             "listPrice": 50.5,
   *             "minQuantity": 2,
   *             "dateRange": {
   *                 "from": "2021-12-31T01:00:00Z",
   *                 "to": "2022-12-31T01:00:00Z"
   *             }
   *         },
   *         {
   *             "tradePolicyId": "2",
   *             "value": 30,
   *             "listPrice": 50,
   *             "minQuantity": 2
   *         }
   *     ]
   * }
   * ```
   */
  getPrice(
    req: operations.GetPriceRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetPriceResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetPriceRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/pricing/prices/{itemId}",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };

    const r = client.request({
      url: url,
      method: "get",
      headers: headers,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetPriceResponse = new operations.GetPriceResponse({
        statusCode: httpRes.status,
        contentType: contentType,
        rawResponse: httpRes,
      });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getprice = utils.objectToClass(httpRes?.data, shared.Getprice);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Create or Update Fixed Prices on a price table or trade policy
   *
   * @remarks
   * Creates or updates the fixed prices of an SKU for a specific price table or trade policy. You can add one or multiple fixed prices per SKU.
   *
   *  ## Request body example
   *
   * ```json
   * [
   *   {
   *     "value": 50.5,
   *     "listPrice": 50.5,
   *     "minQuantity": 2,
   *     "dateRange": {
   *       "from": "2021-12-30T22:00:00-03:00",
   *       "to": "2021-12-30T22:00:00-04:00"
   *     }
   *   }
   * ]
   * ```
   */
  createorupdatefixedpricesonpricetableortradepolicy(
    req: operations.CreateorupdatefixedpricesonpricetableortradepolicyRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.CreateorupdatefixedpricesonpricetableortradepolicyResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.CreateorupdatefixedpricesonpricetableortradepolicyRequest(
          req
        );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/pricing/prices/{itemId}/fixed/{priceTableId}",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CreateorupdatefixedpricesonpricetableortradepolicyResponse =
        new operations.CreateorupdatefixedpricesonpricetableortradepolicyResponse(
          {
            statusCode: httpRes.status,
            contentType: contentType,
            rawResponse: httpRes,
          }
        );
      switch (true) {
        case httpRes?.status == 200:
          break;
      }

      return res;
    });
  }
}
