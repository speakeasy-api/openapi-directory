/*
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

import * as utils from "../internal/utils";
import * as operations from "./models/operations";
import { AxiosInstance, AxiosRequestConfig, AxiosResponse } from "axios";

export class Sm {
  _defaultClient: AxiosInstance;
  _securityClient: AxiosInstance;
  _serverURL: string;
  _language: string;
  _sdkVersion: string;
  _genVersion: string;

  constructor(
    defaultClient: AxiosInstance,
    securityClient: AxiosInstance,
    serverURL: string,
    language: string,
    sdkVersion: string,
    genVersion: string
  ) {
    this._defaultClient = defaultClient;
    this._securityClient = securityClient;
    this._serverURL = serverURL;
    this._language = language;
    this._sdkVersion = sdkVersion;
    this._genVersion = genVersion;
  }

  /**
   * Force check-in a set of devices
   *
   * @remarks
   * Force check-in a set of devices
   */
  checkinNetworkSmDevices(
    req: operations.CheckinNetworkSmDevicesRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.CheckinNetworkSmDevicesResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CheckinNetworkSmDevicesRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/networks/{networkId}/sm/devices/checkin",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CheckinNetworkSmDevicesResponse =
        new operations.CheckinNetworkSmDevicesResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.checkinNetworkSmDevices200ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.CheckinNetworkSmDevices200ApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Bypass activation lock attempt
   *
   * @remarks
   * Bypass activation lock attempt
   */
  createNetworkSmBypassActivationLockAttempt(
    req: operations.CreateNetworkSmBypassActivationLockAttemptRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.CreateNetworkSmBypassActivationLockAttemptResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CreateNetworkSmBypassActivationLockAttemptRequest(
        req
      );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/networks/{networkId}/sm/bypassActivationLockAttempts",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CreateNetworkSmBypassActivationLockAttemptResponse =
        new operations.CreateNetworkSmBypassActivationLockAttemptResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.createNetworkSmBypassActivationLockAttempt201ApplicationJSONObject =
              utils.objectToClass(httpRes?.data);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Add a target group
   *
   * @remarks
   * Add a target group
   */
  createNetworkSmTargetGroup(
    req: operations.CreateNetworkSmTargetGroupRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.CreateNetworkSmTargetGroupResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CreateNetworkSmTargetGroupRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/networks/{networkId}/sm/targetGroups",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CreateNetworkSmTargetGroupResponse =
        new operations.CreateNetworkSmTargetGroupResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.createNetworkSmTargetGroup201ApplicationJSONObject =
              utils.objectToClass(httpRes?.data);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Delete a target group from a network
   *
   * @remarks
   * Delete a target group from a network
   */
  deleteNetworkSmTargetGroup(
    req: operations.DeleteNetworkSmTargetGroupRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.DeleteNetworkSmTargetGroupResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DeleteNetworkSmTargetGroupRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/networks/{networkId}/sm/targetGroups/{targetGroupId}",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DeleteNetworkSmTargetGroupResponse =
        new operations.DeleteNetworkSmTargetGroupResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
      }

      return res;
    });
  }

  /**
   * Delete a User Access Device
   *
   * @remarks
   * Delete a User Access Device
   */
  deleteNetworkSmUserAccessDevice(
    req: operations.DeleteNetworkSmUserAccessDeviceRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.DeleteNetworkSmUserAccessDeviceResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DeleteNetworkSmUserAccessDeviceRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/networks/{networkId}/sm/userAccessDevices/{userAccessDeviceId}",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DeleteNetworkSmUserAccessDeviceResponse =
        new operations.DeleteNetworkSmUserAccessDeviceResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
      }

      return res;
    });
  }

  /**
   * Bypass activation lock attempt status
   *
   * @remarks
   * Bypass activation lock attempt status
   */
  getNetworkSmBypassActivationLockAttempt(
    req: operations.GetNetworkSmBypassActivationLockAttemptRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetNetworkSmBypassActivationLockAttemptResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetNetworkSmBypassActivationLockAttemptRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/networks/{networkId}/sm/bypassActivationLockAttempts/{attemptId}",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetNetworkSmBypassActivationLockAttemptResponse =
        new operations.GetNetworkSmBypassActivationLockAttemptResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getNetworkSmBypassActivationLockAttempt200ApplicationJSONObject =
              utils.objectToClass(httpRes?.data);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Return the client's daily cellular data usage history
   *
   * @remarks
   * Return the client's daily cellular data usage history. Usage data is in kilobytes.
   */
  getNetworkSmDeviceCellularUsageHistory(
    req: operations.GetNetworkSmDeviceCellularUsageHistoryRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetNetworkSmDeviceCellularUsageHistoryResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetNetworkSmDeviceCellularUsageHistoryRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/networks/{networkId}/sm/devices/{deviceId}/cellularUsageHistory",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetNetworkSmDeviceCellularUsageHistoryResponse =
        new operations.GetNetworkSmDeviceCellularUsageHistoryResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getNetworkSmDeviceCellularUsageHistory200ApplicationJSONObjects =
              [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.getNetworkSmDeviceCellularUsageHistory200ApplicationJSONObjects =
              utils.objectToClass(
                httpRes?.data,
                operations.GetNetworkSmDeviceCellularUsageHistory200ApplicationJSON,
                resFieldDepth
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * List the certs on a device
   *
   * @remarks
   * List the certs on a device
   */
  getNetworkSmDeviceCerts(
    req: operations.GetNetworkSmDeviceCertsRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetNetworkSmDeviceCertsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetNetworkSmDeviceCertsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/networks/{networkId}/sm/devices/{deviceId}/certs",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetNetworkSmDeviceCertsResponse =
        new operations.GetNetworkSmDeviceCertsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getNetworkSmDeviceCerts200ApplicationJSONObjects = [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.getNetworkSmDeviceCerts200ApplicationJSONObjects =
              utils.objectToClass(
                httpRes?.data,
                operations.GetNetworkSmDeviceCerts200ApplicationJSON,
                resFieldDepth
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Returns historical connectivity data (whether a device is regularly checking in to Dashboard).
   *
   * @remarks
   * Returns historical connectivity data (whether a device is regularly checking in to Dashboard).
   */
  getNetworkSmDeviceConnectivity(
    req: operations.GetNetworkSmDeviceConnectivityRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetNetworkSmDeviceConnectivityResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetNetworkSmDeviceConnectivityRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/networks/{networkId}/sm/devices/{deviceId}/connectivity",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetNetworkSmDeviceConnectivityResponse =
        new operations.GetNetworkSmDeviceConnectivityResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
          headers: utils.getHeadersFromResponse(httpRes.headers),
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getNetworkSmDeviceConnectivity200ApplicationJSONObjects = [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.getNetworkSmDeviceConnectivity200ApplicationJSONObjects =
              utils.objectToClass(
                httpRes?.data,
                operations.GetNetworkSmDeviceConnectivity200ApplicationJSON,
                resFieldDepth
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Return historical records of various Systems Manager network connection details for desktop devices.
   *
   * @remarks
   * Return historical records of various Systems Manager network connection details for desktop devices.
   */
  getNetworkSmDeviceDesktopLogs(
    req: operations.GetNetworkSmDeviceDesktopLogsRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetNetworkSmDeviceDesktopLogsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetNetworkSmDeviceDesktopLogsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/networks/{networkId}/sm/devices/{deviceId}/desktopLogs",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetNetworkSmDeviceDesktopLogsResponse =
        new operations.GetNetworkSmDeviceDesktopLogsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
          headers: utils.getHeadersFromResponse(httpRes.headers),
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getNetworkSmDeviceDesktopLogs200ApplicationJSONObjects = [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.getNetworkSmDeviceDesktopLogs200ApplicationJSONObjects =
              utils.objectToClass(
                httpRes?.data,
                operations.GetNetworkSmDeviceDesktopLogs200ApplicationJSON,
                resFieldDepth
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Return historical records of commands sent to Systems Manager devices
   *
   * @remarks
   * Return historical records of commands sent to Systems Manager devices. Note that this will include the name of the Dashboard user who initiated the command if it was generated by a Dashboard admin rather than the automatic behavior of the system; you may wish to filter this out of any reports.
   */
  getNetworkSmDeviceDeviceCommandLogs(
    req: operations.GetNetworkSmDeviceDeviceCommandLogsRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetNetworkSmDeviceDeviceCommandLogsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetNetworkSmDeviceDeviceCommandLogsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/networks/{networkId}/sm/devices/{deviceId}/deviceCommandLogs",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetNetworkSmDeviceDeviceCommandLogsResponse =
        new operations.GetNetworkSmDeviceDeviceCommandLogsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
          headers: utils.getHeadersFromResponse(httpRes.headers),
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getNetworkSmDeviceDeviceCommandLogs200ApplicationJSONObjects =
              [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.getNetworkSmDeviceDeviceCommandLogs200ApplicationJSONObjects =
              utils.objectToClass(
                httpRes?.data,
                operations.GetNetworkSmDeviceDeviceCommandLogs200ApplicationJSON,
                resFieldDepth
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Get the installed profiles associated with a device
   *
   * @remarks
   * Get the installed profiles associated with a device
   */
  getNetworkSmDeviceDeviceProfiles(
    req: operations.GetNetworkSmDeviceDeviceProfilesRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetNetworkSmDeviceDeviceProfilesResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetNetworkSmDeviceDeviceProfilesRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/networks/{networkId}/sm/devices/{deviceId}/deviceProfiles",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetNetworkSmDeviceDeviceProfilesResponse =
        new operations.GetNetworkSmDeviceDeviceProfilesResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getNetworkSmDeviceDeviceProfiles200ApplicationJSONObjects = [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.getNetworkSmDeviceDeviceProfiles200ApplicationJSONObjects =
              utils.objectToClass(
                httpRes?.data,
                operations.GetNetworkSmDeviceDeviceProfiles200ApplicationJSON,
                resFieldDepth
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * List the network adapters of a device
   *
   * @remarks
   * List the network adapters of a device
   */
  getNetworkSmDeviceNetworkAdapters(
    req: operations.GetNetworkSmDeviceNetworkAdaptersRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetNetworkSmDeviceNetworkAdaptersResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetNetworkSmDeviceNetworkAdaptersRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/networks/{networkId}/sm/devices/{deviceId}/networkAdapters",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetNetworkSmDeviceNetworkAdaptersResponse =
        new operations.GetNetworkSmDeviceNetworkAdaptersResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getNetworkSmDeviceNetworkAdapters200ApplicationJSONObjects = [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.getNetworkSmDeviceNetworkAdapters200ApplicationJSONObjects =
              utils.objectToClass(
                httpRes?.data,
                operations.GetNetworkSmDeviceNetworkAdapters200ApplicationJSON,
                resFieldDepth
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Return historical records of various Systems Manager client metrics for desktop devices.
   *
   * @remarks
   * Return historical records of various Systems Manager client metrics for desktop devices.
   */
  getNetworkSmDevicePerformanceHistory(
    req: operations.GetNetworkSmDevicePerformanceHistoryRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetNetworkSmDevicePerformanceHistoryResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetNetworkSmDevicePerformanceHistoryRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/networks/{networkId}/sm/devices/{deviceId}/performanceHistory",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetNetworkSmDevicePerformanceHistoryResponse =
        new operations.GetNetworkSmDevicePerformanceHistoryResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
          headers: utils.getHeadersFromResponse(httpRes.headers),
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getNetworkSmDevicePerformanceHistory200ApplicationJSONObjects =
              [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.getNetworkSmDevicePerformanceHistory200ApplicationJSONObjects =
              utils.objectToClass(
                httpRes?.data,
                operations.GetNetworkSmDevicePerformanceHistory200ApplicationJSON,
                resFieldDepth
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * List the restrictions on a device
   *
   * @remarks
   * List the restrictions on a device
   */
  getNetworkSmDeviceRestrictions(
    req: operations.GetNetworkSmDeviceRestrictionsRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetNetworkSmDeviceRestrictionsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetNetworkSmDeviceRestrictionsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/networks/{networkId}/sm/devices/{deviceId}/restrictions",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetNetworkSmDeviceRestrictionsResponse =
        new operations.GetNetworkSmDeviceRestrictionsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getNetworkSmDeviceRestrictions200ApplicationJSONObjects =
              utils.objectToClass(httpRes?.data);
          }
          break;
      }

      return res;
    });
  }

  /**
   * List the security centers on a device
   *
   * @remarks
   * List the security centers on a device
   */
  getNetworkSmDeviceSecurityCenters(
    req: operations.GetNetworkSmDeviceSecurityCentersRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetNetworkSmDeviceSecurityCentersResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetNetworkSmDeviceSecurityCentersRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/networks/{networkId}/sm/devices/{deviceId}/securityCenters",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetNetworkSmDeviceSecurityCentersResponse =
        new operations.GetNetworkSmDeviceSecurityCentersResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getNetworkSmDeviceSecurityCenters200ApplicationJSONObjects = [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.getNetworkSmDeviceSecurityCenters200ApplicationJSONObjects =
              utils.objectToClass(
                httpRes?.data,
                operations.GetNetworkSmDeviceSecurityCenters200ApplicationJSON,
                resFieldDepth
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Get a list of softwares associated with a device
   *
   * @remarks
   * Get a list of softwares associated with a device
   */
  getNetworkSmDeviceSoftwares(
    req: operations.GetNetworkSmDeviceSoftwaresRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetNetworkSmDeviceSoftwaresResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetNetworkSmDeviceSoftwaresRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/networks/{networkId}/sm/devices/{deviceId}/softwares",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetNetworkSmDeviceSoftwaresResponse =
        new operations.GetNetworkSmDeviceSoftwaresResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getNetworkSmDeviceSoftwares200ApplicationJSONObjects = [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.getNetworkSmDeviceSoftwares200ApplicationJSONObjects =
              utils.objectToClass(
                httpRes?.data,
                operations.GetNetworkSmDeviceSoftwares200ApplicationJSON,
                resFieldDepth
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * List the saved SSID names on a device
   *
   * @remarks
   * List the saved SSID names on a device
   */
  getNetworkSmDeviceWlanLists(
    req: operations.GetNetworkSmDeviceWlanListsRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetNetworkSmDeviceWlanListsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetNetworkSmDeviceWlanListsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/networks/{networkId}/sm/devices/{deviceId}/wlanLists",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetNetworkSmDeviceWlanListsResponse =
        new operations.GetNetworkSmDeviceWlanListsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getNetworkSmDeviceWlanLists200ApplicationJSONObjects = [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.getNetworkSmDeviceWlanLists200ApplicationJSONObjects =
              utils.objectToClass(
                httpRes?.data,
                operations.GetNetworkSmDeviceWlanLists200ApplicationJSON,
                resFieldDepth
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * List the devices enrolled in an SM network with various specified fields and filters
   *
   * @remarks
   * List the devices enrolled in an SM network with various specified fields and filters
   */
  getNetworkSmDevices(
    req: operations.GetNetworkSmDevicesRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetNetworkSmDevicesResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetNetworkSmDevicesRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/networks/{networkId}/sm/devices",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetNetworkSmDevicesResponse =
        new operations.GetNetworkSmDevicesResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
          headers: utils.getHeadersFromResponse(httpRes.headers),
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getNetworkSmDevices200ApplicationJSONObjects = [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.getNetworkSmDevices200ApplicationJSONObjects =
              utils.objectToClass(
                httpRes?.data,
                operations.GetNetworkSmDevices200ApplicationJSON,
                resFieldDepth
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * List all profiles in a network
   *
   * @remarks
   * List all profiles in a network
   */
  getNetworkSmProfiles(
    req: operations.GetNetworkSmProfilesRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetNetworkSmProfilesResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetNetworkSmProfilesRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/networks/{networkId}/sm/profiles",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetNetworkSmProfilesResponse =
        new operations.GetNetworkSmProfilesResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getNetworkSmProfiles200ApplicationJSONObjects = [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.getNetworkSmProfiles200ApplicationJSONObjects =
              utils.objectToClass(
                httpRes?.data,
                operations.GetNetworkSmProfiles200ApplicationJSON,
                resFieldDepth
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Return a target group
   *
   * @remarks
   * Return a target group
   */
  getNetworkSmTargetGroup(
    req: operations.GetNetworkSmTargetGroupRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetNetworkSmTargetGroupResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetNetworkSmTargetGroupRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/networks/{networkId}/sm/targetGroups/{targetGroupId}",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetNetworkSmTargetGroupResponse =
        new operations.GetNetworkSmTargetGroupResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getNetworkSmTargetGroup200ApplicationJSONObject =
              utils.objectToClass(httpRes?.data);
          }
          break;
      }

      return res;
    });
  }

  /**
   * List the target groups in this network
   *
   * @remarks
   * List the target groups in this network
   */
  getNetworkSmTargetGroups(
    req: operations.GetNetworkSmTargetGroupsRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetNetworkSmTargetGroupsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetNetworkSmTargetGroupsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/networks/{networkId}/sm/targetGroups",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetNetworkSmTargetGroupsResponse =
        new operations.GetNetworkSmTargetGroupsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getNetworkSmTargetGroups200ApplicationJSONObjects =
              utils.objectToClass(httpRes?.data);
          }
          break;
      }

      return res;
    });
  }

  /**
   * List Trusted Access Configs
   *
   * @remarks
   * List Trusted Access Configs
   */
  getNetworkSmTrustedAccessConfigs(
    req: operations.GetNetworkSmTrustedAccessConfigsRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetNetworkSmTrustedAccessConfigsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetNetworkSmTrustedAccessConfigsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/networks/{networkId}/sm/trustedAccessConfigs",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetNetworkSmTrustedAccessConfigsResponse =
        new operations.GetNetworkSmTrustedAccessConfigsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
          headers: utils.getHeadersFromResponse(httpRes.headers),
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getNetworkSmTrustedAccessConfigs200ApplicationJSONObjects = [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.getNetworkSmTrustedAccessConfigs200ApplicationJSONObjects =
              utils.objectToClass(
                httpRes?.data,
                operations.GetNetworkSmTrustedAccessConfigs200ApplicationJSON,
                resFieldDepth
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * List User Access Devices and its Trusted Access Connections
   *
   * @remarks
   * List User Access Devices and its Trusted Access Connections
   */
  getNetworkSmUserAccessDevices(
    req: operations.GetNetworkSmUserAccessDevicesRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetNetworkSmUserAccessDevicesResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetNetworkSmUserAccessDevicesRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/networks/{networkId}/sm/userAccessDevices",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetNetworkSmUserAccessDevicesResponse =
        new operations.GetNetworkSmUserAccessDevicesResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
          headers: utils.getHeadersFromResponse(httpRes.headers),
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getNetworkSmUserAccessDevices200ApplicationJSONObjects = [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.getNetworkSmUserAccessDevices200ApplicationJSONObjects =
              utils.objectToClass(
                httpRes?.data,
                operations.GetNetworkSmUserAccessDevices200ApplicationJSON,
                resFieldDepth
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Get the profiles associated with a user
   *
   * @remarks
   * Get the profiles associated with a user
   */
  getNetworkSmUserDeviceProfiles(
    req: operations.GetNetworkSmUserDeviceProfilesRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetNetworkSmUserDeviceProfilesResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetNetworkSmUserDeviceProfilesRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/networks/{networkId}/sm/users/{userId}/deviceProfiles",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetNetworkSmUserDeviceProfilesResponse =
        new operations.GetNetworkSmUserDeviceProfilesResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getNetworkSmUserDeviceProfiles200ApplicationJSONObjects = [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.getNetworkSmUserDeviceProfiles200ApplicationJSONObjects =
              utils.objectToClass(
                httpRes?.data,
                operations.GetNetworkSmUserDeviceProfiles200ApplicationJSON,
                resFieldDepth
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Get a list of softwares associated with a user
   *
   * @remarks
   * Get a list of softwares associated with a user
   */
  getNetworkSmUserSoftwares(
    req: operations.GetNetworkSmUserSoftwaresRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetNetworkSmUserSoftwaresResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetNetworkSmUserSoftwaresRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/networks/{networkId}/sm/users/{userId}/softwares",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetNetworkSmUserSoftwaresResponse =
        new operations.GetNetworkSmUserSoftwaresResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getNetworkSmUserSoftwares200ApplicationJSONObjects = [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.getNetworkSmUserSoftwares200ApplicationJSONObjects =
              utils.objectToClass(
                httpRes?.data,
                operations.GetNetworkSmUserSoftwares200ApplicationJSON,
                resFieldDepth
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * List the owners in an SM network with various specified fields and filters
   *
   * @remarks
   * List the owners in an SM network with various specified fields and filters
   */
  getNetworkSmUsers(
    req: operations.GetNetworkSmUsersRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetNetworkSmUsersResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetNetworkSmUsersRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/networks/{networkId}/sm/users",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetNetworkSmUsersResponse =
        new operations.GetNetworkSmUsersResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getNetworkSmUsers200ApplicationJSONObjects = [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.getNetworkSmUsers200ApplicationJSONObjects =
              utils.objectToClass(
                httpRes?.data,
                operations.GetNetworkSmUsers200ApplicationJSON,
                resFieldDepth
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Get the organization's APNS certificate
   *
   * @remarks
   * Get the organization's APNS certificate
   */
  getOrganizationSmApnsCert(
    req: operations.GetOrganizationSmApnsCertRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetOrganizationSmApnsCertResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetOrganizationSmApnsCertRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/organizations/{organizationId}/sm/apnsCert",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetOrganizationSmApnsCertResponse =
        new operations.GetOrganizationSmApnsCertResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getOrganizationSmApnsCert200ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.GetOrganizationSmApnsCert200ApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Get a hash containing the unparsed token of the VPP account with the given ID
   *
   * @remarks
   * Get a hash containing the unparsed token of the VPP account with the given ID
   */
  getOrganizationSmVppAccount(
    req: operations.GetOrganizationSmVppAccountRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetOrganizationSmVppAccountResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetOrganizationSmVppAccountRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/organizations/{organizationId}/sm/vppAccounts/{vppAccountId}",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetOrganizationSmVppAccountResponse =
        new operations.GetOrganizationSmVppAccountResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getOrganizationSmVppAccount200ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.GetOrganizationSmVppAccount200ApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * List the VPP accounts in the organization
   *
   * @remarks
   * List the VPP accounts in the organization
   */
  getOrganizationSmVppAccounts(
    req: operations.GetOrganizationSmVppAccountsRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetOrganizationSmVppAccountsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetOrganizationSmVppAccountsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/organizations/{organizationId}/sm/vppAccounts",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetOrganizationSmVppAccountsResponse =
        new operations.GetOrganizationSmVppAccountsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getOrganizationSmVppAccounts200ApplicationJSONObjects = [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.getOrganizationSmVppAccounts200ApplicationJSONObjects =
              utils.objectToClass(
                httpRes?.data,
                operations.GetOrganizationSmVppAccounts200ApplicationJSON,
                resFieldDepth
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Lock a set of devices
   *
   * @remarks
   * Lock a set of devices
   */
  lockNetworkSmDevices(
    req: operations.LockNetworkSmDevicesRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.LockNetworkSmDevicesResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.LockNetworkSmDevicesRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/networks/{networkId}/sm/devices/lock",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.LockNetworkSmDevicesResponse =
        new operations.LockNetworkSmDevicesResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.lockNetworkSmDevices200ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.LockNetworkSmDevices200ApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Add, delete, or update the tags of a set of devices
   *
   * @remarks
   * Add, delete, or update the tags of a set of devices
   */
  modifyNetworkSmDevicesTags(
    req: operations.ModifyNetworkSmDevicesTagsRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.ModifyNetworkSmDevicesTagsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ModifyNetworkSmDevicesTagsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/networks/{networkId}/sm/devices/modifyTags",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ModifyNetworkSmDevicesTagsResponse =
        new operations.ModifyNetworkSmDevicesTagsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.modifyNetworkSmDevicesTags200ApplicationJSONObjects = [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.modifyNetworkSmDevicesTags200ApplicationJSONObjects =
              utils.objectToClass(
                httpRes?.data,
                operations.ModifyNetworkSmDevicesTags200ApplicationJSON,
                resFieldDepth
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Move a set of devices to a new network
   *
   * @remarks
   * Move a set of devices to a new network
   */
  moveNetworkSmDevices(
    req: operations.MoveNetworkSmDevicesRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.MoveNetworkSmDevicesResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.MoveNetworkSmDevicesRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/networks/{networkId}/sm/devices/move",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.MoveNetworkSmDevicesResponse =
        new operations.MoveNetworkSmDevicesResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.moveNetworkSmDevices200ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.MoveNetworkSmDevices200ApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Refresh the details of a device
   *
   * @remarks
   * Refresh the details of a device
   */
  refreshNetworkSmDeviceDetails(
    req: operations.RefreshNetworkSmDeviceDetailsRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.RefreshNetworkSmDeviceDetailsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.RefreshNetworkSmDeviceDetailsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/networks/{networkId}/sm/devices/{deviceId}/refreshDetails",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "post",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.RefreshNetworkSmDeviceDetailsResponse =
        new operations.RefreshNetworkSmDeviceDetailsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          break;
      }

      return res;
    });
  }

  /**
   * Unenroll a device
   *
   * @remarks
   * Unenroll a device
   */
  unenrollNetworkSmDevice(
    req: operations.UnenrollNetworkSmDeviceRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.UnenrollNetworkSmDeviceResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.UnenrollNetworkSmDeviceRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/networks/{networkId}/sm/devices/{deviceId}/unenroll",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "post",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UnenrollNetworkSmDeviceResponse =
        new operations.UnenrollNetworkSmDeviceResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.unenrollNetworkSmDevice200ApplicationJSONObject =
              utils.objectToClass(httpRes?.data);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Modify the fields of a device
   *
   * @remarks
   * Modify the fields of a device
   */
  updateNetworkSmDevicesFields(
    req: operations.UpdateNetworkSmDevicesFieldsRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.UpdateNetworkSmDevicesFieldsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.UpdateNetworkSmDevicesFieldsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/networks/{networkId}/sm/devices/fields",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "put",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UpdateNetworkSmDevicesFieldsResponse =
        new operations.UpdateNetworkSmDevicesFieldsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.updateNetworkSmDevicesFields200ApplicationJSONObjects = [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.updateNetworkSmDevicesFields200ApplicationJSONObjects =
              utils.objectToClass(
                httpRes?.data,
                operations.UpdateNetworkSmDevicesFields200ApplicationJSON,
                resFieldDepth
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Update a target group
   *
   * @remarks
   * Update a target group
   */
  updateNetworkSmTargetGroup(
    req: operations.UpdateNetworkSmTargetGroupRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.UpdateNetworkSmTargetGroupResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.UpdateNetworkSmTargetGroupRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/networks/{networkId}/sm/targetGroups/{targetGroupId}",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "put",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UpdateNetworkSmTargetGroupResponse =
        new operations.UpdateNetworkSmTargetGroupResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.updateNetworkSmTargetGroup200ApplicationJSONObject =
              utils.objectToClass(httpRes?.data);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Wipe a device
   *
   * @remarks
   * Wipe a device
   */
  wipeNetworkSmDevices(
    req: operations.WipeNetworkSmDevicesRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.WipeNetworkSmDevicesResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.WipeNetworkSmDevicesRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/networks/{networkId}/sm/devices/wipe",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.WipeNetworkSmDevicesResponse =
        new operations.WipeNetworkSmDevicesResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.wipeNetworkSmDevices200ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.WipeNetworkSmDevices200ApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }
}
