/*
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

import * as utils from "../internal/utils";
import * as operations from "./models/operations";
import * as shared from "./models/shared";
import axios from "axios";
import { AxiosInstance, AxiosRequestConfig, AxiosResponse } from "axios";

/**
 * Contains the list of servers available to the SDK
 */
export const ServerList = ["https://verify.twilio.com"] as const;

/**
 * The available configuration options for the SDK
 */
export type SDKProps = {
  /**
   * Allows overriding the default axios client used by the SDK
   */
  defaultClient?: AxiosInstance;
  /**
   * Allows overriding the default server URL used by the SDK
   */
  serverURL?: string;
};

/**
 * This is the public Twilio REST API.
 */
export class SDK {
  public _defaultClient: AxiosInstance;
  public _securityClient: AxiosInstance;
  public _serverURL: string;
  private _language = "typescript";
  private _sdkVersion = "0.0.1";
  private _genVersion = "internal";
  private _globals: any;

  constructor(props?: SDKProps) {
    this._serverURL = props?.serverURL ?? ServerList[0];

    this._defaultClient =
      props?.defaultClient ?? axios.create({ baseURL: this._serverURL });
    this._securityClient = this._defaultClient;
  }

  /**
   * Create a new enrollment Access Token for the Entity
   */
  createAccessToken(
    req: operations.CreateAccessTokenRequest,
    security: operations.CreateAccessTokenSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.CreateAccessTokenResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CreateAccessTokenRequest(req);
    }

    let baseURL: string = operations.CreateAccessTokenServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v2/Services/{ServiceSid}/AccessTokens",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "form"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.CreateAccessTokenSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CreateAccessTokenResponse =
        new operations.CreateAccessTokenResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.verifyV2ServiceAccessToken = utils.objectToClass(
              httpRes?.data,
              shared.VerifyV2ServiceAccessToken
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Create a new Bucket for a Rate Limit
   */
  createBucket(
    req: operations.CreateBucketRequest,
    security: operations.CreateBucketSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.CreateBucketResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CreateBucketRequest(req);
    }

    let baseURL: string = operations.CreateBucketServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v2/Services/{ServiceSid}/RateLimits/{RateLimitSid}/Buckets",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "form"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.CreateBucketSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CreateBucketResponse =
        new operations.CreateBucketResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.verifyV2ServiceRateLimitBucket = utils.objectToClass(
              httpRes?.data,
              shared.VerifyV2ServiceRateLimitBucket
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Create a new Challenge for the Factor
   */
  createChallenge(
    req: operations.CreateChallengeRequest,
    security: operations.CreateChallengeSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.CreateChallengeResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CreateChallengeRequest(req);
    }

    let baseURL: string = operations.CreateChallengeServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v2/Services/{ServiceSid}/Entities/{Identity}/Challenges",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "form"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.CreateChallengeSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CreateChallengeResponse =
        new operations.CreateChallengeResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.verifyV2ServiceEntityChallenge = utils.objectToClass(
              httpRes?.data,
              shared.VerifyV2ServiceEntityChallenge
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Create a new Entity for the Service
   */
  createEntity(
    req: operations.CreateEntityRequest,
    security: operations.CreateEntitySecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.CreateEntityResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CreateEntityRequest(req);
    }

    let baseURL: string = operations.CreateEntityServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v2/Services/{ServiceSid}/Entities",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "form"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.CreateEntitySecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CreateEntityResponse =
        new operations.CreateEntityResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.verifyV2ServiceEntity = utils.objectToClass(
              httpRes?.data,
              shared.VerifyV2ServiceEntity
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Create a new MessagingConfiguration for a service.
   */
  createMessagingConfiguration(
    req: operations.CreateMessagingConfigurationRequest,
    security: operations.CreateMessagingConfigurationSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.CreateMessagingConfigurationResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CreateMessagingConfigurationRequest(req);
    }

    let baseURL: string = operations.CreateMessagingConfigurationServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v2/Services/{ServiceSid}/MessagingConfigurations",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "form"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.CreateMessagingConfigurationSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CreateMessagingConfigurationResponse =
        new operations.CreateMessagingConfigurationResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.verifyV2ServiceMessagingConfiguration = utils.objectToClass(
              httpRes?.data,
              shared.VerifyV2ServiceMessagingConfiguration
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Create a new Factor for the Entity
   */
  createNewFactor(
    req: operations.CreateNewFactorRequest,
    security: operations.CreateNewFactorSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.CreateNewFactorResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CreateNewFactorRequest(req);
    }

    let baseURL: string = operations.CreateNewFactorServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v2/Services/{ServiceSid}/Entities/{Identity}/Factors",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "form"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.CreateNewFactorSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CreateNewFactorResponse =
        new operations.CreateNewFactorResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.verifyV2ServiceEntityNewFactor = utils.objectToClass(
              httpRes?.data,
              shared.VerifyV2ServiceEntityNewFactor
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Create a new Notification for the corresponding Challenge
   */
  createNotification(
    req: operations.CreateNotificationRequest,
    security: operations.CreateNotificationSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.CreateNotificationResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CreateNotificationRequest(req);
    }

    let baseURL: string = operations.CreateNotificationServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v2/Services/{ServiceSid}/Entities/{Identity}/Challenges/{ChallengeSid}/Notifications",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "form"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.CreateNotificationSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CreateNotificationResponse =
        new operations.CreateNotificationResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.verifyV2ServiceEntityChallengeNotification =
              utils.objectToClass(
                httpRes?.data,
                shared.VerifyV2ServiceEntityChallengeNotification
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Create a new Rate Limit for a Service
   */
  createRateLimit(
    req: operations.CreateRateLimitRequest,
    security: operations.CreateRateLimitSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.CreateRateLimitResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CreateRateLimitRequest(req);
    }

    let baseURL: string = operations.CreateRateLimitServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v2/Services/{ServiceSid}/RateLimits",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "form"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.CreateRateLimitSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CreateRateLimitResponse =
        new operations.CreateRateLimitResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.verifyV2ServiceRateLimit = utils.objectToClass(
              httpRes?.data,
              shared.VerifyV2ServiceRateLimit
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Add a new phone number to SafeList.
   */
  createSafelist(
    req: operations.CreateSafelistCreateSafelistRequest,
    security: operations.CreateSafelistSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.CreateSafelistResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CreateSafelistCreateSafelistRequest(req);
    }

    let baseURL: string = operations.CreateSafelistServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = baseURL.replace(/\/$/, "") + "/v2/SafeList/Numbers";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "request",
        "form"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.CreateSafelistSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CreateSafelistResponse =
        new operations.CreateSafelistResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.verifyV2Safelist = utils.objectToClass(
              httpRes?.data,
              shared.VerifyV2Safelist
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Create a new Verification Service.
   */
  createService(
    req: operations.CreateServiceCreateServiceRequest,
    security: operations.CreateServiceSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.CreateServiceResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CreateServiceCreateServiceRequest(req);
    }

    let baseURL: string = operations.CreateServiceServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = baseURL.replace(/\/$/, "") + "/v2/Services";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "request",
        "form"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.CreateServiceSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CreateServiceResponse =
        new operations.CreateServiceResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.verifyV2Service = utils.objectToClass(
              httpRes?.data,
              shared.VerifyV2Service
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Create a new Verification using a Service
   */
  createVerification(
    req: operations.CreateVerificationRequest,
    security: operations.CreateVerificationSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.CreateVerificationResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CreateVerificationRequest(req);
    }

    let baseURL: string = operations.CreateVerificationServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v2/Services/{ServiceSid}/Verifications",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "form"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.CreateVerificationSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CreateVerificationResponse =
        new operations.CreateVerificationResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.verifyV2ServiceVerification = utils.objectToClass(
              httpRes?.data,
              shared.VerifyV2ServiceVerification
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * challenge a specific Verification Check.
   */
  createVerificationCheck(
    req: operations.CreateVerificationCheckRequest,
    security: operations.CreateVerificationCheckSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.CreateVerificationCheckResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CreateVerificationCheckRequest(req);
    }

    let baseURL: string = operations.CreateVerificationCheckServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v2/Services/{ServiceSid}/VerificationCheck",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "form"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.CreateVerificationCheckSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CreateVerificationCheckResponse =
        new operations.CreateVerificationCheckResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.verifyV2ServiceVerificationCheck = utils.objectToClass(
              httpRes?.data,
              shared.VerifyV2ServiceVerificationCheck
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Create a new Webhook for the Service
   */
  createWebhook(
    req: operations.CreateWebhookRequest,
    security: operations.CreateWebhookSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.CreateWebhookResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CreateWebhookRequest(req);
    }

    let baseURL: string = operations.CreateWebhookServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v2/Services/{ServiceSid}/Webhooks",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "form"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.CreateWebhookSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CreateWebhookResponse =
        new operations.CreateWebhookResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.verifyV2ServiceWebhook = utils.objectToClass(
              httpRes?.data,
              shared.VerifyV2ServiceWebhook
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Delete a specific Bucket.
   */
  deleteBucket(
    req: operations.DeleteBucketRequest,
    security: operations.DeleteBucketSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.DeleteBucketResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DeleteBucketRequest(req);
    }

    let baseURL: string = operations.DeleteBucketServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v2/Services/{ServiceSid}/RateLimits/{RateLimitSid}/Buckets/{Sid}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.DeleteBucketSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DeleteBucketResponse =
        new operations.DeleteBucketResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
      }

      return res;
    });
  }

  /**
   * Delete a specific Entity.
   */
  deleteEntity(
    req: operations.DeleteEntityRequest,
    security: operations.DeleteEntitySecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.DeleteEntityResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DeleteEntityRequest(req);
    }

    let baseURL: string = operations.DeleteEntityServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v2/Services/{ServiceSid}/Entities/{Identity}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.DeleteEntitySecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DeleteEntityResponse =
        new operations.DeleteEntityResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
      }

      return res;
    });
  }

  /**
   * Delete a specific Factor.
   */
  deleteFactor(
    req: operations.DeleteFactorRequest,
    security: operations.DeleteFactorSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.DeleteFactorResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DeleteFactorRequest(req);
    }

    let baseURL: string = operations.DeleteFactorServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v2/Services/{ServiceSid}/Entities/{Identity}/Factors/{Sid}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.DeleteFactorSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DeleteFactorResponse =
        new operations.DeleteFactorResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
      }

      return res;
    });
  }

  /**
   * Delete a specific MessagingConfiguration.
   */
  deleteMessagingConfiguration(
    req: operations.DeleteMessagingConfigurationRequest,
    security: operations.DeleteMessagingConfigurationSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.DeleteMessagingConfigurationResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DeleteMessagingConfigurationRequest(req);
    }

    let baseURL: string = operations.DeleteMessagingConfigurationServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v2/Services/{ServiceSid}/MessagingConfigurations/{Country}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.DeleteMessagingConfigurationSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DeleteMessagingConfigurationResponse =
        new operations.DeleteMessagingConfigurationResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
      }

      return res;
    });
  }

  /**
   * Delete a specific Rate Limit.
   */
  deleteRateLimit(
    req: operations.DeleteRateLimitRequest,
    security: operations.DeleteRateLimitSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.DeleteRateLimitResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DeleteRateLimitRequest(req);
    }

    let baseURL: string = operations.DeleteRateLimitServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v2/Services/{ServiceSid}/RateLimits/{Sid}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.DeleteRateLimitSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DeleteRateLimitResponse =
        new operations.DeleteRateLimitResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
      }

      return res;
    });
  }

  /**
   * Remove a phone number from SafeList.
   */
  deleteSafelist(
    req: operations.DeleteSafelistRequest,
    security: operations.DeleteSafelistSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.DeleteSafelistResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DeleteSafelistRequest(req);
    }

    let baseURL: string = operations.DeleteSafelistServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v2/SafeList/Numbers/{PhoneNumber}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.DeleteSafelistSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DeleteSafelistResponse =
        new operations.DeleteSafelistResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
      }

      return res;
    });
  }

  /**
   * Delete a specific Verification Service Instance.
   */
  deleteService(
    req: operations.DeleteServiceRequest,
    security: operations.DeleteServiceSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.DeleteServiceResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DeleteServiceRequest(req);
    }

    let baseURL: string = operations.DeleteServiceServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(baseURL, "/v2/Services/{Sid}", req);
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.DeleteServiceSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DeleteServiceResponse =
        new operations.DeleteServiceResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
      }

      return res;
    });
  }

  /**
   * Delete a specific Webhook.
   */
  deleteWebhook(
    req: operations.DeleteWebhookRequest,
    security: operations.DeleteWebhookSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.DeleteWebhookResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DeleteWebhookRequest(req);
    }

    let baseURL: string = operations.DeleteWebhookServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v2/Services/{ServiceSid}/Webhooks/{Sid}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.DeleteWebhookSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DeleteWebhookResponse =
        new operations.DeleteWebhookResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
      }

      return res;
    });
  }

  /**
   * Fetch an Access Token for the Entity
   */
  fetchAccessToken(
    req: operations.FetchAccessTokenRequest,
    security: operations.FetchAccessTokenSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.FetchAccessTokenResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.FetchAccessTokenRequest(req);
    }

    let baseURL: string = operations.FetchAccessTokenServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v2/Services/{ServiceSid}/AccessTokens/{Sid}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.FetchAccessTokenSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.FetchAccessTokenResponse =
        new operations.FetchAccessTokenResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.verifyV2ServiceAccessToken = utils.objectToClass(
              httpRes?.data,
              shared.VerifyV2ServiceAccessToken
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Fetch a specific Bucket.
   */
  fetchBucket(
    req: operations.FetchBucketRequest,
    security: operations.FetchBucketSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.FetchBucketResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.FetchBucketRequest(req);
    }

    let baseURL: string = operations.FetchBucketServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v2/Services/{ServiceSid}/RateLimits/{RateLimitSid}/Buckets/{Sid}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.FetchBucketSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.FetchBucketResponse =
        new operations.FetchBucketResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.verifyV2ServiceRateLimitBucket = utils.objectToClass(
              httpRes?.data,
              shared.VerifyV2ServiceRateLimitBucket
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Fetch a specific Challenge.
   */
  fetchChallenge(
    req: operations.FetchChallengeRequest,
    security: operations.FetchChallengeSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.FetchChallengeResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.FetchChallengeRequest(req);
    }

    let baseURL: string = operations.FetchChallengeServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v2/Services/{ServiceSid}/Entities/{Identity}/Challenges/{Sid}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.FetchChallengeSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.FetchChallengeResponse =
        new operations.FetchChallengeResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.verifyV2ServiceEntityChallenge = utils.objectToClass(
              httpRes?.data,
              shared.VerifyV2ServiceEntityChallenge
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Fetch a specific Entity.
   */
  fetchEntity(
    req: operations.FetchEntityRequest,
    security: operations.FetchEntitySecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.FetchEntityResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.FetchEntityRequest(req);
    }

    let baseURL: string = operations.FetchEntityServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v2/Services/{ServiceSid}/Entities/{Identity}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.FetchEntitySecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.FetchEntityResponse =
        new operations.FetchEntityResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.verifyV2ServiceEntity = utils.objectToClass(
              httpRes?.data,
              shared.VerifyV2ServiceEntity
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Fetch a specific Factor.
   */
  fetchFactor(
    req: operations.FetchFactorRequest,
    security: operations.FetchFactorSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.FetchFactorResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.FetchFactorRequest(req);
    }

    let baseURL: string = operations.FetchFactorServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v2/Services/{ServiceSid}/Entities/{Identity}/Factors/{Sid}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.FetchFactorSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.FetchFactorResponse =
        new operations.FetchFactorResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.verifyV2ServiceEntityFactor = utils.objectToClass(
              httpRes?.data,
              shared.VerifyV2ServiceEntityFactor
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Fetch the forms for a specific Form Type.
   */
  fetchForm(
    req: operations.FetchFormRequest,
    security: operations.FetchFormSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.FetchFormResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.FetchFormRequest(req);
    }

    let baseURL: string = operations.FetchFormServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(baseURL, "/v2/Forms/{FormType}", req);
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.FetchFormSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.FetchFormResponse =
        new operations.FetchFormResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.verifyV2Form = utils.objectToClass(
              httpRes?.data,
              shared.VerifyV2Form
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Fetch a specific MessagingConfiguration.
   */
  fetchMessagingConfiguration(
    req: operations.FetchMessagingConfigurationRequest,
    security: operations.FetchMessagingConfigurationSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.FetchMessagingConfigurationResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.FetchMessagingConfigurationRequest(req);
    }

    let baseURL: string = operations.FetchMessagingConfigurationServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v2/Services/{ServiceSid}/MessagingConfigurations/{Country}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.FetchMessagingConfigurationSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.FetchMessagingConfigurationResponse =
        new operations.FetchMessagingConfigurationResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.verifyV2ServiceMessagingConfiguration = utils.objectToClass(
              httpRes?.data,
              shared.VerifyV2ServiceMessagingConfiguration
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Fetch a specific Rate Limit.
   */
  fetchRateLimit(
    req: operations.FetchRateLimitRequest,
    security: operations.FetchRateLimitSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.FetchRateLimitResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.FetchRateLimitRequest(req);
    }

    let baseURL: string = operations.FetchRateLimitServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v2/Services/{ServiceSid}/RateLimits/{Sid}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.FetchRateLimitSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.FetchRateLimitResponse =
        new operations.FetchRateLimitResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.verifyV2ServiceRateLimit = utils.objectToClass(
              httpRes?.data,
              shared.VerifyV2ServiceRateLimit
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Check if a phone number exists in SafeList.
   */
  fetchSafelist(
    req: operations.FetchSafelistRequest,
    security: operations.FetchSafelistSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.FetchSafelistResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.FetchSafelistRequest(req);
    }

    let baseURL: string = operations.FetchSafelistServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v2/SafeList/Numbers/{PhoneNumber}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.FetchSafelistSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.FetchSafelistResponse =
        new operations.FetchSafelistResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.verifyV2Safelist = utils.objectToClass(
              httpRes?.data,
              shared.VerifyV2Safelist
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Fetch specific Verification Service Instance.
   */
  fetchService(
    req: operations.FetchServiceRequest,
    security: operations.FetchServiceSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.FetchServiceResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.FetchServiceRequest(req);
    }

    let baseURL: string = operations.FetchServiceServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(baseURL, "/v2/Services/{Sid}", req);
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.FetchServiceSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.FetchServiceResponse =
        new operations.FetchServiceResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.verifyV2Service = utils.objectToClass(
              httpRes?.data,
              shared.VerifyV2Service
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Fetch a specific Verification
   */
  fetchVerification(
    req: operations.FetchVerificationRequest,
    security: operations.FetchVerificationSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.FetchVerificationResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.FetchVerificationRequest(req);
    }

    let baseURL: string = operations.FetchVerificationServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v2/Services/{ServiceSid}/Verifications/{Sid}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.FetchVerificationSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.FetchVerificationResponse =
        new operations.FetchVerificationResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.verifyV2ServiceVerification = utils.objectToClass(
              httpRes?.data,
              shared.VerifyV2ServiceVerification
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Fetch a specific verification attempt.
   */
  fetchVerificationAttempt(
    req: operations.FetchVerificationAttemptRequest,
    security: operations.FetchVerificationAttemptSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.FetchVerificationAttemptResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.FetchVerificationAttemptRequest(req);
    }

    let baseURL: string = operations.FetchVerificationAttemptServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(baseURL, "/v2/Attempts/{Sid}", req);
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.FetchVerificationAttemptSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.FetchVerificationAttemptResponse =
        new operations.FetchVerificationAttemptResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.verifyV2VerificationAttempt = utils.objectToClass(
              httpRes?.data,
              shared.VerifyV2VerificationAttempt
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Get a summary of how many attempts were made and how many were converted.
   */
  fetchVerificationAttemptsSummary(
    req: operations.FetchVerificationAttemptsSummaryRequest,
    security: operations.FetchVerificationAttemptsSummarySecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.FetchVerificationAttemptsSummaryResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.FetchVerificationAttemptsSummaryRequest(req);
    }

    let baseURL: string =
      operations.FetchVerificationAttemptsSummaryServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = baseURL.replace(/\/$/, "") + "/v2/Attempts/Summary";
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.FetchVerificationAttemptsSummarySecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.FetchVerificationAttemptsSummaryResponse =
        new operations.FetchVerificationAttemptsSummaryResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.verifyV2VerificationAttemptsSummary = utils.objectToClass(
              httpRes?.data,
              shared.VerifyV2VerificationAttemptsSummary
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Fetch a specific Webhook.
   */
  fetchWebhook(
    req: operations.FetchWebhookRequest,
    security: operations.FetchWebhookSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.FetchWebhookResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.FetchWebhookRequest(req);
    }

    let baseURL: string = operations.FetchWebhookServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v2/Services/{ServiceSid}/Webhooks/{Sid}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.FetchWebhookSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.FetchWebhookResponse =
        new operations.FetchWebhookResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.verifyV2ServiceWebhook = utils.objectToClass(
              httpRes?.data,
              shared.VerifyV2ServiceWebhook
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Retrieve a list of all Buckets for a Rate Limit.
   */
  listBucket(
    req: operations.ListBucketRequest,
    security: operations.ListBucketSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.ListBucketResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ListBucketRequest(req);
    }

    let baseURL: string = operations.ListBucketServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v2/Services/{ServiceSid}/RateLimits/{RateLimitSid}/Buckets",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ListBucketSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ListBucketResponse =
        new operations.ListBucketResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listBucketResponse = utils.objectToClass(
              httpRes?.data,
              operations.ListBucketListBucketResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Retrieve a list of all Challenges for a Factor.
   */
  listChallenge(
    req: operations.ListChallengeRequest,
    security: operations.ListChallengeSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.ListChallengeResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ListChallengeRequest(req);
    }

    let baseURL: string = operations.ListChallengeServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v2/Services/{ServiceSid}/Entities/{Identity}/Challenges",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ListChallengeSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ListChallengeResponse =
        new operations.ListChallengeResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listChallengeResponse = utils.objectToClass(
              httpRes?.data,
              operations.ListChallengeListChallengeResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Retrieve a list of all Entities for a Service.
   */
  listEntity(
    req: operations.ListEntityRequest,
    security: operations.ListEntitySecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.ListEntityResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ListEntityRequest(req);
    }

    let baseURL: string = operations.ListEntityServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v2/Services/{ServiceSid}/Entities",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ListEntitySecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ListEntityResponse =
        new operations.ListEntityResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listEntityResponse = utils.objectToClass(
              httpRes?.data,
              operations.ListEntityListEntityResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Retrieve a list of all Factors for an Entity.
   */
  listFactor(
    req: operations.ListFactorRequest,
    security: operations.ListFactorSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.ListFactorResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ListFactorRequest(req);
    }

    let baseURL: string = operations.ListFactorServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v2/Services/{ServiceSid}/Entities/{Identity}/Factors",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ListFactorSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ListFactorResponse =
        new operations.ListFactorResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listFactorResponse = utils.objectToClass(
              httpRes?.data,
              operations.ListFactorListFactorResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Retrieve a list of all Messaging Configurations for a Service.
   */
  listMessagingConfiguration(
    req: operations.ListMessagingConfigurationRequest,
    security: operations.ListMessagingConfigurationSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.ListMessagingConfigurationResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ListMessagingConfigurationRequest(req);
    }

    let baseURL: string = operations.ListMessagingConfigurationServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v2/Services/{ServiceSid}/MessagingConfigurations",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ListMessagingConfigurationSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ListMessagingConfigurationResponse =
        new operations.ListMessagingConfigurationResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listMessagingConfigurationResponse = utils.objectToClass(
              httpRes?.data,
              operations.ListMessagingConfigurationListMessagingConfigurationResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Retrieve a list of all Rate Limits for a service.
   */
  listRateLimit(
    req: operations.ListRateLimitRequest,
    security: operations.ListRateLimitSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.ListRateLimitResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ListRateLimitRequest(req);
    }

    let baseURL: string = operations.ListRateLimitServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v2/Services/{ServiceSid}/RateLimits",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ListRateLimitSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ListRateLimitResponse =
        new operations.ListRateLimitResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listRateLimitResponse = utils.objectToClass(
              httpRes?.data,
              operations.ListRateLimitListRateLimitResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Retrieve a list of all Verification Services for an account.
   */
  listService(
    req: operations.ListServiceRequest,
    security: operations.ListServiceSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.ListServiceResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ListServiceRequest(req);
    }

    let baseURL: string = operations.ListServiceServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = baseURL.replace(/\/$/, "") + "/v2/Services";
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ListServiceSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ListServiceResponse =
        new operations.ListServiceResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listServiceResponse = utils.objectToClass(
              httpRes?.data,
              operations.ListServiceListServiceResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * List all the verification attempts for a given Account.
   */
  listVerificationAttempt(
    req: operations.ListVerificationAttemptRequest,
    security: operations.ListVerificationAttemptSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.ListVerificationAttemptResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ListVerificationAttemptRequest(req);
    }

    let baseURL: string = operations.ListVerificationAttemptServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = baseURL.replace(/\/$/, "") + "/v2/Attempts";
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ListVerificationAttemptSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ListVerificationAttemptResponse =
        new operations.ListVerificationAttemptResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listVerificationAttemptResponse = utils.objectToClass(
              httpRes?.data,
              operations.ListVerificationAttemptListVerificationAttemptResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * List all the available templates for a given Account.
   */
  listVerificationTemplate(
    req: operations.ListVerificationTemplateRequest,
    security: operations.ListVerificationTemplateSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.ListVerificationTemplateResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ListVerificationTemplateRequest(req);
    }

    let baseURL: string = operations.ListVerificationTemplateServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = baseURL.replace(/\/$/, "") + "/v2/Templates";
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ListVerificationTemplateSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ListVerificationTemplateResponse =
        new operations.ListVerificationTemplateResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listVerificationTemplateResponse = utils.objectToClass(
              httpRes?.data,
              operations.ListVerificationTemplateListVerificationTemplateResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Retrieve a list of all Webhooks for a Service.
   */
  listWebhook(
    req: operations.ListWebhookRequest,
    security: operations.ListWebhookSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.ListWebhookResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ListWebhookRequest(req);
    }

    let baseURL: string = operations.ListWebhookServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v2/Services/{ServiceSid}/Webhooks",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ListWebhookSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ListWebhookResponse =
        new operations.ListWebhookResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listWebhookResponse = utils.objectToClass(
              httpRes?.data,
              operations.ListWebhookListWebhookResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Update a specific Bucket.
   */
  updateBucket(
    req: operations.UpdateBucketRequest,
    security: operations.UpdateBucketSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.UpdateBucketResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.UpdateBucketRequest(req);
    }

    let baseURL: string = operations.UpdateBucketServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v2/Services/{ServiceSid}/RateLimits/{RateLimitSid}/Buckets/{Sid}",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "form"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.UpdateBucketSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UpdateBucketResponse =
        new operations.UpdateBucketResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.verifyV2ServiceRateLimitBucket = utils.objectToClass(
              httpRes?.data,
              shared.VerifyV2ServiceRateLimitBucket
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Verify a specific Challenge.
   */
  updateChallenge(
    req: operations.UpdateChallengeRequest,
    security: operations.UpdateChallengeSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.UpdateChallengeResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.UpdateChallengeRequest(req);
    }

    let baseURL: string = operations.UpdateChallengeServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v2/Services/{ServiceSid}/Entities/{Identity}/Challenges/{Sid}",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "form"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.UpdateChallengeSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UpdateChallengeResponse =
        new operations.UpdateChallengeResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.verifyV2ServiceEntityChallenge = utils.objectToClass(
              httpRes?.data,
              shared.VerifyV2ServiceEntityChallenge
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Update a specific Factor. This endpoint can be used to Verify a Factor if passed an `AuthPayload` param.
   */
  updateFactor(
    req: operations.UpdateFactorRequest,
    security: operations.UpdateFactorSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.UpdateFactorResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.UpdateFactorRequest(req);
    }

    let baseURL: string = operations.UpdateFactorServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v2/Services/{ServiceSid}/Entities/{Identity}/Factors/{Sid}",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "form"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.UpdateFactorSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UpdateFactorResponse =
        new operations.UpdateFactorResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.verifyV2ServiceEntityFactor = utils.objectToClass(
              httpRes?.data,
              shared.VerifyV2ServiceEntityFactor
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Update a specific MessagingConfiguration
   */
  updateMessagingConfiguration(
    req: operations.UpdateMessagingConfigurationRequest,
    security: operations.UpdateMessagingConfigurationSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.UpdateMessagingConfigurationResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.UpdateMessagingConfigurationRequest(req);
    }

    let baseURL: string = operations.UpdateMessagingConfigurationServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v2/Services/{ServiceSid}/MessagingConfigurations/{Country}",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "form"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.UpdateMessagingConfigurationSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UpdateMessagingConfigurationResponse =
        new operations.UpdateMessagingConfigurationResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.verifyV2ServiceMessagingConfiguration = utils.objectToClass(
              httpRes?.data,
              shared.VerifyV2ServiceMessagingConfiguration
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Update a specific Rate Limit.
   */
  updateRateLimit(
    req: operations.UpdateRateLimitRequest,
    security: operations.UpdateRateLimitSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.UpdateRateLimitResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.UpdateRateLimitRequest(req);
    }

    let baseURL: string = operations.UpdateRateLimitServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v2/Services/{ServiceSid}/RateLimits/{Sid}",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "form"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.UpdateRateLimitSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UpdateRateLimitResponse =
        new operations.UpdateRateLimitResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.verifyV2ServiceRateLimit = utils.objectToClass(
              httpRes?.data,
              shared.VerifyV2ServiceRateLimit
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Update a specific Verification Service.
   */
  updateService(
    req: operations.UpdateServiceRequest,
    security: operations.UpdateServiceSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.UpdateServiceResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.UpdateServiceRequest(req);
    }

    let baseURL: string = operations.UpdateServiceServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(baseURL, "/v2/Services/{Sid}", req);

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "form"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.UpdateServiceSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UpdateServiceResponse =
        new operations.UpdateServiceResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.verifyV2Service = utils.objectToClass(
              httpRes?.data,
              shared.VerifyV2Service
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Update a Verification status
   */
  updateVerification(
    req: operations.UpdateVerificationRequest,
    security: operations.UpdateVerificationSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.UpdateVerificationResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.UpdateVerificationRequest(req);
    }

    let baseURL: string = operations.UpdateVerificationServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v2/Services/{ServiceSid}/Verifications/{Sid}",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "form"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.UpdateVerificationSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UpdateVerificationResponse =
        new operations.UpdateVerificationResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.verifyV2ServiceVerification = utils.objectToClass(
              httpRes?.data,
              shared.VerifyV2ServiceVerification
            );
          }
          break;
      }

      return res;
    });
  }

  updateWebhook(
    req: operations.UpdateWebhookRequest,
    security: operations.UpdateWebhookSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.UpdateWebhookResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.UpdateWebhookRequest(req);
    }

    let baseURL: string = operations.UpdateWebhookServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v2/Services/{ServiceSid}/Webhooks/{Sid}",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "form"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.UpdateWebhookSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UpdateWebhookResponse =
        new operations.UpdateWebhookResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.verifyV2ServiceWebhook = utils.objectToClass(
              httpRes?.data,
              shared.VerifyV2ServiceWebhook
            );
          }
          break;
      }

      return res;
    });
  }
}
