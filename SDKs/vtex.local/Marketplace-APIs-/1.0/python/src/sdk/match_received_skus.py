"""Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT."""

import requests as requests_http
from . import utils
from sdk.models import operations

class MatchReceivedSKUs:
    r"""Match SKU suggestions received in the marketplace"""
    _client: requests_http.Session
    _security_client: requests_http.Session
    _server_url: str
    _language: str
    _sdk_version: str
    _gen_version: str

    def __init__(self, client: requests_http.Session, security_client: requests_http.Session, server_url: str, language: str, sdk_version: str, gen_version: str) -> None:
        self._client = client
        self._security_client = security_client
        self._server_url = server_url
        self._language = language
        self._sdk_version = sdk_version
        self._gen_version = gen_version
        
    def match(self, request: operations.MatchRequest) -> operations.MatchResponse:
        r"""Match Received SKUs individually
        All SKUs sent from a seller to a marketplace must be reviewed and matched. Actions in the matching process are added in the request body through the [matchType] object. Match type actions include: 
        
        1. `newproduct`: match the SKU as a new product. 
        
        2. `itemMatch`: associate the received SKU to an existing SKU. 
        
        3. `productMatch`: associate the received SKU to an existing product. 
        
        4. `deny`: deny the received SKU. 
        
        5. `pending`: the received SKU requires attention. 
        
        6. `incomplete`: the received SKU is lacking information to be matched. 
        
        7. `insufficientScore`: the score given by the Matcher to this received SKU doesn't qualify it to be matched. 
        
        Note that  if the autoApprove setting is enabled, the SKUs will be approved, regardless of the Score.
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.MatchRequest, base_url, '/suggestions/{sellerId}/{sellerskuid}/versions/{version}/matches/{matchid}', request)
        
        headers = utils.get_headers(request)
        req_content_type, data, form = utils.serialize_request_body(request, "match_request", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        query_params = utils.get_query_params(operations.MatchRequest, request)
        
        client = self._security_client
        
        http_res = client.request('PUT', url, params=query_params, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.MatchResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        

        return res

    def match_multiple(self, request: operations.MatchMultipleRequest) -> operations.MatchMultipleResponse:
        r"""Match Multiple Received SKUs
        This endpoint allows the user to bulk approve, deny, or associate received SKUs. In a single request, you can match up to 25 received SKUs from your sellers.
        
        Through the `actionName` attribute you can select the operation you want to apply to the received SKU. 
        
        Actions include: 
        
        1. `newproduct`: match the SKU as a new product. 
        
        2. `skuassociation`: associate the received SKU to an existing SKU. 
        
        3. `productassociation`: associate the received SKU to an existing product. 
        
        4. `deny`: deny the received SKU.
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.MatchMultipleRequest, base_url, '/suggestions/matches/action/{actionName}', request)
        
        headers = utils.get_headers(request)
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        query_params = utils.get_query_params(operations.MatchMultipleRequest, request)
        
        client = self._security_client
        
        http_res = client.request('PUT', url, params=query_params, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.MatchMultipleResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        

        return res

    