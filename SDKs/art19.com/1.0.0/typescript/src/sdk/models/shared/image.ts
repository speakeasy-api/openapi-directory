/*
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

import { SpeakeasyBase, SpeakeasyMetadata } from "../../../internal/utils";
import { ResourceIdentifier } from "./resourceidentifier";
import { Expose, Transform, Type } from "class-transformer";

/**
 * This will be replaced by the relationship `bucket` in a future update.<br/>
 *
 * @remarks
 * The type of the owning entity
 *
 */
export enum ImageAttributesBucketTypeEnum {
  AdRepAccount = "AdRepAccount",
  Agency = "Agency",
  Network = "Network",
  Series = "Series",
  User = "User",
}

export class ImageAttributesTheCropAreaWithinTheOriginalMediaAsset extends SpeakeasyBase {
  /**
   * The height of the crop area
   */
  @SpeakeasyMetadata()
  @Expose({ name: "height" })
  height?: number;

  /**
   * The left coordinate of the crop area
   */
  @SpeakeasyMetadata()
  @Expose({ name: "left" })
  left?: number;

  /**
   * The top coordinate of the crop area
   */
  @SpeakeasyMetadata()
  @Expose({ name: "top" })
  top?: number;

  /**
   * The width of the crop area
   */
  @SpeakeasyMetadata()
  @Expose({ name: "width" })
  width?: number;
}

/**
 * The current value of the image state machine. It starts with `uploaded` and
 *
 * @remarks
 * transitions to `processing` once a worker has picked it up. If all variations and
 * styles of an image have been successfully created, the status becomes `valid`. In
 * case of a problem during the processing it changes to `invalid`.
 *
 */
export enum ImageAttributesStatusEnum {
  Invalid = "invalid",
  Processing = "processing",
  Uploaded = "uploaded",
  Valid = "valid",
}

export class ImageAttributes extends SpeakeasyBase {
  /**
   * This will be replaced by the relationship `bucket` in a future update.<br/>
   *
   * @remarks
   * The ID of the owning entity
   *
   */
  @SpeakeasyMetadata()
  @Expose({ name: "bucket_id" })
  bucketId?: string;

  /**
   * This will be replaced by the relationship `bucket` in a future update.<br/>
   *
   * @remarks
   * The type of the owning entity
   *
   */
  @SpeakeasyMetadata()
  @Expose({ name: "bucket_type" })
  bucketType?: ImageAttributesBucketTypeEnum;

  @SpeakeasyMetadata()
  @Expose({ name: "created_at" })
  @Transform(({ value }) => new Date(value), { toClassOnly: true })
  createdAt?: Date;

  @SpeakeasyMetadata()
  @Expose({ name: "crop_data" })
  @Type(() => ImageAttributesTheCropAreaWithinTheOriginalMediaAsset)
  cropData?: ImageAttributesTheCropAreaWithinTheOriginalMediaAsset;

  /**
   * The current value of the image state machine. It starts with `uploaded` and
   *
   * @remarks
   * transitions to `processing` once a worker has picked it up. If all variations and
   * styles of an image have been successfully created, the status becomes `valid`. In
   * case of a problem during the processing it changes to `invalid`.
   *
   */
  @SpeakeasyMetadata()
  @Expose({ name: "status" })
  status?: ImageAttributesStatusEnum;

  @SpeakeasyMetadata()
  @Expose({ name: "updated_at" })
  @Transform(({ value }) => new Date(value), { toClassOnly: true })
  updatedAt?: Date;
}

export class ImageRelationshipsAllMediaAssetsAvailableForThisImage extends SpeakeasyBase {
  @SpeakeasyMetadata({ elemType: ResourceIdentifier })
  @Expose({ name: "data" })
  @Type(() => ResourceIdentifier)
  data?: ResourceIdentifier[];
}

export class ImageRelationships extends SpeakeasyBase {
  @SpeakeasyMetadata()
  @Expose({ name: "media_assets" })
  @Type(() => ImageRelationshipsAllMediaAssetsAvailableForThisImage)
  mediaAssets?: ImageRelationshipsAllMediaAssetsAvailableForThisImage;
}

export class Image extends SpeakeasyBase {
  @SpeakeasyMetadata()
  @Expose({ name: "attributes" })
  @Type(() => ImageAttributes)
  attributes?: ImageAttributes;

  @SpeakeasyMetadata()
  @Expose({ name: "id" })
  id?: string;

  @SpeakeasyMetadata()
  @Expose({ name: "relationships" })
  @Type(() => ImageRelationships)
  relationships?: ImageRelationships;

  /**
   * The type of resource. This is always `images`
   */
  @SpeakeasyMetadata()
  @Expose({ name: "type" })
  type?: string;
}
