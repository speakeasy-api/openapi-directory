/*
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

import { SpeakeasyBase, SpeakeasyMetadata } from "../../../internal/utils";
import { AudioRenderTimelineSpanInstrumentGroup } from "./audiorendertimelinespaninstrumentgroup";
import { AudioRenderTimelineSpanRegion } from "./audiorendertimelinespanregion";
import { AudioRenderTimelineSpanTempoChanges } from "./audiorendertimelinespantempochanges";
import { Expose, Type } from "class-transformer";

/**
 * Type of span; metered spans represent a pariod of time with music, and unmetered spans denote the end of the prior metered span
 */
export enum AudioRenderTimelineSpanSpanTypeEnum {
  Metered = "metered",
  Unmetered = "unmetered",
}

/**
 * The beginning of a non-overlapping period of absolute time
 */
export class AudioRenderTimelineSpan extends SpeakeasyBase {
  /**
   * An identifier which must be unique within the parent span
   */
  @SpeakeasyMetadata()
  @Expose({ name: "id" })
  id?: number;

  /**
   * An array of instrument_group objects that are used in this span
   */
  @SpeakeasyMetadata({ elemType: AudioRenderTimelineSpanInstrumentGroup })
  @Expose({ name: "instrument_groups" })
  @Type(() => AudioRenderTimelineSpanInstrumentGroup)
  instrumentGroups?: AudioRenderTimelineSpanInstrumentGroup[];

  /**
   * An array of region objects within the span
   */
  @SpeakeasyMetadata({ elemType: AudioRenderTimelineSpanRegion })
  @Expose({ name: "regions" })
  @Type(() => AudioRenderTimelineSpanRegion)
  regions?: AudioRenderTimelineSpanRegion[];

  /**
   * Type of span; metered spans represent a pariod of time with music, and unmetered spans denote the end of the prior metered span
   */
  @SpeakeasyMetadata()
  @Expose({ name: "span_type" })
  spanType: AudioRenderTimelineSpanSpanTypeEnum;

  /**
   * The tempo, in beats per minute, at the start of the span; if not provided, the API selects a random tempo
   */
  @SpeakeasyMetadata()
  @Expose({ name: "tempo" })
  tempo?: number;

  /**
   * Two or more inflection points in a tempo curve; the API creates a smoothly changing tempo by using a linear interpolation of the time between each tempo change
   */
  @SpeakeasyMetadata({ elemType: AudioRenderTimelineSpanTempoChanges })
  @Expose({ name: "tempo_changes" })
  @Type(() => AudioRenderTimelineSpanTempoChanges)
  tempoChanges?: AudioRenderTimelineSpanTempoChanges[];

  /**
   * The absolute time, in seconds, at which the span starts
   */
  @SpeakeasyMetadata()
  @Expose({ name: "time" })
  time: number;
}
