/*
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

import * as utils from "../internal/utils";
import * as operations from "./models/operations";
import * as shared from "./models/shared";
import axios from "axios";
import { AxiosInstance, AxiosRequestConfig, AxiosResponse } from "axios";

/**
 * Contains the list of servers available to the SDK
 */
export const ServerList = ["https://numbers.twilio.com"] as const;

/**
 * The available configuration options for the SDK
 */
export type SDKProps = {
  /**
   * Allows overriding the default axios client used by the SDK
   */
  defaultClient?: AxiosInstance;
  /**
   * Allows overriding the default server URL used by the SDK
   */
  serverURL?: string;
};

/**
 * This is the public Twilio REST API.
 */
export class SDK {
  public _defaultClient: AxiosInstance;
  public _securityClient: AxiosInstance;
  public _serverURL: string;
  private _language = "typescript";
  private _sdkVersion = "0.0.1";
  private _genVersion = "internal";
  private _globals: any;

  constructor(props?: SDKProps) {
    this._serverURL = props?.serverURL ?? ServerList[0];

    this._defaultClient =
      props?.defaultClient ?? axios.create({ baseURL: this._serverURL });
    this._securityClient = this._defaultClient;
  }

  /**
   * Create a new Bundle.
   */
  createBundle(
    req: operations.CreateBundleCreateBundleRequest,
    security: operations.CreateBundleSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.CreateBundleResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CreateBundleCreateBundleRequest(req);
    }

    let baseURL: string = operations.CreateBundleServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string =
      baseURL.replace(/\/$/, "") + "/v2/RegulatoryCompliance/Bundles";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "request",
        "form"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.CreateBundleSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CreateBundleResponse =
        new operations.CreateBundleResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.numbersV2RegulatoryComplianceBundle = utils.objectToClass(
              httpRes?.data,
              shared.NumbersV2RegulatoryComplianceBundle
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Creates a new copy of a Bundle. It will internally create copies of all the bundle items (identities and documents) of the original bundle
   */
  createBundleCopy(
    req: operations.CreateBundleCopyRequest,
    security: operations.CreateBundleCopySecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.CreateBundleCopyResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CreateBundleCopyRequest(req);
    }

    let baseURL: string = operations.CreateBundleCopyServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v2/RegulatoryCompliance/Bundles/{BundleSid}/Copies",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "form"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.CreateBundleCopySecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CreateBundleCopyResponse =
        new operations.CreateBundleCopyResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.numbersV2RegulatoryComplianceBundleBundleCopy =
              utils.objectToClass(
                httpRes?.data,
                shared.NumbersV2RegulatoryComplianceBundleBundleCopy
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Create a new End User.
   */
  createEndUser(
    req: operations.CreateEndUserCreateEndUserRequest,
    security: operations.CreateEndUserSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.CreateEndUserResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CreateEndUserCreateEndUserRequest(req);
    }

    let baseURL: string = operations.CreateEndUserServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string =
      baseURL.replace(/\/$/, "") + "/v2/RegulatoryCompliance/EndUsers";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "request",
        "form"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.CreateEndUserSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CreateEndUserResponse =
        new operations.CreateEndUserResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.numbersV2RegulatoryComplianceEndUser = utils.objectToClass(
              httpRes?.data,
              shared.NumbersV2RegulatoryComplianceEndUser
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Creates an evaluation for a bundle
   */
  createEvaluation(
    req: operations.CreateEvaluationRequest,
    security: operations.CreateEvaluationSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.CreateEvaluationResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CreateEvaluationRequest(req);
    }

    let baseURL: string = operations.CreateEvaluationServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v2/RegulatoryCompliance/Bundles/{BundleSid}/Evaluations",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.CreateEvaluationSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "post",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CreateEvaluationResponse =
        new operations.CreateEvaluationResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.numbersV2RegulatoryComplianceBundleEvaluation =
              utils.objectToClass(
                httpRes?.data,
                shared.NumbersV2RegulatoryComplianceBundleEvaluation
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Create a new Assigned Item.
   */
  createItemAssignment(
    req: operations.CreateItemAssignmentRequest,
    security: operations.CreateItemAssignmentSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.CreateItemAssignmentResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CreateItemAssignmentRequest(req);
    }

    let baseURL: string = operations.CreateItemAssignmentServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v2/RegulatoryCompliance/Bundles/{BundleSid}/ItemAssignments",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "form"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.CreateItemAssignmentSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CreateItemAssignmentResponse =
        new operations.CreateItemAssignmentResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.numbersV2RegulatoryComplianceBundleItemAssignment =
              utils.objectToClass(
                httpRes?.data,
                shared.NumbersV2RegulatoryComplianceBundleItemAssignment
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Replaces all bundle items in the target bundle (specified in the path) with all the bundle items of the source bundle (specified by the from_bundle_sid body param)
   */
  createReplaceItems(
    req: operations.CreateReplaceItemsRequest,
    security: operations.CreateReplaceItemsSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.CreateReplaceItemsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CreateReplaceItemsRequest(req);
    }

    let baseURL: string = operations.CreateReplaceItemsServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v2/RegulatoryCompliance/Bundles/{BundleSid}/ReplaceItems",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "form"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.CreateReplaceItemsSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CreateReplaceItemsResponse =
        new operations.CreateReplaceItemsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.numbersV2RegulatoryComplianceBundleReplaceItems =
              utils.objectToClass(
                httpRes?.data,
                shared.NumbersV2RegulatoryComplianceBundleReplaceItems
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Create a new Supporting Document.
   */
  createSupportingDocument(
    req: operations.CreateSupportingDocumentCreateSupportingDocumentRequest,
    security: operations.CreateSupportingDocumentSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.CreateSupportingDocumentResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.CreateSupportingDocumentCreateSupportingDocumentRequest(
          req
        );
    }

    let baseURL: string = operations.CreateSupportingDocumentServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string =
      baseURL.replace(/\/$/, "") +
      "/v2/RegulatoryCompliance/SupportingDocuments";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "request",
        "form"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.CreateSupportingDocumentSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CreateSupportingDocumentResponse =
        new operations.CreateSupportingDocumentResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.numbersV2RegulatoryComplianceSupportingDocument =
              utils.objectToClass(
                httpRes?.data,
                shared.NumbersV2RegulatoryComplianceSupportingDocument
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Delete a specific Bundle.
   */
  deleteBundle(
    req: operations.DeleteBundleRequest,
    security: operations.DeleteBundleSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.DeleteBundleResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DeleteBundleRequest(req);
    }

    let baseURL: string = operations.DeleteBundleServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v2/RegulatoryCompliance/Bundles/{Sid}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.DeleteBundleSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DeleteBundleResponse =
        new operations.DeleteBundleResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
      }

      return res;
    });
  }

  /**
   * Delete a specific End User.
   */
  deleteEndUser(
    req: operations.DeleteEndUserRequest,
    security: operations.DeleteEndUserSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.DeleteEndUserResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DeleteEndUserRequest(req);
    }

    let baseURL: string = operations.DeleteEndUserServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v2/RegulatoryCompliance/EndUsers/{Sid}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.DeleteEndUserSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DeleteEndUserResponse =
        new operations.DeleteEndUserResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
      }

      return res;
    });
  }

  /**
   * Remove an Assignment Item Instance.
   */
  deleteItemAssignment(
    req: operations.DeleteItemAssignmentRequest,
    security: operations.DeleteItemAssignmentSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.DeleteItemAssignmentResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DeleteItemAssignmentRequest(req);
    }

    let baseURL: string = operations.DeleteItemAssignmentServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v2/RegulatoryCompliance/Bundles/{BundleSid}/ItemAssignments/{Sid}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.DeleteItemAssignmentSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DeleteItemAssignmentResponse =
        new operations.DeleteItemAssignmentResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
      }

      return res;
    });
  }

  /**
   * Delete a specific Supporting Document.
   */
  deleteSupportingDocument(
    req: operations.DeleteSupportingDocumentRequest,
    security: operations.DeleteSupportingDocumentSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.DeleteSupportingDocumentResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DeleteSupportingDocumentRequest(req);
    }

    let baseURL: string = operations.DeleteSupportingDocumentServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v2/RegulatoryCompliance/SupportingDocuments/{Sid}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.DeleteSupportingDocumentSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DeleteSupportingDocumentResponse =
        new operations.DeleteSupportingDocumentResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
      }

      return res;
    });
  }

  /**
   * Fetch a specific Bundle instance.
   */
  fetchBundle(
    req: operations.FetchBundleRequest,
    security: operations.FetchBundleSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.FetchBundleResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.FetchBundleRequest(req);
    }

    let baseURL: string = operations.FetchBundleServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v2/RegulatoryCompliance/Bundles/{Sid}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.FetchBundleSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.FetchBundleResponse =
        new operations.FetchBundleResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.numbersV2RegulatoryComplianceBundle = utils.objectToClass(
              httpRes?.data,
              shared.NumbersV2RegulatoryComplianceBundle
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Fetch specific End User Instance.
   */
  fetchEndUser(
    req: operations.FetchEndUserRequest,
    security: operations.FetchEndUserSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.FetchEndUserResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.FetchEndUserRequest(req);
    }

    let baseURL: string = operations.FetchEndUserServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v2/RegulatoryCompliance/EndUsers/{Sid}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.FetchEndUserSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.FetchEndUserResponse =
        new operations.FetchEndUserResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.numbersV2RegulatoryComplianceEndUser = utils.objectToClass(
              httpRes?.data,
              shared.NumbersV2RegulatoryComplianceEndUser
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Fetch a specific End-User Type Instance.
   */
  fetchEndUserType(
    req: operations.FetchEndUserTypeRequest,
    security: operations.FetchEndUserTypeSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.FetchEndUserTypeResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.FetchEndUserTypeRequest(req);
    }

    let baseURL: string = operations.FetchEndUserTypeServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v2/RegulatoryCompliance/EndUserTypes/{Sid}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.FetchEndUserTypeSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.FetchEndUserTypeResponse =
        new operations.FetchEndUserTypeResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.numbersV2RegulatoryComplianceEndUserType = utils.objectToClass(
              httpRes?.data,
              shared.NumbersV2RegulatoryComplianceEndUserType
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Fetch specific Evaluation Instance.
   */
  fetchEvaluation(
    req: operations.FetchEvaluationRequest,
    security: operations.FetchEvaluationSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.FetchEvaluationResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.FetchEvaluationRequest(req);
    }

    let baseURL: string = operations.FetchEvaluationServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v2/RegulatoryCompliance/Bundles/{BundleSid}/Evaluations/{Sid}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.FetchEvaluationSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.FetchEvaluationResponse =
        new operations.FetchEvaluationResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.numbersV2RegulatoryComplianceBundleEvaluation =
              utils.objectToClass(
                httpRes?.data,
                shared.NumbersV2RegulatoryComplianceBundleEvaluation
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Fetch specific Assigned Item Instance.
   */
  fetchItemAssignment(
    req: operations.FetchItemAssignmentRequest,
    security: operations.FetchItemAssignmentSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.FetchItemAssignmentResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.FetchItemAssignmentRequest(req);
    }

    let baseURL: string = operations.FetchItemAssignmentServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v2/RegulatoryCompliance/Bundles/{BundleSid}/ItemAssignments/{Sid}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.FetchItemAssignmentSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.FetchItemAssignmentResponse =
        new operations.FetchItemAssignmentResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.numbersV2RegulatoryComplianceBundleItemAssignment =
              utils.objectToClass(
                httpRes?.data,
                shared.NumbersV2RegulatoryComplianceBundleItemAssignment
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Fetch specific Regulation Instance.
   */
  fetchRegulation(
    req: operations.FetchRegulationRequest,
    security: operations.FetchRegulationSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.FetchRegulationResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.FetchRegulationRequest(req);
    }

    let baseURL: string = operations.FetchRegulationServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v2/RegulatoryCompliance/Regulations/{Sid}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.FetchRegulationSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.FetchRegulationResponse =
        new operations.FetchRegulationResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.numbersV2RegulatoryComplianceRegulation = utils.objectToClass(
              httpRes?.data,
              shared.NumbersV2RegulatoryComplianceRegulation
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Fetch specific Supporting Document Instance.
   */
  fetchSupportingDocument(
    req: operations.FetchSupportingDocumentRequest,
    security: operations.FetchSupportingDocumentSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.FetchSupportingDocumentResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.FetchSupportingDocumentRequest(req);
    }

    let baseURL: string = operations.FetchSupportingDocumentServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v2/RegulatoryCompliance/SupportingDocuments/{Sid}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.FetchSupportingDocumentSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.FetchSupportingDocumentResponse =
        new operations.FetchSupportingDocumentResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.numbersV2RegulatoryComplianceSupportingDocument =
              utils.objectToClass(
                httpRes?.data,
                shared.NumbersV2RegulatoryComplianceSupportingDocument
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Fetch a specific Supporting Document Type Instance.
   */
  fetchSupportingDocumentType(
    req: operations.FetchSupportingDocumentTypeRequest,
    security: operations.FetchSupportingDocumentTypeSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.FetchSupportingDocumentTypeResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.FetchSupportingDocumentTypeRequest(req);
    }

    let baseURL: string = operations.FetchSupportingDocumentTypeServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v2/RegulatoryCompliance/SupportingDocumentTypes/{Sid}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.FetchSupportingDocumentTypeSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.FetchSupportingDocumentTypeResponse =
        new operations.FetchSupportingDocumentTypeResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.numbersV2RegulatoryComplianceSupportingDocumentType =
              utils.objectToClass(
                httpRes?.data,
                shared.NumbersV2RegulatoryComplianceSupportingDocumentType
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Retrieve a list of all Bundles for an account.
   */
  listBundle(
    req: operations.ListBundleRequest,
    security: operations.ListBundleSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.ListBundleResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ListBundleRequest(req);
    }

    let baseURL: string = operations.ListBundleServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string =
      baseURL.replace(/\/$/, "") + "/v2/RegulatoryCompliance/Bundles";
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ListBundleSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ListBundleResponse =
        new operations.ListBundleResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listBundleResponse = utils.objectToClass(
              httpRes?.data,
              operations.ListBundleListBundleResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Retrieve a list of all Bundles Copies for a Bundle.
   */
  listBundleCopy(
    req: operations.ListBundleCopyRequest,
    security: operations.ListBundleCopySecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.ListBundleCopyResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ListBundleCopyRequest(req);
    }

    let baseURL: string = operations.ListBundleCopyServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v2/RegulatoryCompliance/Bundles/{BundleSid}/Copies",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ListBundleCopySecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ListBundleCopyResponse =
        new operations.ListBundleCopyResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listBundleCopyResponse = utils.objectToClass(
              httpRes?.data,
              operations.ListBundleCopyListBundleCopyResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Retrieve a list of all End User for an account.
   */
  listEndUser(
    req: operations.ListEndUserRequest,
    security: operations.ListEndUserSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.ListEndUserResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ListEndUserRequest(req);
    }

    let baseURL: string = operations.ListEndUserServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string =
      baseURL.replace(/\/$/, "") + "/v2/RegulatoryCompliance/EndUsers";
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ListEndUserSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ListEndUserResponse =
        new operations.ListEndUserResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listEndUserResponse = utils.objectToClass(
              httpRes?.data,
              operations.ListEndUserListEndUserResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Retrieve a list of all End-User Types.
   */
  listEndUserType(
    req: operations.ListEndUserTypeRequest,
    security: operations.ListEndUserTypeSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.ListEndUserTypeResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ListEndUserTypeRequest(req);
    }

    let baseURL: string = operations.ListEndUserTypeServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string =
      baseURL.replace(/\/$/, "") + "/v2/RegulatoryCompliance/EndUserTypes";
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ListEndUserTypeSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ListEndUserTypeResponse =
        new operations.ListEndUserTypeResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listEndUserTypeResponse = utils.objectToClass(
              httpRes?.data,
              operations.ListEndUserTypeListEndUserTypeResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Retrieve a list of Evaluations associated to the Bundle resource.
   */
  listEvaluation(
    req: operations.ListEvaluationRequest,
    security: operations.ListEvaluationSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.ListEvaluationResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ListEvaluationRequest(req);
    }

    let baseURL: string = operations.ListEvaluationServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v2/RegulatoryCompliance/Bundles/{BundleSid}/Evaluations",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ListEvaluationSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ListEvaluationResponse =
        new operations.ListEvaluationResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listEvaluationResponse = utils.objectToClass(
              httpRes?.data,
              operations.ListEvaluationListEvaluationResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Retrieve a list of all Assigned Items for an account.
   */
  listItemAssignment(
    req: operations.ListItemAssignmentRequest,
    security: operations.ListItemAssignmentSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.ListItemAssignmentResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ListItemAssignmentRequest(req);
    }

    let baseURL: string = operations.ListItemAssignmentServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v2/RegulatoryCompliance/Bundles/{BundleSid}/ItemAssignments",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ListItemAssignmentSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ListItemAssignmentResponse =
        new operations.ListItemAssignmentResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listItemAssignmentResponse = utils.objectToClass(
              httpRes?.data,
              operations.ListItemAssignmentListItemAssignmentResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Retrieve a list of all Regulations.
   */
  listRegulation(
    req: operations.ListRegulationRequest,
    security: operations.ListRegulationSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.ListRegulationResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ListRegulationRequest(req);
    }

    let baseURL: string = operations.ListRegulationServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string =
      baseURL.replace(/\/$/, "") + "/v2/RegulatoryCompliance/Regulations";
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ListRegulationSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ListRegulationResponse =
        new operations.ListRegulationResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listRegulationResponse = utils.objectToClass(
              httpRes?.data,
              operations.ListRegulationListRegulationResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Retrieve a list of all Supporting Document for an account.
   */
  listSupportingDocument(
    req: operations.ListSupportingDocumentRequest,
    security: operations.ListSupportingDocumentSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.ListSupportingDocumentResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ListSupportingDocumentRequest(req);
    }

    let baseURL: string = operations.ListSupportingDocumentServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string =
      baseURL.replace(/\/$/, "") +
      "/v2/RegulatoryCompliance/SupportingDocuments";
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ListSupportingDocumentSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ListSupportingDocumentResponse =
        new operations.ListSupportingDocumentResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listSupportingDocumentResponse = utils.objectToClass(
              httpRes?.data,
              operations.ListSupportingDocumentListSupportingDocumentResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Retrieve a list of all Supporting Document Types.
   */
  listSupportingDocumentType(
    req: operations.ListSupportingDocumentTypeRequest,
    security: operations.ListSupportingDocumentTypeSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.ListSupportingDocumentTypeResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ListSupportingDocumentTypeRequest(req);
    }

    let baseURL: string = operations.ListSupportingDocumentTypeServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string =
      baseURL.replace(/\/$/, "") +
      "/v2/RegulatoryCompliance/SupportingDocumentTypes";
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ListSupportingDocumentTypeSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ListSupportingDocumentTypeResponse =
        new operations.ListSupportingDocumentTypeResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listSupportingDocumentTypeResponse = utils.objectToClass(
              httpRes?.data,
              operations.ListSupportingDocumentTypeListSupportingDocumentTypeResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Updates a Bundle in an account.
   */
  updateBundle(
    req: operations.UpdateBundleRequest,
    security: operations.UpdateBundleSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.UpdateBundleResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.UpdateBundleRequest(req);
    }

    let baseURL: string = operations.UpdateBundleServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v2/RegulatoryCompliance/Bundles/{Sid}",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "form"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.UpdateBundleSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UpdateBundleResponse =
        new operations.UpdateBundleResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.numbersV2RegulatoryComplianceBundle = utils.objectToClass(
              httpRes?.data,
              shared.NumbersV2RegulatoryComplianceBundle
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Update an existing End User.
   */
  updateEndUser(
    req: operations.UpdateEndUserRequest,
    security: operations.UpdateEndUserSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.UpdateEndUserResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.UpdateEndUserRequest(req);
    }

    let baseURL: string = operations.UpdateEndUserServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v2/RegulatoryCompliance/EndUsers/{Sid}",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "form"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.UpdateEndUserSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UpdateEndUserResponse =
        new operations.UpdateEndUserResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.numbersV2RegulatoryComplianceEndUser = utils.objectToClass(
              httpRes?.data,
              shared.NumbersV2RegulatoryComplianceEndUser
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Update an existing Supporting Document.
   */
  updateSupportingDocument(
    req: operations.UpdateSupportingDocumentRequest,
    security: operations.UpdateSupportingDocumentSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.UpdateSupportingDocumentResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.UpdateSupportingDocumentRequest(req);
    }

    let baseURL: string = operations.UpdateSupportingDocumentServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v2/RegulatoryCompliance/SupportingDocuments/{Sid}",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "form"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.UpdateSupportingDocumentSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UpdateSupportingDocumentResponse =
        new operations.UpdateSupportingDocumentResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.numbersV2RegulatoryComplianceSupportingDocument =
              utils.objectToClass(
                httpRes?.data,
                shared.NumbersV2RegulatoryComplianceSupportingDocument
              );
          }
          break;
      }

      return res;
    });
  }
}
