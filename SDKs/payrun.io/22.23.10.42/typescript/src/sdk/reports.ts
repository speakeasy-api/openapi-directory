/*
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

import * as utils from "../internal/utils";
import * as operations from "./models/operations";
import * as shared from "./models/shared";
import { AxiosInstance, AxiosRequestConfig, AxiosResponse } from "axios";

export class Reports {
  _defaultClient: AxiosInstance;
  _securityClient: AxiosInstance;
  _serverURL: string;
  _language: string;
  _sdkVersion: string;
  _genVersion: string;

  constructor(
    defaultClient: AxiosInstance,
    securityClient: AxiosInstance,
    serverURL: string,
    language: string,
    sdkVersion: string,
    genVersion: string
  ) {
    this._defaultClient = defaultClient;
    this._securityClient = securityClient;
    this._serverURL = serverURL;
    this._language = language;
    this._sdkVersion = sdkVersion;
    this._genVersion = genVersion;
  }

  /**
   * Deletes a report definition
   *
   * @remarks
   * Delete the specified report definition
   */
  deleteReportDefinition(
    req: operations.DeleteReportDefinitionRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.DeleteReportDefinitionResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DeleteReportDefinitionRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/Report/{ReportDefinitionId}",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };

    const r = client.request({
      url: url,
      method: "delete",
      headers: headers,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DeleteReportDefinitionResponse =
        new operations.DeleteReportDefinitionResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
        case [400, 401, 404, 500].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorModel = utils.objectToClass(
              httpRes?.data,
              shared.ErrorModel
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Deletes a transform definition
   *
   * @remarks
   * Delete the specified transform definition
   */
  deleteTransformDefinition(
    req: operations.DeleteTransformDefinitionRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.DeleteTransformDefinitionResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DeleteTransformDefinitionRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/Transform/{TransformDefinitionId}",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };

    const r = client.request({
      url: url,
      method: "delete",
      headers: headers,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DeleteTransformDefinitionResponse =
        new operations.DeleteTransformDefinitionResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
        case [400, 401, 404, 500].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorModel = utils.objectToClass(
              httpRes?.data,
              shared.ErrorModel
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Runs the active pay instructions report
   *
   * @remarks
   * Returns the result of the executed active pay instructions report for the given query parameters
   */
  getActivePayInstructionsReportOutput(
    req: operations.GetActivePayInstructionsReportOutputRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetActivePayInstructionsReportOutputResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetActivePayInstructionsReportOutputRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/Report/ACTPAYINS/run";

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      headers: headers,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetActivePayInstructionsReportOutputResponse =
        new operations.GetActivePayInstructionsReportOutputResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            const resBody: string = JSON.stringify(httpRes?.data, null, 0);
            const out: Uint8Array = new Uint8Array(resBody.length);
            for (let i = 0; i < resBody.length; i++)
              out[i] = resBody.charCodeAt(i);
            res.getActivePayInstructionsReportOutput200ApplicationJSONBinaryString =
              out;
          }
          break;
        case [400, 401, 404, 500].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorModel = utils.objectToClass(
              httpRes?.data,
              shared.ErrorModel
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Runs the AOE liability report
   *
   * @remarks
   * Returns the result of the executed AOE liability report for the given query parameters
   */
  getAoeLiabilityReportOuput(
    req: operations.GetAoeLiabilityReportOuputRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetAoeLiabilityReportOuputResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetAoeLiabilityReportOuputRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/Report/AOELIABILITY/run";

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      headers: headers,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetAoeLiabilityReportOuputResponse =
        new operations.GetAoeLiabilityReportOuputResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            const resBody: string = JSON.stringify(httpRes?.data, null, 0);
            const out: Uint8Array = new Uint8Array(resBody.length);
            for (let i = 0; i < resBody.length; i++)
              out[i] = resBody.charCodeAt(i);
            res.getAoeLiabilityReportOuput200ApplicationJSONBinaryString = out;
          }
          break;
        case [400, 401, 404, 500].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorModel = utils.objectToClass(
              httpRes?.data,
              shared.ErrorModel
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Runs the DPS message report
   *
   * @remarks
   * Returns the result of the executed DPS message report for the given query parameters
   */
  getDpsMessageReportOutput(
    req: operations.GetDpsMessageReportOutputRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetDpsMessageReportOutputResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetDpsMessageReportOutputRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/Report/DPSMSG/run";

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      headers: headers,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetDpsMessageReportOutputResponse =
        new operations.GetDpsMessageReportOutputResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            const resBody: string = JSON.stringify(httpRes?.data, null, 0);
            const out: Uint8Array = new Uint8Array(resBody.length);
            for (let i = 0; i < resBody.length; i++)
              out[i] = resBody.charCodeAt(i);
            res.getDpsMessageReportOutput200ApplicationJSONBinaryString = out;
          }
          break;
        case [400, 401, 404, 500].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorModel = utils.objectToClass(
              httpRes?.data,
              shared.ErrorModel
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Runs the employer summary report
   *
   * @remarks
   * Returns the result of the employer summary report for the given query parameters
   */
  getEmployerSummaryReportOuput(
    req: operations.GetEmployerSummaryReportOuputRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetEmployerSummaryReportOuputResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetEmployerSummaryReportOuputRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/Report/EMPSUM/run";

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      headers: headers,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetEmployerSummaryReportOuputResponse =
        new operations.GetEmployerSummaryReportOuputResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            const resBody: string = JSON.stringify(httpRes?.data, null, 0);
            const out: Uint8Array = new Uint8Array(resBody.length);
            for (let i = 0; i < resBody.length; i++)
              out[i] = resBody.charCodeAt(i);
            res.getEmployerSummaryReportOuput200ApplicationJSONBinaryString =
              out;
          }
          break;
        case [400, 401, 404, 500].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorModel = utils.objectToClass(
              httpRes?.data,
              shared.ErrorModel
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Runs the gross to net report
   *
   * @remarks
   * Returns the result of the executed gross to net report for the given query parameters
   */
  getGrossToNetReportOutput(
    req: operations.GetGrossToNetReportOutputRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetGrossToNetReportOutputResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetGrossToNetReportOutputRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/Report/GRO2NET/run";

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      headers: headers,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetGrossToNetReportOutputResponse =
        new operations.GetGrossToNetReportOutputResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            const resBody: string = JSON.stringify(httpRes?.data, null, 0);
            const out: Uint8Array = new Uint8Array(resBody.length);
            for (let i = 0; i < resBody.length; i++)
              out[i] = resBody.charCodeAt(i);
            res.getGrossToNetReportOutput200ApplicationJSONBinaryString = out;
          }
          break;
        case [400, 401, 404, 500].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorModel = utils.objectToClass(
              httpRes?.data,
              shared.ErrorModel
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Runs the holiday balance report
   *
   * @remarks
   * Returns the result of the executed holiday balance report for the given query parameters
   */
  getHolidayBalanceReportOutput(
    req: operations.GetHolidayBalanceReportOutputRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetHolidayBalanceReportOutputResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetHolidayBalanceReportOutputRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/Report/HOLBAL/run";

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      headers: headers,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetHolidayBalanceReportOutputResponse =
        new operations.GetHolidayBalanceReportOutputResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            const resBody: string = JSON.stringify(httpRes?.data, null, 0);
            const out: Uint8Array = new Uint8Array(resBody.length);
            for (let i = 0; i < resBody.length; i++)
              out[i] = resBody.charCodeAt(i);
            res.getHolidayBalanceReportOutput200ApplicationJSONBinaryString =
              out;
          }
          break;
        case [400, 401, 404, 500].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorModel = utils.objectToClass(
              httpRes?.data,
              shared.ErrorModel
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Runs the journal report
   *
   * @remarks
   * Returns the result of the journal report for the given query parameters
   */
  getJournalReportOuput(
    req: operations.GetJournalReportOuputRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetJournalReportOuputResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetJournalReportOuputRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/Report/JOURNAL/run";

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      headers: headers,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetJournalReportOuputResponse =
        new operations.GetJournalReportOuputResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            const resBody: string = JSON.stringify(httpRes?.data, null, 0);
            const out: Uint8Array = new Uint8Array(resBody.length);
            for (let i = 0; i < resBody.length; i++)
              out[i] = resBody.charCodeAt(i);
            res.getJournalReportOuput200ApplicationJSONBinaryString = out;
          }
          break;
        case [400, 401, 404, 500].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorModel = utils.objectToClass(
              httpRes?.data,
              shared.ErrorModel
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Runs the last pay date report
   *
   * @remarks
   * Returns the result of the executed last pay date report for the given query parameters
   */
  getLastPayDateReportOuput(
    req: operations.GetLastPayDateReportOuputRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetLastPayDateReportOuputResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetLastPayDateReportOuputRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/Report/LASTPAYDATE/run";

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      headers: headers,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetLastPayDateReportOuputResponse =
        new operations.GetLastPayDateReportOuputResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            const resBody: string = JSON.stringify(httpRes?.data, null, 0);
            const out: Uint8Array = new Uint8Array(resBody.length);
            for (let i = 0; i < resBody.length; i++)
              out[i] = resBody.charCodeAt(i);
            res.getLastPayDateReportOuput200ApplicationJSONBinaryString = out;
          }
          break;
        case [400, 401, 404, 500].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorModel = utils.objectToClass(
              httpRes?.data,
              shared.ErrorModel
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Runs the net pay report
   *
   * @remarks
   * Returns the result of the executed net pay report for the given query parameters
   */
  getNetPayReportOutput(
    req: operations.GetNetPayReportOutputRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetNetPayReportOutputResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetNetPayReportOutputRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/Report/NETPAY/run";

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      headers: headers,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetNetPayReportOutputResponse =
        new operations.GetNetPayReportOutputResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            const resBody: string = JSON.stringify(httpRes?.data, null, 0);
            const out: Uint8Array = new Uint8Array(resBody.length);
            for (let i = 0; i < resBody.length; i++)
              out[i] = resBody.charCodeAt(i);
            res.getNetPayReportOutput200ApplicationJSONBinaryString = out;
          }
          break;
        case [400, 401, 404, 500].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorModel = utils.objectToClass(
              httpRes?.data,
              shared.ErrorModel
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Runs the next pay period report
   *
   * @remarks
   * Returns the result of the executed next pay period report for the given query parameters
   */
  getNextPayPeriodDatesReportOutput(
    req: operations.GetNextPayPeriodDatesReportOutputRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetNextPayPeriodDatesReportOutputResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetNextPayPeriodDatesReportOutputRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/Report/NEXTPERIOD/run";

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      headers: headers,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetNextPayPeriodDatesReportOutputResponse =
        new operations.GetNextPayPeriodDatesReportOutputResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            const resBody: string = JSON.stringify(httpRes?.data, null, 0);
            const out: Uint8Array = new Uint8Array(resBody.length);
            for (let i = 0; i < resBody.length; i++)
              out[i] = resBody.charCodeAt(i);
            res.getNextPayPeriodDatesReportOutput200ApplicationJSONBinaryString =
              out;
          }
          break;
        case [400, 401, 404, 500].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorModel = utils.objectToClass(
              httpRes?.data,
              shared.ErrorModel
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Runs the P11 summary report
   *
   * @remarks
   * Returns the result of the executed P11 summary report for the given query parameters
   */
  getP11SummaryReportOutput(
    req: operations.GetP11SummaryReportOutputRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetP11SummaryReportOutputResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetP11SummaryReportOutputRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/Report/P11SUM/run";

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      headers: headers,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetP11SummaryReportOutputResponse =
        new operations.GetP11SummaryReportOutputResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            const resBody: string = JSON.stringify(httpRes?.data, null, 0);
            const out: Uint8Array = new Uint8Array(resBody.length);
            for (let i = 0; i < resBody.length; i++)
              out[i] = resBody.charCodeAt(i);
            res.getP11SummaryReportOutput200ApplicationJSONBinaryString = out;
          }
          break;
        case [400, 401, 404, 500].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorModel = utils.objectToClass(
              httpRes?.data,
              shared.ErrorModel
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Runs the P32 report
   *
   * @remarks
   * Returns the result of the executed P32 report for the given query parameters
   */
  getP32NetReportOutput(
    req: operations.GetP32NetReportOutputRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetP32NetReportOutputResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetP32NetReportOutputRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/Report/P32/run";

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      headers: headers,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetP32NetReportOutputResponse =
        new operations.GetP32NetReportOutputResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            const resBody: string = JSON.stringify(httpRes?.data, null, 0);
            const out: Uint8Array = new Uint8Array(resBody.length);
            for (let i = 0; i < resBody.length; i++)
              out[i] = resBody.charCodeAt(i);
            res.getP32NetReportOutput200ApplicationJSONBinaryString = out;
          }
          break;
        case [400, 401, 404, 500].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorModel = utils.objectToClass(
              httpRes?.data,
              shared.ErrorModel
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Runs the P32 summary report
   *
   * @remarks
   * Returns the result of the executed P32 summary report for the given query parameters
   */
  getP32SummaryNetReportOutput(
    req: operations.GetP32SummaryNetReportOutputRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetP32SummaryNetReportOutputResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetP32SummaryNetReportOutputRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/Report/P32SUM/run";

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      headers: headers,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetP32SummaryNetReportOutputResponse =
        new operations.GetP32SummaryNetReportOutputResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            const resBody: string = JSON.stringify(httpRes?.data, null, 0);
            const out: Uint8Array = new Uint8Array(resBody.length);
            for (let i = 0; i < resBody.length; i++)
              out[i] = resBody.charCodeAt(i);
            res.getP32SummaryNetReportOutput200ApplicationJSONBinaryString =
              out;
          }
          break;
        case [400, 401, 404, 500].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorModel = utils.objectToClass(
              httpRes?.data,
              shared.ErrorModel
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Runs the P45 report
   *
   * @remarks
   * Returns the result of the executed P45 report for the given query parameters
   */
  getP45ReportOutput(
    req: operations.GetP45ReportOutputRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetP45ReportOutputResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetP45ReportOutputRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/Report/P45/run";

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      headers: headers,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetP45ReportOutputResponse =
        new operations.GetP45ReportOutputResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            const resBody: string = JSON.stringify(httpRes?.data, null, 0);
            const out: Uint8Array = new Uint8Array(resBody.length);
            for (let i = 0; i < resBody.length; i++)
              out[i] = resBody.charCodeAt(i);
            res.getP45ReportOutput200ApplicationJSONBinaryString = out;
          }
          break;
        case [400, 401, 404, 500].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorModel = utils.objectToClass(
              httpRes?.data,
              shared.ErrorModel
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Runs the P60 report
   *
   * @remarks
   * Returns the result of the executed P60 report for the given query parameters
   */
  getP60ReportOutput(
    req: operations.GetP60ReportOutputRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetP60ReportOutputResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetP60ReportOutputRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/Report/P60/run";

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      headers: headers,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetP60ReportOutputResponse =
        new operations.GetP60ReportOutputResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            const resBody: string = JSON.stringify(httpRes?.data, null, 0);
            const out: Uint8Array = new Uint8Array(resBody.length);
            for (let i = 0; i < resBody.length; i++)
              out[i] = resBody.charCodeAt(i);
            res.getP60ReportOutput200ApplicationJSONBinaryString = out;
          }
          break;
        case [400, 401, 404, 500].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorModel = utils.objectToClass(
              httpRes?.data,
              shared.ErrorModel
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Runs the PAPDIS report
   *
   * @remarks
   * Returns the result of the executed PAPDIS report. PAPDIS is a free and open data interface standard designed to allow payroll and middleware software developers to create a file that can be used by pension providers to exchange data. http://www.papdis.org/
   */
  getPapdisReportOuput(
    req: operations.GetPapdisReportOuputRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetPapdisReportOuputResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetPapdisReportOuputRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/Report/PAPDIS/run";

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      headers: headers,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetPapdisReportOuputResponse =
        new operations.GetPapdisReportOuputResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            const resBody: string = JSON.stringify(httpRes?.data, null, 0);
            const out: Uint8Array = new Uint8Array(resBody.length);
            for (let i = 0; i < resBody.length; i++)
              out[i] = resBody.charCodeAt(i);
            res.getPapdisReportOuput200ApplicationJSONBinaryString = out;
          }
          break;
        case [400, 401, 404, 500].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorModel = utils.objectToClass(
              httpRes?.data,
              shared.ErrorModel
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Runs the PASS report
   *
   * @remarks
   * Returns the result of the executed PASS report. PASS stands for Payroll and Systemsync. PASS 1.1 is an extension of the PAPDIS V1.1 schema. https://pensionsynckb.systemsyncsolutions.com/display/PKB/PASS+1.1
   */
  getPassReportOuput(
    req: operations.GetPassReportOuputRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetPassReportOuputResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetPassReportOuputRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/Report/PASS/run";

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      headers: headers,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetPassReportOuputResponse =
        new operations.GetPassReportOuputResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            const resBody: string = JSON.stringify(httpRes?.data, null, 0);
            const out: Uint8Array = new Uint8Array(resBody.length);
            for (let i = 0; i < resBody.length; i++)
              out[i] = resBody.charCodeAt(i);
            res.getPassReportOuput200ApplicationJSONBinaryString = out;
          }
          break;
        case [400, 401, 404, 500].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorModel = utils.objectToClass(
              httpRes?.data,
              shared.ErrorModel
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Runs the Pay Dashboard payslips report
   *
   * @remarks
   * Returns the result of the executed Pay Dashboard payslip report for the given query parameters. See https://api.paydashboard.com for details. For compatability should be returned as JSON with TransformDefinitionKey=Json-Clean.
   */
  getPayDashboardPayslipReportOuput(
    req: operations.GetPayDashboardPayslipReportOuputRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetPayDashboardPayslipReportOuputResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetPayDashboardPayslipReportOuputRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/Report/PAYDASHBOARD/run";

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      headers: headers,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetPayDashboardPayslipReportOuputResponse =
        new operations.GetPayDashboardPayslipReportOuputResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            const resBody: string = JSON.stringify(httpRes?.data, null, 0);
            const out: Uint8Array = new Uint8Array(resBody.length);
            for (let i = 0; i < resBody.length; i++)
              out[i] = resBody.charCodeAt(i);
            res.getPayDashboardPayslipReportOuput200ApplicationJSONBinaryString =
              out;
          }
          break;
        case [400, 401, 404, 500].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorModel = utils.objectToClass(
              httpRes?.data,
              shared.ErrorModel
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Runs the verbose payslip report
   *
   * @remarks
   * Returns the result of the executed verbose payslip report for the given query parameters
   */
  getPayslip3ReportOutput(
    req: operations.GetPayslip3ReportOutputRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetPayslip3ReportOutputResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetPayslip3ReportOutputRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/Report/PAYSLIP3/run";

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      headers: headers,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetPayslip3ReportOutputResponse =
        new operations.GetPayslip3ReportOutputResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            const resBody: string = JSON.stringify(httpRes?.data, null, 0);
            const out: Uint8Array = new Uint8Array(resBody.length);
            for (let i = 0; i < resBody.length; i++)
              out[i] = resBody.charCodeAt(i);
            res.getPayslip3ReportOutput200ApplicationJSONBinaryString = out;
          }
          break;
        case [400, 401, 404, 500].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorModel = utils.objectToClass(
              httpRes?.data,
              shared.ErrorModel
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Runs the pension liability report
   *
   * @remarks
   * Returns the result of the executed pension liability report for the given query parameters
   */
  getPensionLiabilityReportOutput(
    req: operations.GetPensionLiabilityReportOutputRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetPensionLiabilityReportOutputResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetPensionLiabilityReportOutputRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/Report/PENLIABILITY/run";

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      headers: headers,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetPensionLiabilityReportOutputResponse =
        new operations.GetPensionLiabilityReportOutputResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            const resBody: string = JSON.stringify(httpRes?.data, null, 0);
            const out: Uint8Array = new Uint8Array(resBody.length);
            for (let i = 0; i < resBody.length; i++)
              out[i] = resBody.charCodeAt(i);
            res.getPensionLiabilityReportOutput200ApplicationJSONBinaryString =
              out;
          }
          break;
        case [400, 401, 404, 500].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorModel = utils.objectToClass(
              httpRes?.data,
              shared.ErrorModel
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Get the report definition
   *
   * @remarks
   * Returns the specified report definition from the authroised application
   */
  getReportDefinitionFromApplication(
    req: operations.GetReportDefinitionFromApplicationRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetReportDefinitionFromApplicationResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetReportDefinitionFromApplicationRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/Report/{ReportDefinitionId}",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };

    const r = client.request({
      url: url,
      method: "get",
      headers: headers,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetReportDefinitionFromApplicationResponse =
        new operations.GetReportDefinitionFromApplicationResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.reportDefinition = utils.objectToClass(
              httpRes?.data,
              shared.ReportDefinition
            );
          }
          break;
        case [400, 401, 404, 500].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorModel = utils.objectToClass(
              httpRes?.data,
              shared.ErrorModel
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Gets all reports
   *
   * @remarks
   * Get links to all saved report definitions under authorised application
   */
  getReportDefinitionsFromApplication(
    req: operations.GetReportDefinitionsFromApplicationRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetReportDefinitionsFromApplicationResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetReportDefinitionsFromApplicationRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/Reports";

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };

    const r = client.request({
      url: url,
      method: "get",
      headers: headers,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetReportDefinitionsFromApplicationResponse =
        new operations.GetReportDefinitionsFromApplicationResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.linkCollection = utils.objectToClass(
              httpRes?.data,
              shared.LinkCollection
            );
          }
          break;
        case [400, 401, 404, 500].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorModel = utils.objectToClass(
              httpRes?.data,
              shared.ErrorModel
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Runs the specified report definition
   *
   * @remarks
   * Returns the result of the executed report definition
   */
  getReportOutput(
    req: operations.GetReportOutputRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetReportOutputResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetReportOutputRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/Report/{ReportDefinitionId}/run",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };

    const r = client.request({
      url: url,
      method: "get",
      headers: headers,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetReportOutputResponse =
        new operations.GetReportOutputResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            const resBody: string = JSON.stringify(httpRes?.data, null, 0);
            const out: Uint8Array = new Uint8Array(resBody.length);
            for (let i = 0; i < resBody.length; i++)
              out[i] = resBody.charCodeAt(i);
            res.getReportOutput200ApplicationJSONBinaryString = out;
          }
          break;
        case [400, 401, 404, 500].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorModel = utils.objectToClass(
              httpRes?.data,
              shared.ErrorModel
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Get the transform definition
   *
   * @remarks
   * Returns the specified transform definition from the authroised application
   */
  getTransformDefinitionFromApplication(
    req: operations.GetTransformDefinitionFromApplicationRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetTransformDefinitionFromApplicationResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetTransformDefinitionFromApplicationRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/Transform/{TransformDefinitionId}",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };

    const r = client.request({
      url: url,
      method: "get",
      headers: headers,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetTransformDefinitionFromApplicationResponse =
        new operations.GetTransformDefinitionFromApplicationResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.transformDefinition = utils.objectToClass(
              httpRes?.data,
              shared.TransformDefinition
            );
          }
          break;
        case [400, 401, 404, 500].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorModel = utils.objectToClass(
              httpRes?.data,
              shared.ErrorModel
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Gets all transform definitions
   *
   * @remarks
   * Get links to all saved transform definitions under authorised application
   */
  getTransformDefinitionsFromApplication(
    req: operations.GetTransformDefinitionsFromApplicationRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetTransformDefinitionsFromApplicationResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetTransformDefinitionsFromApplicationRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/Transforms";

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };

    const r = client.request({
      url: url,
      method: "get",
      headers: headers,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetTransformDefinitionsFromApplicationResponse =
        new operations.GetTransformDefinitionsFromApplicationResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.linkCollection = utils.objectToClass(
              httpRes?.data,
              shared.LinkCollection
            );
          }
          break;
        case [400, 401, 404, 500].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorModel = utils.objectToClass(
              httpRes?.data,
              shared.ErrorModel
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Create a new report definition
   *
   * @remarks
   * Creates a new report defintion object
   */
  postReportDefinition(
    req: operations.PostReportDefinitionRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.PostReportDefinitionResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PostReportDefinitionRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/Reports";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "reportDefinition",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._defaultClient;

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PostReportDefinitionResponse =
        new operations.PostReportDefinitionResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.link = utils.objectToClass(httpRes?.data, shared.Link);
          }
          break;
        case [400, 401, 404, 500].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorModel = utils.objectToClass(
              httpRes?.data,
              shared.ErrorModel
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Create a new transform definition
   *
   * @remarks
   * Creates a new transform defintion object
   */
  postTransformDefinition(
    req: operations.PostTransformDefinitionRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.PostTransformDefinitionResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PostTransformDefinitionRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/Transforms";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "transformDefinition",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._defaultClient;

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PostTransformDefinitionResponse =
        new operations.PostTransformDefinitionResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.link = utils.objectToClass(httpRes?.data, shared.Link);
          }
          break;
        case [400, 401, 404, 500].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorModel = utils.objectToClass(
              httpRes?.data,
              shared.ErrorModel
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Updates a report definition
   *
   * @remarks
   * Updates the existing specified report definition object
   */
  putReportDefinition(
    req: operations.PutReportDefinitionRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.PutReportDefinitionResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PutReportDefinitionRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/Report/{ReportDefinitionId}",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "reportDefinition",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._defaultClient;

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "put",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PutReportDefinitionResponse =
        new operations.PutReportDefinitionResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.reportDefinition = utils.objectToClass(
              httpRes?.data,
              shared.ReportDefinition
            );
          }
          break;
        case [400, 401, 404, 500].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorModel = utils.objectToClass(
              httpRes?.data,
              shared.ErrorModel
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Updates a transform definition
   *
   * @remarks
   * Updates the existing specified transform definition object
   */
  putTransformDefinition(
    req: operations.PutTransformDefinitionRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.PutTransformDefinitionResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PutTransformDefinitionRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/Transform/{TransformDefinitionId}",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "transformDefinition",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._defaultClient;

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "put",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PutTransformDefinitionResponse =
        new operations.PutTransformDefinitionResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.transformDefinition = utils.objectToClass(
              httpRes?.data,
              shared.TransformDefinition
            );
          }
          break;
        case [400, 401, 404, 500].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorModel = utils.objectToClass(
              httpRes?.data,
              shared.ErrorModel
            );
          }
          break;
      }

      return res;
    });
  }
}
