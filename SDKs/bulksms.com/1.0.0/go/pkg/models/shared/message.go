// Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.

package shared

import (
	"encoding/json"
	"fmt"
	"time"
)

// MessageEncodingEnum - The type of the content.  See the `encoding` field for more information.
type MessageEncodingEnum string

const (
	MessageEncodingEnumText    MessageEncodingEnum = "TEXT"
	MessageEncodingEnumUnicode MessageEncodingEnum = "UNICODE"
	MessageEncodingEnumBinary  MessageEncodingEnum = "BINARY"
)

func (e *MessageEncodingEnum) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return err
	}
	switch s {
	case "TEXT":
		fallthrough
	case "UNICODE":
		fallthrough
	case "BINARY":
		*e = MessageEncodingEnum(s)
		return nil
	default:
		return fmt.Errorf("invalid value for MessageEncodingEnum: %s", s)
	}
}

// MessageStatusSubtypeEnum - Has a value only if the `type` is FAILED.
//
// EXPIRED  Delivery failed because message expired before delivery was possible.
//
// HANDSET_ERROR  Delivery failed because of a problem related to the phone (e.g. message storage area full).
//
// BLOCKED  Your account has been blocked from sending to this phone (e.g. recipient replied STOP to block communication).
//
// NOT_SENT  Message delivery was not attempted (e.g. because we were not able to find a route for the supplied phone number).
type MessageStatusSubtypeEnum string

const (
	MessageStatusSubtypeEnumExpired      MessageStatusSubtypeEnum = "EXPIRED"
	MessageStatusSubtypeEnumHandsetError MessageStatusSubtypeEnum = "HANDSET_ERROR"
	MessageStatusSubtypeEnumBlocked      MessageStatusSubtypeEnum = "BLOCKED"
	MessageStatusSubtypeEnumNotSent      MessageStatusSubtypeEnum = "NOT_SENT"
)

func (e *MessageStatusSubtypeEnum) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return err
	}
	switch s {
	case "EXPIRED":
		fallthrough
	case "HANDSET_ERROR":
		fallthrough
	case "BLOCKED":
		fallthrough
	case "NOT_SENT":
		*e = MessageStatusSubtypeEnum(s)
		return nil
	default:
		return fmt.Errorf("invalid value for MessageStatusSubtypeEnum: %s", s)
	}
}

// MessageStatusTypeEnum -
// ACCEPTED  Message accepted for delivery. Only returned for initial message submissions.
//
// SCHEDULED  Message accepted for delivery at a later date. Only returned for initial message  submissions.
//
// SENT  Message has been relayed away from our systems.
//
// DELIVERED  Successfully delivered to phone.
//
// UNKNOWN  Message is in an unknown state.
//
// FAILED  Delivery failed.
type MessageStatusTypeEnum string

const (
	MessageStatusTypeEnumAccepted  MessageStatusTypeEnum = "ACCEPTED"
	MessageStatusTypeEnumScheduled MessageStatusTypeEnum = "SCHEDULED"
	MessageStatusTypeEnumSent      MessageStatusTypeEnum = "SENT"
	MessageStatusTypeEnumDelivered MessageStatusTypeEnum = "DELIVERED"
	MessageStatusTypeEnumUnknown   MessageStatusTypeEnum = "UNKNOWN"
	MessageStatusTypeEnumFailed    MessageStatusTypeEnum = "FAILED"
)

func (e *MessageStatusTypeEnum) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return err
	}
	switch s {
	case "ACCEPTED":
		fallthrough
	case "SCHEDULED":
		fallthrough
	case "SENT":
		fallthrough
	case "DELIVERED":
		fallthrough
	case "UNKNOWN":
		fallthrough
	case "FAILED":
		*e = MessageStatusTypeEnum(s)
		return nil
	default:
		return fmt.Errorf("invalid value for MessageStatusTypeEnum: %s", s)
	}
}

// MessageStatus - The status of the message
type MessageStatus struct {
	// A concatenated value A.B where A is the `status.type` and B is the `status.subtype`.
	// It there is no value for `subtype` then B takes string value `"null"` (e.g. `"SENT.null"`).
	//
	ID string `json:"id"`
	// Has a value only if the `type` is FAILED.
	//
	// EXPIRED  Delivery failed because message expired before delivery was possible.
	//
	// HANDSET_ERROR  Delivery failed because of a problem related to the phone (e.g. message storage area full).
	//
	// BLOCKED  Your account has been blocked from sending to this phone (e.g. recipient replied STOP to block communication).
	//
	// NOT_SENT  Message delivery was not attempted (e.g. because we were not able to find a route for the supplied phone number).
	//
	Subtype *MessageStatusSubtypeEnum `json:"subtype,omitempty"`
	// ACCEPTED  Message accepted for delivery. Only returned for initial message submissions.
	//
	// SCHEDULED  Message accepted for delivery at a later date. Only returned for initial message  submissions.
	//
	// SENT  Message has been relayed away from our systems.
	//
	// DELIVERED  Successfully delivered to phone.
	//
	// UNKNOWN  Message is in an unknown state.
	//
	// FAILED  Delivery failed.
	//
	Type MessageStatusTypeEnum `json:"type"`
}

// MessageSubmission - Identifies the submission.
type MessageSubmission struct {
	// The date and time the submission was processed. If the `type` is RECEIVED, this field reflects the date and time the received message was processed.
	Date time.Time `json:"date"`
	// A unique identity shared by all messages that were created from the same submission. This field should be ignored if the `type` is not SENT.
	ID string `json:"id"`
}

// MessageTypeEnum - The message direction
type MessageTypeEnum string

const (
	MessageTypeEnumSent     MessageTypeEnum = "SENT"
	MessageTypeEnumReceived MessageTypeEnum = "RECEIVED"
)

func (e *MessageTypeEnum) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return err
	}
	switch s {
	case "SENT":
		fallthrough
	case "RECEIVED":
		*e = MessageTypeEnum(s)
		return nil
	default:
		return fmt.Errorf("invalid value for MessageTypeEnum: %s", s)
	}
}

// Message - The message detail
type Message struct {
	// The content of the message
	Body interface{} `json:"body"`
	// The cost of the message (in credits).   Note that this field does not have a value in the submission response.
	CreditCost *float32 `json:"creditCost,omitempty"`
	// The type of the content.  See the `encoding` field for more information.
	Encoding *MessageEncodingEnum `json:"encoding,omitempty"`
	// The address part of the sender id
	From *string `json:"from,omitempty"`
	// A unique identifier that is assigned when the message is created.
	ID string `json:"id"`
	// See the `messageClass` field for more information.
	MessageClass *int `json:"messageClass,omitempty"`
	// The number of parts.  If this is a concatenated message, the number of parts will be more than 1.  Note that this field does not have a value in the submission response.
	NumberOfParts *int `json:"numberOfParts,omitempty"`
	// See the `protocolId` field for more information.
	ProtocolID *int `json:"protocolId,omitempty"`
	// This field has a value only if the type is RECEIVED.
	// With SMS messages, it is not possible to link a reply directly with a specific sent message.  However, if you specified `REPLIABLE` in the `from` property, BulkSMS will link any reply to the most recent message sent to a given phone number.
	//
	// The `relatedSentMessageId` property keeps the information about this link.
	//
	// You can use this property to derive an implicit conversation from a set of messages.
	//   - If a received reply message has a `relatedSentMessageId`, you can use it to retrieve the last message that was sent before the reply was received.
	//   - If you have the `id` of the sent message and you want all the received messages that relate to it, you can use the List Related Messages Operation.
	//
	RelatedSentMessageID *string `json:"relatedSentMessageId,omitempty"`
	// The status of the message
	Status MessageStatus `json:"status"`
	// Identifies the submission.
	//
	Submission *MessageSubmission `json:"submission,omitempty"`
	// The phone number of the recipient
	To string `json:"to"`
	// The message direction
	Type MessageTypeEnum `json:"type"`
	// This is the value you supplied in the `userSuppliedId` field.
	// Has a value only if the `type` is SENT.
	//
	UserSuppliedID *string `json:"userSuppliedId,omitempty"`
}
