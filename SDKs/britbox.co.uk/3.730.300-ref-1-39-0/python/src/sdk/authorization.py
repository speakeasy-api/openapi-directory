"""Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT."""

import requests as requests_http
from . import utils
from sdk.models import operations, shared
from typing import Optional

class Authorization:
    _client: requests_http.Session
    _security_client: requests_http.Session
    _server_url: str
    _language: str
    _sdk_version: str
    _gen_version: str

    def __init__(self, client: requests_http.Session, security_client: requests_http.Session, server_url: str, language: str, sdk_version: str, gen_version: str) -> None:
        self._client = client
        self._security_client = security_client
        self._server_url = server_url
        self._language = language
        self._sdk_version = sdk_version
        self._gen_version = gen_version
        
    def generate_device_authorization_code(self, request: operations.GenerateDeviceAuthorizationCodeRequest) -> operations.GenerateDeviceAuthorizationCodeResponse:
        r"""Get a generated device authorization code.
        
        This is the first step in the process of authorizing a device by pin code.
        The device will make a request to this endpoint providing a unique identifier
        for the device such as a serial number. This endpoint will then return a
        generated code which is tied to the given device.
        
        The code may subsequently be used to authorize the device to sign in to an
        account via the `/account/devices/authorization` endpoint. Typically this
        will be from a page presented in the web app under the account section.
        
        Once authorized, the device will then be able to sign in to that account
        via the `/authorization/device` endpoint, without needing to provide the 
        credentials of the user.
        """
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/authorization/device/code'
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "device_registration_request", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        query_params = utils.get_query_params(operations.GenerateDeviceAuthorizationCodeRequest, request)
        
        client = self._client
        
        http_res = client.request('POST', url, params=query_params, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GenerateDeviceAuthorizationCodeResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.DeviceAuthorizationCode])
                res.device_authorization_code = out
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ServiceError])
                res.service_error = out

        return res

    def get_account_token(self, request: operations.GetAccountTokenRequest) -> operations.GetAccountTokenResponse:
        r"""Request one or more `Account` level authorization tokens each with a chosen scope.
        
        Tokens are used to access restricted service endpoints. These restricted endpoints
        will require a specific token type (e.g Account) with a specific scope (e.g. Catalog)
        before access is granted.
        
        For convenience, where a Profile level token with the same scope exists it will also be returned.
        
        Authorization with pin is not supported on this endpoint anymore. Use `/itv/pinauthorization`
        endpoint instead.
        """
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/authorization'
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "account_token_request", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        query_params = utils.get_query_params(operations.GetAccountTokenRequest, request)
        
        client = self._client
        
        http_res = client.request('POST', url, params=query_params, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetAccountTokenResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[list[shared.AccessToken]])
                res.access_tokens = out
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ServiceError])
                res.service_error = out

        return res

    def get_account_token_by_code(self, request: operations.GetAccountTokenByCodeRequest) -> operations.GetAccountTokenByCodeResponse:
        r"""Get Catalog tokens for an account using a device authorization code.
        Where a Profile level token of Catalog scope exists it will also be returned.
        
        This is the final step in the process of authorizing a device by pin code.
        
        Firstly the device must request a generated authorization code via the
        `/authorization/device/code` endpoint.
        
        The code is subsequently used to authorize the device to sign in to a given
        account via the `/account/devices/authorization` endpoint. Typically this
        will be from a page presented in the web app under the account section.
        
        Once authorized, this endpoint will allow the device to sign in without
        needing to provide the credentials of the user.
        """
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/authorization/device'
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "account_token_by_code_request", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        query_params = utils.get_query_params(operations.GetAccountTokenByCodeRequest, request)
        
        client = self._client
        
        http_res = client.request('POST', url, params=query_params, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetAccountTokenByCodeResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[list[shared.AccessToken]])
                res.access_tokens = out
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ServiceError])
                res.service_error = out

        return res

    def get_profile_token(self, request: operations.GetProfileTokenRequest, security: operations.GetProfileTokenSecurity) -> operations.GetProfileTokenResponse:
        r"""Request one or more `Profile` level authorization tokens each with a chosen scope.
        
        Tokens are used to access restricted service endpoints. These restriced endpoints
        will require a specific token type (e.g Profile) with a specific scope (e.g. Catalog)
        before access is granted.
        """
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/authorization/profile'
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "profile_token_request", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        query_params = utils.get_query_params(operations.GetProfileTokenRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, params=query_params, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetProfileTokenResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[list[shared.AccessToken]])
                res.access_tokens = out
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ServiceError])
                res.service_error = out

        return res

    def refresh_token(self, request: operations.RefreshTokenRequest) -> operations.RefreshTokenResponse:
        r"""Refresh an account or profile level authorization token which is marked as refreshable."""
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/authorization/refresh'
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "token_refresh_request", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        query_params = utils.get_query_params(operations.RefreshTokenRequest, request)
        
        client = self._client
        
        http_res = client.request('POST', url, params=query_params, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.RefreshTokenResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.AccessToken])
                res.access_token = out
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ServiceError])
                res.service_error = out

        return res

    def sign_out(self, request: operations.SignOutRequest) -> operations.SignOutResponse:
        r"""When a user signs out of an application we need to clear some
        basic cookies we assigned them during token authorization.
        """
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/authorization'
        
        query_params = utils.get_query_params(operations.SignOutRequest, request)
        
        client = self._client
        
        http_res = client.request('DELETE', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.SignOutResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 204:
            pass
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ServiceError])
                res.service_error = out

        return res

    def single_sign_on(self, request: operations.SingleSignOnRequest) -> operations.SingleSignOnResponse:
        r"""Exchange a third party single-sign-on token for our own authorization tokens."""
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/authorization/sso'
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "single_sign_on_request", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        query_params = utils.get_query_params(operations.SingleSignOnRequest, request)
        
        client = self._client
        
        http_res = client.request('POST', url, params=query_params, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.SingleSignOnResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[list[shared.AccessToken]])
                res.access_tokens = out
        elif http_res.status_code in [400, 401, 403, 404, 500]:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ServiceError])
                res.service_error = out

        return res

    