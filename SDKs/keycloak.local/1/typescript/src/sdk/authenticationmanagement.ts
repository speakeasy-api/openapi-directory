/*
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

import * as utils from "../internal/utils";
import * as operations from "./models/operations";
import * as shared from "./models/shared";
import { AxiosInstance, AxiosRequestConfig, AxiosResponse } from "axios";

export class AuthenticationManagement {
  _defaultClient: AxiosInstance;
  _securityClient: AxiosInstance;
  _serverURL: string;
  _language: string;
  _sdkVersion: string;
  _genVersion: string;

  constructor(
    defaultClient: AxiosInstance,
    securityClient: AxiosInstance,
    serverURL: string,
    language: string,
    sdkVersion: string,
    genVersion: string
  ) {
    this._defaultClient = defaultClient;
    this._securityClient = securityClient;
    this._serverURL = serverURL;
    this._language = language;
    this._sdkVersion = sdkVersion;
    this._genVersion = genVersion;
  }

  /**
   * Delete authenticator configuration
   */
  deleteRealmAuthenticationConfigId(
    req: operations.DeleteRealmAuthenticationConfigIdRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.DeleteRealmAuthenticationConfigIdResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DeleteRealmAuthenticationConfigIdRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/{realm}/authentication/config/{id}",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DeleteRealmAuthenticationConfigIdResponse =
        new operations.DeleteRealmAuthenticationConfigIdResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status >= 200 && httpRes?.status < 300:
          break;
      }

      return res;
    });
  }

  /**
   * Delete execution
   */
  deleteRealmAuthenticationExecutionsExecutionId(
    req: operations.DeleteRealmAuthenticationExecutionsExecutionIdRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.DeleteRealmAuthenticationExecutionsExecutionIdResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.DeleteRealmAuthenticationExecutionsExecutionIdRequest(
          req
        );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/{realm}/authentication/executions/{executionId}",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DeleteRealmAuthenticationExecutionsExecutionIdResponse =
        new operations.DeleteRealmAuthenticationExecutionsExecutionIdResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status >= 200 && httpRes?.status < 300:
          break;
      }

      return res;
    });
  }

  /**
   * Delete an authentication flow
   */
  deleteRealmAuthenticationFlowsId(
    req: operations.DeleteRealmAuthenticationFlowsIdRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.DeleteRealmAuthenticationFlowsIdResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DeleteRealmAuthenticationFlowsIdRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/{realm}/authentication/flows/{id}",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DeleteRealmAuthenticationFlowsIdResponse =
        new operations.DeleteRealmAuthenticationFlowsIdResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status >= 200 && httpRes?.status < 300:
          break;
      }

      return res;
    });
  }

  /**
   * Delete required action
   */
  deleteRealmAuthenticationRequiredActionsAlias(
    req: operations.DeleteRealmAuthenticationRequiredActionsAliasRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.DeleteRealmAuthenticationRequiredActionsAliasResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DeleteRealmAuthenticationRequiredActionsAliasRequest(
        req
      );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/{realm}/authentication/required-actions/{alias}",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DeleteRealmAuthenticationRequiredActionsAliasResponse =
        new operations.DeleteRealmAuthenticationRequiredActionsAliasResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status >= 200 && httpRes?.status < 300:
          break;
      }

      return res;
    });
  }

  /**
   * Get authenticator providers   Returns a list of authenticator providers.
   */
  getRealmAuthenticationAuthenticatorProviders(
    req: operations.GetRealmAuthenticationAuthenticatorProvidersRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetRealmAuthenticationAuthenticatorProvidersResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetRealmAuthenticationAuthenticatorProvidersRequest(
        req
      );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/{realm}/authentication/authenticator-providers",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetRealmAuthenticationAuthenticatorProvidersResponse =
        new operations.GetRealmAuthenticationAuthenticatorProvidersResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status >= 200 && httpRes?.status < 300:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getRealmAuthenticationAuthenticatorProviders2XXApplicationJSONObjects =
              utils.objectToClass(httpRes?.data);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Get client authenticator providers   Returns a list of client authenticator providers.
   */
  getRealmAuthenticationClientAuthenticatorProviders(
    req: operations.GetRealmAuthenticationClientAuthenticatorProvidersRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetRealmAuthenticationClientAuthenticatorProvidersResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.GetRealmAuthenticationClientAuthenticatorProvidersRequest(
          req
        );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/{realm}/authentication/client-authenticator-providers",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetRealmAuthenticationClientAuthenticatorProvidersResponse =
        new operations.GetRealmAuthenticationClientAuthenticatorProvidersResponse(
          {
            statusCode: httpRes.status,
            contentType: contentType,
            rawResponse: httpRes,
          }
        );
      switch (true) {
        case httpRes?.status >= 200 && httpRes?.status < 300:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getRealmAuthenticationClientAuthenticatorProviders2XXApplicationJSONObjects =
              utils.objectToClass(httpRes?.data);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Get authenticator provider’s configuration description
   */
  getRealmAuthenticationConfigDescriptionProviderId(
    req: operations.GetRealmAuthenticationConfigDescriptionProviderIdRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetRealmAuthenticationConfigDescriptionProviderIdResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.GetRealmAuthenticationConfigDescriptionProviderIdRequest(
          req
        );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/{realm}/authentication/config-description/{providerId}",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetRealmAuthenticationConfigDescriptionProviderIdResponse =
        new operations.GetRealmAuthenticationConfigDescriptionProviderIdResponse(
          {
            statusCode: httpRes.status,
            contentType: contentType,
            rawResponse: httpRes,
          }
        );
      switch (true) {
        case httpRes?.status >= 200 && httpRes?.status < 300:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.authenticatorConfigInfoRepresentation = utils.objectToClass(
              httpRes?.data,
              shared.AuthenticatorConfigInfoRepresentation
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Get authenticator configuration
   */
  getRealmAuthenticationConfigId(
    req: operations.GetRealmAuthenticationConfigIdRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetRealmAuthenticationConfigIdResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetRealmAuthenticationConfigIdRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/{realm}/authentication/config/{id}",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetRealmAuthenticationConfigIdResponse =
        new operations.GetRealmAuthenticationConfigIdResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status >= 200 && httpRes?.status < 300:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.authenticatorConfigRepresentation = utils.objectToClass(
              httpRes?.data,
              shared.AuthenticatorConfigRepresentation
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Get Single Execution
   */
  getRealmAuthenticationExecutionsExecutionId(
    req: operations.GetRealmAuthenticationExecutionsExecutionIdRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetRealmAuthenticationExecutionsExecutionIdResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetRealmAuthenticationExecutionsExecutionIdRequest(
        req
      );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/{realm}/authentication/executions/{executionId}",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetRealmAuthenticationExecutionsExecutionIdResponse =
        new operations.GetRealmAuthenticationExecutionsExecutionIdResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status >= 200 && httpRes?.status < 300:
          break;
      }

      return res;
    });
  }

  /**
   * Get authentication flows   Returns a list of authentication flows.
   */
  getRealmAuthenticationFlows(
    req: operations.GetRealmAuthenticationFlowsRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetRealmAuthenticationFlowsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetRealmAuthenticationFlowsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/{realm}/authentication/flows",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetRealmAuthenticationFlowsResponse =
        new operations.GetRealmAuthenticationFlowsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status >= 200 && httpRes?.status < 300:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.authenticationFlowRepresentations = [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.authenticationFlowRepresentations = utils.objectToClass(
              httpRes?.data,
              shared.AuthenticationFlowRepresentation,
              resFieldDepth
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Get authentication executions for a flow
   */
  getRealmAuthenticationFlowsFlowAliasExecutions(
    req: operations.GetRealmAuthenticationFlowsFlowAliasExecutionsRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetRealmAuthenticationFlowsFlowAliasExecutionsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.GetRealmAuthenticationFlowsFlowAliasExecutionsRequest(
          req
        );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/{realm}/authentication/flows/{flowAlias}/executions",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetRealmAuthenticationFlowsFlowAliasExecutionsResponse =
        new operations.GetRealmAuthenticationFlowsFlowAliasExecutionsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status >= 200 && httpRes?.status < 300:
          break;
      }

      return res;
    });
  }

  /**
   * Get authentication flow for id
   */
  getRealmAuthenticationFlowsId(
    req: operations.GetRealmAuthenticationFlowsIdRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetRealmAuthenticationFlowsIdResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetRealmAuthenticationFlowsIdRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/{realm}/authentication/flows/{id}",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetRealmAuthenticationFlowsIdResponse =
        new operations.GetRealmAuthenticationFlowsIdResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status >= 200 && httpRes?.status < 300:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.authenticationFlowRepresentation = utils.objectToClass(
              httpRes?.data,
              shared.AuthenticationFlowRepresentation
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Get form action providers   Returns a list of form action providers.
   */
  getRealmAuthenticationFormActionProviders(
    req: operations.GetRealmAuthenticationFormActionProvidersRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetRealmAuthenticationFormActionProvidersResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetRealmAuthenticationFormActionProvidersRequest(
        req
      );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/{realm}/authentication/form-action-providers",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetRealmAuthenticationFormActionProvidersResponse =
        new operations.GetRealmAuthenticationFormActionProvidersResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status >= 200 && httpRes?.status < 300:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getRealmAuthenticationFormActionProviders2XXApplicationJSONObjects =
              utils.objectToClass(httpRes?.data);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Get form providers   Returns a list of form providers.
   */
  getRealmAuthenticationFormProviders(
    req: operations.GetRealmAuthenticationFormProvidersRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetRealmAuthenticationFormProvidersResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetRealmAuthenticationFormProvidersRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/{realm}/authentication/form-providers",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetRealmAuthenticationFormProvidersResponse =
        new operations.GetRealmAuthenticationFormProvidersResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status >= 200 && httpRes?.status < 300:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getRealmAuthenticationFormProviders2XXApplicationJSONObjects =
              utils.objectToClass(httpRes?.data);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Get configuration descriptions for all clients
   */
  getRealmAuthenticationPerClientConfigDescription(
    req: operations.GetRealmAuthenticationPerClientConfigDescriptionRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetRealmAuthenticationPerClientConfigDescriptionResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.GetRealmAuthenticationPerClientConfigDescriptionRequest(
          req
        );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/{realm}/authentication/per-client-config-description",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetRealmAuthenticationPerClientConfigDescriptionResponse =
        new operations.GetRealmAuthenticationPerClientConfigDescriptionResponse(
          {
            statusCode: httpRes.status,
            contentType: contentType,
            rawResponse: httpRes,
          }
        );
      switch (true) {
        case httpRes?.status >= 200 && httpRes?.status < 300:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getRealmAuthenticationPerClientConfigDescription2XXApplicationJSONObject =
              utils.objectToClass(httpRes?.data);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Get required actions   Returns a list of required actions.
   */
  getRealmAuthenticationRequiredActions(
    req: operations.GetRealmAuthenticationRequiredActionsRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetRealmAuthenticationRequiredActionsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetRealmAuthenticationRequiredActionsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/{realm}/authentication/required-actions",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetRealmAuthenticationRequiredActionsResponse =
        new operations.GetRealmAuthenticationRequiredActionsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status >= 200 && httpRes?.status < 300:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.requiredActionProviderRepresentations = [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.requiredActionProviderRepresentations = utils.objectToClass(
              httpRes?.data,
              shared.RequiredActionProviderRepresentation,
              resFieldDepth
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Get required action for alias
   */
  getRealmAuthenticationRequiredActionsAlias(
    req: operations.GetRealmAuthenticationRequiredActionsAliasRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetRealmAuthenticationRequiredActionsAliasResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetRealmAuthenticationRequiredActionsAliasRequest(
        req
      );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/{realm}/authentication/required-actions/{alias}",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetRealmAuthenticationRequiredActionsAliasResponse =
        new operations.GetRealmAuthenticationRequiredActionsAliasResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status >= 200 && httpRes?.status < 300:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.requiredActionProviderRepresentation = utils.objectToClass(
              httpRes?.data,
              shared.RequiredActionProviderRepresentation
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Get unregistered required actions   Returns a list of unregistered required actions.
   */
  getRealmAuthenticationUnregisteredRequiredActions(
    req: operations.GetRealmAuthenticationUnregisteredRequiredActionsRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetRealmAuthenticationUnregisteredRequiredActionsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.GetRealmAuthenticationUnregisteredRequiredActionsRequest(
          req
        );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/{realm}/authentication/unregistered-required-actions",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetRealmAuthenticationUnregisteredRequiredActionsResponse =
        new operations.GetRealmAuthenticationUnregisteredRequiredActionsResponse(
          {
            statusCode: httpRes.status,
            contentType: contentType,
            rawResponse: httpRes,
          }
        );
      switch (true) {
        case httpRes?.status >= 200 && httpRes?.status < 300:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getRealmAuthenticationUnregisteredRequiredActions2XXApplicationJSONObjects =
              utils.objectToClass(httpRes?.data);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Add new authentication execution
   */
  postRealmAuthenticationExecutions(
    req: operations.PostRealmAuthenticationExecutionsRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.PostRealmAuthenticationExecutionsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PostRealmAuthenticationExecutionsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/{realm}/authentication/executions",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "authenticationExecutionRepresentation",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PostRealmAuthenticationExecutionsResponse =
        new operations.PostRealmAuthenticationExecutionsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status >= 200 && httpRes?.status < 300:
          break;
      }

      return res;
    });
  }

  /**
   * Update execution with new configuration
   */
  postRealmAuthenticationExecutionsExecutionIdConfig(
    req: operations.PostRealmAuthenticationExecutionsExecutionIdConfigRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.PostRealmAuthenticationExecutionsExecutionIdConfigResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.PostRealmAuthenticationExecutionsExecutionIdConfigRequest(
          req
        );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/{realm}/authentication/executions/{executionId}/config",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "authenticatorConfigRepresentation",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PostRealmAuthenticationExecutionsExecutionIdConfigResponse =
        new operations.PostRealmAuthenticationExecutionsExecutionIdConfigResponse(
          {
            statusCode: httpRes.status,
            contentType: contentType,
            rawResponse: httpRes,
          }
        );
      switch (true) {
        case httpRes?.status >= 200 && httpRes?.status < 300:
          break;
      }

      return res;
    });
  }

  /**
   * Lower execution’s priority
   */
  postRealmAuthenticationExecutionsExecutionIdLowerPriority(
    req: operations.PostRealmAuthenticationExecutionsExecutionIdLowerPriorityRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.PostRealmAuthenticationExecutionsExecutionIdLowerPriorityResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.PostRealmAuthenticationExecutionsExecutionIdLowerPriorityRequest(
          req
        );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/{realm}/authentication/executions/{executionId}/lower-priority",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "post",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PostRealmAuthenticationExecutionsExecutionIdLowerPriorityResponse =
        new operations.PostRealmAuthenticationExecutionsExecutionIdLowerPriorityResponse(
          {
            statusCode: httpRes.status,
            contentType: contentType,
            rawResponse: httpRes,
          }
        );
      switch (true) {
        case httpRes?.status >= 200 && httpRes?.status < 300:
          break;
      }

      return res;
    });
  }

  /**
   * Raise execution’s priority
   */
  postRealmAuthenticationExecutionsExecutionIdRaisePriority(
    req: operations.PostRealmAuthenticationExecutionsExecutionIdRaisePriorityRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.PostRealmAuthenticationExecutionsExecutionIdRaisePriorityResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.PostRealmAuthenticationExecutionsExecutionIdRaisePriorityRequest(
          req
        );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/{realm}/authentication/executions/{executionId}/raise-priority",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "post",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PostRealmAuthenticationExecutionsExecutionIdRaisePriorityResponse =
        new operations.PostRealmAuthenticationExecutionsExecutionIdRaisePriorityResponse(
          {
            statusCode: httpRes.status,
            contentType: contentType,
            rawResponse: httpRes,
          }
        );
      switch (true) {
        case httpRes?.status >= 200 && httpRes?.status < 300:
          break;
      }

      return res;
    });
  }

  /**
   * Create a new authentication flow
   */
  postRealmAuthenticationFlows(
    req: operations.PostRealmAuthenticationFlowsRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.PostRealmAuthenticationFlowsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PostRealmAuthenticationFlowsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/{realm}/authentication/flows",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "authenticationFlowRepresentation",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PostRealmAuthenticationFlowsResponse =
        new operations.PostRealmAuthenticationFlowsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status >= 200 && httpRes?.status < 300:
          break;
      }

      return res;
    });
  }

  /**
   * Copy existing authentication flow under a new name   The new name is given as 'newName' attribute of the passed JSON object
   */
  postRealmAuthenticationFlowsFlowAliasCopy(
    req: operations.PostRealmAuthenticationFlowsFlowAliasCopyRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.PostRealmAuthenticationFlowsFlowAliasCopyResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PostRealmAuthenticationFlowsFlowAliasCopyRequest(
        req
      );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/{realm}/authentication/flows/{flowAlias}/copy",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PostRealmAuthenticationFlowsFlowAliasCopyResponse =
        new operations.PostRealmAuthenticationFlowsFlowAliasCopyResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status >= 200 && httpRes?.status < 300:
          break;
      }

      return res;
    });
  }

  /**
   * Add new authentication execution to a flow
   */
  postRealmAuthenticationFlowsFlowAliasExecutionsExecution(
    req: operations.PostRealmAuthenticationFlowsFlowAliasExecutionsExecutionRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.PostRealmAuthenticationFlowsFlowAliasExecutionsExecutionResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.PostRealmAuthenticationFlowsFlowAliasExecutionsExecutionRequest(
          req
        );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/{realm}/authentication/flows/{flowAlias}/executions/execution",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PostRealmAuthenticationFlowsFlowAliasExecutionsExecutionResponse =
        new operations.PostRealmAuthenticationFlowsFlowAliasExecutionsExecutionResponse(
          {
            statusCode: httpRes.status,
            contentType: contentType,
            rawResponse: httpRes,
          }
        );
      switch (true) {
        case httpRes?.status >= 200 && httpRes?.status < 300:
          break;
      }

      return res;
    });
  }

  /**
   * Add new flow with new execution to existing flow
   */
  postRealmAuthenticationFlowsFlowAliasExecutionsFlow(
    req: operations.PostRealmAuthenticationFlowsFlowAliasExecutionsFlowRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.PostRealmAuthenticationFlowsFlowAliasExecutionsFlowResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.PostRealmAuthenticationFlowsFlowAliasExecutionsFlowRequest(
          req
        );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/{realm}/authentication/flows/{flowAlias}/executions/flow",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PostRealmAuthenticationFlowsFlowAliasExecutionsFlowResponse =
        new operations.PostRealmAuthenticationFlowsFlowAliasExecutionsFlowResponse(
          {
            statusCode: httpRes.status,
            contentType: contentType,
            rawResponse: httpRes,
          }
        );
      switch (true) {
        case httpRes?.status >= 200 && httpRes?.status < 300:
          break;
      }

      return res;
    });
  }

  /**
   * Register a new required actions
   */
  postRealmAuthenticationRegisterRequiredAction(
    req: operations.PostRealmAuthenticationRegisterRequiredActionRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.PostRealmAuthenticationRegisterRequiredActionResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PostRealmAuthenticationRegisterRequiredActionRequest(
        req
      );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/{realm}/authentication/register-required-action",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PostRealmAuthenticationRegisterRequiredActionResponse =
        new operations.PostRealmAuthenticationRegisterRequiredActionResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status >= 200 && httpRes?.status < 300:
          break;
      }

      return res;
    });
  }

  /**
   * Lower required action’s priority
   */
  postRealmAuthenticationRequiredActionsAliasLowerPriority(
    req: operations.PostRealmAuthenticationRequiredActionsAliasLowerPriorityRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.PostRealmAuthenticationRequiredActionsAliasLowerPriorityResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.PostRealmAuthenticationRequiredActionsAliasLowerPriorityRequest(
          req
        );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/{realm}/authentication/required-actions/{alias}/lower-priority",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "post",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PostRealmAuthenticationRequiredActionsAliasLowerPriorityResponse =
        new operations.PostRealmAuthenticationRequiredActionsAliasLowerPriorityResponse(
          {
            statusCode: httpRes.status,
            contentType: contentType,
            rawResponse: httpRes,
          }
        );
      switch (true) {
        case httpRes?.status >= 200 && httpRes?.status < 300:
          break;
      }

      return res;
    });
  }

  /**
   * Raise required action’s priority
   */
  postRealmAuthenticationRequiredActionsAliasRaisePriority(
    req: operations.PostRealmAuthenticationRequiredActionsAliasRaisePriorityRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.PostRealmAuthenticationRequiredActionsAliasRaisePriorityResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.PostRealmAuthenticationRequiredActionsAliasRaisePriorityRequest(
          req
        );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/{realm}/authentication/required-actions/{alias}/raise-priority",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "post",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PostRealmAuthenticationRequiredActionsAliasRaisePriorityResponse =
        new operations.PostRealmAuthenticationRequiredActionsAliasRaisePriorityResponse(
          {
            statusCode: httpRes.status,
            contentType: contentType,
            rawResponse: httpRes,
          }
        );
      switch (true) {
        case httpRes?.status >= 200 && httpRes?.status < 300:
          break;
      }

      return res;
    });
  }

  /**
   * Update authenticator configuration
   */
  putRealmAuthenticationConfigId(
    req: operations.PutRealmAuthenticationConfigIdRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.PutRealmAuthenticationConfigIdResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PutRealmAuthenticationConfigIdRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/{realm}/authentication/config/{id}",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "authenticatorConfigRepresentation",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "put",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PutRealmAuthenticationConfigIdResponse =
        new operations.PutRealmAuthenticationConfigIdResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status >= 200 && httpRes?.status < 300:
          break;
      }

      return res;
    });
  }

  /**
   * Update authentication executions of a flow
   */
  putRealmAuthenticationFlowsFlowAliasExecutions(
    req: operations.PutRealmAuthenticationFlowsFlowAliasExecutionsRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.PutRealmAuthenticationFlowsFlowAliasExecutionsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.PutRealmAuthenticationFlowsFlowAliasExecutionsRequest(
          req
        );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/{realm}/authentication/flows/{flowAlias}/executions",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "authenticationExecutionInfoRepresentation",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "put",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PutRealmAuthenticationFlowsFlowAliasExecutionsResponse =
        new operations.PutRealmAuthenticationFlowsFlowAliasExecutionsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status >= 200 && httpRes?.status < 300:
          break;
      }

      return res;
    });
  }

  /**
   * Update an authentication flow
   */
  putRealmAuthenticationFlowsId(
    req: operations.PutRealmAuthenticationFlowsIdRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.PutRealmAuthenticationFlowsIdResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PutRealmAuthenticationFlowsIdRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/{realm}/authentication/flows/{id}",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "authenticationFlowRepresentation",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "put",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PutRealmAuthenticationFlowsIdResponse =
        new operations.PutRealmAuthenticationFlowsIdResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status >= 200 && httpRes?.status < 300:
          break;
      }

      return res;
    });
  }

  /**
   * Update required action
   */
  putRealmAuthenticationRequiredActionsAlias(
    req: operations.PutRealmAuthenticationRequiredActionsAliasRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.PutRealmAuthenticationRequiredActionsAliasResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PutRealmAuthenticationRequiredActionsAliasRequest(
        req
      );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/{realm}/authentication/required-actions/{alias}",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requiredActionProviderRepresentation",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "put",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PutRealmAuthenticationRequiredActionsAliasResponse =
        new operations.PutRealmAuthenticationRequiredActionsAliasResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status >= 200 && httpRes?.status < 300:
          break;
      }

      return res;
    });
  }
}
