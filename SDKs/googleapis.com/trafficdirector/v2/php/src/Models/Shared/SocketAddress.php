<?php

/**
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

declare(strict_types=1);

namespace OpenAPI\OpenAPI\Models\Shared;


/**
 * SocketAddress - [#next-free-field: 7]
 * 
 * @package OpenAPI\OpenAPI\Models\Shared
 * @access public
 */
class SocketAddress
{
    /**
     * The address for this socket. :ref:`Listeners ` will bind to the address. An empty address is not allowed. Specify ``0.0.0.0`` or ``::`` to bind to any address. [#comment:TODO(zuercher) reinstate when implemented: It is possible to distinguish a Listener address via the prefix/suffix matching in :ref:`FilterChainMatch `.] When used within an upstream :ref:`BindConfig `, the address controls the source address of outbound connections. For :ref:`clusters `, the cluster type determines whether the address must be an IP (*STATIC* or *EDS* clusters) or a hostname resolved by DNS (*STRICT_DNS* or *LOGICAL_DNS* clusters). Address resolution can be customized via :ref:`resolver_name `.
     * 
     * @var ?string $address
     */
	#[\JMS\Serializer\Annotation\SerializedName('address')]
    #[\JMS\Serializer\Annotation\Type('string')]
    #[\JMS\Serializer\Annotation\SkipWhenEmpty]
    public ?string $address = null;
    
    /**
     * When binding to an IPv6 address above, this enables `IPv4 compatibility `_. Binding to ``::`` will allow both IPv4 and IPv6 connections, with peer IPv4 addresses mapped into IPv6 space as ``::FFFF:``.
     * 
     * @var ?bool $ipv4Compat
     */
	#[\JMS\Serializer\Annotation\SerializedName('ipv4Compat')]
    #[\JMS\Serializer\Annotation\Type('bool')]
    #[\JMS\Serializer\Annotation\SkipWhenEmpty]
    public ?bool $ipv4Compat = null;
    
    /**
     * This is only valid if :ref:`resolver_name ` is specified below and the named resolver is capable of named port resolution.
     * 
     * @var ?string $namedPort
     */
	#[\JMS\Serializer\Annotation\SerializedName('namedPort')]
    #[\JMS\Serializer\Annotation\Type('string')]
    #[\JMS\Serializer\Annotation\SkipWhenEmpty]
    public ?string $namedPort = null;
    
	#[\JMS\Serializer\Annotation\SerializedName('portValue')]
    #[\JMS\Serializer\Annotation\Type('int')]
    #[\JMS\Serializer\Annotation\SkipWhenEmpty]
    public ?int $portValue = null;
    
	#[\JMS\Serializer\Annotation\SerializedName('protocol')]
    #[\JMS\Serializer\Annotation\Type('enum<OpenAPI\OpenAPI\Models\Shared\SocketAddressProtocolEnum>')]
    #[\JMS\Serializer\Annotation\SkipWhenEmpty]
    public ?SocketAddressProtocolEnum $protocol = null;
    
    /**
     * The name of the custom resolver. This must have been registered with Envoy. If this is empty, a context dependent default applies. If the address is a concrete IP address, no resolution will occur. If address is a hostname this should be set for resolution other than DNS. Specifying a custom resolver with *STRICT_DNS* or *LOGICAL_DNS* will generate an error at runtime.
     * 
     * @var ?string $resolverName
     */
	#[\JMS\Serializer\Annotation\SerializedName('resolverName')]
    #[\JMS\Serializer\Annotation\Type('string')]
    #[\JMS\Serializer\Annotation\SkipWhenEmpty]
    public ?string $resolverName = null;
    
	public function __construct()
	{
		$this->address = null;
		$this->ipv4Compat = null;
		$this->namedPort = null;
		$this->portValue = null;
		$this->protocol = null;
		$this->resolverName = null;
	}
}
