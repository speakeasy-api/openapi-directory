"""Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT."""

from __future__ import annotations
import dataclasses
from ..shared import updatecustomobjectcusotmfield as shared_updatecustomobjectcusotmfield
from dataclasses_json import Undefined, dataclass_json
from enum import Enum
from sdk import utils
from typing import Optional

class CustomObjectDefinitionUpdateActionRequestRelationshipCardinalityEnum(str, Enum):
    r"""The cardinality of the relationship from this object to another object.
    
    Only the `manyToOne` cardinality can be used when creating relationships.  A relationship with `oneToMany` cardinality is created implicitly when a `manyToOne` relationship is created.
    
    A custom object definition can have a maximum of 2 `manyToOne` relationships.
    """
    MANY_TO_ONE = 'manyToOne'


@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class CustomObjectDefinitionUpdateActionRequestRelationshipRecordConstraintsCreate:
    
    enforce_valid_mapping: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('enforceValidMapping'), 'exclude': lambda f: f is None }})
    r"""Specifies whether Zuora validates the values of mapped fields
    in custom object records.
    
    By default, Zuora validates the values of mapped fields
    in custom object records. For example, if the
    custom object definition has a field called `AccountId__c`
    that is mapped to the `Id` field of the `account` object,
    Zuora verifies that the value of `AccountId__c` is a valid
    account ID when a custom object record is created.
    If the value of `AccountId__c` is not a valid account ID,
    the operation fails.
    """  
    

@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class CustomObjectDefinitionUpdateActionRequestRelationshipRecordConstraints:
    r"""Specifies contraints to apply to custom object records."""
    
    create: Optional[CustomObjectDefinitionUpdateActionRequestRelationshipRecordConstraintsCreate] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('create'), 'exclude': lambda f: f is None }})  
    

@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class CustomObjectDefinitionUpdateActionRequestRelationship:
    
    fields_: dict[str, str] = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('fields') }})
    r"""Field mappings in the form of `<this-object-field-name>`: `<other-object-field-name>`."""  
    namespace: str = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('namespace') }})
    r"""The namespace where the related object is located"""  
    object: str = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('object') }})
    r"""The API name of the related object"""  
    cardinality: Optional[CustomObjectDefinitionUpdateActionRequestRelationshipCardinalityEnum] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('cardinality'), 'exclude': lambda f: f is None }})
    r"""The cardinality of the relationship from this object to another object.
    
    Only the `manyToOne` cardinality can be used when creating relationships.  A relationship with `oneToMany` cardinality is created implicitly when a `manyToOne` relationship is created.
    
    A custom object definition can have a maximum of 2 `manyToOne` relationships.
    """  
    record_constraints: Optional[CustomObjectDefinitionUpdateActionRequestRelationshipRecordConstraints] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('recordConstraints'), 'exclude': lambda f: f is None }})
    r"""Specifies contraints to apply to custom object records."""  
    
class CustomObjectDefinitionUpdateActionRequestTypeEnum(str, Enum):
    r"""The type of the updating action on a custom object definition"""
    ADD_FIELD = 'addField'
    DELETE_FIELD = 'deleteField'
    UPDATE_FIELD = 'updateField'
    UPDATE_OBJECT = 'updateObject'
    RENAME_FIELD = 'renameField'
    ADD_RELATIONSHIP = 'addRelationship'
    DELETE_RELATIONSHIP = 'deleteRelationship'


@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class CustomObjectDefinitionUpdateActionRequest:
    
    namespace: str = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('namespace') }})
    r"""The namespace of the custom object definition to be updated"""  
    object: str = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('object') }})
    r"""The API name of the custom object definition to be updated"""  
    type: CustomObjectDefinitionUpdateActionRequestTypeEnum = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('type') }})
    r"""The type of the updating action on a custom object definition"""  
    description: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('description'), 'exclude': lambda f: f is None }})
    r"""Optional property for `updateObject` action"""  
    field: Optional[shared_updatecustomobjectcusotmfield.UpdateCustomObjectCusotmField] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('field'), 'exclude': lambda f: f is None }})
    r"""A reference to a field."""  
    label: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('label'), 'exclude': lambda f: f is None }})
    r"""Optional property for `updateObject` action"""  
    relationship: Optional[CustomObjectDefinitionUpdateActionRequestRelationship] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('relationship'), 'exclude': lambda f: f is None }})  
    