<?php

/**
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

declare(strict_types=1);

namespace OpenAPI\OpenAPI;

class RootFileset 
{

	// SDK private variables namespaced with _ to avoid conflicts with API models
	private \GuzzleHttp\ClientInterface $_defaultClient;
	private \GuzzleHttp\ClientInterface $_securityClient;
	private string $_serverUrl;
	private string $_language;
	private string $_sdkVersion;
	private string $_genVersion;	

	/**
	 * @param \GuzzleHttp\ClientInterface $defaultClient
	 * @param \GuzzleHttp\ClientInterface $securityClient
	 * @param string $serverUrl
	 * @param string $language
	 * @param string $sdkVersion
	 * @param string $genVersion
	 */
	public function __construct(\GuzzleHttp\ClientInterface $defaultClient, \GuzzleHttp\ClientInterface $securityClient, string $serverUrl, string $language, string $sdkVersion, string $genVersion)
	{
		$this->_defaultClient = $defaultClient;
		$this->_securityClient = $securityClient;
		$this->_serverUrl = $serverUrl;
		$this->_language = $language;
		$this->_sdkVersion = $sdkVersion;
		$this->_genVersion = $genVersion;
	}
	
    /**
     * Lists all files and directories in a given path
     * 
     * Lists all files and directories in a given path.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\BrowseFilesetSnapshotRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\BrowseFilesetSnapshotResponse
     */
	public function browseFilesetSnapshot(
        \OpenAPI\OpenAPI\Models\Operations\BrowseFilesetSnapshotRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\BrowseFilesetSnapshotResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/fileset/snapshot/{id}/browse', \OpenAPI\OpenAPI\Models\Operations\BrowseFilesetSnapshotRequest::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\BrowseFilesetSnapshotRequest::class, $request, null));
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\BrowseFilesetSnapshotResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->browseResponseListResponse = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\BrowseResponseListResponse', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Create a download fileset snapshot from archival request
     * 
     * Create a download fileset snapshot from archival request.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\CreateDownloadFilesetSnapshotFromCloudRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\CreateDownloadFilesetSnapshotFromCloudResponse
     */
	public function createDownloadFilesetSnapshotFromCloud(
        \OpenAPI\OpenAPI\Models\Operations\CreateDownloadFilesetSnapshotFromCloudRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\CreateDownloadFilesetSnapshotFromCloudResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/fileset/snapshot/{id}/download', \OpenAPI\OpenAPI\Models\Operations\CreateDownloadFilesetSnapshotFromCloudRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_securityClient->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\CreateDownloadFilesetSnapshotFromCloudResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 202) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->asyncRequestStatus = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\AsyncRequestStatus', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Create one fileset for a host
     * 
     * Create a fileset for a network host. A fileset is a fileset template applied to a host.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\CreateFilesetRequestBody $request
     * @return \OpenAPI\OpenAPI\Models\Operations\CreateFilesetResponse
     */
	public function createFileset(
        \OpenAPI\OpenAPI\Models\Operations\CreateFilesetRequestBody $request,
    ): \OpenAPI\OpenAPI\Models\Operations\CreateFilesetResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/fileset');
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "request", "json");
        if ($body === null) {
            throw new \Exception('Request body is required');
        }
        $options = array_merge_recursive($options, $body);
        
        $httpResponse = $this->_securityClient->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\CreateFilesetResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 201) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->filesetDetail = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\FilesetDetail', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Initiate an on-demand backup for a fileset
     * 
     * Create an on-demand backup request for the given fileset.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\CreateFilesetBackupJobRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\CreateFilesetBackupJobResponse
     */
	public function createFilesetBackupJob(
        \OpenAPI\OpenAPI\Models\Operations\CreateFilesetBackupJobRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\CreateFilesetBackupJobResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/fileset/{id}/snapshot', \OpenAPI\OpenAPI\Models\Operations\CreateFilesetBackupJobRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "baseOnDemandSnapshotConfig", "json");
        $options = array_merge_recursive($options, $body);
        
        $httpResponse = $this->_securityClient->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\CreateFilesetBackupJobResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 202) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->asyncRequestStatus = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\AsyncRequestStatus', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Create a file download job from a fileset backup
     * 
     * Initiate a job to download a file from a backup of a fileset. Returns a job instance ID.
     * An email notification will be sent out when the download is ready. When the download is ready, the file can be downloaded from the corresponding event which includes the job instance ID as the value of **jobInstanceId**.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\CreateFilesetDownloadFileJobRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\CreateFilesetDownloadFileJobResponse
     */
	public function createFilesetDownloadFileJob(
        \OpenAPI\OpenAPI\Models\Operations\CreateFilesetDownloadFileJobRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\CreateFilesetDownloadFileJobResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/fileset/snapshot/{id}/download_file', \OpenAPI\OpenAPI\Models\Operations\CreateFilesetDownloadFileJobRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "filesetDownloadFileJobConfig", "json");
        if ($body === null) {
            throw new \Exception('Request body is required');
        }
        $options = array_merge_recursive($options, $body);
        
        $httpResponse = $this->_securityClient->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\CreateFilesetDownloadFileJobResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 202) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->asyncRequestStatus = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\AsyncRequestStatus', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Create export job
     * 
     * Initiate a job to copy a file or folder from a fileset backup to a destination host other than the source host. Returns the job instance ID.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\CreateFilesetExportFileJobRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\CreateFilesetExportFileJobResponse
     */
	public function createFilesetExportFileJob(
        \OpenAPI\OpenAPI\Models\Operations\CreateFilesetExportFileJobRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\CreateFilesetExportFileJobResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/fileset/snapshot/{id}/export_file', \OpenAPI\OpenAPI\Models\Operations\CreateFilesetExportFileJobRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "filesetExportFileJobConfig", "json");
        if ($body === null) {
            throw new \Exception('Request body is required');
        }
        $options = array_merge_recursive($options, $body);
        
        $httpResponse = $this->_securityClient->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\CreateFilesetExportFileJobResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 202) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->asyncRequestStatus = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\AsyncRequestStatus', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Create restore job
     * 
     * Initiate a job to copy a file or folder from a fileset backup to the source host. Returns the job instance ID.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\CreateFilesetRestoreFileJobRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\CreateFilesetRestoreFileJobResponse
     */
	public function createFilesetRestoreFileJob(
        \OpenAPI\OpenAPI\Models\Operations\CreateFilesetRestoreFileJobRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\CreateFilesetRestoreFileJobResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/fileset/snapshot/{id}/restore_file', \OpenAPI\OpenAPI\Models\Operations\CreateFilesetRestoreFileJobRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "filesetRestoreFileJobConfig", "json");
        if ($body === null) {
            throw new \Exception('Request body is required');
        }
        $options = array_merge_recursive($options, $body);
        
        $httpResponse = $this->_securityClient->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\CreateFilesetRestoreFileJobResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 202) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->asyncRequestStatus = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\AsyncRequestStatus', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Delete a fileset
     * 
     * Delete a fileset by specifying the fileset ID.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\DeleteFilesetRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\DeleteFilesetResponse
     */
	public function deleteFileset(
        \OpenAPI\OpenAPI\Models\Operations\DeleteFilesetRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\DeleteFilesetResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/fileset/{id}', \OpenAPI\OpenAPI\Models\Operations\DeleteFilesetRequest::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\DeleteFilesetRequest::class, $request, null));
        
        $httpResponse = $this->_securityClient->request('DELETE', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\DeleteFilesetResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 204 or $httpResponse->getStatusCode() === 404) {
        }

        return $response;
    }
	
    /**
     * Delete a fileset snapshot
     * 
     * Delete a fileset snapshot. A snapshot is deleted only if it is an on-demand snapshot, a snapshot of an unprotected fileset or a local snapshot that was downloaded from an archive location.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\DeleteFilesetSnapshotRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\DeleteFilesetSnapshotResponse
     */
	public function deleteFilesetSnapshot(
        \OpenAPI\OpenAPI\Models\Operations\DeleteFilesetSnapshotRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\DeleteFilesetSnapshotResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/fileset/snapshot/{id}', \OpenAPI\OpenAPI\Models\Operations\DeleteFilesetSnapshotRequest::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\DeleteFilesetSnapshotRequest::class, $request, null));
        
        $httpResponse = $this->_securityClient->request('DELETE', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\DeleteFilesetSnapshotResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 204) {
        }

        return $response;
    }
	
    /**
     * Delete all snapshots of a fileset
     * 
     * Delete all snapshots that were created based on a fileset by providing the fileset ID.
     * Requires an unprotected fileset. Remove the fileset from all SLA Domains.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\DeleteFilesetSnapshotsRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\DeleteFilesetSnapshotsResponse
     */
	public function deleteFilesetSnapshots(
        \OpenAPI\OpenAPI\Models\Operations\DeleteFilesetSnapshotsRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\DeleteFilesetSnapshotsResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/fileset/{id}/snapshot', \OpenAPI\OpenAPI\Models\Operations\DeleteFilesetSnapshotsRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_securityClient->request('DELETE', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\DeleteFilesetSnapshotsResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 204) {
        }

        return $response;
    }
	
    /**
     * Get information for a single fileset
     * 
     * Retrieve summary information for a fileset by specifying the fileset ID.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetFilesetRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\GetFilesetResponse
     */
	public function getFileset(
        \OpenAPI\OpenAPI\Models\Operations\GetFilesetRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\GetFilesetResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/fileset/{id}', \OpenAPI\OpenAPI\Models\Operations\GetFilesetRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetFilesetResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->filesetDetail = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\FilesetDetail', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Get details about an async request
     * 
     * Get details about a fileset related async request.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetFilesetAsyncRequestStatusRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\GetFilesetAsyncRequestStatusResponse
     */
	public function getFilesetAsyncRequestStatus(
        \OpenAPI\OpenAPI\Models\Operations\GetFilesetAsyncRequestStatusRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\GetFilesetAsyncRequestStatusResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/fileset/request/{id}', \OpenAPI\OpenAPI\Models\Operations\GetFilesetAsyncRequestStatusRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetFilesetAsyncRequestStatusResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->asyncRequestStatus = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\AsyncRequestStatus', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Get information for a fileset snapshot
     * 
     * Retrieve summary information for a fileset snapshot by specifying the snapshot ID.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetFilesetSnapshotRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\GetFilesetSnapshotResponse
     */
	public function getFilesetSnapshot(
        \OpenAPI\OpenAPI\Models\Operations\GetFilesetSnapshotRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\GetFilesetSnapshotResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/fileset/snapshot/{id}', \OpenAPI\OpenAPI\Models\Operations\GetFilesetSnapshotRequest::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\GetFilesetSnapshotRequest::class, $request, null));
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetFilesetSnapshotResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->filesetSnapshotDetail = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\FilesetSnapshotDetail', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Get missed snapshots for a fileset
     * 
     * Retrieve summary information about all missed snapshots for a fileset.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetMissedFilesetSnapshotsRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\GetMissedFilesetSnapshotsResponse
     */
	public function getMissedFilesetSnapshots(
        \OpenAPI\OpenAPI\Models\Operations\GetMissedFilesetSnapshotsRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\GetMissedFilesetSnapshotsResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/fileset/{id}/missed_snapshot', \OpenAPI\OpenAPI\Models\Operations\GetMissedFilesetSnapshotsRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetMissedFilesetSnapshotsResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->missedSnapshotListResponse = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\MissedSnapshotListResponse', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Get summary information for all filesets
     * 
     * Retrieve summary information for each fileset. Optionally, filter the retrieved information.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\QueryFilesetRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\QueryFilesetResponse
     */
	public function queryFileset(
        \OpenAPI\OpenAPI\Models\Operations\QueryFilesetRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\QueryFilesetResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/fileset');
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\QueryFilesetRequest::class, $request, null));
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\QueryFilesetResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->filesetSummaryListResponse = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\FilesetSummaryListResponse', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Search for a file within the fileset
     * 
     * Search for a file within the fileset. Search via full path prefix or filename prefix.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\SearchFilesetRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\SearchFilesetResponse
     */
	public function searchFileset(
        \OpenAPI\OpenAPI\Models\Operations\SearchFilesetRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\SearchFilesetResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/fileset/{id}/search', \OpenAPI\OpenAPI\Models\Operations\SearchFilesetRequest::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\SearchFilesetRequest::class, $request, null));
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\SearchFilesetResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->searchResponseListResponse = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\SearchResponseListResponse', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Update a Fileset
     * 
     * Update a Fileset with the specified properties.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\UpdateFilesetRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\UpdateFilesetResponse
     */
	public function updateFileset(
        \OpenAPI\OpenAPI\Models\Operations\UpdateFilesetRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\UpdateFilesetResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/fileset/{id}', \OpenAPI\OpenAPI\Models\Operations\UpdateFilesetRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "filesetUpdate", "json");
        if ($body === null) {
            throw new \Exception('Request body is required');
        }
        $options = array_merge_recursive($options, $body);
        
        $httpResponse = $this->_securityClient->request('PATCH', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\UpdateFilesetResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->filesetDetail = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\FilesetDetail', 'json');
            }
        }

        return $response;
    }
}