"""Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT."""

from __future__ import annotations
import dataclasses
from ..shared import clonedefinition as shared_clonedefinition
from ..shared import clustering as shared_clustering
from ..shared import encryptionconfiguration as shared_encryptionconfiguration
from ..shared import externaldataconfiguration as shared_externaldataconfiguration
from ..shared import materializedviewdefinition as shared_materializedviewdefinition
from ..shared import modeldefinition as shared_modeldefinition
from ..shared import rangepartitioning as shared_rangepartitioning
from ..shared import snapshotdefinition as shared_snapshotdefinition
from ..shared import streamingbuffer as shared_streamingbuffer
from ..shared import tablereference as shared_tablereference
from ..shared import tableschema as shared_tableschema
from ..shared import timepartitioning as shared_timepartitioning
from ..shared import viewdefinition as shared_viewdefinition
from dataclasses_json import Undefined, dataclass_json
from sdk import utils
from typing import Optional


@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class Table:
    r"""Successful response"""
    
    clone_definition: Optional[shared_clonedefinition.CloneDefinition] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('cloneDefinition'), 'exclude': lambda f: f is None }})  
    clustering: Optional[shared_clustering.Clustering] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('clustering'), 'exclude': lambda f: f is None }})  
    creation_time: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('creationTime'), 'exclude': lambda f: f is None }})
    r"""[Output-only] The time when this table was created, in milliseconds since the epoch."""  
    default_collation: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('defaultCollation'), 'exclude': lambda f: f is None }})
    r"""[Output-only] The default collation of the table."""  
    default_rounding_mode: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('defaultRoundingMode'), 'exclude': lambda f: f is None }})
    r"""[Output-only] The default rounding mode of the table."""  
    description: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('description'), 'exclude': lambda f: f is None }})
    r"""[Optional] A user-friendly description of this table."""  
    encryption_configuration: Optional[shared_encryptionconfiguration.EncryptionConfiguration] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('encryptionConfiguration'), 'exclude': lambda f: f is None }})  
    etag: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('etag'), 'exclude': lambda f: f is None }})
    r"""[Output-only] A hash of the table metadata. Used to ensure there were no concurrent modifications to the resource when attempting an update. Not guaranteed to change when the table contents or the fields numRows, numBytes, numLongTermBytes or lastModifiedTime change."""  
    expiration_time: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('expirationTime'), 'exclude': lambda f: f is None }})
    r"""[Optional] The time when this table expires, in milliseconds since the epoch. If not present, the table will persist indefinitely. Expired tables will be deleted and their storage reclaimed. The defaultTableExpirationMs property of the encapsulating dataset can be used to set a default expirationTime on newly created tables."""  
    external_data_configuration: Optional[shared_externaldataconfiguration.ExternalDataConfiguration] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('externalDataConfiguration'), 'exclude': lambda f: f is None }})  
    friendly_name: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('friendlyName'), 'exclude': lambda f: f is None }})
    r"""[Optional] A descriptive name for this table."""  
    id: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('id'), 'exclude': lambda f: f is None }})
    r"""[Output-only] An opaque ID uniquely identifying the table."""  
    kind: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('kind'), 'exclude': lambda f: f is None }})
    r"""[Output-only] The type of the resource."""  
    labels: Optional[dict[str, str]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('labels'), 'exclude': lambda f: f is None }})
    r"""The labels associated with this table. You can use these to organize and group your tables. Label keys and values can be no longer than 63 characters, can only contain lowercase letters, numeric characters, underscores and dashes. International characters are allowed. Label values are optional. Label keys must start with a letter and each label in the list must have a different key."""  
    last_modified_time: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('lastModifiedTime'), 'exclude': lambda f: f is None }})
    r"""[Output-only] The time when this table was last modified, in milliseconds since the epoch."""  
    location: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('location'), 'exclude': lambda f: f is None }})
    r"""[Output-only] The geographic location where the table resides. This value is inherited from the dataset."""  
    materialized_view: Optional[shared_materializedviewdefinition.MaterializedViewDefinition] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('materializedView'), 'exclude': lambda f: f is None }})  
    max_staleness: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('maxStaleness'), 'exclude': lambda f: f is None }})
    r"""[Optional] Max staleness of data that could be returned when table or materialized view is queried (formatted as Google SQL Interval type)."""  
    model: Optional[shared_modeldefinition.ModelDefinition] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('model'), 'exclude': lambda f: f is None }})  
    num_active_logical_bytes: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('num_active_logical_bytes'), 'exclude': lambda f: f is None }})
    r"""[Output-only] Number of logical bytes that are less than 90 days old."""  
    num_active_physical_bytes: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('num_active_physical_bytes'), 'exclude': lambda f: f is None }})
    r"""[Output-only] Number of physical bytes less than 90 days old. This data is not kept in real time, and might be delayed by a few seconds to a few minutes."""  
    num_long_term_logical_bytes: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('num_long_term_logical_bytes'), 'exclude': lambda f: f is None }})
    r"""[Output-only] Number of logical bytes that are more than 90 days old."""  
    num_long_term_physical_bytes: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('num_long_term_physical_bytes'), 'exclude': lambda f: f is None }})
    r"""[Output-only] Number of physical bytes more than 90 days old. This data is not kept in real time, and might be delayed by a few seconds to a few minutes."""  
    num_partitions: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('num_partitions'), 'exclude': lambda f: f is None }})
    r"""[Output-only] The number of partitions present in the table or materialized view. This data is not kept in real time, and might be delayed by a few seconds to a few minutes."""  
    num_time_travel_physical_bytes: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('num_time_travel_physical_bytes'), 'exclude': lambda f: f is None }})
    r"""[Output-only] Number of physical bytes used by time travel storage (deleted or changed data). This data is not kept in real time, and might be delayed by a few seconds to a few minutes."""  
    num_total_logical_bytes: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('num_total_logical_bytes'), 'exclude': lambda f: f is None }})
    r"""[Output-only] Total number of logical bytes in the table or materialized view."""  
    num_total_physical_bytes: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('num_total_physical_bytes'), 'exclude': lambda f: f is None }})
    r"""[Output-only] The physical size of this table in bytes. This also includes storage used for time travel. This data is not kept in real time, and might be delayed by a few seconds to a few minutes."""  
    num_bytes: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('numBytes'), 'exclude': lambda f: f is None }})
    r"""[Output-only] The size of this table in bytes, excluding any data in the streaming buffer."""  
    num_long_term_bytes: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('numLongTermBytes'), 'exclude': lambda f: f is None }})
    r"""[Output-only] The number of bytes in the table that are considered \\"long-term storage\\"."""  
    num_physical_bytes: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('numPhysicalBytes'), 'exclude': lambda f: f is None }})
    r"""[Output-only] [TrustedTester] The physical size of this table in bytes, excluding any data in the streaming buffer. This includes compression and storage used for time travel."""  
    num_rows: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('numRows'), 'exclude': lambda f: f is None }})
    r"""[Output-only] The number of rows of data in this table, excluding any data in the streaming buffer."""  
    range_partitioning: Optional[shared_rangepartitioning.RangePartitioning] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('rangePartitioning'), 'exclude': lambda f: f is None }})  
    require_partition_filter: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('requirePartitionFilter'), 'exclude': lambda f: f is None }})
    r"""[Optional] If set to true, queries over this table require a partition filter that can be used for partition elimination to be specified."""  
    schema: Optional[shared_tableschema.TableSchema] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('schema'), 'exclude': lambda f: f is None }})  
    self_link: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('selfLink'), 'exclude': lambda f: f is None }})
    r"""[Output-only] A URL that can be used to access this resource again."""  
    snapshot_definition: Optional[shared_snapshotdefinition.SnapshotDefinition] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('snapshotDefinition'), 'exclude': lambda f: f is None }})  
    streaming_buffer: Optional[shared_streamingbuffer.Streamingbuffer] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('streamingBuffer'), 'exclude': lambda f: f is None }})  
    table_reference: Optional[shared_tablereference.TableReference] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('tableReference'), 'exclude': lambda f: f is None }})  
    time_partitioning: Optional[shared_timepartitioning.TimePartitioning] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('timePartitioning'), 'exclude': lambda f: f is None }})  
    type: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('type'), 'exclude': lambda f: f is None }})
    r"""[Output-only] Describes the table type. The following values are supported: TABLE: A normal BigQuery table. VIEW: A virtual table defined by a SQL query. SNAPSHOT: An immutable, read-only table that is a copy of another table. [TrustedTester] MATERIALIZED_VIEW: SQL query whose result is persisted. EXTERNAL: A table that references data stored in an external storage system, such as Google Cloud Storage. The default value is TABLE."""  
    view: Optional[shared_viewdefinition.ViewDefinition] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('view'), 'exclude': lambda f: f is None }})  
    