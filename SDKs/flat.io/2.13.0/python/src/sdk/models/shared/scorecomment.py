"""Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT."""

from __future__ import annotations
import dataclasses
import dateutil.parser
from ..shared import scorecommentcontext as shared_scorecommentcontext
from dataclasses_json import Undefined, dataclass_json
from datetime import datetime
from enum import Enum
from marshmallow import fields
from sdk import utils
from typing import Optional

class ScoreCommentTypeEnum(str, Enum):
    r"""The type of the comment"""
    DOCUMENT = 'document'
    INLINE = 'inline'


@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class ScoreComment:
    r"""Comment added on a sheet music"""
    
    comment: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('comment'), 'exclude': lambda f: f is None }})
    r"""The comment text that can includes mentions using the following
    format: `@[id:username]`.
    """  
    context: Optional[shared_scorecommentcontext.ScoreCommentContext] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('context'), 'exclude': lambda f: f is None }})
    r"""The context of the comment (for inline/contextualized comments). A context will include all the information related to the location of the comment (i.e. score parts, range of measure, time position)."""  
    date_: Optional[datetime] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('date'), 'encoder': utils.datetimeisoformat(True), 'decoder': dateutil.parser.isoparse, 'mm_field': fields.DateTime(format='iso'), 'exclude': lambda f: f is None }})
    r"""The date when the comment was posted"""  
    id: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('id'), 'exclude': lambda f: f is None }})
    r"""The comment unique identifier"""  
    mentions: Optional[list[str]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('mentions'), 'exclude': lambda f: f is None }})
    r"""The list of user identifier mentioned on the score"""  
    modification_date: Optional[datetime] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('modificationDate'), 'encoder': utils.datetimeisoformat(True), 'decoder': dateutil.parser.isoparse, 'mm_field': fields.DateTime(format='iso'), 'exclude': lambda f: f is None }})
    r"""The date of the last comment modification"""  
    raw_comment: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('rawComment'), 'exclude': lambda f: f is None }})
    r"""A raw version of the comment, that can be displayed without parsing
    the mentions.
    """  
    reply_to: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('replyTo'), 'exclude': lambda f: f is None }})
    r"""When the comment is a reply to another comment, the unique identifier of the parent comment"""  
    resolved: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('resolved'), 'exclude': lambda f: f is None }})
    r"""For inline comments, the comment can be marked as resolved and will be hidden in the future responses"""  
    resolved_by: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('resolvedBy'), 'exclude': lambda f: f is None }})
    r"""If the user is marked as resolved, this will contain the unique identifier of the User who marked this comment as resolved"""  
    revision: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('revision'), 'exclude': lambda f: f is None }})
    r"""The unique identifier of revision the comment was posted"""  
    score: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('score'), 'exclude': lambda f: f is None }})
    r"""The unique identifier of the score where the comment was posted"""  
    spam: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('spam'), 'exclude': lambda f: f is None }})
    r"""`true  if the message has been detected as spam and hidden from other users"""  
    type: Optional[ScoreCommentTypeEnum] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('type'), 'exclude': lambda f: f is None }})
    r"""The type of the comment"""  
    user: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('user'), 'exclude': lambda f: f is None }})
    r"""The author unique identifier"""  
    