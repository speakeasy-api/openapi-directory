/*
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

import * as utils from "../internal/utils";
import * as operations from "./models/operations";
import * as shared from "./models/shared";
import { AxiosInstance, AxiosRequestConfig, AxiosResponse } from "axios";

export class Relyingparty {
  _defaultClient: AxiosInstance;
  _securityClient: AxiosInstance;
  _serverURL: string;
  _language: string;
  _sdkVersion: string;
  _genVersion: string;

  constructor(
    defaultClient: AxiosInstance,
    securityClient: AxiosInstance,
    serverURL: string,
    language: string,
    sdkVersion: string,
    genVersion: string
  ) {
    this._defaultClient = defaultClient;
    this._securityClient = securityClient;
    this._serverURL = serverURL;
    this._language = language;
    this._sdkVersion = sdkVersion;
    this._genVersion = genVersion;
  }

  /**
   * Creates the URI used by the IdP to authenticate the user.
   */
  identitytoolkitRelyingpartyCreateAuthUri(
    req: operations.IdentitytoolkitRelyingpartyCreateAuthUriRequest,
    security: operations.IdentitytoolkitRelyingpartyCreateAuthUriSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.IdentitytoolkitRelyingpartyCreateAuthUriResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.IdentitytoolkitRelyingpartyCreateAuthUriRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/createAuthUri";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "identitytoolkitRelyingpartyCreateAuthUriRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.IdentitytoolkitRelyingpartyCreateAuthUriSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.IdentitytoolkitRelyingpartyCreateAuthUriResponse =
        new operations.IdentitytoolkitRelyingpartyCreateAuthUriResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.createAuthUriResponse = utils.objectToClass(
              httpRes?.data,
              shared.CreateAuthUriResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Delete user account.
   */
  identitytoolkitRelyingpartyDeleteAccount(
    req: operations.IdentitytoolkitRelyingpartyDeleteAccountRequest,
    security: operations.IdentitytoolkitRelyingpartyDeleteAccountSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.IdentitytoolkitRelyingpartyDeleteAccountResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.IdentitytoolkitRelyingpartyDeleteAccountRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/deleteAccount";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "identitytoolkitRelyingpartyDeleteAccountRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.IdentitytoolkitRelyingpartyDeleteAccountSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.IdentitytoolkitRelyingpartyDeleteAccountResponse =
        new operations.IdentitytoolkitRelyingpartyDeleteAccountResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.deleteAccountResponse = utils.objectToClass(
              httpRes?.data,
              shared.DeleteAccountResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Batch download user accounts.
   */
  identitytoolkitRelyingpartyDownloadAccount(
    req: operations.IdentitytoolkitRelyingpartyDownloadAccountRequest,
    security: operations.IdentitytoolkitRelyingpartyDownloadAccountSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.IdentitytoolkitRelyingpartyDownloadAccountResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.IdentitytoolkitRelyingpartyDownloadAccountRequest(
        req
      );
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/downloadAccount";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "identitytoolkitRelyingpartyDownloadAccountRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.IdentitytoolkitRelyingpartyDownloadAccountSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.IdentitytoolkitRelyingpartyDownloadAccountResponse =
        new operations.IdentitytoolkitRelyingpartyDownloadAccountResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.downloadAccountResponse = utils.objectToClass(
              httpRes?.data,
              shared.DownloadAccountResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Reset password for a user.
   */
  identitytoolkitRelyingpartyEmailLinkSignin(
    req: operations.IdentitytoolkitRelyingpartyEmailLinkSigninRequest,
    security: operations.IdentitytoolkitRelyingpartyEmailLinkSigninSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.IdentitytoolkitRelyingpartyEmailLinkSigninResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.IdentitytoolkitRelyingpartyEmailLinkSigninRequest(
        req
      );
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/emailLinkSignin";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "identitytoolkitRelyingpartyEmailLinkSigninRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.IdentitytoolkitRelyingpartyEmailLinkSigninSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.IdentitytoolkitRelyingpartyEmailLinkSigninResponse =
        new operations.IdentitytoolkitRelyingpartyEmailLinkSigninResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.emailLinkSigninResponse = utils.objectToClass(
              httpRes?.data,
              shared.EmailLinkSigninResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Returns the account info.
   */
  identitytoolkitRelyingpartyGetAccountInfo(
    req: operations.IdentitytoolkitRelyingpartyGetAccountInfoRequest,
    security: operations.IdentitytoolkitRelyingpartyGetAccountInfoSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.IdentitytoolkitRelyingpartyGetAccountInfoResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.IdentitytoolkitRelyingpartyGetAccountInfoRequest(
        req
      );
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/getAccountInfo";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "identitytoolkitRelyingpartyGetAccountInfoRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.IdentitytoolkitRelyingpartyGetAccountInfoSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.IdentitytoolkitRelyingpartyGetAccountInfoResponse =
        new operations.IdentitytoolkitRelyingpartyGetAccountInfoResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getAccountInfoResponse = utils.objectToClass(
              httpRes?.data,
              shared.GetAccountInfoResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Get a code for user action confirmation.
   */
  identitytoolkitRelyingpartyGetOobConfirmationCode(
    req: operations.IdentitytoolkitRelyingpartyGetOobConfirmationCodeRequest,
    security: operations.IdentitytoolkitRelyingpartyGetOobConfirmationCodeSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.IdentitytoolkitRelyingpartyGetOobConfirmationCodeResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.IdentitytoolkitRelyingpartyGetOobConfirmationCodeRequest(
          req
        );
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/getOobConfirmationCode";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "relyingparty",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.IdentitytoolkitRelyingpartyGetOobConfirmationCodeSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.IdentitytoolkitRelyingpartyGetOobConfirmationCodeResponse =
        new operations.IdentitytoolkitRelyingpartyGetOobConfirmationCodeResponse(
          {
            statusCode: httpRes.status,
            contentType: contentType,
            rawResponse: httpRes,
          }
        );
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getOobConfirmationCodeResponse = utils.objectToClass(
              httpRes?.data,
              shared.GetOobConfirmationCodeResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Get project configuration.
   */
  identitytoolkitRelyingpartyGetProjectConfig(
    req: operations.IdentitytoolkitRelyingpartyGetProjectConfigRequest,
    security: operations.IdentitytoolkitRelyingpartyGetProjectConfigSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.IdentitytoolkitRelyingpartyGetProjectConfigResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.IdentitytoolkitRelyingpartyGetProjectConfigRequest(
        req
      );
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/getProjectConfig";
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.IdentitytoolkitRelyingpartyGetProjectConfigSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.IdentitytoolkitRelyingpartyGetProjectConfigResponse =
        new operations.IdentitytoolkitRelyingpartyGetProjectConfigResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.identitytoolkitRelyingpartyGetProjectConfigResponse =
              utils.objectToClass(
                httpRes?.data,
                shared.IdentitytoolkitRelyingpartyGetProjectConfigResponse
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Get token signing public key.
   */
  identitytoolkitRelyingpartyGetPublicKeys(
    req: operations.IdentitytoolkitRelyingpartyGetPublicKeysRequest,
    security: operations.IdentitytoolkitRelyingpartyGetPublicKeysSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.IdentitytoolkitRelyingpartyGetPublicKeysResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.IdentitytoolkitRelyingpartyGetPublicKeysRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/publicKeys";
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.IdentitytoolkitRelyingpartyGetPublicKeysSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.IdentitytoolkitRelyingpartyGetPublicKeysResponse =
        new operations.IdentitytoolkitRelyingpartyGetPublicKeysResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.identitytoolkitRelyingpartyGetPublicKeysResponse =
              utils.objectToClass(httpRes?.data);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Get recaptcha secure param.
   */
  identitytoolkitRelyingpartyGetRecaptchaParam(
    req: operations.IdentitytoolkitRelyingpartyGetRecaptchaParamRequest,
    security: operations.IdentitytoolkitRelyingpartyGetRecaptchaParamSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.IdentitytoolkitRelyingpartyGetRecaptchaParamResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.IdentitytoolkitRelyingpartyGetRecaptchaParamRequest(
        req
      );
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/getRecaptchaParam";
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.IdentitytoolkitRelyingpartyGetRecaptchaParamSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.IdentitytoolkitRelyingpartyGetRecaptchaParamResponse =
        new operations.IdentitytoolkitRelyingpartyGetRecaptchaParamResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getRecaptchaParamResponse = utils.objectToClass(
              httpRes?.data,
              shared.GetRecaptchaParamResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Reset password for a user.
   */
  identitytoolkitRelyingpartyResetPassword(
    req: operations.IdentitytoolkitRelyingpartyResetPasswordRequest,
    security: operations.IdentitytoolkitRelyingpartyResetPasswordSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.IdentitytoolkitRelyingpartyResetPasswordResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.IdentitytoolkitRelyingpartyResetPasswordRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/resetPassword";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "identitytoolkitRelyingpartyResetPasswordRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.IdentitytoolkitRelyingpartyResetPasswordSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.IdentitytoolkitRelyingpartyResetPasswordResponse =
        new operations.IdentitytoolkitRelyingpartyResetPasswordResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.resetPasswordResponse = utils.objectToClass(
              httpRes?.data,
              shared.ResetPasswordResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Send SMS verification code.
   */
  identitytoolkitRelyingpartySendVerificationCode(
    req: operations.IdentitytoolkitRelyingpartySendVerificationCodeRequest,
    security: operations.IdentitytoolkitRelyingpartySendVerificationCodeSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.IdentitytoolkitRelyingpartySendVerificationCodeResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.IdentitytoolkitRelyingpartySendVerificationCodeRequest(
          req
        );
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/sendVerificationCode";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "identitytoolkitRelyingpartySendVerificationCodeRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.IdentitytoolkitRelyingpartySendVerificationCodeSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.IdentitytoolkitRelyingpartySendVerificationCodeResponse =
        new operations.IdentitytoolkitRelyingpartySendVerificationCodeResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.identitytoolkitRelyingpartySendVerificationCodeResponse =
              utils.objectToClass(
                httpRes?.data,
                shared.IdentitytoolkitRelyingpartySendVerificationCodeResponse
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Set account info for a user.
   */
  identitytoolkitRelyingpartySetAccountInfo(
    req: operations.IdentitytoolkitRelyingpartySetAccountInfoRequest,
    security: operations.IdentitytoolkitRelyingpartySetAccountInfoSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.IdentitytoolkitRelyingpartySetAccountInfoResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.IdentitytoolkitRelyingpartySetAccountInfoRequest(
        req
      );
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/setAccountInfo";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "identitytoolkitRelyingpartySetAccountInfoRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.IdentitytoolkitRelyingpartySetAccountInfoSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.IdentitytoolkitRelyingpartySetAccountInfoResponse =
        new operations.IdentitytoolkitRelyingpartySetAccountInfoResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.setAccountInfoResponse = utils.objectToClass(
              httpRes?.data,
              shared.SetAccountInfoResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Set project configuration.
   */
  identitytoolkitRelyingpartySetProjectConfig(
    req: operations.IdentitytoolkitRelyingpartySetProjectConfigRequest,
    security: operations.IdentitytoolkitRelyingpartySetProjectConfigSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.IdentitytoolkitRelyingpartySetProjectConfigResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.IdentitytoolkitRelyingpartySetProjectConfigRequest(
        req
      );
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/setProjectConfig";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "identitytoolkitRelyingpartySetProjectConfigRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.IdentitytoolkitRelyingpartySetProjectConfigSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.IdentitytoolkitRelyingpartySetProjectConfigResponse =
        new operations.IdentitytoolkitRelyingpartySetProjectConfigResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.identitytoolkitRelyingpartySetProjectConfigResponse =
              utils.objectToClass(
                httpRes?.data,
                shared.IdentitytoolkitRelyingpartySetProjectConfigResponse
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Sign out user.
   */
  identitytoolkitRelyingpartySignOutUser(
    req: operations.IdentitytoolkitRelyingpartySignOutUserRequest,
    security: operations.IdentitytoolkitRelyingpartySignOutUserSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.IdentitytoolkitRelyingpartySignOutUserResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.IdentitytoolkitRelyingpartySignOutUserRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/signOutUser";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "identitytoolkitRelyingpartySignOutUserRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.IdentitytoolkitRelyingpartySignOutUserSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.IdentitytoolkitRelyingpartySignOutUserResponse =
        new operations.IdentitytoolkitRelyingpartySignOutUserResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.identitytoolkitRelyingpartySignOutUserResponse =
              utils.objectToClass(
                httpRes?.data,
                shared.IdentitytoolkitRelyingpartySignOutUserResponse
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Signup new user.
   */
  identitytoolkitRelyingpartySignupNewUser(
    req: operations.IdentitytoolkitRelyingpartySignupNewUserRequest,
    security: operations.IdentitytoolkitRelyingpartySignupNewUserSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.IdentitytoolkitRelyingpartySignupNewUserResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.IdentitytoolkitRelyingpartySignupNewUserRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/signupNewUser";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "identitytoolkitRelyingpartySignupNewUserRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.IdentitytoolkitRelyingpartySignupNewUserSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.IdentitytoolkitRelyingpartySignupNewUserResponse =
        new operations.IdentitytoolkitRelyingpartySignupNewUserResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.signupNewUserResponse = utils.objectToClass(
              httpRes?.data,
              shared.SignupNewUserResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Batch upload existing user accounts.
   */
  identitytoolkitRelyingpartyUploadAccount(
    req: operations.IdentitytoolkitRelyingpartyUploadAccountRequest,
    security: operations.IdentitytoolkitRelyingpartyUploadAccountSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.IdentitytoolkitRelyingpartyUploadAccountResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.IdentitytoolkitRelyingpartyUploadAccountRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/uploadAccount";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "identitytoolkitRelyingpartyUploadAccountRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.IdentitytoolkitRelyingpartyUploadAccountSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.IdentitytoolkitRelyingpartyUploadAccountResponse =
        new operations.IdentitytoolkitRelyingpartyUploadAccountResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.uploadAccountResponse = utils.objectToClass(
              httpRes?.data,
              shared.UploadAccountResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Verifies the assertion returned by the IdP.
   */
  identitytoolkitRelyingpartyVerifyAssertion(
    req: operations.IdentitytoolkitRelyingpartyVerifyAssertionRequest,
    security: operations.IdentitytoolkitRelyingpartyVerifyAssertionSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.IdentitytoolkitRelyingpartyVerifyAssertionResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.IdentitytoolkitRelyingpartyVerifyAssertionRequest(
        req
      );
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/verifyAssertion";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "identitytoolkitRelyingpartyVerifyAssertionRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.IdentitytoolkitRelyingpartyVerifyAssertionSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.IdentitytoolkitRelyingpartyVerifyAssertionResponse =
        new operations.IdentitytoolkitRelyingpartyVerifyAssertionResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.verifyAssertionResponse = utils.objectToClass(
              httpRes?.data,
              shared.VerifyAssertionResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Verifies the developer asserted ID token.
   */
  identitytoolkitRelyingpartyVerifyCustomToken(
    req: operations.IdentitytoolkitRelyingpartyVerifyCustomTokenRequest,
    security: operations.IdentitytoolkitRelyingpartyVerifyCustomTokenSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.IdentitytoolkitRelyingpartyVerifyCustomTokenResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.IdentitytoolkitRelyingpartyVerifyCustomTokenRequest(
        req
      );
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/verifyCustomToken";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "identitytoolkitRelyingpartyVerifyCustomTokenRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.IdentitytoolkitRelyingpartyVerifyCustomTokenSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.IdentitytoolkitRelyingpartyVerifyCustomTokenResponse =
        new operations.IdentitytoolkitRelyingpartyVerifyCustomTokenResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.verifyCustomTokenResponse = utils.objectToClass(
              httpRes?.data,
              shared.VerifyCustomTokenResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Verifies the user entered password.
   */
  identitytoolkitRelyingpartyVerifyPassword(
    req: operations.IdentitytoolkitRelyingpartyVerifyPasswordRequest,
    security: operations.IdentitytoolkitRelyingpartyVerifyPasswordSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.IdentitytoolkitRelyingpartyVerifyPasswordResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.IdentitytoolkitRelyingpartyVerifyPasswordRequest(
        req
      );
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/verifyPassword";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "identitytoolkitRelyingpartyVerifyPasswordRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.IdentitytoolkitRelyingpartyVerifyPasswordSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.IdentitytoolkitRelyingpartyVerifyPasswordResponse =
        new operations.IdentitytoolkitRelyingpartyVerifyPasswordResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.verifyPasswordResponse = utils.objectToClass(
              httpRes?.data,
              shared.VerifyPasswordResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Verifies ownership of a phone number and creates/updates the user account accordingly.
   */
  identitytoolkitRelyingpartyVerifyPhoneNumber(
    req: operations.IdentitytoolkitRelyingpartyVerifyPhoneNumberRequest,
    security: operations.IdentitytoolkitRelyingpartyVerifyPhoneNumberSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.IdentitytoolkitRelyingpartyVerifyPhoneNumberResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.IdentitytoolkitRelyingpartyVerifyPhoneNumberRequest(
        req
      );
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/verifyPhoneNumber";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "identitytoolkitRelyingpartyVerifyPhoneNumberRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.IdentitytoolkitRelyingpartyVerifyPhoneNumberSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.IdentitytoolkitRelyingpartyVerifyPhoneNumberResponse =
        new operations.IdentitytoolkitRelyingpartyVerifyPhoneNumberResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.identitytoolkitRelyingpartyVerifyPhoneNumberResponse =
              utils.objectToClass(
                httpRes?.data,
                shared.IdentitytoolkitRelyingpartyVerifyPhoneNumberResponse
              );
          }
          break;
      }

      return res;
    });
  }
}
