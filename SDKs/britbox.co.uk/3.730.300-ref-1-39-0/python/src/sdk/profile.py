"""Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT."""

import requests as requests_http
from . import utils
from datetime import datetime
from sdk.models import operations, shared
from typing import Optional

class Profile:
    _client: requests_http.Session
    _security_client: requests_http.Session
    _server_url: str
    _language: str
    _sdk_version: str
    _gen_version: str

    def __init__(self, client: requests_http.Session, security_client: requests_http.Session, server_url: str, language: str, sdk_version: str, gen_version: str) -> None:
        self._client = client
        self._security_client = security_client
        self._server_url = server_url
        self._language = language
        self._sdk_version = sdk_version
        self._gen_version = gen_version
        
    def bookmark_item(self, request: operations.BookmarkItemRequest, security: operations.BookmarkItemSecurity) -> operations.BookmarkItemResponse:
        r"""Bookmark an item under the active profile.
        
        Creates one if it doesn't exist, overwrites one if it does.
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.BookmarkItemRequest, base_url, '/account/profile/bookmarks/{itemId}', request)
        
        query_params = utils.get_query_params(operations.BookmarkItemRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('PUT', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.BookmarkItemResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Bookmark])
                res.bookmark = out
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ServiceError])
                res.service_error = out

        return res

    def delete_item_bookmark(self, request: operations.DeleteItemBookmarkRequest, security: operations.DeleteItemBookmarkSecurity) -> operations.DeleteItemBookmarkResponse:
        r"""Unbookmark an item under the active profile."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.DeleteItemBookmarkRequest, base_url, '/account/profile/bookmarks/{itemId}', request)
        
        query_params = utils.get_query_params(operations.DeleteItemBookmarkRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('DELETE', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DeleteItemBookmarkResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 204:
            pass
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ServiceError])
                res.service_error = out

        return res

    def delete_watched(self, request: operations.DeleteWatchedRequest, security: operations.DeleteWatchedSecurity) -> operations.DeleteWatchedResponse:
        r"""Remove the watched status of items under the active profile. Passing in
        specific `itemId`s to the `item_ids` query parameter will cause only these
        items to be removed. **If this list is missing all watched items will be
        removed**
        """
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/account/profile/watched'
        
        query_params = utils.get_query_params(operations.DeleteWatchedRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('DELETE', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DeleteWatchedResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 204:
            pass
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ServiceError])
                res.service_error = out

        return res

    def get_bookmark_list(self, request: operations.GetBookmarkListRequest, security: operations.GetBookmarkListSecurity) -> operations.GetBookmarkListResponse:
        r"""Returns the list of bookmarked items under the active profile."""
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/account/profile/bookmarks/list'
        
        query_params = utils.get_query_params(operations.GetBookmarkListRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetBookmarkListResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ItemList])
                res.item_list = out
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ServiceError])
                res.service_error = out

        return res

    def get_bookmarks(self, request: operations.GetBookmarksRequest, security: operations.GetBookmarksSecurity) -> operations.GetBookmarksResponse:
        r"""Get the map of bookmarked item ids (itemId => creationDate) under the active profile."""
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/account/profile/bookmarks'
        
        query_params = utils.get_query_params(operations.GetBookmarksRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetBookmarksResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[dict[str, datetime]])
                res.get_bookmarks_200_application_json_object = out
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ServiceError])
                res.service_error = out

        return res

    def get_continue_watching_list(self, request: operations.GetContinueWatchingListRequest, security: operations.GetContinueWatchingListSecurity) -> operations.GetContinueWatchingListResponse:
        r"""Returns a list of items which have been watched but not completed under the active
        profile.
        
        Multiple episodes under the same show may be watched or in progress, however only a
        single item belonging to a particular show will be included in the returned list.
        
        The next episode to continue watching for a particular show will be the most recent
        incompletely watched episode, or the next episode following the most recently
        completely watched episode. Based on the specified `show_item_type` type, either the next
        episode, the season of the next episode, or the show will be included in the list.
        """
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/account/profile/continue-watching/list'
        
        query_params = utils.get_query_params(operations.GetContinueWatchingListRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetContinueWatchingListResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ItemList])
                res.item_list = out
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ServiceError])
                res.service_error = out

        return res

    def get_item_bookmark(self, request: operations.GetItemBookmarkRequest, security: operations.GetItemBookmarkSecurity) -> operations.GetItemBookmarkResponse:
        r"""Get the bookmark for an item under the active profile."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.GetItemBookmarkRequest, base_url, '/account/profile/bookmarks/{itemId}', request)
        
        query_params = utils.get_query_params(operations.GetItemBookmarkRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetItemBookmarkResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Bookmark])
                res.bookmark = out
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ServiceError])
                res.service_error = out

        return res

    def get_item_rating(self, request: operations.GetItemRatingRequest, security: operations.GetItemRatingSecurity) -> operations.GetItemRatingResponse:
        r"""Get the rating info for an item under the active profile."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.GetItemRatingRequest, base_url, '/account/profile/ratings/{itemId}', request)
        
        query_params = utils.get_query_params(operations.GetItemRatingRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetItemRatingResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.UserRating])
                res.user_rating = out
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ServiceError])
                res.service_error = out

        return res

    def get_item_watched_status(self, request: operations.GetItemWatchedStatusRequest, security: operations.GetItemWatchedStatusSecurity) -> operations.GetItemWatchedStatusResponse:
        r"""Get the watched status info for an item under the active profile."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.GetItemWatchedStatusRequest, base_url, '/account/profile/watched/{itemId}', request)
        
        query_params = utils.get_query_params(operations.GetItemWatchedStatusRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetItemWatchedStatusResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Watched])
                res.watched = out
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ServiceError])
                res.service_error = out

        return res

    def get_next_playback_item(self, request: operations.GetNextPlaybackItemRequest, security: operations.GetNextPlaybackItemSecurity) -> operations.GetNextPlaybackItemResponse:
        r"""Returns the next item to play given a source item id.
        
        For an unwatched show it returns the first episode available to the account.
        
        For a watched show it returns the last incompletely watched episode by the profile,
        or the episode that immediately follows the last completely watched episode 
        or nothing.
        
        For an episode it always returns the immediately following episode, if available to
        the account, or nothing.
        
        If the response does not contain a `next` property then no item was found.
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.GetNextPlaybackItemRequest, base_url, '/account/profile/items/{itemId}/next', request)
        
        query_params = utils.get_query_params(operations.GetNextPlaybackItemRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetNextPlaybackItemResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.NextPlaybackItem])
                res.next_playback_item = out
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ServiceError])
                res.service_error = out

        return res

    def get_profile(self, request: operations.GetProfileRequest, security: operations.GetProfileSecurity) -> operations.GetProfileResponse:
        r"""Get the details of the active profile, including watched, bookmarked and rated items."""
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/account/profile'
        
        query_params = utils.get_query_params(operations.GetProfileRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetProfileResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ProfileDetail])
                res.profile_detail = out
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ServiceError])
                res.service_error = out

        return res

    def get_ratings(self, request: operations.GetRatingsRequest, security: operations.GetRatingsSecurity) -> operations.GetRatingsResponse:
        r"""Get the map of rated item ids (itemId => rating out of 10) under the active profile."""
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/account/profile/ratings'
        
        query_params = utils.get_query_params(operations.GetRatingsRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetRatingsResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[dict[str, int]])
                res.get_ratings_200_application_json_object = out
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ServiceError])
                res.service_error = out

        return res

    def get_ratings_list(self, request: operations.GetRatingsListRequest, security: operations.GetRatingsListSecurity) -> operations.GetRatingsListResponse:
        r"""Returns the list of rated items under the active profile."""
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/account/profile/ratings/list'
        
        query_params = utils.get_query_params(operations.GetRatingsListRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetRatingsListResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ItemList])
                res.item_list = out
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ServiceError])
                res.service_error = out

        return res

    def get_watched(self, request: operations.GetWatchedRequest, security: operations.GetWatchedSecurity) -> operations.GetWatchedResponse:
        r"""Get the map of watched item ids (itemId => last playhead position) under the active profile."""
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/account/profile/watched'
        
        query_params = utils.get_query_params(operations.GetWatchedRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetWatchedResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[dict[str, shared.Watched]])
                res.get_watched_200_application_json_object = out
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ServiceError])
                res.service_error = out

        return res

    def get_watched_list(self, request: operations.GetWatchedListRequest, security: operations.GetWatchedListSecurity) -> operations.GetWatchedListResponse:
        r"""Returns the list of watched items under the active profile."""
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/account/profile/watched/list'
        
        query_params = utils.get_query_params(operations.GetWatchedListRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetWatchedListResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ItemList])
                res.item_list = out
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ServiceError])
                res.service_error = out

        return res

    def rate_item(self, request: operations.RateItemRequest, security: operations.RateItemSecurity) -> operations.RateItemResponse:
        r"""Rate an item under the active profile.
        
        Creates one if it doesn't exist, overwrites one if it does.
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.RateItemRequest, base_url, '/account/profile/ratings/{itemId}', request)
        
        query_params = utils.get_query_params(operations.RateItemRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('PUT', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.RateItemResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.UserRating])
                res.user_rating = out
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ServiceError])
                res.service_error = out

        return res

    def set_item_watched_status(self, request: operations.SetItemWatchedStatusRequest, security: operations.SetItemWatchedStatusSecurity) -> operations.SetItemWatchedStatusResponse:
        r"""Record the watched playhead position of a video under the active profile.
        
        Can be used later to resume a video from where it was last watched.
        
        Creates one if it doesn't exist, overwrites one if it does.
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.SetItemWatchedStatusRequest, base_url, '/account/profile/watched/{itemId}', request)
        
        query_params = utils.get_query_params(operations.SetItemWatchedStatusRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('PUT', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.SetItemWatchedStatusResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Watched])
                res.watched = out
        elif http_res.status_code == 204:
            pass
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ServiceError])
                res.service_error = out

        return res

    