/*
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

import * as utils from "../internal/utils";
import * as operations from "./models/operations";
import { AxiosInstance, AxiosRequestConfig, AxiosResponse } from "axios";

export class SubscriptionGroup {
  _defaultClient: AxiosInstance;
  _securityClient: AxiosInstance;
  _serverURL: string;
  _language: string;
  _sdkVersion: string;
  _genVersion: string;

  constructor(
    defaultClient: AxiosInstance,
    securityClient: AxiosInstance,
    serverURL: string,
    language: string,
    sdkVersion: string,
    genVersion: string
  ) {
    this._defaultClient = defaultClient;
    this._securityClient = securityClient;
    this._serverURL = serverURL;
    this._language = language;
    this._sdkVersion = sdkVersion;
    this._genVersion = genVersion;
  }

  /**
   * Add Subscription item by groupId
   *
   * @remarks
   * Adds an SKU to a given Subscription, filtering by groupId.
   */
  additemsubscriptionGroupId(
    req: operations.AdditemsubscriptionGroupIdRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.AdditemsubscriptionGroupIdResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.AdditemsubscriptionGroupIdRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/subscriptions-group/{groupId}/additem",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "additemsubscriptionGroupIdRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.AdditemsubscriptionGroupIdResponse =
        new operations.AdditemsubscriptionGroupIdResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          break;
      }

      return res;
    });
  }

  /**
   * Cancel Subscription by groupId
   *
   * @remarks
   * Cancels Subscription by `groupId`
   */
  cancelSubscriptionbygroupId(
    req: operations.CancelSubscriptionbygroupIdRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.CancelSubscriptionbygroupIdResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CancelSubscriptionbygroupIdRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/subscriptions-group/{groupId}/cancel",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };

    const r = client.request({
      url: url,
      method: "patch",
      headers: headers,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CancelSubscriptionbygroupIdResponse =
        new operations.CancelSubscriptionbygroupIdResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          break;
      }

      return res;
    });
  }

  /**
   * List All subscription groups
   *
   * @remarks
   * Retrieves all subscription groups in your store.
   */
  getAllsubscriptiongroup(
    req: operations.GetAllsubscriptiongroupRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetAllsubscriptiongroupResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetAllsubscriptiongroupRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/subscriptions-group";

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };

    const r = client.request({
      url: url,
      method: "get",
      headers: headers,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetAllsubscriptiongroupResponse =
        new operations.GetAllsubscriptiongroupResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          break;
      }

      return res;
    });
  }

  /**
   * List Subscription group's Configuration
   *
   * @remarks
   * Retrieves details about a given subscription group's configuration, filtering by groupId.
   */
  getConfigsubscriptionsgroup(
    req: operations.GetConfigsubscriptionsgroupRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetConfigsubscriptionsgroupResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetConfigsubscriptionsgroupRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/subscriptions-group/{groupId}/config",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };

    const r = client.request({
      url: url,
      method: "get",
      headers: headers,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetConfigsubscriptionsgroupResponse =
        new operations.GetConfigsubscriptionsgroupResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          break;
      }

      return res;
    });
  }

  /**
   * Get Conversation Message by groupId
   *
   * @remarks
   * Retrieves the conversation of a given Subscription group, filtering by groupId.
   */
  getConversationMessagebygroupId(
    req: operations.GetConversationMessagebygroupIdRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetConversationMessagebygroupIdResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetConversationMessagebygroupIdRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/subscriptions-group/{groupId}/conversation-message",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };

    const r = client.request({
      url: url,
      method: "get",
      headers: headers,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetConversationMessagebygroupIdResponse =
        new operations.GetConversationMessagebygroupIdResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          break;
      }

      return res;
    });
  }

  /**
   * Get Next purchase
   *
   * @remarks
   * Lists details of a given subscription group's next purchase, filtering by dateStr.
   */
  getNextpurchase(
    req: operations.GetNextpurchaseRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetNextpurchaseResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetNextpurchaseRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/subscriptions-group/nextPurchase/{dateStr}",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };

    const r = client.request({
      url: url,
      method: "get",
      headers: headers,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetNextpurchaseResponse =
        new operations.GetNextpurchaseResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          break;
      }

      return res;
    });
  }

  /**
   * Get Simulation by subscription-group
   *
   * @remarks
   * Retrieves Subscription simulations, filtering by groupId.
   */
  getSimulatebysubscriptionGroup(
    req: operations.GetSimulatebysubscriptionGroupRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetSimulatebysubscriptionGroupResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetSimulatebysubscriptionGroupRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/subscriptions-group/simulate/{groupId}",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };

    const r = client.request({
      url: url,
      method: "get",
      headers: headers,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetSimulatebysubscriptionGroupResponse =
        new operations.GetSimulatebysubscriptionGroupResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          break;
      }

      return res;
    });
  }

  /**
   * Get Subscription by groupId
   *
   * @remarks
   * Lists Subscription details, filtering by `groupId`.
   */
  getSubscriptionbygroupId(
    req: operations.GetSubscriptionbygroupIdRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetSubscriptionbygroupIdResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetSubscriptionbygroupIdRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/subscriptions-group/{groupId}",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };

    const r = client.request({
      url: url,
      method: "get",
      headers: headers,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetSubscriptionbygroupIdResponse =
        new operations.GetSubscriptionbygroupIdResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          break;
      }

      return res;
    });
  }

  /**
   * Get addresses by groupId
   *
   * @remarks
   * Lists addresses linked to a given Subscription group, filtering by groupId.
   */
  getaddressesbygroupId(
    req: operations.GetaddressesbygroupIdRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetaddressesbygroupIdResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetaddressesbygroupIdRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/subscriptions-group/{groupId}/addresses",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };

    const r = client.request({
      url: url,
      method: "get",
      headers: headers,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetaddressesbygroupIdResponse =
        new operations.GetaddressesbygroupIdResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          break;
      }

      return res;
    });
  }

  /**
   * Get frequency options by groupId
   *
   * @remarks
   * Lists frequency options of a given Subscription group, filtering by groupId.
   */
  getfrequencyoptionsbygroupId(
    req: operations.GetfrequencyoptionsbygroupIdRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetfrequencyoptionsbygroupIdResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetfrequencyoptionsbygroupIdRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/subscriptions-group/{groupId}/frequency-options",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };

    const r = client.request({
      url: url,
      method: "get",
      headers: headers,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetfrequencyoptionsbygroupIdResponse =
        new operations.GetfrequencyoptionsbygroupIdResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          break;
      }

      return res;
    });
  }

  /**
   * Get payment System by groupId
   *
   * @remarks
   * Retrieves payment system's information of a given Subscription group, filtering by groupId.
   */
  getpaymentSystembygroupId(
    req: operations.GetpaymentSystembygroupIdRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetpaymentSystembygroupIdResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetpaymentSystembygroupIdRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/subscriptions-group/{groupId}/payment-systems",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };

    const r = client.request({
      url: url,
      method: "get",
      headers: headers,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetpaymentSystembygroupIdResponse =
        new operations.GetpaymentSystembygroupIdResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          break;
      }

      return res;
    });
  }

  /**
   * Get subscription group list
   *
   * @remarks
   * Retrieves a list of Subscription groups in your store.
   */
  getsubscriptiongrouplist(
    req: operations.GetsubscriptiongrouplistRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetsubscriptiongrouplistResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetsubscriptiongrouplistRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/subscriptions-group/list";

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };

    const r = client.request({
      url: url,
      method: "get",
      headers: headers,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetsubscriptiongrouplistResponse =
        new operations.GetsubscriptiongrouplistResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          break;
      }

      return res;
    });
  }

  /**
   * List 'Will create' by groupId
   *
   * @remarks
   * Retrieves Subscription groups listed as 'will create', filtering by groupId.
   */
  getwillcreatebygroupId(
    req: operations.GetwillcreatebygroupIdRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetwillcreatebygroupIdResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetwillcreatebygroupIdRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/subscriptions-group/{groupId}/will-create",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };

    const r = client.request({
      url: url,
      method: "get",
      headers: headers,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetwillcreatebygroupIdResponse =
        new operations.GetwillcreatebygroupIdResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          break;
      }

      return res;
    });
  }

  /**
   * Insert Addresses by groupId
   *
   * @remarks
   * Insert address information of a given Subscription group, filtering by groupId.
   */
  insertAddressesbygroupId(
    req: operations.InsertAddressesbygroupIdRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.InsertAddressesbygroupIdResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.InsertAddressesbygroupIdRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/subscriptions-group/{groupId}/addresses",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "insertAddressesbygroupIdRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.InsertAddressesbygroupIdResponse =
        new operations.InsertAddressesbygroupIdResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          break;
      }

      return res;
    });
  }

  /**
   * Retry subscription by groupId
   *
   * @remarks
   * Permits the retry of a Subscription group, via API, filtering by groupId and instanceId.
   */
  retrysubscriptionbygroupId(
    req: operations.RetrysubscriptionbygroupIdRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.RetrysubscriptionbygroupIdResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.RetrysubscriptionbygroupIdRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/subscriptions-group/{groupid}/instances/{instanceId}/retry",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.RetrysubscriptionbygroupIdResponse =
        new operations.RetrysubscriptionbygroupIdResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          break;
      }

      return res;
    });
  }

  /**
   * Update Subscription by groupId
   *
   * @remarks
   * Updates a Subscription by `groupId`.
   */
  updateSubscriptionbygroupId(
    req: operations.UpdateSubscriptionbygroupIdRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.UpdateSubscriptionbygroupIdResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.UpdateSubscriptionbygroupIdRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/subscriptions-group/{groupId}",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "updateSubscriptionbygroupIdRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "patch",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UpdateSubscriptionbygroupIdResponse =
        new operations.UpdateSubscriptionbygroupIdResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          break;
      }

      return res;
    });
  }
}
