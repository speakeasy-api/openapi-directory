"""Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT."""

import requests as requests_http
from . import utils
from sdk.models import operations, shared
from typing import Any, Optional

class Calls:
    _client: requests_http.Session
    _security_client: requests_http.Session
    _server_url: str
    _language: str
    _sdk_version: str
    _gen_version: str

    def __init__(self, client: requests_http.Session, security_client: requests_http.Session, server_url: str, language: str, sdk_version: str, gen_version: str) -> None:
        self._client = client
        self._security_client = security_client
        self._server_url = server_url
        self._language = language
        self._sdk_version = sdk_version
        self._gen_version = gen_version
        
    def add_call_broadcast_batch(self, request: operations.AddCallBroadcastBatchRequest, security: operations.AddCallBroadcastBatchSecurity) -> operations.AddCallBroadcastBatchResponse:
        r"""Add batches to a call broadcast
        The 'add batch' API allows user to add additional batches to an already created voice broadcast campaign. The added batch will go through the CallFire validation process, unlike in the recipients version of this API. That is why you can use the scrubDuplicates flag to remove duplicates from your batch. Batches may be added as a contact list id, a list of contact ids, or a list of numbers
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.AddCallBroadcastBatchRequest, base_url, '/calls/broadcasts/{id}/batches', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "batch_request", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        query_params = utils.get_query_params(operations.AddCallBroadcastBatchRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, params=query_params, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.AddCallBroadcastBatchResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 201:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ResourceID])
                res.resource_id = out
        elif http_res.status_code in [400, 401, 403, 404, 500]:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ErrorResponse])
                res.error_response = out

        return res

    def add_call_broadcast_recipients(self, request: operations.AddCallBroadcastRecipientsRequest, security: operations.AddCallBroadcastRecipientsSecurity) -> operations.AddCallBroadcastRecipientsResponse:
        r"""Add recipients to a call broadcast
        Use this API to add the recipients to an existing voice broadcast. Post a list of Recipient objects to be added to the voice broadcast campaign. These contacts will not go through validation process, and will be acted upon as they are added. Recipients may be added as a list of contact ids, or list of numbers
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.AddCallBroadcastRecipientsRequest, base_url, '/calls/broadcasts/{id}/recipients', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        query_params = utils.get_query_params(operations.AddCallBroadcastRecipientsRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, params=query_params, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.AddCallBroadcastRecipientsResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.CallList])
                res.call_list = out
        elif http_res.status_code in [400, 401, 403, 404, 500]:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ErrorResponse])
                res.error_response = out

        return res

    def archive_voice_broadcast(self, request: operations.ArchiveVoiceBroadcastRequest, security: operations.ArchiveVoiceBroadcastSecurity) -> operations.ArchiveVoiceBroadcastResponse:
        r"""Archive voice broadcast
        Archives a voice broadcast (voice broadcast will be hidden in search results)
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.ArchiveVoiceBroadcastRequest, base_url, '/calls/broadcasts/{id}/archive', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ArchiveVoiceBroadcastResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code in [400, 401, 403, 404, 500]:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ErrorResponse])
                res.error_response = out

        return res

    def create_call_broadcast(self, request: operations.CreateCallBroadcastRequest, security: operations.CreateCallBroadcastSecurity) -> operations.CreateCallBroadcastResponse:
        r"""Create a call broadcast
        Creates a call broadcast campaign using the Call Broadcast API. Send a CallBroadcast in the message body to add details in a voice broadcast campaign. The campaign can be created without contacts and bare minimum configuration, but contacts will have to be added further on to use the campaign
        """
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/calls/broadcasts'
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "call_broadcast_input", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        query_params = utils.get_query_params(operations.CreateCallBroadcastRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, params=query_params, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.CreateCallBroadcastResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 201:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ResourceID])
                res.resource_id = out
        elif http_res.status_code in [400, 401, 403, 404, 500]:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ErrorResponse])
                res.error_response = out

        return res

    def find_call_broadcasts(self, request: operations.FindCallBroadcastsRequest, security: operations.FindCallBroadcastsSecurity) -> operations.FindCallBroadcastsResponse:
        r"""Find call broadcasts
        Searches for all voice broadcasts created by user. Can query on label, name, and the current running status of the campaign. Returns a paged list of voice broadcasts
        """
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/calls/broadcasts'
        
        query_params = utils.get_query_params(operations.FindCallBroadcastsRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.FindCallBroadcastsResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.CallBroadcastPage])
                res.call_broadcast_page = out
        elif http_res.status_code in [400, 401, 403, 404, 500]:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ErrorResponse])
                res.error_response = out

        return res

    def find_calls(self, request: operations.FindCallsRequest, security: operations.FindCallsSecurity) -> operations.FindCallsResponse:
        r"""Find calls
        To search for all calls sent or received by the user. Use \"id=0\" for the campaignId parameter to query for all calls sent through the POST /calls API. See [call states and results](https://developers.callfire.com/results-responses-errors.html)
        """
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/calls'
        
        query_params = utils.get_query_params(operations.FindCallsRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.FindCallsResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.CallPage])
                res.call_page = out
        elif http_res.status_code in [400, 401, 403, 404, 500]:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ErrorResponse])
                res.error_response = out

        return res

    def get_call(self, request: operations.GetCallRequest, security: operations.GetCallSecurity) -> operations.GetCallResponse:
        r"""Find a specific call
        Returns a single Call instance for a given call id.
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.GetCallRequest, base_url, '/calls/{id}', request)
        
        query_params = utils.get_query_params(operations.GetCallRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetCallResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Call])
                res.call = out
        elif http_res.status_code in [400, 401, 403, 404, 500]:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ErrorResponse])
                res.error_response = out

        return res

    def get_call_broadcast(self, request: operations.GetCallBroadcastRequest, security: operations.GetCallBroadcastSecurity) -> operations.GetCallBroadcastResponse:
        r"""Find a specific call broadcast
        Returns a single CallBroadcast instance for a given call broadcast campaign id
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.GetCallBroadcastRequest, base_url, '/calls/broadcasts/{id}', request)
        
        query_params = utils.get_query_params(operations.GetCallBroadcastRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetCallBroadcastResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.CallBroadcast])
                res.call_broadcast = out
        elif http_res.status_code in [400, 401, 403, 404, 500]:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ErrorResponse])
                res.error_response = out

        return res

    def get_call_broadcast_batches(self, request: operations.GetCallBroadcastBatchesRequest, security: operations.GetCallBroadcastBatchesSecurity) -> operations.GetCallBroadcastBatchesResponse:
        r"""Find batches in a call broadcast
        This endpoint will enable the user to page through all of the batches for a particular voice broadcast campaign
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.GetCallBroadcastBatchesRequest, base_url, '/calls/broadcasts/{id}/batches', request)
        
        query_params = utils.get_query_params(operations.GetCallBroadcastBatchesRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetCallBroadcastBatchesResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.BatchPage])
                res.batch_page = out
        elif http_res.status_code in [400, 401, 403, 404, 500]:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ErrorResponse])
                res.error_response = out

        return res

    def get_call_broadcast_calls(self, request: operations.GetCallBroadcastCallsRequest, security: operations.GetCallBroadcastCallsSecurity) -> operations.GetCallBroadcastCallsResponse:
        r"""Find calls in a call broadcast
        This endpoint will enable the user to page through all calls for a particular call broadcast campaign
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.GetCallBroadcastCallsRequest, base_url, '/calls/broadcasts/{id}/calls', request)
        
        query_params = utils.get_query_params(operations.GetCallBroadcastCallsRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetCallBroadcastCallsResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.CallPage])
                res.call_page = out
        elif http_res.status_code in [400, 401, 403, 404, 500]:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ErrorResponse])
                res.error_response = out

        return res

    def get_call_broadcast_stats(self, request: operations.GetCallBroadcastStatsRequest, security: operations.GetCallBroadcastStatsSecurity) -> operations.GetCallBroadcastStatsResponse:
        r"""Get statistics on call broadcast
        Returns broadcast statistics like total number of sent/received actions, total cost, number of remaining outbound actions, error count, etc
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.GetCallBroadcastStatsRequest, base_url, '/calls/broadcasts/{id}/stats', request)
        
        query_params = utils.get_query_params(operations.GetCallBroadcastStatsRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetCallBroadcastStatsResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.CallBroadcastStats])
                res.call_broadcast_stats = out
        elif http_res.status_code in [400, 401, 403, 404, 500]:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ErrorResponse])
                res.error_response = out

        return res

    def get_call_recording(self, request: operations.GetCallRecordingRequest, security: operations.GetCallRecordingSecurity) -> operations.GetCallRecordingResponse:
        r"""Get call recording by id
        Returns metadata of recording of a particular call. Metadata contains a link to a MP3 recording
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.GetCallRecordingRequest, base_url, '/calls/recordings/{id}', request)
        
        query_params = utils.get_query_params(operations.GetCallRecordingRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetCallRecordingResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.CallRecording])
                res.call_recording = out
        elif http_res.status_code in [400, 401, 403, 404, 500]:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ErrorResponse])
                res.error_response = out

        return res

    def get_call_recording_by_name(self, request: operations.GetCallRecordingByNameRequest, security: operations.GetCallRecordingByNameSecurity) -> operations.GetCallRecordingByNameResponse:
        r"""Get call recording by name
        Returns recording metadata of particular call. Metadata contains link to a MP3 recording
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.GetCallRecordingByNameRequest, base_url, '/calls/{id}/recordings/{name}', request)
        
        query_params = utils.get_query_params(operations.GetCallRecordingByNameRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetCallRecordingByNameResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.CallRecording])
                res.call_recording = out
        elif http_res.status_code in [400, 401, 403, 404, 500]:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ErrorResponse])
                res.error_response = out

        return res

    def get_call_recording_mp3(self, request: operations.GetCallRecordingMp3Request, security: operations.GetCallRecordingMp3Security) -> operations.GetCallRecordingMp3Response:
        r"""Get call recording in mp3 format
        Returns an MP3 recording of particular call, response contains binary data, content type is 'audio/mpeg'
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.GetCallRecordingMp3Request, base_url, '/calls/recordings/{id}.mp3', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetCallRecordingMp3Response(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[dict[str, Any]])
                res.input_stream = out
        elif http_res.status_code in [400, 401, 403, 404, 500]:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ErrorResponse])
                res.error_response = out

        return res

    def get_call_recording_mp3_by_name(self, request: operations.GetCallRecordingMp3ByNameRequest, security: operations.GetCallRecordingMp3ByNameSecurity) -> operations.GetCallRecordingMp3ByNameResponse:
        r"""Get call mp3 recording by name
        Returns a MP3 recording of a particular call, response contains binary data, content type is 'audio/mpeg'
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.GetCallRecordingMp3ByNameRequest, base_url, '/calls/{id}/recordings/{name}.mp3', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetCallRecordingMp3ByNameResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code in [200, 400, 401, 403, 404, 500]:
            if utils.match_content_type(content_type, 'audio/mpeg'):
                res.body = http_res.content

        return res

    def get_call_recordings(self, request: operations.GetCallRecordingsRequest, security: operations.GetCallRecordingsSecurity) -> operations.GetCallRecordingsResponse:
        r"""Get call recordings for a call
        Returns a list of recordings metadata of particular call. Metadata contains link to a MP3 recording
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.GetCallRecordingsRequest, base_url, '/calls/{id}/recordings', request)
        
        query_params = utils.get_query_params(operations.GetCallRecordingsRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetCallRecordingsResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.CallRecordingList])
                res.call_recording_list = out
        elif http_res.status_code in [400, 401, 403, 404, 500]:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ErrorResponse])
                res.error_response = out

        return res

    def send_calls(self, request: operations.SendCallsRequest, security: operations.SendCallsSecurity) -> operations.SendCallsResponse:
        r"""Send calls
        Use the /calls API to send individual calls quickly. A verified Caller ID and sufficient credits are required to make a call. CallRecipient represents a single recipient identified by phone number or contact id in CallFire system. You can attach user-defined attributes to a Call action via CallRecipient.attributes property, attributes are available in Call action response
        """
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/calls'
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        query_params = utils.get_query_params(operations.SendCallsRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, params=query_params, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.SendCallsResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.CallList])
                res.call_list = out
        elif http_res.status_code in [400, 401, 403, 404, 500]:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ErrorResponse])
                res.error_response = out

        return res

    def start_voice_broadcast(self, request: operations.StartVoiceBroadcastRequest, security: operations.StartVoiceBroadcastSecurity) -> operations.StartVoiceBroadcastResponse:
        r"""Start voice broadcast
        Start a voice broadcast
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.StartVoiceBroadcastRequest, base_url, '/calls/broadcasts/{id}/start', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.StartVoiceBroadcastResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code in [400, 401, 403, 404, 500]:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ErrorResponse])
                res.error_response = out

        return res

    def stop_voice_broadcast(self, request: operations.StopVoiceBroadcastRequest, security: operations.StopVoiceBroadcastSecurity) -> operations.StopVoiceBroadcastResponse:
        r"""Stop voice broadcast
        Stop a voice broadcast
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.StopVoiceBroadcastRequest, base_url, '/calls/broadcasts/{id}/stop', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.StopVoiceBroadcastResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code in [400, 401, 403, 404, 500]:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ErrorResponse])
                res.error_response = out

        return res

    def toggle_call_broadcast_recipients_status(self, request: operations.ToggleCallBroadcastRecipientsStatusRequest, security: operations.ToggleCallBroadcastRecipientsStatusSecurity) -> operations.ToggleCallBroadcastRecipientsStatusResponse:
        r"""Disable/enable undialed recipients in broadcast
        This operation lets the user to disable/enable undialed recipients in created broadcast
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.ToggleCallBroadcastRecipientsStatusRequest, base_url, '/calls/broadcasts/{id}/toggleRecipientsStatus', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        query_params = utils.get_query_params(operations.ToggleCallBroadcastRecipientsStatusRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, params=query_params, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ToggleCallBroadcastRecipientsStatusResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code in [400, 401, 403, 404, 500]:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ErrorResponse])
                res.error_response = out

        return res

    def update_call_broadcast(self, request: operations.UpdateCallBroadcastRequest, security: operations.UpdateCallBroadcastSecurity) -> operations.UpdateCallBroadcastResponse:
        r"""Update a call broadcast
        This operation lets the user modify the configuration of a voice broadcast campaign after call broadcast campaign is created. See CallBroadcast for more information on what can/can't be updated on this API
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.UpdateCallBroadcastRequest, base_url, '/calls/broadcasts/{id}', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "call_broadcast_input", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        query_params = utils.get_query_params(operations.UpdateCallBroadcastRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('PUT', url, params=query_params, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.UpdateCallBroadcastResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code in [400, 401, 403, 404, 500]:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ErrorResponse])
                res.error_response = out

        return res

    