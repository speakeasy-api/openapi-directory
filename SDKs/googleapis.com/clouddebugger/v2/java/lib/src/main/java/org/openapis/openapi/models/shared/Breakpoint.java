/* 
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

package org.openapis.openapi.models.shared;

import com.fasterxml.jackson.annotation.JsonInclude.Include;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;

/**
 * Breakpoint - ------------------------------------------------------------------------------ ## Breakpoint (the resource) Represents the breakpoint specification, status and results.
 */
public class Breakpoint {
    /**
     * Action that the agent should perform when the code at the breakpoint location is hit.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("action")
    public BreakpointActionEnum action;

    public Breakpoint withAction(BreakpointActionEnum action) {
        this.action = action;
        return this;
    }
    
    /**
     * The deadline for the breakpoint to stay in CANARY_ACTIVE state. The value is meaningless when the breakpoint is not in CANARY_ACTIVE state.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("canaryExpireTime")
    public String canaryExpireTime;

    public Breakpoint withCanaryExpireTime(String canaryExpireTime) {
        this.canaryExpireTime = canaryExpireTime;
        return this;
    }
    
    /**
     * Condition that triggers the breakpoint. The condition is a compound boolean expression composed using expressions in a programming language at the source location.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("condition")
    public String condition;

    public Breakpoint withCondition(String condition) {
        this.condition = condition;
        return this;
    }
    
    /**
     * Time this breakpoint was created by the server in seconds resolution.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("createTime")
    public String createTime;

    public Breakpoint withCreateTime(String createTime) {
        this.createTime = createTime;
        return this;
    }
    
    /**
     * Values of evaluated expressions at breakpoint time. The evaluated expressions appear in exactly the same order they are listed in the `expressions` field. The `name` field holds the original expression text, the `value` or `members` field holds the result of the evaluated expression. If the expression cannot be evaluated, the `status` inside the `Variable` will indicate an error and contain the error text.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("evaluatedExpressions")
    public Variable[] evaluatedExpressions;

    public Breakpoint withEvaluatedExpressions(Variable[] evaluatedExpressions) {
        this.evaluatedExpressions = evaluatedExpressions;
        return this;
    }
    
    /**
     * List of read-only expressions to evaluate at the breakpoint location. The expressions are composed using expressions in the programming language at the source location. If the breakpoint action is `LOG`, the evaluated expressions are included in log statements.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("expressions")
    public String[] expressions;

    public Breakpoint withExpressions(String[] expressions) {
        this.expressions = expressions;
        return this;
    }
    
    /**
     * Time this breakpoint was finalized as seen by the server in seconds resolution.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("finalTime")
    public String finalTime;

    public Breakpoint withFinalTime(String finalTime) {
        this.finalTime = finalTime;
        return this;
    }
    
    /**
     * Breakpoint identifier, unique in the scope of the debuggee.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("id")
    public String id;

    public Breakpoint withId(String id) {
        this.id = id;
        return this;
    }
    
    /**
     * When true, indicates that this is a final result and the breakpoint state will not change from here on.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("isFinalState")
    public Boolean isFinalState;

    public Breakpoint withIsFinalState(Boolean isFinalState) {
        this.isFinalState = isFinalState;
        return this;
    }
    
    /**
     * A set of custom breakpoint properties, populated by the agent, to be displayed to the user.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("labels")
    public java.util.Map<String, String> labels;

    public Breakpoint withLabels(java.util.Map<String, String> labels) {
        this.labels = labels;
        return this;
    }
    
    /**
     * Represents a location in the source code.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("location")
    public SourceLocation location;

    public Breakpoint withLocation(SourceLocation location) {
        this.location = location;
        return this;
    }
    
    /**
     * Indicates the severity of the log. Only relevant when action is `LOG`.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("logLevel")
    public BreakpointLogLevelEnum logLevel;

    public Breakpoint withLogLevel(BreakpointLogLevelEnum logLevel) {
        this.logLevel = logLevel;
        return this;
    }
    
    /**
     * Only relevant when action is `LOG`. Defines the message to log when the breakpoint hits. The message may include parameter placeholders `$0`, `$1`, etc. These placeholders are replaced with the evaluated value of the appropriate expression. Expressions not referenced in `log_message_format` are not logged. Example: `Message received, id = $0, count = $1` with `expressions` = `[ message.id, message.count ]`.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("logMessageFormat")
    public String logMessageFormat;

    public Breakpoint withLogMessageFormat(String logMessageFormat) {
        this.logMessageFormat = logMessageFormat;
        return this;
    }
    
    /**
     * The stack at breakpoint time, where stack_frames[0] represents the most recently entered function.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("stackFrames")
    public StackFrame[] stackFrames;

    public Breakpoint withStackFrames(StackFrame[] stackFrames) {
        this.stackFrames = stackFrames;
        return this;
    }
    
    /**
     * The current state of the breakpoint.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("state")
    public BreakpointStateEnum state;

    public Breakpoint withState(BreakpointStateEnum state) {
        this.state = state;
        return this;
    }
    
    /**
     * Represents a contextual status message. The message can indicate an error or informational status, and refer to specific parts of the containing object. For example, the `Breakpoint.status` field can indicate an error referring to the `BREAKPOINT_SOURCE_LOCATION` with the message `Location not found`.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("status")
    public StatusMessage status;

    public Breakpoint withStatus(StatusMessage status) {
        this.status = status;
        return this;
    }
    
    /**
     * E-mail address of the user that created this breakpoint
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("userEmail")
    public String userEmail;

    public Breakpoint withUserEmail(String userEmail) {
        this.userEmail = userEmail;
        return this;
    }
    
    /**
     * The `variable_table` exists to aid with computation, memory and network traffic optimization. It enables storing a variable once and reference it from multiple variables, including variables stored in the `variable_table` itself. For example, the same `this` object, which may appear at many levels of the stack, can have all of its data stored once in this table. The stack frame variables then would hold only a reference to it. The variable `var_table_index` field is an index into this repeated field. The stored objects are nameless and get their name from the referencing variable. The effective variable is a merge of the referencing variable and the referenced variable.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("variableTable")
    public Variable[] variableTable;

    public Breakpoint withVariableTable(Variable[] variableTable) {
        this.variableTable = variableTable;
        return this;
    }
    
    public Breakpoint(){}
}
