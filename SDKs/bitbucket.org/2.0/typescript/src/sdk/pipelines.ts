/*
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

import * as utils from "../internal/utils";
import * as operations from "./models/operations";
import * as shared from "./models/shared";
import { AxiosInstance, AxiosRequestConfig, AxiosResponse } from "axios";

/**
 * Bitbucket Pipelines brings continuous delivery to Bitbucket
 *
 * @remarks
 * Cloud, empowering teams with full branching to deployment
 * visibility and faster feedback loops.
 *
 */
export class Pipelines {
  _defaultClient: AxiosInstance;
  _securityClient: AxiosInstance;
  _serverURL: string;
  _language: string;
  _sdkVersion: string;
  _genVersion: string;

  constructor(
    defaultClient: AxiosInstance,
    securityClient: AxiosInstance,
    serverURL: string,
    language: string,
    sdkVersion: string,
    genVersion: string
  ) {
    this._defaultClient = defaultClient;
    this._securityClient = securityClient;
    this._serverURL = serverURL;
    this._language = language;
    this._sdkVersion = sdkVersion;
    this._genVersion = genVersion;
  }

  /**
   * Create a variable for an environment
   *
   * @remarks
   * Create a deployment environment level variable.
   */
  createDeploymentVariable(
    req: operations.CreateDeploymentVariableRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.CreateDeploymentVariableResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CreateDeploymentVariableRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/repositories/{workspace}/{repo_slug}/deployments_config/environments/{environment_uuid}/variables",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CreateDeploymentVariableResponse =
        new operations.CreateDeploymentVariableResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
          headers: utils.getHeadersFromResponse(httpRes.headers),
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.deploymentVariable = utils.objectToClass(httpRes?.data);
          }
          break;
        case [404, 409].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.error = utils.objectToClass(httpRes?.data);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Run a pipeline
   *
   * @remarks
   * Endpoint to create and initiate a pipeline.
   * There are a couple of different options to initiate a pipeline, where the payload of the request will determine which type of pipeline will be instantiated.
   * # Trigger a Pipeline for a branch
   * One way to trigger pipelines is by specifying the branch for which you want to trigger a pipeline.
   * The specified branch will be used to determine which pipeline definition from the `bitbucket-pipelines.yml` file will be applied to initiate the pipeline. The pipeline will then do a clone of the repository and checkout the latest revision of the specified branch.
   *
   * ### Example
   *
   * ```
   * $ curl -X POST -is -u username:password \
   *   -H 'Content-Type: application/json' \
   *  https://api.bitbucket.org/2.0/repositories/jeroendr/meat-demo2/pipelines/ \
   *   -d '
   *   {
   *     "target": {
   *       "ref_type": "branch",
   *       "type": "pipeline_ref_target",
   *       "ref_name": "master"
   *     }
   *   }'
   * ```
   * # Trigger a Pipeline for a commit on a branch or tag
   * You can initiate a pipeline for a specific commit and in the context of a specified reference (e.g. a branch, tag or bookmark).
   * The specified reference will be used to determine which pipeline definition from the bitbucket-pipelines.yml file will be applied to initiate the pipeline. The pipeline will clone the repository and then do a checkout the specified reference.
   *
   * The following reference types are supported:
   *
   * * `branch`
   * * `named_branch`
   * * `bookmark`
   *  * `tag`
   *
   * ### Example
   *
   * ```
   * $ curl -X POST -is -u username:password \
   *   -H 'Content-Type: application/json' \
   *   https://api.bitbucket.org/2.0/repositories/jeroendr/meat-demo2/pipelines/ \
   *   -d '
   *   {
   *     "target": {
   *       "commit": {
   *         "type": "commit",
   *         "hash": "ce5b7431602f7cbba007062eeb55225c6e18e956"
   *       },
   *       "ref_type": "branch",
   *       "type": "pipeline_ref_target",
   *       "ref_name": "master"
   *     }
   *   }'
   * ```
   * # Trigger a specific pipeline definition for a commit
   * You can trigger a specific pipeline that is defined in your `bitbucket-pipelines.yml` file for a specific commit.
   * In addition to the commit revision, you specify the type and pattern of the selector that identifies the pipeline definition. The resulting pipeline will then clone the repository and checkout the specified revision.
   *
   * ### Example
   *
   * ```
   * $ curl -X POST -is -u username:password \
   *   -H 'Content-Type: application/json' \
   *  https://api.bitbucket.org/2.0/repositories/jeroendr/meat-demo2/pipelines/ \
   *  -d '
   *   {
   *      "target": {
   *       "commit": {
   *          "hash":"a3c4e02c9a3755eccdc3764e6ea13facdf30f923",
   *          "type":"commit"
   *        },
   *         "selector": {
   *            "type":"custom",
   *               "pattern":"Deploy to production"
   *           },
   *         "type":"pipeline_commit_target"
   *    }
   *   }'
   * ```
   * # Trigger a specific pipeline definition for a commit on a branch or tag
   * You can trigger a specific pipeline that is defined in your `bitbucket-pipelines.yml` file for a specific commit in the context of a specified reference.
   * In addition to the commit revision, you specify the type and pattern of the selector that identifies the pipeline definition, as well as the reference information. The resulting pipeline will then clone the repository a checkout the specified reference.
   *
   * ### Example
   *
   * ```
   * $ curl -X POST -is -u username:password \
   *   -H 'Content-Type: application/json' \
   *  https://api.bitbucket.org/2.0/repositories/jeroendr/meat-demo2/pipelines/ \
   *  -d '
   *   {
   *      "target": {
   *       "commit": {
   *          "hash":"a3c4e02c9a3755eccdc3764e6ea13facdf30f923",
   *          "type":"commit"
   *        },
   *        "selector": {
   *           "type": "custom",
   *           "pattern": "Deploy to production"
   *        },
   *        "type": "pipeline_ref_target",
   *        "ref_name": "master",
   *        "ref_type": "branch"
   *      }
   *   }'
   * ```
   *
   *
   * # Trigger a custom pipeline with variables
   * In addition to triggering a custom pipeline that is defined in your `bitbucket-pipelines.yml` file as shown in the examples above, you can specify variables that will be available for your build. In the request, provide a list of variables, specifying the following for each variable: key, value, and whether it should be secured or not (this field is optional and defaults to not secured).
   *
   * ### Example
   *
   * ```
   * $ curl -X POST -is -u username:password \
   *   -H 'Content-Type: application/json' \
   *  https://api.bitbucket.org/2.0/repositories/{workspace}/{repo_slug}/pipelines/ \
   *  -d '
   *   {
   *     "target": {
   *       "type": "pipeline_ref_target",
   *       "ref_type": "branch",
   *       "ref_name": "master",
   *       "selector": {
   *         "type": "custom",
   *         "pattern": "Deploy to production"
   *       }
   *     },
   *     "variables": [
   *       {
   *         "key": "var1key",
   *         "value": "var1value",
   *         "secured": true
   *       },
   *       {
   *         "key": "var2key",
   *         "value": "var2value"
   *       }
   *     ]
   *   }'
   * ```
   *
   * # Trigger a pull request pipeline
   *
   * You can also initiate a pipeline for a specific pull request.
   *
   * ### Example
   *
   * ```
   * $ curl -X POST -is -u username:password \
   *   -H 'Content-Type: application/json' \
   *  https://api.bitbucket.org/2.0/repositories/{workspace}/{repo_slug}/pipelines/ \
   *  -d '
   *   {
   * 	"target": {
   *       "type": "pipeline_pullrequest_target",
   * 	  "source": "pull-request-branch",
   *       "destination": "master",
   *       "destination_commit": {
   *       	 "hash" : "9f848b7"
   *       },
   *       "commit": {
   *       	"hash" : "1a372fc"
   *       },
   *       "pullrequest" : {
   *       	"id" : "3"
   *       },
   * 	  "selector": {
   *         "type": "pull-requests",
   *         "pattern": "**"
   *       }
   *     }
   *   }'
   * ```
   *
   */
  createPipelineForRepository(
    req: operations.CreatePipelineForRepositoryRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.CreatePipelineForRepositoryResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CreatePipelineForRepositoryRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/repositories/{workspace}/{repo_slug}/pipelines/",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CreatePipelineForRepositoryResponse =
        new operations.CreatePipelineForRepositoryResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
          headers: utils.getHeadersFromResponse(httpRes.headers),
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.pipeline = utils.objectToClass(httpRes?.data);
          }
          break;
        case [400, 404].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.error = utils.objectToClass(httpRes?.data);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Create a variable for a user
   *
   * @remarks
   * Create an account level variable.
   * This endpoint has been deprecated, and you should use the new workspaces endpoint. For more information, see [the announcement](https://developer.atlassian.com/cloud/bitbucket/bitbucket-api-teams-deprecation/).
   */
  createPipelineVariableForTeam(
    req: operations.CreatePipelineVariableForTeamRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.CreatePipelineVariableForTeamResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CreatePipelineVariableForTeamRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/teams/{username}/pipelines_config/variables/",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CreatePipelineVariableForTeamResponse =
        new operations.CreatePipelineVariableForTeamResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
          headers: utils.getHeadersFromResponse(httpRes.headers),
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.pipelineVariable = utils.objectToClass(httpRes?.data);
          }
          break;
        case [404, 409].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.error = utils.objectToClass(httpRes?.data);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Create a variable for a user
   *
   * @remarks
   * Create a user level variable.
   * This endpoint has been deprecated, and you should use the new workspaces endpoint. For more information, see [the announcement](https://developer.atlassian.com/cloud/bitbucket/bitbucket-api-teams-deprecation/).
   */
  createPipelineVariableForUser(
    req: operations.CreatePipelineVariableForUserRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.CreatePipelineVariableForUserResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CreatePipelineVariableForUserRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/users/{selected_user}/pipelines_config/variables/",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CreatePipelineVariableForUserResponse =
        new operations.CreatePipelineVariableForUserResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
          headers: utils.getHeadersFromResponse(httpRes.headers),
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.pipelineVariable = utils.objectToClass(httpRes?.data);
          }
          break;
        case [404, 409].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.error = utils.objectToClass(httpRes?.data);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Create a variable for a workspace
   *
   * @remarks
   * Create a workspace level variable.
   */
  createPipelineVariableForWorkspace(
    req: operations.CreatePipelineVariableForWorkspaceRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.CreatePipelineVariableForWorkspaceResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CreatePipelineVariableForWorkspaceRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/workspaces/{workspace}/pipelines-config/variables",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CreatePipelineVariableForWorkspaceResponse =
        new operations.CreatePipelineVariableForWorkspaceResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
          headers: utils.getHeadersFromResponse(httpRes.headers),
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.pipelineVariable = utils.objectToClass(httpRes?.data);
          }
          break;
        case [404, 409].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.error = utils.objectToClass(httpRes?.data);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Create a known host
   *
   * @remarks
   * Create a repository level known host.
   */
  createRepositoryPipelineKnownHost(
    req: operations.CreateRepositoryPipelineKnownHostRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.CreateRepositoryPipelineKnownHostResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CreateRepositoryPipelineKnownHostRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/repositories/{workspace}/{repo_slug}/pipelines_config/ssh/known_hosts/",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CreateRepositoryPipelineKnownHostResponse =
        new operations.CreateRepositoryPipelineKnownHostResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
          headers: utils.getHeadersFromResponse(httpRes.headers),
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.pipelineKnownHost = utils.objectToClass(httpRes?.data);
          }
          break;
        case [404, 409].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.error = utils.objectToClass(httpRes?.data);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Create a schedule
   *
   * @remarks
   * Create a schedule for the given repository.
   */
  createRepositoryPipelineSchedule(
    req: operations.CreateRepositoryPipelineScheduleRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.CreateRepositoryPipelineScheduleResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CreateRepositoryPipelineScheduleRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/repositories/{workspace}/{repo_slug}/pipelines_config/schedules/",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CreateRepositoryPipelineScheduleResponse =
        new operations.CreateRepositoryPipelineScheduleResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.pipelineSchedule = utils.objectToClass(httpRes?.data);
          }
          break;
        case [400, 401, 404].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.error = utils.objectToClass(httpRes?.data);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Create a variable for a repository
   *
   * @remarks
   * Create a repository level variable.
   */
  createRepositoryPipelineVariable(
    req: operations.CreateRepositoryPipelineVariableRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.CreateRepositoryPipelineVariableResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CreateRepositoryPipelineVariableRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/repositories/{workspace}/{repo_slug}/pipelines_config/variables/",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CreateRepositoryPipelineVariableResponse =
        new operations.CreateRepositoryPipelineVariableResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
          headers: utils.getHeadersFromResponse(httpRes.headers),
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.pipelineVariable = utils.objectToClass(httpRes?.data);
          }
          break;
        case [404, 409].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.error = utils.objectToClass(httpRes?.data);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Delete a variable for an environment
   *
   * @remarks
   * Delete a deployment environment level variable.
   */
  deleteDeploymentVariable(
    req: operations.DeleteDeploymentVariableRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.DeleteDeploymentVariableResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DeleteDeploymentVariableRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/repositories/{workspace}/{repo_slug}/deployments_config/environments/{environment_uuid}/variables/{variable_uuid}",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const r = client.request({
      url: url,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DeleteDeploymentVariableResponse =
        new operations.DeleteDeploymentVariableResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
        case httpRes?.status == 404:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.error = utils.objectToClass(httpRes?.data);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Delete a variable for a team
   *
   * @remarks
   * Delete a team level variable.
   * This endpoint has been deprecated, and you should use the new workspaces endpoint. For more information, see [the announcement](https://developer.atlassian.com/cloud/bitbucket/bitbucket-api-teams-deprecation/).
   */
  deletePipelineVariableForTeam(
    req: operations.DeletePipelineVariableForTeamRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.DeletePipelineVariableForTeamResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DeletePipelineVariableForTeamRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/teams/{username}/pipelines_config/variables/{variable_uuid}",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const r = client.request({
      url: url,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DeletePipelineVariableForTeamResponse =
        new operations.DeletePipelineVariableForTeamResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
        case httpRes?.status == 404:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.error = utils.objectToClass(httpRes?.data);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Delete a variable for a user
   *
   * @remarks
   * Delete an account level variable.
   * This endpoint has been deprecated, and you should use the new workspaces endpoint. For more information, see [the announcement](https://developer.atlassian.com/cloud/bitbucket/bitbucket-api-teams-deprecation/).
   */
  deletePipelineVariableForUser(
    req: operations.DeletePipelineVariableForUserRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.DeletePipelineVariableForUserResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DeletePipelineVariableForUserRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/users/{selected_user}/pipelines_config/variables/{variable_uuid}",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const r = client.request({
      url: url,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DeletePipelineVariableForUserResponse =
        new operations.DeletePipelineVariableForUserResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
        case httpRes?.status == 404:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.error = utils.objectToClass(httpRes?.data);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Delete a variable for a workspace
   *
   * @remarks
   * Delete a workspace level variable.
   */
  deletePipelineVariableForWorkspace(
    req: operations.DeletePipelineVariableForWorkspaceRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.DeletePipelineVariableForWorkspaceResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DeletePipelineVariableForWorkspaceRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/workspaces/{workspace}/pipelines-config/variables/{variable_uuid}",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const r = client.request({
      url: url,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DeletePipelineVariableForWorkspaceResponse =
        new operations.DeletePipelineVariableForWorkspaceResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
        case httpRes?.status == 404:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.error = utils.objectToClass(httpRes?.data);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Delete a cache
   *
   * @remarks
   * Delete a repository cache.
   */
  deleteRepositoryPipelineCache(
    req: operations.DeleteRepositoryPipelineCacheRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.DeleteRepositoryPipelineCacheResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DeleteRepositoryPipelineCacheRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/repositories/{workspace}/{repo_slug}/pipelines-config/caches/{cache_uuid}",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const r = client.request({
      url: url,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DeleteRepositoryPipelineCacheResponse =
        new operations.DeleteRepositoryPipelineCacheResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
        case httpRes?.status == 404:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.error = utils.objectToClass(httpRes?.data);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Delete caches
   *
   * @remarks
   * Delete repository cache versions by name.
   */
  deleteRepositoryPipelineCaches(
    req: operations.DeleteRepositoryPipelineCachesRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.DeleteRepositoryPipelineCachesResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DeleteRepositoryPipelineCachesRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/repositories/{workspace}/{repo_slug}/pipelines-config/caches",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DeleteRepositoryPipelineCachesResponse =
        new operations.DeleteRepositoryPipelineCachesResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
        case httpRes?.status == 404:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.error = utils.objectToClass(httpRes?.data);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Delete SSH key pair
   *
   * @remarks
   * Delete the repository SSH key pair.
   */
  deleteRepositoryPipelineKeyPair(
    req: operations.DeleteRepositoryPipelineKeyPairRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.DeleteRepositoryPipelineKeyPairResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DeleteRepositoryPipelineKeyPairRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/repositories/{workspace}/{repo_slug}/pipelines_config/ssh/key_pair",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const r = client.request({
      url: url,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DeleteRepositoryPipelineKeyPairResponse =
        new operations.DeleteRepositoryPipelineKeyPairResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
        case httpRes?.status == 404:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.error = utils.objectToClass(httpRes?.data);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Delete a known host
   *
   * @remarks
   * Delete a repository level known host.
   */
  deleteRepositoryPipelineKnownHost(
    req: operations.DeleteRepositoryPipelineKnownHostRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.DeleteRepositoryPipelineKnownHostResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DeleteRepositoryPipelineKnownHostRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/repositories/{workspace}/{repo_slug}/pipelines_config/ssh/known_hosts/{known_host_uuid}",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const r = client.request({
      url: url,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DeleteRepositoryPipelineKnownHostResponse =
        new operations.DeleteRepositoryPipelineKnownHostResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
        case httpRes?.status == 404:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.error = utils.objectToClass(httpRes?.data);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Delete a schedule
   *
   * @remarks
   * Delete a schedule.
   */
  deleteRepositoryPipelineSchedule(
    req: operations.DeleteRepositoryPipelineScheduleRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.DeleteRepositoryPipelineScheduleResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DeleteRepositoryPipelineScheduleRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/repositories/{workspace}/{repo_slug}/pipelines_config/schedules/{schedule_uuid}",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const r = client.request({
      url: url,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DeleteRepositoryPipelineScheduleResponse =
        new operations.DeleteRepositoryPipelineScheduleResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
        case httpRes?.status == 404:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.error = utils.objectToClass(httpRes?.data);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Delete a variable for a repository
   *
   * @remarks
   * Delete a repository level variable.
   */
  deleteRepositoryPipelineVariable(
    req: operations.DeleteRepositoryPipelineVariableRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.DeleteRepositoryPipelineVariableResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DeleteRepositoryPipelineVariableRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/repositories/{workspace}/{repo_slug}/pipelines_config/variables/{variable_uuid}",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const r = client.request({
      url: url,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DeleteRepositoryPipelineVariableResponse =
        new operations.DeleteRepositoryPipelineVariableResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
        case httpRes?.status == 404:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.error = utils.objectToClass(httpRes?.data);
          }
          break;
      }

      return res;
    });
  }

  /**
   * List variables for an environment
   *
   * @remarks
   * Find deployment environment level variables.
   */
  getDeploymentVariables(
    req: operations.GetDeploymentVariablesRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetDeploymentVariablesResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetDeploymentVariablesRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/repositories/{workspace}/{repo_slug}/deployments_config/environments/{environment_uuid}/variables",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetDeploymentVariablesResponse =
        new operations.GetDeploymentVariablesResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.paginatedDeploymentVariable = utils.objectToClass(
              httpRes?.data,
              shared.PaginatedDeploymentVariable
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Get OpenID configuration for OIDC in Pipelines
   *
   * @remarks
   * This is part of OpenID Connect for Pipelines, see https://support.atlassian.com/bitbucket-cloud/docs/integrate-pipelines-with-resource-servers-using-oidc/
   */
  getOIDCConfiguration(
    req: operations.GetOIDCConfigurationRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetOIDCConfigurationResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetOIDCConfigurationRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/workspaces/{workspace}/pipelines-config/identity/oidc/.well-known/openid-configuration",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetOIDCConfigurationResponse =
        new operations.GetOIDCConfigurationResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          break;
        case httpRes?.status == 404:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.error = utils.objectToClass(httpRes?.data);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Get keys for OIDC in Pipelines
   *
   * @remarks
   * This is part of OpenID Connect for Pipelines, see https://support.atlassian.com/bitbucket-cloud/docs/integrate-pipelines-with-resource-servers-using-oidc/
   */
  getOIDCKeys(
    req: operations.GetOIDCKeysRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetOIDCKeysResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetOIDCKeysRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/workspaces/{workspace}/pipelines-config/identity/oidc/keys.json",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetOIDCKeysResponse =
        new operations.GetOIDCKeysResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          break;
        case httpRes?.status == 404:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.error = utils.objectToClass(httpRes?.data);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Get the logs for the build container or a service container for a given step of a pipeline.
   *
   * @remarks
   * Retrieve the log file for a build container or service container.
   *
   * This endpoint supports (and encourages!) the use of [HTTP Range requests](https://tools.ietf.org/html/rfc7233) to deal with potentially very large log files.
   */
  getPipelineContainerLog(
    req: operations.GetPipelineContainerLogRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetPipelineContainerLogResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetPipelineContainerLogRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/repositories/{workspace}/{repo_slug}/pipelines/{pipeline_uuid}/steps/{step_uuid}/logs/{log_uuid}",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetPipelineContainerLogResponse =
        new operations.GetPipelineContainerLogResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          break;
        case httpRes?.status == 404:
          if (utils.matchContentType(contentType, `application/octet-stream`)) {
            const resBody: string = JSON.stringify(httpRes?.data, null, 0);
            const out: Uint8Array = new Uint8Array(resBody.length);
            for (let i = 0; i < resBody.length; i++)
              out[i] = resBody.charCodeAt(i);
            res.body = out;
          }
          break;
      }

      return res;
    });
  }

  /**
   * Get a pipeline
   *
   * @remarks
   * Retrieve a specified pipeline
   */
  getPipelineForRepository(
    req: operations.GetPipelineForRepositoryRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetPipelineForRepositoryResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetPipelineForRepositoryRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/repositories/{workspace}/{repo_slug}/pipelines/{pipeline_uuid}",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetPipelineForRepositoryResponse =
        new operations.GetPipelineForRepositoryResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.pipeline = utils.objectToClass(httpRes?.data);
          }
          break;
        case httpRes?.status == 404:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.error = utils.objectToClass(httpRes?.data);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Get a step of a pipeline
   *
   * @remarks
   * Retrieve a given step of a pipeline.
   */
  getPipelineStepForRepository(
    req: operations.GetPipelineStepForRepositoryRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetPipelineStepForRepositoryResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetPipelineStepForRepositoryRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/repositories/{workspace}/{repo_slug}/pipelines/{pipeline_uuid}/steps/{step_uuid}",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetPipelineStepForRepositoryResponse =
        new operations.GetPipelineStepForRepositoryResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.pipelineStep = utils.objectToClass(httpRes?.data);
          }
          break;
        case httpRes?.status == 404:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.error = utils.objectToClass(httpRes?.data);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Get log file for a step
   *
   * @remarks
   * Retrieve the log file for a given step of a pipeline.
   *
   * This endpoint supports (and encourages!) the use of [HTTP Range requests](https://tools.ietf.org/html/rfc7233) to deal with potentially very large log files.
   */
  getPipelineStepLogForRepository(
    req: operations.GetPipelineStepLogForRepositoryRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetPipelineStepLogForRepositoryResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetPipelineStepLogForRepositoryRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/repositories/{workspace}/{repo_slug}/pipelines/{pipeline_uuid}/steps/{step_uuid}/log",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetPipelineStepLogForRepositoryResponse =
        new operations.GetPipelineStepLogForRepositoryResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          break;
        case [304, 404, 416].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/octet-stream`)) {
            const resBody: string = JSON.stringify(httpRes?.data, null, 0);
            const out: Uint8Array = new Uint8Array(resBody.length);
            for (let i = 0; i < resBody.length; i++)
              out[i] = resBody.charCodeAt(i);
            res.body = out;
          }
          break;
      }

      return res;
    });
  }

  /**
   * List steps for a pipeline
   *
   * @remarks
   * Find steps for the given pipeline.
   */
  getPipelineStepsForRepository(
    req: operations.GetPipelineStepsForRepositoryRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetPipelineStepsForRepositoryResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetPipelineStepsForRepositoryRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/repositories/{workspace}/{repo_slug}/pipelines/{pipeline_uuid}/steps/",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetPipelineStepsForRepositoryResponse =
        new operations.GetPipelineStepsForRepositoryResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.paginatedPipelineSteps = utils.objectToClass(
              httpRes?.data,
              shared.PaginatedPipelineSteps
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Get test case reasons (output) for a given test case in a step of a pipeline.
   */
  getPipelineTestReportTestCaseReasons(
    req: operations.GetPipelineTestReportTestCaseReasonsRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetPipelineTestReportTestCaseReasonsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetPipelineTestReportTestCaseReasonsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/repositories/{workspace}/{repo_slug}/pipelines/{pipeline_uuid}/steps/{step_uuid}/test_reports/test_cases/{test_case_uuid}/test_case_reasons",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetPipelineTestReportTestCaseReasonsResponse =
        new operations.GetPipelineTestReportTestCaseReasonsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          break;
        case httpRes?.status == 404:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.error = utils.objectToClass(httpRes?.data);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Get test cases for a given step of a pipeline.
   */
  getPipelineTestReportTestCases(
    req: operations.GetPipelineTestReportTestCasesRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetPipelineTestReportTestCasesResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetPipelineTestReportTestCasesRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/repositories/{workspace}/{repo_slug}/pipelines/{pipeline_uuid}/steps/{step_uuid}/test_reports/test_cases",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetPipelineTestReportTestCasesResponse =
        new operations.GetPipelineTestReportTestCasesResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          break;
        case httpRes?.status == 404:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.error = utils.objectToClass(httpRes?.data);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Get a summary of test reports for a given step of a pipeline.
   */
  getPipelineTestReports(
    req: operations.GetPipelineTestReportsRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetPipelineTestReportsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetPipelineTestReportsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/repositories/{workspace}/{repo_slug}/pipelines/{pipeline_uuid}/steps/{step_uuid}/test_reports",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetPipelineTestReportsResponse =
        new operations.GetPipelineTestReportsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          break;
        case httpRes?.status == 404:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.error = utils.objectToClass(httpRes?.data);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Get a variable for a team
   *
   * @remarks
   * Retrieve a team level variable.
   * This endpoint has been deprecated, and you should use the new workspaces endpoint. For more information, see [the announcement](https://developer.atlassian.com/cloud/bitbucket/bitbucket-api-teams-deprecation/).
   */
  getPipelineVariableForTeam(
    req: operations.GetPipelineVariableForTeamRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetPipelineVariableForTeamResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetPipelineVariableForTeamRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/teams/{username}/pipelines_config/variables/{variable_uuid}",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetPipelineVariableForTeamResponse =
        new operations.GetPipelineVariableForTeamResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.pipelineVariable = utils.objectToClass(httpRes?.data);
          }
          break;
        case httpRes?.status == 404:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.error = utils.objectToClass(httpRes?.data);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Get a variable for a user
   *
   * @remarks
   * Retrieve a user level variable.
   * This endpoint has been deprecated, and you should use the new workspaces endpoint. For more information, see [the announcement](https://developer.atlassian.com/cloud/bitbucket/bitbucket-api-teams-deprecation/).
   */
  getPipelineVariableForUser(
    req: operations.GetPipelineVariableForUserRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetPipelineVariableForUserResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetPipelineVariableForUserRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/users/{selected_user}/pipelines_config/variables/{variable_uuid}",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetPipelineVariableForUserResponse =
        new operations.GetPipelineVariableForUserResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.pipelineVariable = utils.objectToClass(httpRes?.data);
          }
          break;
        case httpRes?.status == 404:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.error = utils.objectToClass(httpRes?.data);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Get variable for a workspace
   *
   * @remarks
   * Retrieve a workspace level variable.
   */
  getPipelineVariableForWorkspace(
    req: operations.GetPipelineVariableForWorkspaceRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetPipelineVariableForWorkspaceResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetPipelineVariableForWorkspaceRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/workspaces/{workspace}/pipelines-config/variables/{variable_uuid}",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetPipelineVariableForWorkspaceResponse =
        new operations.GetPipelineVariableForWorkspaceResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.pipelineVariable = utils.objectToClass(httpRes?.data);
          }
          break;
        case httpRes?.status == 404:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.error = utils.objectToClass(httpRes?.data);
          }
          break;
      }

      return res;
    });
  }

  /**
   * List variables for an account
   *
   * @remarks
   * Find account level variables.
   * This endpoint has been deprecated, and you should use the new workspaces endpoint. For more information, see [the announcement](https://developer.atlassian.com/cloud/bitbucket/bitbucket-api-teams-deprecation/).
   */
  getPipelineVariablesForTeam(
    req: operations.GetPipelineVariablesForTeamRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetPipelineVariablesForTeamResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetPipelineVariablesForTeamRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/teams/{username}/pipelines_config/variables/",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetPipelineVariablesForTeamResponse =
        new operations.GetPipelineVariablesForTeamResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.paginatedPipelineVariables = utils.objectToClass(
              httpRes?.data,
              shared.PaginatedPipelineVariables
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * List variables for a user
   *
   * @remarks
   * Find user level variables.
   * This endpoint has been deprecated, and you should use the new workspaces endpoint. For more information, see [the announcement](https://developer.atlassian.com/cloud/bitbucket/bitbucket-api-teams-deprecation/).
   */
  getPipelineVariablesForUser(
    req: operations.GetPipelineVariablesForUserRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetPipelineVariablesForUserResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetPipelineVariablesForUserRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/users/{selected_user}/pipelines_config/variables/",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetPipelineVariablesForUserResponse =
        new operations.GetPipelineVariablesForUserResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.paginatedPipelineVariables = utils.objectToClass(
              httpRes?.data,
              shared.PaginatedPipelineVariables
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * List variables for a workspace
   *
   * @remarks
   * Find workspace level variables.
   */
  getPipelineVariablesForWorkspace(
    req: operations.GetPipelineVariablesForWorkspaceRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetPipelineVariablesForWorkspaceResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetPipelineVariablesForWorkspaceRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/workspaces/{workspace}/pipelines-config/variables",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetPipelineVariablesForWorkspaceResponse =
        new operations.GetPipelineVariablesForWorkspaceResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.paginatedPipelineVariables = utils.objectToClass(
              httpRes?.data,
              shared.PaginatedPipelineVariables
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * List pipelines
   *
   * @remarks
   * Find pipelines
   */
  getPipelinesForRepository(
    req: operations.GetPipelinesForRepositoryRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetPipelinesForRepositoryResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetPipelinesForRepositoryRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/repositories/{workspace}/{repo_slug}/pipelines/",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetPipelinesForRepositoryResponse =
        new operations.GetPipelinesForRepositoryResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.paginatedPipelines = utils.objectToClass(
              httpRes?.data,
              shared.PaginatedPipelines
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Get cache content URI
   *
   * @remarks
   * Retrieve the URI of the content of the specified cache.
   */
  getRepositoryPipelineCacheContentURI(
    req: operations.GetRepositoryPipelineCacheContentURIRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetRepositoryPipelineCacheContentURIResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetRepositoryPipelineCacheContentURIRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/repositories/{workspace}/{repo_slug}/pipelines-config/caches/{cache_uuid}/content-uri",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetRepositoryPipelineCacheContentURIResponse =
        new operations.GetRepositoryPipelineCacheContentURIResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.pipelineCacheContentUri = utils.objectToClass(
              httpRes?.data,
              shared.PipelineCacheContentUri
            );
          }
          break;
        case httpRes?.status == 404:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.error = utils.objectToClass(httpRes?.data);
          }
          break;
      }

      return res;
    });
  }

  /**
   * List caches
   *
   * @remarks
   * Retrieve the repository pipelines caches.
   */
  getRepositoryPipelineCaches(
    req: operations.GetRepositoryPipelineCachesRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetRepositoryPipelineCachesResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetRepositoryPipelineCachesRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/repositories/{workspace}/{repo_slug}/pipelines-config/caches/",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetRepositoryPipelineCachesResponse =
        new operations.GetRepositoryPipelineCachesResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.paginatedPipelineCaches = utils.objectToClass(
              httpRes?.data,
              shared.PaginatedPipelineCaches
            );
          }
          break;
        case httpRes?.status == 404:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.error = utils.objectToClass(httpRes?.data);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Get configuration
   *
   * @remarks
   * Retrieve the repository pipelines configuration.
   */
  getRepositoryPipelineConfig(
    req: operations.GetRepositoryPipelineConfigRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetRepositoryPipelineConfigResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetRepositoryPipelineConfigRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/repositories/{workspace}/{repo_slug}/pipelines_config",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetRepositoryPipelineConfigResponse =
        new operations.GetRepositoryPipelineConfigResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.pipelinesConfig = utils.objectToClass(httpRes?.data);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Get a known host
   *
   * @remarks
   * Retrieve a repository level known host.
   */
  getRepositoryPipelineKnownHost(
    req: operations.GetRepositoryPipelineKnownHostRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetRepositoryPipelineKnownHostResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetRepositoryPipelineKnownHostRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/repositories/{workspace}/{repo_slug}/pipelines_config/ssh/known_hosts/{known_host_uuid}",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetRepositoryPipelineKnownHostResponse =
        new operations.GetRepositoryPipelineKnownHostResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.pipelineKnownHost = utils.objectToClass(httpRes?.data);
          }
          break;
        case httpRes?.status == 404:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.error = utils.objectToClass(httpRes?.data);
          }
          break;
      }

      return res;
    });
  }

  /**
   * List known hosts
   *
   * @remarks
   * Find repository level known hosts.
   */
  getRepositoryPipelineKnownHosts(
    req: operations.GetRepositoryPipelineKnownHostsRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetRepositoryPipelineKnownHostsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetRepositoryPipelineKnownHostsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/repositories/{workspace}/{repo_slug}/pipelines_config/ssh/known_hosts/",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetRepositoryPipelineKnownHostsResponse =
        new operations.GetRepositoryPipelineKnownHostsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.paginatedPipelineKnownHosts = utils.objectToClass(
              httpRes?.data,
              shared.PaginatedPipelineKnownHosts
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Get a schedule
   *
   * @remarks
   * Retrieve a schedule by its UUID.
   */
  getRepositoryPipelineSchedule(
    req: operations.GetRepositoryPipelineScheduleRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetRepositoryPipelineScheduleResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetRepositoryPipelineScheduleRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/repositories/{workspace}/{repo_slug}/pipelines_config/schedules/{schedule_uuid}",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetRepositoryPipelineScheduleResponse =
        new operations.GetRepositoryPipelineScheduleResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.pipelineSchedule = utils.objectToClass(httpRes?.data);
          }
          break;
        case httpRes?.status == 404:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.error = utils.objectToClass(httpRes?.data);
          }
          break;
      }

      return res;
    });
  }

  /**
   * List executions of a schedule
   *
   * @remarks
   * Retrieve the executions of a given schedule.
   */
  getRepositoryPipelineScheduleExecutions(
    req: operations.GetRepositoryPipelineScheduleExecutionsRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetRepositoryPipelineScheduleExecutionsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetRepositoryPipelineScheduleExecutionsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/repositories/{workspace}/{repo_slug}/pipelines_config/schedules/{schedule_uuid}/executions/",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetRepositoryPipelineScheduleExecutionsResponse =
        new operations.GetRepositoryPipelineScheduleExecutionsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.paginatedPipelineScheduleExecutions = utils.objectToClass(
              httpRes?.data,
              shared.PaginatedPipelineScheduleExecutions
            );
          }
          break;
        case httpRes?.status == 404:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.error = utils.objectToClass(httpRes?.data);
          }
          break;
      }

      return res;
    });
  }

  /**
   * List schedules
   *
   * @remarks
   * Retrieve the configured schedules for the given repository.
   */
  getRepositoryPipelineSchedules(
    req: operations.GetRepositoryPipelineSchedulesRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetRepositoryPipelineSchedulesResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetRepositoryPipelineSchedulesRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/repositories/{workspace}/{repo_slug}/pipelines_config/schedules/",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetRepositoryPipelineSchedulesResponse =
        new operations.GetRepositoryPipelineSchedulesResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.paginatedPipelineSchedules = utils.objectToClass(
              httpRes?.data,
              shared.PaginatedPipelineSchedules
            );
          }
          break;
        case httpRes?.status == 404:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.error = utils.objectToClass(httpRes?.data);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Get SSH key pair
   *
   * @remarks
   * Retrieve the repository SSH key pair excluding the SSH private key. The private key is a write only field and will never be exposed in the logs or the REST API.
   */
  getRepositoryPipelineSshKeyPair(
    req: operations.GetRepositoryPipelineSshKeyPairRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetRepositoryPipelineSshKeyPairResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetRepositoryPipelineSshKeyPairRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/repositories/{workspace}/{repo_slug}/pipelines_config/ssh/key_pair",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetRepositoryPipelineSshKeyPairResponse =
        new operations.GetRepositoryPipelineSshKeyPairResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.pipelineSshKeyPair = utils.objectToClass(httpRes?.data);
          }
          break;
        case httpRes?.status == 404:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.error = utils.objectToClass(httpRes?.data);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Get a variable for a repository
   *
   * @remarks
   * Retrieve a repository level variable.
   */
  getRepositoryPipelineVariable(
    req: operations.GetRepositoryPipelineVariableRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetRepositoryPipelineVariableResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetRepositoryPipelineVariableRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/repositories/{workspace}/{repo_slug}/pipelines_config/variables/{variable_uuid}",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetRepositoryPipelineVariableResponse =
        new operations.GetRepositoryPipelineVariableResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.pipelineVariable = utils.objectToClass(httpRes?.data);
          }
          break;
        case httpRes?.status == 404:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.error = utils.objectToClass(httpRes?.data);
          }
          break;
      }

      return res;
    });
  }

  /**
   * List variables for a repository
   *
   * @remarks
   * Find repository level variables.
   */
  getRepositoryPipelineVariables(
    req: operations.GetRepositoryPipelineVariablesRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetRepositoryPipelineVariablesResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetRepositoryPipelineVariablesRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/repositories/{workspace}/{repo_slug}/pipelines_config/variables/",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetRepositoryPipelineVariablesResponse =
        new operations.GetRepositoryPipelineVariablesResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.paginatedPipelineVariables = utils.objectToClass(
              httpRes?.data,
              shared.PaginatedPipelineVariables
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Stop a pipeline
   *
   * @remarks
   * Signal the stop of a pipeline and all of its steps that not have completed yet.
   */
  stopPipeline(
    req: operations.StopPipelineRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.StopPipelineResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.StopPipelineRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/repositories/{workspace}/{repo_slug}/pipelines/{pipeline_uuid}/stopPipeline",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const r = client.request({
      url: url,
      method: "post",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.StopPipelineResponse =
        new operations.StopPipelineResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
        case [400, 404].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.error = utils.objectToClass(httpRes?.data);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Update a variable for an environment
   *
   * @remarks
   * Update a deployment environment level variable.
   */
  updateDeploymentVariable(
    req: operations.UpdateDeploymentVariableRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.UpdateDeploymentVariableResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.UpdateDeploymentVariableRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/repositories/{workspace}/{repo_slug}/deployments_config/environments/{environment_uuid}/variables/{variable_uuid}",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "put",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UpdateDeploymentVariableResponse =
        new operations.UpdateDeploymentVariableResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.deploymentVariable = utils.objectToClass(httpRes?.data);
          }
          break;
        case httpRes?.status == 404:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.error = utils.objectToClass(httpRes?.data);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Update a variable for a team
   *
   * @remarks
   * Update a team level variable.
   * This endpoint has been deprecated, and you should use the new workspaces endpoint. For more information, see [the announcement](https://developer.atlassian.com/cloud/bitbucket/bitbucket-api-teams-deprecation/).
   */
  updatePipelineVariableForTeam(
    req: operations.UpdatePipelineVariableForTeamRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.UpdatePipelineVariableForTeamResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.UpdatePipelineVariableForTeamRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/teams/{username}/pipelines_config/variables/{variable_uuid}",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "put",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UpdatePipelineVariableForTeamResponse =
        new operations.UpdatePipelineVariableForTeamResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.pipelineVariable = utils.objectToClass(httpRes?.data);
          }
          break;
        case httpRes?.status == 404:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.error = utils.objectToClass(httpRes?.data);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Update a variable for a user
   *
   * @remarks
   * Update a user level variable.
   * This endpoint has been deprecated, and you should use the new workspaces endpoint. For more information, see [the announcement](https://developer.atlassian.com/cloud/bitbucket/bitbucket-api-teams-deprecation/).
   */
  updatePipelineVariableForUser(
    req: operations.UpdatePipelineVariableForUserRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.UpdatePipelineVariableForUserResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.UpdatePipelineVariableForUserRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/users/{selected_user}/pipelines_config/variables/{variable_uuid}",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "put",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UpdatePipelineVariableForUserResponse =
        new operations.UpdatePipelineVariableForUserResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.pipelineVariable = utils.objectToClass(httpRes?.data);
          }
          break;
        case httpRes?.status == 404:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.error = utils.objectToClass(httpRes?.data);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Update variable for a workspace
   *
   * @remarks
   * Update a workspace level variable.
   */
  updatePipelineVariableForWorkspace(
    req: operations.UpdatePipelineVariableForWorkspaceRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.UpdatePipelineVariableForWorkspaceResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.UpdatePipelineVariableForWorkspaceRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/workspaces/{workspace}/pipelines-config/variables/{variable_uuid}",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "put",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UpdatePipelineVariableForWorkspaceResponse =
        new operations.UpdatePipelineVariableForWorkspaceResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.pipelineVariable = utils.objectToClass(httpRes?.data);
          }
          break;
        case httpRes?.status == 404:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.error = utils.objectToClass(httpRes?.data);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Update the next build number
   *
   * @remarks
   * Update the next build number that should be assigned to a pipeline. The next build number that will be configured has to be strictly higher than the current latest build number for this repository.
   */
  updateRepositoryBuildNumber(
    req: operations.UpdateRepositoryBuildNumberRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.UpdateRepositoryBuildNumberResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.UpdateRepositoryBuildNumberRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/repositories/{workspace}/{repo_slug}/pipelines_config/build_number",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "put",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UpdateRepositoryBuildNumberResponse =
        new operations.UpdateRepositoryBuildNumberResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.pipelineBuildNumber = utils.objectToClass(httpRes?.data);
          }
          break;
        case [400, 404].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.error = utils.objectToClass(httpRes?.data);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Update configuration
   *
   * @remarks
   * Update the pipelines configuration for a repository.
   */
  updateRepositoryPipelineConfig(
    req: operations.UpdateRepositoryPipelineConfigRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.UpdateRepositoryPipelineConfigResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.UpdateRepositoryPipelineConfigRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/repositories/{workspace}/{repo_slug}/pipelines_config",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "put",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UpdateRepositoryPipelineConfigResponse =
        new operations.UpdateRepositoryPipelineConfigResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.pipelinesConfig = utils.objectToClass(httpRes?.data);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Update SSH key pair
   *
   * @remarks
   * Create or update the repository SSH key pair. The private key will be set as a default SSH identity in your build container.
   */
  updateRepositoryPipelineKeyPair(
    req: operations.UpdateRepositoryPipelineKeyPairRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.UpdateRepositoryPipelineKeyPairResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.UpdateRepositoryPipelineKeyPairRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/repositories/{workspace}/{repo_slug}/pipelines_config/ssh/key_pair",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "put",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UpdateRepositoryPipelineKeyPairResponse =
        new operations.UpdateRepositoryPipelineKeyPairResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.pipelineSshKeyPair = utils.objectToClass(httpRes?.data);
          }
          break;
        case httpRes?.status == 404:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.error = utils.objectToClass(httpRes?.data);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Update a known host
   *
   * @remarks
   * Update a repository level known host.
   */
  updateRepositoryPipelineKnownHost(
    req: operations.UpdateRepositoryPipelineKnownHostRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.UpdateRepositoryPipelineKnownHostResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.UpdateRepositoryPipelineKnownHostRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/repositories/{workspace}/{repo_slug}/pipelines_config/ssh/known_hosts/{known_host_uuid}",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "put",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UpdateRepositoryPipelineKnownHostResponse =
        new operations.UpdateRepositoryPipelineKnownHostResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.pipelineKnownHost = utils.objectToClass(httpRes?.data);
          }
          break;
        case httpRes?.status == 404:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.error = utils.objectToClass(httpRes?.data);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Update a schedule
   *
   * @remarks
   * Update a schedule.
   */
  updateRepositoryPipelineSchedule(
    req: operations.UpdateRepositoryPipelineScheduleRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.UpdateRepositoryPipelineScheduleResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.UpdateRepositoryPipelineScheduleRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/repositories/{workspace}/{repo_slug}/pipelines_config/schedules/{schedule_uuid}",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "put",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UpdateRepositoryPipelineScheduleResponse =
        new operations.UpdateRepositoryPipelineScheduleResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.pipelineSchedule = utils.objectToClass(httpRes?.data);
          }
          break;
        case httpRes?.status == 404:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.error = utils.objectToClass(httpRes?.data);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Update a variable for a repository
   *
   * @remarks
   * Update a repository level variable.
   */
  updateRepositoryPipelineVariable(
    req: operations.UpdateRepositoryPipelineVariableRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.UpdateRepositoryPipelineVariableResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.UpdateRepositoryPipelineVariableRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/repositories/{workspace}/{repo_slug}/pipelines_config/variables/{variable_uuid}",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "put",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UpdateRepositoryPipelineVariableResponse =
        new operations.UpdateRepositoryPipelineVariableResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.pipelineVariable = utils.objectToClass(httpRes?.data);
          }
          break;
        case httpRes?.status == 404:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.error = utils.objectToClass(httpRes?.data);
          }
          break;
      }

      return res;
    });
  }
}
