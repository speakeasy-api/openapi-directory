/*
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

import * as utils from "../internal/utils";
import * as operations from "./models/operations";
import * as shared from "./models/shared";
import { AxiosInstance, AxiosRequestConfig, AxiosResponse } from "axios";

export class Line {
  _defaultClient: AxiosInstance;
  _securityClient: AxiosInstance;
  _serverURL: string;
  _language: string;
  _sdkVersion: string;
  _genVersion: string;

  constructor(
    defaultClient: AxiosInstance,
    securityClient: AxiosInstance,
    serverURL: string,
    language: string,
    sdkVersion: string,
    genVersion: string
  ) {
    this._defaultClient = defaultClient;
    this._securityClient = securityClient;
    this._serverURL = serverURL;
    this._language = language;
    this._sdkVersion = sdkVersion;
    this._genVersion = genVersion;
  }

  /**
   * Get the list of arrival predictions for given line ids based at the given stop
   */
  lineArrivals(
    req: operations.LineArrivalsRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.LineArrivalsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.LineArrivalsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/Line/{ids}/Arrivals/{stopPointId}",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.LineArrivalsResponse =
        new operations.LineArrivalsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.tflApiPresentationEntitiesPredictions = [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.tflApiPresentationEntitiesPredictions = utils.objectToClass(
              httpRes?.data,
              shared.TflApiPresentationEntitiesPrediction,
              resFieldDepth
            );
          }
          if (utils.matchContentType(contentType, `text/json`)) {
            res.tflApiPresentationEntitiesPredictions = [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.tflApiPresentationEntitiesPredictions = utils.objectToClass(
              httpRes?.data,
              shared.TflApiPresentationEntitiesPrediction,
              resFieldDepth
            );
          }
          if (utils.matchContentType(contentType, `application/xml`)) {
            const resBody: string = JSON.stringify(httpRes?.data, null, 0);
            const out: Uint8Array = new Uint8Array(resBody.length);
            for (let i = 0; i < resBody.length; i++)
              out[i] = resBody.charCodeAt(i);
            res.body = out;
          }
          if (utils.matchContentType(contentType, `text/xml`)) {
            const resBody: string = JSON.stringify(httpRes?.data, null, 0);
            const out: Uint8Array = new Uint8Array(resBody.length);
            for (let i = 0; i < resBody.length; i++)
              out[i] = resBody.charCodeAt(i);
            res.body = out;
          }
          break;
      }

      return res;
    });
  }

  /**
   * Get disruptions for the given line ids
   */
  lineDisruption(
    req: operations.LineDisruptionRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.LineDisruptionResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.LineDisruptionRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/Line/{ids}/Disruption",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.LineDisruptionResponse =
        new operations.LineDisruptionResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.tflApiPresentationEntitiesDisruptions = [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.tflApiPresentationEntitiesDisruptions = utils.objectToClass(
              httpRes?.data,
              shared.TflApiPresentationEntitiesDisruption,
              resFieldDepth
            );
          }
          if (utils.matchContentType(contentType, `text/json`)) {
            res.tflApiPresentationEntitiesDisruptions = [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.tflApiPresentationEntitiesDisruptions = utils.objectToClass(
              httpRes?.data,
              shared.TflApiPresentationEntitiesDisruption,
              resFieldDepth
            );
          }
          if (utils.matchContentType(contentType, `application/xml`)) {
            const resBody: string = JSON.stringify(httpRes?.data, null, 0);
            const out: Uint8Array = new Uint8Array(resBody.length);
            for (let i = 0; i < resBody.length; i++)
              out[i] = resBody.charCodeAt(i);
            res.body = out;
          }
          if (utils.matchContentType(contentType, `text/xml`)) {
            const resBody: string = JSON.stringify(httpRes?.data, null, 0);
            const out: Uint8Array = new Uint8Array(resBody.length);
            for (let i = 0; i < resBody.length; i++)
              out[i] = resBody.charCodeAt(i);
            res.body = out;
          }
          break;
      }

      return res;
    });
  }

  /**
   * Get disruptions for all lines of the given modes.
   */
  lineDisruptionByMode(
    req: operations.LineDisruptionByModeRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.LineDisruptionByModeResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.LineDisruptionByModeRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/Line/Mode/{modes}/Disruption",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.LineDisruptionByModeResponse =
        new operations.LineDisruptionByModeResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.tflApiPresentationEntitiesDisruptions = [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.tflApiPresentationEntitiesDisruptions = utils.objectToClass(
              httpRes?.data,
              shared.TflApiPresentationEntitiesDisruption,
              resFieldDepth
            );
          }
          if (utils.matchContentType(contentType, `text/json`)) {
            res.tflApiPresentationEntitiesDisruptions = [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.tflApiPresentationEntitiesDisruptions = utils.objectToClass(
              httpRes?.data,
              shared.TflApiPresentationEntitiesDisruption,
              resFieldDepth
            );
          }
          if (utils.matchContentType(contentType, `application/xml`)) {
            const resBody: string = JSON.stringify(httpRes?.data, null, 0);
            const out: Uint8Array = new Uint8Array(resBody.length);
            for (let i = 0; i < resBody.length; i++)
              out[i] = resBody.charCodeAt(i);
            res.body = out;
          }
          if (utils.matchContentType(contentType, `text/xml`)) {
            const resBody: string = JSON.stringify(httpRes?.data, null, 0);
            const out: Uint8Array = new Uint8Array(resBody.length);
            for (let i = 0; i < resBody.length; i++)
              out[i] = resBody.charCodeAt(i);
            res.body = out;
          }
          break;
      }

      return res;
    });
  }

  /**
   * Gets lines that match the specified line ids.
   */
  lineGet(
    req: operations.LineGetRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.LineGetResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.LineGetRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(baseURL, "/Line/{ids}", req);

    const client: AxiosInstance = this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.LineGetResponse = new operations.LineGetResponse({
        statusCode: httpRes.status,
        contentType: contentType,
        rawResponse: httpRes,
      });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.tflApiPresentationEntitiesLines = [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.tflApiPresentationEntitiesLines = utils.objectToClass(
              httpRes?.data,
              shared.TflApiPresentationEntitiesLine,
              resFieldDepth
            );
          }
          if (utils.matchContentType(contentType, `text/json`)) {
            res.tflApiPresentationEntitiesLines = [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.tflApiPresentationEntitiesLines = utils.objectToClass(
              httpRes?.data,
              shared.TflApiPresentationEntitiesLine,
              resFieldDepth
            );
          }
          if (utils.matchContentType(contentType, `application/xml`)) {
            const resBody: string = JSON.stringify(httpRes?.data, null, 0);
            const out: Uint8Array = new Uint8Array(resBody.length);
            for (let i = 0; i < resBody.length; i++)
              out[i] = resBody.charCodeAt(i);
            res.body = out;
          }
          if (utils.matchContentType(contentType, `text/xml`)) {
            const resBody: string = JSON.stringify(httpRes?.data, null, 0);
            const out: Uint8Array = new Uint8Array(resBody.length);
            for (let i = 0; i < resBody.length; i++)
              out[i] = resBody.charCodeAt(i);
            res.body = out;
          }
          break;
      }

      return res;
    });
  }

  /**
   * Gets lines that serve the given modes.
   */
  lineGetByMode(
    req: operations.LineGetByModeRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.LineGetByModeResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.LineGetByModeRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(baseURL, "/Line/Mode/{modes}", req);

    const client: AxiosInstance = this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.LineGetByModeResponse =
        new operations.LineGetByModeResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.tflApiPresentationEntitiesLines = [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.tflApiPresentationEntitiesLines = utils.objectToClass(
              httpRes?.data,
              shared.TflApiPresentationEntitiesLine,
              resFieldDepth
            );
          }
          if (utils.matchContentType(contentType, `text/json`)) {
            res.tflApiPresentationEntitiesLines = [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.tflApiPresentationEntitiesLines = utils.objectToClass(
              httpRes?.data,
              shared.TflApiPresentationEntitiesLine,
              resFieldDepth
            );
          }
          if (utils.matchContentType(contentType, `application/xml`)) {
            const resBody: string = JSON.stringify(httpRes?.data, null, 0);
            const out: Uint8Array = new Uint8Array(resBody.length);
            for (let i = 0; i < resBody.length; i++)
              out[i] = resBody.charCodeAt(i);
            res.body = out;
          }
          if (utils.matchContentType(contentType, `text/xml`)) {
            const resBody: string = JSON.stringify(httpRes?.data, null, 0);
            const out: Uint8Array = new Uint8Array(resBody.length);
            for (let i = 0; i < resBody.length; i++)
              out[i] = resBody.charCodeAt(i);
            res.body = out;
          }
          break;
      }

      return res;
    });
  }

  /**
   * Get all valid routes for given line ids, including the name and id of the originating and terminating stops for each route.
   */
  lineLineRoutesByIds(
    req: operations.LineLineRoutesByIdsRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.LineLineRoutesByIdsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.LineLineRoutesByIdsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(baseURL, "/Line/{ids}/Route", req);

    const client: AxiosInstance = this._defaultClient;

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.LineLineRoutesByIdsResponse =
        new operations.LineLineRoutesByIdsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.tflApiPresentationEntitiesLines = [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.tflApiPresentationEntitiesLines = utils.objectToClass(
              httpRes?.data,
              shared.TflApiPresentationEntitiesLine,
              resFieldDepth
            );
          }
          if (utils.matchContentType(contentType, `text/json`)) {
            res.tflApiPresentationEntitiesLines = [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.tflApiPresentationEntitiesLines = utils.objectToClass(
              httpRes?.data,
              shared.TflApiPresentationEntitiesLine,
              resFieldDepth
            );
          }
          if (utils.matchContentType(contentType, `application/xml`)) {
            const resBody: string = JSON.stringify(httpRes?.data, null, 0);
            const out: Uint8Array = new Uint8Array(resBody.length);
            for (let i = 0; i < resBody.length; i++)
              out[i] = resBody.charCodeAt(i);
            res.body = out;
          }
          if (utils.matchContentType(contentType, `text/xml`)) {
            const resBody: string = JSON.stringify(httpRes?.data, null, 0);
            const out: Uint8Array = new Uint8Array(resBody.length);
            for (let i = 0; i < resBody.length; i++)
              out[i] = resBody.charCodeAt(i);
            res.body = out;
          }
          break;
      }

      return res;
    });
  }

  /**
   * Gets a list of valid disruption categories
   */
  lineMetaDisruptionCategories(
    config?: AxiosRequestConfig
  ): Promise<operations.LineMetaDisruptionCategoriesResponse> {
    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/Line/Meta/DisruptionCategories";

    const client: AxiosInstance = this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.LineMetaDisruptionCategoriesResponse =
        new operations.LineMetaDisruptionCategoriesResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.lineMetaDisruptionCategories200ApplicationJSONStrings =
              utils.objectToClass(httpRes?.data);
          }
          if (utils.matchContentType(contentType, `application/xml`)) {
            const resBody: string = JSON.stringify(httpRes?.data, null, 0);
            const out: Uint8Array = new Uint8Array(resBody.length);
            for (let i = 0; i < resBody.length; i++)
              out[i] = resBody.charCodeAt(i);
            res.body = out;
          }
          if (utils.matchContentType(contentType, `text/xml`)) {
            const resBody: string = JSON.stringify(httpRes?.data, null, 0);
            const out: Uint8Array = new Uint8Array(resBody.length);
            for (let i = 0; i < resBody.length; i++)
              out[i] = resBody.charCodeAt(i);
            res.body = out;
          }
          if (utils.matchContentType(contentType, `text/json`)) {
            res.lineMetaDisruptionCategories200TextJSONStrings =
              utils.objectToClass(httpRes?.data);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Gets a list of valid modes
   */
  lineMetaModes(
    config?: AxiosRequestConfig
  ): Promise<operations.LineMetaModesResponse> {
    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/Line/Meta/Modes";

    const client: AxiosInstance = this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.LineMetaModesResponse =
        new operations.LineMetaModesResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.tflApiPresentationEntitiesModes = [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.tflApiPresentationEntitiesModes = utils.objectToClass(
              httpRes?.data,
              shared.TflApiPresentationEntitiesMode,
              resFieldDepth
            );
          }
          if (utils.matchContentType(contentType, `text/json`)) {
            res.tflApiPresentationEntitiesModes = [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.tflApiPresentationEntitiesModes = utils.objectToClass(
              httpRes?.data,
              shared.TflApiPresentationEntitiesMode,
              resFieldDepth
            );
          }
          if (utils.matchContentType(contentType, `application/xml`)) {
            const resBody: string = JSON.stringify(httpRes?.data, null, 0);
            const out: Uint8Array = new Uint8Array(resBody.length);
            for (let i = 0; i < resBody.length; i++)
              out[i] = resBody.charCodeAt(i);
            res.body = out;
          }
          if (utils.matchContentType(contentType, `text/xml`)) {
            const resBody: string = JSON.stringify(httpRes?.data, null, 0);
            const out: Uint8Array = new Uint8Array(resBody.length);
            for (let i = 0; i < resBody.length; i++)
              out[i] = resBody.charCodeAt(i);
            res.body = out;
          }
          break;
      }

      return res;
    });
  }

  /**
   * Gets a list of valid ServiceTypes to filter on
   */
  lineMetaServiceTypes(
    config?: AxiosRequestConfig
  ): Promise<operations.LineMetaServiceTypesResponse> {
    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/Line/Meta/ServiceTypes";

    const client: AxiosInstance = this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.LineMetaServiceTypesResponse =
        new operations.LineMetaServiceTypesResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.lineMetaServiceTypes200ApplicationJSONStrings =
              utils.objectToClass(httpRes?.data);
          }
          if (utils.matchContentType(contentType, `application/xml`)) {
            const resBody: string = JSON.stringify(httpRes?.data, null, 0);
            const out: Uint8Array = new Uint8Array(resBody.length);
            for (let i = 0; i < resBody.length; i++)
              out[i] = resBody.charCodeAt(i);
            res.body = out;
          }
          if (utils.matchContentType(contentType, `text/xml`)) {
            const resBody: string = JSON.stringify(httpRes?.data, null, 0);
            const out: Uint8Array = new Uint8Array(resBody.length);
            for (let i = 0; i < resBody.length; i++)
              out[i] = resBody.charCodeAt(i);
            res.body = out;
          }
          if (utils.matchContentType(contentType, `text/json`)) {
            res.lineMetaServiceTypes200TextJSONStrings = utils.objectToClass(
              httpRes?.data
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Gets a list of valid severity codes
   */
  lineMetaSeverity(
    config?: AxiosRequestConfig
  ): Promise<operations.LineMetaSeverityResponse> {
    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/Line/Meta/Severity";

    const client: AxiosInstance = this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.LineMetaSeverityResponse =
        new operations.LineMetaSeverityResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.tflApiPresentationEntitiesStatusSeverities = [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.tflApiPresentationEntitiesStatusSeverities =
              utils.objectToClass(
                httpRes?.data,
                shared.TflApiPresentationEntitiesStatusSeverity,
                resFieldDepth
              );
          }
          if (utils.matchContentType(contentType, `text/json`)) {
            res.tflApiPresentationEntitiesStatusSeverities = [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.tflApiPresentationEntitiesStatusSeverities =
              utils.objectToClass(
                httpRes?.data,
                shared.TflApiPresentationEntitiesStatusSeverity,
                resFieldDepth
              );
          }
          if (utils.matchContentType(contentType, `application/xml`)) {
            const resBody: string = JSON.stringify(httpRes?.data, null, 0);
            const out: Uint8Array = new Uint8Array(resBody.length);
            for (let i = 0; i < resBody.length; i++)
              out[i] = resBody.charCodeAt(i);
            res.body = out;
          }
          if (utils.matchContentType(contentType, `text/xml`)) {
            const resBody: string = JSON.stringify(httpRes?.data, null, 0);
            const out: Uint8Array = new Uint8Array(resBody.length);
            for (let i = 0; i < resBody.length; i++)
              out[i] = resBody.charCodeAt(i);
            res.body = out;
          }
          break;
      }

      return res;
    });
  }

  /**
   * Get all valid routes for all lines, including the name and id of the originating and terminating stops for each route.
   */
  lineRoute(
    req: operations.LineRouteRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.LineRouteResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.LineRouteRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/Line/Route";

    const client: AxiosInstance = this._defaultClient;

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.LineRouteResponse =
        new operations.LineRouteResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.tflApiPresentationEntitiesLines = [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.tflApiPresentationEntitiesLines = utils.objectToClass(
              httpRes?.data,
              shared.TflApiPresentationEntitiesLine,
              resFieldDepth
            );
          }
          if (utils.matchContentType(contentType, `text/json`)) {
            res.tflApiPresentationEntitiesLines = [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.tflApiPresentationEntitiesLines = utils.objectToClass(
              httpRes?.data,
              shared.TflApiPresentationEntitiesLine,
              resFieldDepth
            );
          }
          if (utils.matchContentType(contentType, `application/xml`)) {
            const resBody: string = JSON.stringify(httpRes?.data, null, 0);
            const out: Uint8Array = new Uint8Array(resBody.length);
            for (let i = 0; i < resBody.length; i++)
              out[i] = resBody.charCodeAt(i);
            res.body = out;
          }
          if (utils.matchContentType(contentType, `text/xml`)) {
            const resBody: string = JSON.stringify(httpRes?.data, null, 0);
            const out: Uint8Array = new Uint8Array(resBody.length);
            for (let i = 0; i < resBody.length; i++)
              out[i] = resBody.charCodeAt(i);
            res.body = out;
          }
          break;
      }

      return res;
    });
  }

  /**
   * Gets all lines and their valid routes for given modes, including the name and id of the originating and terminating stops for each route
   */
  lineRouteByMode(
    req: operations.LineRouteByModeRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.LineRouteByModeResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.LineRouteByModeRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/Line/Mode/{modes}/Route",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.LineRouteByModeResponse =
        new operations.LineRouteByModeResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.tflApiPresentationEntitiesLines = [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.tflApiPresentationEntitiesLines = utils.objectToClass(
              httpRes?.data,
              shared.TflApiPresentationEntitiesLine,
              resFieldDepth
            );
          }
          if (utils.matchContentType(contentType, `text/json`)) {
            res.tflApiPresentationEntitiesLines = [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.tflApiPresentationEntitiesLines = utils.objectToClass(
              httpRes?.data,
              shared.TflApiPresentationEntitiesLine,
              resFieldDepth
            );
          }
          if (utils.matchContentType(contentType, `application/xml`)) {
            const resBody: string = JSON.stringify(httpRes?.data, null, 0);
            const out: Uint8Array = new Uint8Array(resBody.length);
            for (let i = 0; i < resBody.length; i++)
              out[i] = resBody.charCodeAt(i);
            res.body = out;
          }
          if (utils.matchContentType(contentType, `text/xml`)) {
            const resBody: string = JSON.stringify(httpRes?.data, null, 0);
            const out: Uint8Array = new Uint8Array(resBody.length);
            for (let i = 0; i < resBody.length; i++)
              out[i] = resBody.charCodeAt(i);
            res.body = out;
          }
          break;
      }

      return res;
    });
  }

  /**
   * Gets all valid routes for given line id, including the sequence of stops on each route.
   */
  lineRouteSequence(
    req: operations.LineRouteSequenceRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.LineRouteSequenceResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.LineRouteSequenceRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/Line/{id}/Route/Sequence/{direction}",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.LineRouteSequenceResponse =
        new operations.LineRouteSequenceResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.tflApiPresentationEntitiesRouteSequence = utils.objectToClass(
              httpRes?.data,
              shared.TflApiPresentationEntitiesRouteSequence
            );
          }
          if (utils.matchContentType(contentType, `text/json`)) {
            res.tflApiPresentationEntitiesRouteSequence = utils.objectToClass(
              httpRes?.data,
              shared.TflApiPresentationEntitiesRouteSequence
            );
          }
          if (utils.matchContentType(contentType, `application/xml`)) {
            const resBody: string = JSON.stringify(httpRes?.data, null, 0);
            const out: Uint8Array = new Uint8Array(resBody.length);
            for (let i = 0; i < resBody.length; i++)
              out[i] = resBody.charCodeAt(i);
            res.body = out;
          }
          if (utils.matchContentType(contentType, `text/xml`)) {
            const resBody: string = JSON.stringify(httpRes?.data, null, 0);
            const out: Uint8Array = new Uint8Array(resBody.length);
            for (let i = 0; i < resBody.length; i++)
              out[i] = resBody.charCodeAt(i);
            res.body = out;
          }
          break;
      }

      return res;
    });
  }

  /**
   * Search for lines or routes matching the query string
   */
  lineSearch(
    req: operations.LineSearchRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.LineSearchResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.LineSearchRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(baseURL, "/Line/Search/{query}", req);

    const client: AxiosInstance = this._defaultClient;

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.LineSearchResponse =
        new operations.LineSearchResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.tflApiPresentationEntitiesRouteSearchResponse =
              utils.objectToClass(
                httpRes?.data,
                shared.TflApiPresentationEntitiesRouteSearchResponse
              );
          }
          if (utils.matchContentType(contentType, `text/json`)) {
            res.tflApiPresentationEntitiesRouteSearchResponse =
              utils.objectToClass(
                httpRes?.data,
                shared.TflApiPresentationEntitiesRouteSearchResponse
              );
          }
          if (utils.matchContentType(contentType, `application/xml`)) {
            const resBody: string = JSON.stringify(httpRes?.data, null, 0);
            const out: Uint8Array = new Uint8Array(resBody.length);
            for (let i = 0; i < resBody.length; i++)
              out[i] = resBody.charCodeAt(i);
            res.body = out;
          }
          if (utils.matchContentType(contentType, `text/xml`)) {
            const resBody: string = JSON.stringify(httpRes?.data, null, 0);
            const out: Uint8Array = new Uint8Array(resBody.length);
            for (let i = 0; i < resBody.length; i++)
              out[i] = resBody.charCodeAt(i);
            res.body = out;
          }
          break;
      }

      return res;
    });
  }

  /**
   * Gets the line status for given line ids during the provided dates e.g Minor Delays
   */
  lineStatus(
    req: operations.LineStatusRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.LineStatusResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.LineStatusRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/Line/{ids}/Status/{StartDate}/to/{EndDate}",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.LineStatusResponse =
        new operations.LineStatusResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.tflApiPresentationEntitiesLines = [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.tflApiPresentationEntitiesLines = utils.objectToClass(
              httpRes?.data,
              shared.TflApiPresentationEntitiesLine,
              resFieldDepth
            );
          }
          if (utils.matchContentType(contentType, `text/json`)) {
            res.tflApiPresentationEntitiesLines = [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.tflApiPresentationEntitiesLines = utils.objectToClass(
              httpRes?.data,
              shared.TflApiPresentationEntitiesLine,
              resFieldDepth
            );
          }
          if (utils.matchContentType(contentType, `application/xml`)) {
            const resBody: string = JSON.stringify(httpRes?.data, null, 0);
            const out: Uint8Array = new Uint8Array(resBody.length);
            for (let i = 0; i < resBody.length; i++)
              out[i] = resBody.charCodeAt(i);
            res.body = out;
          }
          if (utils.matchContentType(contentType, `text/xml`)) {
            const resBody: string = JSON.stringify(httpRes?.data, null, 0);
            const out: Uint8Array = new Uint8Array(resBody.length);
            for (let i = 0; i < resBody.length; i++)
              out[i] = resBody.charCodeAt(i);
            res.body = out;
          }
          break;
      }

      return res;
    });
  }

  /**
   * Gets the line status of for given line ids e.g Minor Delays
   */
  lineStatusByIds(
    req: operations.LineStatusByIdsRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.LineStatusByIdsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.LineStatusByIdsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(baseURL, "/Line/{ids}/Status", req);

    const client: AxiosInstance = this._defaultClient;

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.LineStatusByIdsResponse =
        new operations.LineStatusByIdsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.tflApiPresentationEntitiesLines = [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.tflApiPresentationEntitiesLines = utils.objectToClass(
              httpRes?.data,
              shared.TflApiPresentationEntitiesLine,
              resFieldDepth
            );
          }
          if (utils.matchContentType(contentType, `text/json`)) {
            res.tflApiPresentationEntitiesLines = [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.tflApiPresentationEntitiesLines = utils.objectToClass(
              httpRes?.data,
              shared.TflApiPresentationEntitiesLine,
              resFieldDepth
            );
          }
          if (utils.matchContentType(contentType, `application/xml`)) {
            const resBody: string = JSON.stringify(httpRes?.data, null, 0);
            const out: Uint8Array = new Uint8Array(resBody.length);
            for (let i = 0; i < resBody.length; i++)
              out[i] = resBody.charCodeAt(i);
            res.body = out;
          }
          if (utils.matchContentType(contentType, `text/xml`)) {
            const resBody: string = JSON.stringify(httpRes?.data, null, 0);
            const out: Uint8Array = new Uint8Array(resBody.length);
            for (let i = 0; i < resBody.length; i++)
              out[i] = resBody.charCodeAt(i);
            res.body = out;
          }
          break;
      }

      return res;
    });
  }

  /**
   * Gets the line status of for all lines for the given modes
   */
  lineStatusByMode(
    req: operations.LineStatusByModeRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.LineStatusByModeResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.LineStatusByModeRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/Line/Mode/{modes}/Status",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.LineStatusByModeResponse =
        new operations.LineStatusByModeResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.tflApiPresentationEntitiesLines = [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.tflApiPresentationEntitiesLines = utils.objectToClass(
              httpRes?.data,
              shared.TflApiPresentationEntitiesLine,
              resFieldDepth
            );
          }
          if (utils.matchContentType(contentType, `text/json`)) {
            res.tflApiPresentationEntitiesLines = [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.tflApiPresentationEntitiesLines = utils.objectToClass(
              httpRes?.data,
              shared.TflApiPresentationEntitiesLine,
              resFieldDepth
            );
          }
          if (utils.matchContentType(contentType, `application/xml`)) {
            const resBody: string = JSON.stringify(httpRes?.data, null, 0);
            const out: Uint8Array = new Uint8Array(resBody.length);
            for (let i = 0; i < resBody.length; i++)
              out[i] = resBody.charCodeAt(i);
            res.body = out;
          }
          if (utils.matchContentType(contentType, `text/xml`)) {
            const resBody: string = JSON.stringify(httpRes?.data, null, 0);
            const out: Uint8Array = new Uint8Array(resBody.length);
            for (let i = 0; i < resBody.length; i++)
              out[i] = resBody.charCodeAt(i);
            res.body = out;
          }
          break;
      }

      return res;
    });
  }

  /**
   * Gets the line status for all lines with a given severity
   *             A list of valid severity codes can be obtained from a call to Line/Meta/Severity
   */
  lineStatusBySeverity(
    req: operations.LineStatusBySeverityRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.LineStatusBySeverityResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.LineStatusBySeverityRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/Line/Status/{severity}",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.LineStatusBySeverityResponse =
        new operations.LineStatusBySeverityResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.tflApiPresentationEntitiesLines = [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.tflApiPresentationEntitiesLines = utils.objectToClass(
              httpRes?.data,
              shared.TflApiPresentationEntitiesLine,
              resFieldDepth
            );
          }
          if (utils.matchContentType(contentType, `text/json`)) {
            res.tflApiPresentationEntitiesLines = [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.tflApiPresentationEntitiesLines = utils.objectToClass(
              httpRes?.data,
              shared.TflApiPresentationEntitiesLine,
              resFieldDepth
            );
          }
          if (utils.matchContentType(contentType, `application/xml`)) {
            const resBody: string = JSON.stringify(httpRes?.data, null, 0);
            const out: Uint8Array = new Uint8Array(resBody.length);
            for (let i = 0; i < resBody.length; i++)
              out[i] = resBody.charCodeAt(i);
            res.body = out;
          }
          if (utils.matchContentType(contentType, `text/xml`)) {
            const resBody: string = JSON.stringify(httpRes?.data, null, 0);
            const out: Uint8Array = new Uint8Array(resBody.length);
            for (let i = 0; i < resBody.length; i++)
              out[i] = resBody.charCodeAt(i);
            res.body = out;
          }
          break;
      }

      return res;
    });
  }

  /**
   * Gets a list of the stations that serve the given line id
   */
  lineStopPoints(
    req: operations.LineStopPointsRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.LineStopPointsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.LineStopPointsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/Line/{id}/StopPoints",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.LineStopPointsResponse =
        new operations.LineStopPointsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.tflApiPresentationEntitiesStopPoints = [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.tflApiPresentationEntitiesStopPoints = utils.objectToClass(
              httpRes?.data,
              shared.TflApiPresentationEntitiesStopPoint,
              resFieldDepth
            );
          }
          if (utils.matchContentType(contentType, `text/json`)) {
            res.tflApiPresentationEntitiesStopPoints = [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.tflApiPresentationEntitiesStopPoints = utils.objectToClass(
              httpRes?.data,
              shared.TflApiPresentationEntitiesStopPoint,
              resFieldDepth
            );
          }
          if (utils.matchContentType(contentType, `application/xml`)) {
            const resBody: string = JSON.stringify(httpRes?.data, null, 0);
            const out: Uint8Array = new Uint8Array(resBody.length);
            for (let i = 0; i < resBody.length; i++)
              out[i] = resBody.charCodeAt(i);
            res.body = out;
          }
          if (utils.matchContentType(contentType, `text/xml`)) {
            const resBody: string = JSON.stringify(httpRes?.data, null, 0);
            const out: Uint8Array = new Uint8Array(resBody.length);
            for (let i = 0; i < resBody.length; i++)
              out[i] = resBody.charCodeAt(i);
            res.body = out;
          }
          break;
      }

      return res;
    });
  }

  /**
   * Gets the timetable for a specified station on the give line
   */
  lineTimetable(
    req: operations.LineTimetableRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.LineTimetableResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.LineTimetableRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/Line/{id}/Timetable/{fromStopPointId}",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.LineTimetableResponse =
        new operations.LineTimetableResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.tflApiPresentationEntitiesTimetableResponse =
              utils.objectToClass(
                httpRes?.data,
                shared.TflApiPresentationEntitiesTimetableResponse
              );
          }
          if (utils.matchContentType(contentType, `text/json`)) {
            res.tflApiPresentationEntitiesTimetableResponse =
              utils.objectToClass(
                httpRes?.data,
                shared.TflApiPresentationEntitiesTimetableResponse
              );
          }
          if (utils.matchContentType(contentType, `application/xml`)) {
            const resBody: string = JSON.stringify(httpRes?.data, null, 0);
            const out: Uint8Array = new Uint8Array(resBody.length);
            for (let i = 0; i < resBody.length; i++)
              out[i] = resBody.charCodeAt(i);
            res.body = out;
          }
          if (utils.matchContentType(contentType, `text/xml`)) {
            const resBody: string = JSON.stringify(httpRes?.data, null, 0);
            const out: Uint8Array = new Uint8Array(resBody.length);
            for (let i = 0; i < resBody.length; i++)
              out[i] = resBody.charCodeAt(i);
            res.body = out;
          }
          break;
      }

      return res;
    });
  }

  /**
   * Gets the timetable for a specified station on the give line with specified destination
   */
  lineTimetableTo(
    req: operations.LineTimetableToRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.LineTimetableToResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.LineTimetableToRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/Line/{id}/Timetable/{fromStopPointId}/to/{toStopPointId}",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.LineTimetableToResponse =
        new operations.LineTimetableToResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.tflApiPresentationEntitiesTimetableResponse =
              utils.objectToClass(
                httpRes?.data,
                shared.TflApiPresentationEntitiesTimetableResponse
              );
          }
          if (utils.matchContentType(contentType, `text/json`)) {
            res.tflApiPresentationEntitiesTimetableResponse =
              utils.objectToClass(
                httpRes?.data,
                shared.TflApiPresentationEntitiesTimetableResponse
              );
          }
          if (utils.matchContentType(contentType, `application/xml`)) {
            const resBody: string = JSON.stringify(httpRes?.data, null, 0);
            const out: Uint8Array = new Uint8Array(resBody.length);
            for (let i = 0; i < resBody.length; i++)
              out[i] = resBody.charCodeAt(i);
            res.body = out;
          }
          if (utils.matchContentType(contentType, `text/xml`)) {
            const resBody: string = JSON.stringify(httpRes?.data, null, 0);
            const out: Uint8Array = new Uint8Array(resBody.length);
            for (let i = 0; i < resBody.length; i++)
              out[i] = resBody.charCodeAt(i);
            res.body = out;
          }
          break;
      }

      return res;
    });
  }
}
