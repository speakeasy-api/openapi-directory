/*
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

import * as utils from "../internal/utils";
import * as operations from "./models/operations";
import * as shared from "./models/shared";
import { AxiosInstance, AxiosRequestConfig, AxiosResponse } from "axios";

export class Collections {
  _defaultClient: AxiosInstance;
  _securityClient: AxiosInstance;
  _serverURL: string;
  _language: string;
  _sdkVersion: string;
  _genVersion: string;

  constructor(
    defaultClient: AxiosInstance,
    securityClient: AxiosInstance,
    serverURL: string,
    language: string,
    sdkVersion: string,
    genVersion: string
  ) {
    this._defaultClient = defaultClient;
    this._securityClient = securityClient;
    this._serverURL = serverURL;
    this._language = language;
    this._sdkVersion = sdkVersion;
    this._genVersion = genVersion;
  }

  /**
   * Public Collection Articles
   *
   * @remarks
   * Returns a list of public collection articles
   */
  collectionArticles(
    req: operations.CollectionArticlesRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.CollectionArticlesResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CollectionArticlesRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/collections/{collection_id}/articles",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CollectionArticlesResponse =
        new operations.CollectionArticlesResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.articles = [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.articles = utils.objectToClass(
              httpRes?.data,
              shared.Article,
              resFieldDepth
            );
          }
          break;
        case [400, 404, 422, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Collection details
   *
   * @remarks
   * View a collection
   */
  collectionDetails(
    req: operations.CollectionDetailsRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.CollectionDetailsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CollectionDetailsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/collections/{collection_id}",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CollectionDetailsResponse =
        new operations.CollectionDetailsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.collectionComplete = utils.objectToClass(
              httpRes?.data,
              shared.CollectionComplete
            );
          }
          break;
        case [400, 404, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Collection Version details
   *
   * @remarks
   * View details for a certain version of a collection
   */
  collectionVersionDetails(
    req: operations.CollectionVersionDetailsRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.CollectionVersionDetailsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CollectionVersionDetailsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/collections/{collection_id}/versions/{version_id}",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CollectionVersionDetailsResponse =
        new operations.CollectionVersionDetailsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.collectionComplete = utils.objectToClass(
              httpRes?.data,
              shared.CollectionComplete
            );
          }
          break;
        case [400, 404, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Collection Versions list
   *
   * @remarks
   * Returns a list of public collection Versions
   */
  collectionVersions(
    req: operations.CollectionVersionsRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.CollectionVersionsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CollectionVersionsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/collections/{collection_id}/versions",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CollectionVersionsResponse =
        new operations.CollectionVersionsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.collectionVersions = [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.collectionVersions = utils.objectToClass(
              httpRes?.data,
              shared.CollectionVersions,
              resFieldDepth
            );
          }
          break;
        case [400, 404, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Public Collections
   *
   * @remarks
   * Returns a list of public collections
   */
  collectionsList(
    req: operations.CollectionsListRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.CollectionsListResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CollectionsListRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/collections";

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      headers: headers,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CollectionsListResponse =
        new operations.CollectionsListResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
          headers: utils.getHeadersFromResponse(httpRes.headers),
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.collections = [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.collections = utils.objectToClass(
              httpRes?.data,
              shared.Collection,
              resFieldDepth
            );
          }
          break;
        case [400, 422, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Public Collections Search
   *
   * @remarks
   * Returns a list of public collections
   */
  collectionsSearch(
    req: operations.CollectionsSearchRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.CollectionsSearchResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CollectionsSearchRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/collections/search";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "collectionSearch",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._defaultClient;

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CollectionsSearchResponse =
        new operations.CollectionsSearchResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
          headers: utils.getHeadersFromResponse(httpRes.headers),
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.collections = [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.collections = utils.objectToClass(
              httpRes?.data,
              shared.Collection,
              resFieldDepth
            );
          }
          break;
        case [400, 422, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Delete collection article
   *
   * @remarks
   * De-associate article from collection
   */
  privateCollectionArticleDelete(
    req: operations.PrivateCollectionArticleDeleteRequest,
    security: operations.PrivateCollectionArticleDeleteSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.PrivateCollectionArticleDeleteResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PrivateCollectionArticleDeleteRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/account/collections/{collection_id}/articles/{article_id}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.PrivateCollectionArticleDeleteSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PrivateCollectionArticleDeleteResponse =
        new operations.PrivateCollectionArticleDeleteResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case [204, 404, 500].includes(httpRes?.status):
          break;
        case httpRes?.status == 403:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorMessage = utils.objectToClass(
              httpRes?.data,
              shared.ErrorMessage
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Add collection articles
   *
   * @remarks
   * Associate new articles with the collection. This will add new articles to the list of already associated articles
   */
  privateCollectionArticlesAdd(
    req: operations.PrivateCollectionArticlesAddRequest,
    security: operations.PrivateCollectionArticlesAddSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.PrivateCollectionArticlesAddResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PrivateCollectionArticlesAddRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/account/collections/{collection_id}/articles",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "articlesCreator",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.PrivateCollectionArticlesAddSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PrivateCollectionArticlesAddResponse =
        new operations.PrivateCollectionArticlesAddResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
          headers: utils.getHeadersFromResponse(httpRes.headers),
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.location = utils.objectToClass(httpRes?.data, shared.Location);
          }
          break;
        case [400, 404, 500].includes(httpRes?.status):
          break;
        case httpRes?.status == 403:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorMessage = utils.objectToClass(
              httpRes?.data,
              shared.ErrorMessage
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * List collection articles
   *
   * @remarks
   * List collection articles
   */
  privateCollectionArticlesList(
    req: operations.PrivateCollectionArticlesListRequest,
    security: operations.PrivateCollectionArticlesListSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.PrivateCollectionArticlesListResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PrivateCollectionArticlesListRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/account/collections/{collection_id}/articles",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.PrivateCollectionArticlesListSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PrivateCollectionArticlesListResponse =
        new operations.PrivateCollectionArticlesListResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.articles = [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.articles = utils.objectToClass(
              httpRes?.data,
              shared.Article,
              resFieldDepth
            );
          }
          break;
        case [400, 404, 500].includes(httpRes?.status):
          break;
        case httpRes?.status == 403:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorMessage = utils.objectToClass(
              httpRes?.data,
              shared.ErrorMessage
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Replace collection articles
   *
   * @remarks
   * Associate new articles with the collection. This will remove all already associated articles and add these new ones
   */
  privateCollectionArticlesReplace(
    req: operations.PrivateCollectionArticlesReplaceRequest,
    security: operations.PrivateCollectionArticlesReplaceSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.PrivateCollectionArticlesReplaceResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PrivateCollectionArticlesReplaceRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/account/collections/{collection_id}/articles",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "articlesCreator",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.PrivateCollectionArticlesReplaceSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "put",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PrivateCollectionArticlesReplaceResponse =
        new operations.PrivateCollectionArticlesReplaceResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
          headers: utils.getHeadersFromResponse(httpRes.headers),
        });
      switch (true) {
        case httpRes?.status == 205:
          break;
        case [400, 404, 500].includes(httpRes?.status):
          break;
        case httpRes?.status == 403:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorMessage = utils.objectToClass(
              httpRes?.data,
              shared.ErrorMessage
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Delete collection author
   *
   * @remarks
   * Delete collection author
   */
  privateCollectionAuthorDelete(
    req: operations.PrivateCollectionAuthorDeleteRequest,
    security: operations.PrivateCollectionAuthorDeleteSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.PrivateCollectionAuthorDeleteResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PrivateCollectionAuthorDeleteRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/account/collections/{collection_id}/authors/{author_id}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.PrivateCollectionAuthorDeleteSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PrivateCollectionAuthorDeleteResponse =
        new operations.PrivateCollectionAuthorDeleteResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case [204, 404, 500].includes(httpRes?.status):
          break;
        case httpRes?.status == 403:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorMessage = utils.objectToClass(
              httpRes?.data,
              shared.ErrorMessage
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Add collection authors
   *
   * @remarks
   * Associate new authors with the collection. This will add new authors to the list of already associated authors
   */
  privateCollectionAuthorsAdd(
    req: operations.PrivateCollectionAuthorsAddRequest,
    security: operations.PrivateCollectionAuthorsAddSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.PrivateCollectionAuthorsAddResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PrivateCollectionAuthorsAddRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/account/collections/{collection_id}/authors",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "authorsCreator",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.PrivateCollectionAuthorsAddSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PrivateCollectionAuthorsAddResponse =
        new operations.PrivateCollectionAuthorsAddResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
          headers: utils.getHeadersFromResponse(httpRes.headers),
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.location = utils.objectToClass(httpRes?.data, shared.Location);
          }
          break;
        case [400, 404, 500].includes(httpRes?.status):
          break;
        case httpRes?.status == 403:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorMessage = utils.objectToClass(
              httpRes?.data,
              shared.ErrorMessage
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * List collection authors
   *
   * @remarks
   * List collection authors
   */
  privateCollectionAuthorsList(
    req: operations.PrivateCollectionAuthorsListRequest,
    security: operations.PrivateCollectionAuthorsListSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.PrivateCollectionAuthorsListResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PrivateCollectionAuthorsListRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/account/collections/{collection_id}/authors",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.PrivateCollectionAuthorsListSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PrivateCollectionAuthorsListResponse =
        new operations.PrivateCollectionAuthorsListResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.authors = [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.authors = utils.objectToClass(
              httpRes?.data,
              shared.Author,
              resFieldDepth
            );
          }
          break;
        case [400, 404, 500].includes(httpRes?.status):
          break;
        case httpRes?.status == 403:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorMessage = utils.objectToClass(
              httpRes?.data,
              shared.ErrorMessage
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Replace collection authors
   *
   * @remarks
   * Associate new authors with the collection. This will remove all already associated authors and add these new ones
   */
  privateCollectionAuthorsReplace(
    req: operations.PrivateCollectionAuthorsReplaceRequest,
    security: operations.PrivateCollectionAuthorsReplaceSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.PrivateCollectionAuthorsReplaceResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PrivateCollectionAuthorsReplaceRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/account/collections/{collection_id}/authors",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "authorsCreator",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.PrivateCollectionAuthorsReplaceSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "put",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PrivateCollectionAuthorsReplaceResponse =
        new operations.PrivateCollectionAuthorsReplaceResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
          headers: utils.getHeadersFromResponse(httpRes.headers),
        });
      switch (true) {
        case httpRes?.status == 205:
          break;
        case [400, 404, 500].includes(httpRes?.status):
          break;
        case httpRes?.status == 403:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorMessage = utils.objectToClass(
              httpRes?.data,
              shared.ErrorMessage
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Add collection categories
   *
   * @remarks
   * Associate new categories with the collection. This will add new categories to the list of already associated categories
   */
  privateCollectionCategoriesAdd(
    req: operations.PrivateCollectionCategoriesAddRequest,
    security: operations.PrivateCollectionCategoriesAddSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.PrivateCollectionCategoriesAddResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PrivateCollectionCategoriesAddRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/account/collections/{collection_id}/categories",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "categoriesCreator",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.PrivateCollectionCategoriesAddSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PrivateCollectionCategoriesAddResponse =
        new operations.PrivateCollectionCategoriesAddResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
          headers: utils.getHeadersFromResponse(httpRes.headers),
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.location = utils.objectToClass(httpRes?.data, shared.Location);
          }
          break;
        case [400, 404, 500].includes(httpRes?.status):
          break;
        case httpRes?.status == 403:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorMessage = utils.objectToClass(
              httpRes?.data,
              shared.ErrorMessage
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * List collection categories
   *
   * @remarks
   * List collection categories
   */
  privateCollectionCategoriesList(
    req: operations.PrivateCollectionCategoriesListRequest,
    security: operations.PrivateCollectionCategoriesListSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.PrivateCollectionCategoriesListResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PrivateCollectionCategoriesListRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/account/collections/{collection_id}/categories",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.PrivateCollectionCategoriesListSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PrivateCollectionCategoriesListResponse =
        new operations.PrivateCollectionCategoriesListResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.categories = [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.categories = utils.objectToClass(
              httpRes?.data,
              shared.Category,
              resFieldDepth
            );
          }
          break;
        case [400, 404, 500].includes(httpRes?.status):
          break;
        case httpRes?.status == 403:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorMessage = utils.objectToClass(
              httpRes?.data,
              shared.ErrorMessage
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Replace collection categories
   *
   * @remarks
   * Associate new categories with the collection. This will remove all already associated categories and add these new ones
   */
  privateCollectionCategoriesReplace(
    req: operations.PrivateCollectionCategoriesReplaceRequest,
    security: operations.PrivateCollectionCategoriesReplaceSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.PrivateCollectionCategoriesReplaceResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PrivateCollectionCategoriesReplaceRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/account/collections/{collection_id}/categories",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "categoriesCreator",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.PrivateCollectionCategoriesReplaceSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "put",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PrivateCollectionCategoriesReplaceResponse =
        new operations.PrivateCollectionCategoriesReplaceResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
          headers: utils.getHeadersFromResponse(httpRes.headers),
        });
      switch (true) {
        case httpRes?.status == 205:
          break;
        case [400, 404, 500].includes(httpRes?.status):
          break;
        case httpRes?.status == 403:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorMessage = utils.objectToClass(
              httpRes?.data,
              shared.ErrorMessage
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Delete collection category
   *
   * @remarks
   * De-associate category from collection
   */
  privateCollectionCategoryDelete(
    req: operations.PrivateCollectionCategoryDeleteRequest,
    security: operations.PrivateCollectionCategoryDeleteSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.PrivateCollectionCategoryDeleteResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PrivateCollectionCategoryDeleteRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/account/collections/{collection_id}/categories/{category_id}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.PrivateCollectionCategoryDeleteSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PrivateCollectionCategoryDeleteResponse =
        new operations.PrivateCollectionCategoryDeleteResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case [204, 404, 500].includes(httpRes?.status):
          break;
        case httpRes?.status == 403:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorMessage = utils.objectToClass(
              httpRes?.data,
              shared.ErrorMessage
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Create collection
   *
   * @remarks
   * Create a new Collection by sending collection information
   */
  privateCollectionCreate(
    req: shared.CollectionCreate,
    security: operations.PrivateCollectionCreateSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.PrivateCollectionCreateResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new shared.CollectionCreate(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/account/collections";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "request",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.PrivateCollectionCreateSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PrivateCollectionCreateResponse =
        new operations.PrivateCollectionCreateResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.locationWarnings = utils.objectToClass(
              httpRes?.data,
              shared.LocationWarnings
            );
          }
          break;
        case [400, 500].includes(httpRes?.status):
          break;
        case httpRes?.status == 403:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorMessage = utils.objectToClass(
              httpRes?.data,
              shared.ErrorMessage
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Delete collection
   *
   * @remarks
   * Delete n collection
   */
  privateCollectionDelete(
    req: operations.PrivateCollectionDeleteRequest,
    security: operations.PrivateCollectionDeleteSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.PrivateCollectionDeleteResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PrivateCollectionDeleteRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/account/collections/{collection_id}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.PrivateCollectionDeleteSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PrivateCollectionDeleteResponse =
        new operations.PrivateCollectionDeleteResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case [204, 400, 404, 500].includes(httpRes?.status):
          break;
        case httpRes?.status == 403:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorMessage = utils.objectToClass(
              httpRes?.data,
              shared.ErrorMessage
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Collection details
   *
   * @remarks
   * View a collection
   */
  privateCollectionDetails(
    req: operations.PrivateCollectionDetailsRequest,
    security: operations.PrivateCollectionDetailsSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.PrivateCollectionDetailsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PrivateCollectionDetailsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/account/collections/{collection_id}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.PrivateCollectionDetailsSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PrivateCollectionDetailsResponse =
        new operations.PrivateCollectionDetailsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.collectionCompletePrivate = utils.objectToClass(
              httpRes?.data,
              shared.CollectionCompletePrivate
            );
          }
          break;
        case [400, 404, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Create collection private link
   *
   * @remarks
   * Create new private link
   */
  privateCollectionPrivateLinkCreate(
    req: operations.PrivateCollectionPrivateLinkCreateRequest,
    security: operations.PrivateCollectionPrivateLinkCreateSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.PrivateCollectionPrivateLinkCreateResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PrivateCollectionPrivateLinkCreateRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/account/collections/{collection_id}/private_links",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "collectionPrivateLinkCreator",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.PrivateCollectionPrivateLinkCreateSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PrivateCollectionPrivateLinkCreateResponse =
        new operations.PrivateCollectionPrivateLinkCreateResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
          headers: utils.getHeadersFromResponse(httpRes.headers),
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.privateLinkResponse = utils.objectToClass(
              httpRes?.data,
              shared.PrivateLinkResponse
            );
          }
          break;
        case [400, 404, 500].includes(httpRes?.status):
          break;
        case httpRes?.status == 403:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorMessage = utils.objectToClass(
              httpRes?.data,
              shared.ErrorMessage
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Disable private link
   *
   * @remarks
   * Disable/delete private link for this collection
   */
  privateCollectionPrivateLinkDelete(
    req: operations.PrivateCollectionPrivateLinkDeleteRequest,
    security: operations.PrivateCollectionPrivateLinkDeleteSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.PrivateCollectionPrivateLinkDeleteResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PrivateCollectionPrivateLinkDeleteRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/account/collections/{collection_id}/private_links/{link_id}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.PrivateCollectionPrivateLinkDeleteSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PrivateCollectionPrivateLinkDeleteResponse =
        new operations.PrivateCollectionPrivateLinkDeleteResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case [204, 400, 404, 500].includes(httpRes?.status):
          break;
        case httpRes?.status == 403:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorMessage = utils.objectToClass(
              httpRes?.data,
              shared.ErrorMessage
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Update collection private link
   *
   * @remarks
   * Update existing private link for this collection
   */
  privateCollectionPrivateLinkUpdate(
    req: operations.PrivateCollectionPrivateLinkUpdateRequest,
    security: operations.PrivateCollectionPrivateLinkUpdateSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.PrivateCollectionPrivateLinkUpdateResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PrivateCollectionPrivateLinkUpdateRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/account/collections/{collection_id}/private_links/{link_id}",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "collectionPrivateLinkCreator",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.PrivateCollectionPrivateLinkUpdateSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "put",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PrivateCollectionPrivateLinkUpdateResponse =
        new operations.PrivateCollectionPrivateLinkUpdateResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
          headers: utils.getHeadersFromResponse(httpRes.headers),
        });
      switch (true) {
        case httpRes?.status == 205:
          break;
        case [400, 404, 422, 500].includes(httpRes?.status):
          break;
        case httpRes?.status == 403:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorMessage = utils.objectToClass(
              httpRes?.data,
              shared.ErrorMessage
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * List collection private links
   *
   * @remarks
   * List article private links
   */
  privateCollectionPrivateLinksList(
    req: operations.PrivateCollectionPrivateLinksListRequest,
    security: operations.PrivateCollectionPrivateLinksListSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.PrivateCollectionPrivateLinksListResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PrivateCollectionPrivateLinksListRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/account/collections/{collection_id}/private_links",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.PrivateCollectionPrivateLinksListSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PrivateCollectionPrivateLinksListResponse =
        new operations.PrivateCollectionPrivateLinksListResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.privateLinks = [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.privateLinks = utils.objectToClass(
              httpRes?.data,
              shared.PrivateLink,
              resFieldDepth
            );
          }
          break;
        case [400, 404, 500].includes(httpRes?.status):
          break;
        case httpRes?.status == 403:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorMessage = utils.objectToClass(
              httpRes?.data,
              shared.ErrorMessage
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Private Collection Publish
   *
   * @remarks
   * When a collection is published, a new public version will be generated. Any further updates to the collection will affect the private collection data. In order to make these changes publicly visible, an explicit publish operation is needed.
   */
  privateCollectionPublish(
    req: operations.PrivateCollectionPublishRequest,
    security: operations.PrivateCollectionPublishSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.PrivateCollectionPublishResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PrivateCollectionPublishRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/account/collections/{collection_id}/publish",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.PrivateCollectionPublishSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "post",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PrivateCollectionPublishResponse =
        new operations.PrivateCollectionPublishResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
          headers: utils.getHeadersFromResponse(httpRes.headers),
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.location = utils.objectToClass(httpRes?.data, shared.Location);
          }
          break;
        case [400, 500].includes(httpRes?.status):
          break;
        case httpRes?.status == 403:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorMessage = utils.objectToClass(
              httpRes?.data,
              shared.ErrorMessage
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Private Collection Reserve DOI
   *
   * @remarks
   * Reserve DOI for collection
   */
  privateCollectionReserveDoi(
    req: operations.PrivateCollectionReserveDoiRequest,
    security: operations.PrivateCollectionReserveDoiSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.PrivateCollectionReserveDoiResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PrivateCollectionReserveDoiRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/account/collections/{collection_id}/reserve_doi",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.PrivateCollectionReserveDoiSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "post",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PrivateCollectionReserveDoiResponse =
        new operations.PrivateCollectionReserveDoiResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.collectionDOI = utils.objectToClass(
              httpRes?.data,
              shared.CollectionDOI
            );
          }
          break;
        case [400, 500].includes(httpRes?.status):
          break;
        case httpRes?.status == 403:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorMessage = utils.objectToClass(
              httpRes?.data,
              shared.ErrorMessage
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Private Collection Reserve Handle
   *
   * @remarks
   * Reserve Handle for collection
   */
  privateCollectionReserveHandle(
    req: operations.PrivateCollectionReserveHandleRequest,
    security: operations.PrivateCollectionReserveHandleSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.PrivateCollectionReserveHandleResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PrivateCollectionReserveHandleRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/account/collections/{collection_id}/reserve_handle",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.PrivateCollectionReserveHandleSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "post",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PrivateCollectionReserveHandleResponse =
        new operations.PrivateCollectionReserveHandleResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.collectionHandle = utils.objectToClass(
              httpRes?.data,
              shared.CollectionHandle
            );
          }
          break;
        case [400, 500].includes(httpRes?.status):
          break;
        case httpRes?.status == 403:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorMessage = utils.objectToClass(
              httpRes?.data,
              shared.ErrorMessage
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Private Collection Resource
   *
   * @remarks
   * Edit collection resource data.
   */
  privateCollectionResource(
    req: operations.PrivateCollectionResourceRequest,
    security: operations.PrivateCollectionResourceSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.PrivateCollectionResourceResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PrivateCollectionResourceRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/account/collections/{collection_id}/resource",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "resource",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.PrivateCollectionResourceSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PrivateCollectionResourceResponse =
        new operations.PrivateCollectionResourceResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
          headers: utils.getHeadersFromResponse(httpRes.headers),
        });
      switch (true) {
        case httpRes?.status == 205:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.location = utils.objectToClass(httpRes?.data, shared.Location);
          }
          break;
        case httpRes?.status == 403:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorMessage = utils.objectToClass(
              httpRes?.data,
              shared.ErrorMessage
            );
          }
          break;
        case [404, 422].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Update collection
   *
   * @remarks
   * Update collection details; request can also be made with the PATCH method.
   */
  privateCollectionUpdate(
    req: operations.PrivateCollectionUpdateRequest,
    security: operations.PrivateCollectionUpdateSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.PrivateCollectionUpdateResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PrivateCollectionUpdateRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/account/collections/{collection_id}",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "collectionUpdate",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.PrivateCollectionUpdateSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "put",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PrivateCollectionUpdateResponse =
        new operations.PrivateCollectionUpdateResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
          headers: utils.getHeadersFromResponse(httpRes.headers),
        });
      switch (true) {
        case httpRes?.status == 205:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.locationWarningsUpdate = utils.objectToClass(
              httpRes?.data,
              shared.LocationWarningsUpdate
            );
          }
          break;
        case [400, 404, 500].includes(httpRes?.status):
          break;
        case httpRes?.status == 403:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorMessage = utils.objectToClass(
              httpRes?.data,
              shared.ErrorMessage
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Private Collections List
   *
   * @remarks
   * List private collections
   */
  privateCollectionsList(
    req: operations.PrivateCollectionsListRequest,
    security: operations.PrivateCollectionsListSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.PrivateCollectionsListResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PrivateCollectionsListRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/account/collections";
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.PrivateCollectionsListSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PrivateCollectionsListResponse =
        new operations.PrivateCollectionsListResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.collections = [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.collections = utils.objectToClass(
              httpRes?.data,
              shared.Collection,
              resFieldDepth
            );
          }
          break;
        case [400, 500].includes(httpRes?.status):
          break;
        case httpRes?.status == 403:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorMessage = utils.objectToClass(
              httpRes?.data,
              shared.ErrorMessage
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Private Collections Search
   *
   * @remarks
   * Returns a list of private Collections
   */
  privateCollectionsSearch(
    req: shared.PrivateCollectionSearch,
    security: operations.PrivateCollectionsSearchSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.PrivateCollectionsSearchResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new shared.PrivateCollectionSearch(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/account/collections/search";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "request",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.PrivateCollectionsSearchSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PrivateCollectionsSearchResponse =
        new operations.PrivateCollectionsSearchResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.collections = [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.collections = utils.objectToClass(
              httpRes?.data,
              shared.Collection,
              resFieldDepth
            );
          }
          break;
        case [400, 500].includes(httpRes?.status):
          break;
        case httpRes?.status == 403:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorMessage = utils.objectToClass(
              httpRes?.data,
              shared.ErrorMessage
            );
          }
          break;
      }

      return res;
    });
  }
}
