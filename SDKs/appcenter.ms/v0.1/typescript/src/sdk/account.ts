/*
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

import * as utils from "../internal/utils";
import * as operations from "./models/operations";
import { AxiosInstance, AxiosRequestConfig, AxiosResponse } from "axios";

export class Account {
  _defaultClient: AxiosInstance;
  _securityClient: AxiosInstance;
  _serverURL: string;
  _language: string;
  _sdkVersion: string;
  _genVersion: string;

  constructor(
    defaultClient: AxiosInstance,
    securityClient: AxiosInstance,
    serverURL: string,
    language: string,
    sdkVersion: string,
    genVersion: string
  ) {
    this._defaultClient = defaultClient;
    this._securityClient = securityClient;
    this._serverURL = serverURL;
    this._language = language;
    this._sdkVersion = sdkVersion;
    this._genVersion = genVersion;
  }

  usersGetUserMetadata(
    config?: AxiosRequestConfig
  ): Promise<operations.UsersGetUserMetadataResponse> {
    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/v0.1/user/metadata/optimizely";

    const client: AxiosInstance = this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UsersGetUserMetadataResponse =
        new operations.UsersGetUserMetadataResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.usersGetUserMetadata200ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.UsersGetUserMetadata200ApplicationJSON
              );
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.usersGetUserMetadataDefaultApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.UsersGetUserMetadataDefaultApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Delete the App Api Token object with the specific ID
   */
  appApiTokensDelete(
    req: operations.AppApiTokensDeleteRequest,
    security: operations.AppApiTokensDeleteSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.AppApiTokensDeleteResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.AppApiTokensDeleteRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v0.1/apps/{owner_name}/{app_name}/api_tokens/{api_token_id}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.AppApiTokensDeleteSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.AppApiTokensDeleteResponse =
        new operations.AppApiTokensDeleteResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
        case httpRes?.status == 400:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.appApiTokensDelete400ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.AppApiTokensDelete400ApplicationJSON
              );
          }
          break;
        case httpRes?.status == 401:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.appApiTokensDelete401ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.AppApiTokensDelete401ApplicationJSON
              );
          }
          break;
        case httpRes?.status == 404:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.appApiTokensDelete404ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.AppApiTokensDelete404ApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Returns App API tokens for the app
   */
  appApiTokensList(
    req: operations.AppApiTokensListRequest,
    security: operations.AppApiTokensListSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.AppApiTokensListResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.AppApiTokensListRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v0.1/apps/{owner_name}/{app_name}/api_tokens",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.AppApiTokensListSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.AppApiTokensListResponse =
        new operations.AppApiTokensListResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.appApiTokensList200ApplicationJSONObjects = [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.appApiTokensList200ApplicationJSONObjects = utils.objectToClass(
              httpRes?.data,
              operations.AppApiTokensList200ApplicationJSON,
              resFieldDepth
            );
          }
          break;
        case httpRes?.status == 400:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.appApiTokensList400ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.AppApiTokensList400ApplicationJSON
            );
          }
          break;
        case httpRes?.status == 401:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.appApiTokensList401ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.AppApiTokensList401ApplicationJSON
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Creates a new App API token
   */
  appApiTokensNew(
    req: operations.AppApiTokensNewRequest,
    security: operations.AppApiTokensNewSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.AppApiTokensNewResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.AppApiTokensNewRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v0.1/apps/{owner_name}/{app_name}/api_tokens",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.AppApiTokensNewSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.AppApiTokensNewResponse =
        new operations.AppApiTokensNewResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.appApiTokensNew201ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.AppApiTokensNew201ApplicationJSON
            );
          }
          break;
        case httpRes?.status == 400:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.appApiTokensNew400ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.AppApiTokensNew400ApplicationJSON
            );
          }
          break;
        case httpRes?.status == 401:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.appApiTokensNew401ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.AppApiTokensNew401ApplicationJSON
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Accepts a pending invitation for the specified user
   */
  appInvitationsAccept(
    req: operations.AppInvitationsAcceptRequest,
    security: operations.AppInvitationsAcceptSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.AppInvitationsAcceptResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.AppInvitationsAcceptRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v0.1/user/invitations/apps/{invitation_token}/accept",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.AppInvitationsAcceptSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.AppInvitationsAcceptResponse =
        new operations.AppInvitationsAcceptResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.appInvitationsAcceptDefaultApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.AppInvitationsAcceptDefaultApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Invites a new or existing user to an app
   */
  appInvitationsCreate(
    req: operations.AppInvitationsCreateRequest,
    security: operations.AppInvitationsCreateSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.AppInvitationsCreateResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.AppInvitationsCreateRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v0.1/apps/{owner_name}/{app_name}/invitations",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.AppInvitationsCreateSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.AppInvitationsCreateResponse =
        new operations.AppInvitationsCreateResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.appInvitationsCreateDefaultApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.AppInvitationsCreateDefaultApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Invites a new or existing user to an app
   */
  appInvitationsCreateByEmail(
    req: operations.AppInvitationsCreateByEmailRequest,
    security: operations.AppInvitationsCreateByEmailSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.AppInvitationsCreateByEmailResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.AppInvitationsCreateByEmailRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v0.1/apps/{owner_name}/{app_name}/invitations/{user_email}",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.AppInvitationsCreateByEmailSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.AppInvitationsCreateByEmailResponse =
        new operations.AppInvitationsCreateByEmailResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.appInvitationsCreateByEmailDefaultApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.AppInvitationsCreateByEmailDefaultApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Removes a user's invitation to an app
   */
  appInvitationsDelete(
    req: operations.AppInvitationsDeleteRequest,
    security: operations.AppInvitationsDeleteSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.AppInvitationsDeleteResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.AppInvitationsDeleteRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v0.1/apps/{owner_name}/{app_name}/invitations/{user_email}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.AppInvitationsDeleteSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.AppInvitationsDeleteResponse =
        new operations.AppInvitationsDeleteResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.appInvitationsDeleteDefaultApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.AppInvitationsDeleteDefaultApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Gets the pending invitations for the app
   */
  appInvitationsList(
    req: operations.AppInvitationsListRequest,
    security: operations.AppInvitationsListSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.AppInvitationsListResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.AppInvitationsListRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v0.1/apps/{owner_name}/{app_name}/invitations",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.AppInvitationsListSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.AppInvitationsListResponse =
        new operations.AppInvitationsListResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.appInvitationsList200ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.AppInvitationsList200ApplicationJSON
              );
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.appInvitationsListDefaultApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.AppInvitationsListDefaultApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Rejects a pending invitation for the specified user
   */
  appInvitationsReject(
    req: operations.AppInvitationsRejectRequest,
    security: operations.AppInvitationsRejectSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.AppInvitationsRejectResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.AppInvitationsRejectRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v0.1/user/invitations/apps/{invitation_token}/reject",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.AppInvitationsRejectSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.AppInvitationsRejectResponse =
        new operations.AppInvitationsRejectResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.appInvitationsRejectDefaultApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.AppInvitationsRejectDefaultApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Update pending invitation permission
   */
  appInvitationsUpdatePermissions(
    req: operations.AppInvitationsUpdatePermissionsRequest,
    security: operations.AppInvitationsUpdatePermissionsSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.AppInvitationsUpdatePermissionsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.AppInvitationsUpdatePermissionsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v0.1/apps/{owner_name}/{app_name}/invitations/{user_email}",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.AppInvitationsUpdatePermissionsSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "patch",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.AppInvitationsUpdatePermissionsResponse =
        new operations.AppInvitationsUpdatePermissionsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.appInvitationsUpdatePermissionsDefaultApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.AppInvitationsUpdatePermissionsDefaultApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Creates a new app and returns it to the caller
   */
  appsCreate(
    req: operations.AppsCreateRequestBody,
    security: operations.AppsCreateSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.AppsCreateResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.AppsCreateRequestBody(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/v0.1/apps";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "request",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.AppsCreateSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.AppsCreateResponse =
        new operations.AppsCreateResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.appsCreate201ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.AppsCreate201ApplicationJSON
            );
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.appsCreateDefaultApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.AppsCreateDefaultApplicationJSON
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Creates a new app for the organization and returns it to the caller
   */
  appsCreateForOrg(
    req: operations.AppsCreateForOrgRequest,
    security: operations.AppsCreateForOrgSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.AppsCreateForOrgResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.AppsCreateForOrgRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v0.1/orgs/{org_name}/apps",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.AppsCreateForOrgSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.AppsCreateForOrgResponse =
        new operations.AppsCreateForOrgResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.appsCreateForOrg200ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.AppsCreateForOrg200ApplicationJSON
            );
          }
          break;
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.appsCreateForOrg201ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.AppsCreateForOrg201ApplicationJSON
            );
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.appsCreateForOrgDefaultApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.AppsCreateForOrgDefaultApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Delete an app
   */
  appsDelete(
    req: operations.AppsDeleteRequest,
    security: operations.AppsDeleteSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.AppsDeleteResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.AppsDeleteRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v0.1/apps/{owner_name}/{app_name}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.AppsDeleteSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.AppsDeleteResponse =
        new operations.AppsDeleteResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.appsDeleteDefaultApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.AppsDeleteDefaultApplicationJSON
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Deletes the uploaded app avatar
   */
  appsDeleteAvatar(
    req: operations.AppsDeleteAvatarRequest,
    security: operations.AppsDeleteAvatarSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.AppsDeleteAvatarResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.AppsDeleteAvatarRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v0.1/apps/{owner_name}/{app_name}/avatar",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.AppsDeleteAvatarSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.AppsDeleteAvatarResponse =
        new operations.AppsDeleteAvatarResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.appsDeleteAvatar200ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.AppsDeleteAvatar200ApplicationJSON
            );
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.appsDeleteAvatarDefaultApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.AppsDeleteAvatarDefaultApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Return a specific app with the given app name which belongs to the given owner.
   */
  appsGet(
    req: operations.AppsGetRequest,
    security: operations.AppsGetSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.AppsGetResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.AppsGetRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v0.1/apps/{owner_name}/{app_name}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.AppsGetSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.AppsGetResponse = new operations.AppsGetResponse({
        statusCode: httpRes.status,
        contentType: contentType,
        rawResponse: httpRes,
      });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.appsGet200ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.AppsGet200ApplicationJSON
            );
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.appsGetDefaultApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.AppsGetDefaultApplicationJSON
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Get a user apps information from an organization by name
   */
  appsGetForOrgUser(
    req: operations.AppsGetForOrgUserRequest,
    security: operations.AppsGetForOrgUserSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.AppsGetForOrgUserResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.AppsGetForOrgUserRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v0.1/orgs/{org_name}/users/{user_name}/apps",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.AppsGetForOrgUserSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.AppsGetForOrgUserResponse =
        new operations.AppsGetForOrgUserResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.appsGetForOrgUser200ApplicationJSONAnies = [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.appsGetForOrgUser200ApplicationJSONAnies = utils.objectToClass(
              httpRes?.data,
              operations.AppsGetForOrgUser200ApplicationJSON,
              resFieldDepth
            );
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.appsGetForOrgUserDefaultApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.AppsGetForOrgUserDefaultApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Returns the details of all teams that have access to the app.
   */
  appsGetTeams(
    req: operations.AppsGetTeamsRequest,
    security: operations.AppsGetTeamsSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.AppsGetTeamsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.AppsGetTeamsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v0.1/apps/{owner_name}/{app_name}/teams",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.AppsGetTeamsSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.AppsGetTeamsResponse =
        new operations.AppsGetTeamsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.appsGetTeams200ApplicationJSONAnies = [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.appsGetTeams200ApplicationJSONAnies = utils.objectToClass(
              httpRes?.data,
              operations.AppsGetTeams200ApplicationJSON,
              resFieldDepth
            );
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.appsGetTeamsDefaultApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.AppsGetTeamsDefaultApplicationJSON
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Returns a list of apps
   */
  appsList(
    req: operations.AppsListRequest,
    security: operations.AppsListSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.AppsListResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.AppsListRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/v0.1/apps";
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.AppsListSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.AppsListResponse = new operations.AppsListResponse({
        statusCode: httpRes.status,
        contentType: contentType,
        rawResponse: httpRes,
      });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.appsList200ApplicationJSONAnies = [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.appsList200ApplicationJSONAnies = utils.objectToClass(
              httpRes?.data,
              operations.AppsList200ApplicationJSON,
              resFieldDepth
            );
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.appsListDefaultApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.AppsListDefaultApplicationJSON
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Returns a list of apps for the organization
   */
  appsListForOrg(
    req: operations.AppsListForOrgRequest,
    security: operations.AppsListForOrgSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.AppsListForOrgResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.AppsListForOrgRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v0.1/orgs/{org_name}/apps",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.AppsListForOrgSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.AppsListForOrgResponse =
        new operations.AppsListForOrgResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.appsListForOrg200ApplicationJSONAnies = [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.appsListForOrg200ApplicationJSONAnies = utils.objectToClass(
              httpRes?.data,
              operations.AppsListForOrg200ApplicationJSON,
              resFieldDepth
            );
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.appsListForOrgDefaultApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.AppsListForOrgDefaultApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Returns the testers associated with the app specified with the given app name which belongs to the given owner.
   */
  appsListTesters(
    req: operations.AppsListTestersRequest,
    security: operations.AppsListTestersSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.AppsListTestersResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.AppsListTestersRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v0.1/apps/{owner_name}/{app_name}/testers",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.AppsListTestersSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.AppsListTestersResponse =
        new operations.AppsListTestersResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.appsListTesters200ApplicationJSONObjects = [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.appsListTesters200ApplicationJSONObjects = utils.objectToClass(
              httpRes?.data,
              operations.AppsListTesters200ApplicationJSON,
              resFieldDepth
            );
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.appsListTestersDefaultApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.AppsListTestersDefaultApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Removes the user from the app
   */
  appsRemoveUser(
    req: operations.AppsRemoveUserRequest,
    security: operations.AppsRemoveUserSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.AppsRemoveUserResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.AppsRemoveUserRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v0.1/apps/{owner_name}/{app_name}/users/{user_email}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.AppsRemoveUserSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.AppsRemoveUserResponse =
        new operations.AppsRemoveUserResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.appsRemoveUserDefaultApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.AppsRemoveUserDefaultApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Transfers ownership of an app to a different user or organization
   */
  appsTransferOwnershipJson(
    req: operations.AppsTransferOwnershipJsonRequest,
    security: operations.AppsTransferOwnershipJsonSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.AppsTransferOwnershipJsonResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.AppsTransferOwnershipJsonRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v0.1/apps/{owner_name}/{app_name}/transfer/{destination_owner_name}",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.AppsTransferOwnershipJsonSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.AppsTransferOwnershipJsonResponse =
        new operations.AppsTransferOwnershipJsonResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.appsTransferOwnershipJSON200ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.AppsTransferOwnershipJson200ApplicationJSON
              );
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.appsTransferOwnershipJSONDefaultApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.AppsTransferOwnershipJSONDefaultApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Transfers ownership of an app to a different user or organization
   */
  appsTransferOwnershipRaw(
    req: operations.AppsTransferOwnershipRawRequest,
    security: operations.AppsTransferOwnershipRawSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.AppsTransferOwnershipRawResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.AppsTransferOwnershipRawRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v0.1/apps/{owner_name}/{app_name}/transfer/{destination_owner_name}",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "raw"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.AppsTransferOwnershipRawSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.AppsTransferOwnershipRawResponse =
        new operations.AppsTransferOwnershipRawResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.appsTransferOwnershipRaw200ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.AppsTransferOwnershipRaw200ApplicationJSON
              );
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.appsTransferOwnershipRawDefaultApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.AppsTransferOwnershipRawDefaultApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Transfers ownership of an app to a new organization
   */
  appsTransferToOrg(
    req: operations.AppsTransferToOrgRequest,
    security: operations.AppsTransferToOrgSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.AppsTransferToOrgResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.AppsTransferToOrgRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v0.1/apps/{owner_name}/{app_name}/transfer_to_org",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.AppsTransferToOrgSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.AppsTransferToOrgResponse =
        new operations.AppsTransferToOrgResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.appsTransferToOrg200ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.AppsTransferToOrg200ApplicationJSON
            );
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.appsTransferToOrgDefaultApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.AppsTransferToOrgDefaultApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Partially updates a single app
   */
  appsUpdate(
    req: operations.AppsUpdateRequest,
    security: operations.AppsUpdateSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.AppsUpdateResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.AppsUpdateRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v0.1/apps/{owner_name}/{app_name}",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.AppsUpdateSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "patch",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.AppsUpdateResponse =
        new operations.AppsUpdateResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.appsUpdate200ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.AppsUpdate200ApplicationJSON
            );
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.appsUpdateDefaultApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.AppsUpdateDefaultApplicationJSON
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Sets the app avatar
   */
  appsUpdateAvatar(
    req: operations.AppsUpdateAvatarRequest,
    security: operations.AppsUpdateAvatarSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.AppsUpdateAvatarResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.AppsUpdateAvatarRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v0.1/apps/{owner_name}/{app_name}/avatar",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "multipart"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.AppsUpdateAvatarSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.AppsUpdateAvatarResponse =
        new operations.AppsUpdateAvatarResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.appsUpdateAvatar200ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.AppsUpdateAvatar200ApplicationJSON
            );
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.appsUpdateAvatarDefaultApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.AppsUpdateAvatarDefaultApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Update user permission for the app
   */
  appsUpdateUserPermissions(
    req: operations.AppsUpdateUserPermissionsRequest,
    security: operations.AppsUpdateUserPermissionsSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.AppsUpdateUserPermissionsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.AppsUpdateUserPermissionsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v0.1/apps/{owner_name}/{app_name}/users/{user_email}",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.AppsUpdateUserPermissionsSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "patch",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.AppsUpdateUserPermissionsResponse =
        new operations.AppsUpdateUserPermissionsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.appsUpdateUserPermissionsDefaultApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.AppsUpdateUserPermissionsDefaultApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Delete the azure subscriptions for the app
   */
  azureSubscriptionDeleteForApp(
    req: operations.AzureSubscriptionDeleteForAppRequest,
    security: operations.AzureSubscriptionDeleteForAppSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.AzureSubscriptionDeleteForAppResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.AzureSubscriptionDeleteForAppRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v0.1/apps/{owner_name}/{app_name}/azure_subscriptions/{azure_subscription_id}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.AzureSubscriptionDeleteForAppSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.AzureSubscriptionDeleteForAppResponse =
        new operations.AzureSubscriptionDeleteForAppResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.azureSubscriptionDeleteForAppDefaultApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.AzureSubscriptionDeleteForAppDefaultApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Link azure subscription to an app
   */
  azureSubscriptionLinkForApp(
    req: operations.AzureSubscriptionLinkForAppRequest,
    security: operations.AzureSubscriptionLinkForAppSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.AzureSubscriptionLinkForAppResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.AzureSubscriptionLinkForAppRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v0.1/apps/{owner_name}/{app_name}/azure_subscriptions",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.AzureSubscriptionLinkForAppSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.AzureSubscriptionLinkForAppResponse =
        new operations.AzureSubscriptionLinkForAppResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.azureSubscriptionLinkForAppDefaultApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.AzureSubscriptionLinkForAppDefaultApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Returns a list of azure subscriptions for the app
   */
  azureSubscriptionListForApp(
    req: operations.AzureSubscriptionListForAppRequest,
    security: operations.AzureSubscriptionListForAppSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.AzureSubscriptionListForAppResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.AzureSubscriptionListForAppRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v0.1/apps/{owner_name}/{app_name}/azure_subscriptions",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.AzureSubscriptionListForAppSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.AzureSubscriptionListForAppResponse =
        new operations.AzureSubscriptionListForAppResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.azureSubscriptionListForApp200ApplicationJSONObjects = [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.azureSubscriptionListForApp200ApplicationJSONObjects =
              utils.objectToClass(
                httpRes?.data,
                operations.AzureSubscriptionListForApp200ApplicationJSON,
                resFieldDepth
              );
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.azureSubscriptionListForAppDefaultApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.AzureSubscriptionListForAppDefaultApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Returns a list of azure subscriptions for the organization
   */
  azureSubscriptionListForOrg(
    req: operations.AzureSubscriptionListForOrgRequest,
    security: operations.AzureSubscriptionListForOrgSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.AzureSubscriptionListForOrgResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.AzureSubscriptionListForOrgRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v0.1/orgs/{org_name}/azure_subscriptions",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.AzureSubscriptionListForOrgSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.AzureSubscriptionListForOrgResponse =
        new operations.AzureSubscriptionListForOrgResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.azureSubscriptionListForOrg200ApplicationJSONObjects = [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.azureSubscriptionListForOrg200ApplicationJSONObjects =
              utils.objectToClass(
                httpRes?.data,
                operations.AzureSubscriptionListForOrg200ApplicationJSON,
                resFieldDepth
              );
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.azureSubscriptionListForOrgDefaultApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.AzureSubscriptionListForOrgDefaultApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Returns a list of azure subscriptions for the user
   */
  azureSubscriptionListForUser(
    config?: AxiosRequestConfig
  ): Promise<operations.AzureSubscriptionListForUserResponse> {
    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/v0.1/azure_subscriptions";

    const client: AxiosInstance = this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.AzureSubscriptionListForUserResponse =
        new operations.AzureSubscriptionListForUserResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.azureSubscriptionListForUser200ApplicationJSONObjects = [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.azureSubscriptionListForUser200ApplicationJSONObjects =
              utils.objectToClass(
                httpRes?.data,
                operations.AzureSubscriptionListForUser200ApplicationJSON,
                resFieldDepth
              );
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.azureSubscriptionListForUserDefaultApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.AzureSubscriptionListForUserDefaultApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Accepts all pending invitations to distribution groups for the specified user
   */
  distributionGroupInvitationsAcceptAll(
    req: Record<string, any>,
    security: operations.DistributionGroupInvitationsAcceptAllSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.DistributionGroupInvitationsAcceptAllResponse> {
    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") +
      "/v0.1/user/invitations/distribution_groups/accept";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "request",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.DistributionGroupInvitationsAcceptAllSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DistributionGroupInvitationsAcceptAllResponse =
        new operations.DistributionGroupInvitationsAcceptAllResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.distributionGroupInvitationsAcceptAllDefaultApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.DistributionGroupInvitationsAcceptAllDefaultApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Add apps to distribution group in an org
   */
  distributionGroupsAddApps(
    req: operations.DistributionGroupsAddAppsRequest,
    security: operations.DistributionGroupsAddAppsSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.DistributionGroupsAddAppsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DistributionGroupsAddAppsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v0.1/orgs/{org_name}/distribution_groups/{distribution_group_name}/apps",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.DistributionGroupsAddAppsSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DistributionGroupsAddAppsResponse =
        new operations.DistributionGroupsAddAppsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
      }

      return res;
    });
  }

  /**
   * Adds the members to the specified distribution group
   */
  distributionGroupsAddUser(
    req: operations.DistributionGroupsAddUserRequest,
    security: operations.DistributionGroupsAddUserSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.DistributionGroupsAddUserResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DistributionGroupsAddUserRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v0.1/apps/{owner_name}/{app_name}/distribution_groups/{distribution_group_name}/members",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.DistributionGroupsAddUserSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DistributionGroupsAddUserResponse =
        new operations.DistributionGroupsAddUserResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.distributionGroupsAddUser200ApplicationJSONObjects = [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.distributionGroupsAddUser200ApplicationJSONObjects =
              utils.objectToClass(
                httpRes?.data,
                operations.DistributionGroupsAddUser200ApplicationJSON,
                resFieldDepth
              );
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.distributionGroupsAddUserDefaultApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.DistributionGroupsAddUserDefaultApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Accepts an array of user email addresses to get added to the specified group
   */
  distributionGroupsAddUsersForOrg(
    req: operations.DistributionGroupsAddUsersForOrgRequest,
    security: operations.DistributionGroupsAddUsersForOrgSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.DistributionGroupsAddUsersForOrgResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DistributionGroupsAddUsersForOrgRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v0.1/orgs/{org_name}/distribution_groups/{distribution_group_name}/members",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.DistributionGroupsAddUsersForOrgSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DistributionGroupsAddUsersForOrgResponse =
        new operations.DistributionGroupsAddUsersForOrgResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.distributionGroupsAddUsersForOrg200ApplicationJSONObjects = [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.distributionGroupsAddUsersForOrg200ApplicationJSONObjects =
              utils.objectToClass(
                httpRes?.data,
                operations.DistributionGroupsAddUsersForOrg200ApplicationJSON,
                resFieldDepth
              );
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.distributionGroupsAddUsersForOrgDefaultApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.DistributionGroupsAddUsersForOrgDefaultApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Delete apps from distribution group in an org
   */
  distributionGroupsBulkDeleteApps(
    req: operations.DistributionGroupsBulkDeleteAppsRequest,
    security: operations.DistributionGroupsBulkDeleteAppsSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.DistributionGroupsBulkDeleteAppsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DistributionGroupsBulkDeleteAppsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v0.1/orgs/{org_name}/distribution_groups/{distribution_group_name}/apps/bulk_delete",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.DistributionGroupsBulkDeleteAppsSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DistributionGroupsBulkDeleteAppsResponse =
        new operations.DistributionGroupsBulkDeleteAppsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
      }

      return res;
    });
  }

  /**
   * Delete testers from distribution group in an org
   */
  distributionGroupsBulkDeleteUsers(
    req: operations.DistributionGroupsBulkDeleteUsersRequest,
    security: operations.DistributionGroupsBulkDeleteUsersSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.DistributionGroupsBulkDeleteUsersResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DistributionGroupsBulkDeleteUsersRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v0.1/orgs/{org_name}/distribution_groups/{distribution_group_name}/members/bulk_delete",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.DistributionGroupsBulkDeleteUsersSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DistributionGroupsBulkDeleteUsersResponse =
        new operations.DistributionGroupsBulkDeleteUsersResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
      }

      return res;
    });
  }

  /**
   * Creates a new distribution group and returns it to the caller
   */
  distributionGroupsCreate(
    req: operations.DistributionGroupsCreateRequest,
    security: operations.DistributionGroupsCreateSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.DistributionGroupsCreateResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DistributionGroupsCreateRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v0.1/apps/{owner_name}/{app_name}/distribution_groups",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.DistributionGroupsCreateSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DistributionGroupsCreateResponse =
        new operations.DistributionGroupsCreateResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.distributionGroupsCreate201ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.DistributionGroupsCreate201ApplicationJSON
              );
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.distributionGroupsCreateDefaultApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.DistributionGroupsCreateDefaultApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Creates a disribution goup which can be shared across apps under an organization
   */
  distributionGroupsCreateForOrg(
    req: operations.DistributionGroupsCreateForOrgRequest,
    security: operations.DistributionGroupsCreateForOrgSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.DistributionGroupsCreateForOrgResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DistributionGroupsCreateForOrgRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v0.1/orgs/{org_name}/distribution_groups",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.DistributionGroupsCreateForOrgSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DistributionGroupsCreateForOrgResponse =
        new operations.DistributionGroupsCreateForOrgResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.distributionGroupsCreateForOrg201ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.DistributionGroupsCreateForOrg201ApplicationJSON
              );
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.distributionGroupsCreateForOrgDefaultApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.DistributionGroupsCreateForOrgDefaultApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Deletes a distribution group
   */
  distributionGroupsDelete(
    req: operations.DistributionGroupsDeleteRequest,
    security: operations.DistributionGroupsDeleteSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.DistributionGroupsDeleteResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DistributionGroupsDeleteRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v0.1/apps/{owner_name}/{app_name}/distribution_groups/{distribution_group_name}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.DistributionGroupsDeleteSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DistributionGroupsDeleteResponse =
        new operations.DistributionGroupsDeleteResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.distributionGroupsDeleteDefaultApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.DistributionGroupsDeleteDefaultApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Deletes a single distribution group from an org with a given distribution group name
   */
  distributionGroupsDeleteForOrg(
    req: operations.DistributionGroupsDeleteForOrgRequest,
    security: operations.DistributionGroupsDeleteForOrgSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.DistributionGroupsDeleteForOrgResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DistributionGroupsDeleteForOrgRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v0.1/orgs/{org_name}/distribution_groups/{distribution_group_name}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.DistributionGroupsDeleteForOrgSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DistributionGroupsDeleteForOrgResponse =
        new operations.DistributionGroupsDeleteForOrgResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.distributionGroupsDeleteForOrgDefaultApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.DistributionGroupsDeleteForOrgDefaultApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Returns a list of distribution groups with details for an organization
   */
  distributionGroupsDetailsForOrg(
    req: operations.DistributionGroupsDetailsForOrgRequest,
    security: operations.DistributionGroupsDetailsForOrgSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.DistributionGroupsDetailsForOrgResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DistributionGroupsDetailsForOrgRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v0.1/orgs/{org_name}/distribution_groups_details",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.DistributionGroupsDetailsForOrgSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DistributionGroupsDetailsForOrgResponse =
        new operations.DistributionGroupsDetailsForOrgResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.distributionGroupsDetailsForOrg200ApplicationJSONAnies = [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.distributionGroupsDetailsForOrg200ApplicationJSONAnies =
              utils.objectToClass(
                httpRes?.data,
                operations.DistributionGroupsDetailsForOrg200ApplicationJSON,
                resFieldDepth
              );
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.distributionGroupsDetailsForOrgDefaultApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.DistributionGroupsDetailsForOrgDefaultApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Returns a single distribution group for a given distribution group name
   */
  distributionGroupsGet(
    req: operations.DistributionGroupsGetRequest,
    security: operations.DistributionGroupsGetSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.DistributionGroupsGetResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DistributionGroupsGetRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v0.1/apps/{owner_name}/{app_name}/distribution_groups/{distribution_group_name}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.DistributionGroupsGetSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DistributionGroupsGetResponse =
        new operations.DistributionGroupsGetResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.distributionGroupsGet200ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.DistributionGroupsGet200ApplicationJSON
              );
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.distributionGroupsGetDefaultApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.DistributionGroupsGetDefaultApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Get apps from a distribution group in an org
   */
  distributionGroupsGetApps(
    req: operations.DistributionGroupsGetAppsRequest,
    security: operations.DistributionGroupsGetAppsSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.DistributionGroupsGetAppsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DistributionGroupsGetAppsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v0.1/orgs/{org_name}/distribution_groups/{distribution_group_name}/apps",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.DistributionGroupsGetAppsSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DistributionGroupsGetAppsResponse =
        new operations.DistributionGroupsGetAppsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.distributionGroupsGetApps200ApplicationJSONAnies = [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.distributionGroupsGetApps200ApplicationJSONAnies =
              utils.objectToClass(
                httpRes?.data,
                operations.DistributionGroupsGetApps200ApplicationJSON,
                resFieldDepth
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Returns a single distribution group in org for a given distribution group name
   */
  distributionGroupsGetForOrg(
    req: operations.DistributionGroupsGetForOrgRequest,
    security: operations.DistributionGroupsGetForOrgSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.DistributionGroupsGetForOrgResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DistributionGroupsGetForOrgRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v0.1/orgs/{org_name}/distribution_groups/{distribution_group_name}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.DistributionGroupsGetForOrgSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DistributionGroupsGetForOrgResponse =
        new operations.DistributionGroupsGetForOrgResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.distributionGroupsGetForOrg200ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.DistributionGroupsGetForOrg200ApplicationJSON
              );
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.distributionGroupsGetForOrgDefaultApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.DistributionGroupsGetForOrgDefaultApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Returns a list of distribution groups in the app specified
   */
  distributionGroupsList(
    req: operations.DistributionGroupsListRequest,
    security: operations.DistributionGroupsListSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.DistributionGroupsListResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DistributionGroupsListRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v0.1/apps/{owner_name}/{app_name}/distribution_groups",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.DistributionGroupsListSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DistributionGroupsListResponse =
        new operations.DistributionGroupsListResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.distributionGroupsList200ApplicationJSONObjects = [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.distributionGroupsList200ApplicationJSONObjects =
              utils.objectToClass(
                httpRes?.data,
                operations.DistributionGroupsList200ApplicationJSON,
                resFieldDepth
              );
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.distributionGroupsListDefaultApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.DistributionGroupsListDefaultApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Returns a unique list of users including the whole organization members plus testers in any shared group of that org
   */
  distributionGroupsListAllTestersForOrg(
    req: operations.DistributionGroupsListAllTestersForOrgRequest,
    security: operations.DistributionGroupsListAllTestersForOrgSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.DistributionGroupsListAllTestersForOrgResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DistributionGroupsListAllTestersForOrgRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v0.1/orgs/{org_name}/testers",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.DistributionGroupsListAllTestersForOrgSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DistributionGroupsListAllTestersForOrgResponse =
        new operations.DistributionGroupsListAllTestersForOrgResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.distributionGroupsListAllTestersForOrg200ApplicationJSONObjects =
              [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.distributionGroupsListAllTestersForOrg200ApplicationJSONObjects =
              utils.objectToClass(
                httpRes?.data,
                operations.DistributionGroupsListAllTestersForOrg200ApplicationJSON,
                resFieldDepth
              );
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.distributionGroupsListAllTestersForOrgDefaultApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.DistributionGroupsListAllTestersForOrgDefaultApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Returns a list of distribution groups in the org specified
   */
  distributionGroupsListForOrg(
    req: operations.DistributionGroupsListForOrgRequest,
    security: operations.DistributionGroupsListForOrgSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.DistributionGroupsListForOrgResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DistributionGroupsListForOrgRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v0.1/orgs/{org_name}/distribution_groups",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.DistributionGroupsListForOrgSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DistributionGroupsListForOrgResponse =
        new operations.DistributionGroupsListForOrgResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.distributionGroupsListForOrg201ApplicationJSONObjects = [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.distributionGroupsListForOrg201ApplicationJSONObjects =
              utils.objectToClass(
                httpRes?.data,
                operations.DistributionGroupsListForOrg201ApplicationJSON,
                resFieldDepth
              );
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.distributionGroupsListForOrgDefaultApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.DistributionGroupsListForOrgDefaultApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Returns a list of member details in the distribution group specified
   */
  distributionGroupsListUsers(
    req: operations.DistributionGroupsListUsersRequest,
    security: operations.DistributionGroupsListUsersSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.DistributionGroupsListUsersResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DistributionGroupsListUsersRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v0.1/apps/{owner_name}/{app_name}/distribution_groups/{distribution_group_name}/members",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.DistributionGroupsListUsersSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DistributionGroupsListUsersResponse =
        new operations.DistributionGroupsListUsersResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.distributionGroupsListUsers200ApplicationJSONObjects = [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.distributionGroupsListUsers200ApplicationJSONObjects =
              utils.objectToClass(
                httpRes?.data,
                operations.DistributionGroupsListUsers200ApplicationJSON,
                resFieldDepth
              );
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.distributionGroupsListUsersDefaultApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.DistributionGroupsListUsersDefaultApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Returns a list of member in the distribution group specified
   */
  distributionGroupsListUsersForOrg(
    req: operations.DistributionGroupsListUsersForOrgRequest,
    security: operations.DistributionGroupsListUsersForOrgSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.DistributionGroupsListUsersForOrgResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DistributionGroupsListUsersForOrgRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v0.1/orgs/{org_name}/distribution_groups/{distribution_group_name}/members",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.DistributionGroupsListUsersForOrgSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DistributionGroupsListUsersForOrgResponse =
        new operations.DistributionGroupsListUsersForOrgResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.distributionGroupsListUsersForOrg200ApplicationJSONObjects = [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.distributionGroupsListUsersForOrg200ApplicationJSONObjects =
              utils.objectToClass(
                httpRes?.data,
                operations.DistributionGroupsListUsersForOrg200ApplicationJSON,
                resFieldDepth
              );
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.distributionGroupsListUsersForOrgDefaultApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.DistributionGroupsListUsersForOrgDefaultApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Update one given distribution group name in an org
   */
  distributionGroupsPatchForOrg(
    req: operations.DistributionGroupsPatchForOrgRequest,
    security: operations.DistributionGroupsPatchForOrgSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.DistributionGroupsPatchForOrgResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DistributionGroupsPatchForOrgRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v0.1/orgs/{org_name}/distribution_groups/{distribution_group_name}",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.DistributionGroupsPatchForOrgSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "patch",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DistributionGroupsPatchForOrgResponse =
        new operations.DistributionGroupsPatchForOrgResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.distributionGroupsPatchForOrg200ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.DistributionGroupsPatchForOrg200ApplicationJSON
              );
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.distributionGroupsPatchForOrgDefaultApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.DistributionGroupsPatchForOrgDefaultApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Remove the users from the distribution group
   */
  distributionGroupsRemoveUser(
    req: operations.DistributionGroupsRemoveUserRequest,
    security: operations.DistributionGroupsRemoveUserSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.DistributionGroupsRemoveUserResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DistributionGroupsRemoveUserRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v0.1/apps/{owner_name}/{app_name}/distribution_groups/{distribution_group_name}/members/bulk_delete",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.DistributionGroupsRemoveUserSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DistributionGroupsRemoveUserResponse =
        new operations.DistributionGroupsRemoveUserResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.distributionGroupsRemoveUser200ApplicationJSONObjects = [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.distributionGroupsRemoveUser200ApplicationJSONObjects =
              utils.objectToClass(
                httpRes?.data,
                operations.DistributionGroupsRemoveUser200ApplicationJSON,
                resFieldDepth
              );
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.distributionGroupsRemoveUserDefaultApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.DistributionGroupsRemoveUserDefaultApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Resend distribution group app invite notification to previously invited testers
   */
  distributionGroupsResendInvite(
    req: operations.DistributionGroupsResendInviteRequest,
    security: operations.DistributionGroupsResendInviteSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.DistributionGroupsResendInviteResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DistributionGroupsResendInviteRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v0.1/apps/{owner_name}/{app_name}/distribution_groups/{distribution_group_name}/resend_invite",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.DistributionGroupsResendInviteSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DistributionGroupsResendInviteResponse =
        new operations.DistributionGroupsResendInviteResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.distributionGroupsResendInviteDefaultApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.DistributionGroupsResendInviteDefaultApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Resend shared distribution group invite notification to previously invited testers
   */
  distributionGroupsResendSharedInvite(
    req: operations.DistributionGroupsResendSharedInviteRequest,
    security: operations.DistributionGroupsResendSharedInviteSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.DistributionGroupsResendSharedInviteResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DistributionGroupsResendSharedInviteRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v0.1/orgs/{org_name}/distribution_groups/{distribution_group_name}/resend_invite",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.DistributionGroupsResendSharedInviteSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DistributionGroupsResendSharedInviteResponse =
        new operations.DistributionGroupsResendSharedInviteResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.distributionGroupsResendSharedInviteDefaultApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.DistributionGroupsResendSharedInviteDefaultApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Updates the attributes of distribution group
   */
  distributionGroupsUpdate(
    req: operations.DistributionGroupsUpdateRequest,
    security: operations.DistributionGroupsUpdateSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.DistributionGroupsUpdateResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DistributionGroupsUpdateRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v0.1/apps/{owner_name}/{app_name}/distribution_groups/{distribution_group_name}",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.DistributionGroupsUpdateSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "patch",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DistributionGroupsUpdateResponse =
        new operations.DistributionGroupsUpdateResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.distributionGroupsUpdate200ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.DistributionGroupsUpdate200ApplicationJSON
              );
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.distributionGroupsUpdateDefaultApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.DistributionGroupsUpdateDefaultApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Returns all invitations sent by the caller
   */
  invitationsSent(
    config?: AxiosRequestConfig
  ): Promise<operations.InvitationsSentResponse> {
    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/v0.1/invitations/sent";

    const client: AxiosInstance = this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.InvitationsSentResponse =
        new operations.InvitationsSentResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.invitationsSent200ApplicationJSONObjects = [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.invitationsSent200ApplicationJSONObjects = utils.objectToClass(
              httpRes?.data,
              operations.InvitationsSent200ApplicationJSON,
              resFieldDepth
            );
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.invitationsSentDefaultApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.InvitationsSentDefaultApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Removes a user's invitation to an organization
   */
  orgInvitations(
    req: operations.OrgInvitationsRequest,
    security: operations.OrgInvitationsSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.OrgInvitationsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.OrgInvitationsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v0.1/orgs/{org_name}/invitations/{email}/revoke",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.OrgInvitationsSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.OrgInvitationsResponse =
        new operations.OrgInvitationsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.orgInvitationsDefaultApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.OrgInvitationsDefaultApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Accepts a pending organization invitation for the specified user
   */
  orgInvitationsAccept(
    req: operations.OrgInvitationsAcceptRequest,
    security: operations.OrgInvitationsAcceptSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.OrgInvitationsAcceptResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.OrgInvitationsAcceptRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v0.1/user/invitations/orgs/{invitation_token}/accept",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.OrgInvitationsAcceptSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.OrgInvitationsAcceptResponse =
        new operations.OrgInvitationsAcceptResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.orgInvitationsAcceptDefaultApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.OrgInvitationsAcceptDefaultApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Invites a new or existing user to an organization
   */
  orgInvitationsCreate(
    req: operations.OrgInvitationsCreateRequest,
    security: operations.OrgInvitationsCreateSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.OrgInvitationsCreateResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.OrgInvitationsCreateRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v0.1/orgs/{org_name}/invitations",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.OrgInvitationsCreateSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.OrgInvitationsCreateResponse =
        new operations.OrgInvitationsCreateResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.orgInvitationsCreateDefaultApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.OrgInvitationsCreateDefaultApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Removes a user's invitation to an organization
   */
  orgInvitationsDelete(
    req: operations.OrgInvitationsDeleteRequest,
    security: operations.OrgInvitationsDeleteSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.OrgInvitationsDeleteResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.OrgInvitationsDeleteRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v0.1/orgs/{org_name}/invitations",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.OrgInvitationsDeleteSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "delete",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.OrgInvitationsDeleteResponse =
        new operations.OrgInvitationsDeleteResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.orgInvitationsDeleteDefaultApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.OrgInvitationsDeleteDefaultApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Gets the pending invitations for the organization
   */
  orgInvitationsListPending(
    req: operations.OrgInvitationsListPendingRequest,
    security: operations.OrgInvitationsListPendingSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.OrgInvitationsListPendingResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.OrgInvitationsListPendingRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v0.1/orgs/{org_name}/invitations",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.OrgInvitationsListPendingSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.OrgInvitationsListPendingResponse =
        new operations.OrgInvitationsListPendingResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.orgInvitationsListPending200ApplicationJSONObjects = [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.orgInvitationsListPending200ApplicationJSONObjects =
              utils.objectToClass(
                httpRes?.data,
                operations.OrgInvitationsListPending200ApplicationJSON,
                resFieldDepth
              );
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.orgInvitationsListPendingDefaultApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.OrgInvitationsListPendingDefaultApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Rejects a pending organization invitation
   */
  orgInvitationsReject(
    req: operations.OrgInvitationsRejectRequest,
    security: operations.OrgInvitationsRejectSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.OrgInvitationsRejectResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.OrgInvitationsRejectRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v0.1/user/invitations/orgs/{invitation_token}/reject",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.OrgInvitationsRejectSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.OrgInvitationsRejectResponse =
        new operations.OrgInvitationsRejectResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.orgInvitationsRejectDefaultApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.OrgInvitationsRejectDefaultApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Cancels an existing organization invitation for the user and sends a new one
   */
  orgInvitationsSendNewInvitation(
    req: operations.OrgInvitationsSendNewInvitationRequest,
    security: operations.OrgInvitationsSendNewInvitationSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.OrgInvitationsSendNewInvitationResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.OrgInvitationsSendNewInvitationRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v0.1/orgs/{org_name}/invitations/{email}/resend",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.OrgInvitationsSendNewInvitationSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.OrgInvitationsSendNewInvitationResponse =
        new operations.OrgInvitationsSendNewInvitationResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.orgInvitationsSendNewInvitationDefaultApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.OrgInvitationsSendNewInvitationDefaultApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Allows the role of an invited user to be changed
   */
  orgInvitationsUpdate(
    req: operations.OrgInvitationsUpdateRequest,
    security: operations.OrgInvitationsUpdateSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.OrgInvitationsUpdateResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.OrgInvitationsUpdateRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v0.1/orgs/{org_name}/invitations/{email}",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.OrgInvitationsUpdateSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "patch",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.OrgInvitationsUpdateResponse =
        new operations.OrgInvitationsUpdateResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.orgInvitationsUpdateDefaultApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.OrgInvitationsUpdateDefaultApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Deletes the uploaded organization avatar
   */
  organizationDeleteAvatar(
    req: operations.OrganizationDeleteAvatarRequest,
    security: operations.OrganizationDeleteAvatarSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.OrganizationDeleteAvatarResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.OrganizationDeleteAvatarRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v0.1/orgs/{org_name}/avatar",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.OrganizationDeleteAvatarSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.OrganizationDeleteAvatarResponse =
        new operations.OrganizationDeleteAvatarResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.organizationDeleteAvatar200ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.OrganizationDeleteAvatar200ApplicationJSON
              );
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.organizationDeleteAvatarDefaultApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.OrganizationDeleteAvatarDefaultApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Sets the organization avatar
   */
  organizationUpdateAvatar(
    req: operations.OrganizationUpdateAvatarRequest,
    security: operations.OrganizationUpdateAvatarSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.OrganizationUpdateAvatarResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.OrganizationUpdateAvatarRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v0.1/orgs/{org_name}/avatar",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "multipart"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.OrganizationUpdateAvatarSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.OrganizationUpdateAvatarResponse =
        new operations.OrganizationUpdateAvatarResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.organizationUpdateAvatar200ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.OrganizationUpdateAvatar200ApplicationJSON
              );
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.organizationUpdateAvatarDefaultApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.OrganizationUpdateAvatarDefaultApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Creates a new organization and returns it to the caller
   */
  organizationsCreateOrUpdate(
    req: operations.OrganizationsCreateOrUpdateRequestBody,
    security: operations.OrganizationsCreateOrUpdateSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.OrganizationsCreateOrUpdateResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.OrganizationsCreateOrUpdateRequestBody(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/v0.1/orgs";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "request",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.OrganizationsCreateOrUpdateSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.OrganizationsCreateOrUpdateResponse =
        new operations.OrganizationsCreateOrUpdateResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.organizationsCreateOrUpdate201ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.OrganizationsCreateOrUpdate201ApplicationJSON
              );
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.organizationsCreateOrUpdateDefaultApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.OrganizationsCreateOrUpdateDefaultApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Deletes a single organization
   */
  organizationsDelete(
    req: operations.OrganizationsDeleteRequest,
    security: operations.OrganizationsDeleteSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.OrganizationsDeleteResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.OrganizationsDeleteRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v0.1/orgs/{org_name}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.OrganizationsDeleteSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.OrganizationsDeleteResponse =
        new operations.OrganizationsDeleteResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.organizationsDeleteDefaultApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.OrganizationsDeleteDefaultApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Returns the details of a single organization
   */
  organizationsGet(
    req: operations.OrganizationsGetRequest,
    security: operations.OrganizationsGetSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.OrganizationsGetResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.OrganizationsGetRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v0.1/orgs/{org_name}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.OrganizationsGetSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.OrganizationsGetResponse =
        new operations.OrganizationsGetResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.organizationsGet200ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.OrganizationsGet200ApplicationJSON
            );
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.organizationsGetDefaultApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.OrganizationsGetDefaultApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Returns a list of organizations the requesting user has access to
   */
  organizationsList(
    config?: AxiosRequestConfig
  ): Promise<operations.OrganizationsListResponse> {
    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/v0.1/orgs";

    const client: AxiosInstance = this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.OrganizationsListResponse =
        new operations.OrganizationsListResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.organizationsList200ApplicationJSONObjects = [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.organizationsList200ApplicationJSONObjects =
              utils.objectToClass(
                httpRes?.data,
                operations.OrganizationsList200ApplicationJSON,
                resFieldDepth
              );
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.organizationsListDefaultApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.OrganizationsListDefaultApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Returns a list organizations in which the requesting user is an admin
   */
  organizationsListAdministered(
    config?: AxiosRequestConfig
  ): Promise<operations.OrganizationsListAdministeredResponse> {
    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/v0.1/administeredOrgs";

    const client: AxiosInstance = this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.OrganizationsListAdministeredResponse =
        new operations.OrganizationsListAdministeredResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.organizationsListAdministered200ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.OrganizationsListAdministered200ApplicationJSON
              );
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.organizationsListAdministeredDefaultApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.OrganizationsListAdministeredDefaultApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Returns a list of organizations the requesting user has access to
   */
  organizationsUpdate(
    req: operations.OrganizationsUpdateRequest,
    security: operations.OrganizationsUpdateSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.OrganizationsUpdateResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.OrganizationsUpdateRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v0.1/orgs/{org_name}",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.OrganizationsUpdateSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "patch",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.OrganizationsUpdateResponse =
        new operations.OrganizationsUpdateResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.organizationsUpdate200ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.OrganizationsUpdate200ApplicationJSON
              );
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.organizationsUpdateDefaultApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.OrganizationsUpdateDefaultApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Gets all service connections of the service type for GDPR export.
   */
  sharedconnectionConnections(
    config?: AxiosRequestConfig
  ): Promise<operations.SharedconnectionConnectionsResponse> {
    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/v0.1/user/export/serviceConnections";

    const client: AxiosInstance = this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.SharedconnectionConnectionsResponse =
        new operations.SharedconnectionConnectionsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.sharedconnectionConnections200ApplicationJSONObjects = [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.sharedconnectionConnections200ApplicationJSONObjects =
              utils.objectToClass(
                httpRes?.data,
                operations.SharedconnectionConnections200ApplicationJSON,
                resFieldDepth
              );
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.sharedconnectionConnectionsDefaultApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.SharedconnectionConnectionsDefaultApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Adds an app to a team
   */
  teamsAddApp(
    req: operations.TeamsAddAppRequest,
    security: operations.TeamsAddAppSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.TeamsAddAppResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.TeamsAddAppRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v0.1/orgs/{org_name}/teams/{team_name}/apps",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.TeamsAddAppSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.TeamsAddAppResponse =
        new operations.TeamsAddAppResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.teamsAddApp201ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.TeamsAddApp201ApplicationJSON
            );
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.teamsAddAppDefaultApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.TeamsAddAppDefaultApplicationJSON
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Adds a new user to a team that is owned by an organization
   */
  teamsAddUser(
    req: operations.TeamsAddUserRequest,
    security: operations.TeamsAddUserSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.TeamsAddUserResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.TeamsAddUserRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v0.1/orgs/{org_name}/teams/{team_name}/users",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.TeamsAddUserSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.TeamsAddUserResponse =
        new operations.TeamsAddUserResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.teamsAddUser201ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.TeamsAddUser201ApplicationJSON
            );
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.teamsAddUserDefaultApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.TeamsAddUserDefaultApplicationJSON
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Creates a team and returns it
   */
  teamsCreateTeam(
    req: operations.TeamsCreateTeamRequest,
    security: operations.TeamsCreateTeamSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.TeamsCreateTeamResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.TeamsCreateTeamRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v0.1/orgs/{org_name}/teams",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.TeamsCreateTeamSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.TeamsCreateTeamResponse =
        new operations.TeamsCreateTeamResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.teamsCreateTeam201ApplicationJSONObjects = [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.teamsCreateTeam201ApplicationJSONObjects = utils.objectToClass(
              httpRes?.data,
              operations.TeamsCreateTeam201ApplicationJSON,
              resFieldDepth
            );
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.teamsCreateTeamDefaultApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.TeamsCreateTeamDefaultApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Deletes a single team
   */
  teamsDelete(
    req: operations.TeamsDeleteRequest,
    security: operations.TeamsDeleteSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.TeamsDeleteResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.TeamsDeleteRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v0.1/orgs/{org_name}/teams/{team_name}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.TeamsDeleteSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.TeamsDeleteResponse =
        new operations.TeamsDeleteResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.teamsDeleteDefaultApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.TeamsDeleteDefaultApplicationJSON
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Returns the details of a single team
   */
  teamsGetTeam(
    req: operations.TeamsGetTeamRequest,
    security: operations.TeamsGetTeamSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.TeamsGetTeamResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.TeamsGetTeamRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v0.1/orgs/{org_name}/teams/{team_name}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.TeamsGetTeamSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.TeamsGetTeamResponse =
        new operations.TeamsGetTeamResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.teamsGetTeam200ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.TeamsGetTeam200ApplicationJSON
            );
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.teamsGetTeamDefaultApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.TeamsGetTeamDefaultApplicationJSON
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Returns the users of a team which is owned by an organization
   */
  teamsGetUsers(
    req: operations.TeamsGetUsersRequest,
    security: operations.TeamsGetUsersSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.TeamsGetUsersResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.TeamsGetUsersRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v0.1/orgs/{org_name}/teams/{team_name}/users",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.TeamsGetUsersSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.TeamsGetUsersResponse =
        new operations.TeamsGetUsersResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.teamsGetUsers200ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.TeamsGetUsers200ApplicationJSON
            );
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.teamsGetUsersDefaultApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.TeamsGetUsersDefaultApplicationJSON
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Returns the list of all teams in this org
   */
  teamsListAll(
    req: operations.TeamsListAllRequest,
    security: operations.TeamsListAllSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.TeamsListAllResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.TeamsListAllRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v0.1/orgs/{org_name}/teams",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.TeamsListAllSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.TeamsListAllResponse =
        new operations.TeamsListAllResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.teamsListAll200ApplicationJSONObjects = [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.teamsListAll200ApplicationJSONObjects = utils.objectToClass(
              httpRes?.data,
              operations.TeamsListAll200ApplicationJSON,
              resFieldDepth
            );
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.teamsListAllDefaultApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.TeamsListAllDefaultApplicationJSON
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Returns the apps a team has access to
   */
  teamsListApps(
    req: operations.TeamsListAppsRequest,
    security: operations.TeamsListAppsSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.TeamsListAppsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.TeamsListAppsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v0.1/orgs/{org_name}/teams/{team_name}/apps",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.TeamsListAppsSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.TeamsListAppsResponse =
        new operations.TeamsListAppsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.teamsListApps200ApplicationJSONAnies = [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.teamsListApps200ApplicationJSONAnies = utils.objectToClass(
              httpRes?.data,
              operations.TeamsListApps200ApplicationJSON,
              resFieldDepth
            );
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.teamsListAppsDefaultApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.TeamsListAppsDefaultApplicationJSON
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Removes an app from a team
   */
  teamsRemoveApp(
    req: operations.TeamsRemoveAppRequest,
    security: operations.TeamsRemoveAppSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.TeamsRemoveAppResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.TeamsRemoveAppRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v0.1/orgs/{org_name}/teams/{team_name}/apps/{app_name}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.TeamsRemoveAppSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.TeamsRemoveAppResponse =
        new operations.TeamsRemoveAppResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.teamsRemoveAppDefaultApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.TeamsRemoveAppDefaultApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Removes a user from a team that is owned by an organization
   */
  teamsRemoveUser(
    req: operations.TeamsRemoveUserRequest,
    security: operations.TeamsRemoveUserSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.TeamsRemoveUserResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.TeamsRemoveUserRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v0.1/orgs/{org_name}/teams/{team_name}/users/{user_name}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.TeamsRemoveUserSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.TeamsRemoveUserResponse =
        new operations.TeamsRemoveUserResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.teamsRemoveUserDefaultApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.TeamsRemoveUserDefaultApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Updates a single team
   */
  teamsUpdate(
    req: operations.TeamsUpdateRequest,
    security: operations.TeamsUpdateSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.TeamsUpdateResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.TeamsUpdateRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v0.1/orgs/{org_name}/teams/{team_name}",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.TeamsUpdateSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "patch",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.TeamsUpdateResponse =
        new operations.TeamsUpdateResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.teamsUpdate200ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.TeamsUpdate200ApplicationJSON
            );
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.teamsUpdateDefaultApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.TeamsUpdateDefaultApplicationJSON
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Updates the permissions the team has to the app
   */
  teamsUpdatePermissions(
    req: operations.TeamsUpdatePermissionsRequest,
    security: operations.TeamsUpdatePermissionsSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.TeamsUpdatePermissionsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.TeamsUpdatePermissionsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v0.1/orgs/{org_name}/teams/{team_name}/apps/{app_name}",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.TeamsUpdatePermissionsSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "patch",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.TeamsUpdatePermissionsResponse =
        new operations.TeamsUpdatePermissionsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.teamsUpdatePermissions200ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.TeamsUpdatePermissions200ApplicationJSON
              );
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.teamsUpdatePermissionsDefaultApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.TeamsUpdatePermissionsDefaultApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Delete the user api_token object with the specific id
   */
  userApiTokensDelete(
    req: operations.UserApiTokensDeleteRequest,
    security: operations.UserApiTokensDeleteSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.UserApiTokensDeleteResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.UserApiTokensDeleteRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v0.1/api_tokens/{api_token_id}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.UserApiTokensDeleteSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UserApiTokensDeleteResponse =
        new operations.UserApiTokensDeleteResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
        case httpRes?.status == 400:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.userApiTokensDelete400ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.UserApiTokensDelete400ApplicationJSON
              );
          }
          break;
        case httpRes?.status == 401:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.userApiTokensDelete401ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.UserApiTokensDelete401ApplicationJSON
              );
          }
          break;
        case httpRes?.status == 404:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.userApiTokensDelete404ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.UserApiTokensDelete404ApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Returns api tokens for the authenticated user
   */
  userApiTokensList(
    config?: AxiosRequestConfig
  ): Promise<operations.UserApiTokensListResponse> {
    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/v0.1/api_tokens";

    const client: AxiosInstance = this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UserApiTokensListResponse =
        new operations.UserApiTokensListResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.userApiTokensList200ApplicationJSONObjects = [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.userApiTokensList200ApplicationJSONObjects =
              utils.objectToClass(
                httpRes?.data,
                operations.UserApiTokensList200ApplicationJSON,
                resFieldDepth
              );
          }
          break;
        case httpRes?.status == 400:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.userApiTokensList400ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.UserApiTokensList400ApplicationJSON
            );
          }
          break;
        case httpRes?.status == 401:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.userApiTokensList401ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.UserApiTokensList401ApplicationJSON
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Creates a new User API token
   */
  userApiTokensNew(
    req: operations.UserApiTokensNewRequestBody,
    security: operations.UserApiTokensNewSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.UserApiTokensNewResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.UserApiTokensNewRequestBody(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/v0.1/api_tokens";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "request",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.UserApiTokensNewSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UserApiTokensNewResponse =
        new operations.UserApiTokensNewResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.userApiTokensNew201ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.UserApiTokensNew201ApplicationJSON
            );
          }
          break;
        case httpRes?.status == 400:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.userApiTokensNew400ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.UserApiTokensNew400ApplicationJSON
            );
          }
          break;
        case httpRes?.status == 401:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.userApiTokensNew401ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.UserApiTokensNew401ApplicationJSON
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Returns the user profile data
   */
  usersGet(config?: AxiosRequestConfig): Promise<operations.UsersGetResponse> {
    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/v0.1/user";

    const client: AxiosInstance = this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UsersGetResponse = new operations.UsersGetResponse({
        statusCode: httpRes.status,
        contentType: contentType,
        rawResponse: httpRes,
      });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.usersGet200ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.UsersGet200ApplicationJSON
            );
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.usersGetDefaultApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.UsersGetDefaultApplicationJSON
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Get a user information from an organization by name - if there is explicit permission return it, if not if not return highest implicit permission
   */
  usersGetForOrg(
    req: operations.UsersGetForOrgRequest,
    security: operations.UsersGetForOrgSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.UsersGetForOrgResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.UsersGetForOrgRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v0.1/orgs/{org_name}/users/{user_name}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.UsersGetForOrgSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UsersGetForOrgResponse =
        new operations.UsersGetForOrgResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.usersGetForOrg200ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.UsersGetForOrg200ApplicationJSON
            );
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.usersGetForOrgDefaultApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.UsersGetForOrgDefaultApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Returns the users associated with the app specified with the given app name which belongs to the given owner.
   */
  usersList(
    req: operations.UsersListRequest,
    security: operations.UsersListSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.UsersListResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.UsersListRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v0.1/apps/{owner_name}/{app_name}/users",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.UsersListSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UsersListResponse =
        new operations.UsersListResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.usersList200ApplicationJSONObjects = [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.usersList200ApplicationJSONObjects = utils.objectToClass(
              httpRes?.data,
              operations.UsersList200ApplicationJSON,
              resFieldDepth
            );
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.usersListDefaultApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.UsersListDefaultApplicationJSON
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Returns a list of users that belong to an organization
   */
  usersListForOrg(
    req: operations.UsersListForOrgRequest,
    security: operations.UsersListForOrgSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.UsersListForOrgResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.UsersListForOrgRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v0.1/orgs/{org_name}/users",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.UsersListForOrgSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UsersListForOrgResponse =
        new operations.UsersListForOrgResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.usersListForOrg200ApplicationJSONObjects = [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.usersListForOrg200ApplicationJSONObjects = utils.objectToClass(
              httpRes?.data,
              operations.UsersListForOrg200ApplicationJSON,
              resFieldDepth
            );
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.usersListForOrgDefaultApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.UsersListForOrgDefaultApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Removes a user from an organization.
   */
  usersRemoveFromOrg(
    req: operations.UsersRemoveFromOrgRequest,
    security: operations.UsersRemoveFromOrgSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.UsersRemoveFromOrgResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.UsersRemoveFromOrgRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v0.1/orgs/{org_name}/users/{user_name}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.UsersRemoveFromOrgSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UsersRemoveFromOrgResponse =
        new operations.UsersRemoveFromOrgResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.usersRemoveFromOrgDefaultApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.UsersRemoveFromOrgDefaultApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Updates the user profile and returns the updated user data
   */
  usersUpdate(
    req: operations.UsersUpdateRequestBody,
    security: operations.UsersUpdateSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.UsersUpdateResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.UsersUpdateRequestBody(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/v0.1/user";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "request",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.UsersUpdateSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "patch",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UsersUpdateResponse =
        new operations.UsersUpdateResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.usersUpdate200ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.UsersUpdate200ApplicationJSON
            );
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.usersUpdateDefaultApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.UsersUpdateDefaultApplicationJSON
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Updates the given organization user
   */
  usersUpdateOrgRole(
    req: operations.UsersUpdateOrgRoleRequest,
    security: operations.UsersUpdateOrgRoleSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.UsersUpdateOrgRoleResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.UsersUpdateOrgRoleRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v0.1/orgs/{org_name}/users/{user_name}",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.UsersUpdateOrgRoleSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "patch",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UsersUpdateOrgRoleResponse =
        new operations.UsersUpdateOrgRoleResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.usersUpdateOrgRole200ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.UsersUpdateOrgRole200ApplicationJSON
              );
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.usersUpdateOrgRoleDefaultApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.UsersUpdateOrgRoleDefaultApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }
}
