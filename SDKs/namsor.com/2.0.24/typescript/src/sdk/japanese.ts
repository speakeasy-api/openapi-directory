/*
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

import * as utils from "../internal/utils";
import * as operations from "./models/operations";
import * as shared from "./models/shared";
import { AxiosInstance, AxiosRequestConfig, AxiosResponse } from "axios";

/**
 * JAPANESE special features
 */
export class Japanese {
  _defaultClient: AxiosInstance;
  _securityClient: AxiosInstance;
  _serverURL: string;
  _language: string;
  _sdkVersion: string;
  _genVersion: string;

  constructor(
    defaultClient: AxiosInstance,
    securityClient: AxiosInstance,
    serverURL: string,
    language: string,
    sdkVersion: string,
    genVersion: string
  ) {
    this._defaultClient = defaultClient;
    this._securityClient = securityClient;
    this._serverURL = serverURL;
    this._language = language;
    this._sdkVersion = sdkVersion;
    this._genVersion = genVersion;
  }

  /**
   * Infer the likely gender of a Japanese full name ex. 王晓明
   */
  genderJapaneseNameFull(
    req: operations.GenderJapaneseNameFullRequest,
    security: operations.GenderJapaneseNameFullSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.GenderJapaneseNameFullResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GenderJapaneseNameFullRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/api2/json/genderJapaneseNameFull/{japaneseName}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.GenderJapaneseNameFullSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GenderJapaneseNameFullResponse =
        new operations.GenderJapaneseNameFullResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.personalNameGenderedOut = utils.objectToClass(
              httpRes?.data,
              shared.PersonalNameGenderedOut
            );
          }
          break;
        case [401, 403].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Infer the likely gender of up to 100 full names
   */
  genderJapaneseNameFullBatch(
    req: shared.BatchPersonalNameIn,
    security: operations.GenderJapaneseNameFullBatchSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.GenderJapaneseNameFullBatchResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new shared.BatchPersonalNameIn(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/api2/json/genderJapaneseNameFullBatch";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "request",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.GenderJapaneseNameFullBatchSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GenderJapaneseNameFullBatchResponse =
        new operations.GenderJapaneseNameFullBatchResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.batchPersonalNameGenderedOut = utils.objectToClass(
              httpRes?.data,
              shared.BatchPersonalNameGenderedOut
            );
          }
          break;
        case [400, 401, 403].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Infer the likely gender of a Japanese name in LATIN (Pinyin).
   */
  genderJapaneseNamePinyin(
    req: operations.GenderJapaneseNamePinyinRequest,
    security: operations.GenderJapaneseNamePinyinSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.GenderJapaneseNamePinyinResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GenderJapaneseNamePinyinRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/api2/json/genderJapaneseName/{japaneseSurname}/{japaneseGivenName}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.GenderJapaneseNamePinyinSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GenderJapaneseNamePinyinResponse =
        new operations.GenderJapaneseNamePinyinResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.firstLastNameGenderedOut = utils.objectToClass(
              httpRes?.data,
              shared.FirstLastNameGenderedOut
            );
          }
          break;
        case [401, 403].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Infer the likely gender of up to 100 Japanese names in LATIN (Pinyin).
   */
  genderJapaneseNamePinyinBatch(
    req: shared.BatchFirstLastNameIn,
    security: operations.GenderJapaneseNamePinyinBatchSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.GenderJapaneseNamePinyinBatchResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new shared.BatchFirstLastNameIn(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/api2/json/genderJapaneseNameBatch";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "request",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.GenderJapaneseNamePinyinBatchSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GenderJapaneseNamePinyinBatchResponse =
        new operations.GenderJapaneseNamePinyinBatchResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.batchFirstLastNameGenderedOut = utils.objectToClass(
              httpRes?.data,
              shared.BatchFirstLastNameGenderedOut
            );
          }
          break;
        case [400, 401, 403].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Identify japanese name candidates in KANJI, based on the romanized name (firstName = japaneseGivenName; lastName=japaneseSurname) with KNOWN gender, ex. Yamamoto Sanae
   */
  japaneseNameGenderKanjiCandidatesBatch(
    req: shared.BatchFirstLastNameGenderIn,
    security: operations.JapaneseNameGenderKanjiCandidatesBatchSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.JapaneseNameGenderKanjiCandidatesBatchResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new shared.BatchFirstLastNameGenderIn(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") +
      "/api2/json/japaneseNameGenderKanjiCandidatesBatch";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "request",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.JapaneseNameGenderKanjiCandidatesBatchSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.JapaneseNameGenderKanjiCandidatesBatchResponse =
        new operations.JapaneseNameGenderKanjiCandidatesBatchResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.batchNameMatchCandidatesOut = utils.objectToClass(
              httpRes?.data,
              shared.BatchNameMatchCandidatesOut
            );
          }
          break;
        case [400, 401, 403].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Identify japanese name candidates in KANJI, based on the romanized name ex. Yamamoto Sanae
   */
  japaneseNameKanjiCandidates(
    req: operations.JapaneseNameKanjiCandidatesRequest,
    security: operations.JapaneseNameKanjiCandidatesSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.JapaneseNameKanjiCandidatesResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.JapaneseNameKanjiCandidatesRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/api2/json/japaneseNameKanjiCandidates/{japaneseSurnameLatin}/{japaneseGivenNameLatin}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.JapaneseNameKanjiCandidatesSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.JapaneseNameKanjiCandidatesResponse =
        new operations.JapaneseNameKanjiCandidatesResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.nameMatchCandidatesOut = utils.objectToClass(
              httpRes?.data,
              shared.NameMatchCandidatesOut
            );
          }
          break;
        case [401, 403].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Identify japanese name candidates in KANJI, based on the romanized name (firstName = japaneseGivenName; lastName=japaneseSurname), ex. Yamamoto Sanae
   */
  japaneseNameKanjiCandidatesBatch(
    req: shared.BatchFirstLastNameIn,
    security: operations.JapaneseNameKanjiCandidatesBatchSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.JapaneseNameKanjiCandidatesBatchResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new shared.BatchFirstLastNameIn(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") +
      "/api2/json/japaneseNameKanjiCandidatesBatch";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "request",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.JapaneseNameKanjiCandidatesBatchSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.JapaneseNameKanjiCandidatesBatchResponse =
        new operations.JapaneseNameKanjiCandidatesBatchResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.batchNameMatchCandidatesOut = utils.objectToClass(
              httpRes?.data,
              shared.BatchNameMatchCandidatesOut
            );
          }
          break;
        case [400, 401, 403].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Identify japanese name candidates in KANJI, based on the romanized name ex. Yamamoto Sanae - and a known gender.
   */
  japaneseNameKanjiCandidates1(
    req: operations.JapaneseNameKanjiCandidates1Request,
    security: operations.JapaneseNameKanjiCandidates1Security,
    config?: AxiosRequestConfig
  ): Promise<operations.JapaneseNameKanjiCandidates1Response> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.JapaneseNameKanjiCandidates1Request(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/api2/json/japaneseNameKanjiCandidates/{japaneseSurnameLatin}/{japaneseGivenNameLatin}/{knownGender}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.JapaneseNameKanjiCandidates1Security(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.JapaneseNameKanjiCandidates1Response =
        new operations.JapaneseNameKanjiCandidates1Response({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.nameMatchCandidatesOut = utils.objectToClass(
              httpRes?.data,
              shared.NameMatchCandidatesOut
            );
          }
          break;
        case [401, 403].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Romanize japanese name, based on the name in Kanji.
   */
  japaneseNameLatinCandidates(
    req: operations.JapaneseNameLatinCandidatesRequest,
    security: operations.JapaneseNameLatinCandidatesSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.JapaneseNameLatinCandidatesResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.JapaneseNameLatinCandidatesRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/api2/json/japaneseNameLatinCandidates/{japaneseSurnameKanji}/{japaneseGivenNameKanji}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.JapaneseNameLatinCandidatesSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.JapaneseNameLatinCandidatesResponse =
        new operations.JapaneseNameLatinCandidatesResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.nameMatchCandidatesOut = utils.objectToClass(
              httpRes?.data,
              shared.NameMatchCandidatesOut
            );
          }
          break;
        case [401, 403].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Romanize japanese names, based on the name in KANJI
   */
  japaneseNameLatinCandidatesBatch(
    req: shared.BatchFirstLastNameIn,
    security: operations.JapaneseNameLatinCandidatesBatchSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.JapaneseNameLatinCandidatesBatchResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new shared.BatchFirstLastNameIn(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") +
      "/api2/json/japaneseNameLatinCandidatesBatch";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "request",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.JapaneseNameLatinCandidatesBatchSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.JapaneseNameLatinCandidatesBatchResponse =
        new operations.JapaneseNameLatinCandidatesBatchResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.batchNameMatchCandidatesOut = utils.objectToClass(
              httpRes?.data,
              shared.BatchNameMatchCandidatesOut
            );
          }
          break;
        case [400, 401, 403].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Return a score for matching Japanese name in KANJI ex. 山本 早苗 with a romanized name ex. Yamamoto Sanae
   */
  japaneseNameMatch(
    req: operations.JapaneseNameMatchRequest,
    security: operations.JapaneseNameMatchSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.JapaneseNameMatchResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.JapaneseNameMatchRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/api2/json/japaneseNameMatch/{japaneseSurnameLatin}/{japaneseGivenNameLatin}/{japaneseName}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.JapaneseNameMatchSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.JapaneseNameMatchResponse =
        new operations.JapaneseNameMatchResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.nameMatchedOut = utils.objectToClass(
              httpRes?.data,
              shared.NameMatchedOut
            );
          }
          break;
        case [401, 403].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Return a score for matching a list of Japanese names in KANJI ex. 山本 早苗 with romanized names ex. Yamamoto Sanae
   */
  japaneseNameMatchBatch(
    req: shared.BatchMatchPersonalFirstLastNameIn,
    security: operations.JapaneseNameMatchBatchSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.JapaneseNameMatchBatchResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new shared.BatchMatchPersonalFirstLastNameIn(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/api2/json/japaneseNameMatchBatch";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "request",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.JapaneseNameMatchBatchSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.JapaneseNameMatchBatchResponse =
        new operations.JapaneseNameMatchBatchResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.batchNameMatchedOut = utils.objectToClass(
              httpRes?.data,
              shared.BatchNameMatchedOut
            );
          }
          break;
        case [400, 401, 403].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * [CREDITS 1 UNIT] Feedback loop to better perform matching Japanese name in KANJI ex. 山本 早苗 with a romanized name ex. Yamamoto Sanae
   */
  japaneseNameMatchFeedbackLoop(
    req: operations.JapaneseNameMatchFeedbackLoopRequest,
    security: operations.JapaneseNameMatchFeedbackLoopSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.JapaneseNameMatchFeedbackLoopResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.JapaneseNameMatchFeedbackLoopRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/api2/json/japaneseNameMatchFeedbackLoop/{japaneseSurnameLatin}/{japaneseGivenNameLatin}/{japaneseName}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.JapaneseNameMatchFeedbackLoopSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.JapaneseNameMatchFeedbackLoopResponse =
        new operations.JapaneseNameMatchFeedbackLoopResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.feedbackLoopOut = utils.objectToClass(
              httpRes?.data,
              shared.FeedbackLoopOut
            );
          }
          break;
        case [401, 403].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Infer the likely first/last name structure of a name, ex. 山本 早苗 or Yamamoto Sanae
   */
  parseJapaneseName(
    req: operations.ParseJapaneseNameRequest,
    security: operations.ParseJapaneseNameSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.ParseJapaneseNameResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ParseJapaneseNameRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/api2/json/parseJapaneseName/{japaneseName}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ParseJapaneseNameSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ParseJapaneseNameResponse =
        new operations.ParseJapaneseNameResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.personalNameParsedOut = utils.objectToClass(
              httpRes?.data,
              shared.PersonalNameParsedOut
            );
          }
          break;
        case [401, 403].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Infer the likely first/last name structure of a name, ex. 山本 早苗 or Yamamoto Sanae
   */
  parseJapaneseNameBatch(
    req: shared.BatchPersonalNameIn,
    security: operations.ParseJapaneseNameBatchSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.ParseJapaneseNameBatchResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new shared.BatchPersonalNameIn(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/api2/json/parseJapaneseNameBatch";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "request",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ParseJapaneseNameBatchSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ParseJapaneseNameBatchResponse =
        new operations.ParseJapaneseNameBatchResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.batchPersonalNameParsedOut = utils.objectToClass(
              httpRes?.data,
              shared.BatchPersonalNameParsedOut
            );
          }
          break;
        case [400, 401, 403].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }
}
