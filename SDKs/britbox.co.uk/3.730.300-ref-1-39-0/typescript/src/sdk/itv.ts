/*
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

import * as utils from "../internal/utils";
import * as operations from "./models/operations";
import * as shared from "./models/shared";
import { AxiosInstance, AxiosRequestConfig, AxiosResponse } from "axios";

export class Itv {
  _defaultClient: AxiosInstance;
  _securityClient: AxiosInstance;
  _serverURL: string;
  _language: string;
  _sdkVersion: string;
  _genVersion: string;

  constructor(
    defaultClient: AxiosInstance,
    securityClient: AxiosInstance,
    serverURL: string,
    language: string,
    sdkVersion: string,
    genVersion: string
  ) {
    this._defaultClient = defaultClient;
    this._securityClient = securityClient;
    this._serverURL = serverURL;
    this._language = language;
    this._sdkVersion = sdkVersion;
    this._genVersion = genVersion;
  }

  /**
   * Activates the discount for a user. Only Stripe platform is currently supported.
   */
  activateSaveOffer(
    req: operations.ActivateSaveOfferRequest,
    security: operations.ActivateSaveOfferSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.ActivateSaveOfferResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ActivateSaveOfferRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/itv/save-offer";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "string"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ActivateSaveOfferSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url + queryParams,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ActivateSaveOfferResponse =
        new operations.ActivateSaveOfferResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case [204, 401, 404, 406].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Change payment card details.
   */
  changeCardDetails(
    req: operations.ChangeCardDetailsRequest,
    security: operations.ChangeCardDetailsSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.ChangeCardDetailsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ChangeCardDetailsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/itv/cards/{platform}",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "itvChangeCardDetailsRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ChangeCardDetailsSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url + queryParams,
      method: "put",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ChangeCardDetailsResponse =
        new operations.ChangeCardDetailsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.serviceError = utils.objectToClass(
              httpRes?.data,
              shared.ServiceError
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Change email address related to account/profile.
   *
   * The expected token scope is Settings.
   *
   */
  changeEmail(
    req: operations.ChangeEmailRequest,
    security: operations.ChangeEmailSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.ChangeEmailResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ChangeEmailRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/itv/changeemail";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "itvChangeEmailRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ChangeEmailSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url + queryParams,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ChangeEmailResponse =
        new operations.ChangeEmailResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.serviceError = utils.objectToClass(
              httpRes?.data,
              shared.ServiceError
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Change marketing preferences related to account/profile.
   *
   * The expected token scope is Settings.
   *
   */
  changeMarketing(
    req: operations.ChangeMarketingRequest,
    security: operations.ChangeMarketingSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.ChangeMarketingResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ChangeMarketingRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/itv/changemarketing";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "itvChangeMarketingRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ChangeMarketingSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url + queryParams,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ChangeMarketingResponse =
        new operations.ChangeMarketingResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.serviceError = utils.objectToClass(
              httpRes?.data,
              shared.ServiceError
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Check whether the user has been previously entitled.
   */
  checkPreviousEntitlements(
    req: operations.CheckPreviousEntitlementsRequest,
    security: operations.CheckPreviousEntitlementsSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.CheckPreviousEntitlementsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CheckPreviousEntitlementsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/itv/had/entitlements";
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.CheckPreviousEntitlementsSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CheckPreviousEntitlementsResponse =
        new operations.CheckPreviousEntitlementsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.itvHadEntitlement = utils.objectToClass(
              httpRes?.data,
              shared.ItvHadEntitlement
            );
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.serviceError = utils.objectToClass(
              httpRes?.data,
              shared.ServiceError
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Validates the coupon/voucher for specified payment platform.
   */
  checkVoucher(
    req: operations.CheckVoucherRequest,
    security: operations.CheckVoucherSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.CheckVoucherResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CheckVoucherRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/itv/voucher/{platform}",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "itvVoucherRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.CheckVoucherSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url + queryParams,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CheckVoucherResponse =
        new operations.CheckVoucherResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.itvVoucher = utils.objectToClass(
              httpRes?.data,
              shared.ItvVoucher
            );
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.serviceError = utils.objectToClass(
              httpRes?.data,
              shared.ServiceError
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Confirms purchase and returns the details of purchased subscription for specified payment platform.
   */
  confirmPurchase(
    req: operations.ConfirmPurchaseRequest,
    security: operations.ConfirmPurchaseSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.ConfirmPurchaseResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ConfirmPurchaseRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/itv/purchase/{platform}",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "itvPurchaseRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ConfirmPurchaseSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url + queryParams,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ConfirmPurchaseResponse =
        new operations.ConfirmPurchaseResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.itvPurchase = utils.objectToClass(
              httpRes?.data,
              shared.ItvPurchase
            );
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.serviceError = utils.objectToClass(
              httpRes?.data,
              shared.ServiceError
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Confirms purchase and returns the details of purchased subscription for specified payment platform.
   */
  confirmPurchaseStrong(
    req: operations.ConfirmPurchaseStrongRequest,
    security: operations.ConfirmPurchaseStrongSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.ConfirmPurchaseStrongResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ConfirmPurchaseStrongRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/itv/purchase/{platform}/strong",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "itvPurchaseStrongRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ConfirmPurchaseStrongSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url + queryParams,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ConfirmPurchaseStrongResponse =
        new operations.ConfirmPurchaseStrongResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.itvPurchaseStrongResponse = utils.objectToClass(
              httpRes?.data,
              shared.ItvPurchaseStrongResponse
            );
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.serviceError = utils.objectToClass(
              httpRes?.data,
              shared.ServiceError
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Confirms purchase and returns the details of purchased subscription for specified payment platform.
   */
  confirmPurchaseWithOffer(
    req: operations.ConfirmPurchaseWithOfferRequest,
    security: operations.ConfirmPurchaseWithOfferSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.ConfirmPurchaseWithOfferResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ConfirmPurchaseWithOfferRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/itv/purchase/{platform}/withoffer",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "itvPurchaseWithOfferRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ConfirmPurchaseWithOfferSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url + queryParams,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ConfirmPurchaseWithOfferResponse =
        new operations.ConfirmPurchaseWithOfferResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.itvPurchaseWithOfferResponse = utils.objectToClass(
              httpRes?.data,
              shared.ItvPurchaseWithOfferResponse
            );
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.serviceError = utils.objectToClass(
              httpRes?.data,
              shared.ServiceError
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Delete account in compliance with GDPR.
   *
   * The expected token scope is Settings.
   *
   */
  deleteAccount(
    req: operations.DeleteAccountRequest,
    security: operations.DeleteAccountSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.DeleteAccountResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DeleteAccountRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/itv/deleteaccount";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "itvDeleteAccountRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.DeleteAccountSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url + queryParams,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DeleteAccountResponse =
        new operations.DeleteAccountResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.serviceError = utils.objectToClass(
              httpRes?.data,
              shared.ServiceError
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Cancel a plan subscription.
   *
   * A cancelled subscription will continue to be valid until the subscription
   * expiry date or next renewal date.
   *
   */
  deleteItvPurchasePlatform(
    req: operations.DeleteItvPurchasePlatformRequest,
    security: operations.DeleteItvPurchasePlatformSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.DeleteItvPurchasePlatformResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DeleteItvPurchasePlatformRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/itv/purchase/{platform}",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "itvCancelSubscriptionRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.DeleteItvPurchasePlatformSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url + queryParams,
      method: "delete",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DeleteItvPurchasePlatformResponse =
        new operations.DeleteItvPurchasePlatformResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.serviceError = utils.objectToClass(
              httpRes?.data,
              shared.ServiceError
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Sends request to execute specified transaction.
   */
  executeTransaction(
    req: operations.ExecuteTransactionRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.ExecuteTransactionResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ExecuteTransactionRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/itv/roku/transaction/{transactionid}",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "itvRokuTransactionRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url + queryParams,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ExecuteTransactionResponse =
        new operations.ExecuteTransactionResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.serviceError = utils.objectToClass(
              httpRes?.data,
              shared.ServiceError
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Provides authorization with parental control pin.
   *
   * Returns an array containing account token with Playback scope.
   *
   * Requires access token with Catalog scope.
   *
   * Pin must be a 4-digit string
   *
   */
  getAccountTokenWithPin(
    req: operations.GetAccountTokenWithPinRequest,
    security: operations.GetAccountTokenWithPinSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.GetAccountTokenWithPinResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetAccountTokenWithPinRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/itv/pinauthorization";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "itvPinAuthRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.GetAccountTokenWithPinSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url + queryParams,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetAccountTokenWithPinResponse =
        new operations.GetAccountTokenWithPinResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.accessTokens = [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.accessTokens = utils.objectToClass(
              httpRes?.data,
              shared.AccessToken,
              resFieldDepth
            );
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.serviceError = utils.objectToClass(
              httpRes?.data,
              shared.ServiceError
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Returns the list of billing records for specified payment platform.
   */
  getBillingHistory(
    req: operations.GetBillingHistoryRequest,
    security: operations.GetBillingHistorySecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.GetBillingHistoryResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetBillingHistoryRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/itv/billinghistory/{platform}",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "itvBillingHistoryRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.GetBillingHistorySecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url + queryParams,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetBillingHistoryResponse =
        new operations.GetBillingHistoryResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.itvBillingHistory = utils.objectToClass(
              httpRes?.data,
              shared.ItvBillingHistory
            );
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.serviceError = utils.objectToClass(
              httpRes?.data,
              shared.ServiceError
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Get payment card details.
   */
  getCardDetails(
    req: operations.GetCardDetailsRequest,
    security: operations.GetCardDetailsSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.GetCardDetailsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetCardDetailsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/itv/cards/{platform}",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "itvGetCardDetailsRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.GetCardDetailsSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url + queryParams,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetCardDetailsResponse =
        new operations.GetCardDetailsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.itvCardDetails = utils.objectToClass(
              httpRes?.data,
              shared.ItvCardDetails
            );
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.serviceError = utils.objectToClass(
              httpRes?.data,
              shared.ServiceError
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Returns current entitlement.
   */
  getCurrentEntitlement(
    req: operations.GetCurrentEntitlementRequest,
    security: operations.GetCurrentEntitlementSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.GetCurrentEntitlementResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetCurrentEntitlementRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/itv/entitlements/current";
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.GetCurrentEntitlementSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetCurrentEntitlementResponse =
        new operations.GetCurrentEntitlementResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.itvEntitlementCurrent = utils.objectToClass(
              httpRes?.data,
              shared.ItvEntitlementCurrent
            );
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.serviceError = utils.objectToClass(
              httpRes?.data,
              shared.ServiceError
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Returns the details of current subscription for specified payment platform.
   */
  getCurrentSubscription(
    req: operations.GetCurrentSubscriptionRequest,
    security: operations.GetCurrentSubscriptionSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.GetCurrentSubscriptionResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetCurrentSubscriptionRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/itv/purchase/{platform}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.GetCurrentSubscriptionSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetCurrentSubscriptionResponse =
        new operations.GetCurrentSubscriptionResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.itvCurrentSubscription = utils.objectToClass(
              httpRes?.data,
              shared.ItvCurrentSubscription
            );
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.serviceError = utils.objectToClass(
              httpRes?.data,
              shared.ServiceError
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Returns the state of subscription for any payment platform.
   */
  getEntitlementsHistory(
    req: operations.GetEntitlementsHistoryRequest,
    security: operations.GetEntitlementsHistorySecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.GetEntitlementsHistoryResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetEntitlementsHistoryRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/itv/entitlements/history";
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.GetEntitlementsHistorySecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetEntitlementsHistoryResponse =
        new operations.GetEntitlementsHistoryResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.itvEntitlementsHistory = utils.objectToClass(
              httpRes?.data,
              shared.ItvEntitlementsHistory
            );
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.serviceError = utils.objectToClass(
              httpRes?.data,
              shared.ServiceError
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Gets info whether or not a feature is enabled or disabled using a feature flag. Feature flags are set as a custom field within PM. It also supports custom feature flag data if needed. Such data can be return as well.
   */
  getFeatureFlag(
    req: operations.GetFeatureFlagRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetFeatureFlagResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetFeatureFlagRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/itv/featureFlag/{feature}",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetFeatureFlagResponse =
        new operations.GetFeatureFlagResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.itvFeatureFlag = utils.objectToClass(
              httpRes?.data,
              shared.ItvFeatureFlag
            );
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.serviceError = utils.objectToClass(
              httpRes?.data,
              shared.ServiceError
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Returns full price renewal state and reason for specific user.
   */
  getFullPriceRenewal(
    req: operations.GetFullPriceRenewalRequest,
    security: operations.GetFullPriceRenewalSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.GetFullPriceRenewalResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetFullPriceRenewalRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/itv/subscription/fullpricerenewal";
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.GetFullPriceRenewalSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetFullPriceRenewalResponse =
        new operations.GetFullPriceRenewalResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.itvSubscriptionFullPriceRenewal = utils.objectToClass(
              httpRes?.data,
              shared.ItvSubscriptionFullPriceRenewal
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Returns the ITV profile token.
   */
  getItvProfileToken(
    req: operations.GetItvProfileTokenRequest,
    security: operations.GetItvProfileTokenSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.GetItvProfileTokenResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetItvProfileTokenRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/itv/profiletoken";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "itvProfileTokenRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.GetItvProfileTokenSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url + queryParams,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetItvProfileTokenResponse =
        new operations.GetItvProfileTokenResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.itvProfileToken = utils.objectToClass(
              httpRes?.data,
              shared.ItvProfileToken
            );
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.serviceError = utils.objectToClass(
              httpRes?.data,
              shared.ServiceError
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Returns public preview for Samsung based on the page '/samsung-preview' configured in PresentationManager.
   * There is a hard limit of max 40 items to be returned. It splits evenly items count into the page rows, remaining items are added into the first row.
   *
   */
  getPublicPreview(
    config?: AxiosRequestConfig
  ): Promise<operations.GetPublicPreviewResponse> {
    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/samsung-preview";

    const client: AxiosInstance = this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetPublicPreviewResponse =
        new operations.GetPublicPreviewResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.samsungPreview = utils.objectToClass(
              httpRes?.data,
              shared.SamsungPreview
            );
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.serviceError = utils.objectToClass(
              httpRes?.data,
              shared.ServiceError
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Get the list of recommended items under the active profile.
   */
  getRecommendedList(
    req: operations.GetRecommendedListRequest,
    security: operations.GetRecommendedListSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.GetRecommendedListResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetRecommendedListRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/itv/profile/recommendation/list";
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.GetRecommendedListSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetRecommendedListResponse =
        new operations.GetRecommendedListResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.itemList = utils.objectToClass(httpRes?.data, shared.ItemList);
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.serviceError = utils.objectToClass(
              httpRes?.data,
              shared.ServiceError
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Checks the provided coupon id for a user. Only Stripe platform is currently supported.
   */
  getSaveOffer(
    req: operations.GetSaveOfferRequest,
    security: operations.GetSaveOfferSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.GetSaveOfferResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetSaveOfferRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/itv/save-offer";
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.GetSaveOfferSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetSaveOfferResponse =
        new operations.GetSaveOfferResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.itvGetDiscountResponse = utils.objectToClass(
              httpRes?.data,
              shared.ItvGetDiscountResponse
            );
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.serviceError = utils.objectToClass(
              httpRes?.data,
              shared.ServiceError
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Returns the state of subscription for any payment platform.
   */
  getSubscriptionState(
    req: operations.GetSubscriptionStateRequest,
    security: operations.GetSubscriptionStateSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.GetSubscriptionStateResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetSubscriptionStateRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/itv/subscriptionstate";
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.GetSubscriptionStateSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetSubscriptionStateResponse =
        new operations.GetSubscriptionStateResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.itvSubscriptionState = utils.objectToClass(
              httpRes?.data,
              shared.ItvSubscriptionState
            );
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.serviceError = utils.objectToClass(
              httpRes?.data,
              shared.ServiceError
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Returns status of latest payment intent.
   */
  getSubscriptionStatus(
    req: operations.GetSubscriptionStatusRequest,
    security: operations.GetSubscriptionStatusSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.GetSubscriptionStatusResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetSubscriptionStatusRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/itv/subscription/status/{platform}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.GetSubscriptionStatusSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetSubscriptionStatusResponse =
        new operations.GetSubscriptionStatusResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.itvSubscriptionStatusResponse = utils.objectToClass(
              httpRes?.data,
              shared.ItvSubscriptionStatusResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Returns an upcoming invoice
   */
  getUpcomingInvoice(
    req: operations.GetUpcomingInvoiceRequest,
    security: operations.GetUpcomingInvoiceSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.GetUpcomingInvoiceResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetUpcomingInvoiceRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/itv/upcominginvoice";
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.GetUpcomingInvoiceSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetUpcomingInvoiceResponse =
        new operations.GetUpcomingInvoiceResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.itvGetDiscountResponse = utils.objectToClass(
              httpRes?.data,
              shared.ItvGetDiscountResponse
            );
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.serviceError = utils.objectToClass(
              httpRes?.data,
              shared.ServiceError
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Checks the provided coupon id for a user. Only Stripe platform is currently supported.
   */
  getVoucherById(
    req: operations.GetVoucherByIdRequest,
    security: operations.GetVoucherByIdSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.GetVoucherByIdResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetVoucherByIdRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/itv/voucher/{planId}/{voucherId}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.GetVoucherByIdSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetVoucherByIdResponse =
        new operations.GetVoucherByIdResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.itvVoucher = utils.objectToClass(
              httpRes?.data,
              shared.ItvVoucher
            );
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.serviceError = utils.objectToClass(
              httpRes?.data,
              shared.ServiceError
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Redirects to corresponding Axis Item details page.
   */
  getItvItemsummaryExternalId(
    req: operations.GetItvItemsummaryExternalIdRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetItvItemsummaryExternalIdResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetItvItemsummaryExternalIdRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/itv/itemsummary/{externalId}",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetItvItemsummaryExternalIdResponse =
        new operations.GetItvItemsummaryExternalIdResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 302:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getItvItemsummaryExternalId302ApplicationJSONObject =
              utils.objectToClass(httpRes?.data);
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.serviceError = utils.objectToClass(
              httpRes?.data,
              shared.ServiceError
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Returns the plans available for specified payment platform.
   */
  getItvPlansPlatform(
    req: operations.GetItvPlansPlatformRequest,
    security: operations.GetItvPlansPlatformSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.GetItvPlansPlatformResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetItvPlansPlatformRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/itv/plans/{platform}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.GetItvPlansPlatformSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetItvPlansPlatformResponse =
        new operations.GetItvPlansPlatformResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.itvPlans = utils.objectToClass(httpRes?.data, shared.ItvPlans);
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.serviceError = utils.objectToClass(
              httpRes?.data,
              shared.ServiceError
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Returns the ITV profile object.
   */
  getItvProfile(
    req: operations.GetItvProfileRequest,
    security: operations.GetItvProfileSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.GetItvProfileResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetItvProfileRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/itv/profile";
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.GetItvProfileSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetItvProfileResponse =
        new operations.GetItvProfileResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getItvProfile200ApplicationJSONObject = utils.objectToClass(
              httpRes?.data
            );
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.serviceError = utils.objectToClass(
              httpRes?.data,
              shared.ServiceError
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Gets available Roku plans.
   */
  getItvRokuPlans(
    req: operations.GetItvRokuPlansRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetItvRokuPlansResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetItvRokuPlansRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/itv/roku/plans";

    const client: AxiosInstance = this._defaultClient;

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetItvRokuPlansResponse =
        new operations.GetItvRokuPlansResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.rokuPlans = utils.objectToClass(
              httpRes?.data,
              shared.RokuPlans
            );
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.serviceError = utils.objectToClass(
              httpRes?.data,
              shared.ServiceError
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Get the list of recommended items under the active profile.
   */
  googlePaySubscription(
    req: operations.GooglePaySubscriptionRequest,
    security: operations.GooglePaySubscriptionSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.GooglePaySubscriptionResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GooglePaySubscriptionRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/itv/googlepay/subscription";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "itvGooglePaySubscriptionRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.GooglePaySubscriptionSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url + queryParams,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GooglePaySubscriptionResponse =
        new operations.GooglePaySubscriptionResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case [204, 400, 401, 409, 415, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Resubscription for a user.
   */
  resubscribe(
    req: operations.ResubscribeRequest,
    security: operations.ResubscribeSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.ResubscribeResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ResubscribeRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/itv/resubscribe/{platform}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ResubscribeSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "post",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ResubscribeResponse =
        new operations.ResubscribeResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.resubscribe200ApplicationJSONObject = utils.objectToClass(
              httpRes?.data
            );
          }
          break;
        case [401, 404, 406, 409, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Change payment method details.
   */
  updatePaymentIntentStrong(
    req: operations.UpdatePaymentIntentStrongRequest,
    security: operations.UpdatePaymentIntentStrongSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.UpdatePaymentIntentStrongResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.UpdatePaymentIntentStrongRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/itv/updateIntent/strong/{platform}",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "itvUpdateIntentStrongRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.UpdatePaymentIntentStrongSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url + queryParams,
      method: "put",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UpdatePaymentIntentStrongResponse =
        new operations.UpdatePaymentIntentStrongResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.itvUpdateIntentStrongResponse = utils.objectToClass(
              httpRes?.data,
              shared.ItvUpdateIntentStrongResponse
            );
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.serviceError = utils.objectToClass(
              httpRes?.data,
              shared.ServiceError
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Change payment method details.
   */
  updatePaymentMethodStrong(
    req: operations.UpdatePaymentMethodStrongRequest,
    security: operations.UpdatePaymentMethodStrongSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.UpdatePaymentMethodStrongResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.UpdatePaymentMethodStrongRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/itv/updatePayment/strong/{platform}",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "itvUpdatePaymentStrongRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.UpdatePaymentMethodStrongSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url + queryParams,
      method: "put",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UpdatePaymentMethodStrongResponse =
        new operations.UpdatePaymentMethodStrongResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.serviceError = utils.objectToClass(
              httpRes?.data,
              shared.ServiceError
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Update ITV profile.
   *
   * The expected token scope is Settings.
   *
   */
  updateProfile(
    req: operations.UpdateProfileRequest,
    security: operations.UpdateProfileSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.UpdateProfileResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.UpdateProfileRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/itv/profile";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "itvUpdateProfileRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.UpdateProfileSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url + queryParams,
      method: "put",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UpdateProfileResponse =
        new operations.UpdateProfileResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.serviceError = utils.objectToClass(
              httpRes?.data,
              shared.ServiceError
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Upgrades the plan for the current user.
   */
  upgradePlan(
    req: operations.UpgradePlanRequest,
    security: operations.UpgradePlanSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.UpgradePlanResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.UpgradePlanRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(baseURL, "/itv/plan/{platform}", req);

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "itvUpgradePlanRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.UpgradePlanSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url + queryParams,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UpgradePlanResponse =
        new operations.UpgradePlanResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.serviceError = utils.objectToClass(
              httpRes?.data,
              shared.ServiceError
            );
          }
          break;
      }

      return res;
    });
  }
}
