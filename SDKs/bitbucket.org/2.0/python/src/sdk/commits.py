"""Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT."""

import requests as requests_http
from . import utils
from sdk.models import operations, shared
from typing import Any, Optional

class Commits:
    r"""These are the repository's commits. They are paginated and returned in
    reverse chronological order, similar to the output of git log.
    """
    _client: requests_http.Session
    _security_client: requests_http.Session
    _server_url: str
    _language: str
    _sdk_version: str
    _gen_version: str

    def __init__(self, client: requests_http.Session, security_client: requests_http.Session, server_url: str, language: str, sdk_version: str, gen_version: str) -> None:
        self._client = client
        self._security_client = security_client
        self._server_url = server_url
        self._language = language
        self._sdk_version = sdk_version
        self._gen_version = gen_version
        
    def bulk_create_or_update_annotations(self, request: operations.BulkCreateOrUpdateAnnotationsRequest) -> operations.BulkCreateOrUpdateAnnotationsResponse:
        r"""Bulk create or update annotations
        Bulk upload of annotations.
        Annotations are individual findings that have been identified as part of a report, for example, a line of code that represents a vulnerability. These annotations can be attached to a specific file and even a specific line in that file, however, that is optional. Annotations are not mandatory and a report can contain up to 1000 annotations.
        
        Add the annotations you want to upload as objects in a JSON array and make sure each annotation has the external_id field set to a unique value. If you want to use an existing id from your own system, we recommend prefixing it with your system's name to avoid collisions, for example, mySystem-annotation001. The external id can later be used to identify the report as an alternative to the generated [UUID](https://developer.atlassian.com/bitbucket/api/2/reference/meta/uri-uuid#uuid). You can upload up to 100 annotations per POST request.
        
        ### Sample cURL request:
        ```
        curl --location 'https://api.bitbucket.org/2.0/repositories/<username>/<reposity-name>/commit/<commit-hash>/reports/mysystem-001/annotations' \
        --header 'Content-Type: application/json' \
        --data-raw '[
          {
                \"external_id\": \"mysystem-annotation001\",
                \"title\": \"Security scan report\",
                \"annotation_type\": \"VULNERABILITY\",
                \"summary\": \"This line represents a security threat.\",
                \"severity\": \"HIGH\",
              \"path\": \"my-service/src/main/java/com/myCompany/mysystem/logic/Main.java\",
                \"line\": 42
          },
          {
                \"external_id\": \"mySystem-annotation002\",
                \"title\": \"Bug report\",
                \"annotation_type\": \"BUG\",
                \"result\": \"FAILED\",
                \"summary\": \"This line might introduce a bug.\",
                \"severity\": \"MEDIUM\",
              \"path\": \"my-service/src/main/java/com/myCompany/mysystem/logic/Helper.java\",
                \"line\": 13
          }
        ]'
        ```
        
        ### Possible field values:
        annotation_type: VULNERABILITY, CODE_SMELL, BUG
        result: PASSED, FAILED, IGNORED, SKIPPED
        severity: HIGH, MEDIUM, LOW, CRITICAL
        
        Please refer to the [Code Insights documentation](https://confluence.atlassian.com/bitbucket/code-insights-994316785.html) for more information.
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.BulkCreateOrUpdateAnnotationsRequest, base_url, '/repositories/{workspace}/{repo_slug}/commit/{commit}/reports/{reportId}/annotations', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = self._client
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.BulkCreateOrUpdateAnnotationsResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[list[dict[str, Any]]])
                res.report_annotations = out

        return res

    def create_or_update_annotation(self, request: operations.CreateOrUpdateAnnotationRequest) -> operations.CreateOrUpdateAnnotationResponse:
        r"""Create or update an annotation
        Creates or updates an individual annotation for the specified report.
        Annotations are individual findings that have been identified as part of a report, for example, a line of code that represents a vulnerability. These annotations can be attached to a specific file and even a specific line in that file, however, that is optional. Annotations are not mandatory and a report can contain up to 1000 annotations.
        
        Just as reports, annotation needs to be uploaded with a unique ID that can later be used to identify the report as an alternative to the generated [UUID](https://developer.atlassian.com/bitbucket/api/2/reference/meta/uri-uuid#uuid). If you want to use an existing id from your own system, we recommend prefixing it with your system's name to avoid collisions, for example, mySystem-annotation001.
        
        ### Sample cURL request:
        ```
        curl --request PUT 'https://api.bitbucket.org/2.0/repositories/<username>/<reposity-name>/commit/<commit-hash>/reports/mySystem-001/annotations/mysystem-annotation001' \
        --header 'Content-Type: application/json' \
        --data-raw '{
            \"title\": \"Security scan report\",
            \"annotation_type\": \"VULNERABILITY\",
            \"summary\": \"This line represents a security thread.\",
            \"severity\": \"HIGH\",
            \"path\": \"my-service/src/main/java/com/myCompany/mysystem/logic/Main.java\",
            \"line\": 42
        }'
        ```
        
        ### Possible field values:
        annotation_type: VULNERABILITY, CODE_SMELL, BUG
        result: PASSED, FAILED, IGNORED, SKIPPED
        severity: HIGH, MEDIUM, LOW, CRITICAL
        
        Please refer to the [Code Insights documentation](https://confluence.atlassian.com/bitbucket/code-insights-994316785.html) for more information.
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.CreateOrUpdateAnnotationRequest, base_url, '/repositories/{workspace}/{repo_slug}/commit/{commit}/reports/{reportId}/annotations/{annotationId}', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = self._client
        
        http_res = client.request('PUT', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.CreateOrUpdateAnnotationResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[dict[str, Any]])
                res.report_annotation = out
        elif http_res.status_code == 400:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[dict[str, Any]])
                res.error = out

        return res

    def create_or_update_report(self, request: operations.CreateOrUpdateReportRequest) -> operations.CreateOrUpdateReportResponse:
        r"""Create or update a report
        Creates or updates a report for the specified commit.
        To upload a report, make sure to generate an ID that is unique across all reports for that commit. If you want to use an existing id from your own system, we recommend prefixing it with your system's name to avoid collisions, for example, mySystem-001.
        
        ### Sample cURL request:
        ```
        curl --request PUT 'https://api.bitbucket.org/2.0/repositories/<username>/<reposity-name>/commit/<commit-hash>/reports/mysystem-001' \
        --header 'Content-Type: application/json' \
        --data-raw '{
            \"title\": \"Security scan report\",
            \"details\": \"This pull request introduces 10 new dependency vulnerabilities.\",
            \"report_type\": \"SECURITY\",
            \"reporter\": \"mySystem\",
            \"link\": \"http://www.mysystem.com/reports/001\",
            \"result\": \"FAILED\",
            \"data\": [
                {
                    \"title\": \"Duration (seconds)\",
                    \"type\": \"DURATION\",
                    \"value\": 14
                },
                {
                    \"title\": \"Safe to merge?\",
                    \"type\": \"BOOLEAN\",
                    \"value\": false
                }
            ]
        }'
        ```
        
        ### Possible field values:
        report_type: SECURITY, COVERAGE, TEST, BUG
        result: PASSED, FAILED, PENDING
        data.type: BOOLEAN, DATE, DURATION, LINK, NUMBER, PERCENTAGE, TEXT
        
        #### Data field formats
        | Type  Field   | Value Field Type  | Value Field Display |
        |:--------------|:------------------|:--------------------|
        | None/ Omitted | Number, String or Boolean (not an array or object) | Plain text |
        | BOOLEAN	| Boolean | The value will be read as a JSON boolean and displayed as 'Yes' or 'No'. |
        | DATE  | Number | The value will be read as a JSON number in the form of a Unix timestamp (milliseconds) and will be displayed as a relative date if the date is less than one week ago, otherwise  it will be displayed as an absolute date. |
        | DURATION | Number | The value will be read as a JSON number in milliseconds and will be displayed in a human readable duration format. |
        | LINK | Object: `{\"text\": \"Link text here\", \"href\": \"https://link.to.annotation/in/external/tool\"}` | The value will be read as a JSON object containing the fields \"text\" and \"href\" and will be displayed as a clickable link on the report. |
        | NUMBER | Number | The value will be read as a JSON number and large numbers will be  displayed in a human readable format (e.g. 14.3k). |
        | PERCENTAGE | Number (between 0 and 100) | The value will be read as a JSON number between 0 and 100 and will be displayed with a percentage sign. |
        | TEXT | String | The value will be read as a JSON string and will be displayed as-is |
        
        Please refer to the [Code Insights documentation](https://confluence.atlassian.com/bitbucket/code-insights-994316785.html) for more information.
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.CreateOrUpdateReportRequest, base_url, '/repositories/{workspace}/{repo_slug}/commit/{commit}/reports/{reportId}', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = self._client
        
        http_res = client.request('PUT', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.CreateOrUpdateReportResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[dict[str, Any]])
                res.report = out
        elif http_res.status_code == 400:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[dict[str, Any]])
                res.error = out

        return res

    def delete_annotation(self, request: operations.DeleteAnnotationRequest) -> operations.DeleteAnnotationResponse:
        r"""Delete an annotation
        Deletes a single Annotation matching the provided ID.
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.DeleteAnnotationRequest, base_url, '/repositories/{workspace}/{repo_slug}/commit/{commit}/reports/{reportId}/annotations/{annotationId}', request)
        
        
        client = self._client
        
        http_res = client.request('DELETE', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DeleteAnnotationResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        

        return res

    def delete_report(self, request: operations.DeleteReportRequest) -> operations.DeleteReportResponse:
        r"""Delete a report
        Deletes a single Report matching the provided ID.
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.DeleteReportRequest, base_url, '/repositories/{workspace}/{repo_slug}/commit/{commit}/reports/{reportId}', request)
        
        
        client = self._client
        
        http_res = client.request('DELETE', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DeleteReportResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        

        return res

    def delete_repositories_workspace_repo_slug_commit_commit_approve(self, request: operations.DeleteRepositoriesWorkspaceRepoSlugCommitCommitApproveRequest, security: operations.DeleteRepositoriesWorkspaceRepoSlugCommitCommitApproveSecurity) -> operations.DeleteRepositoriesWorkspaceRepoSlugCommitCommitApproveResponse:
        r"""Unapprove a commit
        Redact the authenticated user's approval of the specified commit.
        
        This operation is only available to users that have explicit access to
        the repository. In contrast, just the fact that a repository is
        publicly accessible to users does not give them the ability to approve
        commits.
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.DeleteRepositoriesWorkspaceRepoSlugCommitCommitApproveRequest, base_url, '/repositories/{workspace}/{repo_slug}/commit/{commit}/approve', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('DELETE', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DeleteRepositoriesWorkspaceRepoSlugCommitCommitApproveResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 204:
            pass
        elif http_res.status_code == 404:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[dict[str, Any]])
                res.error = out

        return res

    def delete_repositories_workspace_repo_slug_commit_commit_comments_comment_id_(self, request: operations.DeleteRepositoriesWorkspaceRepoSlugCommitCommitCommentsCommentIDRequest, security: operations.DeleteRepositoriesWorkspaceRepoSlugCommitCommitCommentsCommentIDSecurity) -> operations.DeleteRepositoriesWorkspaceRepoSlugCommitCommitCommentsCommentIDResponse:
        r"""Delete a commit comment
        Deletes the specified commit comment.
        
        Note that deleting comments that have visible replies that point to
        them will not really delete the resource. This is to retain the integrity
        of the original comment tree. Instead, the `deleted` element is set to
        `true` and the content is blanked out. The comment will continue to be
        returned by the collections and self endpoints.
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.DeleteRepositoriesWorkspaceRepoSlugCommitCommitCommentsCommentIDRequest, base_url, '/repositories/{workspace}/{repo_slug}/commit/{commit}/comments/{comment_id}', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('DELETE', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DeleteRepositoriesWorkspaceRepoSlugCommitCommitCommentsCommentIDResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        

        return res

    def get_annotation(self, request: operations.GetAnnotationRequest) -> operations.GetAnnotationResponse:
        r"""Get an annotation
        Returns a single Annotation matching the provided ID.
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.GetAnnotationRequest, base_url, '/repositories/{workspace}/{repo_slug}/commit/{commit}/reports/{reportId}/annotations/{annotationId}', request)
        
        
        client = self._client
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetAnnotationResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[dict[str, Any]])
                res.report_annotation = out
        elif http_res.status_code == 404:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[dict[str, Any]])
                res.error = out

        return res

    def get_annotations_for_report(self, request: operations.GetAnnotationsForReportRequest) -> operations.GetAnnotationsForReportResponse:
        r"""List annotations
        Returns a paginated list of Annotations for a specified report.
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.GetAnnotationsForReportRequest, base_url, '/repositories/{workspace}/{repo_slug}/commit/{commit}/reports/{reportId}/annotations', request)
        
        
        client = self._client
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetAnnotationsForReportResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.PaginatedAnnotations])
                res.paginated_annotations = out

        return res

    def get_report(self, request: operations.GetReportRequest) -> operations.GetReportResponse:
        r"""Get a report
        Returns a single Report matching the provided ID.
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.GetReportRequest, base_url, '/repositories/{workspace}/{repo_slug}/commit/{commit}/reports/{reportId}', request)
        
        
        client = self._client
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetReportResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[dict[str, Any]])
                res.report = out
        elif http_res.status_code == 404:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[dict[str, Any]])
                res.error = out

        return res

    def get_reports_for_commit(self, request: operations.GetReportsForCommitRequest) -> operations.GetReportsForCommitResponse:
        r"""List reports
        Returns a paginated list of Reports linked to this commit.
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.GetReportsForCommitRequest, base_url, '/repositories/{workspace}/{repo_slug}/commit/{commit}/reports', request)
        
        
        client = self._client
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetReportsForCommitResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.PaginatedReports])
                res.paginated_reports = out

        return res

    def get_repositories_workspace_repo_slug_commit_commit_(self, request: operations.GetRepositoriesWorkspaceRepoSlugCommitCommitRequest, security: operations.GetRepositoriesWorkspaceRepoSlugCommitCommitSecurity) -> operations.GetRepositoriesWorkspaceRepoSlugCommitCommitResponse:
        r"""Get a commit
        Returns the specified commit.
        
        Example:
        
        ```
        $ curl https://api.bitbucket.org/2.0/repositories/bitbucket/geordi/commit/f7591a1
        {
            \"rendered\": {
                \"message\": {
                \"raw\": \"Add a GEORDI_OUTPUT_DIR setting\",
                \"markup\": \"markdown\",
                \"html\": \"<p>Add a GEORDI_OUTPUT_DIR setting</p>\",
                \"type\": \"rendered\"
                }
            },
            \"hash\": \"f7591a13eda445d9a9167f98eb870319f4b6c2d8\",
            \"repository\": {
                \"name\": \"geordi\",
                \"type\": \"repository\",
                \"full_name\": \"bitbucket/geordi\",
                \"links\": {
                    \"self\": {
                        \"href\": \"https://api.bitbucket.org/2.0/repositories/bitbucket/geordi\"
                    },
                    \"html\": {
                        \"href\": \"https://bitbucket.org/bitbucket/geordi\"
                    },
                    \"avatar\": {
                        \"href\": \"https://bytebucket.org/ravatar/%7B85d08b4e-571d-44e9-a507-fa476535aa98%7D?ts=1730260\"
                    }
                },
                \"uuid\": \"{85d08b4e-571d-44e9-a507-fa476535aa98}\"
            },
            \"links\": {
                \"self\": {
                    \"href\": \"https://api.bitbucket.org/2.0/repositories/bitbucket/geordi/commit/f7591a13eda445d9a9167f98eb870319f4b6c2d8\"
                },
                \"comments\": {
                    \"href\": \"https://api.bitbucket.org/2.0/repositories/bitbucket/geordi/commit/f7591a13eda445d9a9167f98eb870319f4b6c2d8/comments\"
                },
                \"patch\": {
                    \"href\": \"https://api.bitbucket.org/2.0/repositories/bitbucket/geordi/patch/f7591a13eda445d9a9167f98eb870319f4b6c2d8\"
                },
                \"html\": {
                    \"href\": \"https://bitbucket.org/bitbucket/geordi/commits/f7591a13eda445d9a9167f98eb870319f4b6c2d8\"
                },
                \"diff\": {
                    \"href\": \"https://api.bitbucket.org/2.0/repositories/bitbucket/geordi/diff/f7591a13eda445d9a9167f98eb870319f4b6c2d8\"
                },
                \"approve\": {
                    \"href\": \"https://api.bitbucket.org/2.0/repositories/bitbucket/geordi/commit/f7591a13eda445d9a9167f98eb870319f4b6c2d8/approve\"
                },
                \"statuses\": {
                    \"href\": \"https://api.bitbucket.org/2.0/repositories/bitbucket/geordi/commit/f7591a13eda445d9a9167f98eb870319f4b6c2d8/statuses\"
                }
            },
            \"author\": {
                \"raw\": \"Brodie Rao <a@b.c>\",
                \"type\": \"author\",
                \"user\": {
                    \"display_name\": \"Brodie Rao\",
                    \"uuid\": \"{9484702e-c663-4afd-aefb-c93a8cd31c28}\",
                    \"links\": {
                        \"self\": {
                            \"href\": \"https://api.bitbucket.org/2.0/users/%7B9484702e-c663-4afd-aefb-c93a8cd31c28%7D\"
                        },
                        \"html\": {
                            \"href\": \"https://bitbucket.org/%7B9484702e-c663-4afd-aefb-c93a8cd31c28%7D/\"
                        },
                        \"avatar\": {
                            \"href\": \"https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:3aae1e05-702a-41e5-81c8-f36f29afb6ca/613070db-28b0-421f-8dba-ae8a87e2a5c7/128\"
                        }
                    },
                    \"type\": \"user\",
                    \"nickname\": \"brodie\",
                    \"account_id\": \"557058:3aae1e05-702a-41e5-81c8-f36f29afb6ca\"
                }
            },
            \"summary\": {
                \"raw\": \"Add a GEORDI_OUTPUT_DIR setting\",
                \"markup\": \"markdown\",
                \"html\": \"<p>Add a GEORDI_OUTPUT_DIR setting</p>\",
                \"type\": \"rendered\"
            },
            \"participants\": [],
            \"parents\": [
                {
                    \"type\": \"commit\",
                    \"hash\": \"f06941fec4ef6bcb0c2456927a0cf258fa4f899b\",
                    \"links\": {
                        \"self\": {
                            \"href\": \"https://api.bitbucket.org/2.0/repositories/bitbucket/geordi/commit/f06941fec4ef6bcb0c2456927a0cf258fa4f899b\"
                        },
                        \"html\": {
                            \"href\": \"https://bitbucket.org/bitbucket/geordi/commits/f06941fec4ef6bcb0c2456927a0cf258fa4f899b\"
                        }
                    }
                }
            ],
            \"date\": \"2012-07-16T19:37:54+00:00\",
            \"message\": \"Add a GEORDI_OUTPUT_DIR setting\",
            \"type\": \"commit\"
        }
        ```
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.GetRepositoriesWorkspaceRepoSlugCommitCommitRequest, base_url, '/repositories/{workspace}/{repo_slug}/commit/{commit}', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetRepositoriesWorkspaceRepoSlugCommitCommitResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[dict[str, Any]])
                res.commit = out
        elif http_res.status_code == 404:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[dict[str, Any]])
                res.error = out

        return res

    def get_repositories_workspace_repo_slug_commit_commit_comments(self, request: operations.GetRepositoriesWorkspaceRepoSlugCommitCommitCommentsRequest, security: operations.GetRepositoriesWorkspaceRepoSlugCommitCommitCommentsSecurity) -> operations.GetRepositoriesWorkspaceRepoSlugCommitCommitCommentsResponse:
        r"""List a commit's comments
        Returns the commit's comments.
        
        This includes both global and inline comments.
        
        The default sorting is oldest to newest and can be overridden with
        the `sort` query parameter.
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.GetRepositoriesWorkspaceRepoSlugCommitCommitCommentsRequest, base_url, '/repositories/{workspace}/{repo_slug}/commit/{commit}/comments', request)
        
        query_params = utils.get_query_params(operations.GetRepositoriesWorkspaceRepoSlugCommitCommitCommentsRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetRepositoriesWorkspaceRepoSlugCommitCommitCommentsResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.PaginatedCommitComments])
                res.paginated_commit_comments = out

        return res

    def get_repositories_workspace_repo_slug_commit_commit_comments_comment_id_(self, request: operations.GetRepositoriesWorkspaceRepoSlugCommitCommitCommentsCommentIDRequest, security: operations.GetRepositoriesWorkspaceRepoSlugCommitCommitCommentsCommentIDSecurity) -> operations.GetRepositoriesWorkspaceRepoSlugCommitCommitCommentsCommentIDResponse:
        r"""Get a commit comment
        Returns the specified commit comment.
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.GetRepositoriesWorkspaceRepoSlugCommitCommitCommentsCommentIDRequest, base_url, '/repositories/{workspace}/{repo_slug}/commit/{commit}/comments/{comment_id}', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetRepositoriesWorkspaceRepoSlugCommitCommitCommentsCommentIDResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[dict[str, Any]])
                res.commit_comment = out

        return res

    def get_repositories_workspace_repo_slug_commits(self, request: operations.GetRepositoriesWorkspaceRepoSlugCommitsRequest, security: operations.GetRepositoriesWorkspaceRepoSlugCommitsSecurity) -> operations.GetRepositoriesWorkspaceRepoSlugCommitsResponse:
        r"""List commits
        These are the repository's commits. They are paginated and returned
        in reverse chronological order, similar to the output of `git log`.
        Like these tools, the DAG can be filtered.
        
        #### GET /repositories/{workspace}/{repo_slug}/commits/
        
        Returns all commits in the repo in topological order (newest commit
        first). All branches and tags are included (similar to
        `git log --all`).
        
        #### GET /repositories/{workspace}/{repo_slug}/commits/?exclude=master
        
        Returns all commits in the repo that are not on master
        (similar to `git log --all ^master`).
        
        #### GET /repositories/{workspace}/{repo_slug}/commits/?include=foo&include=bar&exclude=fu&exclude=fubar
        
        Returns all commits that are on refs `foo` or `bar`, but not on `fu` or
        `fubar` (similar to `git log foo bar ^fu ^fubar`).
        
        An optional `path` parameter can be specified that will limit the
        results to commits that affect that path. `path` can either be a file
        or a directory. If a directory is specified, commits are returned that
        have modified any file in the directory tree rooted by `path`. It is
        important to note that if the `path` parameter is specified, the commits
        returned by this endpoint may no longer be a DAG, parent commits that
        do not modify the path will be omitted from the response.
        
        #### GET /repositories/{workspace}/{repo_slug}/commits/?path=README.md&include=foo&include=bar&exclude=master
        
        Returns all commits that are on refs `foo` or `bar`, but not on `master`
        that changed the file README.md.
        
        #### GET /repositories/{workspace}/{repo_slug}/commits/?path=src/&include=foo&include=bar&exclude=master
        
        Returns all commits that are on refs `foo` or `bar`, but not on `master`
        that changed to a file in any file in the directory src or its children.
        
        Because the response could include a very large number of commits, it
        is paginated. Follow the 'next' link in the response to navigate to the
        next page of commits. As with other paginated resources, do not
        construct your own links.
        
        When the include and exclude parameters are more than can fit in a
        query string, clients can use a `x-www-form-urlencoded` POST instead.
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.GetRepositoriesWorkspaceRepoSlugCommitsRequest, base_url, '/repositories/{workspace}/{repo_slug}/commits', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetRepositoriesWorkspaceRepoSlugCommitsResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.PaginatedChangeset])
                res.paginated_changeset = out
        elif http_res.status_code == 404:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[dict[str, Any]])
                res.error = out

        return res

    def get_repositories_workspace_repo_slug_commits_revision_(self, request: operations.GetRepositoriesWorkspaceRepoSlugCommitsRevisionRequest, security: operations.GetRepositoriesWorkspaceRepoSlugCommitsRevisionSecurity) -> operations.GetRepositoriesWorkspaceRepoSlugCommitsRevisionResponse:
        r"""List commits for revision
        These are the repository's commits. They are paginated and returned
        in reverse chronological order, similar to the output of `git log`.
        Like these tools, the DAG can be filtered.
        
        #### GET /repositories/{workspace}/{repo_slug}/commits/master
        
        Returns all commits on ref `master` (similar to `git log master`).
        
        #### GET /repositories/{workspace}/{repo_slug}/commits/dev?include=foo&exclude=master
        
        Returns all commits on ref `dev` or `foo`, except those that are reachable on
        `master` (similar to `git log dev foo ^master`).
        
        An optional `path` parameter can be specified that will limit the
        results to commits that affect that path. `path` can either be a file
        or a directory. If a directory is specified, commits are returned that
        have modified any file in the directory tree rooted by `path`. It is
        important to note that if the `path` parameter is specified, the commits
        returned by this endpoint may no longer be a DAG, parent commits that
        do not modify the path will be omitted from the response.
        
        #### GET /repositories/{workspace}/{repo_slug}/commits/dev?path=README.md&include=foo&include=bar&exclude=master
        
        Returns all commits that are on refs `dev` or `foo` or `bar`, but not on `master`
        that changed the file README.md.
        
        #### GET /repositories/{workspace}/{repo_slug}/commits/dev?path=src/&include=foo&exclude=master
        
        Returns all commits that are on refs `dev` or `foo`, but not on `master`
        that changed to a file in any file in the directory src or its children.
        
        Because the response could include a very large number of commits, it
        is paginated. Follow the 'next' link in the response to navigate to the
        next page of commits. As with other paginated resources, do not
        construct your own links.
        
        When the include and exclude parameters are more than can fit in a
        query string, clients can use a `x-www-form-urlencoded` POST instead.
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.GetRepositoriesWorkspaceRepoSlugCommitsRevisionRequest, base_url, '/repositories/{workspace}/{repo_slug}/commits/{revision}', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetRepositoriesWorkspaceRepoSlugCommitsRevisionResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.PaginatedChangeset])
                res.paginated_changeset = out
        elif http_res.status_code == 404:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[dict[str, Any]])
                res.error = out

        return res

    def get_repositories_workspace_repo_slug_diff_spec_(self, request: operations.GetRepositoriesWorkspaceRepoSlugDiffSpecRequest, security: operations.GetRepositoriesWorkspaceRepoSlugDiffSpecSecurity) -> operations.GetRepositoriesWorkspaceRepoSlugDiffSpecResponse:
        r"""Compare two commits
        Produces a raw git-style diff.
        
        #### Single commit spec
        
        If the `spec` argument to this API is a single commit, the diff is
        produced against the first parent of the specified commit.
        
        #### Two commit spec
        
        Two commits separated by `..` may be provided as the `spec`, e.g.,
        `3a8b42..9ff173`. When two commits are provided and the `topic` query
        parameter is true or absent, this API produces a 2-way three dot diff.
        This is the diff between source commit and the merge base of the source
        commit and the destination commit. When the `topic` query param is false,
        a simple git-style diff is produced.
        
        The two commits are interpreted as follows:
        
        * First commit: the commit containing the changes we wish to preview
        * Second commit: the commit representing the state to which we want to
          compare the first commit
        * **Note**: This is the opposite of the order used in `git diff`.
        
        #### Comparison to patches
        
        While similar to patches, diffs:
        
        * Don't have a commit header (username, commit message, etc)
        * Support the optional `path=foo/bar.py` query param to filter
          the diff to just that one file diff
        
        #### Response
        
        The raw diff is returned as-is, in whatever encoding the files in the
        repository use. It is not decoded into unicode. As such, the
        content-type is `text/plain`.
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.GetRepositoriesWorkspaceRepoSlugDiffSpecRequest, base_url, '/repositories/{workspace}/{repo_slug}/diff/{spec}', request)
        
        query_params = utils.get_query_params(operations.GetRepositoriesWorkspaceRepoSlugDiffSpecRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetRepositoriesWorkspaceRepoSlugDiffSpecResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            pass
        elif http_res.status_code == 555:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[dict[str, Any]])
                res.error = out

        return res

    def get_repositories_workspace_repo_slug_diffstat_spec_(self, request: operations.GetRepositoriesWorkspaceRepoSlugDiffstatSpecRequest, security: operations.GetRepositoriesWorkspaceRepoSlugDiffstatSpecSecurity) -> operations.GetRepositoriesWorkspaceRepoSlugDiffstatSpecResponse:
        r"""Compare two commit diff stats
        Produces a response in JSON format with a record for every path
        modified, including information on the type of the change and the
        number of lines added and removed.
        
        #### Single commit spec
        
        If the `spec` argument to this API is a single commit, the diff is
        produced against the first parent of the specified commit.
        
        #### Two commit spec
        
        Two commits separated by `..` may be provided as the `spec`, e.g.,
        `3a8b42..9ff173`. When two commits are provided and the `topic` query
        parameter is true or absent, this API produces a 2-way three dot diff.
        This is the diff between source commit and the merge base of the source
        commit and the destination commit. When the `topic` query param is false,
        a simple git-style diff is produced.
        
        The two commits are interpreted as follows:
        
        * First commit: the commit containing the changes we wish to preview
        * Second commit: the commit representing the state to which we want to
          compare the first commit
        * **Note**: This is the opposite of the order used in `git diff`.
        
        #### Sample output
        ```
        curl https://api.bitbucket.org/2.0/repositories/bitbucket/geordi/diffstat/d222fa2..e174964
        {
            \"pagelen\": 500,
            \"values\": [
                {
                    \"type\": \"diffstat\",
                    \"status\": \"modified\",
                    \"lines_removed\": 1,
                    \"lines_added\": 2,
                    \"old\": {
                        \"path\": \"setup.py\",
                        \"escaped_path\": \"setup.py\",
                        \"type\": \"commit_file\",
                        \"links\": {
                            \"self\": {
                                \"href\": \"https://api.bitbucket.org/2.0/repositories/bitbucket/geordi/src/e1749643d655d7c7014001a6c0f58abaf42ad850/setup.py\"
                            }
                        }
                    },
                    \"new\": {
                        \"path\": \"setup.py\",
                        \"escaped_path\": \"setup.py\",
                        \"type\": \"commit_file\",
                        \"links\": {
                            \"self\": {
                                \"href\": \"https://api.bitbucket.org/2.0/repositories/bitbucket/geordi/src/d222fa235229c55dad20b190b0b571adf737d5a6/setup.py\"
                            }
                        }
                    }
                }
            ],
            \"page\": 1,
            \"size\": 1
        }
        ```
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.GetRepositoriesWorkspaceRepoSlugDiffstatSpecRequest, base_url, '/repositories/{workspace}/{repo_slug}/diffstat/{spec}', request)
        
        query_params = utils.get_query_params(operations.GetRepositoriesWorkspaceRepoSlugDiffstatSpecRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetRepositoriesWorkspaceRepoSlugDiffstatSpecResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.PaginatedDiffstats])
                res.paginated_diffstats = out
        elif http_res.status_code == 555:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[dict[str, Any]])
                res.error = out

        return res

    def get_repositories_workspace_repo_slug_merge_base_revspec_(self, request: operations.GetRepositoriesWorkspaceRepoSlugMergeBaseRevspecRequest, security: operations.GetRepositoriesWorkspaceRepoSlugMergeBaseRevspecSecurity) -> operations.GetRepositoriesWorkspaceRepoSlugMergeBaseRevspecResponse:
        r"""Get the common ancestor between two commits
        Returns the best common ancestor between two commits, specified in a revspec
        of 2 commits (e.g. 3a8b42..9ff173).
        
        If more than one best common ancestor exists, only one will be returned. It is
        unspecified which will be returned.
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.GetRepositoriesWorkspaceRepoSlugMergeBaseRevspecRequest, base_url, '/repositories/{workspace}/{repo_slug}/merge-base/{revspec}', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetRepositoriesWorkspaceRepoSlugMergeBaseRevspecResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[dict[str, Any]])
                res.commit = out
        elif http_res.status_code in [401, 403, 404]:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[dict[str, Any]])
                res.error = out

        return res

    def get_repositories_workspace_repo_slug_patch_spec_(self, request: operations.GetRepositoriesWorkspaceRepoSlugPatchSpecRequest, security: operations.GetRepositoriesWorkspaceRepoSlugPatchSpecSecurity) -> operations.GetRepositoriesWorkspaceRepoSlugPatchSpecResponse:
        r"""Get a patch for two commits
        Produces a raw patch for a single commit (diffed against its first
        parent), or a patch-series for a revspec of 2 commits (e.g.
        `3a8b42..9ff173` where the first commit represents the source and the
        second commit the destination).
        
        In case of the latter (diffing a revspec), a patch series is returned
        for the commits on the source branch (`3a8b42` and its ancestors in
        our example).
        
        While similar to diffs, patches:
        
        * Have a commit header (username, commit message, etc)
        * Do not support the `path=foo/bar.py` query parameter
        
        The raw patch is returned as-is, in whatever encoding the files in the
        repository use. It is not decoded into unicode. As such, the
        content-type is `text/plain`.
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.GetRepositoriesWorkspaceRepoSlugPatchSpecRequest, base_url, '/repositories/{workspace}/{repo_slug}/patch/{spec}', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetRepositoriesWorkspaceRepoSlugPatchSpecResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            pass
        elif http_res.status_code == 555:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[dict[str, Any]])
                res.error = out

        return res

    def post_repositories_workspace_repo_slug_commit_commit_approve(self, request: operations.PostRepositoriesWorkspaceRepoSlugCommitCommitApproveRequest, security: operations.PostRepositoriesWorkspaceRepoSlugCommitCommitApproveSecurity) -> operations.PostRepositoriesWorkspaceRepoSlugCommitCommitApproveResponse:
        r"""Approve a commit
        Approve the specified commit as the authenticated user.
        
        This operation is only available to users that have explicit access to
        the repository. In contrast, just the fact that a repository is
        publicly accessible to users does not give them the ability to approve
        commits.
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.PostRepositoriesWorkspaceRepoSlugCommitCommitApproveRequest, base_url, '/repositories/{workspace}/{repo_slug}/commit/{commit}/approve', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.PostRepositoriesWorkspaceRepoSlugCommitCommitApproveResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[dict[str, Any]])
                res.participant = out
        elif http_res.status_code == 404:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[dict[str, Any]])
                res.error = out

        return res

    def post_repositories_workspace_repo_slug_commit_commit_comments(self, request: operations.PostRepositoriesWorkspaceRepoSlugCommitCommitCommentsRequest, security: operations.PostRepositoriesWorkspaceRepoSlugCommitCommitCommentsSecurity) -> operations.PostRepositoriesWorkspaceRepoSlugCommitCommitCommentsResponse:
        r"""Create comment for a commit
        Creates new comment on the specified commit.
        
        To post a reply to an existing comment, include the `parent.id` field:
        
        ```
        $ curl https://api.bitbucket.org/2.0/repositories/atlassian/prlinks/commit/db9ba1e031d07a02603eae0e559a7adc010257fc/comments/ \
          -X POST -u evzijst \
          -H 'Content-Type: application/json' \
          -d '{\"content\": {\"raw\": \"One more thing!\"},
               \"parent\": {\"id\": 5728901}}'
        ```
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.PostRepositoriesWorkspaceRepoSlugCommitCommitCommentsRequest, base_url, '/repositories/{workspace}/{repo_slug}/commit/{commit}/comments', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.PostRepositoriesWorkspaceRepoSlugCommitCommitCommentsResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 201:
            res.headers = http_res.headers
            
        elif http_res.status_code in [400, 404]:
            pass

        return res

    def post_repositories_workspace_repo_slug_commits(self, request: operations.PostRepositoriesWorkspaceRepoSlugCommitsRequest, security: operations.PostRepositoriesWorkspaceRepoSlugCommitsSecurity) -> operations.PostRepositoriesWorkspaceRepoSlugCommitsResponse:
        r"""List commits with include/exclude
        Identical to `GET /repositories/{workspace}/{repo_slug}/commits`,
        except that POST allows clients to place the include and exclude
        parameters in the request body to avoid URL length issues.
        
        **Note that this resource does NOT support new commit creation.**
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.PostRepositoriesWorkspaceRepoSlugCommitsRequest, base_url, '/repositories/{workspace}/{repo_slug}/commits', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.PostRepositoriesWorkspaceRepoSlugCommitsResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.PaginatedChangeset])
                res.paginated_changeset = out
        elif http_res.status_code == 404:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[dict[str, Any]])
                res.error = out

        return res

    def post_repositories_workspace_repo_slug_commits_revision_(self, request: operations.PostRepositoriesWorkspaceRepoSlugCommitsRevisionRequest, security: operations.PostRepositoriesWorkspaceRepoSlugCommitsRevisionSecurity) -> operations.PostRepositoriesWorkspaceRepoSlugCommitsRevisionResponse:
        r"""List commits for revision using include/exclude
        Identical to `GET /repositories/{workspace}/{repo_slug}/commits/{revision}`,
        except that POST allows clients to place the include and exclude
        parameters in the request body to avoid URL length issues.
        
        **Note that this resource does NOT support new commit creation.**
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.PostRepositoriesWorkspaceRepoSlugCommitsRevisionRequest, base_url, '/repositories/{workspace}/{repo_slug}/commits/{revision}', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.PostRepositoriesWorkspaceRepoSlugCommitsRevisionResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.PaginatedChangeset])
                res.paginated_changeset = out
        elif http_res.status_code == 404:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[dict[str, Any]])
                res.error = out

        return res

    def put_repositories_workspace_repo_slug_commit_commit_comments_comment_id_(self, request: operations.PutRepositoriesWorkspaceRepoSlugCommitCommitCommentsCommentIDRequest, security: operations.PutRepositoriesWorkspaceRepoSlugCommitCommitCommentsCommentIDSecurity) -> operations.PutRepositoriesWorkspaceRepoSlugCommitCommitCommentsCommentIDResponse:
        r"""Update a commit comment
        Used to update the contents of a comment. Only the content of the comment can be updated.
        
        ```
        $ curl https://api.bitbucket.org/2.0/repositories/atlassian/prlinks/commit/7f71b5/comments/5728901 \
          -X PUT -u evzijst \
          -H 'Content-Type: application/json' \
          -d '{\"content\": {\"raw\": \"One more thing!\"}'
        ```
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.PutRepositoriesWorkspaceRepoSlugCommitCommitCommentsCommentIDRequest, base_url, '/repositories/{workspace}/{repo_slug}/commit/{commit}/comments/{comment_id}', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('PUT', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.PutRepositoriesWorkspaceRepoSlugCommitCommitCommentsCommentIDResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 201:
            res.headers = http_res.headers
            
        elif http_res.status_code == 400:
            pass

        return res

    