// Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.

package operations

import (
	"encoding/json"
	"fmt"
	"net/http"
)

// PostGeomarksNewRequestBodyAllowOverlapEnum - When multiple=true select this option to allow overlapping geometries
type PostGeomarksNewRequestBodyAllowOverlapEnum string

const (
	PostGeomarksNewRequestBodyAllowOverlapEnumFalse PostGeomarksNewRequestBodyAllowOverlapEnum = "false"
	PostGeomarksNewRequestBodyAllowOverlapEnumTrue  PostGeomarksNewRequestBodyAllowOverlapEnum = "true"
)

func (e *PostGeomarksNewRequestBodyAllowOverlapEnum) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return err
	}
	switch s {
	case "false":
		fallthrough
	case "true":
		*e = PostGeomarksNewRequestBodyAllowOverlapEnum(s)
		return nil
	default:
		return fmt.Errorf("invalid value for PostGeomarksNewRequestBodyAllowOverlapEnum: %s", s)
	}
}

// PostGeomarksNewRequestBodyBufferCapEnum - If bufferMetres is specified, The style of buffer to use at the ends of a buffered line.
type PostGeomarksNewRequestBodyBufferCapEnum string

const (
	PostGeomarksNewRequestBodyBufferCapEnumRound  PostGeomarksNewRequestBodyBufferCapEnum = "ROUND"
	PostGeomarksNewRequestBodyBufferCapEnumSquare PostGeomarksNewRequestBodyBufferCapEnum = "SQUARE"
	PostGeomarksNewRequestBodyBufferCapEnumFlat   PostGeomarksNewRequestBodyBufferCapEnum = "FLAT"
)

func (e *PostGeomarksNewRequestBodyBufferCapEnum) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return err
	}
	switch s {
	case "ROUND":
		fallthrough
	case "SQUARE":
		fallthrough
	case "FLAT":
		*e = PostGeomarksNewRequestBodyBufferCapEnum(s)
		return nil
	default:
		return fmt.Errorf("invalid value for PostGeomarksNewRequestBodyBufferCapEnum: %s", s)
	}
}

// PostGeomarksNewRequestBodyBufferJoinEnum - If bufferMetres is specified, The style of buffer to use for joins between the line segments for lines and polygons.
type PostGeomarksNewRequestBodyBufferJoinEnum string

const (
	PostGeomarksNewRequestBodyBufferJoinEnumRound PostGeomarksNewRequestBodyBufferJoinEnum = "ROUND"
	PostGeomarksNewRequestBodyBufferJoinEnumMitre PostGeomarksNewRequestBodyBufferJoinEnum = "MITRE"
	PostGeomarksNewRequestBodyBufferJoinEnumBevel PostGeomarksNewRequestBodyBufferJoinEnum = "BEVEL"
)

func (e *PostGeomarksNewRequestBodyBufferJoinEnum) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return err
	}
	switch s {
	case "ROUND":
		fallthrough
	case "MITRE":
		fallthrough
	case "BEVEL":
		*e = PostGeomarksNewRequestBodyBufferJoinEnum(s)
		return nil
	default:
		return fmt.Errorf("invalid value for PostGeomarksNewRequestBodyBufferJoinEnum: %s", s)
	}
}

// PostGeomarksNewRequestBodyFormatEnum - The file format name extension of the input geometry.
type PostGeomarksNewRequestBodyFormatEnum string

const (
	PostGeomarksNewRequestBodyFormatEnumJSON    PostGeomarksNewRequestBodyFormatEnum = "json"
	PostGeomarksNewRequestBodyFormatEnumXML     PostGeomarksNewRequestBodyFormatEnum = "xml"
	PostGeomarksNewRequestBodyFormatEnumKml     PostGeomarksNewRequestBodyFormatEnum = "kml"
	PostGeomarksNewRequestBodyFormatEnumKmz     PostGeomarksNewRequestBodyFormatEnum = "kmz"
	PostGeomarksNewRequestBodyFormatEnumShp     PostGeomarksNewRequestBodyFormatEnum = "shp"
	PostGeomarksNewRequestBodyFormatEnumShpz    PostGeomarksNewRequestBodyFormatEnum = "shpz"
	PostGeomarksNewRequestBodyFormatEnumGeojson PostGeomarksNewRequestBodyFormatEnum = "geojson"
	PostGeomarksNewRequestBodyFormatEnumGml     PostGeomarksNewRequestBodyFormatEnum = "gml"
	PostGeomarksNewRequestBodyFormatEnumGpkg    PostGeomarksNewRequestBodyFormatEnum = "gpkg"
	PostGeomarksNewRequestBodyFormatEnumWkt     PostGeomarksNewRequestBodyFormatEnum = "wkt"
)

func (e *PostGeomarksNewRequestBodyFormatEnum) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return err
	}
	switch s {
	case "json":
		fallthrough
	case "xml":
		fallthrough
	case "kml":
		fallthrough
	case "kmz":
		fallthrough
	case "shp":
		fallthrough
	case "shpz":
		fallthrough
	case "geojson":
		fallthrough
	case "gml":
		fallthrough
	case "gpkg":
		fallthrough
	case "wkt":
		*e = PostGeomarksNewRequestBodyFormatEnum(s)
		return nil
	default:
		return fmt.Errorf("invalid value for PostGeomarksNewRequestBodyFormatEnum: %s", s)
	}
}

// PostGeomarksNewRequestBodyMultipleEnum - Boolean flag indicating if multiple geometries are to be used for the geomark (true) or only a single geometry from the first geometry (false).
type PostGeomarksNewRequestBodyMultipleEnum string

const (
	PostGeomarksNewRequestBodyMultipleEnumFalse PostGeomarksNewRequestBodyMultipleEnum = "false"
	PostGeomarksNewRequestBodyMultipleEnumTrue  PostGeomarksNewRequestBodyMultipleEnum = "true"
)

func (e *PostGeomarksNewRequestBodyMultipleEnum) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return err
	}
	switch s {
	case "false":
		fallthrough
	case "true":
		*e = PostGeomarksNewRequestBodyMultipleEnum(s)
		return nil
	default:
		return fmt.Errorf("invalid value for PostGeomarksNewRequestBodyMultipleEnum: %s", s)
	}
}

// PostGeomarksNewRequestBodyResultFormatEnum - The file format the geomark info resource should be returned using.
type PostGeomarksNewRequestBodyResultFormatEnum string

const (
	PostGeomarksNewRequestBodyResultFormatEnumJSON    PostGeomarksNewRequestBodyResultFormatEnum = "json"
	PostGeomarksNewRequestBodyResultFormatEnumXML     PostGeomarksNewRequestBodyResultFormatEnum = "xml"
	PostGeomarksNewRequestBodyResultFormatEnumKml     PostGeomarksNewRequestBodyResultFormatEnum = "kml"
	PostGeomarksNewRequestBodyResultFormatEnumKmz     PostGeomarksNewRequestBodyResultFormatEnum = "kmz"
	PostGeomarksNewRequestBodyResultFormatEnumShp     PostGeomarksNewRequestBodyResultFormatEnum = "shp"
	PostGeomarksNewRequestBodyResultFormatEnumShpz    PostGeomarksNewRequestBodyResultFormatEnum = "shpz"
	PostGeomarksNewRequestBodyResultFormatEnumGeojson PostGeomarksNewRequestBodyResultFormatEnum = "geojson"
	PostGeomarksNewRequestBodyResultFormatEnumGml     PostGeomarksNewRequestBodyResultFormatEnum = "gml"
	PostGeomarksNewRequestBodyResultFormatEnumGpkg    PostGeomarksNewRequestBodyResultFormatEnum = "gpkg"
	PostGeomarksNewRequestBodyResultFormatEnumWkt     PostGeomarksNewRequestBodyResultFormatEnum = "wkt"
)

func (e *PostGeomarksNewRequestBodyResultFormatEnum) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return err
	}
	switch s {
	case "json":
		fallthrough
	case "xml":
		fallthrough
	case "kml":
		fallthrough
	case "kmz":
		fallthrough
	case "shp":
		fallthrough
	case "shpz":
		fallthrough
	case "geojson":
		fallthrough
	case "gml":
		fallthrough
	case "gpkg":
		fallthrough
	case "wkt":
		*e = PostGeomarksNewRequestBodyResultFormatEnum(s)
		return nil
	default:
		return fmt.Errorf("invalid value for PostGeomarksNewRequestBodyResultFormatEnum: %s", s)
	}
}

// PostGeomarksNewRequestBodySridEnum - The srid of the coordinate system the input geometries are in. If the file includes a coordinate system definition that will be used.
type PostGeomarksNewRequestBodySridEnum string

const (
	PostGeomarksNewRequestBodySridEnumFourThousandThreeHundredAndTwentySix   PostGeomarksNewRequestBodySridEnum = "4326"
	PostGeomarksNewRequestBodySridEnumThreeThousandAndFive                   PostGeomarksNewRequestBodySridEnum = "3005"
	PostGeomarksNewRequestBodySridEnumThreeThousandEightHundredAndFiftySeven PostGeomarksNewRequestBodySridEnum = "3857"
	PostGeomarksNewRequestBodySridEnumTwentySixThousandNineHundredAndSeven   PostGeomarksNewRequestBodySridEnum = "26907"
	PostGeomarksNewRequestBodySridEnumTwentySixThousandNineHundredAndEight   PostGeomarksNewRequestBodySridEnum = "26908"
	PostGeomarksNewRequestBodySridEnumTwentySixThousandNineHundredAndNine    PostGeomarksNewRequestBodySridEnum = "26909"
	PostGeomarksNewRequestBodySridEnumTwentySixThousandNineHundredAndTen     PostGeomarksNewRequestBodySridEnum = "26910"
	PostGeomarksNewRequestBodySridEnumTwentySixThousandNineHundredAndEleven  PostGeomarksNewRequestBodySridEnum = "26911"
)

func (e *PostGeomarksNewRequestBodySridEnum) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return err
	}
	switch s {
	case "4326":
		fallthrough
	case "3005":
		fallthrough
	case "3857":
		fallthrough
	case "26907":
		fallthrough
	case "26908":
		fallthrough
	case "26909":
		fallthrough
	case "26910":
		fallthrough
	case "26911":
		*e = PostGeomarksNewRequestBodySridEnum(s)
		return nil
	default:
		return fmt.Errorf("invalid value for PostGeomarksNewRequestBodySridEnum: %s", s)
	}
}

type PostGeomarksNewRequestBody struct {
	// When multiple=true select this option to allow overlapping geometries
	AllowOverlap *PostGeomarksNewRequestBodyAllowOverlapEnum `form:"name=allowOverlap"`
	// The binary or character content representing the geometry or geometries
	Body *string `form:"name=body"`
	// If bufferMetres is specified, The style of buffer to use at the ends of a buffered line.
	BufferCap *PostGeomarksNewRequestBodyBufferCapEnum `form:"name=bufferCap"`
	// If bufferMetres is specified, The style of buffer to use for joins between the line segments for lines and polygons.
	BufferJoin *PostGeomarksNewRequestBodyBufferJoinEnum `form:"name=bufferJoin"`
	// The amount to buffer the geometry in metres, must only contain numerical digits (e.g 10). Leave blank and no buffer will be added to input geometries. If blank then any Point, LineString, MultiPoint and MultiLineString geometries will be ignored.
	BufferMetres *int64 `form:"name=bufferMetres"`
	// If bufferMetres is specified, the maximum ratio of distance from the original geometry to a mitre buffer point and the buffer amount. If the ratio is greater than this a bevel will be used instead. This prevents infinite distances when the angle between the two lines at a join is small. Must be > 0.
	BufferMitreLimit *int64 `form:"name=bufferMitreLimit"`
	// If bufferMetres is specified, the number of line segments used in each quadrant to approximate the curve for round end-cap and join styles. Must be > 0.
	BufferSegments *int64 `form:"name=bufferSegments"`
	// The callback function a JSON result format would be wrapped in to support Ajax requests.
	Callback *string `form:"name=callback"`
	// The url to redirect if the geomark could not be created. The URL will include a <fieldName>_Error parameter with the error message for the field that caused the error.
	FailureRedirectURL *string `form:"name=failureRedirectUrl"`
	// The file format name extension of the input geometry.
	Format *PostGeomarksNewRequestBodyFormatEnum `form:"name=format"`
	// Boolean flag indicating if multiple geometries are to be used for the geomark (true) or only a single geometry from the first geometry (false).
	Multiple *PostGeomarksNewRequestBodyMultipleEnum `form:"name=multiple"`
	// The optional external URL to redirect the user to when the geomark is created rather than showing the geomark info page. The geomarkId and geomarkUrl query string parameters will be added to the redirectUrl so that the target application gets a reference to the geomark.
	RedirectURL *string `form:"name=redirectUrl"`
	// The file format the geomark info resource should be returned using.
	ResultFormat *PostGeomarksNewRequestBodyResultFormatEnum `form:"name=resultFormat"`
	// The srid of the coordinate system the input geometries are in. If the file includes a coordinate system definition that will be used.
	Srid *PostGeomarksNewRequestBodySridEnum `form:"name=srid"`
}

type PostGeomarksNewResponse struct {
	ContentType string
	StatusCode  int
	RawResponse *http.Response
}
