"""Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT."""

import requests as requests_http
from . import utils
from sdk.models import operations, shared
from typing import Any, Optional

SERVERS = [
    "http://inspector2.{region}.amazonaws.com",
    r"""The Inspector2 multi-region endpoint"""
    "https://inspector2.{region}.amazonaws.com",
    r"""The Inspector2 multi-region endpoint"""
    "http://inspector2.{region}.amazonaws.com.cn",
    r"""The Inspector2 endpoint for China (Beijing) and China (Ningxia)"""
    "https://inspector2.{region}.amazonaws.com.cn",
    r"""The Inspector2 endpoint for China (Beijing) and China (Ningxia)"""
]
"""Contains the list of servers available to the SDK"""

class SDK:
    r"""Amazon Inspector is a vulnerability discovery service that automates continuous scanning for security vulnerabilities within your Amazon EC2 and Amazon ECR environments.
    https://docs.aws.amazon.com/inspector2/ - Amazon Web Services documentation
    """

    _client: requests_http.Session
    _security_client: requests_http.Session
    _server_url: str = SERVERS[0]
    _language: str = "python"
    _sdk_version: str = "0.0.1"
    _gen_version: str = "internal"

    def __init__(self,
                 security: shared.Security = None,
                 server_url: str = None,
                 url_params: dict[str, str] = None,
                 client: requests_http.Session = None
                 ) -> None:
        """Instantiates the SDK configuring it with the provided parameters.
        
        :param security: The security details required for authentication
        :type security: shared.Security
        :param server_url: The server URL to use for all operations
        :type server_url: str
        :param url_params: Parameters to optionally template the server URL with
        :type url_params: dict[str, str]
        :param client: The requests.Session HTTP client to use for all operations
        :type client: requests_http.Session        
        """
        self._client = requests_http.Session()
        
        
        if server_url is not None:
            if url_params is not None:
                self._server_url = utils.template_url(server_url, url_params)
            else:
                self._server_url = server_url

        if client is not None:
            self._client = client
        
        self._security_client = utils.configure_security_client(self._client, security)
        

        
    
    
    def associate_member(self, request: operations.AssociateMemberRequest) -> operations.AssociateMemberResponse:
        r"""Associates an Amazon Web Services account with an Amazon Inspector delegated administrator."""
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/members/associate'
        
        headers = utils.get_headers(request)
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = self._security_client
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.AssociateMemberResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.AssociateMemberResponse])
                res.associate_member_response = out
        elif http_res.status_code == 480:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.validation_exception = out
        elif http_res.status_code == 481:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.access_denied_exception = out
        elif http_res.status_code == 482:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.throttling_exception = out
        elif http_res.status_code == 483:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.internal_server_exception = out

        return res

    def batch_get_account_status(self, request: operations.BatchGetAccountStatusRequest) -> operations.BatchGetAccountStatusResponse:
        r"""Retrieves the Amazon Inspector status of multiple Amazon Web Services accounts within your environment."""
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/status/batch/get'
        
        headers = utils.get_headers(request)
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = self._security_client
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.BatchGetAccountStatusResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.BatchGetAccountStatusResponse])
                res.batch_get_account_status_response = out
        elif http_res.status_code == 480:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.validation_exception = out
        elif http_res.status_code == 481:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.access_denied_exception = out
        elif http_res.status_code == 482:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.resource_not_found_exception = out
        elif http_res.status_code == 483:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.throttling_exception = out
        elif http_res.status_code == 484:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.internal_server_exception = out

        return res

    def batch_get_free_trial_info(self, request: operations.BatchGetFreeTrialInfoRequest) -> operations.BatchGetFreeTrialInfoResponse:
        r"""Gets free trial status for multiple Amazon Web Services accounts."""
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/freetrialinfo/batchget'
        
        headers = utils.get_headers(request)
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = self._security_client
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.BatchGetFreeTrialInfoResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.BatchGetFreeTrialInfoResponse])
                res.batch_get_free_trial_info_response = out
        elif http_res.status_code == 480:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.validation_exception = out
        elif http_res.status_code == 481:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.access_denied_exception = out
        elif http_res.status_code == 482:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.throttling_exception = out
        elif http_res.status_code == 483:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.internal_server_exception = out

        return res

    def cancel_findings_report(self, request: operations.CancelFindingsReportRequest) -> operations.CancelFindingsReportResponse:
        r"""Cancels the given findings report."""
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/reporting/cancel'
        
        headers = utils.get_headers(request)
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = self._security_client
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.CancelFindingsReportResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.CancelFindingsReportResponse])
                res.cancel_findings_report_response = out
        elif http_res.status_code == 480:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.validation_exception = out
        elif http_res.status_code == 481:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.access_denied_exception = out
        elif http_res.status_code == 482:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.resource_not_found_exception = out
        elif http_res.status_code == 483:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.throttling_exception = out
        elif http_res.status_code == 484:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.internal_server_exception = out

        return res

    def create_filter(self, request: operations.CreateFilterRequest) -> operations.CreateFilterResponse:
        r"""Creates a filter resource using specified filter criteria."""
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/filters/create'
        
        headers = utils.get_headers(request)
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = self._security_client
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.CreateFilterResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.CreateFilterResponse])
                res.create_filter_response = out
        elif http_res.status_code == 480:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.service_quota_exceeded_exception = out
        elif http_res.status_code == 481:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.bad_request_exception = out
        elif http_res.status_code == 482:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.validation_exception = out
        elif http_res.status_code == 483:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.access_denied_exception = out
        elif http_res.status_code == 484:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.throttling_exception = out
        elif http_res.status_code == 485:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.internal_server_exception = out

        return res

    def create_findings_report(self, request: operations.CreateFindingsReportRequest) -> operations.CreateFindingsReportResponse:
        r"""Creates a finding report."""
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/reporting/create'
        
        headers = utils.get_headers(request)
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = self._security_client
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.CreateFindingsReportResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.CreateFindingsReportResponse])
                res.create_findings_report_response = out
        elif http_res.status_code == 480:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.validation_exception = out
        elif http_res.status_code == 481:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.access_denied_exception = out
        elif http_res.status_code == 482:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.resource_not_found_exception = out
        elif http_res.status_code == 483:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.throttling_exception = out
        elif http_res.status_code == 484:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.internal_server_exception = out

        return res

    def delete_filter(self, request: operations.DeleteFilterRequest) -> operations.DeleteFilterResponse:
        r"""Deletes a filter resource."""
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/filters/delete'
        
        headers = utils.get_headers(request)
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = self._security_client
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DeleteFilterResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.DeleteFilterResponse])
                res.delete_filter_response = out
        elif http_res.status_code == 480:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.validation_exception = out
        elif http_res.status_code == 481:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.access_denied_exception = out
        elif http_res.status_code == 482:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.resource_not_found_exception = out
        elif http_res.status_code == 483:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.throttling_exception = out
        elif http_res.status_code == 484:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.internal_server_exception = out

        return res

    def describe_organization_configuration(self, request: operations.DescribeOrganizationConfigurationRequest) -> operations.DescribeOrganizationConfigurationResponse:
        r"""Describe Amazon Inspector configuration settings for an Amazon Web Services organization."""
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/organizationconfiguration/describe'
        
        headers = utils.get_headers(request)
        
        client = self._security_client
        
        http_res = client.request('POST', url, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DescribeOrganizationConfigurationResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.DescribeOrganizationConfigurationResponse])
                res.describe_organization_configuration_response = out
        elif http_res.status_code == 480:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.validation_exception = out
        elif http_res.status_code == 481:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.access_denied_exception = out
        elif http_res.status_code == 482:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.throttling_exception = out
        elif http_res.status_code == 483:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.internal_server_exception = out

        return res

    def disable(self, request: operations.DisableRequest) -> operations.DisableResponse:
        r"""Disables Amazon Inspector scans for one or more Amazon Web Services accounts. Disabling all scan types in an account disables the Amazon Inspector service."""
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/disable'
        
        headers = utils.get_headers(request)
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = self._security_client
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DisableResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.DisableResponse])
                res.disable_response = out
        elif http_res.status_code == 480:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.validation_exception = out
        elif http_res.status_code == 481:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.access_denied_exception = out
        elif http_res.status_code == 482:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.resource_not_found_exception = out
        elif http_res.status_code == 483:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.throttling_exception = out
        elif http_res.status_code == 484:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.internal_server_exception = out

        return res

    def disable_delegated_admin_account(self, request: operations.DisableDelegatedAdminAccountRequest) -> operations.DisableDelegatedAdminAccountResponse:
        r"""Disables the Amazon Inspector delegated administrator for your organization."""
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/delegatedadminaccounts/disable'
        
        headers = utils.get_headers(request)
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = self._security_client
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DisableDelegatedAdminAccountResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.DisableDelegatedAdminAccountResponse])
                res.disable_delegated_admin_account_response = out
        elif http_res.status_code == 480:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.conflict_exception = out
        elif http_res.status_code == 481:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.validation_exception = out
        elif http_res.status_code == 482:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.access_denied_exception = out
        elif http_res.status_code == 483:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.resource_not_found_exception = out
        elif http_res.status_code == 484:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.throttling_exception = out
        elif http_res.status_code == 485:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.internal_server_exception = out

        return res

    def disassociate_member(self, request: operations.DisassociateMemberRequest) -> operations.DisassociateMemberResponse:
        r"""Disassociates a member account from an Amazon Inspector delegated administrator."""
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/members/disassociate'
        
        headers = utils.get_headers(request)
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = self._security_client
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DisassociateMemberResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.DisassociateMemberResponse])
                res.disassociate_member_response = out
        elif http_res.status_code == 480:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.validation_exception = out
        elif http_res.status_code == 481:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.access_denied_exception = out
        elif http_res.status_code == 482:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.throttling_exception = out
        elif http_res.status_code == 483:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.internal_server_exception = out

        return res

    def enable(self, request: operations.EnableRequest) -> operations.EnableResponse:
        r"""Enables Amazon Inspector scans for one or more Amazon Web Services accounts."""
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/enable'
        
        headers = utils.get_headers(request)
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = self._security_client
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.EnableResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.EnableResponse])
                res.enable_response = out
        elif http_res.status_code == 480:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.validation_exception = out
        elif http_res.status_code == 481:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.access_denied_exception = out
        elif http_res.status_code == 482:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.resource_not_found_exception = out
        elif http_res.status_code == 483:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.throttling_exception = out
        elif http_res.status_code == 484:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.internal_server_exception = out

        return res

    def enable_delegated_admin_account(self, request: operations.EnableDelegatedAdminAccountRequest) -> operations.EnableDelegatedAdminAccountResponse:
        r"""Enables the Amazon Inspector delegated administrator for your Organizations organization."""
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/delegatedadminaccounts/enable'
        
        headers = utils.get_headers(request)
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = self._security_client
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.EnableDelegatedAdminAccountResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.EnableDelegatedAdminAccountResponse])
                res.enable_delegated_admin_account_response = out
        elif http_res.status_code == 480:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.conflict_exception = out
        elif http_res.status_code == 481:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.validation_exception = out
        elif http_res.status_code == 482:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.access_denied_exception = out
        elif http_res.status_code == 483:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.resource_not_found_exception = out
        elif http_res.status_code == 484:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.throttling_exception = out
        elif http_res.status_code == 485:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.internal_server_exception = out

        return res

    def get_configuration(self, request: operations.GetConfigurationRequest) -> operations.GetConfigurationResponse:
        r"""Retrieves setting configurations for Inspector scans."""
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/configuration/get'
        
        headers = utils.get_headers(request)
        
        client = self._security_client
        
        http_res = client.request('POST', url, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetConfigurationResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.GetConfigurationResponse])
                res.get_configuration_response = out
        elif http_res.status_code == 480:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.resource_not_found_exception = out
        elif http_res.status_code == 481:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.throttling_exception = out
        elif http_res.status_code == 482:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.internal_server_exception = out

        return res

    def get_delegated_admin_account(self, request: operations.GetDelegatedAdminAccountRequest) -> operations.GetDelegatedAdminAccountResponse:
        r"""Retrieves information about the Amazon Inspector delegated administrator for your organization."""
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/delegatedadminaccounts/get'
        
        headers = utils.get_headers(request)
        
        client = self._security_client
        
        http_res = client.request('POST', url, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetDelegatedAdminAccountResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.GetDelegatedAdminAccountResponse])
                res.get_delegated_admin_account_response = out
        elif http_res.status_code == 480:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.access_denied_exception = out
        elif http_res.status_code == 481:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.validation_exception = out
        elif http_res.status_code == 482:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.resource_not_found_exception = out
        elif http_res.status_code == 483:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.throttling_exception = out
        elif http_res.status_code == 484:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.internal_server_exception = out

        return res

    def get_findings_report_status(self, request: operations.GetFindingsReportStatusRequest) -> operations.GetFindingsReportStatusResponse:
        r"""Gets the status of a findings report."""
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/reporting/status/get'
        
        headers = utils.get_headers(request)
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = self._security_client
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetFindingsReportStatusResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.GetFindingsReportStatusResponse])
                res.get_findings_report_status_response = out
        elif http_res.status_code == 480:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.validation_exception = out
        elif http_res.status_code == 481:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.access_denied_exception = out
        elif http_res.status_code == 482:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.resource_not_found_exception = out
        elif http_res.status_code == 483:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.throttling_exception = out
        elif http_res.status_code == 484:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.internal_server_exception = out

        return res

    def get_member(self, request: operations.GetMemberRequest) -> operations.GetMemberResponse:
        r"""Gets member information for your organization."""
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/members/get'
        
        headers = utils.get_headers(request)
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = self._security_client
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetMemberResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.GetMemberResponse])
                res.get_member_response = out
        elif http_res.status_code == 480:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.validation_exception = out
        elif http_res.status_code == 481:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.access_denied_exception = out
        elif http_res.status_code == 482:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.resource_not_found_exception = out
        elif http_res.status_code == 483:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.throttling_exception = out
        elif http_res.status_code == 484:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.internal_server_exception = out

        return res

    def list_account_permissions(self, request: operations.ListAccountPermissionsRequest) -> operations.ListAccountPermissionsResponse:
        r"""Lists the permissions an account has to configure Amazon Inspector."""
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/accountpermissions/list'
        
        headers = utils.get_headers(request)
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        query_params = utils.get_query_params(operations.ListAccountPermissionsRequest, request)
        
        client = self._security_client
        
        http_res = client.request('POST', url, params=query_params, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ListAccountPermissionsResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ListAccountPermissionsResponse])
                res.list_account_permissions_response = out
        elif http_res.status_code == 480:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.validation_exception = out
        elif http_res.status_code == 481:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.access_denied_exception = out
        elif http_res.status_code == 482:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.throttling_exception = out
        elif http_res.status_code == 483:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.internal_server_exception = out

        return res

    def list_coverage(self, request: operations.ListCoverageRequest) -> operations.ListCoverageResponse:
        r"""Lists coverage details for you environment."""
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/coverage/list'
        
        headers = utils.get_headers(request)
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        query_params = utils.get_query_params(operations.ListCoverageRequest, request)
        
        client = self._security_client
        
        http_res = client.request('POST', url, params=query_params, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ListCoverageResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ListCoverageResponse])
                res.list_coverage_response = out
        elif http_res.status_code == 480:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.validation_exception = out
        elif http_res.status_code == 481:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.throttling_exception = out
        elif http_res.status_code == 482:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.internal_server_exception = out

        return res

    def list_coverage_statistics(self, request: operations.ListCoverageStatisticsRequest) -> operations.ListCoverageStatisticsResponse:
        r"""Lists Amazon Inspector coverage statistics for your environment."""
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/coverage/statistics/list'
        
        headers = utils.get_headers(request)
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        query_params = utils.get_query_params(operations.ListCoverageStatisticsRequest, request)
        
        client = self._security_client
        
        http_res = client.request('POST', url, params=query_params, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ListCoverageStatisticsResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ListCoverageStatisticsResponse])
                res.list_coverage_statistics_response = out
        elif http_res.status_code == 480:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.validation_exception = out
        elif http_res.status_code == 481:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.throttling_exception = out
        elif http_res.status_code == 482:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.internal_server_exception = out

        return res

    def list_delegated_admin_accounts(self, request: operations.ListDelegatedAdminAccountsRequest) -> operations.ListDelegatedAdminAccountsResponse:
        r"""Lists information about the Amazon Inspector delegated administrator of your organization."""
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/delegatedadminaccounts/list'
        
        headers = utils.get_headers(request)
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        query_params = utils.get_query_params(operations.ListDelegatedAdminAccountsRequest, request)
        
        client = self._security_client
        
        http_res = client.request('POST', url, params=query_params, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ListDelegatedAdminAccountsResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ListDelegatedAdminAccountsResponse])
                res.list_delegated_admin_accounts_response = out
        elif http_res.status_code == 480:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.validation_exception = out
        elif http_res.status_code == 481:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.access_denied_exception = out
        elif http_res.status_code == 482:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.throttling_exception = out
        elif http_res.status_code == 483:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.internal_server_exception = out

        return res

    def list_filters(self, request: operations.ListFiltersRequest) -> operations.ListFiltersResponse:
        r"""Lists the filters associated with your account."""
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/filters/list'
        
        headers = utils.get_headers(request)
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        query_params = utils.get_query_params(operations.ListFiltersRequest, request)
        
        client = self._security_client
        
        http_res = client.request('POST', url, params=query_params, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ListFiltersResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ListFiltersResponse])
                res.list_filters_response = out
        elif http_res.status_code == 480:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.validation_exception = out
        elif http_res.status_code == 481:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.access_denied_exception = out
        elif http_res.status_code == 482:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.throttling_exception = out
        elif http_res.status_code == 483:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.internal_server_exception = out

        return res

    def list_finding_aggregations(self, request: operations.ListFindingAggregationsRequest) -> operations.ListFindingAggregationsResponse:
        r"""Lists aggregated finding data for your environment based on specific criteria."""
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/findings/aggregation/list'
        
        headers = utils.get_headers(request)
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        query_params = utils.get_query_params(operations.ListFindingAggregationsRequest, request)
        
        client = self._security_client
        
        http_res = client.request('POST', url, params=query_params, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ListFindingAggregationsResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ListFindingAggregationsResponse])
                res.list_finding_aggregations_response = out
        elif http_res.status_code == 480:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.validation_exception = out
        elif http_res.status_code == 481:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.throttling_exception = out
        elif http_res.status_code == 482:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.internal_server_exception = out

        return res

    def list_findings(self, request: operations.ListFindingsRequest) -> operations.ListFindingsResponse:
        r"""Lists findings for your environment."""
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/findings/list'
        
        headers = utils.get_headers(request)
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        query_params = utils.get_query_params(operations.ListFindingsRequest, request)
        
        client = self._security_client
        
        http_res = client.request('POST', url, params=query_params, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ListFindingsResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ListFindingsResponse])
                res.list_findings_response = out
        elif http_res.status_code == 480:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.validation_exception = out
        elif http_res.status_code == 481:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.throttling_exception = out
        elif http_res.status_code == 482:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.internal_server_exception = out

        return res

    def list_members(self, request: operations.ListMembersRequest) -> operations.ListMembersResponse:
        r"""List members associated with the Amazon Inspector delegated administrator for your organization."""
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/members/list'
        
        headers = utils.get_headers(request)
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        query_params = utils.get_query_params(operations.ListMembersRequest, request)
        
        client = self._security_client
        
        http_res = client.request('POST', url, params=query_params, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ListMembersResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ListMembersResponse])
                res.list_members_response = out
        elif http_res.status_code == 480:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.validation_exception = out
        elif http_res.status_code == 481:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.access_denied_exception = out
        elif http_res.status_code == 482:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.throttling_exception = out
        elif http_res.status_code == 483:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.internal_server_exception = out

        return res

    def list_tags_for_resource(self, request: operations.ListTagsForResourceRequest) -> operations.ListTagsForResourceResponse:
        r"""Lists all tags attached to a given resource."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.ListTagsForResourceRequest, base_url, '/tags/{resourceArn}', request)
        
        headers = utils.get_headers(request)
        
        client = self._security_client
        
        http_res = client.request('GET', url, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ListTagsForResourceResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ListTagsForResourceResponse])
                res.list_tags_for_resource_response = out
        elif http_res.status_code == 480:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.validation_exception = out
        elif http_res.status_code == 481:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.resource_not_found_exception = out
        elif http_res.status_code == 482:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.throttling_exception = out
        elif http_res.status_code == 483:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.internal_server_exception = out

        return res

    def list_usage_totals(self, request: operations.ListUsageTotalsRequest) -> operations.ListUsageTotalsResponse:
        r"""Lists the Amazon Inspector usage totals over the last 30 days."""
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/usage/list'
        
        headers = utils.get_headers(request)
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        query_params = utils.get_query_params(operations.ListUsageTotalsRequest, request)
        
        client = self._security_client
        
        http_res = client.request('POST', url, params=query_params, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ListUsageTotalsResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ListUsageTotalsResponse])
                res.list_usage_totals_response = out
        elif http_res.status_code == 480:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.validation_exception = out
        elif http_res.status_code == 481:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.access_denied_exception = out
        elif http_res.status_code == 482:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.throttling_exception = out
        elif http_res.status_code == 483:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.internal_server_exception = out

        return res

    def tag_resource(self, request: operations.TagResourceRequest) -> operations.TagResourceResponse:
        r"""Adds tags to a resource."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.TagResourceRequest, base_url, '/tags/{resourceArn}', request)
        
        headers = utils.get_headers(request)
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = self._security_client
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.TagResourceResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[dict[str, Any]])
                res.tag_resource_response = out
        elif http_res.status_code == 480:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.bad_request_exception = out
        elif http_res.status_code == 481:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.validation_exception = out
        elif http_res.status_code == 482:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.resource_not_found_exception = out
        elif http_res.status_code == 483:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.throttling_exception = out
        elif http_res.status_code == 484:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.internal_server_exception = out

        return res

    def untag_resource(self, request: operations.UntagResourceRequest) -> operations.UntagResourceResponse:
        r"""Removes tags from a resource."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.UntagResourceRequest, base_url, '/tags/{resourceArn}#tagKeys', request)
        
        headers = utils.get_headers(request)
        query_params = utils.get_query_params(operations.UntagResourceRequest, request)
        
        client = self._security_client
        
        http_res = client.request('DELETE', url, params=query_params, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.UntagResourceResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[dict[str, Any]])
                res.untag_resource_response = out
        elif http_res.status_code == 480:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.validation_exception = out
        elif http_res.status_code == 481:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.resource_not_found_exception = out
        elif http_res.status_code == 482:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.throttling_exception = out
        elif http_res.status_code == 483:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.internal_server_exception = out

        return res

    def update_configuration(self, request: operations.UpdateConfigurationRequest) -> operations.UpdateConfigurationResponse:
        r"""Updates setting configurations for your Amazon Inspector account. When you use this API as an Amazon Inspector delegated administrator this updates the setting for all accounts you manage. Member accounts in an organization cannot update this setting."""
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/configuration/update'
        
        headers = utils.get_headers(request)
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = self._security_client
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.UpdateConfigurationResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[dict[str, Any]])
                res.update_configuration_response = out
        elif http_res.status_code == 480:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.validation_exception = out
        elif http_res.status_code == 481:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.access_denied_exception = out
        elif http_res.status_code == 482:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.throttling_exception = out
        elif http_res.status_code == 483:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.internal_server_exception = out

        return res

    def update_filter(self, request: operations.UpdateFilterRequest) -> operations.UpdateFilterResponse:
        r"""Specifies the action that is to be applied to the findings that match the filter."""
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/filters/update'
        
        headers = utils.get_headers(request)
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = self._security_client
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.UpdateFilterResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.UpdateFilterResponse])
                res.update_filter_response = out
        elif http_res.status_code == 480:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.validation_exception = out
        elif http_res.status_code == 481:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.access_denied_exception = out
        elif http_res.status_code == 482:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.resource_not_found_exception = out
        elif http_res.status_code == 483:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.throttling_exception = out
        elif http_res.status_code == 484:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.internal_server_exception = out

        return res

    def update_organization_configuration(self, request: operations.UpdateOrganizationConfigurationRequest) -> operations.UpdateOrganizationConfigurationResponse:
        r"""Updates the configurations for your Amazon Inspector organization."""
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/organizationconfiguration/update'
        
        headers = utils.get_headers(request)
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = self._security_client
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.UpdateOrganizationConfigurationResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.UpdateOrganizationConfigurationResponse])
                res.update_organization_configuration_response = out
        elif http_res.status_code == 480:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.access_denied_exception = out
        elif http_res.status_code == 481:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.validation_exception = out
        elif http_res.status_code == 482:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.throttling_exception = out
        elif http_res.status_code == 483:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.internal_server_exception = out

        return res

    