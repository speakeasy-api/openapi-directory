// Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.

package shared

import (
	"encoding/json"
	"fmt"
)

type SocketAddressProtocolEnum string

const (
	SocketAddressProtocolEnumTCP SocketAddressProtocolEnum = "TCP"
	SocketAddressProtocolEnumUDP SocketAddressProtocolEnum = "UDP"
)

func (e SocketAddressProtocolEnum) ToPointer() *SocketAddressProtocolEnum {
	return &e
}

func (e *SocketAddressProtocolEnum) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "TCP":
		fallthrough
	case "UDP":
		*e = SocketAddressProtocolEnum(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SocketAddressProtocolEnum: %v", v)
	}
}

// SocketAddress - [#next-free-field: 7]
type SocketAddress struct {
	// The address for this socket. :ref:`Listeners ` will bind to the address. An empty address is not allowed. Specify ``0.0.0.0`` or ``::`` to bind to any address. [#comment:TODO(zuercher) reinstate when implemented: It is possible to distinguish a Listener address via the prefix/suffix matching in :ref:`FilterChainMatch `.] When used within an upstream :ref:`BindConfig `, the address controls the source address of outbound connections. For :ref:`clusters `, the cluster type determines whether the address must be an IP (*STATIC* or *EDS* clusters) or a hostname resolved by DNS (*STRICT_DNS* or *LOGICAL_DNS* clusters). Address resolution can be customized via :ref:`resolver_name `.
	Address *string `json:"address,omitempty"`
	// When binding to an IPv6 address above, this enables `IPv4 compatibility `_. Binding to ``::`` will allow both IPv4 and IPv6 connections, with peer IPv4 addresses mapped into IPv6 space as ``::FFFF:``.
	Ipv4Compat *bool `json:"ipv4Compat,omitempty"`
	// This is only valid if :ref:`resolver_name ` is specified below and the named resolver is capable of named port resolution.
	NamedPort *string                    `json:"namedPort,omitempty"`
	PortValue *int64                     `json:"portValue,omitempty"`
	Protocol  *SocketAddressProtocolEnum `json:"protocol,omitempty"`
	// The name of the custom resolver. This must have been registered with Envoy. If this is empty, a context dependent default applies. If the address is a concrete IP address, no resolution will occur. If address is a hostname this should be set for resolution other than DNS. Specifying a custom resolver with *STRICT_DNS* or *LOGICAL_DNS* will generate an error at runtime.
	ResolverName *string `json:"resolverName,omitempty"`
}
