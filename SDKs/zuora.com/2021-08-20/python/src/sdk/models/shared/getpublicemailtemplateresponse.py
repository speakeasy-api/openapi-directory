"""Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT."""

from __future__ import annotations
import dataclasses
import dateutil.parser
from dataclasses_json import Undefined, dataclass_json
from datetime import datetime
from enum import Enum
from marshmallow import fields
from sdk import utils
from typing import Optional

class GETPublicEmailTemplateResponseCcEmailTypeEnum(str, Enum):
    r"""Email cc type."""
    BILL_TO_CONTACT = 'BillToContact'
    SOLD_TO_CONTACT = 'SoldToContact'
    SPECIFIC_EMAILS = 'SpecificEmails'
    TENANT_ADMIN = 'TenantAdmin'
    BILL_TO_AND_SOLD_TO_CONTACTS = 'BillToAndSoldToContacts'
    RUN_OWNER = 'RunOwner'
    ALL_CONTACTS = 'AllContacts'
    INVOICE_OWNER_BILL_TO_CONTACT = 'InvoiceOwnerBillToContact'
    INVOICE_OWNER_SOLD_TO_CONTACT = 'InvoiceOwnerSoldToContact'
    INVOICE_OWNER_BILL_TO_AND_SOLD_TO_CONTACTS = 'InvoiceOwnerBillToAndSoldToContacts'
    INVOICE_OWNER_ALL_CONTACTS = 'InvoiceOwnerAllContacts'

class GETPublicEmailTemplateResponseEncodingTypeEnum(str, Enum):
    r"""The endcode type of the email body."""
    UTF8 = 'UTF8'
    SHIFT_JIS = 'Shift_JIS'
    ISO_2022_JP = 'ISO_2022_JP'
    EUC_JP = 'EUC_JP'
    X_SJIS_0213 = 'X_SJIS_0213'

class GETPublicEmailTemplateResponseFromEmailTypeEnum(str, Enum):
    r"""The from email type."""
    TENANT_EMAIL = 'TenantEmail'
    SPECIFIC_EMAIL = 'SpecificEmail'

class GETPublicEmailTemplateResponseReplyToEmailTypeEnum(str, Enum):
    r"""The reply email type."""
    TENANT_EMAIL = 'TenantEmail'
    SPECIFIC_EMAIL = 'SpecificEmail'

class GETPublicEmailTemplateResponseToEmailTypeEnum(str, Enum):
    r"""Email receive type."""
    BILL_TO_CONTACT = 'BillToContact'
    SOLD_TO_CONTACT = 'SoldToContact'
    SPECIFIC_EMAILS = 'SpecificEmails'
    TENANT_ADMIN = 'TenantAdmin'
    BILL_TO_AND_SOLD_TO_CONTACTS = 'BillToAndSoldToContacts'
    RUN_OWNER = 'RunOwner'
    ALL_CONTACTS = 'AllContacts'
    INVOICE_OWNER_BILL_TO_CONTACT = 'InvoiceOwnerBillToContact'
    INVOICE_OWNER_SOLD_TO_CONTACT = 'InvoiceOwnerSoldToContact'
    INVOICE_OWNER_BILL_TO_AND_SOLD_TO_CONTACTS = 'InvoiceOwnerBillToAndSoldToContacts'
    INVOICE_OWNER_ALL_CONTACTS = 'InvoiceOwnerAllContacts'


@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class GETPublicEmailTemplateResponse:
    r"""OK"""
    
    active: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('active'), 'exclude': lambda f: f is None }})
    r"""The status of the email template."""  
    bcc_email_address: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('bccEmailAddress'), 'exclude': lambda f: f is None }})
    r"""Email BCC address."""  
    cc_email_address: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('ccEmailAddress'), 'exclude': lambda f: f is None }})
    r"""Email CC address."""  
    cc_email_type: Optional[GETPublicEmailTemplateResponseCcEmailTypeEnum] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('ccEmailType'), 'exclude': lambda f: f is None }})
    r"""Email cc type."""  
    created_by: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('createdBy'), 'exclude': lambda f: f is None }})
    r"""The ID of the user who created the notification definition."""  
    created_on: Optional[datetime] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('createdOn'), 'encoder': utils.datetimeisoformat(True), 'decoder': dateutil.parser.isoparse, 'mm_field': fields.DateTime(format='iso'), 'exclude': lambda f: f is None }})
    r"""The time when the notification definition was created. Specified in the UTC timezone in the ISO860 format (YYYY-MM-DDThh:mm:ss.sTZD). E.g. 1997-07-16T19:20:30.45+00:00"""  
    description: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('description'), 'exclude': lambda f: f is None }})
    r"""The description of the email template."""  
    email_body: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('emailBody'), 'exclude': lambda f: f is None }})
    r"""The email body. You can add merge fields in the email object using angle brackets.
    User can also embed html tags if 'isHtml' is true.
    """  
    email_subject: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('emailSubject'), 'exclude': lambda f: f is None }})
    r"""The email subject. You can add merge fields in the email subject using angle brackets."""  
    encoding_type: Optional[GETPublicEmailTemplateResponseEncodingTypeEnum] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('encodingType'), 'exclude': lambda f: f is None }})
    r"""The endcode type of the email body."""  
    event_type_name: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('eventTypeName'), 'exclude': lambda f: f is None }})
    r"""The name of the event type."""  
    event_type_namespace: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('eventTypeNamespace'), 'exclude': lambda f: f is None }})
    r"""The namespace of the `eventTypeName` field."""  
    from_email_address: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('fromEmailAddress'), 'exclude': lambda f: f is None }})
    r"""If formEmailType is SpecificEmail, this field is required."""  
    from_email_type: Optional[GETPublicEmailTemplateResponseFromEmailTypeEnum] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('fromEmailType'), 'exclude': lambda f: f is None }})
    r"""The from email type."""  
    from_name: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('fromName'), 'exclude': lambda f: f is None }})
    r"""The name of email sender."""  
    id: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('id'), 'exclude': lambda f: f is None }})
    r"""The filter rule associated with this notification definition."""  
    is_html: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('isHtml'), 'exclude': lambda f: f is None }})
    r"""Specified whether the style of email body is HTML."""  
    name: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('name'), 'exclude': lambda f: f is None }})
    r"""The name of the email template."""  
    reply_to_email_address: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('replyToEmailAddress'), 'exclude': lambda f: f is None }})
    r"""If replyToEmailType is SpecificEmail, this field is required"""  
    reply_to_email_type: Optional[GETPublicEmailTemplateResponseReplyToEmailTypeEnum] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('replyToEmailType'), 'exclude': lambda f: f is None }})
    r"""The reply email type."""  
    to_email_address: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('toEmailAddress'), 'exclude': lambda f: f is None }})
    r"""If toEmailType is SpecificEmail, this field is required."""  
    to_email_type: Optional[GETPublicEmailTemplateResponseToEmailTypeEnum] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('toEmailType'), 'exclude': lambda f: f is None }})
    r"""Email receive type."""  
    updated_by: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('updatedBy'), 'exclude': lambda f: f is None }})
    r"""The ID of the user who updated the notification definition."""  
    updated_on: Optional[datetime] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('updatedOn'), 'encoder': utils.datetimeisoformat(True), 'decoder': dateutil.parser.isoparse, 'mm_field': fields.DateTime(format='iso'), 'exclude': lambda f: f is None }})
    r"""The time when the notification definition was updated. Specified in the UTC timezone in the ISO860 format (YYYY-MM-DDThh:mm:ss.sTZD). E.g. 1997-07-16T19:20:30.45+00:00"""  
    