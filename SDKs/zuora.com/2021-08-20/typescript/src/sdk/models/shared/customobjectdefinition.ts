/*
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

import {
  objectToClass,
  SpeakeasyBase,
  SpeakeasyMetadata,
} from "../../../internal/utils";
import { CustomObjectCustomFieldDefinition } from "./customobjectcustomfielddefinition";
import { Expose, Transform, Type } from "class-transformer";

/**
 * The cardinality of the relationship from this object to another object.
 *
 * @remarks
 *
 * A `manyToOne` relationship means this object is the child object (the "many" side), and the referenced object (the "one" side) is the parent.
 *
 * A `oneToMany` relationship means this object is the parent object (the "one" side), and the referenced object (the "many" side) is the child.
 *
 */
export enum CustomObjectDefinitionSchemaRelationshipsCardinalityEnum {
  ManyToOne = "manyToOne",
  OneToMany = "oneToMany",
}

export class CustomObjectDefinitionSchemaRelationshipsRecordConstraintsCreate extends SpeakeasyBase {
  /**
   * Specifies whether Zuora validates the values of mapped fields
   *
   * @remarks
   * in custom object records.
   *
   */
  @SpeakeasyMetadata()
  @Expose({ name: "enforceValidMapping" })
  enforceValidMapping?: boolean;
}

/**
 * Specifies contraints to apply to custom object records.
 *
 * @remarks
 *
 */
export class CustomObjectDefinitionSchemaRelationshipsRecordConstraints extends SpeakeasyBase {
  @SpeakeasyMetadata()
  @Expose({ name: "create" })
  @Type(() => CustomObjectDefinitionSchemaRelationshipsRecordConstraintsCreate)
  create?: CustomObjectDefinitionSchemaRelationshipsRecordConstraintsCreate;
}

export class CustomObjectDefinitionSchemaRelationships extends SpeakeasyBase {
  /**
   * The cardinality of the relationship from this object to another object.
   *
   * @remarks
   *
   * A `manyToOne` relationship means this object is the child object (the "many" side), and the referenced object (the "one" side) is the parent.
   *
   * A `oneToMany` relationship means this object is the parent object (the "one" side), and the referenced object (the "many" side) is the child.
   *
   */
  @SpeakeasyMetadata()
  @Expose({ name: "cardinality" })
  cardinality?: CustomObjectDefinitionSchemaRelationshipsCardinalityEnum;

  /**
   * Field mappings in the form of `<this-object-field-name>`: `<other-object-field-name>`.
   *
   * @remarks
   *
   */
  @SpeakeasyMetadata()
  @Expose({ name: "fields" })
  fields?: Record<string, string>;

  /**
   * The namespace where the related object is located
   */
  @SpeakeasyMetadata()
  @Expose({ name: "namespace" })
  namespace?: string;

  /**
   * The API name of the related object
   */
  @SpeakeasyMetadata()
  @Expose({ name: "object" })
  object?: string;

  /**
   * Specifies contraints to apply to custom object records.
   *
   * @remarks
   *
   */
  @SpeakeasyMetadata()
  @Expose({ name: "recordConstraints" })
  @Type(() => CustomObjectDefinitionSchemaRelationshipsRecordConstraints)
  recordConstraints?: CustomObjectDefinitionSchemaRelationshipsRecordConstraints;
}

/**
 * The custom object definition type. Can only be `object` currently.
 */
export enum CustomObjectDefinitionSchemaTypeEnum {
  Object = "object",
}

/**
 * The schema of the custom object definition
 */
export class CustomObjectDefinitionSchema extends SpeakeasyBase {
  /**
   * The set of fields that are allowed to be queried on. Queries on non-filterable fields will be rejected. You can not change a non-filterable field to filterable.
   */
  @SpeakeasyMetadata()
  @Expose({ name: "filterable" })
  filterable?: string[];

  /**
   * A label for the custom object
   */
  @SpeakeasyMetadata()
  @Expose({ name: "label" })
  label?: string;

  /**
   * The API name of the custom object
   */
  @SpeakeasyMetadata()
  @Expose({ name: "object" })
  object?: string;

  /**
   * The definitions of all the fields in the custom object definition
   */
  @SpeakeasyMetadata({ elemType: CustomObjectCustomFieldDefinition })
  @Expose({ name: "properties" })
  @Transform(
    ({ value }) => {
      const obj: Record<string, CustomObjectCustomFieldDefinition> = {};
      for (const key in value) {
        obj[key] = objectToClass(value[key], CustomObjectCustomFieldDefinition);
      }
      return obj;
    },
    { toClassOnly: true }
  )
  properties?: Record<string, CustomObjectCustomFieldDefinition>;

  /**
   * An array of relationships with Zuora objects or other custom objects
   */
  @SpeakeasyMetadata({ elemType: CustomObjectDefinitionSchemaRelationships })
  @Expose({ name: "relationships" })
  @Type(() => CustomObjectDefinitionSchemaRelationships)
  relationships?: CustomObjectDefinitionSchemaRelationships[];

  /**
   * The required fields of the custom object definition. You can change required fields to optional. However, you can only change optional fields to required on the custom objects with no records.
   */
  @SpeakeasyMetadata()
  @Expose({ name: "required" })
  required?: string[];

  /**
   * The custom object definition type. Can only be `object` currently.
   */
  @SpeakeasyMetadata()
  @Expose({ name: "type" })
  type?: CustomObjectDefinitionSchemaTypeEnum;
}

/**
 * OK
 */
export class CustomObjectDefinition extends SpeakeasyBase {
  /**
   * The creator's Id
   */
  @SpeakeasyMetadata()
  @Expose({ name: "CreatedById" })
  createdById?: string;

  /**
   * The creation time of the custom object definition in date-time format.
   */
  @SpeakeasyMetadata()
  @Expose({ name: "CreatedDate" })
  @Transform(({ value }) => new Date(value), { toClassOnly: true })
  createdDate?: Date;

  /**
   * The unique Id of the custom object definition
   */
  @SpeakeasyMetadata()
  @Expose({ name: "Id" })
  id?: string;

  /**
   * The modifier's Id
   */
  @SpeakeasyMetadata()
  @Expose({ name: "UpdatedById" })
  updatedById?: string;

  /**
   * The update time of the custom object definition in date-time format.
   */
  @SpeakeasyMetadata()
  @Expose({ name: "UpdatedDate" })
  @Transform(({ value }) => new Date(value), { toClassOnly: true })
  updatedDate?: Date;

  /**
   * The schema of the custom object definition
   */
  @SpeakeasyMetadata()
  @Expose({ name: "schema" })
  @Type(() => CustomObjectDefinitionSchema)
  schema?: CustomObjectDefinitionSchema;

  /**
   * The API name of the custom object
   */
  @SpeakeasyMetadata()
  @Expose({ name: "type" })
  type?: string;
}
