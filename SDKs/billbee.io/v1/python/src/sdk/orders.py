"""Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT."""

import requests as requests_http
from . import utils
from sdk.models import operations, shared
from typing import Any, Optional

class Orders:
    _client: requests_http.Session
    _security_client: requests_http.Session
    _server_url: str
    _language: str
    _sdk_version: str
    _gen_version: str

    def __init__(self, client: requests_http.Session, security_client: requests_http.Session, server_url: str, language: str, sdk_version: str, gen_version: str) -> None:
        self._client = client
        self._security_client = security_client
        self._server_url = server_url
        self._language = language
        self._sdk_version = sdk_version
        self._gen_version = gen_version
        
    def layout_api_get_list(self) -> operations.LayoutAPIGetListResponse:
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/api/v1/layouts'
        
        
        client = self._client
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.LayoutAPIGetListResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.RechnungsdruckWebAppControllersAPIAPIResultSystemCollectionsGenericListBillbeeInterfacesBillbeeAPIModelsLayoutTemplate])
                res.rechnungsdruck_web_app_controllers_api_api_result_system_collections_generic_list_billbee_interfaces_billbee_api_models_layout_template = out
            if utils.match_content_type(content_type, 'text/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.RechnungsdruckWebAppControllersAPIAPIResultSystemCollectionsGenericListBillbeeInterfacesBillbeeAPIModelsLayoutTemplate])
                res.rechnungsdruck_web_app_controllers_api_api_result_system_collections_generic_list_billbee_interfaces_billbee_api_models_layout_template = out
            if utils.match_content_type(content_type, 'application/xml'):
                res.body = http_res.content
            if utils.match_content_type(content_type, 'text/xml'):
                res.body = http_res.content

        return res

    def order_api_add_shipment_form(self, request: operations.OrderAPIAddShipmentFormRequest) -> operations.OrderAPIAddShipmentFormResponse:
        r"""Add a shipment to a given order"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.OrderAPIAddShipmentFormRequest, base_url, '/api/v1/orders/{id}/shipment', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "rechnungsdruck_web_app_controllers_api_api_add_shipment_to_order_model", 'form')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = self._client
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.OrderAPIAddShipmentFormResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[dict[str, Any]])
                res.order_api_add_shipment_form_200_application_json_object = out
            if utils.match_content_type(content_type, 'text/json'):
                out = utils.unmarshal_json(http_res.text, Optional[dict[str, Any]])
                res.order_api_add_shipment_form_200_text_json_object = out

        return res

    def order_api_add_shipment_json(self, request: operations.OrderAPIAddShipmentJSONRequest) -> operations.OrderAPIAddShipmentJSONResponse:
        r"""Add a shipment to a given order"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.OrderAPIAddShipmentJSONRequest, base_url, '/api/v1/orders/{id}/shipment', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "rechnungsdruck_web_app_controllers_api_api_add_shipment_to_order_model", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = self._client
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.OrderAPIAddShipmentJSONResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[dict[str, Any]])
                res.order_api_add_shipment_json_200_application_json_object = out
            if utils.match_content_type(content_type, 'text/json'):
                out = utils.unmarshal_json(http_res.text, Optional[dict[str, Any]])
                res.order_api_add_shipment_json_200_text_json_object = out

        return res

    def order_api_add_shipment_raw(self, request: operations.OrderAPIAddShipmentRawRequest) -> operations.OrderAPIAddShipmentRawResponse:
        r"""Add a shipment to a given order"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.OrderAPIAddShipmentRawRequest, base_url, '/api/v1/orders/{id}/shipment', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'raw')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = self._client
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.OrderAPIAddShipmentRawResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[dict[str, Any]])
                res.order_api_add_shipment_raw_200_application_json_object = out
            if utils.match_content_type(content_type, 'text/json'):
                out = utils.unmarshal_json(http_res.text, Optional[dict[str, Any]])
                res.order_api_add_shipment_raw_200_text_json_object = out

        return res

    def order_api_create_delivery_note(self, request: operations.OrderAPICreateDeliveryNoteRequest) -> operations.OrderAPICreateDeliveryNoteResponse:
        r"""Create an delivery note for an existing order. This request is extra throttled by order and api key to a maximum of 1 per 5 minutes."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.OrderAPICreateDeliveryNoteRequest, base_url, '/api/v1/orders/CreateDeliveryNote/{id}', request)
        
        query_params = utils.get_query_params(operations.OrderAPICreateDeliveryNoteRequest, request)
        
        client = self._client
        
        http_res = client.request('POST', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.OrderAPICreateDeliveryNoteResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[dict[str, Any]])
                res.order_api_create_delivery_note_200_application_json_object = out
            if utils.match_content_type(content_type, 'text/json'):
                out = utils.unmarshal_json(http_res.text, Optional[dict[str, Any]])
                res.order_api_create_delivery_note_200_text_json_object = out

        return res

    def order_api_create_invoice(self, request: operations.OrderAPICreateInvoiceRequest) -> operations.OrderAPICreateInvoiceResponse:
        r"""Create an invoice for an existing order. This request is extra throttled by order and api key to a maximum of 1 per 5 minutes."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.OrderAPICreateInvoiceRequest, base_url, '/api/v1/orders/CreateInvoice/{id}', request)
        
        query_params = utils.get_query_params(operations.OrderAPICreateInvoiceRequest, request)
        
        client = self._client
        
        http_res = client.request('POST', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.OrderAPICreateInvoiceResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[dict[str, Any]])
                res.order_api_create_invoice_200_application_json_object = out
            if utils.match_content_type(content_type, 'text/json'):
                out = utils.unmarshal_json(http_res.text, Optional[dict[str, Any]])
                res.order_api_create_invoice_200_text_json_object = out

        return res

    def order_api_find(self, request: operations.OrderAPIFindRequest) -> operations.OrderAPIFindResponse:
        r"""Find a single order by its external id (order number)"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.OrderAPIFindRequest, base_url, '/api/v1/orders/find/{id}/{partner}', request)
        
        
        client = self._client
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.OrderAPIFindResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[dict[str, Any]])
                res.order_api_find_200_application_json_object = out
            if utils.match_content_type(content_type, 'text/json'):
                out = utils.unmarshal_json(http_res.text, Optional[dict[str, Any]])
                res.order_api_find_200_text_json_object = out

        return res

    def order_api_get(self, request: operations.OrderAPIGetRequest) -> operations.OrderAPIGetResponse:
        r"""Get a single order by its internal billbee id. This request is throttled to 6 calls per order in one minute"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.OrderAPIGetRequest, base_url, '/api/v1/orders/{id}', request)
        
        query_params = utils.get_query_params(operations.OrderAPIGetRequest, request)
        
        client = self._client
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.OrderAPIGetResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.RechnungsdruckWebAppControllersAPIAPIResultBillbeeInterfacesBillbeeAPIModelOrder])
                res.rechnungsdruck_web_app_controllers_api_api_result_billbee_interfaces_billbee_api_model_order = out
            if utils.match_content_type(content_type, 'text/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.RechnungsdruckWebAppControllersAPIAPIResultBillbeeInterfacesBillbeeAPIModelOrder])
                res.rechnungsdruck_web_app_controllers_api_api_result_billbee_interfaces_billbee_api_model_order = out
            if utils.match_content_type(content_type, 'application/xml'):
                res.body = http_res.content
            if utils.match_content_type(content_type, 'text/xml'):
                res.body = http_res.content

        return res

    def order_api_get_by_ext_ref(self, request: operations.OrderAPIGetByExtRefRequest) -> operations.OrderAPIGetByExtRefResponse:
        r"""Get a single order by its external order number"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.OrderAPIGetByExtRefRequest, base_url, '/api/v1/orders/findbyextref/{extRef}', request)
        
        
        client = self._client
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.OrderAPIGetByExtRefResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.RechnungsdruckWebAppControllersAPIAPIResultBillbeeInterfacesBillbeeAPIModelOrder])
                res.rechnungsdruck_web_app_controllers_api_api_result_billbee_interfaces_billbee_api_model_order = out
            if utils.match_content_type(content_type, 'text/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.RechnungsdruckWebAppControllersAPIAPIResultBillbeeInterfacesBillbeeAPIModelOrder])
                res.rechnungsdruck_web_app_controllers_api_api_result_billbee_interfaces_billbee_api_model_order = out
            if utils.match_content_type(content_type, 'application/xml'):
                res.body = http_res.content
            if utils.match_content_type(content_type, 'text/xml'):
                res.body = http_res.content

        return res

    def order_api_get_invoice_list(self, request: operations.OrderAPIGetInvoiceListRequest) -> operations.OrderAPIGetInvoiceListResponse:
        r"""Get a list of all invoices optionally filtered by date. This request ist throttled to 1 per 1 minute for same page and minInvoiceDate"""
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/api/v1/orders/invoices'
        
        query_params = utils.get_query_params(operations.OrderAPIGetInvoiceListRequest, request)
        
        client = self._client
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.OrderAPIGetInvoiceListResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[dict[str, Any]])
                res.order_api_get_invoice_list_200_application_json_object = out
            if utils.match_content_type(content_type, 'text/json'):
                out = utils.unmarshal_json(http_res.text, Optional[dict[str, Any]])
                res.order_api_get_invoice_list_200_text_json_object = out

        return res

    def order_api_get_list(self, request: operations.OrderAPIGetListRequest) -> operations.OrderAPIGetListResponse:
        r"""Get a list of all orders optionally filtered by date"""
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/api/v1/orders'
        
        query_params = utils.get_query_params(operations.OrderAPIGetListRequest, request)
        
        client = self._client
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.OrderAPIGetListResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.RechnungsdruckWebAppControllersAPIAPIPagedResultSystemCollectionsGenericListBillbeeInterfacesBillbeeAPIModelOrder])
                res.rechnungsdruck_web_app_controllers_api_api_paged_result_system_collections_generic_list_billbee_interfaces_billbee_api_model_order = out
            if utils.match_content_type(content_type, 'text/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.RechnungsdruckWebAppControllersAPIAPIPagedResultSystemCollectionsGenericListBillbeeInterfacesBillbeeAPIModelOrder])
                res.rechnungsdruck_web_app_controllers_api_api_paged_result_system_collections_generic_list_billbee_interfaces_billbee_api_model_order = out
            if utils.match_content_type(content_type, 'application/xml'):
                res.body = http_res.content
            if utils.match_content_type(content_type, 'text/xml'):
                res.body = http_res.content

        return res

    def order_api_get_patchable_fields(self) -> operations.OrderAPIGetPatchableFieldsResponse:
        r"""Returns a list of fields which can be updated with the orders/{id} patch call"""
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/api/v1/orders/PatchableFields'
        
        
        client = self._client
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.OrderAPIGetPatchableFieldsResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[dict[str, Any]])
                res.order_api_get_patchable_fields_200_application_json_object = out
            if utils.match_content_type(content_type, 'text/json'):
                out = utils.unmarshal_json(http_res.text, Optional[dict[str, Any]])
                res.order_api_get_patchable_fields_200_text_json_object = out

        return res

    def order_api_parse_placeholders_form(self, request: operations.OrderAPIParsePlaceholdersFormRequest) -> operations.OrderAPIParsePlaceholdersFormResponse:
        r"""Parses a text and replaces all placeholders"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.OrderAPIParsePlaceholdersFormRequest, base_url, '/api/v1/orders/{id}/parse-placeholders', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "rechnungsdruck_web_app_controllers_api_order_api_controller_parse_text_container", 'form')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = self._client
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.OrderAPIParsePlaceholdersFormResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[dict[str, Any]])
                res.order_api_parse_placeholders_form_200_application_json_object = out
            if utils.match_content_type(content_type, 'text/json'):
                out = utils.unmarshal_json(http_res.text, Optional[dict[str, Any]])
                res.order_api_parse_placeholders_form_200_text_json_object = out

        return res

    def order_api_parse_placeholders_json(self, request: operations.OrderAPIParsePlaceholdersJSONRequest) -> operations.OrderAPIParsePlaceholdersJSONResponse:
        r"""Parses a text and replaces all placeholders"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.OrderAPIParsePlaceholdersJSONRequest, base_url, '/api/v1/orders/{id}/parse-placeholders', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "rechnungsdruck_web_app_controllers_api_order_api_controller_parse_text_container", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = self._client
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.OrderAPIParsePlaceholdersJSONResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[dict[str, Any]])
                res.order_api_parse_placeholders_json_200_application_json_object = out
            if utils.match_content_type(content_type, 'text/json'):
                out = utils.unmarshal_json(http_res.text, Optional[dict[str, Any]])
                res.order_api_parse_placeholders_json_200_text_json_object = out

        return res

    def order_api_parse_placeholders_raw(self, request: operations.OrderAPIParsePlaceholdersRawRequest) -> operations.OrderAPIParsePlaceholdersRawResponse:
        r"""Parses a text and replaces all placeholders"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.OrderAPIParsePlaceholdersRawRequest, base_url, '/api/v1/orders/{id}/parse-placeholders', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'raw')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = self._client
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.OrderAPIParsePlaceholdersRawResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[dict[str, Any]])
                res.order_api_parse_placeholders_raw_200_application_json_object = out
            if utils.match_content_type(content_type, 'text/json'):
                out = utils.unmarshal_json(http_res.text, Optional[dict[str, Any]])
                res.order_api_parse_placeholders_raw_200_text_json_object = out

        return res

    def order_api_patch_order(self, request: operations.OrderAPIPatchOrderRequest) -> operations.OrderAPIPatchOrderResponse:
        r"""Updates one or more fields of an order"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.OrderAPIPatchOrderRequest, base_url, '/api/v1/orders/{id}', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = self._client
        
        http_res = client.request('PATCH', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.OrderAPIPatchOrderResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.RechnungsdruckWebAppControllersAPIAPIResultBillbeeInterfacesBillbeeAPIModelOrder])
                res.rechnungsdruck_web_app_controllers_api_api_result_billbee_interfaces_billbee_api_model_order = out
            if utils.match_content_type(content_type, 'text/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.RechnungsdruckWebAppControllersAPIAPIResultBillbeeInterfacesBillbeeAPIModelOrder])
                res.rechnungsdruck_web_app_controllers_api_api_result_billbee_interfaces_billbee_api_model_order = out
            if utils.match_content_type(content_type, 'application/xml'):
                res.body = http_res.content
            if utils.match_content_type(content_type, 'text/xml'):
                res.body = http_res.content

        return res

    def order_api_post_new_order_form(self, request: operations.OrderAPIPostNewOrderFormRequest) -> operations.OrderAPIPostNewOrderFormResponse:
        r"""Creates a new order in the Billbee account
        To create an order POST an JSON object to the orders endpoint with the shown properties.
        Not all properties are required.
        """
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/api/v1/orders'
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "billbee_interfaces_billbee_api_model_order_input", 'form')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        query_params = utils.get_query_params(operations.OrderAPIPostNewOrderFormRequest, request)
        
        client = self._client
        
        http_res = client.request('POST', url, params=query_params, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.OrderAPIPostNewOrderFormResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 201:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.RechnungsdruckWebAppControllersAPIAPIResultBillbeeInterfacesBillbeeAPIModelOrder])
                res.rechnungsdruck_web_app_controllers_api_api_result_billbee_interfaces_billbee_api_model_order = out
            if utils.match_content_type(content_type, 'text/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.RechnungsdruckWebAppControllersAPIAPIResultBillbeeInterfacesBillbeeAPIModelOrder])
                res.rechnungsdruck_web_app_controllers_api_api_result_billbee_interfaces_billbee_api_model_order = out
            if utils.match_content_type(content_type, 'application/xml'):
                res.body = http_res.content
            if utils.match_content_type(content_type, 'text/xml'):
                res.body = http_res.content
        elif http_res.status_code in [400, 500]:
            pass

        return res

    def order_api_post_new_order_json(self, request: operations.OrderAPIPostNewOrderJSONRequest) -> operations.OrderAPIPostNewOrderJSONResponse:
        r"""Creates a new order in the Billbee account
        To create an order POST an JSON object to the orders endpoint with the shown properties.
        Not all properties are required.
        """
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/api/v1/orders'
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "billbee_interfaces_billbee_api_model_order_input", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        query_params = utils.get_query_params(operations.OrderAPIPostNewOrderJSONRequest, request)
        
        client = self._client
        
        http_res = client.request('POST', url, params=query_params, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.OrderAPIPostNewOrderJSONResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 201:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.RechnungsdruckWebAppControllersAPIAPIResultBillbeeInterfacesBillbeeAPIModelOrder])
                res.rechnungsdruck_web_app_controllers_api_api_result_billbee_interfaces_billbee_api_model_order = out
            if utils.match_content_type(content_type, 'text/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.RechnungsdruckWebAppControllersAPIAPIResultBillbeeInterfacesBillbeeAPIModelOrder])
                res.rechnungsdruck_web_app_controllers_api_api_result_billbee_interfaces_billbee_api_model_order = out
            if utils.match_content_type(content_type, 'application/xml'):
                res.body = http_res.content
            if utils.match_content_type(content_type, 'text/xml'):
                res.body = http_res.content
        elif http_res.status_code in [400, 500]:
            pass

        return res

    def order_api_post_new_order_raw(self, request: operations.OrderAPIPostNewOrderRawRequest) -> operations.OrderAPIPostNewOrderRawResponse:
        r"""Creates a new order in the Billbee account
        To create an order POST an JSON object to the orders endpoint with the shown properties.
        Not all properties are required.
        """
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/api/v1/orders'
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'raw')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        query_params = utils.get_query_params(operations.OrderAPIPostNewOrderRawRequest, request)
        
        client = self._client
        
        http_res = client.request('POST', url, params=query_params, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.OrderAPIPostNewOrderRawResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 201:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.RechnungsdruckWebAppControllersAPIAPIResultBillbeeInterfacesBillbeeAPIModelOrder])
                res.rechnungsdruck_web_app_controllers_api_api_result_billbee_interfaces_billbee_api_model_order = out
            if utils.match_content_type(content_type, 'text/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.RechnungsdruckWebAppControllersAPIAPIResultBillbeeInterfacesBillbeeAPIModelOrder])
                res.rechnungsdruck_web_app_controllers_api_api_result_billbee_interfaces_billbee_api_model_order = out
            if utils.match_content_type(content_type, 'application/xml'):
                res.body = http_res.content
            if utils.match_content_type(content_type, 'text/xml'):
                res.body = http_res.content
        elif http_res.status_code in [400, 500]:
            pass

        return res

    def order_api_send_message_form(self, request: operations.OrderAPISendMessageFormRequest) -> operations.OrderAPISendMessageFormResponse:
        r"""Sends a message to the buyer"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.OrderAPISendMessageFormRequest, base_url, '/api/v1/orders/{id}/send-message', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "rechnungsdruck_web_app_controllers_api_order_api_controller_send_message_model", 'form')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = self._client
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.OrderAPISendMessageFormResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[dict[str, Any]])
                res.order_api_send_message_form_200_application_json_object = out
            if utils.match_content_type(content_type, 'text/json'):
                out = utils.unmarshal_json(http_res.text, Optional[dict[str, Any]])
                res.order_api_send_message_form_200_text_json_object = out

        return res

    def order_api_send_message_json(self, request: operations.OrderAPISendMessageJSONRequest) -> operations.OrderAPISendMessageJSONResponse:
        r"""Sends a message to the buyer"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.OrderAPISendMessageJSONRequest, base_url, '/api/v1/orders/{id}/send-message', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "rechnungsdruck_web_app_controllers_api_order_api_controller_send_message_model", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = self._client
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.OrderAPISendMessageJSONResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[dict[str, Any]])
                res.order_api_send_message_json_200_application_json_object = out
            if utils.match_content_type(content_type, 'text/json'):
                out = utils.unmarshal_json(http_res.text, Optional[dict[str, Any]])
                res.order_api_send_message_json_200_text_json_object = out

        return res

    def order_api_send_message_raw(self, request: operations.OrderAPISendMessageRawRequest) -> operations.OrderAPISendMessageRawResponse:
        r"""Sends a message to the buyer"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.OrderAPISendMessageRawRequest, base_url, '/api/v1/orders/{id}/send-message', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'raw')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = self._client
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.OrderAPISendMessageRawResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[dict[str, Any]])
                res.order_api_send_message_raw_200_application_json_object = out
            if utils.match_content_type(content_type, 'text/json'):
                out = utils.unmarshal_json(http_res.text, Optional[dict[str, Any]])
                res.order_api_send_message_raw_200_text_json_object = out

        return res

    def order_api_tags_create_form(self, request: operations.OrderAPITagsCreateFormRequest) -> operations.OrderAPITagsCreateFormResponse:
        r"""Attach one or more tags to an order
        When a tag is already attached, it is ignored. Tags are not case sensitive. All given tags are added to the existing tags.
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.OrderAPITagsCreateFormRequest, base_url, '/api/v1/orders/{id}/tags', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "rechnungsdruck_web_app_controllers_api_order_tag_create", 'form')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = self._client
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.OrderAPITagsCreateFormResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[dict[str, Any]])
                res.order_api_tags_create_form_200_application_json_object = out
            if utils.match_content_type(content_type, 'text/json'):
                out = utils.unmarshal_json(http_res.text, Optional[dict[str, Any]])
                res.order_api_tags_create_form_200_text_json_object = out

        return res

    def order_api_tags_create_json(self, request: operations.OrderAPITagsCreateJSONRequest) -> operations.OrderAPITagsCreateJSONResponse:
        r"""Attach one or more tags to an order
        When a tag is already attached, it is ignored. Tags are not case sensitive. All given tags are added to the existing tags.
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.OrderAPITagsCreateJSONRequest, base_url, '/api/v1/orders/{id}/tags', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "rechnungsdruck_web_app_controllers_api_order_tag_create", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = self._client
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.OrderAPITagsCreateJSONResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[dict[str, Any]])
                res.order_api_tags_create_json_200_application_json_object = out
            if utils.match_content_type(content_type, 'text/json'):
                out = utils.unmarshal_json(http_res.text, Optional[dict[str, Any]])
                res.order_api_tags_create_json_200_text_json_object = out

        return res

    def order_api_tags_create_raw(self, request: operations.OrderAPITagsCreateRawRequest) -> operations.OrderAPITagsCreateRawResponse:
        r"""Attach one or more tags to an order
        When a tag is already attached, it is ignored. Tags are not case sensitive. All given tags are added to the existing tags.
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.OrderAPITagsCreateRawRequest, base_url, '/api/v1/orders/{id}/tags', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'raw')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = self._client
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.OrderAPITagsCreateRawResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[dict[str, Any]])
                res.order_api_tags_create_raw_200_application_json_object = out
            if utils.match_content_type(content_type, 'text/json'):
                out = utils.unmarshal_json(http_res.text, Optional[dict[str, Any]])
                res.order_api_tags_create_raw_200_text_json_object = out

        return res

    def order_api_tags_update_form(self, request: operations.OrderAPITagsUpdateFormRequest) -> operations.OrderAPITagsUpdateFormResponse:
        r"""Sets the tags attached to an order
        All existing tags will be replaced by the given list of new tags. To just add tags, use POST method.
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.OrderAPITagsUpdateFormRequest, base_url, '/api/v1/orders/{id}/tags', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "rechnungsdruck_web_app_controllers_api_order_tag_create", 'form')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = self._client
        
        http_res = client.request('PUT', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.OrderAPITagsUpdateFormResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[dict[str, Any]])
                res.order_api_tags_update_form_200_application_json_object = out
            if utils.match_content_type(content_type, 'text/json'):
                out = utils.unmarshal_json(http_res.text, Optional[dict[str, Any]])
                res.order_api_tags_update_form_200_text_json_object = out

        return res

    def order_api_tags_update_json(self, request: operations.OrderAPITagsUpdateJSONRequest) -> operations.OrderAPITagsUpdateJSONResponse:
        r"""Sets the tags attached to an order
        All existing tags will be replaced by the given list of new tags. To just add tags, use POST method.
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.OrderAPITagsUpdateJSONRequest, base_url, '/api/v1/orders/{id}/tags', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "rechnungsdruck_web_app_controllers_api_order_tag_create", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = self._client
        
        http_res = client.request('PUT', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.OrderAPITagsUpdateJSONResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[dict[str, Any]])
                res.order_api_tags_update_json_200_application_json_object = out
            if utils.match_content_type(content_type, 'text/json'):
                out = utils.unmarshal_json(http_res.text, Optional[dict[str, Any]])
                res.order_api_tags_update_json_200_text_json_object = out

        return res

    def order_api_tags_update_raw(self, request: operations.OrderAPITagsUpdateRawRequest) -> operations.OrderAPITagsUpdateRawResponse:
        r"""Sets the tags attached to an order
        All existing tags will be replaced by the given list of new tags. To just add tags, use POST method.
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.OrderAPITagsUpdateRawRequest, base_url, '/api/v1/orders/{id}/tags', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'raw')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = self._client
        
        http_res = client.request('PUT', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.OrderAPITagsUpdateRawResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[dict[str, Any]])
                res.order_api_tags_update_raw_200_application_json_object = out
            if utils.match_content_type(content_type, 'text/json'):
                out = utils.unmarshal_json(http_res.text, Optional[dict[str, Any]])
                res.order_api_tags_update_raw_200_text_json_object = out

        return res

    def order_api_trigger_event_form(self, request: operations.OrderAPITriggerEventFormRequest) -> operations.OrderAPITriggerEventFormResponse:
        r"""Triggers a rule event"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.OrderAPITriggerEventFormRequest, base_url, '/api/v1/orders/{id}/trigger-event', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "rechnungsdruck_web_app_controllers_api_order_api_controller_trigger_event_container", 'form')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = self._client
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.OrderAPITriggerEventFormResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[dict[str, Any]])
                res.order_api_trigger_event_form_200_application_json_object = out
            if utils.match_content_type(content_type, 'text/json'):
                out = utils.unmarshal_json(http_res.text, Optional[dict[str, Any]])
                res.order_api_trigger_event_form_200_text_json_object = out

        return res

    def order_api_trigger_event_json(self, request: operations.OrderAPITriggerEventJSONRequest) -> operations.OrderAPITriggerEventJSONResponse:
        r"""Triggers a rule event"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.OrderAPITriggerEventJSONRequest, base_url, '/api/v1/orders/{id}/trigger-event', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "rechnungsdruck_web_app_controllers_api_order_api_controller_trigger_event_container", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = self._client
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.OrderAPITriggerEventJSONResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[dict[str, Any]])
                res.order_api_trigger_event_json_200_application_json_object = out
            if utils.match_content_type(content_type, 'text/json'):
                out = utils.unmarshal_json(http_res.text, Optional[dict[str, Any]])
                res.order_api_trigger_event_json_200_text_json_object = out

        return res

    def order_api_trigger_event_raw(self, request: operations.OrderAPITriggerEventRawRequest) -> operations.OrderAPITriggerEventRawResponse:
        r"""Triggers a rule event"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.OrderAPITriggerEventRawRequest, base_url, '/api/v1/orders/{id}/trigger-event', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'raw')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = self._client
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.OrderAPITriggerEventRawResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[dict[str, Any]])
                res.order_api_trigger_event_raw_200_application_json_object = out
            if utils.match_content_type(content_type, 'text/json'):
                out = utils.unmarshal_json(http_res.text, Optional[dict[str, Any]])
                res.order_api_trigger_event_raw_200_text_json_object = out

        return res

    def order_api_update_state_form(self, request: operations.OrderAPIUpdateStateFormRequest) -> operations.OrderAPIUpdateStateFormResponse:
        r"""Changes the main state of a single order
        ### REMARKS ###
        Use this call to change the state of an order to i.e. paid or sent.
        
        The state is transfered to the external shop/marketplace if configured.
        This is the list of known states:
        - 1: ordered
        - 2: confirmed
        - 3: paid
        - 4: shipped
        - 5: reclamation
        - 6: deleted
        - 7: closed
        - 8: canceled
        - 9: archived
        - 10: not used
        - 11: demand note 1
        - 12: demand note 2
        - 13: packed
        - 14: offered
        - 15: payment reminder
        - 16: fulfilling
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.OrderAPIUpdateStateFormRequest, base_url, '/api/v1/orders/{id}/orderstate', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "rechnungsdruck_web_app_controllers_api_order_state_update", 'form')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = self._client
        
        http_res = client.request('PUT', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.OrderAPIUpdateStateFormResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[dict[str, Any]])
                res.order_api_update_state_form_200_application_json_object = out
            if utils.match_content_type(content_type, 'text/json'):
                out = utils.unmarshal_json(http_res.text, Optional[dict[str, Any]])
                res.order_api_update_state_form_200_text_json_object = out

        return res

    def order_api_update_state_json(self, request: operations.OrderAPIUpdateStateJSONRequest) -> operations.OrderAPIUpdateStateJSONResponse:
        r"""Changes the main state of a single order
        ### REMARKS ###
        Use this call to change the state of an order to i.e. paid or sent.
        
        The state is transfered to the external shop/marketplace if configured.
        This is the list of known states:
        - 1: ordered
        - 2: confirmed
        - 3: paid
        - 4: shipped
        - 5: reclamation
        - 6: deleted
        - 7: closed
        - 8: canceled
        - 9: archived
        - 10: not used
        - 11: demand note 1
        - 12: demand note 2
        - 13: packed
        - 14: offered
        - 15: payment reminder
        - 16: fulfilling
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.OrderAPIUpdateStateJSONRequest, base_url, '/api/v1/orders/{id}/orderstate', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "rechnungsdruck_web_app_controllers_api_order_state_update", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = self._client
        
        http_res = client.request('PUT', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.OrderAPIUpdateStateJSONResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[dict[str, Any]])
                res.order_api_update_state_json_200_application_json_object = out
            if utils.match_content_type(content_type, 'text/json'):
                out = utils.unmarshal_json(http_res.text, Optional[dict[str, Any]])
                res.order_api_update_state_json_200_text_json_object = out

        return res

    def order_api_update_state_raw(self, request: operations.OrderAPIUpdateStateRawRequest) -> operations.OrderAPIUpdateStateRawResponse:
        r"""Changes the main state of a single order
        ### REMARKS ###
        Use this call to change the state of an order to i.e. paid or sent.
        
        The state is transfered to the external shop/marketplace if configured.
        This is the list of known states:
        - 1: ordered
        - 2: confirmed
        - 3: paid
        - 4: shipped
        - 5: reclamation
        - 6: deleted
        - 7: closed
        - 8: canceled
        - 9: archived
        - 10: not used
        - 11: demand note 1
        - 12: demand note 2
        - 13: packed
        - 14: offered
        - 15: payment reminder
        - 16: fulfilling
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.OrderAPIUpdateStateRawRequest, base_url, '/api/v1/orders/{id}/orderstate', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'raw')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = self._client
        
        http_res = client.request('PUT', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.OrderAPIUpdateStateRawResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[dict[str, Any]])
                res.order_api_update_state_raw_200_application_json_object = out
            if utils.match_content_type(content_type, 'text/json'):
                out = utils.unmarshal_json(http_res.text, Optional[dict[str, Any]])
                res.order_api_update_state_raw_200_text_json_object = out

        return res

    def search_search_form(self, request: shared.RechnungsdruckWebAppControllersAPISearchControllerSearchModel) -> operations.SearchSearchFormResponse:
        r"""Search for products, customers and orders.
        Type can be \\"order\\", \\"product\\" and / or \\"customer\\"
        Term can contains lucene query syntax
        """
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/api/v1/search'
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request", 'form')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = self._client
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.SearchSearchFormResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.RechnungsdruckWebAppControllersAPIAPIResultRechnungsdruckWebAppControllersAPISearchControllerSearchResultsModel])
                res.rechnungsdruck_web_app_controllers_api_api_result_rechnungsdruck_web_app_controllers_api_search_controller_search_results_model = out
            if utils.match_content_type(content_type, 'text/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.RechnungsdruckWebAppControllersAPIAPIResultRechnungsdruckWebAppControllersAPISearchControllerSearchResultsModel])
                res.rechnungsdruck_web_app_controllers_api_api_result_rechnungsdruck_web_app_controllers_api_search_controller_search_results_model = out
            if utils.match_content_type(content_type, 'application/xml'):
                res.body = http_res.content
            if utils.match_content_type(content_type, 'text/xml'):
                res.body = http_res.content

        return res

    def search_search_json(self, request: shared.RechnungsdruckWebAppControllersAPISearchControllerSearchModel) -> operations.SearchSearchJSONResponse:
        r"""Search for products, customers and orders.
        Type can be \\"order\\", \\"product\\" and / or \\"customer\\"
        Term can contains lucene query syntax
        """
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/api/v1/search'
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = self._client
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.SearchSearchJSONResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.RechnungsdruckWebAppControllersAPIAPIResultRechnungsdruckWebAppControllersAPISearchControllerSearchResultsModel])
                res.rechnungsdruck_web_app_controllers_api_api_result_rechnungsdruck_web_app_controllers_api_search_controller_search_results_model = out
            if utils.match_content_type(content_type, 'text/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.RechnungsdruckWebAppControllersAPIAPIResultRechnungsdruckWebAppControllersAPISearchControllerSearchResultsModel])
                res.rechnungsdruck_web_app_controllers_api_api_result_rechnungsdruck_web_app_controllers_api_search_controller_search_results_model = out
            if utils.match_content_type(content_type, 'application/xml'):
                res.body = http_res.content
            if utils.match_content_type(content_type, 'text/xml'):
                res.body = http_res.content

        return res

    def search_search_raw(self, request: bytes) -> operations.SearchSearchRawResponse:
        r"""Search for products, customers and orders.
        Type can be \\"order\\", \\"product\\" and / or \\"customer\\"
        Term can contains lucene query syntax
        """
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/api/v1/search'
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request", 'raw')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = self._client
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.SearchSearchRawResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.RechnungsdruckWebAppControllersAPIAPIResultRechnungsdruckWebAppControllersAPISearchControllerSearchResultsModel])
                res.rechnungsdruck_web_app_controllers_api_api_result_rechnungsdruck_web_app_controllers_api_search_controller_search_results_model = out
            if utils.match_content_type(content_type, 'text/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.RechnungsdruckWebAppControllersAPIAPIResultRechnungsdruckWebAppControllersAPISearchControllerSearchResultsModel])
                res.rechnungsdruck_web_app_controllers_api_api_result_rechnungsdruck_web_app_controllers_api_search_controller_search_results_model = out
            if utils.match_content_type(content_type, 'application/xml'):
                res.body = http_res.content
            if utils.match_content_type(content_type, 'text/xml'):
                res.body = http_res.content

        return res

    