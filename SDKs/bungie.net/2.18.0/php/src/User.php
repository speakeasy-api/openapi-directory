<?php

/**
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

declare(strict_types=1);

namespace OpenAPI\OpenAPI;

class User 
{

	// SDK private variables namespaced with _ to avoid conflicts with API models
	private \GuzzleHttp\ClientInterface $_defaultClient;
	private \GuzzleHttp\ClientInterface $_securityClient;
	private string $_serverUrl;
	private string $_language;
	private string $_sdkVersion;
	private string $_genVersion;	

	/**
	 * @param \GuzzleHttp\ClientInterface $defaultClient
	 * @param \GuzzleHttp\ClientInterface $securityClient
	 * @param string $serverUrl
	 * @param string $language
	 * @param string $sdkVersion
	 * @param string $genVersion
	 */
	public function __construct(\GuzzleHttp\ClientInterface $defaultClient, \GuzzleHttp\ClientInterface $securityClient, string $serverUrl, string $language, string $sdkVersion, string $genVersion)
	{
		$this->_defaultClient = $defaultClient;
		$this->_securityClient = $securityClient;
		$this->_serverUrl = $serverUrl;
		$this->_language = $language;
		$this->_sdkVersion = $sdkVersion;
		$this->_genVersion = $genVersion;
	}
	
    /**
     * Returns a list of all available user themes.
     * 
     * @return \OpenAPI\OpenAPI\Models\Operations\UserGetAvailableThemesResponse
     */
	public function userGetAvailableThemes(
    ): \OpenAPI\OpenAPI\Models\Operations\UserGetAvailableThemesResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/User/GetAvailableThemes/');
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_defaultClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\UserGetAvailableThemesResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, '*/*')) {
                $response->body = $httpResponse->getBody()->getContents();
            }
        }

        return $response;
    }
	
    /**
     * Loads a bungienet user by membership id.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\UserGetBungieNetUserByIdRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\UserGetBungieNetUserByIdResponse
     */
	public function userGetBungieNetUserById(
        \OpenAPI\OpenAPI\Models\Operations\UserGetBungieNetUserByIdRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\UserGetBungieNetUserByIdResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/User/GetBungieNetUserById/{id}/', \OpenAPI\OpenAPI\Models\Operations\UserGetBungieNetUserByIdRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_defaultClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\UserGetBungieNetUserByIdResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, '*/*')) {
                $response->body = $httpResponse->getBody()->getContents();
            }
        }

        return $response;
    }
	
    /**
     * Returns a list of credential types attached to the requested account
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\UserGetCredentialTypesForTargetAccountRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\UserGetCredentialTypesForTargetAccountResponse
     */
	public function userGetCredentialTypesForTargetAccount(
        \OpenAPI\OpenAPI\Models\Operations\UserGetCredentialTypesForTargetAccountRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\UserGetCredentialTypesForTargetAccountResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/User/GetCredentialTypesForTargetAccount/{membershipId}/', \OpenAPI\OpenAPI\Models\Operations\UserGetCredentialTypesForTargetAccountRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_defaultClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\UserGetCredentialTypesForTargetAccountResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, '*/*')) {
                $response->body = $httpResponse->getBody()->getContents();
            }
        }

        return $response;
    }
	
    /**
     * Returns a list of accounts associated with the supplied membership ID and membership type. This will include all linked accounts (even when hidden) if supplied credentials permit it.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\UserGetMembershipDataByIdRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\UserGetMembershipDataByIdResponse
     */
	public function userGetMembershipDataById(
        \OpenAPI\OpenAPI\Models\Operations\UserGetMembershipDataByIdRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\UserGetMembershipDataByIdResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/User/GetMembershipsById/{membershipId}/{membershipType}/', \OpenAPI\OpenAPI\Models\Operations\UserGetMembershipDataByIdRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_defaultClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\UserGetMembershipDataByIdResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, '*/*')) {
                $response->body = $httpResponse->getBody()->getContents();
            }
        }

        return $response;
    }
	
    /**
     * Returns a list of accounts associated with signed in user. This is useful for OAuth implementations that do not give you access to the token response.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\UserGetMembershipDataForCurrentUserSecurity $security
     * @return \OpenAPI\OpenAPI\Models\Operations\UserGetMembershipDataForCurrentUserResponse
     */
	public function userGetMembershipDataForCurrentUser(
        \OpenAPI\OpenAPI\Models\Operations\UserGetMembershipDataForCurrentUserSecurity $security,
    ): \OpenAPI\OpenAPI\Models\Operations\UserGetMembershipDataForCurrentUserResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/User/GetMembershipsForCurrentUser/');
        
        $options = ['http_errors' => false];
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\UserGetMembershipDataForCurrentUserResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, '*/*')) {
                $response->body = $httpResponse->getBody()->getContents();
            }
        }

        return $response;
    }
	
    /**
     * Gets any hard linked membership given a credential. Only works for credentials that are public (just SteamID64 right now). Cross Save aware.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\UserGetMembershipFromHardLinkedCredentialRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\UserGetMembershipFromHardLinkedCredentialResponse
     */
	public function userGetMembershipFromHardLinkedCredential(
        \OpenAPI\OpenAPI\Models\Operations\UserGetMembershipFromHardLinkedCredentialRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\UserGetMembershipFromHardLinkedCredentialResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/User/GetMembershipFromHardLinkedCredential/{crType}/{credential}/', \OpenAPI\OpenAPI\Models\Operations\UserGetMembershipFromHardLinkedCredentialRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_defaultClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\UserGetMembershipFromHardLinkedCredentialResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, '*/*')) {
                $response->body = $httpResponse->getBody()->getContents();
            }
        }

        return $response;
    }
	
    /**
     * Gets a list of all display names linked to this membership id but sanitized (profanity filtered). Obeys all visibility rules of calling user and is heavily cached.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\UserGetSanitizedPlatformDisplayNamesRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\UserGetSanitizedPlatformDisplayNamesResponse
     */
	public function userGetSanitizedPlatformDisplayNames(
        \OpenAPI\OpenAPI\Models\Operations\UserGetSanitizedPlatformDisplayNamesRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\UserGetSanitizedPlatformDisplayNamesResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/User/GetSanitizedPlatformDisplayNames/{membershipId}/', \OpenAPI\OpenAPI\Models\Operations\UserGetSanitizedPlatformDisplayNamesRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_defaultClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\UserGetSanitizedPlatformDisplayNamesResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, '*/*')) {
                $response->body = $httpResponse->getBody()->getContents();
            }
        }

        return $response;
    }
	
    /**
     * Given the prefix of a global display name, returns all users who share that name.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\UserSearchByGlobalNamePostRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\UserSearchByGlobalNamePostResponse
     */
	public function userSearchByGlobalNamePost(
        \OpenAPI\OpenAPI\Models\Operations\UserSearchByGlobalNamePostRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\UserSearchByGlobalNamePostResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/User/Search/GlobalName/{page}/', \OpenAPI\OpenAPI\Models\Operations\UserSearchByGlobalNamePostRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_defaultClient->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\UserSearchByGlobalNamePostResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, '*/*')) {
                $response->body = $httpResponse->getBody()->getContents();
            }
        }

        return $response;
    }
	
    /**
     * [OBSOLETE] Do not use this to search users, use SearchByGlobalNamePost instead.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\UserSearchByGlobalNamePrefixRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\UserSearchByGlobalNamePrefixResponse
     */
	public function userSearchByGlobalNamePrefix(
        \OpenAPI\OpenAPI\Models\Operations\UserSearchByGlobalNamePrefixRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\UserSearchByGlobalNamePrefixResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/User/Search/Prefix/{displayNamePrefix}/{page}/', \OpenAPI\OpenAPI\Models\Operations\UserSearchByGlobalNamePrefixRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_defaultClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\UserSearchByGlobalNamePrefixResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, '*/*')) {
                $response->body = $httpResponse->getBody()->getContents();
            }
        }

        return $response;
    }
}