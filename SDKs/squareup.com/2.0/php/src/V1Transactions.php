<?php

/**
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

declare(strict_types=1);

namespace OpenAPI\OpenAPI;

class V1Transactions 
{

	// SDK private variables namespaced with _ to avoid conflicts with API models
	private \GuzzleHttp\ClientInterface $_defaultClient;
	private \GuzzleHttp\ClientInterface $_securityClient;
	private string $_serverUrl;
	private string $_language;
	private string $_sdkVersion;
	private string $_genVersion;	

	/**
	 * @param \GuzzleHttp\ClientInterface $defaultClient
	 * @param \GuzzleHttp\ClientInterface $securityClient
	 * @param string $serverUrl
	 * @param string $language
	 * @param string $sdkVersion
	 * @param string $genVersion
	 */
	public function __construct(\GuzzleHttp\ClientInterface $defaultClient, \GuzzleHttp\ClientInterface $securityClient, string $serverUrl, string $language, string $sdkVersion, string $genVersion)
	{
		$this->_defaultClient = $defaultClient;
		$this->_securityClient = $securityClient;
		$this->_serverUrl = $serverUrl;
		$this->_language = $language;
		$this->_sdkVersion = $sdkVersion;
		$this->_genVersion = $genVersion;
	}
	
    /**
     * CreateRefund
     * 
     * Issues a refund for a previously processed payment. You must issue
     * a refund within 60 days of the associated payment.
     * 
     * You cannot issue a partial refund for a split tender payment. You must
     * instead issue a full or partial refund for a particular tender, by
     * providing the applicable tender id to the V1CreateRefund endpoint.
     * Issuing a full refund for a split tender payment refunds all tenders
     * associated with the payment.
     * 
     * Issuing a refund for a card payment is not reversible. For development
     * purposes, you can create fake cash payments in Square Point of Sale and
     * refund them.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\CreateRefundRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\CreateRefundSecurity $security
     * @return \OpenAPI\OpenAPI\Models\Operations\CreateRefundResponse
     */
	public function createRefund(
        \OpenAPI\OpenAPI\Models\Operations\CreateRefundRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\CreateRefundSecurity $security,
    ): \OpenAPI\OpenAPI\Models\Operations\CreateRefundResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v1/{location_id}/refunds', \OpenAPI\OpenAPI\Models\Operations\CreateRefundRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "v1CreateRefundRequest", "json");
        if ($body === null) {
            throw new \Exception('Request body is required');
        }
        $options = array_merge_recursive($options, $body);
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\CreateRefundResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->v1Refund = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\V1Refund', 'json');
            }
        }

        return $response;
    }
	
    /**
     * ListOrders
     * 
     * Provides summary information for a merchant's online store orders.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\ListOrdersRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\ListOrdersSecurity $security
     * @return \OpenAPI\OpenAPI\Models\Operations\ListOrdersResponse
     */
	public function listOrders(
        \OpenAPI\OpenAPI\Models\Operations\ListOrdersRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\ListOrdersSecurity $security,
    ): \OpenAPI\OpenAPI\Models\Operations\ListOrdersResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v1/{location_id}/orders', \OpenAPI\OpenAPI\Models\Operations\ListOrdersRequest::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\ListOrdersRequest::class, $request, null));
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\ListOrdersResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->v1Orders = $serializer->deserialize((string)$httpResponse->getBody(), 'array<OpenAPI\OpenAPI\Models\Shared\V1Order>', 'json');
            }
        }

        return $response;
    }
	
    /**
     * ListPayments
     * 
     * Provides summary information for all payments taken for a given
     * Square account during a date range. Date ranges cannot exceed 1 year in
     * length. See Date ranges for details of inclusive and exclusive dates.
     * 
     * *Note**: Details for payments processed with Square Point of Sale while
     * in offline mode may not be transmitted to Square for up to 72 hours.
     * Offline payments have a `created_at` value that reflects the time the
     * payment was originally processed, not the time it was subsequently
     * transmitted to Square. Consequently, the ListPayments endpoint might
     * list an offline payment chronologically between online payments that
     * were seen in a previous request.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\ListPaymentsRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\ListPaymentsSecurity $security
     * @return \OpenAPI\OpenAPI\Models\Operations\ListPaymentsResponse
     */
	public function listPayments(
        \OpenAPI\OpenAPI\Models\Operations\ListPaymentsRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\ListPaymentsSecurity $security,
    ): \OpenAPI\OpenAPI\Models\Operations\ListPaymentsResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v1/{location_id}/payments', \OpenAPI\OpenAPI\Models\Operations\ListPaymentsRequest::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\ListPaymentsRequest::class, $request, null));
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\ListPaymentsResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->v1Payments = $serializer->deserialize((string)$httpResponse->getBody(), 'array<OpenAPI\OpenAPI\Models\Shared\V1Payment>', 'json');
            }
        }

        return $response;
    }
	
    /**
     * ListRefunds
     * 
     * Provides the details for all refunds initiated by a merchant or any of the merchant's mobile staff during a date range. Date ranges cannot exceed one year in length.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\ListRefundsRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\ListRefundsSecurity $security
     * @return \OpenAPI\OpenAPI\Models\Operations\ListRefundsResponse
     */
	public function listRefunds(
        \OpenAPI\OpenAPI\Models\Operations\ListRefundsRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\ListRefundsSecurity $security,
    ): \OpenAPI\OpenAPI\Models\Operations\ListRefundsResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v1/{location_id}/refunds', \OpenAPI\OpenAPI\Models\Operations\ListRefundsRequest::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\ListRefundsRequest::class, $request, null));
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\ListRefundsResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->v1Refunds = $serializer->deserialize((string)$httpResponse->getBody(), 'array<OpenAPI\OpenAPI\Models\Shared\V1Refund>', 'json');
            }
        }

        return $response;
    }
	
    /**
     * ListSettlements
     * 
     * Provides summary information for all deposits and withdrawals
     * initiated by Square to a linked bank account during a date range. Date
     * ranges cannot exceed one year in length.
     * 
     * *Note**: the ListSettlements endpoint does not provide entry
     * information.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\ListSettlementsRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\ListSettlementsSecurity $security
     * @return \OpenAPI\OpenAPI\Models\Operations\ListSettlementsResponse
     */
	public function listSettlements(
        \OpenAPI\OpenAPI\Models\Operations\ListSettlementsRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\ListSettlementsSecurity $security,
    ): \OpenAPI\OpenAPI\Models\Operations\ListSettlementsResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v1/{location_id}/settlements', \OpenAPI\OpenAPI\Models\Operations\ListSettlementsRequest::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\ListSettlementsRequest::class, $request, null));
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\ListSettlementsResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->v1Settlements = $serializer->deserialize((string)$httpResponse->getBody(), 'array<OpenAPI\OpenAPI\Models\Shared\V1Settlement>', 'json');
            }
        }

        return $response;
    }
	
    /**
     * RetrieveOrder
     * 
     * Provides comprehensive information for a single online store order, including the order's history.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\RetrieveOrderRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\RetrieveOrderSecurity $security
     * @return \OpenAPI\OpenAPI\Models\Operations\RetrieveOrderResponse
     */
	public function retrieveOrder(
        \OpenAPI\OpenAPI\Models\Operations\RetrieveOrderRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\RetrieveOrderSecurity $security,
    ): \OpenAPI\OpenAPI\Models\Operations\RetrieveOrderResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v1/{location_id}/orders/{order_id}', \OpenAPI\OpenAPI\Models\Operations\RetrieveOrderRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\RetrieveOrderResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->v1Order = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\V1Order', 'json');
            }
        }

        return $response;
    }
	
    /**
     * RetrievePayment
     * 
     * Provides comprehensive information for a single payment.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\RetrievePaymentRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\RetrievePaymentSecurity $security
     * @return \OpenAPI\OpenAPI\Models\Operations\RetrievePaymentResponse
     */
	public function retrievePayment(
        \OpenAPI\OpenAPI\Models\Operations\RetrievePaymentRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\RetrievePaymentSecurity $security,
    ): \OpenAPI\OpenAPI\Models\Operations\RetrievePaymentResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v1/{location_id}/payments/{payment_id}', \OpenAPI\OpenAPI\Models\Operations\RetrievePaymentRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\RetrievePaymentResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->v1Payment = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\V1Payment', 'json');
            }
        }

        return $response;
    }
	
    /**
     * RetrieveSettlement
     * 
     * Provides comprehensive information for a single settlement.
     * 
     * The returned `Settlement` objects include an `entries` field that lists
     * the transactions that contribute to the settlement total. Most
     * settlement entries correspond to a payment payout, but settlement
     * entries are also generated for less common events, like refunds, manual
     * adjustments, or chargeback holds.
     * 
     * Square initiates its regular deposits as indicated in the
     * [Deposit Options with Square](https://squareup.com/help/us/en/article/3807)
     * help article. Details for a regular deposit are usually not available
     * from Connect API endpoints before 10 p.m. PST the same day.
     * 
     * Square does not know when an initiated settlement **completes**, only
     * whether it has failed. A completed settlement is typically reflected in
     * a bank account within 3 business days, but in exceptional cases it may
     * take longer.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\RetrieveSettlementRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\RetrieveSettlementSecurity $security
     * @return \OpenAPI\OpenAPI\Models\Operations\RetrieveSettlementResponse
     */
	public function retrieveSettlement(
        \OpenAPI\OpenAPI\Models\Operations\RetrieveSettlementRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\RetrieveSettlementSecurity $security,
    ): \OpenAPI\OpenAPI\Models\Operations\RetrieveSettlementResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v1/{location_id}/settlements/{settlement_id}', \OpenAPI\OpenAPI\Models\Operations\RetrieveSettlementRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\RetrieveSettlementResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->v1Settlement = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\V1Settlement', 'json');
            }
        }

        return $response;
    }
	
    /**
     * UpdateOrder
     * 
     * Updates the details of an online store order. Every update you perform on an order corresponds to one of three actions:
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\UpdateOrderRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\UpdateOrderSecurity $security
     * @return \OpenAPI\OpenAPI\Models\Operations\UpdateOrderResponse
     */
	public function updateOrder(
        \OpenAPI\OpenAPI\Models\Operations\UpdateOrderRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\UpdateOrderSecurity $security,
    ): \OpenAPI\OpenAPI\Models\Operations\UpdateOrderResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v1/{location_id}/orders/{order_id}', \OpenAPI\OpenAPI\Models\Operations\UpdateOrderRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "v1UpdateOrderRequest", "json");
        if ($body === null) {
            throw new \Exception('Request body is required');
        }
        $options = array_merge_recursive($options, $body);
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('PUT', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\UpdateOrderResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->v1Order = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\V1Order', 'json');
            }
        }

        return $response;
    }
}