"""Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT."""

from __future__ import annotations
import dataclasses
from dataclasses_json import Undefined, dataclass_json
from sdk import utils
from typing import Optional


@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class IssueTokenRequestFlags:
    r"""Object representing flags that potentialy modify this transaction"""
    
    split_change: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('splitChange'), 'exclude': lambda f: f is None }})
    r"""If true change will be split into 2 outputs, one for NEBL change and one for NTP1 change (recommended)"""  
    

@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class IssueTokenRequestMetadataEncryptions:
    
    format: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('format'), 'exclude': lambda f: f is None }})
    r"""key format (pem or der)"""  
    key: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('key'), 'exclude': lambda f: f is None }})
    r"""userData key to encrypt"""  
    pubkey: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('pubkey'), 'exclude': lambda f: f is None }})
    r"""RSA public key used for encryption"""  
    type: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('type'), 'exclude': lambda f: f is None }})
    r"""pkcs1 or pkcs8"""  
    

@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class IssueTokenRequestMetadataRulesExpiration:
    r"""Object describing expiration rules of the token"""
    
    locked: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('locked'), 'exclude': lambda f: f is None }})
    r"""Whether this rule can be modified in future transactions"""  
    valid_until: Optional[float] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('validUntil'), 'exclude': lambda f: f is None }})
    r"""Blockheight at wh"""  
    

@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class IssueTokenRequestMetadataRulesFeesItems:
    
    address: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('address'), 'exclude': lambda f: f is None }})
    r"""Address fee is auto sent to"""  
    token_id: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('tokenId'), 'exclude': lambda f: f is None }})
    r"""How fee should be paid, either with a tokenId, or with NEBL if null"""  
    value: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('value'), 'exclude': lambda f: f is None }})
    r"""Amount of NTP1 token, or NEBL (in satoshi) to pay as fee"""  
    

@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class IssueTokenRequestMetadataRulesFees:
    
    items: Optional[list[IssueTokenRequestMetadataRulesFeesItems]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('items'), 'exclude': lambda f: f is None }})
    r"""Array of objects describing fee rules"""  
    locked: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('locked'), 'exclude': lambda f: f is None }})
    r"""Whether this rule can be modified in future transactions"""  
    

@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class IssueTokenRequestMetadataRulesHolders:
    
    address: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('address'), 'exclude': lambda f: f is None }})
    r"""Address that can hold the token"""  
    locked: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('locked'), 'exclude': lambda f: f is None }})
    r"""Whether this rule can be modified in future transactions"""  
    

@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class IssueTokenRequestMetadataRules:
    r"""Object describing token rules"""
    
    expiration: Optional[IssueTokenRequestMetadataRulesExpiration] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('expiration'), 'exclude': lambda f: f is None }})
    r"""Object describing expiration rules of the token"""  
    fees: Optional[IssueTokenRequestMetadataRulesFees] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('fees'), 'exclude': lambda f: f is None }})  
    holders: Optional[list[IssueTokenRequestMetadataRulesHolders]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('holders'), 'exclude': lambda f: f is None }})
    r"""Array of objects describing what addresses can hold the token"""  
    

@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class IssueTokenRequestMetadataUrls:
    
    data_hash: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('dataHash'), 'exclude': lambda f: f is None }})
    r"""Hash of data at the URL, used for verification"""  
    mime_type: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('mimeType'), 'exclude': lambda f: f is None }})
    r"""mimeType of URL content"""  
    name: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('name'), 'exclude': lambda f: f is None }})
    r"""Name of the URL"""  
    url: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('url'), 'exclude': lambda f: f is None }})
    r"""Actual URL"""  
    

@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class IssueTokenRequestMetadataUserDataMeta:
    
    key: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('key'), 'exclude': lambda f: f is None }})  
    value: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('value'), 'exclude': lambda f: f is None }})  
    

@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class IssueTokenRequestMetadataUserData:
    r"""Metadata set by user on token"""
    
    meta: Optional[list[IssueTokenRequestMetadataUserDataMeta]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('meta'), 'exclude': lambda f: f is None }})  
    

@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class IssueTokenRequestMetadata:
    r"""Object representing all metadata at token issuance"""
    
    description: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('description'), 'exclude': lambda f: f is None }})
    r"""Long name or description of token (ex. Nibble)"""  
    encryptions: Optional[list[IssueTokenRequestMetadataEncryptions]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('encryptions'), 'exclude': lambda f: f is None }})
    r"""Array of encryption instruction objects for encrypting userData"""  
    issuer: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('issuer'), 'exclude': lambda f: f is None }})
    r"""Name of token issuer"""  
    rules: Optional[IssueTokenRequestMetadataRules] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('rules'), 'exclude': lambda f: f is None }})
    r"""Object describing token rules"""  
    token_name: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('tokenName'), 'exclude': lambda f: f is None }})
    r"""Token Symbol it will be identified by (ex. NIBBL)"""  
    urls: Optional[list[IssueTokenRequestMetadataUrls]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('urls'), 'exclude': lambda f: f is None }})  
    user_data: Optional[IssueTokenRequestMetadataUserData] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('userData'), 'exclude': lambda f: f is None }})
    r"""Metadata set by user on token"""  
    

@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class IssueTokenRequestTransfer:
    
    address: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('address'), 'exclude': lambda f: f is None }})
    r"""Address to send the amount of issued tokens to"""  
    amount: Optional[float] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('amount'), 'exclude': lambda f: f is None }})  
    

@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class IssueTokenRequest:
    r"""Object representing the token to be created"""
    
    amount: float = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('amount') }})
    r"""Number of tokens to issue"""  
    divisibility: float = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('divisibility') }})
    r"""Number of decimal places the token should be divisble by (0-7)"""  
    fee: float = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('fee') }})
    r"""Fee in satoshi to include in the issuance transaction min 1000000000 (10 NEBL)"""  
    issue_address: str = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('issueAddress') }})
    r"""Address issuing the token"""  
    reissuable: bool = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('reissuable') }})
    r"""whether the token should be reissuable"""  
    transfer: list[IssueTokenRequestTransfer] = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('transfer') }})  
    flags: Optional[IssueTokenRequestFlags] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('flags'), 'exclude': lambda f: f is None }})
    r"""Object representing flags that potentialy modify this transaction"""  
    metadata: Optional[IssueTokenRequestMetadata] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('metadata'), 'exclude': lambda f: f is None }})
    r"""Object representing all metadata at token issuance"""  
    