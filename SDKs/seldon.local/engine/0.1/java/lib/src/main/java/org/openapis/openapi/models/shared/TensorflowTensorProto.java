/* 
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

package org.openapis.openapi.models.shared;

import com.fasterxml.jackson.annotation.JsonInclude.Include;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;

/**
 * TensorflowTensorProto - Protocol buffer representing a tensor.
 */
public class TensorflowTensorProto {
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("bool_val")
    public Boolean[] boolVal;

    public TensorflowTensorProto withBoolVal(Boolean[] boolVal) {
        this.boolVal = boolVal;
        return this;
    }
    
    /**
     * DT_COMPLEX128. dcomplex_val(2*i) and dcomplex_val(2*i+1) are real and imaginary parts of i-th double precision complex.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("dcomplex_val")
    public Double[] dcomplexVal;

    public TensorflowTensorProto withDcomplexVal(Double[] dcomplexVal) {
        this.dcomplexVal = dcomplexVal;
        return this;
    }
    
    /**
     * DT_DOUBLE.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("double_val")
    public Double[] doubleVal;

    public TensorflowTensorProto withDoubleVal(Double[] doubleVal) {
        this.doubleVal = doubleVal;
        return this;
    }
    
    /**
     * - DT_INVALID: Not a legal value for DataType.  Used to indicate a DataType field has not been set. - DT_FLOAT: Data types that all computation devices are expected to be capable to support. - DT_FLOAT_REF: Do not use!  These are only for parameters.  Every enum above should have a corresponding value below (verified by types_test).
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("dtype")
    public TensorflowDataTypeEnum dtype;

    public TensorflowTensorProto withDtype(TensorflowDataTypeEnum dtype) {
        this.dtype = dtype;
        return this;
    }
    
    /**
     * DT_FLOAT.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("float_val")
    public Float[] floatVal;

    public TensorflowTensorProto withFloatVal(Float[] floatVal) {
        this.floatVal = floatVal;
        return this;
    }
    
    /**
     * DT_HALF, DT_BFLOAT16. Note that since protobuf has no int16 type, we'll have some pointless zero padding for each value here.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("half_val")
    public Integer[] halfVal;

    public TensorflowTensorProto withHalfVal(Integer[] halfVal) {
        this.halfVal = halfVal;
        return this;
    }
    
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("int64_val")
    public String[] int64Val;

    public TensorflowTensorProto withInt64Val(String[] int64Val) {
        this.int64Val = int64Val;
        return this;
    }
    
    /**
     * DT_INT32, DT_INT16, DT_INT8, DT_UINT8.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("int_val")
    public Integer[] intVal;

    public TensorflowTensorProto withIntVal(Integer[] intVal) {
        this.intVal = intVal;
        return this;
    }
    
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("resource_handle_val")
    public TensorflowResourceHandleProto[] resourceHandleVal;

    public TensorflowTensorProto withResourceHandleVal(TensorflowResourceHandleProto[] resourceHandleVal) {
        this.resourceHandleVal = resourceHandleVal;
        return this;
    }
    
    /**
     * DT_COMPLEX64. scomplex_val(2*i) and scomplex_val(2*i+1) are real and imaginary parts of i-th single precision complex.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("scomplex_val")
    public Float[] scomplexVal;

    public TensorflowTensorProto withScomplexVal(Float[] scomplexVal) {
        this.scomplexVal = scomplexVal;
        return this;
    }
    
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("string_val")
    public String[] stringVal;

    public TensorflowTensorProto withStringVal(String[] stringVal) {
        this.stringVal = stringVal;
        return this;
    }
    
    /**
     * Serialized raw tensor content from either Tensor::AsProtoTensorContent or memcpy in tensorflow::grpc::EncodeTensorToByteBuffer. This representation can be used for all tensor types. The purpose of this representation is to reduce serialization overhead during RPC call by avoiding serialization of many repeated small items.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("tensor_content")
    public String tensorContent;

    public TensorflowTensorProto withTensorContent(String tensorContent) {
        this.tensorContent = tensorContent;
        return this;
    }
    
    /**
     * Dimensions of a tensor.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("tensor_shape")
    public TensorflowTensorShapeProto tensorShape;

    public TensorflowTensorProto withTensorShape(TensorflowTensorShapeProto tensorShape) {
        this.tensorShape = tensorShape;
        return this;
    }
    
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("uint32_val")
    public Long[] uint32Val;

    public TensorflowTensorProto withUint32Val(Long[] uint32Val) {
        this.uint32Val = uint32Val;
        return this;
    }
    
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("uint64_val")
    public String[] uint64Val;

    public TensorflowTensorProto withUint64Val(String[] uint64Val) {
        this.uint64Val = uint64Val;
        return this;
    }
    
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("variant_val")
    public TensorflowVariantTensorDataProto[] variantVal;

    public TensorflowTensorProto withVariantVal(TensorflowVariantTensorDataProto[] variantVal) {
        this.variantVal = variantVal;
        return this;
    }
    
    /**
     * Version number.
     * In version 0, if the "repeated xxx" representations contain only one element, that element is repeated to fill the shape.  This makes it easy to represent a constant Tensor with a single value.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("version_number")
    public Integer versionNumber;

    public TensorflowTensorProto withVersionNumber(Integer versionNumber) {
        this.versionNumber = versionNumber;
        return this;
    }
    
    public TensorflowTensorProto(){}
}
