"""Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT."""

import requests as requests_http
from . import utils
from sdk.models import operations, shared
from typing import Optional

SERVERS = [
    "https://verify.twilio.com",
]
"""Contains the list of servers available to the SDK"""

class SDK:
    r"""This is the public Twilio REST API."""

    _client: requests_http.Session
    _security_client: requests_http.Session
    _server_url: str = SERVERS[0]
    _language: str = "python"
    _sdk_version: str = "0.0.1"
    _gen_version: str = "internal"

    def __init__(self,
                 server_url: str = None,
                 url_params: dict[str, str] = None,
                 client: requests_http.Session = None
                 ) -> None:
        """Instantiates the SDK configuring it with the provided parameters.
        
        :param server_url: The server URL to use for all operations
        :type server_url: str
        :param url_params: Parameters to optionally template the server URL with
        :type url_params: dict[str, str]
        :param client: The requests.Session HTTP client to use for all operations
        :type client: requests_http.Session        
        """
        self._client = requests_http.Session()
        
        
        if server_url is not None:
            if url_params is not None:
                self._server_url = utils.template_url(server_url, url_params)
            else:
                self._server_url = server_url

        if client is not None:
            self._client = client
        
        self._security_client = self._client
        

        
    
    
    def create_access_token(self, request: operations.CreateAccessTokenRequest, security: operations.CreateAccessTokenSecurity, server_url: Optional[str] = None) -> operations.CreateAccessTokenResponse:
        r"""Create a new enrollment Access Token for the Entity"""
        base_url = operations.CREATE_ACCESS_TOKEN_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.CreateAccessTokenRequest, base_url, '/v2/Services/{ServiceSid}/AccessTokens', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'form')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.CreateAccessTokenResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 201:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.VerifyV2ServiceAccessToken])
                res.verify_v2_service_access_token = out

        return res

    def create_bucket(self, request: operations.CreateBucketRequest, security: operations.CreateBucketSecurity, server_url: Optional[str] = None) -> operations.CreateBucketResponse:
        r"""Create a new Bucket for a Rate Limit"""
        base_url = operations.CREATE_BUCKET_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.CreateBucketRequest, base_url, '/v2/Services/{ServiceSid}/RateLimits/{RateLimitSid}/Buckets', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'form')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.CreateBucketResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 201:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.VerifyV2ServiceRateLimitBucket])
                res.verify_v2_service_rate_limit_bucket = out

        return res

    def create_challenge(self, request: operations.CreateChallengeRequest, security: operations.CreateChallengeSecurity, server_url: Optional[str] = None) -> operations.CreateChallengeResponse:
        r"""Create a new Challenge for the Factor"""
        base_url = operations.CREATE_CHALLENGE_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.CreateChallengeRequest, base_url, '/v2/Services/{ServiceSid}/Entities/{Identity}/Challenges', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'form')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.CreateChallengeResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 201:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.VerifyV2ServiceEntityChallenge])
                res.verify_v2_service_entity_challenge = out

        return res

    def create_entity(self, request: operations.CreateEntityRequest, security: operations.CreateEntitySecurity, server_url: Optional[str] = None) -> operations.CreateEntityResponse:
        r"""Create a new Entity for the Service"""
        base_url = operations.CREATE_ENTITY_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.CreateEntityRequest, base_url, '/v2/Services/{ServiceSid}/Entities', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'form')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.CreateEntityResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 201:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.VerifyV2ServiceEntity])
                res.verify_v2_service_entity = out

        return res

    def create_messaging_configuration(self, request: operations.CreateMessagingConfigurationRequest, security: operations.CreateMessagingConfigurationSecurity, server_url: Optional[str] = None) -> operations.CreateMessagingConfigurationResponse:
        r"""Create a new MessagingConfiguration for a service."""
        base_url = operations.CREATE_MESSAGING_CONFIGURATION_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.CreateMessagingConfigurationRequest, base_url, '/v2/Services/{ServiceSid}/MessagingConfigurations', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'form')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.CreateMessagingConfigurationResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 201:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.VerifyV2ServiceMessagingConfiguration])
                res.verify_v2_service_messaging_configuration = out

        return res

    def create_new_factor(self, request: operations.CreateNewFactorRequest, security: operations.CreateNewFactorSecurity, server_url: Optional[str] = None) -> operations.CreateNewFactorResponse:
        r"""Create a new Factor for the Entity"""
        base_url = operations.CREATE_NEW_FACTOR_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.CreateNewFactorRequest, base_url, '/v2/Services/{ServiceSid}/Entities/{Identity}/Factors', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'form')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.CreateNewFactorResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 201:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.VerifyV2ServiceEntityNewFactor])
                res.verify_v2_service_entity_new_factor = out

        return res

    def create_notification(self, request: operations.CreateNotificationRequest, security: operations.CreateNotificationSecurity, server_url: Optional[str] = None) -> operations.CreateNotificationResponse:
        r"""Create a new Notification for the corresponding Challenge"""
        base_url = operations.CREATE_NOTIFICATION_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.CreateNotificationRequest, base_url, '/v2/Services/{ServiceSid}/Entities/{Identity}/Challenges/{ChallengeSid}/Notifications', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'form')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.CreateNotificationResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 201:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.VerifyV2ServiceEntityChallengeNotification])
                res.verify_v2_service_entity_challenge_notification = out

        return res

    def create_rate_limit(self, request: operations.CreateRateLimitRequest, security: operations.CreateRateLimitSecurity, server_url: Optional[str] = None) -> operations.CreateRateLimitResponse:
        r"""Create a new Rate Limit for a Service"""
        base_url = operations.CREATE_RATE_LIMIT_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.CreateRateLimitRequest, base_url, '/v2/Services/{ServiceSid}/RateLimits', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'form')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.CreateRateLimitResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 201:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.VerifyV2ServiceRateLimit])
                res.verify_v2_service_rate_limit = out

        return res

    def create_safelist(self, request: operations.CreateSafelistCreateSafelistRequest, security: operations.CreateSafelistSecurity, server_url: Optional[str] = None) -> operations.CreateSafelistResponse:
        r"""Add a new phone number to SafeList."""
        base_url = operations.CREATE_SAFELIST_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = base_url.removesuffix('/') + '/v2/SafeList/Numbers'
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request", 'form')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.CreateSafelistResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 201:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.VerifyV2Safelist])
                res.verify_v2_safelist = out

        return res

    def create_service(self, request: operations.CreateServiceCreateServiceRequest, security: operations.CreateServiceSecurity, server_url: Optional[str] = None) -> operations.CreateServiceResponse:
        r"""Create a new Verification Service."""
        base_url = operations.CREATE_SERVICE_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = base_url.removesuffix('/') + '/v2/Services'
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request", 'form')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.CreateServiceResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 201:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.VerifyV2Service])
                res.verify_v2_service = out

        return res

    def create_verification(self, request: operations.CreateVerificationRequest, security: operations.CreateVerificationSecurity, server_url: Optional[str] = None) -> operations.CreateVerificationResponse:
        r"""Create a new Verification using a Service"""
        base_url = operations.CREATE_VERIFICATION_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.CreateVerificationRequest, base_url, '/v2/Services/{ServiceSid}/Verifications', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'form')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.CreateVerificationResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 201:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.VerifyV2ServiceVerification])
                res.verify_v2_service_verification = out

        return res

    def create_verification_check(self, request: operations.CreateVerificationCheckRequest, security: operations.CreateVerificationCheckSecurity, server_url: Optional[str] = None) -> operations.CreateVerificationCheckResponse:
        r"""challenge a specific Verification Check."""
        base_url = operations.CREATE_VERIFICATION_CHECK_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.CreateVerificationCheckRequest, base_url, '/v2/Services/{ServiceSid}/VerificationCheck', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'form')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.CreateVerificationCheckResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 201:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.VerifyV2ServiceVerificationCheck])
                res.verify_v2_service_verification_check = out

        return res

    def create_webhook(self, request: operations.CreateWebhookRequest, security: operations.CreateWebhookSecurity, server_url: Optional[str] = None) -> operations.CreateWebhookResponse:
        r"""Create a new Webhook for the Service"""
        base_url = operations.CREATE_WEBHOOK_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.CreateWebhookRequest, base_url, '/v2/Services/{ServiceSid}/Webhooks', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'form')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.CreateWebhookResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 201:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.VerifyV2ServiceWebhook])
                res.verify_v2_service_webhook = out

        return res

    def delete_bucket(self, request: operations.DeleteBucketRequest, security: operations.DeleteBucketSecurity, server_url: Optional[str] = None) -> operations.DeleteBucketResponse:
        r"""Delete a specific Bucket."""
        base_url = operations.DELETE_BUCKET_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.DeleteBucketRequest, base_url, '/v2/Services/{ServiceSid}/RateLimits/{RateLimitSid}/Buckets/{Sid}', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('DELETE', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DeleteBucketResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        

        return res

    def delete_entity(self, request: operations.DeleteEntityRequest, security: operations.DeleteEntitySecurity, server_url: Optional[str] = None) -> operations.DeleteEntityResponse:
        r"""Delete a specific Entity."""
        base_url = operations.DELETE_ENTITY_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.DeleteEntityRequest, base_url, '/v2/Services/{ServiceSid}/Entities/{Identity}', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('DELETE', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DeleteEntityResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        

        return res

    def delete_factor(self, request: operations.DeleteFactorRequest, security: operations.DeleteFactorSecurity, server_url: Optional[str] = None) -> operations.DeleteFactorResponse:
        r"""Delete a specific Factor."""
        base_url = operations.DELETE_FACTOR_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.DeleteFactorRequest, base_url, '/v2/Services/{ServiceSid}/Entities/{Identity}/Factors/{Sid}', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('DELETE', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DeleteFactorResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        

        return res

    def delete_messaging_configuration(self, request: operations.DeleteMessagingConfigurationRequest, security: operations.DeleteMessagingConfigurationSecurity, server_url: Optional[str] = None) -> operations.DeleteMessagingConfigurationResponse:
        r"""Delete a specific MessagingConfiguration."""
        base_url = operations.DELETE_MESSAGING_CONFIGURATION_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.DeleteMessagingConfigurationRequest, base_url, '/v2/Services/{ServiceSid}/MessagingConfigurations/{Country}', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('DELETE', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DeleteMessagingConfigurationResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        

        return res

    def delete_rate_limit(self, request: operations.DeleteRateLimitRequest, security: operations.DeleteRateLimitSecurity, server_url: Optional[str] = None) -> operations.DeleteRateLimitResponse:
        r"""Delete a specific Rate Limit."""
        base_url = operations.DELETE_RATE_LIMIT_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.DeleteRateLimitRequest, base_url, '/v2/Services/{ServiceSid}/RateLimits/{Sid}', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('DELETE', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DeleteRateLimitResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        

        return res

    def delete_safelist(self, request: operations.DeleteSafelistRequest, security: operations.DeleteSafelistSecurity, server_url: Optional[str] = None) -> operations.DeleteSafelistResponse:
        r"""Remove a phone number from SafeList."""
        base_url = operations.DELETE_SAFELIST_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.DeleteSafelistRequest, base_url, '/v2/SafeList/Numbers/{PhoneNumber}', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('DELETE', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DeleteSafelistResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        

        return res

    def delete_service(self, request: operations.DeleteServiceRequest, security: operations.DeleteServiceSecurity, server_url: Optional[str] = None) -> operations.DeleteServiceResponse:
        r"""Delete a specific Verification Service Instance."""
        base_url = operations.DELETE_SERVICE_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.DeleteServiceRequest, base_url, '/v2/Services/{Sid}', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('DELETE', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DeleteServiceResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        

        return res

    def delete_webhook(self, request: operations.DeleteWebhookRequest, security: operations.DeleteWebhookSecurity, server_url: Optional[str] = None) -> operations.DeleteWebhookResponse:
        r"""Delete a specific Webhook."""
        base_url = operations.DELETE_WEBHOOK_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.DeleteWebhookRequest, base_url, '/v2/Services/{ServiceSid}/Webhooks/{Sid}', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('DELETE', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DeleteWebhookResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        

        return res

    def fetch_access_token(self, request: operations.FetchAccessTokenRequest, security: operations.FetchAccessTokenSecurity, server_url: Optional[str] = None) -> operations.FetchAccessTokenResponse:
        r"""Fetch an Access Token for the Entity"""
        base_url = operations.FETCH_ACCESS_TOKEN_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.FetchAccessTokenRequest, base_url, '/v2/Services/{ServiceSid}/AccessTokens/{Sid}', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.FetchAccessTokenResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.VerifyV2ServiceAccessToken])
                res.verify_v2_service_access_token = out

        return res

    def fetch_bucket(self, request: operations.FetchBucketRequest, security: operations.FetchBucketSecurity, server_url: Optional[str] = None) -> operations.FetchBucketResponse:
        r"""Fetch a specific Bucket."""
        base_url = operations.FETCH_BUCKET_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.FetchBucketRequest, base_url, '/v2/Services/{ServiceSid}/RateLimits/{RateLimitSid}/Buckets/{Sid}', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.FetchBucketResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.VerifyV2ServiceRateLimitBucket])
                res.verify_v2_service_rate_limit_bucket = out

        return res

    def fetch_challenge(self, request: operations.FetchChallengeRequest, security: operations.FetchChallengeSecurity, server_url: Optional[str] = None) -> operations.FetchChallengeResponse:
        r"""Fetch a specific Challenge."""
        base_url = operations.FETCH_CHALLENGE_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.FetchChallengeRequest, base_url, '/v2/Services/{ServiceSid}/Entities/{Identity}/Challenges/{Sid}', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.FetchChallengeResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.VerifyV2ServiceEntityChallenge])
                res.verify_v2_service_entity_challenge = out

        return res

    def fetch_entity(self, request: operations.FetchEntityRequest, security: operations.FetchEntitySecurity, server_url: Optional[str] = None) -> operations.FetchEntityResponse:
        r"""Fetch a specific Entity."""
        base_url = operations.FETCH_ENTITY_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.FetchEntityRequest, base_url, '/v2/Services/{ServiceSid}/Entities/{Identity}', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.FetchEntityResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.VerifyV2ServiceEntity])
                res.verify_v2_service_entity = out

        return res

    def fetch_factor(self, request: operations.FetchFactorRequest, security: operations.FetchFactorSecurity, server_url: Optional[str] = None) -> operations.FetchFactorResponse:
        r"""Fetch a specific Factor."""
        base_url = operations.FETCH_FACTOR_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.FetchFactorRequest, base_url, '/v2/Services/{ServiceSid}/Entities/{Identity}/Factors/{Sid}', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.FetchFactorResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.VerifyV2ServiceEntityFactor])
                res.verify_v2_service_entity_factor = out

        return res

    def fetch_form(self, request: operations.FetchFormRequest, security: operations.FetchFormSecurity, server_url: Optional[str] = None) -> operations.FetchFormResponse:
        r"""Fetch the forms for a specific Form Type."""
        base_url = operations.FETCH_FORM_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.FetchFormRequest, base_url, '/v2/Forms/{FormType}', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.FetchFormResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.VerifyV2Form])
                res.verify_v2_form = out

        return res

    def fetch_messaging_configuration(self, request: operations.FetchMessagingConfigurationRequest, security: operations.FetchMessagingConfigurationSecurity, server_url: Optional[str] = None) -> operations.FetchMessagingConfigurationResponse:
        r"""Fetch a specific MessagingConfiguration."""
        base_url = operations.FETCH_MESSAGING_CONFIGURATION_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.FetchMessagingConfigurationRequest, base_url, '/v2/Services/{ServiceSid}/MessagingConfigurations/{Country}', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.FetchMessagingConfigurationResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.VerifyV2ServiceMessagingConfiguration])
                res.verify_v2_service_messaging_configuration = out

        return res

    def fetch_rate_limit(self, request: operations.FetchRateLimitRequest, security: operations.FetchRateLimitSecurity, server_url: Optional[str] = None) -> operations.FetchRateLimitResponse:
        r"""Fetch a specific Rate Limit."""
        base_url = operations.FETCH_RATE_LIMIT_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.FetchRateLimitRequest, base_url, '/v2/Services/{ServiceSid}/RateLimits/{Sid}', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.FetchRateLimitResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.VerifyV2ServiceRateLimit])
                res.verify_v2_service_rate_limit = out

        return res

    def fetch_safelist(self, request: operations.FetchSafelistRequest, security: operations.FetchSafelistSecurity, server_url: Optional[str] = None) -> operations.FetchSafelistResponse:
        r"""Check if a phone number exists in SafeList."""
        base_url = operations.FETCH_SAFELIST_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.FetchSafelistRequest, base_url, '/v2/SafeList/Numbers/{PhoneNumber}', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.FetchSafelistResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.VerifyV2Safelist])
                res.verify_v2_safelist = out

        return res

    def fetch_service(self, request: operations.FetchServiceRequest, security: operations.FetchServiceSecurity, server_url: Optional[str] = None) -> operations.FetchServiceResponse:
        r"""Fetch specific Verification Service Instance."""
        base_url = operations.FETCH_SERVICE_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.FetchServiceRequest, base_url, '/v2/Services/{Sid}', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.FetchServiceResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.VerifyV2Service])
                res.verify_v2_service = out

        return res

    def fetch_verification(self, request: operations.FetchVerificationRequest, security: operations.FetchVerificationSecurity, server_url: Optional[str] = None) -> operations.FetchVerificationResponse:
        r"""Fetch a specific Verification"""
        base_url = operations.FETCH_VERIFICATION_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.FetchVerificationRequest, base_url, '/v2/Services/{ServiceSid}/Verifications/{Sid}', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.FetchVerificationResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.VerifyV2ServiceVerification])
                res.verify_v2_service_verification = out

        return res

    def fetch_verification_attempt(self, request: operations.FetchVerificationAttemptRequest, security: operations.FetchVerificationAttemptSecurity, server_url: Optional[str] = None) -> operations.FetchVerificationAttemptResponse:
        r"""Fetch a specific verification attempt."""
        base_url = operations.FETCH_VERIFICATION_ATTEMPT_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.FetchVerificationAttemptRequest, base_url, '/v2/Attempts/{Sid}', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.FetchVerificationAttemptResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.VerifyV2VerificationAttempt])
                res.verify_v2_verification_attempt = out

        return res

    def fetch_verification_attempts_summary(self, request: operations.FetchVerificationAttemptsSummaryRequest, security: operations.FetchVerificationAttemptsSummarySecurity, server_url: Optional[str] = None) -> operations.FetchVerificationAttemptsSummaryResponse:
        r"""Get a summary of how many attempts were made and how many were converted."""
        base_url = operations.FETCH_VERIFICATION_ATTEMPTS_SUMMARY_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = base_url.removesuffix('/') + '/v2/Attempts/Summary'
        
        query_params = utils.get_query_params(operations.FetchVerificationAttemptsSummaryRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.FetchVerificationAttemptsSummaryResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.VerifyV2VerificationAttemptsSummary])
                res.verify_v2_verification_attempts_summary = out

        return res

    def fetch_webhook(self, request: operations.FetchWebhookRequest, security: operations.FetchWebhookSecurity, server_url: Optional[str] = None) -> operations.FetchWebhookResponse:
        r"""Fetch a specific Webhook."""
        base_url = operations.FETCH_WEBHOOK_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.FetchWebhookRequest, base_url, '/v2/Services/{ServiceSid}/Webhooks/{Sid}', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.FetchWebhookResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.VerifyV2ServiceWebhook])
                res.verify_v2_service_webhook = out

        return res

    def list_bucket(self, request: operations.ListBucketRequest, security: operations.ListBucketSecurity, server_url: Optional[str] = None) -> operations.ListBucketResponse:
        r"""Retrieve a list of all Buckets for a Rate Limit."""
        base_url = operations.LIST_BUCKET_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.ListBucketRequest, base_url, '/v2/Services/{ServiceSid}/RateLimits/{RateLimitSid}/Buckets', request)
        
        query_params = utils.get_query_params(operations.ListBucketRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ListBucketResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.ListBucketListBucketResponse])
                res.list_bucket_response = out

        return res

    def list_challenge(self, request: operations.ListChallengeRequest, security: operations.ListChallengeSecurity, server_url: Optional[str] = None) -> operations.ListChallengeResponse:
        r"""Retrieve a list of all Challenges for a Factor."""
        base_url = operations.LIST_CHALLENGE_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.ListChallengeRequest, base_url, '/v2/Services/{ServiceSid}/Entities/{Identity}/Challenges', request)
        
        query_params = utils.get_query_params(operations.ListChallengeRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ListChallengeResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.ListChallengeListChallengeResponse])
                res.list_challenge_response = out

        return res

    def list_entity(self, request: operations.ListEntityRequest, security: operations.ListEntitySecurity, server_url: Optional[str] = None) -> operations.ListEntityResponse:
        r"""Retrieve a list of all Entities for a Service."""
        base_url = operations.LIST_ENTITY_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.ListEntityRequest, base_url, '/v2/Services/{ServiceSid}/Entities', request)
        
        query_params = utils.get_query_params(operations.ListEntityRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ListEntityResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.ListEntityListEntityResponse])
                res.list_entity_response = out

        return res

    def list_factor(self, request: operations.ListFactorRequest, security: operations.ListFactorSecurity, server_url: Optional[str] = None) -> operations.ListFactorResponse:
        r"""Retrieve a list of all Factors for an Entity."""
        base_url = operations.LIST_FACTOR_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.ListFactorRequest, base_url, '/v2/Services/{ServiceSid}/Entities/{Identity}/Factors', request)
        
        query_params = utils.get_query_params(operations.ListFactorRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ListFactorResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.ListFactorListFactorResponse])
                res.list_factor_response = out

        return res

    def list_messaging_configuration(self, request: operations.ListMessagingConfigurationRequest, security: operations.ListMessagingConfigurationSecurity, server_url: Optional[str] = None) -> operations.ListMessagingConfigurationResponse:
        r"""Retrieve a list of all Messaging Configurations for a Service."""
        base_url = operations.LIST_MESSAGING_CONFIGURATION_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.ListMessagingConfigurationRequest, base_url, '/v2/Services/{ServiceSid}/MessagingConfigurations', request)
        
        query_params = utils.get_query_params(operations.ListMessagingConfigurationRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ListMessagingConfigurationResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.ListMessagingConfigurationListMessagingConfigurationResponse])
                res.list_messaging_configuration_response = out

        return res

    def list_rate_limit(self, request: operations.ListRateLimitRequest, security: operations.ListRateLimitSecurity, server_url: Optional[str] = None) -> operations.ListRateLimitResponse:
        r"""Retrieve a list of all Rate Limits for a service."""
        base_url = operations.LIST_RATE_LIMIT_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.ListRateLimitRequest, base_url, '/v2/Services/{ServiceSid}/RateLimits', request)
        
        query_params = utils.get_query_params(operations.ListRateLimitRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ListRateLimitResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.ListRateLimitListRateLimitResponse])
                res.list_rate_limit_response = out

        return res

    def list_service(self, request: operations.ListServiceRequest, security: operations.ListServiceSecurity, server_url: Optional[str] = None) -> operations.ListServiceResponse:
        r"""Retrieve a list of all Verification Services for an account."""
        base_url = operations.LIST_SERVICE_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = base_url.removesuffix('/') + '/v2/Services'
        
        query_params = utils.get_query_params(operations.ListServiceRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ListServiceResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.ListServiceListServiceResponse])
                res.list_service_response = out

        return res

    def list_verification_attempt(self, request: operations.ListVerificationAttemptRequest, security: operations.ListVerificationAttemptSecurity, server_url: Optional[str] = None) -> operations.ListVerificationAttemptResponse:
        r"""List all the verification attempts for a given Account."""
        base_url = operations.LIST_VERIFICATION_ATTEMPT_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = base_url.removesuffix('/') + '/v2/Attempts'
        
        query_params = utils.get_query_params(operations.ListVerificationAttemptRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ListVerificationAttemptResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.ListVerificationAttemptListVerificationAttemptResponse])
                res.list_verification_attempt_response = out

        return res

    def list_verification_template(self, request: operations.ListVerificationTemplateRequest, security: operations.ListVerificationTemplateSecurity, server_url: Optional[str] = None) -> operations.ListVerificationTemplateResponse:
        r"""List all the available templates for a given Account."""
        base_url = operations.LIST_VERIFICATION_TEMPLATE_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = base_url.removesuffix('/') + '/v2/Templates'
        
        query_params = utils.get_query_params(operations.ListVerificationTemplateRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ListVerificationTemplateResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.ListVerificationTemplateListVerificationTemplateResponse])
                res.list_verification_template_response = out

        return res

    def list_webhook(self, request: operations.ListWebhookRequest, security: operations.ListWebhookSecurity, server_url: Optional[str] = None) -> operations.ListWebhookResponse:
        r"""Retrieve a list of all Webhooks for a Service."""
        base_url = operations.LIST_WEBHOOK_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.ListWebhookRequest, base_url, '/v2/Services/{ServiceSid}/Webhooks', request)
        
        query_params = utils.get_query_params(operations.ListWebhookRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ListWebhookResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.ListWebhookListWebhookResponse])
                res.list_webhook_response = out

        return res

    def update_bucket(self, request: operations.UpdateBucketRequest, security: operations.UpdateBucketSecurity, server_url: Optional[str] = None) -> operations.UpdateBucketResponse:
        r"""Update a specific Bucket."""
        base_url = operations.UPDATE_BUCKET_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.UpdateBucketRequest, base_url, '/v2/Services/{ServiceSid}/RateLimits/{RateLimitSid}/Buckets/{Sid}', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'form')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.UpdateBucketResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.VerifyV2ServiceRateLimitBucket])
                res.verify_v2_service_rate_limit_bucket = out

        return res

    def update_challenge(self, request: operations.UpdateChallengeRequest, security: operations.UpdateChallengeSecurity, server_url: Optional[str] = None) -> operations.UpdateChallengeResponse:
        r"""Verify a specific Challenge."""
        base_url = operations.UPDATE_CHALLENGE_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.UpdateChallengeRequest, base_url, '/v2/Services/{ServiceSid}/Entities/{Identity}/Challenges/{Sid}', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'form')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.UpdateChallengeResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.VerifyV2ServiceEntityChallenge])
                res.verify_v2_service_entity_challenge = out

        return res

    def update_factor(self, request: operations.UpdateFactorRequest, security: operations.UpdateFactorSecurity, server_url: Optional[str] = None) -> operations.UpdateFactorResponse:
        r"""Update a specific Factor. This endpoint can be used to Verify a Factor if passed an `AuthPayload` param."""
        base_url = operations.UPDATE_FACTOR_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.UpdateFactorRequest, base_url, '/v2/Services/{ServiceSid}/Entities/{Identity}/Factors/{Sid}', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'form')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.UpdateFactorResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.VerifyV2ServiceEntityFactor])
                res.verify_v2_service_entity_factor = out

        return res

    def update_messaging_configuration(self, request: operations.UpdateMessagingConfigurationRequest, security: operations.UpdateMessagingConfigurationSecurity, server_url: Optional[str] = None) -> operations.UpdateMessagingConfigurationResponse:
        r"""Update a specific MessagingConfiguration"""
        base_url = operations.UPDATE_MESSAGING_CONFIGURATION_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.UpdateMessagingConfigurationRequest, base_url, '/v2/Services/{ServiceSid}/MessagingConfigurations/{Country}', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'form')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.UpdateMessagingConfigurationResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.VerifyV2ServiceMessagingConfiguration])
                res.verify_v2_service_messaging_configuration = out

        return res

    def update_rate_limit(self, request: operations.UpdateRateLimitRequest, security: operations.UpdateRateLimitSecurity, server_url: Optional[str] = None) -> operations.UpdateRateLimitResponse:
        r"""Update a specific Rate Limit."""
        base_url = operations.UPDATE_RATE_LIMIT_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.UpdateRateLimitRequest, base_url, '/v2/Services/{ServiceSid}/RateLimits/{Sid}', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'form')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.UpdateRateLimitResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.VerifyV2ServiceRateLimit])
                res.verify_v2_service_rate_limit = out

        return res

    def update_service(self, request: operations.UpdateServiceRequest, security: operations.UpdateServiceSecurity, server_url: Optional[str] = None) -> operations.UpdateServiceResponse:
        r"""Update a specific Verification Service."""
        base_url = operations.UPDATE_SERVICE_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.UpdateServiceRequest, base_url, '/v2/Services/{Sid}', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'form')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.UpdateServiceResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.VerifyV2Service])
                res.verify_v2_service = out

        return res

    def update_verification(self, request: operations.UpdateVerificationRequest, security: operations.UpdateVerificationSecurity, server_url: Optional[str] = None) -> operations.UpdateVerificationResponse:
        r"""Update a Verification status"""
        base_url = operations.UPDATE_VERIFICATION_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.UpdateVerificationRequest, base_url, '/v2/Services/{ServiceSid}/Verifications/{Sid}', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'form')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.UpdateVerificationResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.VerifyV2ServiceVerification])
                res.verify_v2_service_verification = out

        return res

    def update_webhook(self, request: operations.UpdateWebhookRequest, security: operations.UpdateWebhookSecurity, server_url: Optional[str] = None) -> operations.UpdateWebhookResponse:
        base_url = operations.UPDATE_WEBHOOK_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.UpdateWebhookRequest, base_url, '/v2/Services/{ServiceSid}/Webhooks/{Sid}', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'form')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.UpdateWebhookResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.VerifyV2ServiceWebhook])
                res.verify_v2_service_webhook = out

        return res

    