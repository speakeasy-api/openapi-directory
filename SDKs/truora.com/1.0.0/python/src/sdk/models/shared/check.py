"""Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT."""

from __future__ import annotations
import dataclasses
import dateutil.parser
from ..shared import companysummary as shared_companysummary
from ..shared import score as shared_score
from ..shared import status as shared_status
from ..shared import summary as shared_summary
from ..shared import vehiclesummary as shared_vehiclesummary
from ..shared import wronginput as shared_wronginput
from dataclasses_json import Undefined, dataclass_json
from datetime import datetime
from enum import Enum
from marshmallow import fields
from sdk import utils
from typing import Optional

class CheckCountryEnum(str, Enum):
    r"""ID Document country"""
    ALL = 'ALL'
    BR = 'BR'
    CL = 'CL'
    CO = 'CO'
    CR = 'CR'
    EC = 'EC'
    MX = 'MX'
    PE = 'PE'
    AR = 'AR'

class CheckNativeCountryEnum(str, Enum):
    r"""Person origin country"""
    AD = 'ad'
    AE = 'ae'
    AF = 'af'
    AG = 'ag'
    AI = 'ai'
    AL = 'al'
    AM = 'am'
    AN = 'an'
    AO = 'ao'
    AQ = 'aq'
    AR = 'ar'
    AS = 'as'
    AT = 'at'
    AU = 'au'
    AW = 'aw'
    AX = 'ax'
    AZ = 'az'
    BA = 'ba'
    BB = 'bb'
    BD = 'bd'
    BE = 'be'
    BF = 'bf'
    BG = 'bg'
    BH = 'bh'
    BI = 'bi'
    BJ = 'bj'
    BM = 'bm'
    BN = 'bn'
    BO = 'bo'
    BR = 'br'
    BS = 'bs'
    BT = 'bt'
    BV = 'bv'
    BW = 'bw'
    BY = 'by'
    BZ = 'bz'
    CA = 'ca'
    CC = 'cc'
    CD = 'cd'
    CF = 'cf'
    CG = 'cg'
    CH = 'ch'
    CI = 'ci'
    CK = 'ck'
    CL = 'cl'
    CM = 'cm'
    CN = 'cn'
    CO = 'co'
    CR = 'cr'
    CU = 'cu'
    CV = 'cv'
    CX = 'cx'
    CY = 'cy'
    CZ = 'cz'
    DE = 'de'
    DJ = 'dj'
    DK = 'dk'
    DM = 'dm'
    DO = 'do'
    DZ = 'dz'
    EA = 'ea'
    EC = 'ec'
    EE = 'ee'
    EG = 'eg'
    EH = 'eh'
    ER = 'er'
    ES = 'es'
    ET = 'et'
    FI = 'fi'
    FJ = 'fj'
    FK = 'fk'
    FM = 'fm'
    FO = 'fo'
    FR = 'fr'
    GA = 'ga'
    GB = 'gb'
    GD = 'gd'
    GE = 'ge'
    GF = 'gf'
    GG = 'gg'
    GH = 'gh'
    GI = 'gi'
    GL = 'gl'
    GM = 'gm'
    GN = 'gn'
    GP = 'gp'
    GQ = 'gq'
    GR = 'gr'
    GS = 'gs'
    GT = 'gt'
    GU = 'gu'
    GW = 'gw'
    GY = 'gy'
    HK = 'hk'
    HM = 'hm'
    HN = 'hn'
    HR = 'hr'
    HT = 'ht'
    HU = 'hu'
    ID = 'id'
    IE = 'ie'
    IL = 'il'
    IM = 'im'
    IN = 'in'
    IO = 'io'
    IQ = 'iq'
    IR = 'ir'
    IS = 'is'
    IT = 'it'
    JE = 'je'
    JM = 'jm'
    JO = 'jo'
    JP = 'jp'
    KE = 'ke'
    KG = 'kg'
    KH = 'kh'
    KI = 'ki'
    KM = 'km'
    KN = 'kn'
    KP = 'kp'
    KR = 'kr'
    KW = 'kw'
    KY = 'ky'
    KZ = 'kz'
    LA = 'la'
    LB = 'lb'
    LC = 'lc'
    LI = 'li'
    LK = 'lk'
    LR = 'lr'
    LS = 'ls'
    LT = 'lt'
    LU = 'lu'
    LV = 'lv'
    LY = 'ly'
    MA = 'ma'
    MC = 'mc'
    MD = 'md'
    ME = 'me'
    MG = 'mg'
    MH = 'mh'
    MK = 'mk'
    ML = 'ml'
    MM = 'mm'
    MN = 'mn'
    MO = 'mo'
    MP = 'mp'
    MQ = 'mq'
    MR = 'mr'
    MS = 'ms'
    MT = 'mt'
    MU = 'mu'
    MV = 'mv'
    MW = 'mw'
    MX = 'mx'
    MY = 'my'
    MZ = 'mz'
    NA = 'na'
    NC = 'nc'
    NE = 'ne'
    NF = 'nf'
    NG = 'ng'
    NI = 'ni'
    NL = 'nl'
    NO = 'no'
    NP = 'np'
    NR = 'nr'
    NU = 'nu'
    NZ = 'nz'
    OM = 'om'
    PA = 'pa'
    PE = 'pe'
    PF = 'pf'
    PG = 'pg'
    PH = 'ph'
    PK = 'pk'
    PL = 'pl'
    PM = 'pm'
    PN = 'pn'
    PR = 'pr'
    PS = 'ps'
    PT = 'pt'
    PW = 'pw'
    PY = 'py'
    QA = 'qa'
    RE = 're'
    RO = 'ro'
    RS = 'rs'
    RU = 'ru'
    RW = 'rw'
    SA = 'sa'
    SB = 'sb'
    SC = 'sc'
    SD = 'sd'
    SE = 'se'
    SG = 'sg'
    SH = 'sh'
    SI = 'si'
    SJ = 'sj'
    SK = 'sk'
    SL = 'sl'
    SM = 'sm'
    SN = 'sn'
    SO = 'so'
    SR = 'sr'
    ST = 'st'
    SV = 'sv'
    SY = 'sy'
    SZ = 'sz'
    TC = 'tc'
    TD = 'td'
    TF = 'tf'
    TG = 'tg'
    TH = 'th'
    TJ = 'tj'
    TK = 'tk'
    TL = 'tl'
    TM = 'tm'
    TN = 'tn'
    TO = 'to'
    TR = 'tr'
    TT = 'tt'
    TV = 'tv'
    TW = 'tw'
    TZ = 'tz'
    UA = 'ua'
    UG = 'ug'
    UM = 'um'
    US = 'us'
    UY = 'uy'
    UZ = 'uz'
    VA = 'va'
    VC = 'vc'
    VE = 've'
    VG = 'vg'
    VI = 'vi'
    VN = 'vn'
    VU = 'vu'
    WF = 'wf'
    WS = 'ws'
    YE = 'ye'
    YT = 'yt'
    ZA = 'za'
    ZM = 'zm'
    ZW = 'zw'

class CheckRegionEnum(str, Enum):
    r"""Region where the background is to be checked. By default, background checks in Brazil are performed in region where the person is from. Applies for some Brazil collectors only. Allowed values are: DF: Distrito Federal, AC: Acre, AL: Alagoas, AP: Amapá, AM: Amazonas, BA: Bahía, CE: Ceará, ES: Espírito Santo, GO: Goiás, MA: Maranhão, MT: Mato Grosso, MS: Mato Grosso do Sul, MG: Minas Gerais, PA: Pará, PB: Paraíba, PR: Paraná, PE: Pernambuco, PI: Piauí, RJ: Río de Janeiro, RN: Río Grande do Norte, RS: Río Grande do Sul, RO: Rondônia, RR: Roraima, SC: Santa Catarina, SP: São Paulo, SE: Sergipe, TO : Tocantins."""
    DF = 'DF'
    AC = 'AC'
    AL = 'AL'
    AP = 'AP'
    AM = 'AM'
    BA = 'BA'
    CE = 'CE'
    ES = 'ES'
    GO = 'GO'
    MA = 'MA'
    MT = 'MT'
    MS = 'MS'
    MG = 'MG'
    PA = 'PA'
    PB = 'PB'
    PR = 'PR'
    PE = 'PE'
    PI = 'PI'
    RJ = 'RJ'
    RN = 'RN'
    RS = 'RS'
    RO = 'RO'
    RR = 'RR'
    SC = 'SC'
    SP = 'SP'
    SE = 'SE'
    TO = 'TO'

class CheckStatusEnum(str, Enum):
    r"""Result status of the background check. **Not_started** means the background check is still in queue, since there is a limit of background checks that can be processed simultaneously, **completed** means the check finished successfully, **error** means the check failed, **in_progress** means the check is currently being processed, **delayed** means the check is waiting for an additional requirement to be met, this can last up to 3 days. **Completed** and **error** are the two only final statuses"""
    NOT_STARTED = 'not_started'
    IN_PROGRESS = 'in_progress'
    COMPLETED = 'completed'
    ERROR = 'error'
    DELAYED = 'delayed'

class CheckTypeEnum(str, Enum):
    r"""Background check type"""
    COMPANY = 'company'
    PERSON = 'person'
    VEHICLE = 'vehicle'


@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class Check:
    r"""Represents a background check"""
    
    check_id: str = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('check_id') }})
    r"""Background check ID"""  
    country: CheckCountryEnum = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('country') }})
    r"""ID Document country"""  
    creation_date: datetime = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('creation_date'), 'encoder': utils.datetimeisoformat(False), 'decoder': dateutil.parser.isoparse, 'mm_field': fields.DateTime(format='iso') }})
    r"""Background check creation date"""  
    id_score: float = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('id_score') }})
    r"""Background check score regarding results by ID number only. It is a number between 0 and 1 where 1 is the best score. This result is a weighted average of the id_scores listed under scores."""  
    score: float = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('score') }})
    r"""Background check score. Number between 0 and 1 where 1 is the best score"""  
    status: CheckStatusEnum = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('status') }})
    r"""Result status of the background check. **Not_started** means the background check is still in queue, since there is a limit of background checks that can be processed simultaneously, **completed** means the check finished successfully, **error** means the check failed, **in_progress** means the check is currently being processed, **delayed** means the check is waiting for an additional requirement to be met, this can last up to 3 days. **Completed** and **error** are the two only final statuses"""  
    statuses: list[shared_status.Status] = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('statuses') }})
    r"""Database status list"""  
    summary: shared_summary.Summary = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('summary') }})
    r"""Represents a background check summary"""  
    type: CheckTypeEnum = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('type') }})
    r"""Background check type"""  
    birth_certificate: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('birth_certificate'), 'exclude': lambda f: f is None }})
    r"""Person birth certificate"""  
    company_summary: Optional[shared_companysummary.CompanySummary] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('company_summary'), 'exclude': lambda f: f is None }})
    r"""Represents the summary of a company background check"""  
    date_of_birth: Optional[datetime] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('date_of_birth'), 'encoder': utils.datetimeisoformat(True), 'decoder': dateutil.parser.isoparse, 'mm_field': fields.DateTime(format='iso'), 'exclude': lambda f: f is None }})
    r"""Person birthdate. Shown only if provided during check creation. YYYY-MM-DD format"""  
    diplomatic_id: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('diplomatic_id'), 'exclude': lambda f: f is None }})
    r"""Person diplomatic id"""  
    driver_license: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('driver_license'), 'exclude': lambda f: f is None }})
    r"""Person driver's license"""  
    first_name: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('first_name'), 'exclude': lambda f: f is None }})
    r"""Person or entity first name. Shown only if provided during check creation"""  
    foreign_id: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('foreign_id'), 'exclude': lambda f: f is None }})
    r"""Person foreign identification"""  
    homonym_probability: Optional[float] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('homonym_probability'), 'exclude': lambda f: f is None }})
    r"""[Experimental] Analyzes the probability that the results by name are attributed to a homonym. Number between 0 and 1 where 1 is the the greatest probability"""  
    homonym_score: Optional[float] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('homonym_score'), 'exclude': lambda f: f is None }})
    r"""Background check score including results by name only. This might contain homonym information"""  
    homonym_scores: Optional[list[shared_score.Score]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('homonym_scores'), 'exclude': lambda f: f is None }})
    r"""Background check scores by name for each profile group. [Deprecated for API key V1]"""  
    issue_date: Optional[datetime] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('issue_date'), 'encoder': utils.datetimeisoformat(True), 'decoder': dateutil.parser.isoparse, 'mm_field': fields.DateTime(format='iso'), 'exclude': lambda f: f is None }})
    r"""Issue date of the person ID"""  
    last_name: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('last_name'), 'exclude': lambda f: f is None }})
    r"""Person or entity last name. Shown only if provided during check creation"""  
    license_plate: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('license_plate'), 'exclude': lambda f: f is None }})
    r"""Vehicle license plate"""  
    national_id: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('national_id'), 'exclude': lambda f: f is None }})
    r"""Person national identification"""  
    native_country: Optional[CheckNativeCountryEnum] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('native_country'), 'exclude': lambda f: f is None }})
    r"""Person origin country"""  
    owner_document_id: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('owner_document_id'), 'exclude': lambda f: f is None }})
    r"""Vehicle owner identification"""  
    owner_document_type: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('owner_document_type'), 'exclude': lambda f: f is None }})
    r"""Vehicle owner document type"""  
    passport: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('passport'), 'exclude': lambda f: f is None }})
    r"""Person passport"""  
    payment_date: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('payment_date'), 'exclude': lambda f: f is None }})
    r"""Vehicle license payment date"""  
    pep: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('pep'), 'exclude': lambda f: f is None }})
    r"""Colombian PEP idenfitication for Venezuelans"""  
    phone_number: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('phone_number'), 'exclude': lambda f: f is None }})
    r"""Person phone number. Required by law in order to notify the person their background is being checked"""  
    professional_card: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('professional_card'), 'exclude': lambda f: f is None }})
    r"""Person professional card number"""  
    ptp: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('ptp'), 'exclude': lambda f: f is None }})
    r"""Temporary residence permit of the person"""  
    region: Optional[CheckRegionEnum] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('region'), 'exclude': lambda f: f is None }})
    r"""Region where the background is to be checked. By default, background checks in Brazil are performed in region where the person is from. Applies for some Brazil collectors only. Allowed values are: DF: Distrito Federal, AC: Acre, AL: Alagoas, AP: Amapá, AM: Amazonas, BA: Bahía, CE: Ceará, ES: Espírito Santo, GO: Goiás, MA: Maranhão, MT: Mato Grosso, MS: Mato Grosso do Sul, MG: Minas Gerais, PA: Pará, PB: Paraíba, PR: Paraná, PE: Pernambuco, PI: Piauí, RJ: Río de Janeiro, RN: Río Grande do Norte, RS: Río Grande do Sul, RO: Rondônia, RR: Roraima, SC: Santa Catarina, SP: São Paulo, SE: Sergipe, TO : Tocantins."""  
    report_id: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('report_id'), 'exclude': lambda f: f is None }})
    r"""Report ID the background check is associated with"""  
    scores: Optional[list[shared_score.Score]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('scores'), 'exclude': lambda f: f is None }})
    r"""Background check score of each profile group and dataset"""  
    tax_id: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('tax_id'), 'exclude': lambda f: f is None }})
    r"""Person or company tax id"""  
    update_date: Optional[datetime] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('update_date'), 'encoder': utils.datetimeisoformat(True), 'decoder': dateutil.parser.isoparse, 'mm_field': fields.DateTime(format='iso'), 'exclude': lambda f: f is None }})
    r"""Background check update date"""  
    vehicle_id: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('vehicle_id'), 'exclude': lambda f: f is None }})
    r"""Vehicle identification"""  
    vehicle_summary: Optional[shared_vehiclesummary.VehicleSummary] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('vehicle_summary'), 'exclude': lambda f: f is None }})
    r"""Represents the summary of a vehicle background check"""  
    wrong_inputs: Optional[list[shared_wronginput.WrongInput]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('wrong_inputs'), 'exclude': lambda f: f is None }})
    r"""List of parameters entered during background check creation that do not match the information obtained"""  
    