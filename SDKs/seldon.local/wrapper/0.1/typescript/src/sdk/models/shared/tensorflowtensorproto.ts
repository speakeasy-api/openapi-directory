/*
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

import { SpeakeasyBase, SpeakeasyMetadata } from "../../../internal/utils";
import { TensorflowDataTypeEnum } from "./tensorflowdatatypeenum";
import { TensorflowResourceHandleProto } from "./tensorflowresourcehandleproto";
import { TensorflowTensorShapeProto } from "./tensorflowtensorshapeproto";
import { TensorflowVariantTensorDataProto } from "./tensorflowvarianttensordataproto";
import { Expose, Type } from "class-transformer";

/**
 * Protocol buffer representing a tensor.
 */
export class TensorflowTensorProto extends SpeakeasyBase {
  @SpeakeasyMetadata()
  @Expose({ name: "bool_val" })
  boolVal?: boolean[];

  /**
   * DT_COMPLEX128. dcomplex_val(2*i) and dcomplex_val(2*i+1) are real
   *
   * @remarks
   * and imaginary parts of i-th double precision complex.
   */
  @SpeakeasyMetadata()
  @Expose({ name: "dcomplex_val" })
  dcomplexVal?: number[];

  /**
   * DT_DOUBLE.
   */
  @SpeakeasyMetadata()
  @Expose({ name: "double_val" })
  doubleVal?: number[];

  /**
   * - DT_INVALID: Not a legal value for DataType.  Used to indicate a DataType field
   *
   * @remarks
   * has not been set.
   *  - DT_FLOAT: Data types that all computation devices are expected to be
   * capable to support.
   *  - DT_FLOAT_REF: Do not use!  These are only for parameters.  Every enum above
   * should have a corresponding value below (verified by types_test).
   */
  @SpeakeasyMetadata()
  @Expose({ name: "dtype" })
  dtype?: TensorflowDataTypeEnum;

  /**
   * DT_FLOAT.
   */
  @SpeakeasyMetadata()
  @Expose({ name: "float_val" })
  floatVal?: number[];

  /**
   * DT_HALF, DT_BFLOAT16. Note that since protobuf has no int16 type, we'll
   *
   * @remarks
   * have some pointless zero padding for each value here.
   */
  @SpeakeasyMetadata()
  @Expose({ name: "half_val" })
  halfVal?: number[];

  @SpeakeasyMetadata()
  @Expose({ name: "int64_val" })
  int64Val?: string[];

  /**
   * DT_INT32, DT_INT16, DT_INT8, DT_UINT8.
   */
  @SpeakeasyMetadata()
  @Expose({ name: "int_val" })
  intVal?: number[];

  @SpeakeasyMetadata({ elemType: TensorflowResourceHandleProto })
  @Expose({ name: "resource_handle_val" })
  @Type(() => TensorflowResourceHandleProto)
  resourceHandleVal?: TensorflowResourceHandleProto[];

  /**
   * DT_COMPLEX64. scomplex_val(2*i) and scomplex_val(2*i+1) are real
   *
   * @remarks
   * and imaginary parts of i-th single precision complex.
   */
  @SpeakeasyMetadata()
  @Expose({ name: "scomplex_val" })
  scomplexVal?: number[];

  @SpeakeasyMetadata()
  @Expose({ name: "string_val" })
  stringVal?: string[];

  /**
   * Serialized raw tensor content from either Tensor::AsProtoTensorContent or
   *
   * @remarks
   * memcpy in tensorflow::grpc::EncodeTensorToByteBuffer. This representation
   * can be used for all tensor types. The purpose of this representation is to
   * reduce serialization overhead during RPC call by avoiding serialization of
   * many repeated small items.
   */
  @SpeakeasyMetadata()
  @Expose({ name: "tensor_content" })
  tensorContent?: string;

  /**
   * Dimensions of a tensor.
   */
  @SpeakeasyMetadata()
  @Expose({ name: "tensor_shape" })
  @Type(() => TensorflowTensorShapeProto)
  tensorShape?: TensorflowTensorShapeProto;

  @SpeakeasyMetadata()
  @Expose({ name: "uint32_val" })
  uint32Val?: number[];

  @SpeakeasyMetadata()
  @Expose({ name: "uint64_val" })
  uint64Val?: string[];

  @SpeakeasyMetadata({ elemType: TensorflowVariantTensorDataProto })
  @Expose({ name: "variant_val" })
  @Type(() => TensorflowVariantTensorDataProto)
  variantVal?: TensorflowVariantTensorDataProto[];

  /**
   * Version number.
   *
   * @remarks
   *
   * In version 0, if the "repeated xxx" representations contain only one
   * element, that element is repeated to fill the shape.  This makes it easy
   * to represent a constant Tensor with a single value.
   */
  @SpeakeasyMetadata()
  @Expose({ name: "version_number" })
  versionNumber?: number;
}
