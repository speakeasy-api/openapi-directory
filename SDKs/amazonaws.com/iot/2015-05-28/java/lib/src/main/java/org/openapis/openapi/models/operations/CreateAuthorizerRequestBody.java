/* 
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

package org.openapis.openapi.models.operations;

import com.fasterxml.jackson.annotation.JsonInclude.Include;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;

public class CreateAuthorizerRequestBody {
    /**
     * The ARN of the authorizer's Lambda function.
     */
    @JsonProperty("authorizerFunctionArn")
    public String authorizerFunctionArn;
    public CreateAuthorizerRequestBody withAuthorizerFunctionArn(String authorizerFunctionArn) {
        this.authorizerFunctionArn = authorizerFunctionArn;
        return this;
    }
    
    /**
     * &lt;p&gt;When &lt;code&gt;true&lt;/code&gt;, the result from the authorizer\u2019s Lambda function is cached for clients that use persistent HTTP connections. The results are cached for the time specified by the Lambda function in &lt;code&gt;refreshAfterInSeconds&lt;/code&gt;. This value does not affect authorization of clients that use MQTT connections.&lt;/p&gt; &lt;p&gt;The default value is &lt;code&gt;false&lt;/code&gt;.&lt;/p&gt;
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("enableCachingForHttp")
    public Boolean enableCachingForHttp;
    public CreateAuthorizerRequestBody withEnableCachingForHttp(Boolean enableCachingForHttp) {
        this.enableCachingForHttp = enableCachingForHttp;
        return this;
    }
    
    /**
     * Specifies whether IoT validates the token signature in an authorization request.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("signingDisabled")
    public Boolean signingDisabled;
    public CreateAuthorizerRequestBody withSigningDisabled(Boolean signingDisabled) {
        this.signingDisabled = signingDisabled;
        return this;
    }
    
    /**
     * The status of the create authorizer request.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("status")
    public CreateAuthorizerRequestBodyStatusEnum status;
    public CreateAuthorizerRequestBody withStatus(CreateAuthorizerRequestBodyStatusEnum status) {
        this.status = status;
        return this;
    }
    
    /**
     * &lt;p&gt;Metadata which can be used to manage the custom authorizer.&lt;/p&gt; &lt;note&gt; &lt;p&gt;For URI Request parameters use format: ...key1=value1&amp;amp;key2=value2...&lt;/p&gt; &lt;p&gt;For the CLI command-line parameter use format: &amp;amp;&amp;amp;tags "key1=value1&amp;amp;key2=value2..."&lt;/p&gt; &lt;p&gt;For the cli-input-json file use format: "tags": "key1=value1&amp;amp;key2=value2..."&lt;/p&gt; &lt;/note&gt;
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("tags")
    public org.openapis.openapi.models.shared.Tag[] tags;
    public CreateAuthorizerRequestBody withTags(org.openapis.openapi.models.shared.Tag[] tags) {
        this.tags = tags;
        return this;
    }
    
    /**
     * The name of the token key used to extract the token from the HTTP headers.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("tokenKeyName")
    public String tokenKeyName;
    public CreateAuthorizerRequestBody withTokenKeyName(String tokenKeyName) {
        this.tokenKeyName = tokenKeyName;
        return this;
    }
    
    /**
     * The public keys used to verify the digital signature returned by your custom authentication service.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("tokenSigningPublicKeys")
    public java.util.Map<String, String> tokenSigningPublicKeys;
    public CreateAuthorizerRequestBody withTokenSigningPublicKeys(java.util.Map<String, String> tokenSigningPublicKeys) {
        this.tokenSigningPublicKeys = tokenSigningPublicKeys;
        return this;
    }
    
}
