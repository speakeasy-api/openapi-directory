// Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.

package shared

import (
	"bytes"
	"encoding/json"
	"errors"
	"fmt"
)

type GeonamesPlaceAlternatenamesType string

const (
	GeonamesPlaceAlternatenamesTypeStr GeonamesPlaceAlternatenamesType = "str"
)

type GeonamesPlaceAlternatenames struct {
	Str *string

	Type GeonamesPlaceAlternatenamesType
}

func CreateGeonamesPlaceAlternatenamesStr(str string) GeonamesPlaceAlternatenames {
	typ := GeonamesPlaceAlternatenamesTypeStr

	return GeonamesPlaceAlternatenames{
		Str:  &str,
		Type: typ,
	}
}

func (u *GeonamesPlaceAlternatenames) UnmarshalJSON(data []byte) error {
	var d *json.Decoder

	str := new(string)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&str); err == nil {
		u.Str = str
		u.Type = GeonamesPlaceAlternatenamesTypeStr
		return nil
	}

	return errors.New("could not unmarshal into supported union types")
}

func (u GeonamesPlaceAlternatenames) MarshalJSON() ([]byte, error) {
	if u.Str != nil {
		return json.Marshal(u.Str)
	}

	return nil, nil
}

type GeonamesPlaceCc2Type string

const (
	GeonamesPlaceCc2TypeStr GeonamesPlaceCc2Type = "str"
)

type GeonamesPlaceCc2 struct {
	Str *string

	Type GeonamesPlaceCc2Type
}

func CreateGeonamesPlaceCc2Str(str string) GeonamesPlaceCc2 {
	typ := GeonamesPlaceCc2TypeStr

	return GeonamesPlaceCc2{
		Str:  &str,
		Type: typ,
	}
}

func (u *GeonamesPlaceCc2) UnmarshalJSON(data []byte) error {
	var d *json.Decoder

	str := new(string)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&str); err == nil {
		u.Str = str
		u.Type = GeonamesPlaceCc2TypeStr
		return nil
	}

	return errors.New("could not unmarshal into supported union types")
}

func (u GeonamesPlaceCc2) MarshalJSON() ([]byte, error) {
	if u.Str != nil {
		return json.Marshal(u.Str)
	}

	return nil, nil
}

type GeonamesPlaceDatasetEnum string

const (
	GeonamesPlaceDatasetEnumGeonames GeonamesPlaceDatasetEnum = "geonames"
)

func (e *GeonamesPlaceDatasetEnum) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return err
	}
	switch s {
	case "geonames":
		*e = GeonamesPlaceDatasetEnum(s)
		return nil
	default:
		return fmt.Errorf("invalid value for GeonamesPlaceDatasetEnum: %s", s)
	}
}

// GeonamesPlaceFeatureClassEnum - GeoNames single letter feature code
type GeonamesPlaceFeatureClassEnum string

const (
	GeonamesPlaceFeatureClassEnumA GeonamesPlaceFeatureClassEnum = "A"
	GeonamesPlaceFeatureClassEnumH GeonamesPlaceFeatureClassEnum = "H"
	GeonamesPlaceFeatureClassEnumL GeonamesPlaceFeatureClassEnum = "L"
	GeonamesPlaceFeatureClassEnumP GeonamesPlaceFeatureClassEnum = "P"
	GeonamesPlaceFeatureClassEnumR GeonamesPlaceFeatureClassEnum = "R"
	GeonamesPlaceFeatureClassEnumS GeonamesPlaceFeatureClassEnum = "S"
	GeonamesPlaceFeatureClassEnumT GeonamesPlaceFeatureClassEnum = "T"
	GeonamesPlaceFeatureClassEnumU GeonamesPlaceFeatureClassEnum = "U"
	GeonamesPlaceFeatureClassEnumV GeonamesPlaceFeatureClassEnum = "V"
)

func (e *GeonamesPlaceFeatureClassEnum) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return err
	}
	switch s {
	case "A":
		fallthrough
	case "H":
		fallthrough
	case "L":
		fallthrough
	case "P":
		fallthrough
	case "R":
		fallthrough
	case "S":
		fallthrough
	case "T":
		fallthrough
	case "U":
		fallthrough
	case "V":
		*e = GeonamesPlaceFeatureClassEnum(s)
		return nil
	default:
		return fmt.Errorf("invalid value for GeonamesPlaceFeatureClassEnum: %s", s)
	}
}

// GeonamesPlace - Full GeoNames place specification
type GeonamesPlace struct {
	// Fipscode (subject to change to iso code)
	Admin1Code string `json:"admin1_code"`
	// GeoName ID for first administrative area
	Admin1Geonameid int `json:"admin1_geonameid"`
	// Name of first administrative area
	Admin1Name string `json:"admin1_name"`
	// Code for the second administrative division
	Admin2Code string `json:"admin2_code"`
	// GeoName ID for second administrative area
	Admin2Geonameid int `json:"admin2_geonameid"`
	// Name of second administrative area
	Admin2Name string `json:"admin2_name"`
	// Code for third level administrative division
	Admin3Code string `json:"admin3_code"`
	// Code for fourth level administrative division
	Admin4Code string `json:"admin4_code"`
	// List of alternate ASCII names
	Alternatenames []GeonamesPlaceAlternatenames `json:"alternatenames"`
	// Place Name (ASCII)
	Asciiname string `json:"asciiname"`
	// List of other countries codes mapping to this place
	Cc2 []GeonamesPlaceCc2 `json:"cc2"`
	// 2 Letter ISO country code
	CountryCode string                    `json:"country_code"`
	Dataset     *GeonamesPlaceDatasetEnum `json:"dataset,omitempty"`
	// Digital elevation model
	Dem int `json:"dem"`
	// Elevation in meters
	Elevation int `json:"elevation"`
	// GeoNames single letter feature code
	FeatureClass GeonamesPlaceFeatureClassEnum `json:"feature_class"`
	// Full GeoNames feature code (http://www.geonames.org/export/codes.html)
	FeatureCode string `json:"feature_code"`
	// Unique identifier for GeoNames place
	Geonameid int `json:"geonameid"`
	// Unique place ID
	ID *string `json:"id,omitempty"`
	// The latitude of the postcode (WGS84/ETRS89).
	//
	// Can be a positive or negative decimal. E.g. `51.5083983`.
	//
	// Returns an empty string if no location data is available.
	Latitude Latitude `json:"latitude"`
	// The longitude of the postcode (WGS84/ETRS89).
	//
	// Can be a positive or negative decimal. E.g. -0.1283983
	//
	// Returns an empty string if no location data is available.
	Longitude Longitude `json:"longitude"`
	// Datetime format
	ModificationDate string `json:"modification_date"`
	// Place name (UTF8)
	Name string `json:"name"`
	// Population at place. Represented as string as it could be a larger than a 32bit integer
	Population string `json:"population"`
	// The IANA timezone ID
	Timezone string `json:"timezone"`
}
