"""Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT."""

import requests as requests_http
from . import utils
from sdk.models import operations, shared
from typing import Optional

SERVERS = [
    "https://preview.twilio.com",
]
"""Contains the list of servers available to the SDK"""

class SDK:
    r"""This is the public Twilio REST API."""

    _client: requests_http.Session
    _security_client: requests_http.Session
    _server_url: str = SERVERS[0]
    _language: str = "python"
    _sdk_version: str = "0.0.1"
    _gen_version: str = "internal"

    def __init__(self,
                 server_url: str = None,
                 url_params: dict[str, str] = None,
                 client: requests_http.Session = None
                 ) -> None:
        """Instantiates the SDK configuring it with the provided parameters.
        
        :param server_url: The server URL to use for all operations
        :type server_url: str
        :param url_params: Parameters to optionally template the server URL with
        :type url_params: dict[str, str]
        :param client: The requests.Session HTTP client to use for all operations
        :type client: requests_http.Session        
        """
        self._client = requests_http.Session()
        
        
        if server_url is not None:
            if url_params is not None:
                self._server_url = utils.template_url(server_url, url_params)
            else:
                self._server_url = server_url

        if client is not None:
            self._client = client
        
        self._security_client = self._client
        

        
    
    
    def create_deployed_devices_certificate(self, request: operations.CreateDeployedDevicesCertificateRequest, security: operations.CreateDeployedDevicesCertificateSecurity, server_url: Optional[str] = None) -> operations.CreateDeployedDevicesCertificateResponse:
        r"""Enroll a new Certificate credential to the Fleet, optionally giving it a friendly name and assigning to a Device."""
        base_url = operations.CREATE_DEPLOYED_DEVICES_CERTIFICATE_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.CreateDeployedDevicesCertificateRequest, base_url, '/DeployedDevices/Fleets/{FleetSid}/Certificates', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'form')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.CreateDeployedDevicesCertificateResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 201:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.PreviewDeployedDevicesFleetCertificate])
                res.preview_deployed_devices_fleet_certificate = out

        return res

    def create_deployed_devices_deployment(self, request: operations.CreateDeployedDevicesDeploymentRequest, security: operations.CreateDeployedDevicesDeploymentSecurity, server_url: Optional[str] = None) -> operations.CreateDeployedDevicesDeploymentResponse:
        r"""Create a new Deployment in the Fleet, optionally giving it a friendly name and linking to a specific Twilio Sync service instance."""
        base_url = operations.CREATE_DEPLOYED_DEVICES_DEPLOYMENT_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.CreateDeployedDevicesDeploymentRequest, base_url, '/DeployedDevices/Fleets/{FleetSid}/Deployments', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'form')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.CreateDeployedDevicesDeploymentResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 201:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.PreviewDeployedDevicesFleetDeployment])
                res.preview_deployed_devices_fleet_deployment = out

        return res

    def create_deployed_devices_device(self, request: operations.CreateDeployedDevicesDeviceRequest, security: operations.CreateDeployedDevicesDeviceSecurity, server_url: Optional[str] = None) -> operations.CreateDeployedDevicesDeviceResponse:
        r"""Create a new Device in the Fleet, optionally giving it a unique name, friendly name, and assigning to a Deployment and/or human identity."""
        base_url = operations.CREATE_DEPLOYED_DEVICES_DEVICE_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.CreateDeployedDevicesDeviceRequest, base_url, '/DeployedDevices/Fleets/{FleetSid}/Devices', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'form')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.CreateDeployedDevicesDeviceResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 201:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.PreviewDeployedDevicesFleetDevice])
                res.preview_deployed_devices_fleet_device = out

        return res

    def create_deployed_devices_fleet(self, request: operations.CreateDeployedDevicesFleetCreateDeployedDevicesFleetRequest, security: operations.CreateDeployedDevicesFleetSecurity, server_url: Optional[str] = None) -> operations.CreateDeployedDevicesFleetResponse:
        r"""Create a new Fleet for scoping of deployed devices within your account."""
        base_url = operations.CREATE_DEPLOYED_DEVICES_FLEET_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = base_url.removesuffix('/') + '/DeployedDevices/Fleets'
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request", 'form')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.CreateDeployedDevicesFleetResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 201:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.PreviewDeployedDevicesFleet])
                res.preview_deployed_devices_fleet = out

        return res

    def create_deployed_devices_key(self, request: operations.CreateDeployedDevicesKeyRequest, security: operations.CreateDeployedDevicesKeySecurity, server_url: Optional[str] = None) -> operations.CreateDeployedDevicesKeyResponse:
        r"""Create a new Key credential in the Fleet, optionally giving it a friendly name and assigning to a Device."""
        base_url = operations.CREATE_DEPLOYED_DEVICES_KEY_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.CreateDeployedDevicesKeyRequest, base_url, '/DeployedDevices/Fleets/{FleetSid}/Keys', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'form')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.CreateDeployedDevicesKeyResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 201:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.PreviewDeployedDevicesFleetKey])
                res.preview_deployed_devices_fleet_key = out

        return res

    def create_hosted_numbers_authorization_document(self, request: operations.CreateHostedNumbersAuthorizationDocumentCreateHostedNumbersAuthorizationDocumentRequest, security: operations.CreateHostedNumbersAuthorizationDocumentSecurity, server_url: Optional[str] = None) -> operations.CreateHostedNumbersAuthorizationDocumentResponse:
        r"""Create an AuthorizationDocument for authorizing the hosting of phone number capabilities on Twilio's platform."""
        base_url = operations.CREATE_HOSTED_NUMBERS_AUTHORIZATION_DOCUMENT_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = base_url.removesuffix('/') + '/HostedNumbers/AuthorizationDocuments'
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request", 'form')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.CreateHostedNumbersAuthorizationDocumentResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 201:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.PreviewHostedNumbersAuthorizationDocument])
                res.preview_hosted_numbers_authorization_document = out

        return res

    def create_hosted_numbers_hosted_number_order(self, request: operations.CreateHostedNumbersHostedNumberOrderCreateHostedNumbersHostedNumberOrderRequest, security: operations.CreateHostedNumbersHostedNumberOrderSecurity, server_url: Optional[str] = None) -> operations.CreateHostedNumbersHostedNumberOrderResponse:
        r"""Host a phone number's capability on Twilio's platform."""
        base_url = operations.CREATE_HOSTED_NUMBERS_HOSTED_NUMBER_ORDER_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = base_url.removesuffix('/') + '/HostedNumbers/HostedNumberOrders'
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request", 'form')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.CreateHostedNumbersHostedNumberOrderResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 201:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.PreviewHostedNumbersHostedNumberOrder])
                res.preview_hosted_numbers_hosted_number_order = out

        return res

    def create_marketplace_installed_add_on(self, request: operations.CreateMarketplaceInstalledAddOnCreateMarketplaceInstalledAddOnRequest, security: operations.CreateMarketplaceInstalledAddOnSecurity, server_url: Optional[str] = None) -> operations.CreateMarketplaceInstalledAddOnResponse:
        r"""Install an Add-on for the Account specified."""
        base_url = operations.CREATE_MARKETPLACE_INSTALLED_ADD_ON_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = base_url.removesuffix('/') + '/marketplace/InstalledAddOns'
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request", 'form')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.CreateMarketplaceInstalledAddOnResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 201:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.PreviewMarketplaceInstalledAddOn])
                res.preview_marketplace_installed_add_on = out

        return res

    def create_sync_document(self, request: operations.CreateSyncDocumentRequest, security: operations.CreateSyncDocumentSecurity, server_url: Optional[str] = None) -> operations.CreateSyncDocumentResponse:
        base_url = operations.CREATE_SYNC_DOCUMENT_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.CreateSyncDocumentRequest, base_url, '/Sync/Services/{ServiceSid}/Documents', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'form')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.CreateSyncDocumentResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 201:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.PreviewSyncServiceDocument])
                res.preview_sync_service_document = out

        return res

    def create_sync_service(self, request: operations.CreateSyncServiceCreateSyncServiceRequest, security: operations.CreateSyncServiceSecurity, server_url: Optional[str] = None) -> operations.CreateSyncServiceResponse:
        base_url = operations.CREATE_SYNC_SERVICE_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = base_url.removesuffix('/') + '/Sync/Services'
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request", 'form')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.CreateSyncServiceResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 201:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.PreviewSyncService])
                res.preview_sync_service = out

        return res

    def create_sync_sync_list(self, request: operations.CreateSyncSyncListRequest, security: operations.CreateSyncSyncListSecurity, server_url: Optional[str] = None) -> operations.CreateSyncSyncListResponse:
        base_url = operations.CREATE_SYNC_SYNC_LIST_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.CreateSyncSyncListRequest, base_url, '/Sync/Services/{ServiceSid}/Lists', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'form')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.CreateSyncSyncListResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 201:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.PreviewSyncServiceSyncList])
                res.preview_sync_service_sync_list = out

        return res

    def create_sync_sync_list_item(self, request: operations.CreateSyncSyncListItemRequest, security: operations.CreateSyncSyncListItemSecurity, server_url: Optional[str] = None) -> operations.CreateSyncSyncListItemResponse:
        base_url = operations.CREATE_SYNC_SYNC_LIST_ITEM_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.CreateSyncSyncListItemRequest, base_url, '/Sync/Services/{ServiceSid}/Lists/{ListSid}/Items', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'form')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.CreateSyncSyncListItemResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 201:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.PreviewSyncServiceSyncListSyncListItem])
                res.preview_sync_service_sync_list_sync_list_item = out

        return res

    def create_sync_sync_map(self, request: operations.CreateSyncSyncMapRequest, security: operations.CreateSyncSyncMapSecurity, server_url: Optional[str] = None) -> operations.CreateSyncSyncMapResponse:
        base_url = operations.CREATE_SYNC_SYNC_MAP_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.CreateSyncSyncMapRequest, base_url, '/Sync/Services/{ServiceSid}/Maps', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'form')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.CreateSyncSyncMapResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 201:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.PreviewSyncServiceSyncMap])
                res.preview_sync_service_sync_map = out

        return res

    def create_sync_sync_map_item(self, request: operations.CreateSyncSyncMapItemRequest, security: operations.CreateSyncSyncMapItemSecurity, server_url: Optional[str] = None) -> operations.CreateSyncSyncMapItemResponse:
        base_url = operations.CREATE_SYNC_SYNC_MAP_ITEM_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.CreateSyncSyncMapItemRequest, base_url, '/Sync/Services/{ServiceSid}/Maps/{MapSid}/Items', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'form')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.CreateSyncSyncMapItemResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 201:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.PreviewSyncServiceSyncMapSyncMapItem])
                res.preview_sync_service_sync_map_sync_map_item = out

        return res

    def create_understand_assistant(self, request: operations.CreateUnderstandAssistantCreateUnderstandAssistantRequest, security: operations.CreateUnderstandAssistantSecurity, server_url: Optional[str] = None) -> operations.CreateUnderstandAssistantResponse:
        base_url = operations.CREATE_UNDERSTAND_ASSISTANT_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = base_url.removesuffix('/') + '/understand/Assistants'
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request", 'form')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.CreateUnderstandAssistantResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 201:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.PreviewUnderstandAssistant])
                res.preview_understand_assistant = out

        return res

    def create_understand_field(self, request: operations.CreateUnderstandFieldRequest, security: operations.CreateUnderstandFieldSecurity, server_url: Optional[str] = None) -> operations.CreateUnderstandFieldResponse:
        base_url = operations.CREATE_UNDERSTAND_FIELD_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.CreateUnderstandFieldRequest, base_url, '/understand/Assistants/{AssistantSid}/Tasks/{TaskSid}/Fields', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'form')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.CreateUnderstandFieldResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 201:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.PreviewUnderstandAssistantTaskField])
                res.preview_understand_assistant_task_field = out

        return res

    def create_understand_field_type(self, request: operations.CreateUnderstandFieldTypeRequest, security: operations.CreateUnderstandFieldTypeSecurity, server_url: Optional[str] = None) -> operations.CreateUnderstandFieldTypeResponse:
        base_url = operations.CREATE_UNDERSTAND_FIELD_TYPE_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.CreateUnderstandFieldTypeRequest, base_url, '/understand/Assistants/{AssistantSid}/FieldTypes', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'form')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.CreateUnderstandFieldTypeResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 201:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.PreviewUnderstandAssistantFieldType])
                res.preview_understand_assistant_field_type = out

        return res

    def create_understand_field_value(self, request: operations.CreateUnderstandFieldValueRequest, security: operations.CreateUnderstandFieldValueSecurity, server_url: Optional[str] = None) -> operations.CreateUnderstandFieldValueResponse:
        base_url = operations.CREATE_UNDERSTAND_FIELD_VALUE_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.CreateUnderstandFieldValueRequest, base_url, '/understand/Assistants/{AssistantSid}/FieldTypes/{FieldTypeSid}/FieldValues', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'form')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.CreateUnderstandFieldValueResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 201:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.PreviewUnderstandAssistantFieldTypeFieldValue])
                res.preview_understand_assistant_field_type_field_value = out

        return res

    def create_understand_model_build(self, request: operations.CreateUnderstandModelBuildRequest, security: operations.CreateUnderstandModelBuildSecurity, server_url: Optional[str] = None) -> operations.CreateUnderstandModelBuildResponse:
        base_url = operations.CREATE_UNDERSTAND_MODEL_BUILD_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.CreateUnderstandModelBuildRequest, base_url, '/understand/Assistants/{AssistantSid}/ModelBuilds', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'form')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.CreateUnderstandModelBuildResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 201:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.PreviewUnderstandAssistantModelBuild])
                res.preview_understand_assistant_model_build = out

        return res

    def create_understand_query(self, request: operations.CreateUnderstandQueryRequest, security: operations.CreateUnderstandQuerySecurity, server_url: Optional[str] = None) -> operations.CreateUnderstandQueryResponse:
        base_url = operations.CREATE_UNDERSTAND_QUERY_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.CreateUnderstandQueryRequest, base_url, '/understand/Assistants/{AssistantSid}/Queries', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'form')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.CreateUnderstandQueryResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 201:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.PreviewUnderstandAssistantQuery])
                res.preview_understand_assistant_query = out

        return res

    def create_understand_sample(self, request: operations.CreateUnderstandSampleRequest, security: operations.CreateUnderstandSampleSecurity, server_url: Optional[str] = None) -> operations.CreateUnderstandSampleResponse:
        base_url = operations.CREATE_UNDERSTAND_SAMPLE_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.CreateUnderstandSampleRequest, base_url, '/understand/Assistants/{AssistantSid}/Tasks/{TaskSid}/Samples', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'form')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.CreateUnderstandSampleResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 201:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.PreviewUnderstandAssistantTaskSample])
                res.preview_understand_assistant_task_sample = out

        return res

    def create_understand_task(self, request: operations.CreateUnderstandTaskRequest, security: operations.CreateUnderstandTaskSecurity, server_url: Optional[str] = None) -> operations.CreateUnderstandTaskResponse:
        base_url = operations.CREATE_UNDERSTAND_TASK_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.CreateUnderstandTaskRequest, base_url, '/understand/Assistants/{AssistantSid}/Tasks', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'form')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.CreateUnderstandTaskResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 201:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.PreviewUnderstandAssistantTask])
                res.preview_understand_assistant_task = out

        return res

    def create_wireless_command(self, request: operations.CreateWirelessCommandCreateWirelessCommandRequest, security: operations.CreateWirelessCommandSecurity, server_url: Optional[str] = None) -> operations.CreateWirelessCommandResponse:
        base_url = operations.CREATE_WIRELESS_COMMAND_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = base_url.removesuffix('/') + '/wireless/Commands'
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request", 'form')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.CreateWirelessCommandResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 201:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.PreviewWirelessCommand])
                res.preview_wireless_command = out

        return res

    def create_wireless_rate_plan(self, request: operations.CreateWirelessRatePlanCreateWirelessRatePlanRequest, security: operations.CreateWirelessRatePlanSecurity, server_url: Optional[str] = None) -> operations.CreateWirelessRatePlanResponse:
        base_url = operations.CREATE_WIRELESS_RATE_PLAN_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = base_url.removesuffix('/') + '/wireless/RatePlans'
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request", 'form')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.CreateWirelessRatePlanResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 201:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.PreviewWirelessRatePlan])
                res.preview_wireless_rate_plan = out

        return res

    def delete_deployed_devices_certificate(self, request: operations.DeleteDeployedDevicesCertificateRequest, security: operations.DeleteDeployedDevicesCertificateSecurity, server_url: Optional[str] = None) -> operations.DeleteDeployedDevicesCertificateResponse:
        r"""Unregister a specific Certificate credential from the Fleet, effectively disallowing any inbound client connections that are presenting it."""
        base_url = operations.DELETE_DEPLOYED_DEVICES_CERTIFICATE_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.DeleteDeployedDevicesCertificateRequest, base_url, '/DeployedDevices/Fleets/{FleetSid}/Certificates/{Sid}', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('DELETE', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DeleteDeployedDevicesCertificateResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        

        return res

    def delete_deployed_devices_deployment(self, request: operations.DeleteDeployedDevicesDeploymentRequest, security: operations.DeleteDeployedDevicesDeploymentSecurity, server_url: Optional[str] = None) -> operations.DeleteDeployedDevicesDeploymentResponse:
        r"""Delete a specific Deployment from the Fleet, leaving associated devices effectively undeployed."""
        base_url = operations.DELETE_DEPLOYED_DEVICES_DEPLOYMENT_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.DeleteDeployedDevicesDeploymentRequest, base_url, '/DeployedDevices/Fleets/{FleetSid}/Deployments/{Sid}', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('DELETE', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DeleteDeployedDevicesDeploymentResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        

        return res

    def delete_deployed_devices_device(self, request: operations.DeleteDeployedDevicesDeviceRequest, security: operations.DeleteDeployedDevicesDeviceSecurity, server_url: Optional[str] = None) -> operations.DeleteDeployedDevicesDeviceResponse:
        r"""Delete a specific Device from the Fleet, also removing it from associated Deployments."""
        base_url = operations.DELETE_DEPLOYED_DEVICES_DEVICE_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.DeleteDeployedDevicesDeviceRequest, base_url, '/DeployedDevices/Fleets/{FleetSid}/Devices/{Sid}', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('DELETE', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DeleteDeployedDevicesDeviceResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        

        return res

    def delete_deployed_devices_fleet(self, request: operations.DeleteDeployedDevicesFleetRequest, security: operations.DeleteDeployedDevicesFleetSecurity, server_url: Optional[str] = None) -> operations.DeleteDeployedDevicesFleetResponse:
        r"""Delete a specific Fleet from your account, also destroys all nested resources: Devices, Deployments, Certificates, Keys."""
        base_url = operations.DELETE_DEPLOYED_DEVICES_FLEET_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.DeleteDeployedDevicesFleetRequest, base_url, '/DeployedDevices/Fleets/{Sid}', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('DELETE', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DeleteDeployedDevicesFleetResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        

        return res

    def delete_deployed_devices_key(self, request: operations.DeleteDeployedDevicesKeyRequest, security: operations.DeleteDeployedDevicesKeySecurity, server_url: Optional[str] = None) -> operations.DeleteDeployedDevicesKeyResponse:
        r"""Delete a specific Key credential from the Fleet, effectively disallowing any inbound client connections that are presenting it."""
        base_url = operations.DELETE_DEPLOYED_DEVICES_KEY_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.DeleteDeployedDevicesKeyRequest, base_url, '/DeployedDevices/Fleets/{FleetSid}/Keys/{Sid}', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('DELETE', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DeleteDeployedDevicesKeyResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        

        return res

    def delete_hosted_numbers_hosted_number_order(self, request: operations.DeleteHostedNumbersHostedNumberOrderRequest, security: operations.DeleteHostedNumbersHostedNumberOrderSecurity, server_url: Optional[str] = None) -> operations.DeleteHostedNumbersHostedNumberOrderResponse:
        r"""Cancel the HostedNumberOrder (only available when the status is in `received`)."""
        base_url = operations.DELETE_HOSTED_NUMBERS_HOSTED_NUMBER_ORDER_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.DeleteHostedNumbersHostedNumberOrderRequest, base_url, '/HostedNumbers/HostedNumberOrders/{Sid}', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('DELETE', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DeleteHostedNumbersHostedNumberOrderResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        

        return res

    def delete_marketplace_installed_add_on(self, request: operations.DeleteMarketplaceInstalledAddOnRequest, security: operations.DeleteMarketplaceInstalledAddOnSecurity, server_url: Optional[str] = None) -> operations.DeleteMarketplaceInstalledAddOnResponse:
        r"""Remove an Add-on installation from your account"""
        base_url = operations.DELETE_MARKETPLACE_INSTALLED_ADD_ON_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.DeleteMarketplaceInstalledAddOnRequest, base_url, '/marketplace/InstalledAddOns/{Sid}', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('DELETE', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DeleteMarketplaceInstalledAddOnResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        

        return res

    def delete_sync_document(self, request: operations.DeleteSyncDocumentRequest, security: operations.DeleteSyncDocumentSecurity, server_url: Optional[str] = None) -> operations.DeleteSyncDocumentResponse:
        base_url = operations.DELETE_SYNC_DOCUMENT_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.DeleteSyncDocumentRequest, base_url, '/Sync/Services/{ServiceSid}/Documents/{Sid}', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('DELETE', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DeleteSyncDocumentResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        

        return res

    def delete_sync_document_permission(self, request: operations.DeleteSyncDocumentPermissionRequest, security: operations.DeleteSyncDocumentPermissionSecurity, server_url: Optional[str] = None) -> operations.DeleteSyncDocumentPermissionResponse:
        r"""Delete a specific Sync Document Permission."""
        base_url = operations.DELETE_SYNC_DOCUMENT_PERMISSION_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.DeleteSyncDocumentPermissionRequest, base_url, '/Sync/Services/{ServiceSid}/Documents/{DocumentSid}/Permissions/{Identity}', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('DELETE', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DeleteSyncDocumentPermissionResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        

        return res

    def delete_sync_service(self, request: operations.DeleteSyncServiceRequest, security: operations.DeleteSyncServiceSecurity, server_url: Optional[str] = None) -> operations.DeleteSyncServiceResponse:
        base_url = operations.DELETE_SYNC_SERVICE_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.DeleteSyncServiceRequest, base_url, '/Sync/Services/{Sid}', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('DELETE', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DeleteSyncServiceResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        

        return res

    def delete_sync_sync_list(self, request: operations.DeleteSyncSyncListRequest, security: operations.DeleteSyncSyncListSecurity, server_url: Optional[str] = None) -> operations.DeleteSyncSyncListResponse:
        base_url = operations.DELETE_SYNC_SYNC_LIST_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.DeleteSyncSyncListRequest, base_url, '/Sync/Services/{ServiceSid}/Lists/{Sid}', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('DELETE', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DeleteSyncSyncListResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        

        return res

    def delete_sync_sync_list_item(self, request: operations.DeleteSyncSyncListItemRequest, security: operations.DeleteSyncSyncListItemSecurity, server_url: Optional[str] = None) -> operations.DeleteSyncSyncListItemResponse:
        base_url = operations.DELETE_SYNC_SYNC_LIST_ITEM_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.DeleteSyncSyncListItemRequest, base_url, '/Sync/Services/{ServiceSid}/Lists/{ListSid}/Items/{Index}', request)
        
        headers = utils.get_headers(request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('DELETE', url, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DeleteSyncSyncListItemResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        

        return res

    def delete_sync_sync_list_permission(self, request: operations.DeleteSyncSyncListPermissionRequest, security: operations.DeleteSyncSyncListPermissionSecurity, server_url: Optional[str] = None) -> operations.DeleteSyncSyncListPermissionResponse:
        r"""Delete a specific Sync List Permission."""
        base_url = operations.DELETE_SYNC_SYNC_LIST_PERMISSION_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.DeleteSyncSyncListPermissionRequest, base_url, '/Sync/Services/{ServiceSid}/Lists/{ListSid}/Permissions/{Identity}', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('DELETE', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DeleteSyncSyncListPermissionResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        

        return res

    def delete_sync_sync_map(self, request: operations.DeleteSyncSyncMapRequest, security: operations.DeleteSyncSyncMapSecurity, server_url: Optional[str] = None) -> operations.DeleteSyncSyncMapResponse:
        base_url = operations.DELETE_SYNC_SYNC_MAP_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.DeleteSyncSyncMapRequest, base_url, '/Sync/Services/{ServiceSid}/Maps/{Sid}', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('DELETE', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DeleteSyncSyncMapResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        

        return res

    def delete_sync_sync_map_item(self, request: operations.DeleteSyncSyncMapItemRequest, security: operations.DeleteSyncSyncMapItemSecurity, server_url: Optional[str] = None) -> operations.DeleteSyncSyncMapItemResponse:
        base_url = operations.DELETE_SYNC_SYNC_MAP_ITEM_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.DeleteSyncSyncMapItemRequest, base_url, '/Sync/Services/{ServiceSid}/Maps/{MapSid}/Items/{Key}', request)
        
        headers = utils.get_headers(request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('DELETE', url, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DeleteSyncSyncMapItemResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        

        return res

    def delete_sync_sync_map_permission(self, request: operations.DeleteSyncSyncMapPermissionRequest, security: operations.DeleteSyncSyncMapPermissionSecurity, server_url: Optional[str] = None) -> operations.DeleteSyncSyncMapPermissionResponse:
        r"""Delete a specific Sync Map Permission."""
        base_url = operations.DELETE_SYNC_SYNC_MAP_PERMISSION_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.DeleteSyncSyncMapPermissionRequest, base_url, '/Sync/Services/{ServiceSid}/Maps/{MapSid}/Permissions/{Identity}', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('DELETE', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DeleteSyncSyncMapPermissionResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        

        return res

    def delete_understand_assistant(self, request: operations.DeleteUnderstandAssistantRequest, security: operations.DeleteUnderstandAssistantSecurity, server_url: Optional[str] = None) -> operations.DeleteUnderstandAssistantResponse:
        base_url = operations.DELETE_UNDERSTAND_ASSISTANT_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.DeleteUnderstandAssistantRequest, base_url, '/understand/Assistants/{Sid}', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('DELETE', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DeleteUnderstandAssistantResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        

        return res

    def delete_understand_field(self, request: operations.DeleteUnderstandFieldRequest, security: operations.DeleteUnderstandFieldSecurity, server_url: Optional[str] = None) -> operations.DeleteUnderstandFieldResponse:
        base_url = operations.DELETE_UNDERSTAND_FIELD_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.DeleteUnderstandFieldRequest, base_url, '/understand/Assistants/{AssistantSid}/Tasks/{TaskSid}/Fields/{Sid}', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('DELETE', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DeleteUnderstandFieldResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        

        return res

    def delete_understand_field_type(self, request: operations.DeleteUnderstandFieldTypeRequest, security: operations.DeleteUnderstandFieldTypeSecurity, server_url: Optional[str] = None) -> operations.DeleteUnderstandFieldTypeResponse:
        base_url = operations.DELETE_UNDERSTAND_FIELD_TYPE_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.DeleteUnderstandFieldTypeRequest, base_url, '/understand/Assistants/{AssistantSid}/FieldTypes/{Sid}', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('DELETE', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DeleteUnderstandFieldTypeResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        

        return res

    def delete_understand_field_value(self, request: operations.DeleteUnderstandFieldValueRequest, security: operations.DeleteUnderstandFieldValueSecurity, server_url: Optional[str] = None) -> operations.DeleteUnderstandFieldValueResponse:
        base_url = operations.DELETE_UNDERSTAND_FIELD_VALUE_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.DeleteUnderstandFieldValueRequest, base_url, '/understand/Assistants/{AssistantSid}/FieldTypes/{FieldTypeSid}/FieldValues/{Sid}', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('DELETE', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DeleteUnderstandFieldValueResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        

        return res

    def delete_understand_model_build(self, request: operations.DeleteUnderstandModelBuildRequest, security: operations.DeleteUnderstandModelBuildSecurity, server_url: Optional[str] = None) -> operations.DeleteUnderstandModelBuildResponse:
        base_url = operations.DELETE_UNDERSTAND_MODEL_BUILD_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.DeleteUnderstandModelBuildRequest, base_url, '/understand/Assistants/{AssistantSid}/ModelBuilds/{Sid}', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('DELETE', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DeleteUnderstandModelBuildResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        

        return res

    def delete_understand_query(self, request: operations.DeleteUnderstandQueryRequest, security: operations.DeleteUnderstandQuerySecurity, server_url: Optional[str] = None) -> operations.DeleteUnderstandQueryResponse:
        base_url = operations.DELETE_UNDERSTAND_QUERY_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.DeleteUnderstandQueryRequest, base_url, '/understand/Assistants/{AssistantSid}/Queries/{Sid}', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('DELETE', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DeleteUnderstandQueryResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        

        return res

    def delete_understand_sample(self, request: operations.DeleteUnderstandSampleRequest, security: operations.DeleteUnderstandSampleSecurity, server_url: Optional[str] = None) -> operations.DeleteUnderstandSampleResponse:
        base_url = operations.DELETE_UNDERSTAND_SAMPLE_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.DeleteUnderstandSampleRequest, base_url, '/understand/Assistants/{AssistantSid}/Tasks/{TaskSid}/Samples/{Sid}', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('DELETE', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DeleteUnderstandSampleResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        

        return res

    def delete_understand_task(self, request: operations.DeleteUnderstandTaskRequest, security: operations.DeleteUnderstandTaskSecurity, server_url: Optional[str] = None) -> operations.DeleteUnderstandTaskResponse:
        base_url = operations.DELETE_UNDERSTAND_TASK_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.DeleteUnderstandTaskRequest, base_url, '/understand/Assistants/{AssistantSid}/Tasks/{Sid}', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('DELETE', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DeleteUnderstandTaskResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        

        return res

    def delete_wireless_rate_plan(self, request: operations.DeleteWirelessRatePlanRequest, security: operations.DeleteWirelessRatePlanSecurity, server_url: Optional[str] = None) -> operations.DeleteWirelessRatePlanResponse:
        base_url = operations.DELETE_WIRELESS_RATE_PLAN_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.DeleteWirelessRatePlanRequest, base_url, '/wireless/RatePlans/{Sid}', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('DELETE', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DeleteWirelessRatePlanResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        

        return res

    def fetch_deployed_devices_certificate(self, request: operations.FetchDeployedDevicesCertificateRequest, security: operations.FetchDeployedDevicesCertificateSecurity, server_url: Optional[str] = None) -> operations.FetchDeployedDevicesCertificateResponse:
        r"""Fetch information about a specific Certificate credential in the Fleet."""
        base_url = operations.FETCH_DEPLOYED_DEVICES_CERTIFICATE_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.FetchDeployedDevicesCertificateRequest, base_url, '/DeployedDevices/Fleets/{FleetSid}/Certificates/{Sid}', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.FetchDeployedDevicesCertificateResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.PreviewDeployedDevicesFleetCertificate])
                res.preview_deployed_devices_fleet_certificate = out

        return res

    def fetch_deployed_devices_deployment(self, request: operations.FetchDeployedDevicesDeploymentRequest, security: operations.FetchDeployedDevicesDeploymentSecurity, server_url: Optional[str] = None) -> operations.FetchDeployedDevicesDeploymentResponse:
        r"""Fetch information about a specific Deployment in the Fleet."""
        base_url = operations.FETCH_DEPLOYED_DEVICES_DEPLOYMENT_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.FetchDeployedDevicesDeploymentRequest, base_url, '/DeployedDevices/Fleets/{FleetSid}/Deployments/{Sid}', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.FetchDeployedDevicesDeploymentResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.PreviewDeployedDevicesFleetDeployment])
                res.preview_deployed_devices_fleet_deployment = out

        return res

    def fetch_deployed_devices_device(self, request: operations.FetchDeployedDevicesDeviceRequest, security: operations.FetchDeployedDevicesDeviceSecurity, server_url: Optional[str] = None) -> operations.FetchDeployedDevicesDeviceResponse:
        r"""Fetch information about a specific Device in the Fleet."""
        base_url = operations.FETCH_DEPLOYED_DEVICES_DEVICE_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.FetchDeployedDevicesDeviceRequest, base_url, '/DeployedDevices/Fleets/{FleetSid}/Devices/{Sid}', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.FetchDeployedDevicesDeviceResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.PreviewDeployedDevicesFleetDevice])
                res.preview_deployed_devices_fleet_device = out

        return res

    def fetch_deployed_devices_fleet(self, request: operations.FetchDeployedDevicesFleetRequest, security: operations.FetchDeployedDevicesFleetSecurity, server_url: Optional[str] = None) -> operations.FetchDeployedDevicesFleetResponse:
        r"""Fetch information about a specific Fleet in your account."""
        base_url = operations.FETCH_DEPLOYED_DEVICES_FLEET_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.FetchDeployedDevicesFleetRequest, base_url, '/DeployedDevices/Fleets/{Sid}', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.FetchDeployedDevicesFleetResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.PreviewDeployedDevicesFleet])
                res.preview_deployed_devices_fleet = out

        return res

    def fetch_deployed_devices_key(self, request: operations.FetchDeployedDevicesKeyRequest, security: operations.FetchDeployedDevicesKeySecurity, server_url: Optional[str] = None) -> operations.FetchDeployedDevicesKeyResponse:
        r"""Fetch information about a specific Key credential in the Fleet."""
        base_url = operations.FETCH_DEPLOYED_DEVICES_KEY_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.FetchDeployedDevicesKeyRequest, base_url, '/DeployedDevices/Fleets/{FleetSid}/Keys/{Sid}', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.FetchDeployedDevicesKeyResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.PreviewDeployedDevicesFleetKey])
                res.preview_deployed_devices_fleet_key = out

        return res

    def fetch_hosted_numbers_authorization_document(self, request: operations.FetchHostedNumbersAuthorizationDocumentRequest, security: operations.FetchHostedNumbersAuthorizationDocumentSecurity, server_url: Optional[str] = None) -> operations.FetchHostedNumbersAuthorizationDocumentResponse:
        r"""Fetch a specific AuthorizationDocument."""
        base_url = operations.FETCH_HOSTED_NUMBERS_AUTHORIZATION_DOCUMENT_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.FetchHostedNumbersAuthorizationDocumentRequest, base_url, '/HostedNumbers/AuthorizationDocuments/{Sid}', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.FetchHostedNumbersAuthorizationDocumentResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.PreviewHostedNumbersAuthorizationDocument])
                res.preview_hosted_numbers_authorization_document = out

        return res

    def fetch_hosted_numbers_hosted_number_order(self, request: operations.FetchHostedNumbersHostedNumberOrderRequest, security: operations.FetchHostedNumbersHostedNumberOrderSecurity, server_url: Optional[str] = None) -> operations.FetchHostedNumbersHostedNumberOrderResponse:
        r"""Fetch a specific HostedNumberOrder."""
        base_url = operations.FETCH_HOSTED_NUMBERS_HOSTED_NUMBER_ORDER_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.FetchHostedNumbersHostedNumberOrderRequest, base_url, '/HostedNumbers/HostedNumberOrders/{Sid}', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.FetchHostedNumbersHostedNumberOrderResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.PreviewHostedNumbersHostedNumberOrder])
                res.preview_hosted_numbers_hosted_number_order = out

        return res

    def fetch_marketplace_available_add_on(self, request: operations.FetchMarketplaceAvailableAddOnRequest, security: operations.FetchMarketplaceAvailableAddOnSecurity, server_url: Optional[str] = None) -> operations.FetchMarketplaceAvailableAddOnResponse:
        r"""Fetch an instance of an Add-on currently available to be installed."""
        base_url = operations.FETCH_MARKETPLACE_AVAILABLE_ADD_ON_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.FetchMarketplaceAvailableAddOnRequest, base_url, '/marketplace/AvailableAddOns/{Sid}', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.FetchMarketplaceAvailableAddOnResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.PreviewMarketplaceAvailableAddOn])
                res.preview_marketplace_available_add_on = out

        return res

    def fetch_marketplace_available_add_on_extension(self, request: operations.FetchMarketplaceAvailableAddOnExtensionRequest, security: operations.FetchMarketplaceAvailableAddOnExtensionSecurity, server_url: Optional[str] = None) -> operations.FetchMarketplaceAvailableAddOnExtensionResponse:
        r"""Fetch an instance of an Extension for the Available Add-on."""
        base_url = operations.FETCH_MARKETPLACE_AVAILABLE_ADD_ON_EXTENSION_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.FetchMarketplaceAvailableAddOnExtensionRequest, base_url, '/marketplace/AvailableAddOns/{AvailableAddOnSid}/Extensions/{Sid}', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.FetchMarketplaceAvailableAddOnExtensionResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.PreviewMarketplaceAvailableAddOnAvailableAddOnExtension])
                res.preview_marketplace_available_add_on_available_add_on_extension = out

        return res

    def fetch_marketplace_installed_add_on(self, request: operations.FetchMarketplaceInstalledAddOnRequest, security: operations.FetchMarketplaceInstalledAddOnSecurity, server_url: Optional[str] = None) -> operations.FetchMarketplaceInstalledAddOnResponse:
        r"""Fetch an instance of an Add-on currently installed on this Account."""
        base_url = operations.FETCH_MARKETPLACE_INSTALLED_ADD_ON_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.FetchMarketplaceInstalledAddOnRequest, base_url, '/marketplace/InstalledAddOns/{Sid}', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.FetchMarketplaceInstalledAddOnResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.PreviewMarketplaceInstalledAddOn])
                res.preview_marketplace_installed_add_on = out

        return res

    def fetch_marketplace_installed_add_on_extension(self, request: operations.FetchMarketplaceInstalledAddOnExtensionRequest, security: operations.FetchMarketplaceInstalledAddOnExtensionSecurity, server_url: Optional[str] = None) -> operations.FetchMarketplaceInstalledAddOnExtensionResponse:
        r"""Fetch an instance of an Extension for the Installed Add-on."""
        base_url = operations.FETCH_MARKETPLACE_INSTALLED_ADD_ON_EXTENSION_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.FetchMarketplaceInstalledAddOnExtensionRequest, base_url, '/marketplace/InstalledAddOns/{InstalledAddOnSid}/Extensions/{Sid}', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.FetchMarketplaceInstalledAddOnExtensionResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.PreviewMarketplaceInstalledAddOnInstalledAddOnExtension])
                res.preview_marketplace_installed_add_on_installed_add_on_extension = out

        return res

    def fetch_sync_document(self, request: operations.FetchSyncDocumentRequest, security: operations.FetchSyncDocumentSecurity, server_url: Optional[str] = None) -> operations.FetchSyncDocumentResponse:
        base_url = operations.FETCH_SYNC_DOCUMENT_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.FetchSyncDocumentRequest, base_url, '/Sync/Services/{ServiceSid}/Documents/{Sid}', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.FetchSyncDocumentResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.PreviewSyncServiceDocument])
                res.preview_sync_service_document = out

        return res

    def fetch_sync_document_permission(self, request: operations.FetchSyncDocumentPermissionRequest, security: operations.FetchSyncDocumentPermissionSecurity, server_url: Optional[str] = None) -> operations.FetchSyncDocumentPermissionResponse:
        r"""Fetch a specific Sync Document Permission."""
        base_url = operations.FETCH_SYNC_DOCUMENT_PERMISSION_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.FetchSyncDocumentPermissionRequest, base_url, '/Sync/Services/{ServiceSid}/Documents/{DocumentSid}/Permissions/{Identity}', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.FetchSyncDocumentPermissionResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.PreviewSyncServiceDocumentDocumentPermission])
                res.preview_sync_service_document_document_permission = out

        return res

    def fetch_sync_service(self, request: operations.FetchSyncServiceRequest, security: operations.FetchSyncServiceSecurity, server_url: Optional[str] = None) -> operations.FetchSyncServiceResponse:
        base_url = operations.FETCH_SYNC_SERVICE_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.FetchSyncServiceRequest, base_url, '/Sync/Services/{Sid}', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.FetchSyncServiceResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.PreviewSyncService])
                res.preview_sync_service = out

        return res

    def fetch_sync_sync_list(self, request: operations.FetchSyncSyncListRequest, security: operations.FetchSyncSyncListSecurity, server_url: Optional[str] = None) -> operations.FetchSyncSyncListResponse:
        base_url = operations.FETCH_SYNC_SYNC_LIST_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.FetchSyncSyncListRequest, base_url, '/Sync/Services/{ServiceSid}/Lists/{Sid}', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.FetchSyncSyncListResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.PreviewSyncServiceSyncList])
                res.preview_sync_service_sync_list = out

        return res

    def fetch_sync_sync_list_item(self, request: operations.FetchSyncSyncListItemRequest, security: operations.FetchSyncSyncListItemSecurity, server_url: Optional[str] = None) -> operations.FetchSyncSyncListItemResponse:
        base_url = operations.FETCH_SYNC_SYNC_LIST_ITEM_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.FetchSyncSyncListItemRequest, base_url, '/Sync/Services/{ServiceSid}/Lists/{ListSid}/Items/{Index}', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.FetchSyncSyncListItemResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.PreviewSyncServiceSyncListSyncListItem])
                res.preview_sync_service_sync_list_sync_list_item = out

        return res

    def fetch_sync_sync_list_permission(self, request: operations.FetchSyncSyncListPermissionRequest, security: operations.FetchSyncSyncListPermissionSecurity, server_url: Optional[str] = None) -> operations.FetchSyncSyncListPermissionResponse:
        r"""Fetch a specific Sync List Permission."""
        base_url = operations.FETCH_SYNC_SYNC_LIST_PERMISSION_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.FetchSyncSyncListPermissionRequest, base_url, '/Sync/Services/{ServiceSid}/Lists/{ListSid}/Permissions/{Identity}', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.FetchSyncSyncListPermissionResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.PreviewSyncServiceSyncListSyncListPermission])
                res.preview_sync_service_sync_list_sync_list_permission = out

        return res

    def fetch_sync_sync_map(self, request: operations.FetchSyncSyncMapRequest, security: operations.FetchSyncSyncMapSecurity, server_url: Optional[str] = None) -> operations.FetchSyncSyncMapResponse:
        base_url = operations.FETCH_SYNC_SYNC_MAP_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.FetchSyncSyncMapRequest, base_url, '/Sync/Services/{ServiceSid}/Maps/{Sid}', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.FetchSyncSyncMapResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.PreviewSyncServiceSyncMap])
                res.preview_sync_service_sync_map = out

        return res

    def fetch_sync_sync_map_item(self, request: operations.FetchSyncSyncMapItemRequest, security: operations.FetchSyncSyncMapItemSecurity, server_url: Optional[str] = None) -> operations.FetchSyncSyncMapItemResponse:
        base_url = operations.FETCH_SYNC_SYNC_MAP_ITEM_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.FetchSyncSyncMapItemRequest, base_url, '/Sync/Services/{ServiceSid}/Maps/{MapSid}/Items/{Key}', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.FetchSyncSyncMapItemResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.PreviewSyncServiceSyncMapSyncMapItem])
                res.preview_sync_service_sync_map_sync_map_item = out

        return res

    def fetch_sync_sync_map_permission(self, request: operations.FetchSyncSyncMapPermissionRequest, security: operations.FetchSyncSyncMapPermissionSecurity, server_url: Optional[str] = None) -> operations.FetchSyncSyncMapPermissionResponse:
        r"""Fetch a specific Sync Map Permission."""
        base_url = operations.FETCH_SYNC_SYNC_MAP_PERMISSION_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.FetchSyncSyncMapPermissionRequest, base_url, '/Sync/Services/{ServiceSid}/Maps/{MapSid}/Permissions/{Identity}', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.FetchSyncSyncMapPermissionResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.PreviewSyncServiceSyncMapSyncMapPermission])
                res.preview_sync_service_sync_map_sync_map_permission = out

        return res

    def fetch_understand_assistant(self, request: operations.FetchUnderstandAssistantRequest, security: operations.FetchUnderstandAssistantSecurity, server_url: Optional[str] = None) -> operations.FetchUnderstandAssistantResponse:
        base_url = operations.FETCH_UNDERSTAND_ASSISTANT_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.FetchUnderstandAssistantRequest, base_url, '/understand/Assistants/{Sid}', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.FetchUnderstandAssistantResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.PreviewUnderstandAssistant])
                res.preview_understand_assistant = out

        return res

    def fetch_understand_assistant_fallback_actions(self, request: operations.FetchUnderstandAssistantFallbackActionsRequest, security: operations.FetchUnderstandAssistantFallbackActionsSecurity, server_url: Optional[str] = None) -> operations.FetchUnderstandAssistantFallbackActionsResponse:
        base_url = operations.FETCH_UNDERSTAND_ASSISTANT_FALLBACK_ACTIONS_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.FetchUnderstandAssistantFallbackActionsRequest, base_url, '/understand/Assistants/{AssistantSid}/FallbackActions', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.FetchUnderstandAssistantFallbackActionsResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.PreviewUnderstandAssistantAssistantFallbackActions])
                res.preview_understand_assistant_assistant_fallback_actions = out

        return res

    def fetch_understand_assistant_initiation_actions(self, request: operations.FetchUnderstandAssistantInitiationActionsRequest, security: operations.FetchUnderstandAssistantInitiationActionsSecurity, server_url: Optional[str] = None) -> operations.FetchUnderstandAssistantInitiationActionsResponse:
        base_url = operations.FETCH_UNDERSTAND_ASSISTANT_INITIATION_ACTIONS_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.FetchUnderstandAssistantInitiationActionsRequest, base_url, '/understand/Assistants/{AssistantSid}/InitiationActions', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.FetchUnderstandAssistantInitiationActionsResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.PreviewUnderstandAssistantAssistantInitiationActions])
                res.preview_understand_assistant_assistant_initiation_actions = out

        return res

    def fetch_understand_dialogue(self, request: operations.FetchUnderstandDialogueRequest, security: operations.FetchUnderstandDialogueSecurity, server_url: Optional[str] = None) -> operations.FetchUnderstandDialogueResponse:
        base_url = operations.FETCH_UNDERSTAND_DIALOGUE_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.FetchUnderstandDialogueRequest, base_url, '/understand/Assistants/{AssistantSid}/Dialogues/{Sid}', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.FetchUnderstandDialogueResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.PreviewUnderstandAssistantDialogue])
                res.preview_understand_assistant_dialogue = out

        return res

    def fetch_understand_field(self, request: operations.FetchUnderstandFieldRequest, security: operations.FetchUnderstandFieldSecurity, server_url: Optional[str] = None) -> operations.FetchUnderstandFieldResponse:
        base_url = operations.FETCH_UNDERSTAND_FIELD_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.FetchUnderstandFieldRequest, base_url, '/understand/Assistants/{AssistantSid}/Tasks/{TaskSid}/Fields/{Sid}', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.FetchUnderstandFieldResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.PreviewUnderstandAssistantTaskField])
                res.preview_understand_assistant_task_field = out

        return res

    def fetch_understand_field_type(self, request: operations.FetchUnderstandFieldTypeRequest, security: operations.FetchUnderstandFieldTypeSecurity, server_url: Optional[str] = None) -> operations.FetchUnderstandFieldTypeResponse:
        base_url = operations.FETCH_UNDERSTAND_FIELD_TYPE_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.FetchUnderstandFieldTypeRequest, base_url, '/understand/Assistants/{AssistantSid}/FieldTypes/{Sid}', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.FetchUnderstandFieldTypeResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.PreviewUnderstandAssistantFieldType])
                res.preview_understand_assistant_field_type = out

        return res

    def fetch_understand_field_value(self, request: operations.FetchUnderstandFieldValueRequest, security: operations.FetchUnderstandFieldValueSecurity, server_url: Optional[str] = None) -> operations.FetchUnderstandFieldValueResponse:
        base_url = operations.FETCH_UNDERSTAND_FIELD_VALUE_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.FetchUnderstandFieldValueRequest, base_url, '/understand/Assistants/{AssistantSid}/FieldTypes/{FieldTypeSid}/FieldValues/{Sid}', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.FetchUnderstandFieldValueResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.PreviewUnderstandAssistantFieldTypeFieldValue])
                res.preview_understand_assistant_field_type_field_value = out

        return res

    def fetch_understand_model_build(self, request: operations.FetchUnderstandModelBuildRequest, security: operations.FetchUnderstandModelBuildSecurity, server_url: Optional[str] = None) -> operations.FetchUnderstandModelBuildResponse:
        base_url = operations.FETCH_UNDERSTAND_MODEL_BUILD_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.FetchUnderstandModelBuildRequest, base_url, '/understand/Assistants/{AssistantSid}/ModelBuilds/{Sid}', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.FetchUnderstandModelBuildResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.PreviewUnderstandAssistantModelBuild])
                res.preview_understand_assistant_model_build = out

        return res

    def fetch_understand_query(self, request: operations.FetchUnderstandQueryRequest, security: operations.FetchUnderstandQuerySecurity, server_url: Optional[str] = None) -> operations.FetchUnderstandQueryResponse:
        base_url = operations.FETCH_UNDERSTAND_QUERY_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.FetchUnderstandQueryRequest, base_url, '/understand/Assistants/{AssistantSid}/Queries/{Sid}', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.FetchUnderstandQueryResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.PreviewUnderstandAssistantQuery])
                res.preview_understand_assistant_query = out

        return res

    def fetch_understand_sample(self, request: operations.FetchUnderstandSampleRequest, security: operations.FetchUnderstandSampleSecurity, server_url: Optional[str] = None) -> operations.FetchUnderstandSampleResponse:
        base_url = operations.FETCH_UNDERSTAND_SAMPLE_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.FetchUnderstandSampleRequest, base_url, '/understand/Assistants/{AssistantSid}/Tasks/{TaskSid}/Samples/{Sid}', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.FetchUnderstandSampleResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.PreviewUnderstandAssistantTaskSample])
                res.preview_understand_assistant_task_sample = out

        return res

    def fetch_understand_style_sheet(self, request: operations.FetchUnderstandStyleSheetRequest, security: operations.FetchUnderstandStyleSheetSecurity, server_url: Optional[str] = None) -> operations.FetchUnderstandStyleSheetResponse:
        r"""Returns Style sheet JSON object for this Assistant"""
        base_url = operations.FETCH_UNDERSTAND_STYLE_SHEET_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.FetchUnderstandStyleSheetRequest, base_url, '/understand/Assistants/{AssistantSid}/StyleSheet', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.FetchUnderstandStyleSheetResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.PreviewUnderstandAssistantStyleSheet])
                res.preview_understand_assistant_style_sheet = out

        return res

    def fetch_understand_task(self, request: operations.FetchUnderstandTaskRequest, security: operations.FetchUnderstandTaskSecurity, server_url: Optional[str] = None) -> operations.FetchUnderstandTaskResponse:
        base_url = operations.FETCH_UNDERSTAND_TASK_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.FetchUnderstandTaskRequest, base_url, '/understand/Assistants/{AssistantSid}/Tasks/{Sid}', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.FetchUnderstandTaskResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.PreviewUnderstandAssistantTask])
                res.preview_understand_assistant_task = out

        return res

    def fetch_understand_task_actions(self, request: operations.FetchUnderstandTaskActionsRequest, security: operations.FetchUnderstandTaskActionsSecurity, server_url: Optional[str] = None) -> operations.FetchUnderstandTaskActionsResponse:
        r"""Returns JSON actions for this Task."""
        base_url = operations.FETCH_UNDERSTAND_TASK_ACTIONS_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.FetchUnderstandTaskActionsRequest, base_url, '/understand/Assistants/{AssistantSid}/Tasks/{TaskSid}/Actions', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.FetchUnderstandTaskActionsResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.PreviewUnderstandAssistantTaskTaskActions])
                res.preview_understand_assistant_task_task_actions = out

        return res

    def fetch_understand_task_statistics(self, request: operations.FetchUnderstandTaskStatisticsRequest, security: operations.FetchUnderstandTaskStatisticsSecurity, server_url: Optional[str] = None) -> operations.FetchUnderstandTaskStatisticsResponse:
        base_url = operations.FETCH_UNDERSTAND_TASK_STATISTICS_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.FetchUnderstandTaskStatisticsRequest, base_url, '/understand/Assistants/{AssistantSid}/Tasks/{TaskSid}/Statistics', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.FetchUnderstandTaskStatisticsResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.PreviewUnderstandAssistantTaskTaskStatistics])
                res.preview_understand_assistant_task_task_statistics = out

        return res

    def fetch_wireless_command(self, request: operations.FetchWirelessCommandRequest, security: operations.FetchWirelessCommandSecurity, server_url: Optional[str] = None) -> operations.FetchWirelessCommandResponse:
        base_url = operations.FETCH_WIRELESS_COMMAND_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.FetchWirelessCommandRequest, base_url, '/wireless/Commands/{Sid}', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.FetchWirelessCommandResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.PreviewWirelessCommand])
                res.preview_wireless_command = out

        return res

    def fetch_wireless_rate_plan(self, request: operations.FetchWirelessRatePlanRequest, security: operations.FetchWirelessRatePlanSecurity, server_url: Optional[str] = None) -> operations.FetchWirelessRatePlanResponse:
        base_url = operations.FETCH_WIRELESS_RATE_PLAN_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.FetchWirelessRatePlanRequest, base_url, '/wireless/RatePlans/{Sid}', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.FetchWirelessRatePlanResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.PreviewWirelessRatePlan])
                res.preview_wireless_rate_plan = out

        return res

    def fetch_wireless_sim(self, request: operations.FetchWirelessSimRequest, security: operations.FetchWirelessSimSecurity, server_url: Optional[str] = None) -> operations.FetchWirelessSimResponse:
        base_url = operations.FETCH_WIRELESS_SIM_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.FetchWirelessSimRequest, base_url, '/wireless/Sims/{Sid}', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.FetchWirelessSimResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.PreviewWirelessSim])
                res.preview_wireless_sim = out

        return res

    def fetch_wireless_usage(self, request: operations.FetchWirelessUsageRequest, security: operations.FetchWirelessUsageSecurity, server_url: Optional[str] = None) -> operations.FetchWirelessUsageResponse:
        base_url = operations.FETCH_WIRELESS_USAGE_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.FetchWirelessUsageRequest, base_url, '/wireless/Sims/{SimSid}/Usage', request)
        
        query_params = utils.get_query_params(operations.FetchWirelessUsageRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.FetchWirelessUsageResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.PreviewWirelessSimUsage])
                res.preview_wireless_sim_usage = out

        return res

    def list_deployed_devices_certificate(self, request: operations.ListDeployedDevicesCertificateRequest, security: operations.ListDeployedDevicesCertificateSecurity, server_url: Optional[str] = None) -> operations.ListDeployedDevicesCertificateResponse:
        r"""Retrieve a list of all Certificate credentials belonging to the Fleet."""
        base_url = operations.LIST_DEPLOYED_DEVICES_CERTIFICATE_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.ListDeployedDevicesCertificateRequest, base_url, '/DeployedDevices/Fleets/{FleetSid}/Certificates', request)
        
        query_params = utils.get_query_params(operations.ListDeployedDevicesCertificateRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ListDeployedDevicesCertificateResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.ListDeployedDevicesCertificateListDeployedDevicesCertificateResponse])
                res.list_deployed_devices_certificate_response = out

        return res

    def list_deployed_devices_deployment(self, request: operations.ListDeployedDevicesDeploymentRequest, security: operations.ListDeployedDevicesDeploymentSecurity, server_url: Optional[str] = None) -> operations.ListDeployedDevicesDeploymentResponse:
        r"""Retrieve a list of all Deployments belonging to the Fleet."""
        base_url = operations.LIST_DEPLOYED_DEVICES_DEPLOYMENT_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.ListDeployedDevicesDeploymentRequest, base_url, '/DeployedDevices/Fleets/{FleetSid}/Deployments', request)
        
        query_params = utils.get_query_params(operations.ListDeployedDevicesDeploymentRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ListDeployedDevicesDeploymentResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.ListDeployedDevicesDeploymentListDeployedDevicesDeploymentResponse])
                res.list_deployed_devices_deployment_response = out

        return res

    def list_deployed_devices_device(self, request: operations.ListDeployedDevicesDeviceRequest, security: operations.ListDeployedDevicesDeviceSecurity, server_url: Optional[str] = None) -> operations.ListDeployedDevicesDeviceResponse:
        r"""Retrieve a list of all Devices belonging to the Fleet."""
        base_url = operations.LIST_DEPLOYED_DEVICES_DEVICE_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.ListDeployedDevicesDeviceRequest, base_url, '/DeployedDevices/Fleets/{FleetSid}/Devices', request)
        
        query_params = utils.get_query_params(operations.ListDeployedDevicesDeviceRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ListDeployedDevicesDeviceResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.ListDeployedDevicesDeviceListDeployedDevicesDeviceResponse])
                res.list_deployed_devices_device_response = out

        return res

    def list_deployed_devices_fleet(self, request: operations.ListDeployedDevicesFleetRequest, security: operations.ListDeployedDevicesFleetSecurity, server_url: Optional[str] = None) -> operations.ListDeployedDevicesFleetResponse:
        r"""Retrieve a list of all Fleets belonging to your account."""
        base_url = operations.LIST_DEPLOYED_DEVICES_FLEET_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = base_url.removesuffix('/') + '/DeployedDevices/Fleets'
        
        query_params = utils.get_query_params(operations.ListDeployedDevicesFleetRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ListDeployedDevicesFleetResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.ListDeployedDevicesFleetListDeployedDevicesFleetResponse])
                res.list_deployed_devices_fleet_response = out

        return res

    def list_deployed_devices_key(self, request: operations.ListDeployedDevicesKeyRequest, security: operations.ListDeployedDevicesKeySecurity, server_url: Optional[str] = None) -> operations.ListDeployedDevicesKeyResponse:
        r"""Retrieve a list of all Keys credentials belonging to the Fleet."""
        base_url = operations.LIST_DEPLOYED_DEVICES_KEY_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.ListDeployedDevicesKeyRequest, base_url, '/DeployedDevices/Fleets/{FleetSid}/Keys', request)
        
        query_params = utils.get_query_params(operations.ListDeployedDevicesKeyRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ListDeployedDevicesKeyResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.ListDeployedDevicesKeyListDeployedDevicesKeyResponse])
                res.list_deployed_devices_key_response = out

        return res

    def list_hosted_numbers_authorization_document(self, request: operations.ListHostedNumbersAuthorizationDocumentRequest, security: operations.ListHostedNumbersAuthorizationDocumentSecurity, server_url: Optional[str] = None) -> operations.ListHostedNumbersAuthorizationDocumentResponse:
        r"""Retrieve a list of AuthorizationDocuments belonging to the account initiating the request."""
        base_url = operations.LIST_HOSTED_NUMBERS_AUTHORIZATION_DOCUMENT_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = base_url.removesuffix('/') + '/HostedNumbers/AuthorizationDocuments'
        
        query_params = utils.get_query_params(operations.ListHostedNumbersAuthorizationDocumentRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ListHostedNumbersAuthorizationDocumentResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.ListHostedNumbersAuthorizationDocumentListHostedNumbersAuthorizationDocumentResponse])
                res.list_hosted_numbers_authorization_document_response = out

        return res

    def list_hosted_numbers_dependent_hosted_number_order(self, request: operations.ListHostedNumbersDependentHostedNumberOrderRequest, security: operations.ListHostedNumbersDependentHostedNumberOrderSecurity, server_url: Optional[str] = None) -> operations.ListHostedNumbersDependentHostedNumberOrderResponse:
        r"""Retrieve a list of dependent HostedNumberOrders belonging to the AuthorizationDocument."""
        base_url = operations.LIST_HOSTED_NUMBERS_DEPENDENT_HOSTED_NUMBER_ORDER_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.ListHostedNumbersDependentHostedNumberOrderRequest, base_url, '/HostedNumbers/AuthorizationDocuments/{SigningDocumentSid}/DependentHostedNumberOrders', request)
        
        query_params = utils.get_query_params(operations.ListHostedNumbersDependentHostedNumberOrderRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ListHostedNumbersDependentHostedNumberOrderResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.ListHostedNumbersDependentHostedNumberOrderListHostedNumbersDependentHostedNumberOrderResponse])
                res.list_hosted_numbers_dependent_hosted_number_order_response = out

        return res

    def list_hosted_numbers_hosted_number_order(self, request: operations.ListHostedNumbersHostedNumberOrderRequest, security: operations.ListHostedNumbersHostedNumberOrderSecurity, server_url: Optional[str] = None) -> operations.ListHostedNumbersHostedNumberOrderResponse:
        r"""Retrieve a list of HostedNumberOrders belonging to the account initiating the request."""
        base_url = operations.LIST_HOSTED_NUMBERS_HOSTED_NUMBER_ORDER_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = base_url.removesuffix('/') + '/HostedNumbers/HostedNumberOrders'
        
        query_params = utils.get_query_params(operations.ListHostedNumbersHostedNumberOrderRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ListHostedNumbersHostedNumberOrderResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.ListHostedNumbersHostedNumberOrderListHostedNumbersHostedNumberOrderResponse])
                res.list_hosted_numbers_hosted_number_order_response = out

        return res

    def list_marketplace_available_add_on(self, request: operations.ListMarketplaceAvailableAddOnRequest, security: operations.ListMarketplaceAvailableAddOnSecurity, server_url: Optional[str] = None) -> operations.ListMarketplaceAvailableAddOnResponse:
        r"""Retrieve a list of Add-ons currently available to be installed."""
        base_url = operations.LIST_MARKETPLACE_AVAILABLE_ADD_ON_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = base_url.removesuffix('/') + '/marketplace/AvailableAddOns'
        
        query_params = utils.get_query_params(operations.ListMarketplaceAvailableAddOnRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ListMarketplaceAvailableAddOnResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.ListMarketplaceAvailableAddOnListMarketplaceAvailableAddOnResponse])
                res.list_marketplace_available_add_on_response = out

        return res

    def list_marketplace_available_add_on_extension(self, request: operations.ListMarketplaceAvailableAddOnExtensionRequest, security: operations.ListMarketplaceAvailableAddOnExtensionSecurity, server_url: Optional[str] = None) -> operations.ListMarketplaceAvailableAddOnExtensionResponse:
        r"""Retrieve a list of Extensions for the Available Add-on."""
        base_url = operations.LIST_MARKETPLACE_AVAILABLE_ADD_ON_EXTENSION_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.ListMarketplaceAvailableAddOnExtensionRequest, base_url, '/marketplace/AvailableAddOns/{AvailableAddOnSid}/Extensions', request)
        
        query_params = utils.get_query_params(operations.ListMarketplaceAvailableAddOnExtensionRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ListMarketplaceAvailableAddOnExtensionResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.ListMarketplaceAvailableAddOnExtensionListMarketplaceAvailableAddOnExtensionResponse])
                res.list_marketplace_available_add_on_extension_response = out

        return res

    def list_marketplace_installed_add_on(self, request: operations.ListMarketplaceInstalledAddOnRequest, security: operations.ListMarketplaceInstalledAddOnSecurity, server_url: Optional[str] = None) -> operations.ListMarketplaceInstalledAddOnResponse:
        r"""Retrieve a list of Add-ons currently installed on this Account."""
        base_url = operations.LIST_MARKETPLACE_INSTALLED_ADD_ON_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = base_url.removesuffix('/') + '/marketplace/InstalledAddOns'
        
        query_params = utils.get_query_params(operations.ListMarketplaceInstalledAddOnRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ListMarketplaceInstalledAddOnResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.ListMarketplaceInstalledAddOnListMarketplaceInstalledAddOnResponse])
                res.list_marketplace_installed_add_on_response = out

        return res

    def list_marketplace_installed_add_on_extension(self, request: operations.ListMarketplaceInstalledAddOnExtensionRequest, security: operations.ListMarketplaceInstalledAddOnExtensionSecurity, server_url: Optional[str] = None) -> operations.ListMarketplaceInstalledAddOnExtensionResponse:
        r"""Retrieve a list of Extensions for the Installed Add-on."""
        base_url = operations.LIST_MARKETPLACE_INSTALLED_ADD_ON_EXTENSION_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.ListMarketplaceInstalledAddOnExtensionRequest, base_url, '/marketplace/InstalledAddOns/{InstalledAddOnSid}/Extensions', request)
        
        query_params = utils.get_query_params(operations.ListMarketplaceInstalledAddOnExtensionRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ListMarketplaceInstalledAddOnExtensionResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.ListMarketplaceInstalledAddOnExtensionListMarketplaceInstalledAddOnExtensionResponse])
                res.list_marketplace_installed_add_on_extension_response = out

        return res

    def list_sync_document(self, request: operations.ListSyncDocumentRequest, security: operations.ListSyncDocumentSecurity, server_url: Optional[str] = None) -> operations.ListSyncDocumentResponse:
        base_url = operations.LIST_SYNC_DOCUMENT_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.ListSyncDocumentRequest, base_url, '/Sync/Services/{ServiceSid}/Documents', request)
        
        query_params = utils.get_query_params(operations.ListSyncDocumentRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ListSyncDocumentResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.ListSyncDocumentListSyncDocumentResponse])
                res.list_sync_document_response = out

        return res

    def list_sync_document_permission(self, request: operations.ListSyncDocumentPermissionRequest, security: operations.ListSyncDocumentPermissionSecurity, server_url: Optional[str] = None) -> operations.ListSyncDocumentPermissionResponse:
        r"""Retrieve a list of all Permissions applying to a Sync Document."""
        base_url = operations.LIST_SYNC_DOCUMENT_PERMISSION_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.ListSyncDocumentPermissionRequest, base_url, '/Sync/Services/{ServiceSid}/Documents/{DocumentSid}/Permissions', request)
        
        query_params = utils.get_query_params(operations.ListSyncDocumentPermissionRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ListSyncDocumentPermissionResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.ListSyncDocumentPermissionListSyncDocumentPermissionResponse])
                res.list_sync_document_permission_response = out

        return res

    def list_sync_service(self, request: operations.ListSyncServiceRequest, security: operations.ListSyncServiceSecurity, server_url: Optional[str] = None) -> operations.ListSyncServiceResponse:
        base_url = operations.LIST_SYNC_SERVICE_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = base_url.removesuffix('/') + '/Sync/Services'
        
        query_params = utils.get_query_params(operations.ListSyncServiceRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ListSyncServiceResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.ListSyncServiceListSyncServiceResponse])
                res.list_sync_service_response = out

        return res

    def list_sync_sync_list(self, request: operations.ListSyncSyncListRequest, security: operations.ListSyncSyncListSecurity, server_url: Optional[str] = None) -> operations.ListSyncSyncListResponse:
        base_url = operations.LIST_SYNC_SYNC_LIST_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.ListSyncSyncListRequest, base_url, '/Sync/Services/{ServiceSid}/Lists', request)
        
        query_params = utils.get_query_params(operations.ListSyncSyncListRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ListSyncSyncListResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.ListSyncSyncListListSyncSyncListResponse])
                res.list_sync_sync_list_response = out

        return res

    def list_sync_sync_list_item(self, request: operations.ListSyncSyncListItemRequest, security: operations.ListSyncSyncListItemSecurity, server_url: Optional[str] = None) -> operations.ListSyncSyncListItemResponse:
        base_url = operations.LIST_SYNC_SYNC_LIST_ITEM_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.ListSyncSyncListItemRequest, base_url, '/Sync/Services/{ServiceSid}/Lists/{ListSid}/Items', request)
        
        query_params = utils.get_query_params(operations.ListSyncSyncListItemRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ListSyncSyncListItemResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.ListSyncSyncListItemListSyncSyncListItemResponse])
                res.list_sync_sync_list_item_response = out

        return res

    def list_sync_sync_list_permission(self, request: operations.ListSyncSyncListPermissionRequest, security: operations.ListSyncSyncListPermissionSecurity, server_url: Optional[str] = None) -> operations.ListSyncSyncListPermissionResponse:
        r"""Retrieve a list of all Permissions applying to a Sync List."""
        base_url = operations.LIST_SYNC_SYNC_LIST_PERMISSION_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.ListSyncSyncListPermissionRequest, base_url, '/Sync/Services/{ServiceSid}/Lists/{ListSid}/Permissions', request)
        
        query_params = utils.get_query_params(operations.ListSyncSyncListPermissionRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ListSyncSyncListPermissionResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.ListSyncSyncListPermissionListSyncSyncListPermissionResponse])
                res.list_sync_sync_list_permission_response = out

        return res

    def list_sync_sync_map(self, request: operations.ListSyncSyncMapRequest, security: operations.ListSyncSyncMapSecurity, server_url: Optional[str] = None) -> operations.ListSyncSyncMapResponse:
        base_url = operations.LIST_SYNC_SYNC_MAP_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.ListSyncSyncMapRequest, base_url, '/Sync/Services/{ServiceSid}/Maps', request)
        
        query_params = utils.get_query_params(operations.ListSyncSyncMapRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ListSyncSyncMapResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.ListSyncSyncMapListSyncSyncMapResponse])
                res.list_sync_sync_map_response = out

        return res

    def list_sync_sync_map_item(self, request: operations.ListSyncSyncMapItemRequest, security: operations.ListSyncSyncMapItemSecurity, server_url: Optional[str] = None) -> operations.ListSyncSyncMapItemResponse:
        base_url = operations.LIST_SYNC_SYNC_MAP_ITEM_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.ListSyncSyncMapItemRequest, base_url, '/Sync/Services/{ServiceSid}/Maps/{MapSid}/Items', request)
        
        query_params = utils.get_query_params(operations.ListSyncSyncMapItemRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ListSyncSyncMapItemResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.ListSyncSyncMapItemListSyncSyncMapItemResponse])
                res.list_sync_sync_map_item_response = out

        return res

    def list_sync_sync_map_permission(self, request: operations.ListSyncSyncMapPermissionRequest, security: operations.ListSyncSyncMapPermissionSecurity, server_url: Optional[str] = None) -> operations.ListSyncSyncMapPermissionResponse:
        r"""Retrieve a list of all Permissions applying to a Sync Map."""
        base_url = operations.LIST_SYNC_SYNC_MAP_PERMISSION_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.ListSyncSyncMapPermissionRequest, base_url, '/Sync/Services/{ServiceSid}/Maps/{MapSid}/Permissions', request)
        
        query_params = utils.get_query_params(operations.ListSyncSyncMapPermissionRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ListSyncSyncMapPermissionResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.ListSyncSyncMapPermissionListSyncSyncMapPermissionResponse])
                res.list_sync_sync_map_permission_response = out

        return res

    def list_understand_assistant(self, request: operations.ListUnderstandAssistantRequest, security: operations.ListUnderstandAssistantSecurity, server_url: Optional[str] = None) -> operations.ListUnderstandAssistantResponse:
        base_url = operations.LIST_UNDERSTAND_ASSISTANT_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = base_url.removesuffix('/') + '/understand/Assistants'
        
        query_params = utils.get_query_params(operations.ListUnderstandAssistantRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ListUnderstandAssistantResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.ListUnderstandAssistantListUnderstandAssistantResponse])
                res.list_understand_assistant_response = out

        return res

    def list_understand_field(self, request: operations.ListUnderstandFieldRequest, security: operations.ListUnderstandFieldSecurity, server_url: Optional[str] = None) -> operations.ListUnderstandFieldResponse:
        base_url = operations.LIST_UNDERSTAND_FIELD_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.ListUnderstandFieldRequest, base_url, '/understand/Assistants/{AssistantSid}/Tasks/{TaskSid}/Fields', request)
        
        query_params = utils.get_query_params(operations.ListUnderstandFieldRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ListUnderstandFieldResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.ListUnderstandFieldListUnderstandFieldResponse])
                res.list_understand_field_response = out

        return res

    def list_understand_field_type(self, request: operations.ListUnderstandFieldTypeRequest, security: operations.ListUnderstandFieldTypeSecurity, server_url: Optional[str] = None) -> operations.ListUnderstandFieldTypeResponse:
        base_url = operations.LIST_UNDERSTAND_FIELD_TYPE_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.ListUnderstandFieldTypeRequest, base_url, '/understand/Assistants/{AssistantSid}/FieldTypes', request)
        
        query_params = utils.get_query_params(operations.ListUnderstandFieldTypeRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ListUnderstandFieldTypeResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.ListUnderstandFieldTypeListUnderstandFieldTypeResponse])
                res.list_understand_field_type_response = out

        return res

    def list_understand_field_value(self, request: operations.ListUnderstandFieldValueRequest, security: operations.ListUnderstandFieldValueSecurity, server_url: Optional[str] = None) -> operations.ListUnderstandFieldValueResponse:
        base_url = operations.LIST_UNDERSTAND_FIELD_VALUE_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.ListUnderstandFieldValueRequest, base_url, '/understand/Assistants/{AssistantSid}/FieldTypes/{FieldTypeSid}/FieldValues', request)
        
        query_params = utils.get_query_params(operations.ListUnderstandFieldValueRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ListUnderstandFieldValueResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.ListUnderstandFieldValueListUnderstandFieldValueResponse])
                res.list_understand_field_value_response = out

        return res

    def list_understand_model_build(self, request: operations.ListUnderstandModelBuildRequest, security: operations.ListUnderstandModelBuildSecurity, server_url: Optional[str] = None) -> operations.ListUnderstandModelBuildResponse:
        base_url = operations.LIST_UNDERSTAND_MODEL_BUILD_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.ListUnderstandModelBuildRequest, base_url, '/understand/Assistants/{AssistantSid}/ModelBuilds', request)
        
        query_params = utils.get_query_params(operations.ListUnderstandModelBuildRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ListUnderstandModelBuildResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.ListUnderstandModelBuildListUnderstandModelBuildResponse])
                res.list_understand_model_build_response = out

        return res

    def list_understand_query(self, request: operations.ListUnderstandQueryRequest, security: operations.ListUnderstandQuerySecurity, server_url: Optional[str] = None) -> operations.ListUnderstandQueryResponse:
        base_url = operations.LIST_UNDERSTAND_QUERY_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.ListUnderstandQueryRequest, base_url, '/understand/Assistants/{AssistantSid}/Queries', request)
        
        query_params = utils.get_query_params(operations.ListUnderstandQueryRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ListUnderstandQueryResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.ListUnderstandQueryListUnderstandQueryResponse])
                res.list_understand_query_response = out

        return res

    def list_understand_sample(self, request: operations.ListUnderstandSampleRequest, security: operations.ListUnderstandSampleSecurity, server_url: Optional[str] = None) -> operations.ListUnderstandSampleResponse:
        base_url = operations.LIST_UNDERSTAND_SAMPLE_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.ListUnderstandSampleRequest, base_url, '/understand/Assistants/{AssistantSid}/Tasks/{TaskSid}/Samples', request)
        
        query_params = utils.get_query_params(operations.ListUnderstandSampleRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ListUnderstandSampleResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.ListUnderstandSampleListUnderstandSampleResponse])
                res.list_understand_sample_response = out

        return res

    def list_understand_task(self, request: operations.ListUnderstandTaskRequest, security: operations.ListUnderstandTaskSecurity, server_url: Optional[str] = None) -> operations.ListUnderstandTaskResponse:
        base_url = operations.LIST_UNDERSTAND_TASK_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.ListUnderstandTaskRequest, base_url, '/understand/Assistants/{AssistantSid}/Tasks', request)
        
        query_params = utils.get_query_params(operations.ListUnderstandTaskRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ListUnderstandTaskResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.ListUnderstandTaskListUnderstandTaskResponse])
                res.list_understand_task_response = out

        return res

    def list_wireless_command(self, request: operations.ListWirelessCommandRequest, security: operations.ListWirelessCommandSecurity, server_url: Optional[str] = None) -> operations.ListWirelessCommandResponse:
        base_url = operations.LIST_WIRELESS_COMMAND_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = base_url.removesuffix('/') + '/wireless/Commands'
        
        query_params = utils.get_query_params(operations.ListWirelessCommandRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ListWirelessCommandResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.ListWirelessCommandListWirelessCommandResponse])
                res.list_wireless_command_response = out

        return res

    def list_wireless_rate_plan(self, request: operations.ListWirelessRatePlanRequest, security: operations.ListWirelessRatePlanSecurity, server_url: Optional[str] = None) -> operations.ListWirelessRatePlanResponse:
        base_url = operations.LIST_WIRELESS_RATE_PLAN_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = base_url.removesuffix('/') + '/wireless/RatePlans'
        
        query_params = utils.get_query_params(operations.ListWirelessRatePlanRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ListWirelessRatePlanResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.ListWirelessRatePlanListWirelessRatePlanResponse])
                res.list_wireless_rate_plan_response = out

        return res

    def list_wireless_sim(self, request: operations.ListWirelessSimRequest, security: operations.ListWirelessSimSecurity, server_url: Optional[str] = None) -> operations.ListWirelessSimResponse:
        base_url = operations.LIST_WIRELESS_SIM_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = base_url.removesuffix('/') + '/wireless/Sims'
        
        query_params = utils.get_query_params(operations.ListWirelessSimRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ListWirelessSimResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.ListWirelessSimListWirelessSimResponse])
                res.list_wireless_sim_response = out

        return res

    def update_deployed_devices_certificate(self, request: operations.UpdateDeployedDevicesCertificateRequest, security: operations.UpdateDeployedDevicesCertificateSecurity, server_url: Optional[str] = None) -> operations.UpdateDeployedDevicesCertificateResponse:
        r"""Update the given properties of a specific Certificate credential in the Fleet, giving it a friendly name or assigning to a Device."""
        base_url = operations.UPDATE_DEPLOYED_DEVICES_CERTIFICATE_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.UpdateDeployedDevicesCertificateRequest, base_url, '/DeployedDevices/Fleets/{FleetSid}/Certificates/{Sid}', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'form')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.UpdateDeployedDevicesCertificateResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.PreviewDeployedDevicesFleetCertificate])
                res.preview_deployed_devices_fleet_certificate = out

        return res

    def update_deployed_devices_deployment(self, request: operations.UpdateDeployedDevicesDeploymentRequest, security: operations.UpdateDeployedDevicesDeploymentSecurity, server_url: Optional[str] = None) -> operations.UpdateDeployedDevicesDeploymentResponse:
        r"""Update the given properties of a specific Deployment credential in the Fleet, giving it a friendly name or linking to a specific Twilio Sync service instance."""
        base_url = operations.UPDATE_DEPLOYED_DEVICES_DEPLOYMENT_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.UpdateDeployedDevicesDeploymentRequest, base_url, '/DeployedDevices/Fleets/{FleetSid}/Deployments/{Sid}', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'form')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.UpdateDeployedDevicesDeploymentResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.PreviewDeployedDevicesFleetDeployment])
                res.preview_deployed_devices_fleet_deployment = out

        return res

    def update_deployed_devices_device(self, request: operations.UpdateDeployedDevicesDeviceRequest, security: operations.UpdateDeployedDevicesDeviceSecurity, server_url: Optional[str] = None) -> operations.UpdateDeployedDevicesDeviceResponse:
        r"""Update the given properties of a specific Device in the Fleet, giving it a friendly name, assigning to a Deployment, or a human identity."""
        base_url = operations.UPDATE_DEPLOYED_DEVICES_DEVICE_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.UpdateDeployedDevicesDeviceRequest, base_url, '/DeployedDevices/Fleets/{FleetSid}/Devices/{Sid}', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'form')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.UpdateDeployedDevicesDeviceResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.PreviewDeployedDevicesFleetDevice])
                res.preview_deployed_devices_fleet_device = out

        return res

    def update_deployed_devices_fleet(self, request: operations.UpdateDeployedDevicesFleetRequest, security: operations.UpdateDeployedDevicesFleetSecurity, server_url: Optional[str] = None) -> operations.UpdateDeployedDevicesFleetResponse:
        r"""Update the friendly name property of a specific Fleet in your account."""
        base_url = operations.UPDATE_DEPLOYED_DEVICES_FLEET_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.UpdateDeployedDevicesFleetRequest, base_url, '/DeployedDevices/Fleets/{Sid}', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'form')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.UpdateDeployedDevicesFleetResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.PreviewDeployedDevicesFleet])
                res.preview_deployed_devices_fleet = out

        return res

    def update_deployed_devices_key(self, request: operations.UpdateDeployedDevicesKeyRequest, security: operations.UpdateDeployedDevicesKeySecurity, server_url: Optional[str] = None) -> operations.UpdateDeployedDevicesKeyResponse:
        r"""Update the given properties of a specific Key credential in the Fleet, giving it a friendly name or assigning to a Device."""
        base_url = operations.UPDATE_DEPLOYED_DEVICES_KEY_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.UpdateDeployedDevicesKeyRequest, base_url, '/DeployedDevices/Fleets/{FleetSid}/Keys/{Sid}', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'form')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.UpdateDeployedDevicesKeyResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.PreviewDeployedDevicesFleetKey])
                res.preview_deployed_devices_fleet_key = out

        return res

    def update_hosted_numbers_authorization_document(self, request: operations.UpdateHostedNumbersAuthorizationDocumentRequest, security: operations.UpdateHostedNumbersAuthorizationDocumentSecurity, server_url: Optional[str] = None) -> operations.UpdateHostedNumbersAuthorizationDocumentResponse:
        r"""Updates a specific AuthorizationDocument."""
        base_url = operations.UPDATE_HOSTED_NUMBERS_AUTHORIZATION_DOCUMENT_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.UpdateHostedNumbersAuthorizationDocumentRequest, base_url, '/HostedNumbers/AuthorizationDocuments/{Sid}', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'form')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.UpdateHostedNumbersAuthorizationDocumentResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.PreviewHostedNumbersAuthorizationDocument])
                res.preview_hosted_numbers_authorization_document = out

        return res

    def update_hosted_numbers_hosted_number_order(self, request: operations.UpdateHostedNumbersHostedNumberOrderRequest, security: operations.UpdateHostedNumbersHostedNumberOrderSecurity, server_url: Optional[str] = None) -> operations.UpdateHostedNumbersHostedNumberOrderResponse:
        r"""Updates a specific HostedNumberOrder."""
        base_url = operations.UPDATE_HOSTED_NUMBERS_HOSTED_NUMBER_ORDER_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.UpdateHostedNumbersHostedNumberOrderRequest, base_url, '/HostedNumbers/HostedNumberOrders/{Sid}', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'form')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.UpdateHostedNumbersHostedNumberOrderResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.PreviewHostedNumbersHostedNumberOrder])
                res.preview_hosted_numbers_hosted_number_order = out

        return res

    def update_marketplace_installed_add_on(self, request: operations.UpdateMarketplaceInstalledAddOnRequest, security: operations.UpdateMarketplaceInstalledAddOnSecurity, server_url: Optional[str] = None) -> operations.UpdateMarketplaceInstalledAddOnResponse:
        r"""Update an Add-on installation for the Account specified."""
        base_url = operations.UPDATE_MARKETPLACE_INSTALLED_ADD_ON_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.UpdateMarketplaceInstalledAddOnRequest, base_url, '/marketplace/InstalledAddOns/{Sid}', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'form')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.UpdateMarketplaceInstalledAddOnResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.PreviewMarketplaceInstalledAddOn])
                res.preview_marketplace_installed_add_on = out

        return res

    def update_marketplace_installed_add_on_extension(self, request: operations.UpdateMarketplaceInstalledAddOnExtensionRequest, security: operations.UpdateMarketplaceInstalledAddOnExtensionSecurity, server_url: Optional[str] = None) -> operations.UpdateMarketplaceInstalledAddOnExtensionResponse:
        r"""Update an Extension for an Add-on installation."""
        base_url = operations.UPDATE_MARKETPLACE_INSTALLED_ADD_ON_EXTENSION_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.UpdateMarketplaceInstalledAddOnExtensionRequest, base_url, '/marketplace/InstalledAddOns/{InstalledAddOnSid}/Extensions/{Sid}', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'form')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.UpdateMarketplaceInstalledAddOnExtensionResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.PreviewMarketplaceInstalledAddOnInstalledAddOnExtension])
                res.preview_marketplace_installed_add_on_installed_add_on_extension = out

        return res

    def update_sync_document(self, request: operations.UpdateSyncDocumentRequest, security: operations.UpdateSyncDocumentSecurity, server_url: Optional[str] = None) -> operations.UpdateSyncDocumentResponse:
        base_url = operations.UPDATE_SYNC_DOCUMENT_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.UpdateSyncDocumentRequest, base_url, '/Sync/Services/{ServiceSid}/Documents/{Sid}', request)
        
        headers = utils.get_headers(request)
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'form')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.UpdateSyncDocumentResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.PreviewSyncServiceDocument])
                res.preview_sync_service_document = out

        return res

    def update_sync_document_permission(self, request: operations.UpdateSyncDocumentPermissionRequest, security: operations.UpdateSyncDocumentPermissionSecurity, server_url: Optional[str] = None) -> operations.UpdateSyncDocumentPermissionResponse:
        r"""Update an identity's access to a specific Sync Document."""
        base_url = operations.UPDATE_SYNC_DOCUMENT_PERMISSION_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.UpdateSyncDocumentPermissionRequest, base_url, '/Sync/Services/{ServiceSid}/Documents/{DocumentSid}/Permissions/{Identity}', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'form')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.UpdateSyncDocumentPermissionResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.PreviewSyncServiceDocumentDocumentPermission])
                res.preview_sync_service_document_document_permission = out

        return res

    def update_sync_service(self, request: operations.UpdateSyncServiceRequest, security: operations.UpdateSyncServiceSecurity, server_url: Optional[str] = None) -> operations.UpdateSyncServiceResponse:
        base_url = operations.UPDATE_SYNC_SERVICE_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.UpdateSyncServiceRequest, base_url, '/Sync/Services/{Sid}', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'form')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.UpdateSyncServiceResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.PreviewSyncService])
                res.preview_sync_service = out

        return res

    def update_sync_sync_list_item(self, request: operations.UpdateSyncSyncListItemRequest, security: operations.UpdateSyncSyncListItemSecurity, server_url: Optional[str] = None) -> operations.UpdateSyncSyncListItemResponse:
        base_url = operations.UPDATE_SYNC_SYNC_LIST_ITEM_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.UpdateSyncSyncListItemRequest, base_url, '/Sync/Services/{ServiceSid}/Lists/{ListSid}/Items/{Index}', request)
        
        headers = utils.get_headers(request)
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'form')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.UpdateSyncSyncListItemResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.PreviewSyncServiceSyncListSyncListItem])
                res.preview_sync_service_sync_list_sync_list_item = out

        return res

    def update_sync_sync_list_permission(self, request: operations.UpdateSyncSyncListPermissionRequest, security: operations.UpdateSyncSyncListPermissionSecurity, server_url: Optional[str] = None) -> operations.UpdateSyncSyncListPermissionResponse:
        r"""Update an identity's access to a specific Sync List."""
        base_url = operations.UPDATE_SYNC_SYNC_LIST_PERMISSION_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.UpdateSyncSyncListPermissionRequest, base_url, '/Sync/Services/{ServiceSid}/Lists/{ListSid}/Permissions/{Identity}', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'form')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.UpdateSyncSyncListPermissionResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.PreviewSyncServiceSyncListSyncListPermission])
                res.preview_sync_service_sync_list_sync_list_permission = out

        return res

    def update_sync_sync_map_item(self, request: operations.UpdateSyncSyncMapItemRequest, security: operations.UpdateSyncSyncMapItemSecurity, server_url: Optional[str] = None) -> operations.UpdateSyncSyncMapItemResponse:
        base_url = operations.UPDATE_SYNC_SYNC_MAP_ITEM_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.UpdateSyncSyncMapItemRequest, base_url, '/Sync/Services/{ServiceSid}/Maps/{MapSid}/Items/{Key}', request)
        
        headers = utils.get_headers(request)
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'form')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.UpdateSyncSyncMapItemResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.PreviewSyncServiceSyncMapSyncMapItem])
                res.preview_sync_service_sync_map_sync_map_item = out

        return res

    def update_sync_sync_map_permission(self, request: operations.UpdateSyncSyncMapPermissionRequest, security: operations.UpdateSyncSyncMapPermissionSecurity, server_url: Optional[str] = None) -> operations.UpdateSyncSyncMapPermissionResponse:
        r"""Update an identity's access to a specific Sync Map."""
        base_url = operations.UPDATE_SYNC_SYNC_MAP_PERMISSION_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.UpdateSyncSyncMapPermissionRequest, base_url, '/Sync/Services/{ServiceSid}/Maps/{MapSid}/Permissions/{Identity}', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'form')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.UpdateSyncSyncMapPermissionResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.PreviewSyncServiceSyncMapSyncMapPermission])
                res.preview_sync_service_sync_map_sync_map_permission = out

        return res

    def update_understand_assistant(self, request: operations.UpdateUnderstandAssistantRequest, security: operations.UpdateUnderstandAssistantSecurity, server_url: Optional[str] = None) -> operations.UpdateUnderstandAssistantResponse:
        base_url = operations.UPDATE_UNDERSTAND_ASSISTANT_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.UpdateUnderstandAssistantRequest, base_url, '/understand/Assistants/{Sid}', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'form')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.UpdateUnderstandAssistantResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.PreviewUnderstandAssistant])
                res.preview_understand_assistant = out

        return res

    def update_understand_assistant_fallback_actions(self, request: operations.UpdateUnderstandAssistantFallbackActionsRequest, security: operations.UpdateUnderstandAssistantFallbackActionsSecurity, server_url: Optional[str] = None) -> operations.UpdateUnderstandAssistantFallbackActionsResponse:
        base_url = operations.UPDATE_UNDERSTAND_ASSISTANT_FALLBACK_ACTIONS_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.UpdateUnderstandAssistantFallbackActionsRequest, base_url, '/understand/Assistants/{AssistantSid}/FallbackActions', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'form')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.UpdateUnderstandAssistantFallbackActionsResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.PreviewUnderstandAssistantAssistantFallbackActions])
                res.preview_understand_assistant_assistant_fallback_actions = out

        return res

    def update_understand_assistant_initiation_actions(self, request: operations.UpdateUnderstandAssistantInitiationActionsRequest, security: operations.UpdateUnderstandAssistantInitiationActionsSecurity, server_url: Optional[str] = None) -> operations.UpdateUnderstandAssistantInitiationActionsResponse:
        base_url = operations.UPDATE_UNDERSTAND_ASSISTANT_INITIATION_ACTIONS_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.UpdateUnderstandAssistantInitiationActionsRequest, base_url, '/understand/Assistants/{AssistantSid}/InitiationActions', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'form')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.UpdateUnderstandAssistantInitiationActionsResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.PreviewUnderstandAssistantAssistantInitiationActions])
                res.preview_understand_assistant_assistant_initiation_actions = out

        return res

    def update_understand_field_type(self, request: operations.UpdateUnderstandFieldTypeRequest, security: operations.UpdateUnderstandFieldTypeSecurity, server_url: Optional[str] = None) -> operations.UpdateUnderstandFieldTypeResponse:
        base_url = operations.UPDATE_UNDERSTAND_FIELD_TYPE_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.UpdateUnderstandFieldTypeRequest, base_url, '/understand/Assistants/{AssistantSid}/FieldTypes/{Sid}', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'form')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.UpdateUnderstandFieldTypeResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.PreviewUnderstandAssistantFieldType])
                res.preview_understand_assistant_field_type = out

        return res

    def update_understand_model_build(self, request: operations.UpdateUnderstandModelBuildRequest, security: operations.UpdateUnderstandModelBuildSecurity, server_url: Optional[str] = None) -> operations.UpdateUnderstandModelBuildResponse:
        base_url = operations.UPDATE_UNDERSTAND_MODEL_BUILD_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.UpdateUnderstandModelBuildRequest, base_url, '/understand/Assistants/{AssistantSid}/ModelBuilds/{Sid}', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'form')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.UpdateUnderstandModelBuildResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.PreviewUnderstandAssistantModelBuild])
                res.preview_understand_assistant_model_build = out

        return res

    def update_understand_query(self, request: operations.UpdateUnderstandQueryRequest, security: operations.UpdateUnderstandQuerySecurity, server_url: Optional[str] = None) -> operations.UpdateUnderstandQueryResponse:
        base_url = operations.UPDATE_UNDERSTAND_QUERY_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.UpdateUnderstandQueryRequest, base_url, '/understand/Assistants/{AssistantSid}/Queries/{Sid}', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'form')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.UpdateUnderstandQueryResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.PreviewUnderstandAssistantQuery])
                res.preview_understand_assistant_query = out

        return res

    def update_understand_sample(self, request: operations.UpdateUnderstandSampleRequest, security: operations.UpdateUnderstandSampleSecurity, server_url: Optional[str] = None) -> operations.UpdateUnderstandSampleResponse:
        base_url = operations.UPDATE_UNDERSTAND_SAMPLE_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.UpdateUnderstandSampleRequest, base_url, '/understand/Assistants/{AssistantSid}/Tasks/{TaskSid}/Samples/{Sid}', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'form')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.UpdateUnderstandSampleResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.PreviewUnderstandAssistantTaskSample])
                res.preview_understand_assistant_task_sample = out

        return res

    def update_understand_style_sheet(self, request: operations.UpdateUnderstandStyleSheetRequest, security: operations.UpdateUnderstandStyleSheetSecurity, server_url: Optional[str] = None) -> operations.UpdateUnderstandStyleSheetResponse:
        r"""Updates the style sheet for an assistant identified by {AssistantSid} or {AssistantUniqueName}."""
        base_url = operations.UPDATE_UNDERSTAND_STYLE_SHEET_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.UpdateUnderstandStyleSheetRequest, base_url, '/understand/Assistants/{AssistantSid}/StyleSheet', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'form')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.UpdateUnderstandStyleSheetResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.PreviewUnderstandAssistantStyleSheet])
                res.preview_understand_assistant_style_sheet = out

        return res

    def update_understand_task(self, request: operations.UpdateUnderstandTaskRequest, security: operations.UpdateUnderstandTaskSecurity, server_url: Optional[str] = None) -> operations.UpdateUnderstandTaskResponse:
        base_url = operations.UPDATE_UNDERSTAND_TASK_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.UpdateUnderstandTaskRequest, base_url, '/understand/Assistants/{AssistantSid}/Tasks/{Sid}', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'form')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.UpdateUnderstandTaskResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.PreviewUnderstandAssistantTask])
                res.preview_understand_assistant_task = out

        return res

    def update_understand_task_actions(self, request: operations.UpdateUnderstandTaskActionsRequest, security: operations.UpdateUnderstandTaskActionsSecurity, server_url: Optional[str] = None) -> operations.UpdateUnderstandTaskActionsResponse:
        r"""Updates the actions of an Task identified by {TaskSid} or {TaskUniqueName}."""
        base_url = operations.UPDATE_UNDERSTAND_TASK_ACTIONS_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.UpdateUnderstandTaskActionsRequest, base_url, '/understand/Assistants/{AssistantSid}/Tasks/{TaskSid}/Actions', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'form')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.UpdateUnderstandTaskActionsResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.PreviewUnderstandAssistantTaskTaskActions])
                res.preview_understand_assistant_task_task_actions = out

        return res

    def update_wireless_rate_plan(self, request: operations.UpdateWirelessRatePlanRequest, security: operations.UpdateWirelessRatePlanSecurity, server_url: Optional[str] = None) -> operations.UpdateWirelessRatePlanResponse:
        base_url = operations.UPDATE_WIRELESS_RATE_PLAN_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.UpdateWirelessRatePlanRequest, base_url, '/wireless/RatePlans/{Sid}', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'form')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.UpdateWirelessRatePlanResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.PreviewWirelessRatePlan])
                res.preview_wireless_rate_plan = out

        return res

    def update_wireless_sim(self, request: operations.UpdateWirelessSimRequest, security: operations.UpdateWirelessSimSecurity, server_url: Optional[str] = None) -> operations.UpdateWirelessSimResponse:
        base_url = operations.UPDATE_WIRELESS_SIM_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.UpdateWirelessSimRequest, base_url, '/wireless/Sims/{Sid}', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'form')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.UpdateWirelessSimResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.PreviewWirelessSim])
                res.preview_wireless_sim = out

        return res

    