"""Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT."""

import requests as requests_http
from . import utils
from sdk.models import operations, shared
from typing import Optional

class Weather:
    r"""#### Hourly forecast values for the following flight-impacting weather elements:
    * Cloud Ceiling (CIG)
    * Dewpoint Temperature (DEWPT)
    * Cloud Cover (SKY)
    * Air Temperature (TEMP)
    * Visibility (VIS)
    * Wind Direction (WINDDIR)
    * Wind Speed (WINDSPEED)
    * Wind Gust Speed (WINDGUST)
    """
    _client: requests_http.Session
    _security_client: requests_http.Session
    _server_url: str
    _language: str
    _sdk_version: str
    _gen_version: str

    def __init__(self, client: requests_http.Session, security_client: requests_http.Session, server_url: str, language: str, sdk_version: str, gen_version: str) -> None:
        self._client = client
        self._security_client = security_client
        self._server_url = server_url
        self._language = language
        self._sdk_version = sdk_version
        self._gen_version = gen_version
        
    def wx_by_distance_us_v1_wx_forecast_distance_query_post(self, request: operations.WxByDistanceUsV1WxForecastDistanceQueryPostRequest) -> operations.WxByDistanceUsV1WxForecastDistanceQueryPostResponse:
        r"""Retrieve forecast values within given distance of location for all requested weather elements and time periods.
        Retrieve forecast values for selected weather elements and time period. Request body parameters are:
        * latitude:  WGS84 latitude coordinate of your selected point, in decimal degrees
        * longitude:  WGS84 longitude coordinate of your selected point, in decimal degrees
        * distance:  distance in meters (max allowed value is 25000)
        * wxtypes:  list of one or more weather forecast elements you wish to retrieve. Allowed values are \"CIG\", \"DEWPT\", \"SKY\", \"TEMP\", \"VIS\", \"WINDDIR\", \"WINDGUST\", \"WINDSPEED\".
        * hours:  number of hourly forecasts to return (1-24). For current hour only you should enter value of 1. To also retrieve values for each of the next n hours, enter n.
        
        
        The response will consist of a GeoJSON FeatureCollection with one Feature for each forecast location found within requested area,
        properties of which will include an ordered list of forecast values for each requested weather element, for each requested hour. Units for each element are as follows:
        * CIG: meters AGL
        * DEWPT: degrees Celsius
        * SKY: % cloud cover
        * TEMP: degrees Celsius
        * VIS: meters
        * WINDDIR: degrees true
        * WINDGUST: meters/sec
        * WINDSPEED: meters/sec
        """
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/us/v1/wx-forecast/distance-query'
        
        headers = utils.get_headers(request)
        req_content_type, data, form = utils.serialize_request_body(request, "wx_by_distance", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = self._client
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.WxByDistanceUsV1WxForecastDistanceQueryPostResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.WxDistanceResponse])
                res.wx_distance_response = out
        elif http_res.status_code == 422:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.HTTPValidationError])
                res.http_validation_error = out

        return res

    def wx_by_poly_us_v1_wx_forecast_polygon_query_post(self, request: operations.WxByPolyUsV1WxForecastPolygonQueryPostRequest) -> operations.WxByPolyUsV1WxForecastPolygonQueryPostResponse:
        r"""Retrieve forecast values within given GeoJSON polygon for all requested weather elements and time periods.
        Retrieve forecast values located within given area for requested weather elements and time period. Request body parameters are:
        * poly:  [GeoJSON Polygon](https://www.rfc-editor.org/rfc/rfc7946.html#appendix-A) defining the area. Max allowed area is 1000 km^2.
        * wxtypes:  list of one or more weather forecast elements you wish to retrieve. Allowed values are \"CIG\", \"DEWPT\", \"SKY\", \"TEMP\", \"VIS\", \"WINDDIR\", \"WINDGUST\", \"WINDSPEED\".
        * hours:  number of hourly forecasts to return (1-24). For current hour only you should enter value of 1. To also retrieve values for each of the next n hours, enter n.
        
        
        The response will consist of a GeoJSON FeatureCollection with one Feature for each forecast location found within requested area,
        properties of which will include an ordered list of forecast values for each requested weather element, for each requested hour. Units for each element are as follows:
        * CIG: meters AGL
        * DEWPT: degrees Celsius
        * SKY: % cloud cover
        * TEMP: degrees Celsius
        * VIS: meters
        * WINDDIR: degrees true
        * WINDGUST: meters/sec
        * WINDSPEED: meters/sec
        """
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/us/v1/wx-forecast/polygon-query'
        
        headers = utils.get_headers(request)
        req_content_type, data, form = utils.serialize_request_body(request, "wx_by_polygon", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = self._client
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.WxByPolyUsV1WxForecastPolygonQueryPostResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.WxPolyResponse])
                res.wx_poly_response = out
        elif http_res.status_code == 422:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.HTTPValidationError])
                res.http_validation_error = out

        return res

    def wx_by_route_us_v1_wx_forecast_route_query_post(self, request: operations.WxByRouteUsV1WxForecastRouteQueryPostRequest) -> operations.WxByRouteUsV1WxForecastRouteQueryPostResponse:
        r"""Retrieve forecast values along a route for all requested weather elements and time periods.
        Retrieve forecast values along route for requested weather elements and time period. Request body parameters are:
        * route:  [GeoJSON Linestring](https://www.rfc-editor.org/rfc/rfc7946.html#appendix-A) defining the route. Max allowed length is 50 km.
        * wxtypes:  list of one or more weather forecast elements you wish to retrieve. Allowed values are \"CIG\", \"DEWPT\", \"SKY\", \"TEMP\", \"VIS\", \"WINDDIR\", \"WINDGUST\", \"WINDSPEED\".
        * hours:  number of hourly forecasts to return (1-24). For current hour only you should enter value of 1. To also retrieve values for each of the next n hours, enter n.
        
        
        The response will consist of a GeoJSON FeatureCollection with one Feature for each forecast location found within requested area,
        properties of which will include an ordered list of forecast values for each requested weather element, for each requested hour. Units for each element are as follows:
        * CIG: meters AGL
        * DEWPT: degrees Celsius
        * SKY: % cloud cover
        * TEMP: degrees Celsius
        * VIS: meters
        * WINDDIR: degrees true
        * WINDGUST: meters/sec
        * WINDSPEED: meters/sec
        """
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/us/v1/wx-forecast/route-query'
        
        headers = utils.get_headers(request)
        req_content_type, data, form = utils.serialize_request_body(request, "wx_by_route", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = self._client
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.WxByRouteUsV1WxForecastRouteQueryPostResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.WxRouteResponse])
                res.wx_route_response = out
        elif http_res.status_code == 422:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.HTTPValidationError])
                res.http_validation_error = out

        return res

    