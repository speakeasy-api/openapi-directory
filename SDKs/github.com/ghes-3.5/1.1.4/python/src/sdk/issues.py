"""Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT."""

import requests as requests_http
from . import utils
from sdk.models import operations, shared
from typing import Any, Optional

class Issues:
    r"""Interact with GitHub Issues."""
    _client: requests_http.Session
    _security_client: requests_http.Session
    _server_url: str
    _language: str
    _sdk_version: str
    _gen_version: str

    def __init__(self, client: requests_http.Session, security_client: requests_http.Session, server_url: str, language: str, sdk_version: str, gen_version: str) -> None:
        self._client = client
        self._security_client = security_client
        self._server_url = server_url
        self._language = language
        self._sdk_version = sdk_version
        self._gen_version = gen_version
        
    def issues_add_assignees(self, request: operations.IssuesAddAssigneesRequest) -> operations.IssuesAddAssigneesResponse:
        r"""Add assignees to an issue
        Adds up to 10 assignees to an issue. Users already assigned to an issue are not replaced.
        https://docs.github.com/enterprise-server@3.5/rest/reference/issues#add-assignees-to-an-issue - API method documentation
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.IssuesAddAssigneesRequest, base_url, '/repos/{owner}/{repo}/issues/{issue_number}/assignees', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        
        client = self._client
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.IssuesAddAssigneesResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 201:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Issue])
                res.issue = out

        return res

    def issues_add_labels(self, request: operations.IssuesAddLabelsRequest) -> operations.IssuesAddLabelsResponse:
        r"""Add labels to an issue
        https://docs.github.com/enterprise-server@3.5/rest/reference/issues#add-labels-to-an-issue - API method documentation
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.IssuesAddLabelsRequest, base_url, '/repos/{owner}/{repo}/issues/{issue_number}/labels', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        
        client = self._client
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.IssuesAddLabelsResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[list[shared.Label]])
                res.labels = out
        elif http_res.status_code in [301, 404, 410]:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.BasicError])
                res.basic_error = out
        elif http_res.status_code == 422:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ValidationError])
                res.validation_error = out

        return res

    def issues_check_user_can_be_assigned(self, request: operations.IssuesCheckUserCanBeAssignedRequest) -> operations.IssuesCheckUserCanBeAssignedResponse:
        r"""Check if a user can be assigned
        Checks if a user has permission to be assigned to an issue in this repository.
        
        If the `assignee` can be assigned to issues in the repository, a `204` header with no content is returned.
        
        Otherwise a `404` status code is returned.
        https://docs.github.com/enterprise-server@3.5/rest/reference/issues#check-if-a-user-can-be-assigned - API method documentation
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.IssuesCheckUserCanBeAssignedRequest, base_url, '/repos/{owner}/{repo}/assignees/{assignee}', request)
        
        
        client = self._client
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.IssuesCheckUserCanBeAssignedResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 204:
            pass
        elif http_res.status_code == 404:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.BasicError])
                res.basic_error = out

        return res

    def issues_check_user_can_be_assigned_to_issue(self, request: operations.IssuesCheckUserCanBeAssignedToIssueRequest) -> operations.IssuesCheckUserCanBeAssignedToIssueResponse:
        r"""Check if a user can be assigned to a issue
        Checks if a user has permission to be assigned to a specific issue.
        
        If the `assignee` can be assigned to this issue, a `204` status code with no content is returned.
        
        Otherwise a `404` status code is returned.
        https://docs.github.com/enterprise-server@3.5/rest/reference/issues#check-if-a-user-can-be-assigned-to-a-issue - API method documentation
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.IssuesCheckUserCanBeAssignedToIssueRequest, base_url, '/repos/{owner}/{repo}/issues/{issue_number}/assignees/{assignee}', request)
        
        
        client = self._client
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.IssuesCheckUserCanBeAssignedToIssueResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 204:
            pass
        elif http_res.status_code == 404:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.BasicError])
                res.basic_error = out

        return res

    def issues_create(self, request: operations.IssuesCreateRequest) -> operations.IssuesCreateResponse:
        r"""Create an issue
        Any user with pull access to a repository can create an issue. If [issues are disabled in the repository](https://docs.github.com/enterprise-server@3.5/articles/disabling-issues/), the API returns a `410 Gone` status.
        
        This endpoint triggers [notifications](https://docs.github.com/enterprise-server@3.5/github/managing-subscriptions-and-notifications-on-github/about-notifications). Creating content too quickly using this endpoint may result in secondary rate limiting. See \"[Secondary rate limits](https://docs.github.com/enterprise-server@3.5/rest/overview/resources-in-the-rest-api#secondary-rate-limits)\" and \"[Dealing with secondary rate limits](https://docs.github.com/enterprise-server@3.5/rest/guides/best-practices-for-integrators#dealing-with-secondary-rate-limits)\" for details.
        https://docs.github.com/enterprise-server@3.5/rest/reference/issues#create-an-issue - API method documentation
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.IssuesCreateRequest, base_url, '/repos/{owner}/{repo}/issues', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = self._client
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.IssuesCreateResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 201:
            res.headers = http_res.headers
            
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Issue])
                res.issue = out
        elif http_res.status_code in [403, 404, 410]:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.BasicError])
                res.basic_error = out
        elif http_res.status_code == 422:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ValidationError])
                res.validation_error = out
        elif http_res.status_code == 503:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.IssuesCreate503ApplicationJSON])
                res.issues_create_503_application_json_object = out

        return res

    def issues_create_comment(self, request: operations.IssuesCreateCommentRequest) -> operations.IssuesCreateCommentResponse:
        r"""Create an issue comment
        This endpoint triggers [notifications](https://docs.github.com/enterprise-server@3.5/github/managing-subscriptions-and-notifications-on-github/about-notifications). Creating content too quickly using this endpoint may result in secondary rate limiting. See \"[Secondary rate limits](https://docs.github.com/enterprise-server@3.5/rest/overview/resources-in-the-rest-api#secondary-rate-limits)\" and \"[Dealing with secondary rate limits](https://docs.github.com/enterprise-server@3.5/rest/guides/best-practices-for-integrators#dealing-with-secondary-rate-limits)\" for details.
        https://docs.github.com/enterprise-server@3.5/rest/reference/issues#create-an-issue-comment - API method documentation
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.IssuesCreateCommentRequest, base_url, '/repos/{owner}/{repo}/issues/{issue_number}/comments', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = self._client
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.IssuesCreateCommentResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 201:
            res.headers = http_res.headers
            
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.IssueComment])
                res.issue_comment = out
        elif http_res.status_code in [403, 404, 410]:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.BasicError])
                res.basic_error = out
        elif http_res.status_code == 422:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ValidationError])
                res.validation_error = out

        return res

    def issues_create_label(self, request: operations.IssuesCreateLabelRequest) -> operations.IssuesCreateLabelResponse:
        r"""Create a label
        https://docs.github.com/enterprise-server@3.5/rest/reference/issues#create-a-label - API method documentation
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.IssuesCreateLabelRequest, base_url, '/repos/{owner}/{repo}/labels', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = self._client
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.IssuesCreateLabelResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 201:
            res.headers = http_res.headers
            
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Label])
                res.label = out
        elif http_res.status_code == 404:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.BasicError])
                res.basic_error = out
        elif http_res.status_code == 422:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ValidationError])
                res.validation_error = out

        return res

    def issues_create_milestone(self, request: operations.IssuesCreateMilestoneRequest) -> operations.IssuesCreateMilestoneResponse:
        r"""Create a milestone
        https://docs.github.com/enterprise-server@3.5/rest/reference/issues#create-a-milestone - API method documentation
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.IssuesCreateMilestoneRequest, base_url, '/repos/{owner}/{repo}/milestones', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = self._client
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.IssuesCreateMilestoneResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 201:
            res.headers = http_res.headers
            
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Milestone])
                res.milestone = out
        elif http_res.status_code == 404:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.BasicError])
                res.basic_error = out
        elif http_res.status_code == 422:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ValidationError])
                res.validation_error = out

        return res

    def issues_delete_comment(self, request: operations.IssuesDeleteCommentRequest) -> operations.IssuesDeleteCommentResponse:
        r"""Delete an issue comment
        https://docs.github.com/enterprise-server@3.5/rest/reference/issues#delete-an-issue-comment - API method documentation
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.IssuesDeleteCommentRequest, base_url, '/repos/{owner}/{repo}/issues/comments/{comment_id}', request)
        
        
        client = self._client
        
        http_res = client.request('DELETE', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.IssuesDeleteCommentResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        

        return res

    def issues_delete_label(self, request: operations.IssuesDeleteLabelRequest) -> operations.IssuesDeleteLabelResponse:
        r"""Delete a label
        https://docs.github.com/enterprise-server@3.5/rest/reference/issues#delete-a-label - API method documentation
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.IssuesDeleteLabelRequest, base_url, '/repos/{owner}/{repo}/labels/{name}', request)
        
        
        client = self._client
        
        http_res = client.request('DELETE', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.IssuesDeleteLabelResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        

        return res

    def issues_delete_milestone(self, request: operations.IssuesDeleteMilestoneRequest) -> operations.IssuesDeleteMilestoneResponse:
        r"""Delete a milestone
        https://docs.github.com/enterprise-server@3.5/rest/reference/issues#delete-a-milestone - API method documentation
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.IssuesDeleteMilestoneRequest, base_url, '/repos/{owner}/{repo}/milestones/{milestone_number}', request)
        
        
        client = self._client
        
        http_res = client.request('DELETE', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.IssuesDeleteMilestoneResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 204:
            pass
        elif http_res.status_code == 404:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.BasicError])
                res.basic_error = out

        return res

    def issues_get(self, request: operations.IssuesGetRequest) -> operations.IssuesGetResponse:
        r"""Get an issue
        The API returns a [`301 Moved Permanently` status](https://docs.github.com/enterprise-server@3.5/rest/overview/resources-in-the-rest-api#http-redirects-redirects) if the issue was
        [transferred](https://docs.github.com/enterprise-server@3.5/articles/transferring-an-issue-to-another-repository/) to another repository. If
        the issue was transferred to or deleted from a repository where the authenticated user lacks read access, the API
        returns a `404 Not Found` status. If the issue was deleted from a repository where the authenticated user has read
        access, the API returns a `410 Gone` status. To receive webhook events for transferred and deleted issues, subscribe
        to the [`issues`](https://docs.github.com/enterprise-server@3.5/webhooks/event-payloads/#issues) webhook.
        
        **Note**: GitHub's REST API considers every pull request an issue, but not every issue is a pull request. For this
        reason, \"Issues\" endpoints may return both issues and pull requests in the response. You can identify pull requests by
        the `pull_request` key. Be aware that the `id` of a pull request returned from \"Issues\" endpoints will be an _issue id_. To find out the pull
        request id, use the \"[List pull requests](https://docs.github.com/enterprise-server@3.5/rest/reference/pulls#list-pull-requests)\" endpoint.
        https://docs.github.com/enterprise-server@3.5/rest/reference/issues#get-an-issue - API method documentation
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.IssuesGetRequest, base_url, '/repos/{owner}/{repo}/issues/{issue_number}', request)
        
        
        client = self._client
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.IssuesGetResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Issue])
                res.issue = out
        elif http_res.status_code in [301, 404, 410]:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.BasicError])
                res.basic_error = out
        elif http_res.status_code == 304:
            pass

        return res

    def issues_get_comment(self, request: operations.IssuesGetCommentRequest) -> operations.IssuesGetCommentResponse:
        r"""Get an issue comment
        https://docs.github.com/enterprise-server@3.5/rest/reference/issues#get-an-issue-comment - API method documentation
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.IssuesGetCommentRequest, base_url, '/repos/{owner}/{repo}/issues/comments/{comment_id}', request)
        
        
        client = self._client
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.IssuesGetCommentResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.IssueComment])
                res.issue_comment = out
        elif http_res.status_code == 404:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.BasicError])
                res.basic_error = out

        return res

    def issues_get_event(self, request: operations.IssuesGetEventRequest) -> operations.IssuesGetEventResponse:
        r"""Get an issue event
        https://docs.github.com/enterprise-server@3.5/rest/reference/issues#get-an-issue-event - API method documentation
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.IssuesGetEventRequest, base_url, '/repos/{owner}/{repo}/issues/events/{event_id}', request)
        
        
        client = self._client
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.IssuesGetEventResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.IssueEvent])
                res.issue_event = out
        elif http_res.status_code in [403, 404, 410]:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.BasicError])
                res.basic_error = out

        return res

    def issues_get_label(self, request: operations.IssuesGetLabelRequest) -> operations.IssuesGetLabelResponse:
        r"""Get a label
        https://docs.github.com/enterprise-server@3.5/rest/reference/issues#get-a-label - API method documentation
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.IssuesGetLabelRequest, base_url, '/repos/{owner}/{repo}/labels/{name}', request)
        
        
        client = self._client
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.IssuesGetLabelResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Label])
                res.label = out
        elif http_res.status_code == 404:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.BasicError])
                res.basic_error = out

        return res

    def issues_get_milestone(self, request: operations.IssuesGetMilestoneRequest) -> operations.IssuesGetMilestoneResponse:
        r"""Get a milestone
        https://docs.github.com/enterprise-server@3.5/rest/reference/issues#get-a-milestone - API method documentation
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.IssuesGetMilestoneRequest, base_url, '/repos/{owner}/{repo}/milestones/{milestone_number}', request)
        
        
        client = self._client
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.IssuesGetMilestoneResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Milestone])
                res.milestone = out
        elif http_res.status_code == 404:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.BasicError])
                res.basic_error = out

        return res

    def issues_list(self, request: operations.IssuesListRequest) -> operations.IssuesListResponse:
        r"""List issues assigned to the authenticated user
        List issues assigned to the authenticated user across all visible repositories including owned repositories, member
        repositories, and organization repositories. You can use the `filter` query parameter to fetch issues that are not
        necessarily assigned to you.
        
        
        **Note**: GitHub's REST API considers every pull request an issue, but not every issue is a pull request. For this
        reason, \"Issues\" endpoints may return both issues and pull requests in the response. You can identify pull requests by
        the `pull_request` key. Be aware that the `id` of a pull request returned from \"Issues\" endpoints will be an _issue id_. To find out the pull
        request id, use the \"[List pull requests](https://docs.github.com/enterprise-server@3.5/rest/reference/pulls#list-pull-requests)\" endpoint.
        https://docs.github.com/enterprise-server@3.5/rest/reference/issues#list-issues-assigned-to-the-authenticated-user - API method documentation
        """
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/issues'
        
        query_params = utils.get_query_params(operations.IssuesListRequest, request)
        
        client = self._client
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.IssuesListResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            res.headers = http_res.headers
            
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[list[shared.Issue]])
                res.issues = out
        elif http_res.status_code == 304:
            pass
        elif http_res.status_code == 404:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.BasicError])
                res.basic_error = out
        elif http_res.status_code == 422:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ValidationError])
                res.validation_error = out

        return res

    def issues_list_assignees(self, request: operations.IssuesListAssigneesRequest) -> operations.IssuesListAssigneesResponse:
        r"""List assignees
        Lists the [available assignees](https://docs.github.com/enterprise-server@3.5/articles/assigning-issues-and-pull-requests-to-other-github-users/) for issues in a repository.
        https://docs.github.com/enterprise-server@3.5/rest/reference/issues#list-assignees - API method documentation
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.IssuesListAssigneesRequest, base_url, '/repos/{owner}/{repo}/assignees', request)
        
        query_params = utils.get_query_params(operations.IssuesListAssigneesRequest, request)
        
        client = self._client
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.IssuesListAssigneesResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            res.headers = http_res.headers
            
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[list[shared.SimpleUser]])
                res.simple_users = out
        elif http_res.status_code == 404:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.BasicError])
                res.basic_error = out

        return res

    def issues_list_comments(self, request: operations.IssuesListCommentsRequest) -> operations.IssuesListCommentsResponse:
        r"""List issue comments
        Issue Comments are ordered by ascending ID.
        https://docs.github.com/enterprise-server@3.5/rest/reference/issues#list-issue-comments - API method documentation
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.IssuesListCommentsRequest, base_url, '/repos/{owner}/{repo}/issues/{issue_number}/comments', request)
        
        query_params = utils.get_query_params(operations.IssuesListCommentsRequest, request)
        
        client = self._client
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.IssuesListCommentsResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            res.headers = http_res.headers
            
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[list[shared.IssueComment]])
                res.issue_comments = out
        elif http_res.status_code in [404, 410]:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.BasicError])
                res.basic_error = out

        return res

    def issues_list_comments_for_repo(self, request: operations.IssuesListCommentsForRepoRequest) -> operations.IssuesListCommentsForRepoResponse:
        r"""List issue comments for a repository
        By default, Issue Comments are ordered by ascending ID.
        https://docs.github.com/enterprise-server@3.5/rest/reference/issues#list-issue-comments-for-a-repository - API method documentation
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.IssuesListCommentsForRepoRequest, base_url, '/repos/{owner}/{repo}/issues/comments', request)
        
        query_params = utils.get_query_params(operations.IssuesListCommentsForRepoRequest, request)
        
        client = self._client
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.IssuesListCommentsForRepoResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            res.headers = http_res.headers
            
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[list[shared.IssueComment]])
                res.issue_comments = out
        elif http_res.status_code == 404:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.BasicError])
                res.basic_error = out
        elif http_res.status_code == 422:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ValidationError])
                res.validation_error = out

        return res

    def issues_list_events(self, request: operations.IssuesListEventsRequest) -> operations.IssuesListEventsResponse:
        r"""List issue events
        https://docs.github.com/enterprise-server@3.5/rest/reference/issues#list-issue-events - API method documentation
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.IssuesListEventsRequest, base_url, '/repos/{owner}/{repo}/issues/{issue_number}/events', request)
        
        query_params = utils.get_query_params(operations.IssuesListEventsRequest, request)
        
        client = self._client
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.IssuesListEventsResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            res.headers = http_res.headers
            
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[list[Any]])
                res.issue_event_for_issues = out
        elif http_res.status_code == 410:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.BasicError])
                res.basic_error = out

        return res

    def issues_list_events_for_repo(self, request: operations.IssuesListEventsForRepoRequest) -> operations.IssuesListEventsForRepoResponse:
        r"""List issue events for a repository
        https://docs.github.com/enterprise-server@3.5/rest/reference/issues#list-issue-events-for-a-repository - API method documentation
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.IssuesListEventsForRepoRequest, base_url, '/repos/{owner}/{repo}/issues/events', request)
        
        query_params = utils.get_query_params(operations.IssuesListEventsForRepoRequest, request)
        
        client = self._client
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.IssuesListEventsForRepoResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            res.headers = http_res.headers
            
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[list[shared.IssueEvent]])
                res.issue_events = out
        elif http_res.status_code == 422:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ValidationError])
                res.validation_error = out

        return res

    def issues_list_events_for_timeline(self, request: operations.IssuesListEventsForTimelineRequest) -> operations.IssuesListEventsForTimelineResponse:
        r"""List timeline events for an issue
        https://docs.github.com/enterprise-server@3.5/rest/reference/issues#list-timeline-events-for-an-issue - API method documentation
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.IssuesListEventsForTimelineRequest, base_url, '/repos/{owner}/{repo}/issues/{issue_number}/timeline', request)
        
        query_params = utils.get_query_params(operations.IssuesListEventsForTimelineRequest, request)
        
        client = self._client
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.IssuesListEventsForTimelineResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            res.headers = http_res.headers
            
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[list[Any]])
                res.timeline_issue_events = out
        elif http_res.status_code in [404, 410]:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.BasicError])
                res.basic_error = out

        return res

    def issues_list_for_authenticated_user(self, request: operations.IssuesListForAuthenticatedUserRequest) -> operations.IssuesListForAuthenticatedUserResponse:
        r"""List user account issues assigned to the authenticated user
        List issues across owned and member repositories assigned to the authenticated user.
        
        **Note**: GitHub's REST API considers every pull request an issue, but not every issue is a pull request. For this
        reason, \"Issues\" endpoints may return both issues and pull requests in the response. You can identify pull requests by
        the `pull_request` key. Be aware that the `id` of a pull request returned from \"Issues\" endpoints will be an _issue id_. To find out the pull
        request id, use the \"[List pull requests](https://docs.github.com/enterprise-server@3.5/rest/reference/pulls#list-pull-requests)\" endpoint.
        https://docs.github.com/enterprise-server@3.5/rest/reference/issues#list-user-account-issues-assigned-to-the-authenticated-user - API method documentation
        """
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/user/issues'
        
        query_params = utils.get_query_params(operations.IssuesListForAuthenticatedUserRequest, request)
        
        client = self._client
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.IssuesListForAuthenticatedUserResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            res.headers = http_res.headers
            
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[list[shared.Issue]])
                res.issues = out
        elif http_res.status_code == 304:
            pass
        elif http_res.status_code == 404:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.BasicError])
                res.basic_error = out

        return res

    def issues_list_for_org(self, request: operations.IssuesListForOrgRequest) -> operations.IssuesListForOrgResponse:
        r"""List organization issues assigned to the authenticated user
        List issues in an organization assigned to the authenticated user.
        
        **Note**: GitHub's REST API considers every pull request an issue, but not every issue is a pull request. For this
        reason, \"Issues\" endpoints may return both issues and pull requests in the response. You can identify pull requests by
        the `pull_request` key. Be aware that the `id` of a pull request returned from \"Issues\" endpoints will be an _issue id_. To find out the pull
        request id, use the \"[List pull requests](https://docs.github.com/enterprise-server@3.5/rest/reference/pulls#list-pull-requests)\" endpoint.
        https://docs.github.com/enterprise-server@3.5/rest/reference/issues#list-organization-issues-assigned-to-the-authenticated-user - API method documentation
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.IssuesListForOrgRequest, base_url, '/orgs/{org}/issues', request)
        
        query_params = utils.get_query_params(operations.IssuesListForOrgRequest, request)
        
        client = self._client
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.IssuesListForOrgResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            res.headers = http_res.headers
            
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[list[shared.Issue]])
                res.issues = out
        elif http_res.status_code == 404:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.BasicError])
                res.basic_error = out

        return res

    def issues_list_for_repo(self, request: operations.IssuesListForRepoRequest) -> operations.IssuesListForRepoResponse:
        r"""List repository issues
        List issues in a repository. Only open issues will be listed.
        
        **Note**: GitHub's REST API considers every pull request an issue, but not every issue is a pull request. For this
        reason, \"Issues\" endpoints may return both issues and pull requests in the response. You can identify pull requests by
        the `pull_request` key. Be aware that the `id` of a pull request returned from \"Issues\" endpoints will be an _issue id_. To find out the pull
        request id, use the \"[List pull requests](https://docs.github.com/enterprise-server@3.5/rest/reference/pulls#list-pull-requests)\" endpoint.
        https://docs.github.com/enterprise-server@3.5/rest/reference/issues#list-repository-issues - API method documentation
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.IssuesListForRepoRequest, base_url, '/repos/{owner}/{repo}/issues', request)
        
        query_params = utils.get_query_params(operations.IssuesListForRepoRequest, request)
        
        client = self._client
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.IssuesListForRepoResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            res.headers = http_res.headers
            
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[list[shared.Issue]])
                res.issues = out
        elif http_res.status_code in [301, 404]:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.BasicError])
                res.basic_error = out
        elif http_res.status_code == 422:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ValidationError])
                res.validation_error = out

        return res

    def issues_list_labels_for_milestone(self, request: operations.IssuesListLabelsForMilestoneRequest) -> operations.IssuesListLabelsForMilestoneResponse:
        r"""List labels for issues in a milestone
        https://docs.github.com/enterprise-server@3.5/rest/reference/issues#list-labels-for-issues-in-a-milestone - API method documentation
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.IssuesListLabelsForMilestoneRequest, base_url, '/repos/{owner}/{repo}/milestones/{milestone_number}/labels', request)
        
        query_params = utils.get_query_params(operations.IssuesListLabelsForMilestoneRequest, request)
        
        client = self._client
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.IssuesListLabelsForMilestoneResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            res.headers = http_res.headers
            
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[list[shared.Label]])
                res.labels = out

        return res

    def issues_list_labels_for_repo(self, request: operations.IssuesListLabelsForRepoRequest) -> operations.IssuesListLabelsForRepoResponse:
        r"""List labels for a repository
        https://docs.github.com/enterprise-server@3.5/rest/reference/issues#list-labels-for-a-repository - API method documentation
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.IssuesListLabelsForRepoRequest, base_url, '/repos/{owner}/{repo}/labels', request)
        
        query_params = utils.get_query_params(operations.IssuesListLabelsForRepoRequest, request)
        
        client = self._client
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.IssuesListLabelsForRepoResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            res.headers = http_res.headers
            
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[list[shared.Label]])
                res.labels = out
        elif http_res.status_code == 404:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.BasicError])
                res.basic_error = out

        return res

    def issues_list_labels_on_issue(self, request: operations.IssuesListLabelsOnIssueRequest) -> operations.IssuesListLabelsOnIssueResponse:
        r"""List labels for an issue
        https://docs.github.com/enterprise-server@3.5/rest/reference/issues#list-labels-for-an-issue - API method documentation
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.IssuesListLabelsOnIssueRequest, base_url, '/repos/{owner}/{repo}/issues/{issue_number}/labels', request)
        
        query_params = utils.get_query_params(operations.IssuesListLabelsOnIssueRequest, request)
        
        client = self._client
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.IssuesListLabelsOnIssueResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            res.headers = http_res.headers
            
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[list[shared.Label]])
                res.labels = out
        elif http_res.status_code in [301, 404, 410]:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.BasicError])
                res.basic_error = out

        return res

    def issues_list_milestones(self, request: operations.IssuesListMilestonesRequest) -> operations.IssuesListMilestonesResponse:
        r"""List milestones
        https://docs.github.com/enterprise-server@3.5/rest/reference/issues#list-milestones - API method documentation
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.IssuesListMilestonesRequest, base_url, '/repos/{owner}/{repo}/milestones', request)
        
        query_params = utils.get_query_params(operations.IssuesListMilestonesRequest, request)
        
        client = self._client
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.IssuesListMilestonesResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            res.headers = http_res.headers
            
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[list[shared.Milestone]])
                res.milestones = out
        elif http_res.status_code == 404:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.BasicError])
                res.basic_error = out

        return res

    def issues_lock(self, request: operations.IssuesLockRequest) -> operations.IssuesLockResponse:
        r"""Lock an issue
        Users with push access can lock an issue or pull request's conversation.
        
        Note that, if you choose not to pass any parameters, you'll need to set `Content-Length` to zero when calling out to this endpoint. For more information, see \"[HTTP verbs](https://docs.github.com/enterprise-server@3.5/rest/overview/resources-in-the-rest-api#http-verbs).\" 
        https://docs.github.com/enterprise-server@3.5/rest/reference/issues#lock-an-issue - API method documentation
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.IssuesLockRequest, base_url, '/repos/{owner}/{repo}/issues/{issue_number}/lock', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        
        client = self._client
        
        http_res = client.request('PUT', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.IssuesLockResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 204:
            pass
        elif http_res.status_code in [403, 404, 410]:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.BasicError])
                res.basic_error = out
        elif http_res.status_code == 422:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ValidationError])
                res.validation_error = out

        return res

    def issues_remove_all_labels(self, request: operations.IssuesRemoveAllLabelsRequest) -> operations.IssuesRemoveAllLabelsResponse:
        r"""Remove all labels from an issue
        https://docs.github.com/enterprise-server@3.5/rest/reference/issues#remove-all-labels-from-an-issue - API method documentation
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.IssuesRemoveAllLabelsRequest, base_url, '/repos/{owner}/{repo}/issues/{issue_number}/labels', request)
        
        
        client = self._client
        
        http_res = client.request('DELETE', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.IssuesRemoveAllLabelsResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 204:
            pass
        elif http_res.status_code in [301, 404, 410]:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.BasicError])
                res.basic_error = out

        return res

    def issues_remove_assignees(self, request: operations.IssuesRemoveAssigneesRequest) -> operations.IssuesRemoveAssigneesResponse:
        r"""Remove assignees from an issue
        Removes one or more assignees from an issue.
        https://docs.github.com/enterprise-server@3.5/rest/reference/issues#remove-assignees-from-an-issue - API method documentation
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.IssuesRemoveAssigneesRequest, base_url, '/repos/{owner}/{repo}/issues/{issue_number}/assignees', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        
        client = self._client
        
        http_res = client.request('DELETE', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.IssuesRemoveAssigneesResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Issue])
                res.issue = out

        return res

    def issues_remove_label(self, request: operations.IssuesRemoveLabelRequest) -> operations.IssuesRemoveLabelResponse:
        r"""Remove a label from an issue
        Removes the specified label from the issue, and returns the remaining labels on the issue. This endpoint returns a `404 Not Found` status if the label does not exist.
        https://docs.github.com/enterprise-server@3.5/rest/reference/issues#remove-a-label-from-an-issue - API method documentation
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.IssuesRemoveLabelRequest, base_url, '/repos/{owner}/{repo}/issues/{issue_number}/labels/{name}', request)
        
        
        client = self._client
        
        http_res = client.request('DELETE', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.IssuesRemoveLabelResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[list[shared.Label]])
                res.labels = out
        elif http_res.status_code in [301, 404, 410]:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.BasicError])
                res.basic_error = out

        return res

    def issues_set_labels(self, request: operations.IssuesSetLabelsRequest) -> operations.IssuesSetLabelsResponse:
        r"""Set labels for an issue
        Removes any previous labels and sets the new labels for an issue.
        https://docs.github.com/enterprise-server@3.5/rest/reference/issues#set-labels-for-an-issue - API method documentation
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.IssuesSetLabelsRequest, base_url, '/repos/{owner}/{repo}/issues/{issue_number}/labels', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        
        client = self._client
        
        http_res = client.request('PUT', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.IssuesSetLabelsResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[list[shared.Label]])
                res.labels = out
        elif http_res.status_code in [301, 404, 410]:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.BasicError])
                res.basic_error = out
        elif http_res.status_code == 422:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ValidationError])
                res.validation_error = out

        return res

    def issues_unlock(self, request: operations.IssuesUnlockRequest) -> operations.IssuesUnlockResponse:
        r"""Unlock an issue
        Users with push access can unlock an issue's conversation.
        https://docs.github.com/enterprise-server@3.5/rest/reference/issues#unlock-an-issue - API method documentation
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.IssuesUnlockRequest, base_url, '/repos/{owner}/{repo}/issues/{issue_number}/lock', request)
        
        
        client = self._client
        
        http_res = client.request('DELETE', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.IssuesUnlockResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 204:
            pass
        elif http_res.status_code in [403, 404]:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.BasicError])
                res.basic_error = out

        return res

    def issues_update(self, request: operations.IssuesUpdateRequest) -> operations.IssuesUpdateResponse:
        r"""Update an issue
        Issue owners and users with push access can edit an issue.
        https://docs.github.com/enterprise-server@3.5/rest/reference/issues#update-an-issue - API method documentation
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.IssuesUpdateRequest, base_url, '/repos/{owner}/{repo}/issues/{issue_number}', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        
        client = self._client
        
        http_res = client.request('PATCH', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.IssuesUpdateResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Issue])
                res.issue = out
        elif http_res.status_code in [301, 403, 404, 410]:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.BasicError])
                res.basic_error = out
        elif http_res.status_code == 422:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ValidationError])
                res.validation_error = out
        elif http_res.status_code == 503:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.IssuesUpdate503ApplicationJSON])
                res.issues_update_503_application_json_object = out

        return res

    def issues_update_comment(self, request: operations.IssuesUpdateCommentRequest) -> operations.IssuesUpdateCommentResponse:
        r"""Update an issue comment
        https://docs.github.com/enterprise-server@3.5/rest/reference/issues#update-an-issue-comment - API method documentation
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.IssuesUpdateCommentRequest, base_url, '/repos/{owner}/{repo}/issues/comments/{comment_id}', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = self._client
        
        http_res = client.request('PATCH', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.IssuesUpdateCommentResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.IssueComment])
                res.issue_comment = out
        elif http_res.status_code == 422:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ValidationError])
                res.validation_error = out

        return res

    def issues_update_label(self, request: operations.IssuesUpdateLabelRequest) -> operations.IssuesUpdateLabelResponse:
        r"""Update a label
        https://docs.github.com/enterprise-server@3.5/rest/reference/issues#update-a-label - API method documentation
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.IssuesUpdateLabelRequest, base_url, '/repos/{owner}/{repo}/labels/{name}', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        
        client = self._client
        
        http_res = client.request('PATCH', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.IssuesUpdateLabelResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Label])
                res.label = out

        return res

    def issues_update_milestone(self, request: operations.IssuesUpdateMilestoneRequest) -> operations.IssuesUpdateMilestoneResponse:
        r"""Update a milestone
        https://docs.github.com/enterprise-server@3.5/rest/reference/issues#update-a-milestone - API method documentation
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.IssuesUpdateMilestoneRequest, base_url, '/repos/{owner}/{repo}/milestones/{milestone_number}', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        
        client = self._client
        
        http_res = client.request('PATCH', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.IssuesUpdateMilestoneResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Milestone])
                res.milestone = out

        return res

    