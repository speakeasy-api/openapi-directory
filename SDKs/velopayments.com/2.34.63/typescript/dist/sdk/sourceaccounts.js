"use strict";
/*
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SourceAccounts = void 0;
var utils = __importStar(require("../internal/utils"));
var operations = __importStar(require("./models/operations"));
var shared = __importStar(require("./models/shared"));
/**
 * <p>Source Accounts are where funds are drawn from for making payouts</p>
 *
 * @remarks
 *
 */
var SourceAccounts = /** @class */ (function () {
    function SourceAccounts(defaultClient, securityClient, serverURL, language, sdkVersion, genVersion) {
        this._defaultClient = defaultClient;
        this._securityClient = securityClient;
        this._serverURL = serverURL;
        this._language = language;
        this._sdkVersion = sdkVersion;
        this._genVersion = genVersion;
    }
    /**
     * Get Source Account
     *
     * @remarks
     * Get details about given source account.
     */
    SourceAccounts.prototype.getSourceAccountV2 = function (req, config) {
        if (!(req instanceof utils.SpeakeasyBase)) {
            req = new operations.GetSourceAccountV2Request(req);
        }
        var baseURL = this._serverURL;
        var url = utils.generateURL(baseURL, "/v2/sourceAccounts/{sourceAccountId}", req);
        var client = this._securityClient || this._defaultClient;
        var r = client.request(__assign({ url: url, method: "get" }, config));
        return r.then(function (httpRes) {
            var _a, _b;
            var contentType = (_b = (_a = httpRes === null || httpRes === void 0 ? void 0 : httpRes.headers) === null || _a === void 0 ? void 0 : _a["content-type"]) !== null && _b !== void 0 ? _b : "";
            if ((httpRes === null || httpRes === void 0 ? void 0 : httpRes.status) == null)
                throw new Error("status code not found in response: ".concat(httpRes));
            var res = new operations.GetSourceAccountV2Response({
                statusCode: httpRes.status,
                contentType: contentType,
                rawResponse: httpRes,
            });
            switch (true) {
                case (httpRes === null || httpRes === void 0 ? void 0 : httpRes.status) == 200:
                    if (utils.matchContentType(contentType, "application/json")) {
                        res.sourceAccountResponseV2 = utils.objectToClass(httpRes === null || httpRes === void 0 ? void 0 : httpRes.data, shared.SourceAccountResponseV2);
                    }
                    break;
                case (httpRes === null || httpRes === void 0 ? void 0 : httpRes.status) == 400:
                    if (utils.matchContentType(contentType, "application/json")) {
                        res.inlineResponse400 = utils.objectToClass(httpRes === null || httpRes === void 0 ? void 0 : httpRes.data, shared.InlineResponse400);
                    }
                    break;
                case (httpRes === null || httpRes === void 0 ? void 0 : httpRes.status) == 401:
                    if (utils.matchContentType(contentType, "application/json")) {
                        res.inlineResponse401 = utils.objectToClass(httpRes === null || httpRes === void 0 ? void 0 : httpRes.data, shared.InlineResponse401);
                    }
                    break;
                case (httpRes === null || httpRes === void 0 ? void 0 : httpRes.status) == 403:
                    if (utils.matchContentType(contentType, "application/json")) {
                        res.inlineResponse403 = utils.objectToClass(httpRes === null || httpRes === void 0 ? void 0 : httpRes.data, shared.InlineResponse403);
                    }
                    break;
                case (httpRes === null || httpRes === void 0 ? void 0 : httpRes.status) == 404:
                    if (utils.matchContentType(contentType, "application/json")) {
                        res.inlineResponse404 = utils.objectToClass(httpRes === null || httpRes === void 0 ? void 0 : httpRes.data, shared.InlineResponse404);
                    }
                    break;
            }
            return res;
        });
    };
    /**
     * Get details about given source account.
     *
     * @remarks
     * Get details about given source account.
     */
    SourceAccounts.prototype.getSourceAccountV3 = function (req, config) {
        if (!(req instanceof utils.SpeakeasyBase)) {
            req = new operations.GetSourceAccountV3Request(req);
        }
        var baseURL = this._serverURL;
        var url = utils.generateURL(baseURL, "/v3/sourceAccounts/{sourceAccountId}", req);
        var client = this._securityClient || this._defaultClient;
        var r = client.request(__assign({ url: url, method: "get" }, config));
        return r.then(function (httpRes) {
            var _a, _b;
            var contentType = (_b = (_a = httpRes === null || httpRes === void 0 ? void 0 : httpRes.headers) === null || _a === void 0 ? void 0 : _a["content-type"]) !== null && _b !== void 0 ? _b : "";
            if ((httpRes === null || httpRes === void 0 ? void 0 : httpRes.status) == null)
                throw new Error("status code not found in response: ".concat(httpRes));
            var res = new operations.GetSourceAccountV3Response({
                statusCode: httpRes.status,
                contentType: contentType,
                rawResponse: httpRes,
            });
            switch (true) {
                case (httpRes === null || httpRes === void 0 ? void 0 : httpRes.status) == 200:
                    if (utils.matchContentType(contentType, "application/json")) {
                        res.sourceAccountResponseV3 = utils.objectToClass(httpRes === null || httpRes === void 0 ? void 0 : httpRes.data, shared.SourceAccountResponseV3);
                    }
                    break;
                case (httpRes === null || httpRes === void 0 ? void 0 : httpRes.status) == 400:
                    if (utils.matchContentType(contentType, "application/json")) {
                        res.inlineResponse400 = utils.objectToClass(httpRes === null || httpRes === void 0 ? void 0 : httpRes.data, shared.InlineResponse400);
                    }
                    break;
                case (httpRes === null || httpRes === void 0 ? void 0 : httpRes.status) == 401:
                    if (utils.matchContentType(contentType, "application/json")) {
                        res.inlineResponse401 = utils.objectToClass(httpRes === null || httpRes === void 0 ? void 0 : httpRes.data, shared.InlineResponse401);
                    }
                    break;
                case (httpRes === null || httpRes === void 0 ? void 0 : httpRes.status) == 403:
                    if (utils.matchContentType(contentType, "application/json")) {
                        res.inlineResponse403 = utils.objectToClass(httpRes === null || httpRes === void 0 ? void 0 : httpRes.data, shared.InlineResponse403);
                    }
                    break;
                case (httpRes === null || httpRes === void 0 ? void 0 : httpRes.status) == 404:
                    if (utils.matchContentType(contentType, "application/json")) {
                        res.inlineResponse404 = utils.objectToClass(httpRes === null || httpRes === void 0 ? void 0 : httpRes.data, shared.InlineResponse404);
                    }
                    break;
            }
            return res;
        });
    };
    /**
     * Get list of source accounts
     *
     * @remarks
     * List source accounts.
     */
    SourceAccounts.prototype.getSourceAccountsV2 = function (req, config) {
        if (!(req instanceof utils.SpeakeasyBase)) {
            req = new operations.GetSourceAccountsV2Request(req);
        }
        var baseURL = this._serverURL;
        var url = baseURL.replace(/\/$/, "") + "/v2/sourceAccounts";
        var client = this._securityClient || this._defaultClient;
        var queryParams = utils.serializeQueryParams(req);
        var r = client.request(__assign({ url: url + queryParams, method: "get" }, config));
        return r.then(function (httpRes) {
            var _a, _b;
            var contentType = (_b = (_a = httpRes === null || httpRes === void 0 ? void 0 : httpRes.headers) === null || _a === void 0 ? void 0 : _a["content-type"]) !== null && _b !== void 0 ? _b : "";
            if ((httpRes === null || httpRes === void 0 ? void 0 : httpRes.status) == null)
                throw new Error("status code not found in response: ".concat(httpRes));
            var res = new operations.GetSourceAccountsV2Response({
                statusCode: httpRes.status,
                contentType: contentType,
                rawResponse: httpRes,
            });
            switch (true) {
                case (httpRes === null || httpRes === void 0 ? void 0 : httpRes.status) == 200:
                    if (utils.matchContentType(contentType, "application/json")) {
                        res.listSourceAccountResponseV2 = utils.objectToClass(httpRes === null || httpRes === void 0 ? void 0 : httpRes.data, shared.ListSourceAccountResponseV2);
                    }
                    break;
                case (httpRes === null || httpRes === void 0 ? void 0 : httpRes.status) == 400:
                    if (utils.matchContentType(contentType, "application/json")) {
                        res.inlineResponse400 = utils.objectToClass(httpRes === null || httpRes === void 0 ? void 0 : httpRes.data, shared.InlineResponse400);
                    }
                    break;
                case (httpRes === null || httpRes === void 0 ? void 0 : httpRes.status) == 401:
                    if (utils.matchContentType(contentType, "application/json")) {
                        res.inlineResponse401 = utils.objectToClass(httpRes === null || httpRes === void 0 ? void 0 : httpRes.data, shared.InlineResponse401);
                    }
                    break;
                case (httpRes === null || httpRes === void 0 ? void 0 : httpRes.status) == 403:
                    if (utils.matchContentType(contentType, "application/json")) {
                        res.inlineResponse403 = utils.objectToClass(httpRes === null || httpRes === void 0 ? void 0 : httpRes.data, shared.InlineResponse403);
                    }
                    break;
                case (httpRes === null || httpRes === void 0 ? void 0 : httpRes.status) == 404:
                    if (utils.matchContentType(contentType, "application/json")) {
                        res.inlineResponse404 = utils.objectToClass(httpRes === null || httpRes === void 0 ? void 0 : httpRes.data, shared.InlineResponse404);
                    }
                    break;
            }
            return res;
        });
    };
    /**
     * Get list of source accounts
     *
     * @remarks
     * List source accounts.
     */
    SourceAccounts.prototype.getSourceAccountsV3 = function (req, config) {
        if (!(req instanceof utils.SpeakeasyBase)) {
            req = new operations.GetSourceAccountsV3Request(req);
        }
        var baseURL = this._serverURL;
        var url = baseURL.replace(/\/$/, "") + "/v3/sourceAccounts";
        var client = this._securityClient || this._defaultClient;
        var queryParams = utils.serializeQueryParams(req);
        var r = client.request(__assign({ url: url + queryParams, method: "get" }, config));
        return r.then(function (httpRes) {
            var _a, _b;
            var contentType = (_b = (_a = httpRes === null || httpRes === void 0 ? void 0 : httpRes.headers) === null || _a === void 0 ? void 0 : _a["content-type"]) !== null && _b !== void 0 ? _b : "";
            if ((httpRes === null || httpRes === void 0 ? void 0 : httpRes.status) == null)
                throw new Error("status code not found in response: ".concat(httpRes));
            var res = new operations.GetSourceAccountsV3Response({
                statusCode: httpRes.status,
                contentType: contentType,
                rawResponse: httpRes,
            });
            switch (true) {
                case (httpRes === null || httpRes === void 0 ? void 0 : httpRes.status) == 200:
                    if (utils.matchContentType(contentType, "application/json")) {
                        res.listSourceAccountResponseV3 = utils.objectToClass(httpRes === null || httpRes === void 0 ? void 0 : httpRes.data, shared.ListSourceAccountResponseV3);
                    }
                    break;
                case (httpRes === null || httpRes === void 0 ? void 0 : httpRes.status) == 400:
                    if (utils.matchContentType(contentType, "application/json")) {
                        res.inlineResponse400 = utils.objectToClass(httpRes === null || httpRes === void 0 ? void 0 : httpRes.data, shared.InlineResponse400);
                    }
                    break;
                case (httpRes === null || httpRes === void 0 ? void 0 : httpRes.status) == 401:
                    if (utils.matchContentType(contentType, "application/json")) {
                        res.inlineResponse401 = utils.objectToClass(httpRes === null || httpRes === void 0 ? void 0 : httpRes.data, shared.InlineResponse401);
                    }
                    break;
                case (httpRes === null || httpRes === void 0 ? void 0 : httpRes.status) == 403:
                    if (utils.matchContentType(contentType, "application/json")) {
                        res.inlineResponse403 = utils.objectToClass(httpRes === null || httpRes === void 0 ? void 0 : httpRes.data, shared.InlineResponse403);
                    }
                    break;
                case (httpRes === null || httpRes === void 0 ? void 0 : httpRes.status) == 404:
                    if (utils.matchContentType(contentType, "application/json")) {
                        res.inlineResponse404 = utils.objectToClass(httpRes === null || httpRes === void 0 ? void 0 : httpRes.data, shared.InlineResponse404);
                    }
                    break;
            }
            return res;
        });
    };
    /**
     * Set notifications
     *
     * @remarks
     * <p>Set notifications for a given source account</p>
     * <p>deprecated since 2.34 (use v3 version)</p>
     *
     */
    SourceAccounts.prototype.setNotificationsRequest = function (req, config) {
        var _a;
        if (!(req instanceof utils.SpeakeasyBase)) {
            req = new operations.SetNotificationsRequestRequest(req);
        }
        var baseURL = this._serverURL;
        var url = utils.generateURL(baseURL, "/v1/sourceAccounts/{sourceAccountId}/notifications", req);
        var _b = [{}, {}], reqBodyHeaders = _b[0], reqBody = _b[1];
        try {
            _a = utils.serializeRequestBody(req, "setNotificationsRequest", "json"), reqBodyHeaders = _a[0], reqBody = _a[1];
        }
        catch (e) {
            if (e instanceof Error) {
                throw new Error("Error serializing request body, cause: ".concat(e.message));
            }
        }
        var client = this._securityClient || this._defaultClient;
        var headers = __assign(__assign({}, reqBodyHeaders), config === null || config === void 0 ? void 0 : config.headers);
        if (reqBody == null || Object.keys(reqBody).length === 0)
            throw new Error("request body is required");
        var r = client.request(__assign({ url: url, method: "post", headers: headers, data: reqBody }, config));
        return r.then(function (httpRes) {
            var _a, _b;
            var contentType = (_b = (_a = httpRes === null || httpRes === void 0 ? void 0 : httpRes.headers) === null || _a === void 0 ? void 0 : _a["content-type"]) !== null && _b !== void 0 ? _b : "";
            if ((httpRes === null || httpRes === void 0 ? void 0 : httpRes.status) == null)
                throw new Error("status code not found in response: ".concat(httpRes));
            var res = new operations.SetNotificationsRequestResponse({
                statusCode: httpRes.status,
                contentType: contentType,
                rawResponse: httpRes,
            });
            switch (true) {
                case (httpRes === null || httpRes === void 0 ? void 0 : httpRes.status) == 204:
                    break;
                case (httpRes === null || httpRes === void 0 ? void 0 : httpRes.status) == 400:
                    if (utils.matchContentType(contentType, "application/json")) {
                        res.inlineResponse400 = utils.objectToClass(httpRes === null || httpRes === void 0 ? void 0 : httpRes.data, shared.InlineResponse400);
                    }
                    break;
                case (httpRes === null || httpRes === void 0 ? void 0 : httpRes.status) == 401:
                    if (utils.matchContentType(contentType, "application/json")) {
                        res.inlineResponse401 = utils.objectToClass(httpRes === null || httpRes === void 0 ? void 0 : httpRes.data, shared.InlineResponse401);
                    }
                    break;
                case (httpRes === null || httpRes === void 0 ? void 0 : httpRes.status) == 403:
                    if (utils.matchContentType(contentType, "application/json")) {
                        res.inlineResponse403 = utils.objectToClass(httpRes === null || httpRes === void 0 ? void 0 : httpRes.data, shared.InlineResponse403);
                    }
                    break;
                case (httpRes === null || httpRes === void 0 ? void 0 : httpRes.status) == 404:
                    if (utils.matchContentType(contentType, "application/json")) {
                        res.inlineResponse404 = utils.objectToClass(httpRes === null || httpRes === void 0 ? void 0 : httpRes.data, shared.InlineResponse404);
                    }
                    break;
            }
            return res;
        });
    };
    /**
     * Set notifications
     *
     * @remarks
     * <p>Set notifications for a given source account</p>
     * <p>If the balance falls below the amount set in the request an email notification will be sent to the email address registered in the payor profile</p>
     *
     */
    SourceAccounts.prototype.setNotificationsRequestV3 = function (req, config) {
        var _a;
        if (!(req instanceof utils.SpeakeasyBase)) {
            req = new operations.SetNotificationsRequestV3Request(req);
        }
        var baseURL = this._serverURL;
        var url = utils.generateURL(baseURL, "/v3/sourceAccounts/{sourceAccountId}/notifications", req);
        var _b = [{}, {}], reqBodyHeaders = _b[0], reqBody = _b[1];
        try {
            _a = utils.serializeRequestBody(req, "setNotificationsRequest2", "json"), reqBodyHeaders = _a[0], reqBody = _a[1];
        }
        catch (e) {
            if (e instanceof Error) {
                throw new Error("Error serializing request body, cause: ".concat(e.message));
            }
        }
        var client = this._securityClient || this._defaultClient;
        var headers = __assign(__assign({}, reqBodyHeaders), config === null || config === void 0 ? void 0 : config.headers);
        if (reqBody == null || Object.keys(reqBody).length === 0)
            throw new Error("request body is required");
        var r = client.request(__assign({ url: url, method: "post", headers: headers, data: reqBody }, config));
        return r.then(function (httpRes) {
            var _a, _b;
            var contentType = (_b = (_a = httpRes === null || httpRes === void 0 ? void 0 : httpRes.headers) === null || _a === void 0 ? void 0 : _a["content-type"]) !== null && _b !== void 0 ? _b : "";
            if ((httpRes === null || httpRes === void 0 ? void 0 : httpRes.status) == null)
                throw new Error("status code not found in response: ".concat(httpRes));
            var res = new operations.SetNotificationsRequestV3Response({
                statusCode: httpRes.status,
                contentType: contentType,
                rawResponse: httpRes,
            });
            switch (true) {
                case (httpRes === null || httpRes === void 0 ? void 0 : httpRes.status) == 204:
                    break;
                case (httpRes === null || httpRes === void 0 ? void 0 : httpRes.status) == 400:
                    if (utils.matchContentType(contentType, "application/json")) {
                        res.inlineResponse400 = utils.objectToClass(httpRes === null || httpRes === void 0 ? void 0 : httpRes.data, shared.InlineResponse400);
                    }
                    break;
                case (httpRes === null || httpRes === void 0 ? void 0 : httpRes.status) == 401:
                    if (utils.matchContentType(contentType, "application/json")) {
                        res.inlineResponse401 = utils.objectToClass(httpRes === null || httpRes === void 0 ? void 0 : httpRes.data, shared.InlineResponse401);
                    }
                    break;
                case (httpRes === null || httpRes === void 0 ? void 0 : httpRes.status) == 403:
                    if (utils.matchContentType(contentType, "application/json")) {
                        res.inlineResponse403 = utils.objectToClass(httpRes === null || httpRes === void 0 ? void 0 : httpRes.data, shared.InlineResponse403);
                    }
                    break;
                case (httpRes === null || httpRes === void 0 ? void 0 : httpRes.status) == 404:
                    if (utils.matchContentType(contentType, "application/json")) {
                        res.inlineResponse404 = utils.objectToClass(httpRes === null || httpRes === void 0 ? void 0 : httpRes.data, shared.InlineResponse404);
                    }
                    break;
            }
            return res;
        });
    };
    /**
     * Transfer Funds between source accounts
     *
     * @remarks
     * Transfer funds between source accounts for a Payor. The 'from' source account is identified in the URL, and is the account which will be debited. The 'to' (destination) source account is in the body, and is the account which will be credited. Both source accounts must belong to the same Payor. There must be sufficient balance in the 'from' source account, otherwise the transfer attempt will fail.
     */
    SourceAccounts.prototype.transferFundsV2 = function (req, config) {
        var _a;
        if (!(req instanceof utils.SpeakeasyBase)) {
            req = new operations.TransferFundsV2Request(req);
        }
        var baseURL = this._serverURL;
        var url = utils.generateURL(baseURL, "/v2/sourceAccounts/{sourceAccountId}/transfers", req);
        var _b = [{}, {}], reqBodyHeaders = _b[0], reqBody = _b[1];
        try {
            _a = utils.serializeRequestBody(req, "transferRequestV2", "json"), reqBodyHeaders = _a[0], reqBody = _a[1];
        }
        catch (e) {
            if (e instanceof Error) {
                throw new Error("Error serializing request body, cause: ".concat(e.message));
            }
        }
        var client = this._securityClient || this._defaultClient;
        var headers = __assign(__assign({}, reqBodyHeaders), config === null || config === void 0 ? void 0 : config.headers);
        if (reqBody == null || Object.keys(reqBody).length === 0)
            throw new Error("request body is required");
        var r = client.request(__assign({ url: url, method: "post", headers: headers, data: reqBody }, config));
        return r.then(function (httpRes) {
            var _a, _b;
            var contentType = (_b = (_a = httpRes === null || httpRes === void 0 ? void 0 : httpRes.headers) === null || _a === void 0 ? void 0 : _a["content-type"]) !== null && _b !== void 0 ? _b : "";
            if ((httpRes === null || httpRes === void 0 ? void 0 : httpRes.status) == null)
                throw new Error("status code not found in response: ".concat(httpRes));
            var res = new operations.TransferFundsV2Response({
                statusCode: httpRes.status,
                contentType: contentType,
                rawResponse: httpRes,
            });
            switch (true) {
                case (httpRes === null || httpRes === void 0 ? void 0 : httpRes.status) == 204:
                    break;
                case (httpRes === null || httpRes === void 0 ? void 0 : httpRes.status) == 400:
                    if (utils.matchContentType(contentType, "application/json")) {
                        res.inlineResponse400 = utils.objectToClass(httpRes === null || httpRes === void 0 ? void 0 : httpRes.data, shared.InlineResponse400);
                    }
                    break;
                case (httpRes === null || httpRes === void 0 ? void 0 : httpRes.status) == 401:
                    if (utils.matchContentType(contentType, "application/json")) {
                        res.inlineResponse401 = utils.objectToClass(httpRes === null || httpRes === void 0 ? void 0 : httpRes.data, shared.InlineResponse401);
                    }
                    break;
                case (httpRes === null || httpRes === void 0 ? void 0 : httpRes.status) == 403:
                    if (utils.matchContentType(contentType, "application/json")) {
                        res.inlineResponse403 = utils.objectToClass(httpRes === null || httpRes === void 0 ? void 0 : httpRes.data, shared.InlineResponse403);
                    }
                    break;
                case (httpRes === null || httpRes === void 0 ? void 0 : httpRes.status) == 404:
                    if (utils.matchContentType(contentType, "application/json")) {
                        res.inlineResponse404 = utils.objectToClass(httpRes === null || httpRes === void 0 ? void 0 : httpRes.data, shared.InlineResponse404);
                    }
                    break;
            }
            return res;
        });
    };
    /**
     * Transfer Funds between source accounts
     *
     * @remarks
     * Transfer funds between source accounts for a Payor. The 'from' source account is identified in the URL, and is the account which will be debited. The 'to' (destination) source account is in the body, and is the account which will be credited. Both source accounts must belong to the same Payor. There must be sufficient balance in the 'from' source account, otherwise the transfer attempt will fail.
     */
    SourceAccounts.prototype.transferFundsV3 = function (req, config) {
        var _a;
        if (!(req instanceof utils.SpeakeasyBase)) {
            req = new operations.TransferFundsV3Request(req);
        }
        var baseURL = this._serverURL;
        var url = utils.generateURL(baseURL, "/v3/sourceAccounts/{sourceAccountId}/transfers", req);
        var _b = [{}, {}], reqBodyHeaders = _b[0], reqBody = _b[1];
        try {
            _a = utils.serializeRequestBody(req, "transferRequestV3", "json"), reqBodyHeaders = _a[0], reqBody = _a[1];
        }
        catch (e) {
            if (e instanceof Error) {
                throw new Error("Error serializing request body, cause: ".concat(e.message));
            }
        }
        var client = this._securityClient || this._defaultClient;
        var headers = __assign(__assign({}, reqBodyHeaders), config === null || config === void 0 ? void 0 : config.headers);
        if (reqBody == null || Object.keys(reqBody).length === 0)
            throw new Error("request body is required");
        var r = client.request(__assign({ url: url, method: "post", headers: headers, data: reqBody }, config));
        return r.then(function (httpRes) {
            var _a, _b;
            var contentType = (_b = (_a = httpRes === null || httpRes === void 0 ? void 0 : httpRes.headers) === null || _a === void 0 ? void 0 : _a["content-type"]) !== null && _b !== void 0 ? _b : "";
            if ((httpRes === null || httpRes === void 0 ? void 0 : httpRes.status) == null)
                throw new Error("status code not found in response: ".concat(httpRes));
            var res = new operations.TransferFundsV3Response({
                statusCode: httpRes.status,
                contentType: contentType,
                rawResponse: httpRes,
            });
            switch (true) {
                case (httpRes === null || httpRes === void 0 ? void 0 : httpRes.status) == 204:
                    break;
                case (httpRes === null || httpRes === void 0 ? void 0 : httpRes.status) == 400:
                    if (utils.matchContentType(contentType, "application/json")) {
                        res.inlineResponse400 = utils.objectToClass(httpRes === null || httpRes === void 0 ? void 0 : httpRes.data, shared.InlineResponse400);
                    }
                    break;
                case (httpRes === null || httpRes === void 0 ? void 0 : httpRes.status) == 401:
                    if (utils.matchContentType(contentType, "application/json")) {
                        res.inlineResponse401 = utils.objectToClass(httpRes === null || httpRes === void 0 ? void 0 : httpRes.data, shared.InlineResponse401);
                    }
                    break;
                case (httpRes === null || httpRes === void 0 ? void 0 : httpRes.status) == 403:
                    if (utils.matchContentType(contentType, "application/json")) {
                        res.inlineResponse403 = utils.objectToClass(httpRes === null || httpRes === void 0 ? void 0 : httpRes.data, shared.InlineResponse403);
                    }
                    break;
                case (httpRes === null || httpRes === void 0 ? void 0 : httpRes.status) == 404:
                    if (utils.matchContentType(contentType, "application/json")) {
                        res.inlineResponse404 = utils.objectToClass(httpRes === null || httpRes === void 0 ? void 0 : httpRes.data, shared.InlineResponse404);
                    }
                    break;
            }
            return res;
        });
    };
    return SourceAccounts;
}());
exports.SourceAccounts = SourceAccounts;
