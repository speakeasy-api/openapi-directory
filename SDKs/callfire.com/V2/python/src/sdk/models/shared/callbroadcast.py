"""Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT."""

from __future__ import annotations
import dataclasses
from ..shared import callbroadcastsounds as shared_callbroadcastsounds
from ..shared import localtimerestriction as shared_localtimerestriction
from ..shared import recipient as shared_recipient
from ..shared import retryconfig as shared_retryconfig
from ..shared import schedule as shared_schedule
from dataclasses_json import Undefined, dataclass_json
from enum import Enum
from sdk import utils
from typing import Optional

class CallBroadcastAnsweringMachineConfigEnum(str, Enum):
    r"""Specifies which action should be taken if answering machine was detected, default value: AM_AND_LIVE. Available values: AM_ONLY - run AMD (Answering Machine Detection), hang up if LA (Live Answer); AM_AND_LIVE - run AMD, play separate live vs. machine sound; LIVE_WITH_AMD, run AMD, hang up if machine answers; LIVE_IMMEDIATE - no AMD, play live sound immediately"""
    AM_ONLY = 'AM_ONLY'
    AM_AND_LIVE = 'AM_AND_LIVE'
    LIVE_WITH_AMD = 'LIVE_WITH_AMD'
    LIVE_IMMEDIATE = 'LIVE_IMMEDIATE'


@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class CallBroadcastInput:
    r"""Call broadcast can be used to send out a voice message to a group of numbers. It supports IVR scripting, scheduling, retry logic, playing pre-recorded sounds, answering machine detection"""
    
    answering_machine_config: Optional[CallBroadcastAnsweringMachineConfigEnum] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('answeringMachineConfig'), 'exclude': lambda f: f is None }})
    r"""Specifies which action should be taken if answering machine was detected, default value: AM_AND_LIVE. Available values: AM_ONLY - run AMD (Answering Machine Detection), hang up if LA (Live Answer); AM_AND_LIVE - run AMD, play separate live vs. machine sound; LIVE_WITH_AMD, run AMD, hang up if machine answers; LIVE_IMMEDIATE - no AMD, play live sound immediately"""  
    dialplan_xml: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('dialplanXml'), 'exclude': lambda f: f is None }})
    r"""IVR xml is a document which describes the dialplan to setup the IVR broadcast"""  
    from_number: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('fromNumber'), 'exclude': lambda f: f is None }})
    r"""Phone number in E.164 format (11-digit) or short code for text. Example: 12132000384, 67076"""  
    id: Optional[int] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('id'), 'exclude': lambda f: f is None }})
    r"""A unique id of broadcast (readonly)"""  
    labels: Optional[list[str]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('labels'), 'exclude': lambda f: f is None }})
    r"""Labels of a broadcast"""  
    local_time_restriction: Optional[shared_localtimerestriction.LocalTimeRestriction] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('localTimeRestriction'), 'exclude': lambda f: f is None }})
    r"""Represents a range of time during which CallFire will send a call or text to recipients. Timeframe uses the local timezone of recipient's number"""  
    max_active: Optional[int] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('maxActive'), 'exclude': lambda f: f is None }})
    r"""Sets a maximum number of calls to be dialed by CallFire at once"""  
    max_active_transfers: Optional[int] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('maxActiveTransfers'), 'exclude': lambda f: f is None }})
    r"""A maximum number of active transfers"""  
    name: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('name'), 'exclude': lambda f: f is None }})
    r"""A name of a broadcast"""  
    recipients: Optional[list[shared_recipient.Recipient]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('recipients'), 'exclude': lambda f: f is None }})
    r"""Recipients of a call broadcast, can be either existing contacts or a new ones"""  
    resume_next_day: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('resumeNextDay'), 'exclude': lambda f: f is None }})
    r"""If true resumes the unfinished campaign to the next day"""  
    retry_config: Optional[shared_retryconfig.RetryConfig] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('retryConfig'), 'exclude': lambda f: f is None }})
    r"""Retry configuration will help you to resend a call or text if it was not delivered first time"""  
    schedules: Optional[list[shared_schedule.Schedule]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('schedules'), 'exclude': lambda f: f is None }})
    r"""A list of schedule objects which specifies a range of time when broadcast should be started and stopped. Supports the scheduling per day of week"""  
    sounds: Optional[shared_callbroadcastsounds.CallBroadcastSounds] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('sounds'), 'exclude': lambda f: f is None }})
    r"""A set of sounds assigned to a voice broadcast to play according to an answering machine configuration. You can add the existing sounds from the account's sound library or to provide a text which will be converted into a speech. There are four sound options available for a Voice Broadcast campaign"""  
    
class CallBroadcastStatusEnum(str, Enum):
    r"""A status of a broadcast (read only). SETUP - campaign isn't configured yet; START_PENDING - waiting for contact batch population; RUNNING - campaign is running; STOPPED - campaign is stopped; FINISHED - campaign is finished; ARCHIVED - campaign was archived"""
    TEST = 'TEST'
    SETUP = 'SETUP'
    START_PENDING = 'START_PENDING'
    RUNNING = 'RUNNING'
    SCHEDULED = 'SCHEDULED'
    STOPPED = 'STOPPED'
    SUSPENDED = 'SUSPENDED'
    FINISHED = 'FINISHED'
    ARCHIVED = 'ARCHIVED'
    VALIDATING_START = 'VALIDATING_START'
    VALIDATING_EMAIL = 'VALIDATING_EMAIL'
    BLOCKED_SUSPICIOUS = 'BLOCKED_SUSPICIOUS'
    DECLINED = 'DECLINED'
    APPROVED = 'APPROVED'


@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class CallBroadcast:
    r"""Call broadcast can be used to send out a voice message to a group of numbers. It supports IVR scripting, scheduling, retry logic, playing pre-recorded sounds, answering machine detection"""
    
    answering_machine_config: Optional[CallBroadcastAnsweringMachineConfigEnum] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('answeringMachineConfig'), 'exclude': lambda f: f is None }})
    r"""Specifies which action should be taken if answering machine was detected, default value: AM_AND_LIVE. Available values: AM_ONLY - run AMD (Answering Machine Detection), hang up if LA (Live Answer); AM_AND_LIVE - run AMD, play separate live vs. machine sound; LIVE_WITH_AMD, run AMD, hang up if machine answers; LIVE_IMMEDIATE - no AMD, play live sound immediately"""  
    dialplan_xml: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('dialplanXml'), 'exclude': lambda f: f is None }})
    r"""IVR xml is a document which describes the dialplan to setup the IVR broadcast"""  
    from_number: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('fromNumber'), 'exclude': lambda f: f is None }})
    r"""Phone number in E.164 format (11-digit) or short code for text. Example: 12132000384, 67076"""  
    id: Optional[int] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('id'), 'exclude': lambda f: f is None }})
    r"""A unique id of broadcast (readonly)"""  
    labels: Optional[list[str]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('labels'), 'exclude': lambda f: f is None }})
    r"""Labels of a broadcast"""  
    last_modified: Optional[int] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('lastModified'), 'exclude': lambda f: f is None }})
    r"""The time when a given resource was updated, formatted in unix time milliseconds (read only). Example: 1473781817000 for Sat, 05 Jan 1985 14:03:37 GMT"""  
    local_time_restriction: Optional[shared_localtimerestriction.LocalTimeRestriction] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('localTimeRestriction'), 'exclude': lambda f: f is None }})
    r"""Represents a range of time during which CallFire will send a call or text to recipients. Timeframe uses the local timezone of recipient's number"""  
    max_active: Optional[int] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('maxActive'), 'exclude': lambda f: f is None }})
    r"""Sets a maximum number of calls to be dialed by CallFire at once"""  
    max_active_transfers: Optional[int] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('maxActiveTransfers'), 'exclude': lambda f: f is None }})
    r"""A maximum number of active transfers"""  
    name: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('name'), 'exclude': lambda f: f is None }})
    r"""A name of a broadcast"""  
    recipients: Optional[list[shared_recipient.Recipient]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('recipients'), 'exclude': lambda f: f is None }})
    r"""Recipients of a call broadcast, can be either existing contacts or a new ones"""  
    resume_next_day: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('resumeNextDay'), 'exclude': lambda f: f is None }})
    r"""If true resumes the unfinished campaign to the next day"""  
    retry_config: Optional[shared_retryconfig.RetryConfig] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('retryConfig'), 'exclude': lambda f: f is None }})
    r"""Retry configuration will help you to resend a call or text if it was not delivered first time"""  
    schedules: Optional[list[shared_schedule.Schedule]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('schedules'), 'exclude': lambda f: f is None }})
    r"""A list of schedule objects which specifies a range of time when broadcast should be started and stopped. Supports the scheduling per day of week"""  
    sounds: Optional[shared_callbroadcastsounds.CallBroadcastSounds] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('sounds'), 'exclude': lambda f: f is None }})
    r"""A set of sounds assigned to a voice broadcast to play according to an answering machine configuration. You can add the existing sounds from the account's sound library or to provide a text which will be converted into a speech. There are four sound options available for a Voice Broadcast campaign"""  
    status: Optional[CallBroadcastStatusEnum] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('status'), 'exclude': lambda f: f is None }})
    r"""A status of a broadcast (read only). SETUP - campaign isn't configured yet; START_PENDING - waiting for contact batch population; RUNNING - campaign is running; STOPPED - campaign is stopped; FINISHED - campaign is finished; ARCHIVED - campaign was archived"""  
    