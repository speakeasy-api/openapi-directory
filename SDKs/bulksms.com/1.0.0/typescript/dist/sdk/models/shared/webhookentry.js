"use strict";
/*
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.WebhookEntry = exports.WebhookEntryTriggerScopeEnum = exports.WebhookEntryInvokeOptionEnum = void 0;
var utils_1 = require("../../../internal/utils");
var class_transformer_1 = require("class-transformer");
/**
 * Specifies how to invoke your webhook.
 *
 * @remarks
 *
 * If the value is `ONE` the array POSTed to your webhook will contain no more than a single message.  Use this option if your webhook logic is unable to handle more than one messages at a time.
 *
 * If the value is `MANY` the array POSTed to your webhook can contain up to 10 messages.  This is the recommended option.  The number of calls made to your webhook would be less and this will speed up your total processing time.
 * If your webhook fails for an invoke that has more than one message, each message in the array will automatically be retried one at a time.
 *
 * This value defaults to `ONE` - but it is recommended that you set this property to `MANY`.
 *
 */
var WebhookEntryInvokeOptionEnum;
(function (WebhookEntryInvokeOptionEnum) {
    WebhookEntryInvokeOptionEnum["One"] = "ONE";
    WebhookEntryInvokeOptionEnum["Many"] = "MANY";
})(WebhookEntryInvokeOptionEnum = exports.WebhookEntryInvokeOptionEnum || (exports.WebhookEntryInvokeOptionEnum = {}));
/**
 * Specifies when the webhook will be triggered.
 *
 * @remarks
 *
 * Please note the values are case sensitive.
 *
 * If the value is `SENT`, the webhook will be called when a status update becomes available for a message you sent (i.e. a mobile terminating (MT) message).
 *
 * If the value is `RECEIVED`, the webhook will be called when a message is received (i.e. a mobile originating (MO) message).
 *
 * Note that this field forces you to create two separate webhook entries if you want to collect all messages.  However,  you can use the same `url` for both webhooks if you want.
 *
 */
var WebhookEntryTriggerScopeEnum;
(function (WebhookEntryTriggerScopeEnum) {
    WebhookEntryTriggerScopeEnum["Sent"] = "SENT";
    WebhookEntryTriggerScopeEnum["Received"] = "RECEIVED";
})(WebhookEntryTriggerScopeEnum = exports.WebhookEntryTriggerScopeEnum || (exports.WebhookEntryTriggerScopeEnum = {}));
/**
 * Contains the property values for your new webhook
 *
 * @remarks
 *
 */
var WebhookEntry = /** @class */ (function (_super) {
    __extends(WebhookEntry, _super);
    function WebhookEntry() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate([
        (0, utils_1.SpeakeasyMetadata)(),
        (0, class_transformer_1.Expose)({ name: "active" }),
        __metadata("design:type", Boolean)
    ], WebhookEntry.prototype, "active", void 0);
    __decorate([
        (0, utils_1.SpeakeasyMetadata)(),
        (0, class_transformer_1.Expose)({ name: "contactEmailAddress" }),
        __metadata("design:type", String)
    ], WebhookEntry.prototype, "contactEmailAddress", void 0);
    __decorate([
        (0, utils_1.SpeakeasyMetadata)(),
        (0, class_transformer_1.Expose)({ name: "invokeOption" }),
        __metadata("design:type", String)
    ], WebhookEntry.prototype, "invokeOption", void 0);
    __decorate([
        (0, utils_1.SpeakeasyMetadata)(),
        (0, class_transformer_1.Expose)({ name: "name" }),
        __metadata("design:type", String)
    ], WebhookEntry.prototype, "name", void 0);
    __decorate([
        (0, utils_1.SpeakeasyMetadata)(),
        (0, class_transformer_1.Expose)({ name: "onWebApp" }),
        __metadata("design:type", Boolean)
    ], WebhookEntry.prototype, "onWebApp", void 0);
    __decorate([
        (0, utils_1.SpeakeasyMetadata)(),
        (0, class_transformer_1.Expose)({ name: "triggerScope" }),
        __metadata("design:type", String)
    ], WebhookEntry.prototype, "triggerScope", void 0);
    __decorate([
        (0, utils_1.SpeakeasyMetadata)(),
        (0, class_transformer_1.Expose)({ name: "url" }),
        __metadata("design:type", String)
    ], WebhookEntry.prototype, "url", void 0);
    return WebhookEntry;
}(utils_1.SpeakeasyBase));
exports.WebhookEntry = WebhookEntry;
