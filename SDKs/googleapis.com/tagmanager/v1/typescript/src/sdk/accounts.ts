/*
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

import * as utils from "../internal/utils";
import * as operations from "./models/operations";
import * as shared from "./models/shared";
import { AxiosInstance, AxiosRequestConfig, AxiosResponse } from "axios";

export class Accounts {
  _defaultClient: AxiosInstance;
  _securityClient: AxiosInstance;
  _serverURL: string;
  _language: string;
  _sdkVersion: string;
  _genVersion: string;

  constructor(
    defaultClient: AxiosInstance,
    securityClient: AxiosInstance,
    serverURL: string,
    language: string,
    sdkVersion: string,
    genVersion: string
  ) {
    this._defaultClient = defaultClient;
    this._securityClient = securityClient;
    this._serverURL = serverURL;
    this._language = language;
    this._sdkVersion = sdkVersion;
    this._genVersion = genVersion;
  }

  /**
   * Creates a Container.
   */
  tagmanagerAccountsContainersCreate(
    req: operations.TagmanagerAccountsContainersCreateRequest,
    security: operations.TagmanagerAccountsContainersCreateSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.TagmanagerAccountsContainersCreateResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.TagmanagerAccountsContainersCreateRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/tagmanager/v1/accounts/{accountId}/containers",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "container",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.TagmanagerAccountsContainersCreateSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.TagmanagerAccountsContainersCreateResponse =
        new operations.TagmanagerAccountsContainersCreateResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.container = utils.objectToClass(
              httpRes?.data,
              shared.Container
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Deletes a Container.
   */
  tagmanagerAccountsContainersDelete(
    req: operations.TagmanagerAccountsContainersDeleteRequest,
    security: operations.TagmanagerAccountsContainersDeleteSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.TagmanagerAccountsContainersDeleteResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.TagmanagerAccountsContainersDeleteRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/tagmanager/v1/accounts/{accountId}/containers/{containerId}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.TagmanagerAccountsContainersDeleteSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.TagmanagerAccountsContainersDeleteResponse =
        new operations.TagmanagerAccountsContainersDeleteResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          break;
      }

      return res;
    });
  }

  /**
   * Creates a GTM Environment.
   */
  tagmanagerAccountsContainersEnvironmentsCreate(
    req: operations.TagmanagerAccountsContainersEnvironmentsCreateRequest,
    security: operations.TagmanagerAccountsContainersEnvironmentsCreateSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.TagmanagerAccountsContainersEnvironmentsCreateResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.TagmanagerAccountsContainersEnvironmentsCreateRequest(
          req
        );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/tagmanager/v1/accounts/{accountId}/containers/{containerId}/environments",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "environment",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.TagmanagerAccountsContainersEnvironmentsCreateSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.TagmanagerAccountsContainersEnvironmentsCreateResponse =
        new operations.TagmanagerAccountsContainersEnvironmentsCreateResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.environment = utils.objectToClass(
              httpRes?.data,
              shared.Environment
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Deletes a GTM Environment.
   */
  tagmanagerAccountsContainersEnvironmentsDelete(
    req: operations.TagmanagerAccountsContainersEnvironmentsDeleteRequest,
    security: operations.TagmanagerAccountsContainersEnvironmentsDeleteSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.TagmanagerAccountsContainersEnvironmentsDeleteResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.TagmanagerAccountsContainersEnvironmentsDeleteRequest(
          req
        );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/tagmanager/v1/accounts/{accountId}/containers/{containerId}/environments/{environmentId}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.TagmanagerAccountsContainersEnvironmentsDeleteSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.TagmanagerAccountsContainersEnvironmentsDeleteResponse =
        new operations.TagmanagerAccountsContainersEnvironmentsDeleteResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          break;
      }

      return res;
    });
  }

  /**
   * Gets a GTM Environment.
   */
  tagmanagerAccountsContainersEnvironmentsGet(
    req: operations.TagmanagerAccountsContainersEnvironmentsGetRequest,
    security: operations.TagmanagerAccountsContainersEnvironmentsGetSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.TagmanagerAccountsContainersEnvironmentsGetResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.TagmanagerAccountsContainersEnvironmentsGetRequest(
        req
      );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/tagmanager/v1/accounts/{accountId}/containers/{containerId}/environments/{environmentId}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.TagmanagerAccountsContainersEnvironmentsGetSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.TagmanagerAccountsContainersEnvironmentsGetResponse =
        new operations.TagmanagerAccountsContainersEnvironmentsGetResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.environment = utils.objectToClass(
              httpRes?.data,
              shared.Environment
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Lists all GTM Environments of a GTM Container.
   */
  tagmanagerAccountsContainersEnvironmentsList(
    req: operations.TagmanagerAccountsContainersEnvironmentsListRequest,
    security: operations.TagmanagerAccountsContainersEnvironmentsListSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.TagmanagerAccountsContainersEnvironmentsListResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.TagmanagerAccountsContainersEnvironmentsListRequest(
        req
      );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/tagmanager/v1/accounts/{accountId}/containers/{containerId}/environments",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.TagmanagerAccountsContainersEnvironmentsListSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.TagmanagerAccountsContainersEnvironmentsListResponse =
        new operations.TagmanagerAccountsContainersEnvironmentsListResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listEnvironmentsResponse = utils.objectToClass(
              httpRes?.data,
              shared.ListEnvironmentsResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Updates a GTM Environment.
   */
  tagmanagerAccountsContainersEnvironmentsUpdate(
    req: operations.TagmanagerAccountsContainersEnvironmentsUpdateRequest,
    security: operations.TagmanagerAccountsContainersEnvironmentsUpdateSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.TagmanagerAccountsContainersEnvironmentsUpdateResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.TagmanagerAccountsContainersEnvironmentsUpdateRequest(
          req
        );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/tagmanager/v1/accounts/{accountId}/containers/{containerId}/environments/{environmentId}",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "environment",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.TagmanagerAccountsContainersEnvironmentsUpdateSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "put",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.TagmanagerAccountsContainersEnvironmentsUpdateResponse =
        new operations.TagmanagerAccountsContainersEnvironmentsUpdateResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.environment = utils.objectToClass(
              httpRes?.data,
              shared.Environment
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Creates a GTM Folder.
   */
  tagmanagerAccountsContainersFoldersCreate(
    req: operations.TagmanagerAccountsContainersFoldersCreateRequest,
    security: operations.TagmanagerAccountsContainersFoldersCreateSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.TagmanagerAccountsContainersFoldersCreateResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.TagmanagerAccountsContainersFoldersCreateRequest(
        req
      );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/tagmanager/v1/accounts/{accountId}/containers/{containerId}/folders",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "folder",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.TagmanagerAccountsContainersFoldersCreateSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.TagmanagerAccountsContainersFoldersCreateResponse =
        new operations.TagmanagerAccountsContainersFoldersCreateResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.folder = utils.objectToClass(httpRes?.data, shared.Folder);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Deletes a GTM Folder.
   */
  tagmanagerAccountsContainersFoldersDelete(
    req: operations.TagmanagerAccountsContainersFoldersDeleteRequest,
    security: operations.TagmanagerAccountsContainersFoldersDeleteSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.TagmanagerAccountsContainersFoldersDeleteResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.TagmanagerAccountsContainersFoldersDeleteRequest(
        req
      );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/tagmanager/v1/accounts/{accountId}/containers/{containerId}/folders/{folderId}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.TagmanagerAccountsContainersFoldersDeleteSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.TagmanagerAccountsContainersFoldersDeleteResponse =
        new operations.TagmanagerAccountsContainersFoldersDeleteResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          break;
      }

      return res;
    });
  }

  /**
   * List all entities in a GTM Folder.
   */
  tagmanagerAccountsContainersFoldersEntitiesList(
    req: operations.TagmanagerAccountsContainersFoldersEntitiesListRequest,
    security: operations.TagmanagerAccountsContainersFoldersEntitiesListSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.TagmanagerAccountsContainersFoldersEntitiesListResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.TagmanagerAccountsContainersFoldersEntitiesListRequest(
          req
        );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/tagmanager/v1/accounts/{accountId}/containers/{containerId}/folders/{folderId}/entities",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.TagmanagerAccountsContainersFoldersEntitiesListSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.TagmanagerAccountsContainersFoldersEntitiesListResponse =
        new operations.TagmanagerAccountsContainersFoldersEntitiesListResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.folderEntities = utils.objectToClass(
              httpRes?.data,
              shared.FolderEntities
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Gets a GTM Folder.
   */
  tagmanagerAccountsContainersFoldersGet(
    req: operations.TagmanagerAccountsContainersFoldersGetRequest,
    security: operations.TagmanagerAccountsContainersFoldersGetSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.TagmanagerAccountsContainersFoldersGetResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.TagmanagerAccountsContainersFoldersGetRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/tagmanager/v1/accounts/{accountId}/containers/{containerId}/folders/{folderId}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.TagmanagerAccountsContainersFoldersGetSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.TagmanagerAccountsContainersFoldersGetResponse =
        new operations.TagmanagerAccountsContainersFoldersGetResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.folder = utils.objectToClass(httpRes?.data, shared.Folder);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Lists all GTM Folders of a Container.
   */
  tagmanagerAccountsContainersFoldersList(
    req: operations.TagmanagerAccountsContainersFoldersListRequest,
    security: operations.TagmanagerAccountsContainersFoldersListSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.TagmanagerAccountsContainersFoldersListResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.TagmanagerAccountsContainersFoldersListRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/tagmanager/v1/accounts/{accountId}/containers/{containerId}/folders",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.TagmanagerAccountsContainersFoldersListSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.TagmanagerAccountsContainersFoldersListResponse =
        new operations.TagmanagerAccountsContainersFoldersListResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listFoldersResponse = utils.objectToClass(
              httpRes?.data,
              shared.ListFoldersResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Updates a GTM Folder.
   */
  tagmanagerAccountsContainersFoldersUpdate(
    req: operations.TagmanagerAccountsContainersFoldersUpdateRequest,
    security: operations.TagmanagerAccountsContainersFoldersUpdateSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.TagmanagerAccountsContainersFoldersUpdateResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.TagmanagerAccountsContainersFoldersUpdateRequest(
        req
      );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/tagmanager/v1/accounts/{accountId}/containers/{containerId}/folders/{folderId}",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "folder",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.TagmanagerAccountsContainersFoldersUpdateSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "put",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.TagmanagerAccountsContainersFoldersUpdateResponse =
        new operations.TagmanagerAccountsContainersFoldersUpdateResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.folder = utils.objectToClass(httpRes?.data, shared.Folder);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Gets a Container.
   */
  tagmanagerAccountsContainersGet(
    req: operations.TagmanagerAccountsContainersGetRequest,
    security: operations.TagmanagerAccountsContainersGetSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.TagmanagerAccountsContainersGetResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.TagmanagerAccountsContainersGetRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/tagmanager/v1/accounts/{accountId}/containers/{containerId}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.TagmanagerAccountsContainersGetSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.TagmanagerAccountsContainersGetResponse =
        new operations.TagmanagerAccountsContainersGetResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.container = utils.objectToClass(
              httpRes?.data,
              shared.Container
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Lists all Containers that belongs to a GTM Account.
   */
  tagmanagerAccountsContainersList(
    req: operations.TagmanagerAccountsContainersListRequest,
    security: operations.TagmanagerAccountsContainersListSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.TagmanagerAccountsContainersListResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.TagmanagerAccountsContainersListRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/tagmanager/v1/accounts/{accountId}/containers",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.TagmanagerAccountsContainersListSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.TagmanagerAccountsContainersListResponse =
        new operations.TagmanagerAccountsContainersListResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listContainersResponse = utils.objectToClass(
              httpRes?.data,
              shared.ListContainersResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Moves entities to a GTM Folder.
   */
  tagmanagerAccountsContainersMoveFoldersUpdate(
    req: operations.TagmanagerAccountsContainersMoveFoldersUpdateRequest,
    security: operations.TagmanagerAccountsContainersMoveFoldersUpdateSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.TagmanagerAccountsContainersMoveFoldersUpdateResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.TagmanagerAccountsContainersMoveFoldersUpdateRequest(
        req
      );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/tagmanager/v1/accounts/{accountId}/containers/{containerId}/move_folders/{folderId}",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "folder",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.TagmanagerAccountsContainersMoveFoldersUpdateSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "put",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.TagmanagerAccountsContainersMoveFoldersUpdateResponse =
        new operations.TagmanagerAccountsContainersMoveFoldersUpdateResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          break;
      }

      return res;
    });
  }

  /**
   * Re-generates the authorization code for a GTM Environment.
   */
  tagmanagerAccountsContainersReauthorizeEnvironmentsUpdate(
    req: operations.TagmanagerAccountsContainersReauthorizeEnvironmentsUpdateRequest,
    security: operations.TagmanagerAccountsContainersReauthorizeEnvironmentsUpdateSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.TagmanagerAccountsContainersReauthorizeEnvironmentsUpdateResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.TagmanagerAccountsContainersReauthorizeEnvironmentsUpdateRequest(
          req
        );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/tagmanager/v1/accounts/{accountId}/containers/{containerId}/reauthorize_environments/{environmentId}",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "environment",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.TagmanagerAccountsContainersReauthorizeEnvironmentsUpdateSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "put",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.TagmanagerAccountsContainersReauthorizeEnvironmentsUpdateResponse =
        new operations.TagmanagerAccountsContainersReauthorizeEnvironmentsUpdateResponse(
          {
            statusCode: httpRes.status,
            contentType: contentType,
            rawResponse: httpRes,
          }
        );
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.environment = utils.objectToClass(
              httpRes?.data,
              shared.Environment
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Creates a GTM Tag.
   */
  tagmanagerAccountsContainersTagsCreate(
    req: operations.TagmanagerAccountsContainersTagsCreateRequest,
    security: operations.TagmanagerAccountsContainersTagsCreateSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.TagmanagerAccountsContainersTagsCreateResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.TagmanagerAccountsContainersTagsCreateRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/tagmanager/v1/accounts/{accountId}/containers/{containerId}/tags",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "tag",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.TagmanagerAccountsContainersTagsCreateSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.TagmanagerAccountsContainersTagsCreateResponse =
        new operations.TagmanagerAccountsContainersTagsCreateResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.tag = utils.objectToClass(httpRes?.data, shared.Tag);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Deletes a GTM Tag.
   */
  tagmanagerAccountsContainersTagsDelete(
    req: operations.TagmanagerAccountsContainersTagsDeleteRequest,
    security: operations.TagmanagerAccountsContainersTagsDeleteSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.TagmanagerAccountsContainersTagsDeleteResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.TagmanagerAccountsContainersTagsDeleteRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/tagmanager/v1/accounts/{accountId}/containers/{containerId}/tags/{tagId}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.TagmanagerAccountsContainersTagsDeleteSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.TagmanagerAccountsContainersTagsDeleteResponse =
        new operations.TagmanagerAccountsContainersTagsDeleteResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          break;
      }

      return res;
    });
  }

  /**
   * Gets a GTM Tag.
   */
  tagmanagerAccountsContainersTagsGet(
    req: operations.TagmanagerAccountsContainersTagsGetRequest,
    security: operations.TagmanagerAccountsContainersTagsGetSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.TagmanagerAccountsContainersTagsGetResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.TagmanagerAccountsContainersTagsGetRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/tagmanager/v1/accounts/{accountId}/containers/{containerId}/tags/{tagId}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.TagmanagerAccountsContainersTagsGetSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.TagmanagerAccountsContainersTagsGetResponse =
        new operations.TagmanagerAccountsContainersTagsGetResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.tag = utils.objectToClass(httpRes?.data, shared.Tag);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Lists all GTM Tags of a Container.
   */
  tagmanagerAccountsContainersTagsList(
    req: operations.TagmanagerAccountsContainersTagsListRequest,
    security: operations.TagmanagerAccountsContainersTagsListSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.TagmanagerAccountsContainersTagsListResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.TagmanagerAccountsContainersTagsListRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/tagmanager/v1/accounts/{accountId}/containers/{containerId}/tags",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.TagmanagerAccountsContainersTagsListSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.TagmanagerAccountsContainersTagsListResponse =
        new operations.TagmanagerAccountsContainersTagsListResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listTagsResponse = utils.objectToClass(
              httpRes?.data,
              shared.ListTagsResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Updates a GTM Tag.
   */
  tagmanagerAccountsContainersTagsUpdate(
    req: operations.TagmanagerAccountsContainersTagsUpdateRequest,
    security: operations.TagmanagerAccountsContainersTagsUpdateSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.TagmanagerAccountsContainersTagsUpdateResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.TagmanagerAccountsContainersTagsUpdateRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/tagmanager/v1/accounts/{accountId}/containers/{containerId}/tags/{tagId}",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "tag",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.TagmanagerAccountsContainersTagsUpdateSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "put",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.TagmanagerAccountsContainersTagsUpdateResponse =
        new operations.TagmanagerAccountsContainersTagsUpdateResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.tag = utils.objectToClass(httpRes?.data, shared.Tag);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Creates a GTM Trigger.
   */
  tagmanagerAccountsContainersTriggersCreate(
    req: operations.TagmanagerAccountsContainersTriggersCreateRequest,
    security: operations.TagmanagerAccountsContainersTriggersCreateSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.TagmanagerAccountsContainersTriggersCreateResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.TagmanagerAccountsContainersTriggersCreateRequest(
        req
      );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/tagmanager/v1/accounts/{accountId}/containers/{containerId}/triggers",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "trigger",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.TagmanagerAccountsContainersTriggersCreateSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.TagmanagerAccountsContainersTriggersCreateResponse =
        new operations.TagmanagerAccountsContainersTriggersCreateResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.trigger = utils.objectToClass(httpRes?.data, shared.Trigger);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Deletes a GTM Trigger.
   */
  tagmanagerAccountsContainersTriggersDelete(
    req: operations.TagmanagerAccountsContainersTriggersDeleteRequest,
    security: operations.TagmanagerAccountsContainersTriggersDeleteSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.TagmanagerAccountsContainersTriggersDeleteResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.TagmanagerAccountsContainersTriggersDeleteRequest(
        req
      );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/tagmanager/v1/accounts/{accountId}/containers/{containerId}/triggers/{triggerId}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.TagmanagerAccountsContainersTriggersDeleteSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.TagmanagerAccountsContainersTriggersDeleteResponse =
        new operations.TagmanagerAccountsContainersTriggersDeleteResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          break;
      }

      return res;
    });
  }

  /**
   * Gets a GTM Trigger.
   */
  tagmanagerAccountsContainersTriggersGet(
    req: operations.TagmanagerAccountsContainersTriggersGetRequest,
    security: operations.TagmanagerAccountsContainersTriggersGetSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.TagmanagerAccountsContainersTriggersGetResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.TagmanagerAccountsContainersTriggersGetRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/tagmanager/v1/accounts/{accountId}/containers/{containerId}/triggers/{triggerId}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.TagmanagerAccountsContainersTriggersGetSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.TagmanagerAccountsContainersTriggersGetResponse =
        new operations.TagmanagerAccountsContainersTriggersGetResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.trigger = utils.objectToClass(httpRes?.data, shared.Trigger);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Lists all GTM Triggers of a Container.
   */
  tagmanagerAccountsContainersTriggersList(
    req: operations.TagmanagerAccountsContainersTriggersListRequest,
    security: operations.TagmanagerAccountsContainersTriggersListSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.TagmanagerAccountsContainersTriggersListResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.TagmanagerAccountsContainersTriggersListRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/tagmanager/v1/accounts/{accountId}/containers/{containerId}/triggers",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.TagmanagerAccountsContainersTriggersListSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.TagmanagerAccountsContainersTriggersListResponse =
        new operations.TagmanagerAccountsContainersTriggersListResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listTriggersResponse = utils.objectToClass(
              httpRes?.data,
              shared.ListTriggersResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Updates a GTM Trigger.
   */
  tagmanagerAccountsContainersTriggersUpdate(
    req: operations.TagmanagerAccountsContainersTriggersUpdateRequest,
    security: operations.TagmanagerAccountsContainersTriggersUpdateSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.TagmanagerAccountsContainersTriggersUpdateResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.TagmanagerAccountsContainersTriggersUpdateRequest(
        req
      );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/tagmanager/v1/accounts/{accountId}/containers/{containerId}/triggers/{triggerId}",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "trigger",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.TagmanagerAccountsContainersTriggersUpdateSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "put",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.TagmanagerAccountsContainersTriggersUpdateResponse =
        new operations.TagmanagerAccountsContainersTriggersUpdateResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.trigger = utils.objectToClass(httpRes?.data, shared.Trigger);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Updates a Container.
   */
  tagmanagerAccountsContainersUpdate(
    req: operations.TagmanagerAccountsContainersUpdateRequest,
    security: operations.TagmanagerAccountsContainersUpdateSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.TagmanagerAccountsContainersUpdateResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.TagmanagerAccountsContainersUpdateRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/tagmanager/v1/accounts/{accountId}/containers/{containerId}",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "container",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.TagmanagerAccountsContainersUpdateSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "put",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.TagmanagerAccountsContainersUpdateResponse =
        new operations.TagmanagerAccountsContainersUpdateResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.container = utils.objectToClass(
              httpRes?.data,
              shared.Container
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Creates a GTM Variable.
   */
  tagmanagerAccountsContainersVariablesCreate(
    req: operations.TagmanagerAccountsContainersVariablesCreateRequest,
    security: operations.TagmanagerAccountsContainersVariablesCreateSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.TagmanagerAccountsContainersVariablesCreateResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.TagmanagerAccountsContainersVariablesCreateRequest(
        req
      );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/tagmanager/v1/accounts/{accountId}/containers/{containerId}/variables",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "variable",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.TagmanagerAccountsContainersVariablesCreateSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.TagmanagerAccountsContainersVariablesCreateResponse =
        new operations.TagmanagerAccountsContainersVariablesCreateResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.variable = utils.objectToClass(httpRes?.data, shared.Variable);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Deletes a GTM Variable.
   */
  tagmanagerAccountsContainersVariablesDelete(
    req: operations.TagmanagerAccountsContainersVariablesDeleteRequest,
    security: operations.TagmanagerAccountsContainersVariablesDeleteSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.TagmanagerAccountsContainersVariablesDeleteResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.TagmanagerAccountsContainersVariablesDeleteRequest(
        req
      );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/tagmanager/v1/accounts/{accountId}/containers/{containerId}/variables/{variableId}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.TagmanagerAccountsContainersVariablesDeleteSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.TagmanagerAccountsContainersVariablesDeleteResponse =
        new operations.TagmanagerAccountsContainersVariablesDeleteResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          break;
      }

      return res;
    });
  }

  /**
   * Gets a GTM Variable.
   */
  tagmanagerAccountsContainersVariablesGet(
    req: operations.TagmanagerAccountsContainersVariablesGetRequest,
    security: operations.TagmanagerAccountsContainersVariablesGetSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.TagmanagerAccountsContainersVariablesGetResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.TagmanagerAccountsContainersVariablesGetRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/tagmanager/v1/accounts/{accountId}/containers/{containerId}/variables/{variableId}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.TagmanagerAccountsContainersVariablesGetSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.TagmanagerAccountsContainersVariablesGetResponse =
        new operations.TagmanagerAccountsContainersVariablesGetResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.variable = utils.objectToClass(httpRes?.data, shared.Variable);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Lists all GTM Variables of a Container.
   */
  tagmanagerAccountsContainersVariablesList(
    req: operations.TagmanagerAccountsContainersVariablesListRequest,
    security: operations.TagmanagerAccountsContainersVariablesListSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.TagmanagerAccountsContainersVariablesListResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.TagmanagerAccountsContainersVariablesListRequest(
        req
      );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/tagmanager/v1/accounts/{accountId}/containers/{containerId}/variables",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.TagmanagerAccountsContainersVariablesListSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.TagmanagerAccountsContainersVariablesListResponse =
        new operations.TagmanagerAccountsContainersVariablesListResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listVariablesResponse = utils.objectToClass(
              httpRes?.data,
              shared.ListVariablesResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Updates a GTM Variable.
   */
  tagmanagerAccountsContainersVariablesUpdate(
    req: operations.TagmanagerAccountsContainersVariablesUpdateRequest,
    security: operations.TagmanagerAccountsContainersVariablesUpdateSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.TagmanagerAccountsContainersVariablesUpdateResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.TagmanagerAccountsContainersVariablesUpdateRequest(
        req
      );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/tagmanager/v1/accounts/{accountId}/containers/{containerId}/variables/{variableId}",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "variable",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.TagmanagerAccountsContainersVariablesUpdateSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "put",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.TagmanagerAccountsContainersVariablesUpdateResponse =
        new operations.TagmanagerAccountsContainersVariablesUpdateResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.variable = utils.objectToClass(httpRes?.data, shared.Variable);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Creates a Container Version.
   */
  tagmanagerAccountsContainersVersionsCreate(
    req: operations.TagmanagerAccountsContainersVersionsCreateRequest,
    security: operations.TagmanagerAccountsContainersVersionsCreateSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.TagmanagerAccountsContainersVersionsCreateResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.TagmanagerAccountsContainersVersionsCreateRequest(
        req
      );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/tagmanager/v1/accounts/{accountId}/containers/{containerId}/versions",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "createContainerVersionRequestVersionOptions",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.TagmanagerAccountsContainersVersionsCreateSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.TagmanagerAccountsContainersVersionsCreateResponse =
        new operations.TagmanagerAccountsContainersVersionsCreateResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.createContainerVersionResponse = utils.objectToClass(
              httpRes?.data,
              shared.CreateContainerVersionResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Deletes a Container Version.
   */
  tagmanagerAccountsContainersVersionsDelete(
    req: operations.TagmanagerAccountsContainersVersionsDeleteRequest,
    security: operations.TagmanagerAccountsContainersVersionsDeleteSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.TagmanagerAccountsContainersVersionsDeleteResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.TagmanagerAccountsContainersVersionsDeleteRequest(
        req
      );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/tagmanager/v1/accounts/{accountId}/containers/{containerId}/versions/{containerVersionId}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.TagmanagerAccountsContainersVersionsDeleteSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.TagmanagerAccountsContainersVersionsDeleteResponse =
        new operations.TagmanagerAccountsContainersVersionsDeleteResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          break;
      }

      return res;
    });
  }

  /**
   * Gets a Container Version.
   */
  tagmanagerAccountsContainersVersionsGet(
    req: operations.TagmanagerAccountsContainersVersionsGetRequest,
    security: operations.TagmanagerAccountsContainersVersionsGetSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.TagmanagerAccountsContainersVersionsGetResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.TagmanagerAccountsContainersVersionsGetRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/tagmanager/v1/accounts/{accountId}/containers/{containerId}/versions/{containerVersionId}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.TagmanagerAccountsContainersVersionsGetSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.TagmanagerAccountsContainersVersionsGetResponse =
        new operations.TagmanagerAccountsContainersVersionsGetResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.containerVersion = utils.objectToClass(
              httpRes?.data,
              shared.ContainerVersion
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Lists all Container Versions of a GTM Container.
   */
  tagmanagerAccountsContainersVersionsList(
    req: operations.TagmanagerAccountsContainersVersionsListRequest,
    security: operations.TagmanagerAccountsContainersVersionsListSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.TagmanagerAccountsContainersVersionsListResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.TagmanagerAccountsContainersVersionsListRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/tagmanager/v1/accounts/{accountId}/containers/{containerId}/versions",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.TagmanagerAccountsContainersVersionsListSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.TagmanagerAccountsContainersVersionsListResponse =
        new operations.TagmanagerAccountsContainersVersionsListResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listContainerVersionsResponse = utils.objectToClass(
              httpRes?.data,
              shared.ListContainerVersionsResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Publishes a Container Version.
   */
  tagmanagerAccountsContainersVersionsPublish(
    req: operations.TagmanagerAccountsContainersVersionsPublishRequest,
    security: operations.TagmanagerAccountsContainersVersionsPublishSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.TagmanagerAccountsContainersVersionsPublishResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.TagmanagerAccountsContainersVersionsPublishRequest(
        req
      );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/tagmanager/v1/accounts/{accountId}/containers/{containerId}/versions/{containerVersionId}/publish",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.TagmanagerAccountsContainersVersionsPublishSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "post",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.TagmanagerAccountsContainersVersionsPublishResponse =
        new operations.TagmanagerAccountsContainersVersionsPublishResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.publishContainerVersionResponse = utils.objectToClass(
              httpRes?.data,
              shared.PublishContainerVersionResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Restores a Container Version. This will overwrite the container's current configuration (including its variables, triggers and tags). The operation will not have any effect on the version that is being served (i.e. the published version).
   */
  tagmanagerAccountsContainersVersionsRestore(
    req: operations.TagmanagerAccountsContainersVersionsRestoreRequest,
    security: operations.TagmanagerAccountsContainersVersionsRestoreSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.TagmanagerAccountsContainersVersionsRestoreResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.TagmanagerAccountsContainersVersionsRestoreRequest(
        req
      );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/tagmanager/v1/accounts/{accountId}/containers/{containerId}/versions/{containerVersionId}/restore",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.TagmanagerAccountsContainersVersionsRestoreSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "post",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.TagmanagerAccountsContainersVersionsRestoreResponse =
        new operations.TagmanagerAccountsContainersVersionsRestoreResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.containerVersion = utils.objectToClass(
              httpRes?.data,
              shared.ContainerVersion
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Undeletes a Container Version.
   */
  tagmanagerAccountsContainersVersionsUndelete(
    req: operations.TagmanagerAccountsContainersVersionsUndeleteRequest,
    security: operations.TagmanagerAccountsContainersVersionsUndeleteSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.TagmanagerAccountsContainersVersionsUndeleteResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.TagmanagerAccountsContainersVersionsUndeleteRequest(
        req
      );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/tagmanager/v1/accounts/{accountId}/containers/{containerId}/versions/{containerVersionId}/undelete",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.TagmanagerAccountsContainersVersionsUndeleteSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "post",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.TagmanagerAccountsContainersVersionsUndeleteResponse =
        new operations.TagmanagerAccountsContainersVersionsUndeleteResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.containerVersion = utils.objectToClass(
              httpRes?.data,
              shared.ContainerVersion
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Updates a Container Version.
   */
  tagmanagerAccountsContainersVersionsUpdate(
    req: operations.TagmanagerAccountsContainersVersionsUpdateRequest,
    security: operations.TagmanagerAccountsContainersVersionsUpdateSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.TagmanagerAccountsContainersVersionsUpdateResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.TagmanagerAccountsContainersVersionsUpdateRequest(
        req
      );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/tagmanager/v1/accounts/{accountId}/containers/{containerId}/versions/{containerVersionId}",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "containerVersion",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.TagmanagerAccountsContainersVersionsUpdateSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "put",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.TagmanagerAccountsContainersVersionsUpdateResponse =
        new operations.TagmanagerAccountsContainersVersionsUpdateResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.containerVersion = utils.objectToClass(
              httpRes?.data,
              shared.ContainerVersion
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Gets a GTM Account.
   */
  tagmanagerAccountsGet(
    req: operations.TagmanagerAccountsGetRequest,
    security: operations.TagmanagerAccountsGetSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.TagmanagerAccountsGetResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.TagmanagerAccountsGetRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/tagmanager/v1/accounts/{accountId}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.TagmanagerAccountsGetSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.TagmanagerAccountsGetResponse =
        new operations.TagmanagerAccountsGetResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.account = utils.objectToClass(httpRes?.data, shared.Account);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Lists all GTM Accounts that a user has access to.
   */
  tagmanagerAccountsList(
    req: operations.TagmanagerAccountsListRequest,
    security: operations.TagmanagerAccountsListSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.TagmanagerAccountsListResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.TagmanagerAccountsListRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/tagmanager/v1/accounts";
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.TagmanagerAccountsListSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.TagmanagerAccountsListResponse =
        new operations.TagmanagerAccountsListResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listAccountsResponse = utils.objectToClass(
              httpRes?.data,
              shared.ListAccountsResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Creates a user's Account & Container Permissions.
   */
  tagmanagerAccountsPermissionsCreate(
    req: operations.TagmanagerAccountsPermissionsCreateRequest,
    security: operations.TagmanagerAccountsPermissionsCreateSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.TagmanagerAccountsPermissionsCreateResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.TagmanagerAccountsPermissionsCreateRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/tagmanager/v1/accounts/{accountId}/permissions",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "userAccess",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.TagmanagerAccountsPermissionsCreateSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.TagmanagerAccountsPermissionsCreateResponse =
        new operations.TagmanagerAccountsPermissionsCreateResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.userAccess = utils.objectToClass(
              httpRes?.data,
              shared.UserAccess
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Removes a user from the account, revoking access to it and all of its containers.
   */
  tagmanagerAccountsPermissionsDelete(
    req: operations.TagmanagerAccountsPermissionsDeleteRequest,
    security: operations.TagmanagerAccountsPermissionsDeleteSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.TagmanagerAccountsPermissionsDeleteResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.TagmanagerAccountsPermissionsDeleteRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/tagmanager/v1/accounts/{accountId}/permissions/{permissionId}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.TagmanagerAccountsPermissionsDeleteSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.TagmanagerAccountsPermissionsDeleteResponse =
        new operations.TagmanagerAccountsPermissionsDeleteResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          break;
      }

      return res;
    });
  }

  /**
   * Gets a user's Account & Container Permissions.
   */
  tagmanagerAccountsPermissionsGet(
    req: operations.TagmanagerAccountsPermissionsGetRequest,
    security: operations.TagmanagerAccountsPermissionsGetSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.TagmanagerAccountsPermissionsGetResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.TagmanagerAccountsPermissionsGetRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/tagmanager/v1/accounts/{accountId}/permissions/{permissionId}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.TagmanagerAccountsPermissionsGetSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.TagmanagerAccountsPermissionsGetResponse =
        new operations.TagmanagerAccountsPermissionsGetResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.userAccess = utils.objectToClass(
              httpRes?.data,
              shared.UserAccess
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * List all users that have access to the account along with Account and Container Permissions granted to each of them.
   */
  tagmanagerAccountsPermissionsList(
    req: operations.TagmanagerAccountsPermissionsListRequest,
    security: operations.TagmanagerAccountsPermissionsListSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.TagmanagerAccountsPermissionsListResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.TagmanagerAccountsPermissionsListRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/tagmanager/v1/accounts/{accountId}/permissions",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.TagmanagerAccountsPermissionsListSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.TagmanagerAccountsPermissionsListResponse =
        new operations.TagmanagerAccountsPermissionsListResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listAccountUsersResponse = utils.objectToClass(
              httpRes?.data,
              shared.ListAccountUsersResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Updates a user's Account & Container Permissions.
   */
  tagmanagerAccountsPermissionsUpdate(
    req: operations.TagmanagerAccountsPermissionsUpdateRequest,
    security: operations.TagmanagerAccountsPermissionsUpdateSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.TagmanagerAccountsPermissionsUpdateResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.TagmanagerAccountsPermissionsUpdateRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/tagmanager/v1/accounts/{accountId}/permissions/{permissionId}",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "userAccess",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.TagmanagerAccountsPermissionsUpdateSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "put",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.TagmanagerAccountsPermissionsUpdateResponse =
        new operations.TagmanagerAccountsPermissionsUpdateResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.userAccess = utils.objectToClass(
              httpRes?.data,
              shared.UserAccess
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Updates a GTM Account.
   */
  tagmanagerAccountsUpdate(
    req: operations.TagmanagerAccountsUpdateRequest,
    security: operations.TagmanagerAccountsUpdateSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.TagmanagerAccountsUpdateResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.TagmanagerAccountsUpdateRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/tagmanager/v1/accounts/{accountId}",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "account",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.TagmanagerAccountsUpdateSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "put",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.TagmanagerAccountsUpdateResponse =
        new operations.TagmanagerAccountsUpdateResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.account = utils.objectToClass(httpRes?.data, shared.Account);
          }
          break;
      }

      return res;
    });
  }
}
