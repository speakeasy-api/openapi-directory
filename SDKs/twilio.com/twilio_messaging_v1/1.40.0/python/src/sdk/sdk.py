"""Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT."""

import requests as requests_http
from . import utils
from sdk.models import operations, shared
from typing import Optional

SERVERS = [
    "https://messaging.twilio.com",
]
"""Contains the list of servers available to the SDK"""

class SDK:
    r"""This is the public Twilio REST API."""

    _client: requests_http.Session
    _security_client: requests_http.Session
    _server_url: str = SERVERS[0]
    _language: str = "python"
    _sdk_version: str = "0.0.1"
    _gen_version: str = "internal"

    def __init__(self,
                 server_url: str = None,
                 url_params: dict[str, str] = None,
                 client: requests_http.Session = None
                 ) -> None:
        """Instantiates the SDK configuring it with the provided parameters.
        
        :param server_url: The server URL to use for all operations
        :type server_url: str
        :param url_params: Parameters to optionally template the server URL with
        :type url_params: dict[str, str]
        :param client: The requests.Session HTTP client to use for all operations
        :type client: requests_http.Session        
        """
        self._client = requests_http.Session()
        
        
        if server_url is not None:
            if url_params is not None:
                self._server_url = utils.template_url(server_url, url_params)
            else:
                self._server_url = server_url

        if client is not None:
            self._client = client
        
        self._security_client = self._client
        

        
    
    
    def create_alpha_sender(self, request: operations.CreateAlphaSenderRequest, security: operations.CreateAlphaSenderSecurity, server_url: Optional[str] = None) -> operations.CreateAlphaSenderResponse:
        base_url = operations.CREATE_ALPHA_SENDER_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.CreateAlphaSenderRequest, base_url, '/v1/Services/{ServiceSid}/AlphaSenders', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'form')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.CreateAlphaSenderResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 201:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.MessagingV1ServiceAlphaSender])
                res.messaging_v1_service_alpha_sender = out

        return res

    def create_brand_registrations(self, request: operations.CreateBrandRegistrationsCreateBrandRegistrationsRequest, security: operations.CreateBrandRegistrationsSecurity, server_url: Optional[str] = None) -> operations.CreateBrandRegistrationsResponse:
        base_url = operations.CREATE_BRAND_REGISTRATIONS_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = base_url.removesuffix('/') + '/v1/a2p/BrandRegistrations'
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request", 'form')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.CreateBrandRegistrationsResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 201:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.MessagingV1BrandRegistrations])
                res.messaging_v1_brand_registrations = out

        return res

    def create_brand_vetting(self, request: operations.CreateBrandVettingRequest, security: operations.CreateBrandVettingSecurity, server_url: Optional[str] = None) -> operations.CreateBrandVettingResponse:
        base_url = operations.CREATE_BRAND_VETTING_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.CreateBrandVettingRequest, base_url, '/v1/a2p/BrandRegistrations/{BrandSid}/Vettings', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'form')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.CreateBrandVettingResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 201:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.MessagingV1BrandRegistrationsBrandVetting])
                res.messaging_v1_brand_registrations_brand_vetting = out

        return res

    def create_external_campaign(self, request: operations.CreateExternalCampaignCreateExternalCampaignRequest, security: operations.CreateExternalCampaignSecurity, server_url: Optional[str] = None) -> operations.CreateExternalCampaignResponse:
        base_url = operations.CREATE_EXTERNAL_CAMPAIGN_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = base_url.removesuffix('/') + '/v1/Services/PreregisteredUsa2p'
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request", 'form')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.CreateExternalCampaignResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 201:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.MessagingV1ExternalCampaign])
                res.messaging_v1_external_campaign = out

        return res

    def create_linkshortening_messaging_service(self, request: operations.CreateLinkshorteningMessagingServiceRequest, security: operations.CreateLinkshorteningMessagingServiceSecurity, server_url: Optional[str] = None) -> operations.CreateLinkshorteningMessagingServiceResponse:
        base_url = operations.CREATE_LINKSHORTENING_MESSAGING_SERVICE_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.CreateLinkshorteningMessagingServiceRequest, base_url, '/v1/LinkShortening/Domains/{DomainSid}/MessagingServices/{MessagingServiceSid}', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.CreateLinkshorteningMessagingServiceResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 201:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.MessagingV1LinkshorteningMessagingService])
                res.messaging_v1_linkshortening_messaging_service = out

        return res

    def create_phone_number(self, request: operations.CreatePhoneNumberRequest, security: operations.CreatePhoneNumberSecurity, server_url: Optional[str] = None) -> operations.CreatePhoneNumberResponse:
        base_url = operations.CREATE_PHONE_NUMBER_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.CreatePhoneNumberRequest, base_url, '/v1/Services/{ServiceSid}/PhoneNumbers', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'form')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.CreatePhoneNumberResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 201:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.MessagingV1ServicePhoneNumber])
                res.messaging_v1_service_phone_number = out

        return res

    def create_service(self, request: operations.CreateServiceCreateServiceRequest, security: operations.CreateServiceSecurity, server_url: Optional[str] = None) -> operations.CreateServiceResponse:
        base_url = operations.CREATE_SERVICE_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = base_url.removesuffix('/') + '/v1/Services'
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request", 'form')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.CreateServiceResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 201:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.MessagingV1Service])
                res.messaging_v1_service = out

        return res

    def create_short_code(self, request: operations.CreateShortCodeRequest, security: operations.CreateShortCodeSecurity, server_url: Optional[str] = None) -> operations.CreateShortCodeResponse:
        base_url = operations.CREATE_SHORT_CODE_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.CreateShortCodeRequest, base_url, '/v1/Services/{ServiceSid}/ShortCodes', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'form')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.CreateShortCodeResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 201:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.MessagingV1ServiceShortCode])
                res.messaging_v1_service_short_code = out

        return res

    def create_tollfree_verification(self, request: operations.CreateTollfreeVerificationCreateTollfreeVerificationRequest, security: operations.CreateTollfreeVerificationSecurity, server_url: Optional[str] = None) -> operations.CreateTollfreeVerificationResponse:
        base_url = operations.CREATE_TOLLFREE_VERIFICATION_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = base_url.removesuffix('/') + '/v1/Tollfree/Verifications'
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request", 'form')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.CreateTollfreeVerificationResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 201:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.MessagingV1TollfreeVerification])
                res.messaging_v1_tollfree_verification = out

        return res

    def create_us_app_to_person(self, request: operations.CreateUsAppToPersonRequest, security: operations.CreateUsAppToPersonSecurity, server_url: Optional[str] = None) -> operations.CreateUsAppToPersonResponse:
        base_url = operations.CREATE_US_APP_TO_PERSON_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.CreateUsAppToPersonRequest, base_url, '/v1/Services/{MessagingServiceSid}/Compliance/Usa2p', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'form')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.CreateUsAppToPersonResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 201:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.MessagingV1ServiceUsAppToPerson])
                res.messaging_v1_service_us_app_to_person = out

        return res

    def delete_alpha_sender(self, request: operations.DeleteAlphaSenderRequest, security: operations.DeleteAlphaSenderSecurity, server_url: Optional[str] = None) -> operations.DeleteAlphaSenderResponse:
        base_url = operations.DELETE_ALPHA_SENDER_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.DeleteAlphaSenderRequest, base_url, '/v1/Services/{ServiceSid}/AlphaSenders/{Sid}', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('DELETE', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DeleteAlphaSenderResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        

        return res

    def delete_domain_cert_v4(self, request: operations.DeleteDomainCertV4Request, security: operations.DeleteDomainCertV4Security, server_url: Optional[str] = None) -> operations.DeleteDomainCertV4Response:
        base_url = operations.DELETE_DOMAIN_CERT_V4_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.DeleteDomainCertV4Request, base_url, '/v1/LinkShortening/Domains/{DomainSid}/Certificate', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('DELETE', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DeleteDomainCertV4Response(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        

        return res

    def delete_linkshortening_messaging_service(self, request: operations.DeleteLinkshorteningMessagingServiceRequest, security: operations.DeleteLinkshorteningMessagingServiceSecurity, server_url: Optional[str] = None) -> operations.DeleteLinkshorteningMessagingServiceResponse:
        base_url = operations.DELETE_LINKSHORTENING_MESSAGING_SERVICE_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.DeleteLinkshorteningMessagingServiceRequest, base_url, '/v1/LinkShortening/Domains/{DomainSid}/MessagingServices/{MessagingServiceSid}', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('DELETE', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DeleteLinkshorteningMessagingServiceResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        

        return res

    def delete_phone_number(self, request: operations.DeletePhoneNumberRequest, security: operations.DeletePhoneNumberSecurity, server_url: Optional[str] = None) -> operations.DeletePhoneNumberResponse:
        base_url = operations.DELETE_PHONE_NUMBER_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.DeletePhoneNumberRequest, base_url, '/v1/Services/{ServiceSid}/PhoneNumbers/{Sid}', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('DELETE', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DeletePhoneNumberResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        

        return res

    def delete_service(self, request: operations.DeleteServiceRequest, security: operations.DeleteServiceSecurity, server_url: Optional[str] = None) -> operations.DeleteServiceResponse:
        base_url = operations.DELETE_SERVICE_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.DeleteServiceRequest, base_url, '/v1/Services/{Sid}', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('DELETE', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DeleteServiceResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        

        return res

    def delete_short_code(self, request: operations.DeleteShortCodeRequest, security: operations.DeleteShortCodeSecurity, server_url: Optional[str] = None) -> operations.DeleteShortCodeResponse:
        base_url = operations.DELETE_SHORT_CODE_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.DeleteShortCodeRequest, base_url, '/v1/Services/{ServiceSid}/ShortCodes/{Sid}', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('DELETE', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DeleteShortCodeResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        

        return res

    def delete_us_app_to_person(self, request: operations.DeleteUsAppToPersonRequest, security: operations.DeleteUsAppToPersonSecurity, server_url: Optional[str] = None) -> operations.DeleteUsAppToPersonResponse:
        base_url = operations.DELETE_US_APP_TO_PERSON_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.DeleteUsAppToPersonRequest, base_url, '/v1/Services/{MessagingServiceSid}/Compliance/Usa2p/{Sid}', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('DELETE', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DeleteUsAppToPersonResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        

        return res

    def fetch_alpha_sender(self, request: operations.FetchAlphaSenderRequest, security: operations.FetchAlphaSenderSecurity, server_url: Optional[str] = None) -> operations.FetchAlphaSenderResponse:
        base_url = operations.FETCH_ALPHA_SENDER_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.FetchAlphaSenderRequest, base_url, '/v1/Services/{ServiceSid}/AlphaSenders/{Sid}', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.FetchAlphaSenderResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.MessagingV1ServiceAlphaSender])
                res.messaging_v1_service_alpha_sender = out

        return res

    def fetch_brand_registrations(self, request: operations.FetchBrandRegistrationsRequest, security: operations.FetchBrandRegistrationsSecurity, server_url: Optional[str] = None) -> operations.FetchBrandRegistrationsResponse:
        base_url = operations.FETCH_BRAND_REGISTRATIONS_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.FetchBrandRegistrationsRequest, base_url, '/v1/a2p/BrandRegistrations/{Sid}', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.FetchBrandRegistrationsResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.MessagingV1BrandRegistrations])
                res.messaging_v1_brand_registrations = out

        return res

    def fetch_brand_vetting(self, request: operations.FetchBrandVettingRequest, security: operations.FetchBrandVettingSecurity, server_url: Optional[str] = None) -> operations.FetchBrandVettingResponse:
        base_url = operations.FETCH_BRAND_VETTING_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.FetchBrandVettingRequest, base_url, '/v1/a2p/BrandRegistrations/{BrandSid}/Vettings/{BrandVettingSid}', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.FetchBrandVettingResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.MessagingV1BrandRegistrationsBrandVetting])
                res.messaging_v1_brand_registrations_brand_vetting = out

        return res

    def fetch_deactivation(self, request: operations.FetchDeactivationRequest, security: operations.FetchDeactivationSecurity, server_url: Optional[str] = None) -> operations.FetchDeactivationResponse:
        r"""Fetch a list of all United States numbers that have been deactivated on a specific date."""
        base_url = operations.FETCH_DEACTIVATION_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = base_url.removesuffix('/') + '/v1/Deactivations'
        
        query_params = utils.get_query_params(operations.FetchDeactivationRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.FetchDeactivationResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 307:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.MessagingV1Deactivation])
                res.messaging_v1_deactivation = out

        return res

    def fetch_domain_cert_v4(self, request: operations.FetchDomainCertV4Request, security: operations.FetchDomainCertV4Security, server_url: Optional[str] = None) -> operations.FetchDomainCertV4Response:
        base_url = operations.FETCH_DOMAIN_CERT_V4_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.FetchDomainCertV4Request, base_url, '/v1/LinkShortening/Domains/{DomainSid}/Certificate', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.FetchDomainCertV4Response(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.MessagingV1DomainCertV4])
                res.messaging_v1_domain_cert_v4 = out

        return res

    def fetch_domain_config(self, request: operations.FetchDomainConfigRequest, security: operations.FetchDomainConfigSecurity, server_url: Optional[str] = None) -> operations.FetchDomainConfigResponse:
        base_url = operations.FETCH_DOMAIN_CONFIG_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.FetchDomainConfigRequest, base_url, '/v1/LinkShortening/Domains/{DomainSid}/Config', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.FetchDomainConfigResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.MessagingV1DomainConfig])
                res.messaging_v1_domain_config = out

        return res

    def fetch_domain_config_messaging_service(self, request: operations.FetchDomainConfigMessagingServiceRequest, security: operations.FetchDomainConfigMessagingServiceSecurity, server_url: Optional[str] = None) -> operations.FetchDomainConfigMessagingServiceResponse:
        base_url = operations.FETCH_DOMAIN_CONFIG_MESSAGING_SERVICE_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.FetchDomainConfigMessagingServiceRequest, base_url, '/v1/LinkShortening/MessagingService/{MessagingServiceSid}/DomainConfig', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.FetchDomainConfigMessagingServiceResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.MessagingV1DomainConfigMessagingService])
                res.messaging_v1_domain_config_messaging_service = out

        return res

    def fetch_phone_number(self, request: operations.FetchPhoneNumberRequest, security: operations.FetchPhoneNumberSecurity, server_url: Optional[str] = None) -> operations.FetchPhoneNumberResponse:
        base_url = operations.FETCH_PHONE_NUMBER_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.FetchPhoneNumberRequest, base_url, '/v1/Services/{ServiceSid}/PhoneNumbers/{Sid}', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.FetchPhoneNumberResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.MessagingV1ServicePhoneNumber])
                res.messaging_v1_service_phone_number = out

        return res

    def fetch_service(self, request: operations.FetchServiceRequest, security: operations.FetchServiceSecurity, server_url: Optional[str] = None) -> operations.FetchServiceResponse:
        base_url = operations.FETCH_SERVICE_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.FetchServiceRequest, base_url, '/v1/Services/{Sid}', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.FetchServiceResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.MessagingV1Service])
                res.messaging_v1_service = out

        return res

    def fetch_short_code(self, request: operations.FetchShortCodeRequest, security: operations.FetchShortCodeSecurity, server_url: Optional[str] = None) -> operations.FetchShortCodeResponse:
        base_url = operations.FETCH_SHORT_CODE_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.FetchShortCodeRequest, base_url, '/v1/Services/{ServiceSid}/ShortCodes/{Sid}', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.FetchShortCodeResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.MessagingV1ServiceShortCode])
                res.messaging_v1_service_short_code = out

        return res

    def fetch_tollfree_verification(self, request: operations.FetchTollfreeVerificationRequest, security: operations.FetchTollfreeVerificationSecurity, server_url: Optional[str] = None) -> operations.FetchTollfreeVerificationResponse:
        base_url = operations.FETCH_TOLLFREE_VERIFICATION_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.FetchTollfreeVerificationRequest, base_url, '/v1/Tollfree/Verifications/{Sid}', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.FetchTollfreeVerificationResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.MessagingV1TollfreeVerification])
                res.messaging_v1_tollfree_verification = out

        return res

    def fetch_us_app_to_person(self, request: operations.FetchUsAppToPersonRequest, security: operations.FetchUsAppToPersonSecurity, server_url: Optional[str] = None) -> operations.FetchUsAppToPersonResponse:
        base_url = operations.FETCH_US_APP_TO_PERSON_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.FetchUsAppToPersonRequest, base_url, '/v1/Services/{MessagingServiceSid}/Compliance/Usa2p/{Sid}', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.FetchUsAppToPersonResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.MessagingV1ServiceUsAppToPerson])
                res.messaging_v1_service_us_app_to_person = out

        return res

    def fetch_us_app_to_person_usecase(self, request: operations.FetchUsAppToPersonUsecaseRequest, security: operations.FetchUsAppToPersonUsecaseSecurity, server_url: Optional[str] = None) -> operations.FetchUsAppToPersonUsecaseResponse:
        base_url = operations.FETCH_US_APP_TO_PERSON_USECASE_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.FetchUsAppToPersonUsecaseRequest, base_url, '/v1/Services/{MessagingServiceSid}/Compliance/Usa2p/Usecases', request)
        
        query_params = utils.get_query_params(operations.FetchUsAppToPersonUsecaseRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.FetchUsAppToPersonUsecaseResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.MessagingV1ServiceUsAppToPersonUsecase])
                res.messaging_v1_service_us_app_to_person_usecase = out

        return res

    def fetch_usecase(self, server_url: Optional[str] = None) -> operations.FetchUsecaseResponse:
        base_url = operations.FETCH_USECASE_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = base_url.removesuffix('/') + '/v1/Services/Usecases'
        
        
        client = self._client
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.FetchUsecaseResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.MessagingV1Usecase])
                res.messaging_v1_usecase = out

        return res

    def list_alpha_sender(self, request: operations.ListAlphaSenderRequest, security: operations.ListAlphaSenderSecurity, server_url: Optional[str] = None) -> operations.ListAlphaSenderResponse:
        base_url = operations.LIST_ALPHA_SENDER_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.ListAlphaSenderRequest, base_url, '/v1/Services/{ServiceSid}/AlphaSenders', request)
        
        query_params = utils.get_query_params(operations.ListAlphaSenderRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ListAlphaSenderResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.ListAlphaSenderListAlphaSenderResponse])
                res.list_alpha_sender_response = out

        return res

    def list_brand_registrations(self, request: operations.ListBrandRegistrationsRequest, security: operations.ListBrandRegistrationsSecurity, server_url: Optional[str] = None) -> operations.ListBrandRegistrationsResponse:
        base_url = operations.LIST_BRAND_REGISTRATIONS_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = base_url.removesuffix('/') + '/v1/a2p/BrandRegistrations'
        
        query_params = utils.get_query_params(operations.ListBrandRegistrationsRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ListBrandRegistrationsResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.ListBrandRegistrationsListBrandRegistrationsResponse])
                res.list_brand_registrations_response = out

        return res

    def list_brand_vetting(self, request: operations.ListBrandVettingRequest, security: operations.ListBrandVettingSecurity, server_url: Optional[str] = None) -> operations.ListBrandVettingResponse:
        base_url = operations.LIST_BRAND_VETTING_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.ListBrandVettingRequest, base_url, '/v1/a2p/BrandRegistrations/{BrandSid}/Vettings', request)
        
        query_params = utils.get_query_params(operations.ListBrandVettingRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ListBrandVettingResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.ListBrandVettingListBrandVettingResponse])
                res.list_brand_vetting_response = out

        return res

    def list_phone_number(self, request: operations.ListPhoneNumberRequest, security: operations.ListPhoneNumberSecurity, server_url: Optional[str] = None) -> operations.ListPhoneNumberResponse:
        base_url = operations.LIST_PHONE_NUMBER_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.ListPhoneNumberRequest, base_url, '/v1/Services/{ServiceSid}/PhoneNumbers', request)
        
        query_params = utils.get_query_params(operations.ListPhoneNumberRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ListPhoneNumberResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.ListPhoneNumberListPhoneNumberResponse])
                res.list_phone_number_response = out

        return res

    def list_service(self, request: operations.ListServiceRequest, security: operations.ListServiceSecurity, server_url: Optional[str] = None) -> operations.ListServiceResponse:
        base_url = operations.LIST_SERVICE_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = base_url.removesuffix('/') + '/v1/Services'
        
        query_params = utils.get_query_params(operations.ListServiceRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ListServiceResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.ListServiceListServiceResponse])
                res.list_service_response = out

        return res

    def list_short_code(self, request: operations.ListShortCodeRequest, security: operations.ListShortCodeSecurity, server_url: Optional[str] = None) -> operations.ListShortCodeResponse:
        base_url = operations.LIST_SHORT_CODE_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.ListShortCodeRequest, base_url, '/v1/Services/{ServiceSid}/ShortCodes', request)
        
        query_params = utils.get_query_params(operations.ListShortCodeRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ListShortCodeResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.ListShortCodeListShortCodeResponse])
                res.list_short_code_response = out

        return res

    def list_tollfree_verification(self, request: operations.ListTollfreeVerificationRequest, security: operations.ListTollfreeVerificationSecurity, server_url: Optional[str] = None) -> operations.ListTollfreeVerificationResponse:
        base_url = operations.LIST_TOLLFREE_VERIFICATION_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = base_url.removesuffix('/') + '/v1/Tollfree/Verifications'
        
        query_params = utils.get_query_params(operations.ListTollfreeVerificationRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ListTollfreeVerificationResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.ListTollfreeVerificationListTollfreeVerificationResponse])
                res.list_tollfree_verification_response = out

        return res

    def list_us_app_to_person(self, request: operations.ListUsAppToPersonRequest, security: operations.ListUsAppToPersonSecurity, server_url: Optional[str] = None) -> operations.ListUsAppToPersonResponse:
        base_url = operations.LIST_US_APP_TO_PERSON_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.ListUsAppToPersonRequest, base_url, '/v1/Services/{MessagingServiceSid}/Compliance/Usa2p', request)
        
        query_params = utils.get_query_params(operations.ListUsAppToPersonRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ListUsAppToPersonResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.ListUsAppToPersonListUsAppToPersonResponse])
                res.list_us_app_to_person_response = out

        return res

    def update_brand_registrations(self, request: operations.UpdateBrandRegistrationsRequest, security: operations.UpdateBrandRegistrationsSecurity, server_url: Optional[str] = None) -> operations.UpdateBrandRegistrationsResponse:
        base_url = operations.UPDATE_BRAND_REGISTRATIONS_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.UpdateBrandRegistrationsRequest, base_url, '/v1/a2p/BrandRegistrations/{Sid}', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.UpdateBrandRegistrationsResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 202:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.MessagingV1BrandRegistrations])
                res.messaging_v1_brand_registrations = out

        return res

    def update_domain_cert_v4(self, request: operations.UpdateDomainCertV4Request, security: operations.UpdateDomainCertV4Security, server_url: Optional[str] = None) -> operations.UpdateDomainCertV4Response:
        base_url = operations.UPDATE_DOMAIN_CERT_V4_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.UpdateDomainCertV4Request, base_url, '/v1/LinkShortening/Domains/{DomainSid}/Certificate', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'form')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.UpdateDomainCertV4Response(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code in [200, 201]:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.MessagingV1DomainCertV4])
                res.messaging_v1_domain_cert_v4 = out

        return res

    def update_domain_config(self, request: operations.UpdateDomainConfigRequest, security: operations.UpdateDomainConfigSecurity, server_url: Optional[str] = None) -> operations.UpdateDomainConfigResponse:
        base_url = operations.UPDATE_DOMAIN_CONFIG_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.UpdateDomainConfigRequest, base_url, '/v1/LinkShortening/Domains/{DomainSid}/Config', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'form')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.UpdateDomainConfigResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code in [200, 201]:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.MessagingV1DomainConfig])
                res.messaging_v1_domain_config = out

        return res

    def update_service(self, request: operations.UpdateServiceRequest, security: operations.UpdateServiceSecurity, server_url: Optional[str] = None) -> operations.UpdateServiceResponse:
        base_url = operations.UPDATE_SERVICE_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.UpdateServiceRequest, base_url, '/v1/Services/{Sid}', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'form')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.UpdateServiceResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.MessagingV1Service])
                res.messaging_v1_service = out

        return res

    def update_tollfree_verification(self, request: operations.UpdateTollfreeVerificationRequest, security: operations.UpdateTollfreeVerificationSecurity, server_url: Optional[str] = None) -> operations.UpdateTollfreeVerificationResponse:
        base_url = operations.UPDATE_TOLLFREE_VERIFICATION_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.UpdateTollfreeVerificationRequest, base_url, '/v1/Tollfree/Verifications/{Sid}', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'form')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.UpdateTollfreeVerificationResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 202:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.MessagingV1TollfreeVerification])
                res.messaging_v1_tollfree_verification = out

        return res

    