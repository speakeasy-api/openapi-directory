<?php

/**
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

declare(strict_types=1);

namespace OpenAPI\OpenAPI;

/**
 * SDK - The Socrata OpenDataNetwork (ODN) REST API exposes public data, often continuosly updated and enhanced, from many thousands of public
 * 
 * government and non profit agencies.
 * 
 * Much of this data originating from independent sources is fused together to create new, and often
 * powerful, entity level data. The API, in addition to search and autosuggest capabilities for finding datasets,
 * enables data based comparisons across geographical regions such as states, counties, metropolitan areas,
 * cities and zip codes using highly vetted data providers such as US Census, BEA, HUD and others. Comparison data
 * is preformatted for easy and efficient display on a chart, graph or interactive map.
 * 
 * The API also exposes data organized by narrative style questions a human might ask. The questions can
 * be rapidly found using an autosuggest style index, and then used to directly access all data needed to
 * thoroughly and authoritatively answer the question. Retrieved data includes time series (temporally aligned),
 * tabular, map heavy (includes spatial boundaries), and auto generated unstructured descriptive text.
 * 
 * The ODN API does not duplicate API endpoints or services provided by public sector agencies, but rather,
 * returns context relevant pre-populated REST URLs, when appropriate, so the caller can access data
 * directly from the source.
 * 
 * The [open source](http://github.com/socrata/odn-backend) API powers [OpenDataNetwork.com](http://OpenDataNetwork.com), an [open source](http://github.com/socrata/opendatanetwork.com)
 * site; the site highlights myriad uses and provides API badges with contextually relevant API example
 * REST endpoints and documentation pointers.
 * 
 * Finally, we continuously add new dat sources which appear automatically in the API, so if your favorite data
 * source is not available, check back soon. You can also join us [HERE](http://www.opendatanetwork.com/join-open-data-network)
 * and receive updates or let us know which data sources you are most interested in.
 * 
 * ## App Tokens
 * 
 * Registering for and including a [Socrata application token](https://dev.socrata.com/docs/app-tokens.html)
 * is _required_ for the ODN API. They can be passed either using the `app_token` parameter
 * or the `X-App-Token` HTTP header.
 * 
 * @package OpenAPI\OpenAPI
 * @access public
 */
class SDK
{
	public const SERVERS = [
		'http://api.opendatanetwork.com',
	];
  		
	// SDK private variables namespaced with _ to avoid conflicts with API models
	private ?\GuzzleHttp\ClientInterface $_defaultClient;
	private ?\GuzzleHttp\ClientInterface $_securityClient;
	
	private string $_serverUrl;
	private string $_language = 'php';
	private string $_sdkVersion = '0.0.1';
	private string $_genVersion = 'internal';

	/**
	 * Returns a new instance of the SDK builder used to configure and create the SDK instance.
	 * 
	 * @return SDKBuilder
	 */
	public static function builder(): SDKBuilder
	{
		return new SDKBuilder();
	}

	/**
	 * @param \GuzzleHttp\ClientInterface|null $client
	 * @param string $serverUrl
	 * @param array<string, string>|null $params
	 */
	public function __construct(?\GuzzleHttp\ClientInterface $client, string $serverUrl, ?array $params)
	{
		$this->_defaultClient = $client;
		
		if ($this->_defaultClient === null) {
			$this->_defaultClient = new \GuzzleHttp\Client([
				'timeout' => 60,
			]);
		}

		$this->_securityClient = null;
		if ($this->_securityClient === null) {
			$this->_securityClient = $this->_defaultClient;
		}

		if (!empty($serverUrl)) {
			$this->_serverUrl = Utils\Utils::templateUrl($serverUrl, $params);
		}
		
		if (empty($this->_serverUrl)) {
			$this->_serverUrl = $this::SERVERS[0];
		}
	}
	
    /**
     * Create a map
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\CreateAMapRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\CreateAMapResponse
     */
	public function createAMap(
        \OpenAPI\OpenAPI\Models\Operations\CreateAMapRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\CreateAMapResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/data/v1/map/new');
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\CreateAMapRequest::class, $request, null));
        $options = array_merge_recursive($options, Utils\Utils::getHeaders($request));
        
        $httpResponse = $this->_defaultClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\CreateAMapResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
        }

        return $response;
    }
	
    /**
     * Find all available data for some entities
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\FindAllAvailableDataForSomeEntitiesRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\FindAllAvailableDataForSomeEntitiesResponse
     */
	public function findAllAvailableDataForSomeEntities(
        \OpenAPI\OpenAPI\Models\Operations\FindAllAvailableDataForSomeEntitiesRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\FindAllAvailableDataForSomeEntitiesResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/data/v1/availability/');
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\FindAllAvailableDataForSomeEntitiesRequest::class, $request, null));
        $options = array_merge_recursive($options, Utils\Utils::getHeaders($request));
        
        $httpResponse = $this->_defaultClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\FindAllAvailableDataForSomeEntitiesResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
        }

        return $response;
    }
	
    /**
     * Find the relatives of an entity
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\FindTheRelativesOfAnEntityRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\FindTheRelativesOfAnEntityResponse
     */
	public function findTheRelativesOfAnEntity(
        \OpenAPI\OpenAPI\Models\Operations\FindTheRelativesOfAnEntityRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\FindTheRelativesOfAnEntityResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/entity/v1/{relation}', \OpenAPI\OpenAPI\Models\Operations\FindTheRelativesOfAnEntityRequest::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\FindTheRelativesOfAnEntityRequest::class, $request, null));
        $options = array_merge_recursive($options, Utils\Utils::getHeaders($request));
        
        $httpResponse = $this->_defaultClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\FindTheRelativesOfAnEntityResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
        }

        return $response;
    }
	
    /**
     * Get Entities
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetEntitiesRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\GetEntitiesResponse
     */
	public function getEntities(
        \OpenAPI\OpenAPI\Models\Operations\GetEntitiesRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\GetEntitiesResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/entity/v1');
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\GetEntitiesRequest::class, $request, null));
        $options = array_merge_recursive($options, Utils\Utils::getHeaders($request));
        
        $httpResponse = $this->_defaultClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetEntitiesResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
        }

        return $response;
    }
	
    /**
     * Get constraint permutations for entities
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetConstraintPermutationsForEntitiesRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\GetConstraintPermutationsForEntitiesResponse
     */
	public function getConstraintPermutationsForEntities(
        \OpenAPI\OpenAPI\Models\Operations\GetConstraintPermutationsForEntitiesRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\GetConstraintPermutationsForEntitiesResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/data/v1/constraint/{variable}', \OpenAPI\OpenAPI\Models\Operations\GetConstraintPermutationsForEntitiesRequest::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\GetConstraintPermutationsForEntitiesRequest::class, $request, null));
        $options = array_merge_recursive($options, Utils\Utils::getHeaders($request));
        
        $httpResponse = $this->_defaultClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetConstraintPermutationsForEntitiesResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
        }

        return $response;
    }
	
    /**
     * Get datasets
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetDatasetsRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\GetDatasetsResponse
     */
	public function getDatasets(
        \OpenAPI\OpenAPI\Models\Operations\GetDatasetsRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\GetDatasetsResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/search/v1/dataset');
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\GetDatasetsRequest::class, $request, null));
        $options = array_merge_recursive($options, Utils\Utils::getHeaders($request));
        
        $httpResponse = $this->_defaultClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetDatasetsResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
        }

        return $response;
    }
	
    /**
     * Get questions
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetQuestionsRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\GetQuestionsResponse
     */
	public function getQuestions(
        \OpenAPI\OpenAPI\Models\Operations\GetQuestionsRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\GetQuestionsResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/search/v1/question');
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\GetQuestionsRequest::class, $request, null));
        $options = array_merge_recursive($options, Utils\Utils::getHeaders($request));
        
        $httpResponse = $this->_defaultClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetQuestionsResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
        }

        return $response;
    }
	
    /**
     * Get suggestions
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetSuggestionsRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\GetSuggestionsResponse
     */
	public function getSuggestions(
        \OpenAPI\OpenAPI\Models\Operations\GetSuggestionsRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\GetSuggestionsResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/suggest/v1/{type}', \OpenAPI\OpenAPI\Models\Operations\GetSuggestionsRequest::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\GetSuggestionsRequest::class, $request, null));
        $options = array_merge_recursive($options, Utils\Utils::getHeaders($request));
        
        $httpResponse = $this->_defaultClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetSuggestionsResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
        }

        return $response;
    }
	
    /**
     * Get values for variables
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetValuesForVariablesRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\GetValuesForVariablesResponse
     */
	public function getValuesForVariables(
        \OpenAPI\OpenAPI\Models\Operations\GetValuesForVariablesRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\GetValuesForVariablesResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/data/v1/values');
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\GetValuesForVariablesRequest::class, $request, null));
        $options = array_merge_recursive($options, Utils\Utils::getHeaders($request));
        
        $httpResponse = $this->_defaultClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetValuesForVariablesResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
        }

        return $response;
    }
}