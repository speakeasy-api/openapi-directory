"""Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT."""

import requests as requests_http
from . import utils
from sdk.models import operations, shared
from typing import Any, Optional

class ContinuousProject:
    _client: requests_http.Session
    _security_client: requests_http.Session
    _server_url: str
    _language: str
    _sdk_version: str
    _gen_version: str

    def __init__(self, client: requests_http.Session, security_client: requests_http.Session, server_url: str, language: str, sdk_version: str, gen_version: str) -> None:
        self._client = client
        self._security_client = security_client
        self._server_url = server_url
        self._language = language
        self._sdk_version = sdk_version
        self._gen_version = gen_version
        
    def add_document(self, request: operations.AddDocumentRequest) -> operations.AddDocumentResponse:
        r"""Add a new document to your continuous project
        Add a new document to your continuous project. If the name already exists, it will update the existing document. In most scenarios, this operation will also trigger auto-translation of your document, via MT and/or TM.
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.AddDocumentRequest, base_url, '/continuous_projects/{projectId}/documents', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "add_or_update_document_request", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        
        client = self._security_client
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.AddDocumentResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ContinuousProjectDocument])
                res.continuous_project_document = out

        return res

    def collect_analytics(self, request: operations.CollectAnalyticsRequest) -> operations.CollectAnalyticsResponse:
        r"""Save/collect analytics data from Active widget
        Save/collect analytics data from Active widget
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.CollectAnalyticsRequest, base_url, '/continuous_projects/{id}/collect-analytics', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "analytics_collection", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        
        client = self._security_client
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.CollectAnalyticsResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.OperationStatus])
                res.operation_status = out

        return res

    def complete(self, request: operations.CompleteRequest) -> operations.CompleteResponse:
        r"""Complete continuous project
        Complete continuous project
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.CompleteRequest, base_url, '/continuous_projects/{id}/complete', request)
        
        
        client = self._security_client
        
        http_res = client.request('POST', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.CompleteResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.OperationStatus])
                res.operation_status = out

        return res

    def complete_continuous_document(self, request: operations.CompleteContinuousDocumentRequest) -> operations.CompleteContinuousDocumentResponse:
        r"""Complete a continuous project document
        Complete a continuous project document. Per your project settings, a continuous project document can be target language-specific or project-wide for all target languages of the project.
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.CompleteContinuousDocumentRequest, base_url, '/continuous_projects/{id}/documents/{documentId}/complete', request)
        
        
        client = self._security_client
        
        http_res = client.request('POST', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.CompleteContinuousDocumentResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.OperationStatus])
                res.operation_status = out
        elif http_res.status_code == 404:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Error])
                res.error = out

        return res

    def complete_language(self, request: operations.CompleteLanguageRequest) -> operations.CompleteLanguageResponse:
        r"""Complete continuous project language
        Complete continuous project language
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.CompleteLanguageRequest, base_url, '/continuous_projects/{id}/languages/{targetLanguage}/complete', request)
        
        
        client = self._security_client
        
        http_res = client.request('POST', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.CompleteLanguageResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.OperationStatus])
                res.operation_status = out

        return res

    def create_active_widget(self, request: operations.CreateActiveWidgetRequest) -> operations.CreateActiveWidgetResponse:
        r"""Create a new Active widget
        Create a new widget for your Active project to be used in your website. Most website-specific configuration is provided via widgets. This does not create a new Active project, just a separate widget.
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.CreateActiveWidgetRequest, base_url, '/continuous_projects/{projectId}/widgets', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "active_widget", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        
        client = self._security_client
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.CreateActiveWidgetResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ActiveWidget])
                res.active_widget = out
        elif http_res.status_code == 404:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Error])
                res.error = out

        return res

    def create_continuous_project(self, request: shared.ContinuousProject) -> operations.CreateContinuousProjectResponse:
        r"""Create a continuous project
        Create a new continuous project for your software, website, CI/CD translation needs.
        """
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/continuous_projects'
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        
        client = self._security_client
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.CreateContinuousProjectResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ContinuousProject])
                res.continuous_project = out

        return res

    def create_subscription(self, request: operations.CreateSubscriptionRequest) -> operations.CreateSubscriptionResponse:
        r"""Create subscription for continuous project
        Create subscription for continuous project
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.CreateSubscriptionRequest, base_url, '/continuous_projects/{id}/subscription', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "subscription", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = self._security_client
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.CreateSubscriptionResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Subscription])
                res.subscription = out
        elif http_res.status_code in [400, 404]:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Error])
                res.error = out

        return res

    def delete_active_widget(self, request: operations.DeleteActiveWidgetRequest) -> operations.DeleteActiveWidgetResponse:
        r"""Delete a single widget for this Active project
        Delete a single widget for this Active project
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.DeleteActiveWidgetRequest, base_url, '/continuous_projects/{projectId}/widgets/{widgetId}', request)
        
        
        client = self._security_client
        
        http_res = client.request('DELETE', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DeleteActiveWidgetResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.OperationStatus])
                res.operation_status = out
        elif http_res.status_code == 404:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Error])
                res.error = out

        return res

    def delete_continuous_project(self, request: operations.DeleteContinuousProjectRequest) -> operations.DeleteContinuousProjectResponse:
        r"""Delete a continuous project
        Delete an existing continuous project. Your project will be cancelled, and you will still be charged for the amount of translations we have done for you so far.
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.DeleteContinuousProjectRequest, base_url, '/continuous_projects/{id}', request)
        
        
        client = self._security_client
        
        http_res = client.request('DELETE', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DeleteContinuousProjectResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.OperationStatus])
                res.operation_status = out
        elif http_res.status_code == 404:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Error])
                res.error = out

        return res

    def delete_subscription(self, request: operations.DeleteSubscriptionRequest) -> operations.DeleteSubscriptionResponse:
        r"""Delete subscription for continuous project
        Delete subscription for continuous project
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.DeleteSubscriptionRequest, base_url, '/continuous_projects/{id}/subscription', request)
        
        
        client = self._security_client
        
        http_res = client.request('DELETE', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DeleteSubscriptionResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Subscription])
                res.subscription = out
        elif http_res.status_code in [400, 404]:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Error])
                res.error = out

        return res

    def get_active_widget(self, request: operations.GetActiveWidgetRequest) -> operations.GetActiveWidgetResponse:
        r"""View an Active widget
        View the details of an Active widget to be used in your website. Most website-specific configuration is provided via widgets.
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.GetActiveWidgetRequest, base_url, '/continuous_projects/{projectId}/widgets/{widgetId}', request)
        
        
        client = self._security_client
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetActiveWidgetResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ActiveWidget])
                res.active_widget = out
        elif http_res.status_code == 404:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Error])
                res.error = out

        return res

    def get_active_widgets(self, request: operations.GetActiveWidgetsRequest) -> operations.GetActiveWidgetsResponse:
        r"""View Active widgets
        View a list of widgets in your Active project to be used in your website. Most website-specific configuration is provided via widgets.
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.GetActiveWidgetsRequest, base_url, '/continuous_projects/{projectId}/widgets', request)
        
        
        client = self._security_client
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetActiveWidgetsResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ActiveWidgetList])
                res.active_widget_list = out
        elif http_res.status_code == 404:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Error])
                res.error = out

        return res

    def get_analytics_token(self, request: operations.GetAnalyticsTokenRequest) -> operations.GetAnalyticsTokenResponse:
        r"""Get JWT token to be used in analytics dashboards
        Get JWT token to be used in analytics dashboards
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.GetAnalyticsTokenRequest, base_url, '/continuous_projects/{id}/analytics-token', request)
        
        
        client = self._security_client
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetAnalyticsTokenResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.AnalyticsToken])
                res.analytics_token = out

        return res

    def get_continuous_project(self, request: operations.GetContinuousProjectRequest) -> operations.GetContinuousProjectResponse:
        r"""View a continuous project
        View the details of a continuous project.
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.GetContinuousProjectRequest, base_url, '/continuous_projects/{id}', request)
        
        
        client = self._security_client
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetContinuousProjectResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ContinuousProject])
                res.continuous_project = out
        elif http_res.status_code == 404:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Error])
                res.error = out

        return res

    def get_continuous_project_document(self, request: operations.GetContinuousProjectDocumentRequest) -> operations.GetContinuousProjectDocumentResponse:
        r"""View a continuous document
        View the details of a source document in continuous translation project.
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.GetContinuousProjectDocumentRequest, base_url, '/continuous_projects/{projectId}/documents/{documentId}', request)
        
        
        client = self._security_client
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetContinuousProjectDocumentResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ContinuousProjectDocument])
                res.continuous_project_document = out
        elif http_res.status_code == 404:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Error])
                res.error = out

        return res

    def get_continuous_project_document_progress(self, request: operations.GetContinuousProjectDocumentProgressRequest) -> operations.GetContinuousProjectDocumentProgressResponse:
        r"""Monitor progress of a continuous document
        Monitor the translation progress of a document in a continuous project in real-time.
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.GetContinuousProjectDocumentProgressRequest, base_url, '/continuous_projects/{projectId}/documents/{documentId}/progress', request)
        
        query_params = utils.get_query_params(operations.GetContinuousProjectDocumentProgressRequest, request)
        
        client = self._security_client
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetContinuousProjectDocumentProgressResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Progress])
                res.progress = out
        elif http_res.status_code == 404:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Error])
                res.error = out

        return res

    def get_continuous_project_documents(self, request: operations.GetContinuousProjectDocumentsRequest) -> operations.GetContinuousProjectDocumentsResponse:
        r"""View continuous documents
        View the documents under this continuous project
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.GetContinuousProjectDocumentsRequest, base_url, '/continuous_projects/{projectId}/documents', request)
        
        query_params = utils.get_query_params(operations.GetContinuousProjectDocumentsRequest, request)
        
        client = self._security_client
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetContinuousProjectDocumentsResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ContinuousProjectDocumentList])
                res.continuous_project_document_list = out
        elif http_res.status_code == 404:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Error])
                res.error = out

        return res

    def get_continuous_project_invoices(self, request: operations.GetContinuousProjectInvoicesRequest) -> operations.GetContinuousProjectInvoicesResponse:
        r"""Invoices of a continuous project
        Get real-time access to a continuous project's invoices.
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.GetContinuousProjectInvoicesRequest, base_url, '/continuous_projects/{projectId}/invoices', request)
        
        
        client = self._security_client
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetContinuousProjectInvoicesResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ContinuousProjectInvoices])
                res.continuous_project_invoices = out
        elif http_res.status_code == 404:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Error])
                res.error = out

        return res

    def get_continuous_project_progress(self, request: operations.GetContinuousProjectProgressRequest) -> operations.GetContinuousProjectProgressResponse:
        r"""Monitor progress and status of a continous project
        Monitor the translation progress of an ongoing continuous project in real-time.
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.GetContinuousProjectProgressRequest, base_url, '/continuous_projects/{projectId}/progress', request)
        
        query_params = utils.get_query_params(operations.GetContinuousProjectProgressRequest, request)
        
        client = self._security_client
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetContinuousProjectProgressResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ContinuousProjectProgress])
                res.continuous_project_progress = out
        elif http_res.status_code == 404:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Error])
                res.error = out

        return res

    def get_continuous_projects(self, request: operations.GetContinuousProjectsRequest) -> operations.GetContinuousProjectsResponse:
        r"""View continuous projects
        View a list of continuous projects under your account. Continuous projects are those that are constantly updated, such as a CI/CD project, software project, website translation and such.
        """
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/continuous_projects'
        
        query_params = utils.get_query_params(operations.GetContinuousProjectsRequest, request)
        
        client = self._security_client
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetContinuousProjectsResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ContinuousProjectsList])
                res.continuous_projects_list = out

        return res

    def get_quote_for_document(self, request: operations.GetQuoteForDocumentRequest) -> operations.GetQuoteForDocumentResponse:
        r"""Get a quote for a continuous project document
        Get a new quote for provided document in continuous project. Per your project settings, a continuous project document can be target language-specific or project-wide for all target languages of the project.
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.GetQuoteForDocumentRequest, base_url, '/continuous_projects/{id}/documents/{documentId}/quote', request)
        
        
        client = self._security_client
        
        http_res = client.request('POST', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetQuoteForDocumentResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ProjectList])
                res.project_list = out
        elif http_res.status_code in [400, 405, 406, 500]:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Error])
                res.error = out

        return res

    def get_quote_for_documents(self, request: operations.GetQuoteForDocumentsRequest) -> operations.GetQuoteForDocumentsResponse:
        r"""Get quote for documents
        Get a new quote for provided documents in continuous project
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.GetQuoteForDocumentsRequest, base_url, '/continuous_projects/{id}/documents/quote', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "get_quotes_for_documents_body", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        
        client = self._security_client
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetQuoteForDocumentsResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ProjectList])
                res.project_list = out
        elif http_res.status_code in [400, 405, 406, 500]:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Error])
                res.error = out

        return res

    def get_quote_for_language(self, request: operations.GetQuoteForLanguageRequest) -> operations.GetQuoteForLanguageResponse:
        r"""Get quote for language
        Get a new quote for provided target language in continuous project
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.GetQuoteForLanguageRequest, base_url, '/continuous_projects/{id}/languages/{targetLanguage}/quote', request)
        
        
        client = self._security_client
        
        http_res = client.request('POST', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetQuoteForLanguageResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ProjectList])
                res.project_list = out
        elif http_res.status_code in [400, 405, 406, 500]:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Error])
                res.error = out

        return res

    def get_quote_for_languages(self, request: operations.GetQuoteForLanguagesRequest) -> operations.GetQuoteForLanguagesResponse:
        r"""Get quote for languages
        Get a new quote for provided target languages in continuous project
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.GetQuoteForLanguagesRequest, base_url, '/continuous_projects/{id}/languages/quote', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "get_quotes_for_languages_body", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        
        client = self._security_client
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetQuoteForLanguagesResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ProjectList])
                res.project_list = out
        elif http_res.status_code in [400, 405, 406, 500]:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Error])
                res.error = out

        return res

    def get_subscription(self, request: operations.GetSubscriptionRequest) -> operations.GetSubscriptionResponse:
        r"""Get subscription for continuous project
        Get subscription for continuous project
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.GetSubscriptionRequest, base_url, '/continuous_projects/{id}/subscription', request)
        
        
        client = self._security_client
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetSubscriptionResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Subscription])
                res.subscription = out
        elif http_res.status_code in [400, 404]:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Error])
                res.error = out

        return res

    def post_continuous_project_document_progress(self, request: operations.PostContinuousProjectDocumentProgressRequest) -> operations.PostContinuousProjectDocumentProgressResponse:
        r"""Get continuous project document progress for multiple IDs
        Get continuous project document progress for multiple IDs
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.PostContinuousProjectDocumentProgressRequest, base_url, '/continuous_projects/{projectId}/documents/progress', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "continuous_project_document_progress_body", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        
        client = self._security_client
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.PostContinuousProjectDocumentProgressResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Progress])
                res.progress = out
        elif http_res.status_code == 404:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Error])
                res.error = out

        return res

    def reset_active_widget_token(self, request: operations.ResetActiveWidgetTokenRequest) -> operations.ResetActiveWidgetTokenResponse:
        r"""Reset Active widget token
        Reset the public token used with your Active widget. This token is used when communicating from your environment to MotaWord systems for translation, analytics and meta.
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.ResetActiveWidgetTokenRequest, base_url, '/continuous_projects/{projectId}/widgets/{widgetId}/reset-token', request)
        
        
        client = self._security_client
        
        http_res = client.request('POST', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ResetActiveWidgetTokenResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ActiveWidget])
                res.active_widget = out
        elif http_res.status_code == 404:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Error])
                res.error = out

        return res

    def translate(self, request: operations.TranslateRequest) -> operations.TranslateResponse:
        r"""Instantly translate your content
        Instantly translate your content with your existing TM and MT resources. This is the primary endpoint to translate your files and content on the fly, especially in CI/CD environments. This is a complex endpoint that is configured in your Active or Continuous Project dashboards. For instance, you can configure whether to use your TM, or translate missing strings via MT and then post-edit those new translations. There are various scenarios you can establish via a set of configurations.
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.TranslateRequest, base_url, '/continuous_projects/{id}/translate/{targetLanguage}', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "instant_translation_request", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        
        client = self._security_client
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.TranslateResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.instant_translation_result = out

        return res

    def update_active_widget(self, request: operations.UpdateActiveWidgetRequest) -> operations.UpdateActiveWidgetResponse:
        r"""Update Active widget settings.
        Update Active widget settings.
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.UpdateActiveWidgetRequest, base_url, '/continuous_projects/{projectId}/widgets/{widgetId}', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "active_widget", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        
        client = self._security_client
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.UpdateActiveWidgetResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ActiveWidget])
                res.active_widget = out
        elif http_res.status_code == 404:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Error])
                res.error = out

        return res

    def update_continuous_project(self, request: operations.UpdateContinuousProjectRequest) -> operations.UpdateContinuousProjectResponse:
        r"""Update a continuous project
        Update the details and settings of continuous project.
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.UpdateContinuousProjectRequest, base_url, '/continuous_projects/{id}', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "continuous_project_update_content", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        
        client = self._security_client
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.UpdateContinuousProjectResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ContinuousProject])
                res.continuous_project = out
        elif http_res.status_code == 404:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Error])
                res.error = out

        return res

    def update_document(self, request: operations.UpdateDocumentRequest) -> operations.UpdateDocumentResponse:
        r"""Update the document
        Update source document in your continuous project. In most scenarios, this operation will also trigger auto-translation of your document, via MT and/or TM.
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.UpdateDocumentRequest, base_url, '/continuous_projects/{projectId}/documents/{documentId}', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "add_or_update_document_request", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        
        client = self._security_client
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.UpdateDocumentResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ContinuousProjectDocument])
                res.continuous_project_document = out

        return res

    def update_subscription(self, request: operations.UpdateSubscriptionRequest) -> operations.UpdateSubscriptionResponse:
        r"""Update subscription for continuous project
        Update subscription for continuous project
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.UpdateSubscriptionRequest, base_url, '/continuous_projects/{id}/subscription', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "subscription", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = self._security_client
        
        http_res = client.request('PUT', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.UpdateSubscriptionResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Subscription])
                res.subscription = out
        elif http_res.status_code in [400, 404]:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Error])
                res.error = out

        return res

    def update_subscription_payment_method(self, request: operations.UpdateSubscriptionPaymentMethodRequest) -> operations.UpdateSubscriptionPaymentMethodResponse:
        r"""Update subscription payment method for continuous project
        Update subscription payment method for continuous project
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.UpdateSubscriptionPaymentMethodRequest, base_url, '/continuous_projects/{id}/subscription/payment', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "subscription", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = self._security_client
        
        http_res = client.request('PUT', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.UpdateSubscriptionPaymentMethodResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Subscription])
                res.subscription = out
        elif http_res.status_code in [400, 404]:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Error])
                res.error = out

        return res

    