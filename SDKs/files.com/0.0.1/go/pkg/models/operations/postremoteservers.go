// Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.

package operations

import (
	"encoding/json"
	"fmt"
	"net/http"
	"openapi/pkg/models/shared"
)

// PostRemoteServersRequestBodyFilesAgentPermissionSetEnum - Local permissions for files agent. read_only, write_only, or read_write
type PostRemoteServersRequestBodyFilesAgentPermissionSetEnum string

const (
	PostRemoteServersRequestBodyFilesAgentPermissionSetEnumReadWrite PostRemoteServersRequestBodyFilesAgentPermissionSetEnum = "read_write"
	PostRemoteServersRequestBodyFilesAgentPermissionSetEnumReadOnly  PostRemoteServersRequestBodyFilesAgentPermissionSetEnum = "read_only"
	PostRemoteServersRequestBodyFilesAgentPermissionSetEnumWriteOnly PostRemoteServersRequestBodyFilesAgentPermissionSetEnum = "write_only"
)

func (e *PostRemoteServersRequestBodyFilesAgentPermissionSetEnum) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return err
	}
	switch s {
	case "read_write":
		fallthrough
	case "read_only":
		fallthrough
	case "write_only":
		*e = PostRemoteServersRequestBodyFilesAgentPermissionSetEnum(s)
		return nil
	default:
		return fmt.Errorf("invalid value for PostRemoteServersRequestBodyFilesAgentPermissionSetEnum: %s", s)
	}
}

// PostRemoteServersRequestBodyOneDriveAccountTypeEnum - Either personal or business_other account types
type PostRemoteServersRequestBodyOneDriveAccountTypeEnum string

const (
	PostRemoteServersRequestBodyOneDriveAccountTypeEnumPersonal      PostRemoteServersRequestBodyOneDriveAccountTypeEnum = "personal"
	PostRemoteServersRequestBodyOneDriveAccountTypeEnumBusinessOther PostRemoteServersRequestBodyOneDriveAccountTypeEnum = "business_other"
)

func (e *PostRemoteServersRequestBodyOneDriveAccountTypeEnum) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return err
	}
	switch s {
	case "personal":
		fallthrough
	case "business_other":
		*e = PostRemoteServersRequestBodyOneDriveAccountTypeEnum(s)
		return nil
	default:
		return fmt.Errorf("invalid value for PostRemoteServersRequestBodyOneDriveAccountTypeEnum: %s", s)
	}
}

// PostRemoteServersRequestBodyServerCertificateEnum - Remote server certificate
type PostRemoteServersRequestBodyServerCertificateEnum string

const (
	PostRemoteServersRequestBodyServerCertificateEnumRequireMatch PostRemoteServersRequestBodyServerCertificateEnum = "require_match"
	PostRemoteServersRequestBodyServerCertificateEnumAllowAny     PostRemoteServersRequestBodyServerCertificateEnum = "allow_any"
)

func (e *PostRemoteServersRequestBodyServerCertificateEnum) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return err
	}
	switch s {
	case "require_match":
		fallthrough
	case "allow_any":
		*e = PostRemoteServersRequestBodyServerCertificateEnum(s)
		return nil
	default:
		return fmt.Errorf("invalid value for PostRemoteServersRequestBodyServerCertificateEnum: %s", s)
	}
}

// PostRemoteServersRequestBodyServerTypeEnum - Remote server type.
type PostRemoteServersRequestBodyServerTypeEnum string

const (
	PostRemoteServersRequestBodyServerTypeEnumFtp                PostRemoteServersRequestBodyServerTypeEnum = "ftp"
	PostRemoteServersRequestBodyServerTypeEnumSftp               PostRemoteServersRequestBodyServerTypeEnum = "sftp"
	PostRemoteServersRequestBodyServerTypeEnumS3                 PostRemoteServersRequestBodyServerTypeEnum = "s3"
	PostRemoteServersRequestBodyServerTypeEnumGoogleCloudStorage PostRemoteServersRequestBodyServerTypeEnum = "google_cloud_storage"
	PostRemoteServersRequestBodyServerTypeEnumWebdav             PostRemoteServersRequestBodyServerTypeEnum = "webdav"
	PostRemoteServersRequestBodyServerTypeEnumWasabi             PostRemoteServersRequestBodyServerTypeEnum = "wasabi"
	PostRemoteServersRequestBodyServerTypeEnumBackblazeB2        PostRemoteServersRequestBodyServerTypeEnum = "backblaze_b2"
	PostRemoteServersRequestBodyServerTypeEnumOneDrive           PostRemoteServersRequestBodyServerTypeEnum = "one_drive"
	PostRemoteServersRequestBodyServerTypeEnumRackspace          PostRemoteServersRequestBodyServerTypeEnum = "rackspace"
	PostRemoteServersRequestBodyServerTypeEnumBox                PostRemoteServersRequestBodyServerTypeEnum = "box"
	PostRemoteServersRequestBodyServerTypeEnumDropbox            PostRemoteServersRequestBodyServerTypeEnum = "dropbox"
	PostRemoteServersRequestBodyServerTypeEnumGoogleDrive        PostRemoteServersRequestBodyServerTypeEnum = "google_drive"
	PostRemoteServersRequestBodyServerTypeEnumAzure              PostRemoteServersRequestBodyServerTypeEnum = "azure"
	PostRemoteServersRequestBodyServerTypeEnumSharepoint         PostRemoteServersRequestBodyServerTypeEnum = "sharepoint"
	PostRemoteServersRequestBodyServerTypeEnumS3Compatible       PostRemoteServersRequestBodyServerTypeEnum = "s3_compatible"
	PostRemoteServersRequestBodyServerTypeEnumAzureFiles         PostRemoteServersRequestBodyServerTypeEnum = "azure_files"
	PostRemoteServersRequestBodyServerTypeEnumFilesAgent         PostRemoteServersRequestBodyServerTypeEnum = "files_agent"
	PostRemoteServersRequestBodyServerTypeEnumFilebase           PostRemoteServersRequestBodyServerTypeEnum = "filebase"
)

func (e *PostRemoteServersRequestBodyServerTypeEnum) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return err
	}
	switch s {
	case "ftp":
		fallthrough
	case "sftp":
		fallthrough
	case "s3":
		fallthrough
	case "google_cloud_storage":
		fallthrough
	case "webdav":
		fallthrough
	case "wasabi":
		fallthrough
	case "backblaze_b2":
		fallthrough
	case "one_drive":
		fallthrough
	case "rackspace":
		fallthrough
	case "box":
		fallthrough
	case "dropbox":
		fallthrough
	case "google_drive":
		fallthrough
	case "azure":
		fallthrough
	case "sharepoint":
		fallthrough
	case "s3_compatible":
		fallthrough
	case "azure_files":
		fallthrough
	case "files_agent":
		fallthrough
	case "filebase":
		*e = PostRemoteServersRequestBodyServerTypeEnum(s)
		return nil
	default:
		return fmt.Errorf("invalid value for PostRemoteServersRequestBodyServerTypeEnum: %s", s)
	}
}

// PostRemoteServersRequestBodySslEnum - Should we require SSL?
type PostRemoteServersRequestBodySslEnum string

const (
	PostRemoteServersRequestBodySslEnumIfAvailable     PostRemoteServersRequestBodySslEnum = "if_available"
	PostRemoteServersRequestBodySslEnumRequire         PostRemoteServersRequestBodySslEnum = "require"
	PostRemoteServersRequestBodySslEnumRequireImplicit PostRemoteServersRequestBodySslEnum = "require_implicit"
	PostRemoteServersRequestBodySslEnumNever           PostRemoteServersRequestBodySslEnum = "never"
)

func (e *PostRemoteServersRequestBodySslEnum) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return err
	}
	switch s {
	case "if_available":
		fallthrough
	case "require":
		fallthrough
	case "require_implicit":
		fallthrough
	case "never":
		*e = PostRemoteServersRequestBodySslEnum(s)
		return nil
	default:
		return fmt.Errorf("invalid value for PostRemoteServersRequestBodySslEnum: %s", s)
	}
}

type PostRemoteServersRequestBody struct {
	// AWS Access Key.
	AwsAccessKey *string `multipartForm:"name=aws_access_key"`
	// AWS secret key.
	AwsSecretKey *string `multipartForm:"name=aws_secret_key"`
	// Azure Blob Storage secret key.
	AzureBlobStorageAccessKey *string `multipartForm:"name=azure_blob_storage_access_key"`
	// Azure Blob Storage Account name
	AzureBlobStorageAccount *string `multipartForm:"name=azure_blob_storage_account"`
	// Azure Blob Storage Container name
	AzureBlobStorageContainer *string `multipartForm:"name=azure_blob_storage_container"`
	// Shared Access Signature (SAS) token
	AzureBlobStorageSasToken *string `multipartForm:"name=azure_blob_storage_sas_token"`
	// Azure File Storage access key.
	AzureFilesStorageAccessKey *string `multipartForm:"name=azure_files_storage_access_key"`
	// Azure File Storage Account name
	AzureFilesStorageAccount *string `multipartForm:"name=azure_files_storage_account"`
	// Shared Access Signature (SAS) token
	AzureFilesStorageSasToken *string `multipartForm:"name=azure_files_storage_sas_token"`
	// Azure File Storage Share name
	AzureFilesStorageShareName *string `multipartForm:"name=azure_files_storage_share_name"`
	// Backblaze B2 Cloud Storage applicationKey.
	BackblazeB2ApplicationKey *string `multipartForm:"name=backblaze_b2_application_key"`
	// Backblaze B2 Cloud Storage Bucket name
	BackblazeB2Bucket *string `multipartForm:"name=backblaze_b2_bucket"`
	// Backblaze B2 Cloud Storage keyID.
	BackblazeB2KeyID *string `multipartForm:"name=backblaze_b2_key_id"`
	// Backblaze B2 Cloud Storage S3 Endpoint
	BackblazeB2S3Endpoint *string `multipartForm:"name=backblaze_b2_s3_endpoint"`
	// `true` if remote server only accepts connections from dedicated IPs
	EnableDedicatedIps *bool `multipartForm:"name=enable_dedicated_ips"`
	// Filebase Access Key.
	FilebaseAccessKey *string `multipartForm:"name=filebase_access_key"`
	// Filebase Bucket name
	FilebaseBucket *string `multipartForm:"name=filebase_bucket"`
	// Filebase secret key
	FilebaseSecretKey *string `multipartForm:"name=filebase_secret_key"`
	// Local permissions for files agent. read_only, write_only, or read_write
	FilesAgentPermissionSet *PostRemoteServersRequestBodyFilesAgentPermissionSetEnum `multipartForm:"name=files_agent_permission_set"`
	// Agent local root path
	FilesAgentRoot *string `multipartForm:"name=files_agent_root"`
	// Google Cloud Storage bucket name
	GoogleCloudStorageBucket *string `multipartForm:"name=google_cloud_storage_bucket"`
	// A JSON file that contains the private key. To generate see https://cloud.google.com/storage/docs/json_api/v1/how-tos/authorizing#APIKey
	GoogleCloudStorageCredentialsJSON *string `multipartForm:"name=google_cloud_storage_credentials_json"`
	// Google Cloud Project ID
	GoogleCloudStorageProjectID *string `multipartForm:"name=google_cloud_storage_project_id"`
	// Hostname or IP address
	Hostname *string `multipartForm:"name=hostname"`
	// Max number of parallel connections.  Ignored for S3 connections (we will parallelize these as much as possible).
	MaxConnections *int `multipartForm:"name=max_connections"`
	// Internal name for your reference
	Name *string `multipartForm:"name=name"`
	// Either personal or business_other account types
	OneDriveAccountType *PostRemoteServersRequestBodyOneDriveAccountTypeEnum `multipartForm:"name=one_drive_account_type"`
	// Password if needed.
	Password *string `multipartForm:"name=password"`
	// If true, we will ensure that all communications with this remote server are made through the primary region of the site.  This setting can also be overridden by a sitewide setting which will force it to true.
	PinToSiteRegion *bool `multipartForm:"name=pin_to_site_region"`
	// Port for remote server.  Not needed for S3.
	Port *int `multipartForm:"name=port"`
	// Private key if needed.
	PrivateKey *string `multipartForm:"name=private_key"`
	// Passphrase for private key if needed.
	PrivateKeyPassphrase *string `multipartForm:"name=private_key_passphrase"`
	// Rackspace API key from the Rackspace Cloud Control Panel.
	RackspaceAPIKey *string `multipartForm:"name=rackspace_api_key"`
	// The name of the container (top level directory) where files will sync.
	RackspaceContainer *string `multipartForm:"name=rackspace_container"`
	// Three letter airport code for Rackspace region. See https://support.rackspace.com/how-to/about-regions/
	RackspaceRegion *string `multipartForm:"name=rackspace_region"`
	// Rackspace username used to login to the Rackspace Cloud Control Panel.
	RackspaceUsername *string `multipartForm:"name=rackspace_username"`
	// Reset authenticated account
	ResetAuthentication *bool `multipartForm:"name=reset_authentication"`
	// S3 bucket name
	S3Bucket *string `multipartForm:"name=s3_bucket"`
	// S3-compatible Access Key.
	S3CompatibleAccessKey *string `multipartForm:"name=s3_compatible_access_key"`
	// S3-compatible Bucket name
	S3CompatibleBucket *string `multipartForm:"name=s3_compatible_bucket"`
	// S3-compatible endpoint
	S3CompatibleEndpoint *string `multipartForm:"name=s3_compatible_endpoint"`
	// S3-compatible endpoint
	S3CompatibleRegion *string `multipartForm:"name=s3_compatible_region"`
	// S3-compatible secret key
	S3CompatibleSecretKey *string `multipartForm:"name=s3_compatible_secret_key"`
	// S3 region
	S3Region *string `multipartForm:"name=s3_region"`
	// Remote server certificate
	ServerCertificate *PostRemoteServersRequestBodyServerCertificateEnum `multipartForm:"name=server_certificate"`
	// Remote server SSH Host Key. If provided, we will require that the server host key matches the provided key. Uses OpenSSH format similar to what would go into ~/.ssh/known_hosts
	ServerHostKey *string `multipartForm:"name=server_host_key"`
	// Remote server type.
	ServerType *PostRemoteServersRequestBodyServerTypeEnum `multipartForm:"name=server_type"`
	// Should we require SSL?
	Ssl *PostRemoteServersRequestBodySslEnum `multipartForm:"name=ssl"`
	// SSL client certificate.
	SslCertificate *string `multipartForm:"name=ssl_certificate"`
	// Remote server username.  Not needed for S3 buckets.
	Username *string `multipartForm:"name=username"`
	// Wasabi access key.
	WasabiAccessKey *string `multipartForm:"name=wasabi_access_key"`
	// Wasabi Bucket name
	WasabiBucket *string `multipartForm:"name=wasabi_bucket"`
	// Wasabi region
	WasabiRegion *string `multipartForm:"name=wasabi_region"`
	// Wasabi secret key.
	WasabiSecretKey *string `multipartForm:"name=wasabi_secret_key"`
}

type PostRemoteServersResponse struct {
	ContentType string
	// The RemoteServers object.
	RemoteServerEntity *shared.RemoteServerEntity
	StatusCode         int
	RawResponse        *http.Response
}
