"""Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT."""

from __future__ import annotations
import dataclasses
from ..shared import dataexecutionstatus as shared_dataexecutionstatus
from ..shared import gridrange as shared_gridrange
from ..shared import pivotfiltercriteria as shared_pivotfiltercriteria
from ..shared import pivotfilterspec as shared_pivotfilterspec
from ..shared import pivotgroup as shared_pivotgroup
from ..shared import pivotvalue as shared_pivotvalue
from dataclasses_json import Undefined, dataclass_json
from enum import Enum
from sdk import utils
from typing import Optional

class PivotTableValueLayoutEnum(str, Enum):
    r"""Whether values should be listed horizontally (as columns) or vertically (as rows)."""
    HORIZONTAL = 'HORIZONTAL'
    VERTICAL = 'VERTICAL'


@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class PivotTable:
    r"""A pivot table."""
    
    columns: Optional[list[shared_pivotgroup.PivotGroup]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('columns'), 'exclude': lambda f: f is None }})
    r"""Each column grouping in the pivot table."""  
    criteria: Optional[dict[str, shared_pivotfiltercriteria.PivotFilterCriteria]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('criteria'), 'exclude': lambda f: f is None }})
    r"""An optional mapping of filters per source column offset. The filters are applied before aggregating data into the pivot table. The map's key is the column offset of the source range that you want to filter, and the value is the criteria for that column. For example, if the source was `C10:E15`, a key of `0` will have the filter for column `C`, whereas the key `1` is for column `D`. This field is deprecated in favor of filter_specs."""  
    data_execution_status: Optional[shared_dataexecutionstatus.DataExecutionStatus] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('dataExecutionStatus'), 'exclude': lambda f: f is None }})
    r"""The data execution status. A data execution is created to sync a data source object with the latest data from a DataSource. It is usually scheduled to run at background, you can check its state to tell if an execution completes There are several scenarios where a data execution is triggered to run: * Adding a data source creates an associated data source sheet as well as a data execution to sync the data from the data source to the sheet. * Updating a data source creates a data execution to refresh the associated data source sheet similarly. * You can send refresh request to explicitly refresh one or multiple data source objects."""  
    data_source_id: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('dataSourceId'), 'exclude': lambda f: f is None }})
    r"""The ID of the data source the pivot table is reading data from."""  
    filter_specs: Optional[list[shared_pivotfilterspec.PivotFilterSpec]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('filterSpecs'), 'exclude': lambda f: f is None }})
    r"""The filters applied to the source columns before aggregating data for the pivot table. Both criteria and filter_specs are populated in responses. If both fields are specified in an update request, this field takes precedence."""  
    rows: Optional[list[shared_pivotgroup.PivotGroup]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('rows'), 'exclude': lambda f: f is None }})
    r"""Each row grouping in the pivot table."""  
    source: Optional[shared_gridrange.GridRange] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('source'), 'exclude': lambda f: f is None }})
    r"""A range on a sheet. All indexes are zero-based. Indexes are half open, i.e. the start index is inclusive and the end index is exclusive -- [start_index, end_index). Missing indexes indicate the range is unbounded on that side. For example, if `\\"Sheet1\\"` is sheet ID 123456, then: `Sheet1!A1:A1 == sheet_id: 123456, start_row_index: 0, end_row_index: 1, start_column_index: 0, end_column_index: 1` `Sheet1!A3:B4 == sheet_id: 123456, start_row_index: 2, end_row_index: 4, start_column_index: 0, end_column_index: 2` `Sheet1!A:B == sheet_id: 123456, start_column_index: 0, end_column_index: 2` `Sheet1!A5:B == sheet_id: 123456, start_row_index: 4, start_column_index: 0, end_column_index: 2` `Sheet1 == sheet_id: 123456` The start index must always be less than or equal to the end index. If the start index equals the end index, then the range is empty. Empty ranges are typically not meaningful and are usually rendered in the UI as `#REF!`."""  
    value_layout: Optional[PivotTableValueLayoutEnum] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('valueLayout'), 'exclude': lambda f: f is None }})
    r"""Whether values should be listed horizontally (as columns) or vertically (as rows)."""  
    values: Optional[list[shared_pivotvalue.PivotValue]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('values'), 'exclude': lambda f: f is None }})
    r"""A list of values to include in the pivot table."""  
    