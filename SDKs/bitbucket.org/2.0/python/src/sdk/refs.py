"""Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT."""

import requests as requests_http
from . import utils
from sdk.models import operations, shared
from typing import Any, Optional

class Refs:
    r"""The refs resource allows you access branches and tags in a repository.
    By default, results will be in the order the underlying source control
    system returns them and identical to the ordering one sees when running
    \"$ git show-ref\". Note that this follows simple lexical ordering of the
     ref names.
    """
    _client: requests_http.Session
    _security_client: requests_http.Session
    _server_url: str
    _language: str
    _sdk_version: str
    _gen_version: str

    def __init__(self, client: requests_http.Session, security_client: requests_http.Session, server_url: str, language: str, sdk_version: str, gen_version: str) -> None:
        self._client = client
        self._security_client = security_client
        self._server_url = server_url
        self._language = language
        self._sdk_version = sdk_version
        self._gen_version = gen_version
        
    def delete_repositories_workspace_repo_slug_refs_branches_name_(self, request: operations.DeleteRepositoriesWorkspaceRepoSlugRefsBranchesNameRequest, security: operations.DeleteRepositoriesWorkspaceRepoSlugRefsBranchesNameSecurity) -> operations.DeleteRepositoriesWorkspaceRepoSlugRefsBranchesNameResponse:
        r"""Delete a branch
        Delete a branch in the specified repository.
        
        The main branch is not allowed to be deleted and will return a 400
        response.
        
        The branch name should not include any prefixes (e.g.
        refs/heads).
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.DeleteRepositoriesWorkspaceRepoSlugRefsBranchesNameRequest, base_url, '/repositories/{workspace}/{repo_slug}/refs/branches/{name}', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('DELETE', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DeleteRepositoriesWorkspaceRepoSlugRefsBranchesNameResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 204:
            pass
        elif http_res.status_code in [403, 404]:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[dict[str, Any]])
                res.error = out

        return res

    def delete_repositories_workspace_repo_slug_refs_tags_name_(self, request: operations.DeleteRepositoriesWorkspaceRepoSlugRefsTagsNameRequest, security: operations.DeleteRepositoriesWorkspaceRepoSlugRefsTagsNameSecurity) -> operations.DeleteRepositoriesWorkspaceRepoSlugRefsTagsNameResponse:
        r"""Delete a tag
        Delete a tag in the specified repository.
        
        The tag name should not include any prefixes (e.g. refs/tags).
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.DeleteRepositoriesWorkspaceRepoSlugRefsTagsNameRequest, base_url, '/repositories/{workspace}/{repo_slug}/refs/tags/{name}', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('DELETE', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DeleteRepositoriesWorkspaceRepoSlugRefsTagsNameResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 204:
            pass
        elif http_res.status_code in [403, 404]:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[dict[str, Any]])
                res.error = out

        return res

    def get_repositories_workspace_repo_slug_refs(self, request: operations.GetRepositoriesWorkspaceRepoSlugRefsRequest, security: operations.GetRepositoriesWorkspaceRepoSlugRefsSecurity) -> operations.GetRepositoriesWorkspaceRepoSlugRefsResponse:
        r"""List branches and tags
        Returns the branches and tags in the repository.
        
        By default, results will be in the order the underlying source control system returns them and identical to
        the ordering one sees when running \"$ git show-ref\". Note that this follows simple
        lexical ordering of the ref names.
        
        This can be undesirable as it does apply any natural sorting semantics, meaning for instance that refs are
        sorted [\"branch1\", \"branch10\", \"branch2\", \"v10\", \"v11\", \"v9\"] instead of [\"branch1\", \"branch2\",
        \"branch10\", \"v9\", \"v10\", \"v11\"].
        
        Sorting can be changed using the ?sort= query parameter. When using ?sort=name to explicitly sort on ref name,
        Bitbucket will apply natural sorting and interpret numerical values as numbers instead of strings.
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.GetRepositoriesWorkspaceRepoSlugRefsRequest, base_url, '/repositories/{workspace}/{repo_slug}/refs', request)
        
        query_params = utils.get_query_params(operations.GetRepositoriesWorkspaceRepoSlugRefsRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetRepositoriesWorkspaceRepoSlugRefsResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.PaginatedRefs])
                res.paginated_refs = out
        elif http_res.status_code in [403, 404]:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[dict[str, Any]])
                res.error = out

        return res

    def get_repositories_workspace_repo_slug_refs_branches(self, request: operations.GetRepositoriesWorkspaceRepoSlugRefsBranchesRequest, security: operations.GetRepositoriesWorkspaceRepoSlugRefsBranchesSecurity) -> operations.GetRepositoriesWorkspaceRepoSlugRefsBranchesResponse:
        r"""List open branches
        Returns a list of all open branches within the specified repository.
                Results will be in the order the source control manager returns them.
        
                ```
                $ curl -s https://api.bitbucket.org/2.0/repositories/atlassian/aui/refs/branches?pagelen=1 | jq .
                {
                  \"pagelen\": 1,
                  \"size\": 187,
                  \"values\": [
                    {
                      \"name\": \"issue-9.3/AUI-5343-assistive-class\",
                      \"links\": {
                        \"commits\": {
                          \"href\": \"https://api.bitbucket.org/2.0/repositories/atlassian/aui/commits/issue-9.3/AUI-5343-assistive-class\"
                        },
                        \"self\": {
                          \"href\": \"https://api.bitbucket.org/2.0/repositories/atlassian/aui/refs/branches/issue-9.3/AUI-5343-assistive-class\"
                        },
                        \"html\": {
                          \"href\": \"https://bitbucket.org/atlassian/aui/branch/issue-9.3/AUI-5343-assistive-class\"
                        }
                      },
                      \"default_merge_strategy\": \"squash\",
                      \"merge_strategies\": [
                        \"merge_commit\",
                        \"squash\",
                        \"fast_forward\"
                      ],
                      \"type\": \"branch\",
                      \"target\": {
                        \"hash\": \"e5d1cde9069fcb9f0af90403a4de2150c125a148\",
                        \"repository\": {
                          \"links\": {
                            \"self\": {
                              \"href\": \"https://api.bitbucket.org/2.0/repositories/atlassian/aui\"
                            },
                            \"html\": {
                              \"href\": \"https://bitbucket.org/atlassian/aui\"
                            },
                            \"avatar\": {
                              \"href\": \"https://bytebucket.org/ravatar/%7B585074de-7b60-4fd1-81ed-e0bc7fafbda5%7D?ts=86317\"
                            }
                          },
                          \"type\": \"repository\",
                          \"name\": \"aui\",
                          \"full_name\": \"atlassian/aui\",
                          \"uuid\": \"{585074de-7b60-4fd1-81ed-e0bc7fafbda5}\"
                        },
                        \"links\": {
                          \"self\": {
                            \"href\": \"https://api.bitbucket.org/2.0/repositories/atlassian/aui/commit/e5d1cde9069fcb9f0af90403a4de2150c125a148\"
                          },
                          \"comments\": {
                            \"href\": \"https://api.bitbucket.org/2.0/repositories/atlassian/aui/commit/e5d1cde9069fcb9f0af90403a4de2150c125a148/comments\"
                          },
                          \"patch\": {
                            \"href\": \"https://api.bitbucket.org/2.0/repositories/atlassian/aui/patch/e5d1cde9069fcb9f0af90403a4de2150c125a148\"
                          },
                          \"html\": {
                            \"href\": \"https://bitbucket.org/atlassian/aui/commits/e5d1cde9069fcb9f0af90403a4de2150c125a148\"
                          },
                          \"diff\": {
                            \"href\": \"https://api.bitbucket.org/2.0/repositories/atlassian/aui/diff/e5d1cde9069fcb9f0af90403a4de2150c125a148\"
                          },
                          \"approve\": {
                            \"href\": \"https://api.bitbucket.org/2.0/repositories/atlassian/aui/commit/e5d1cde9069fcb9f0af90403a4de2150c125a148/approve\"
                          },
                          \"statuses\": {
                            \"href\": \"https://api.bitbucket.org/2.0/repositories/atlassian/aui/commit/e5d1cde9069fcb9f0af90403a4de2150c125a148/statuses\"
                          }
                        },
                        \"author\": {
                          \"raw\": \"Marcin Konopka <mkonopka@atlassian.com>\",
                          \"type\": \"author\",
                          \"user\": {
                            \"display_name\": \"Marcin Konopka\",
                            \"uuid\": \"{47cc24f4-2a05-4420-88fe-0417535a110a}\",
                            \"links\": {
                              \"self\": {
                                \"href\": \"https://api.bitbucket.org/2.0/users/%7B47cc24f4-2a05-4420-88fe-0417535a110a%7D\"
                              },
                              \"html\": {
                                \"href\": \"https://bitbucket.org/%7B47cc24f4-2a05-4420-88fe-0417535a110a%7D/\"
                              },
                              \"avatar\": {
                                \"href\": \"https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/initials/MK-1.png\"
                              }
                            },
                            \"nickname\": \"Marcin Konopka\",
                            \"type\": \"user\",
                            \"account_id\": \"60113d2b47a9540069f4de03\"
                          }
                        },
                        \"parents\": [
                          {
                            \"hash\": \"87f7fc92b00464ae47b13ef65c91884e4ac9be51\",
                            \"type\": \"commit\",
                            \"links\": {
                              \"self\": {
                                \"href\": \"https://api.bitbucket.org/2.0/repositories/atlassian/aui/commit/87f7fc92b00464ae47b13ef65c91884e4ac9be51\"
                              },
                              \"html\": {
                                \"href\": \"https://bitbucket.org/atlassian/aui/commits/87f7fc92b00464ae47b13ef65c91884e4ac9be51\"
                              }
                            }
                          }
                        ],
                        \"date\": \"2021-04-13T13:44:49+00:00\",
                        \"message\": \"wip
        \",
                        \"type\": \"commit\"
                      }
                    }
                  ],
                  \"page\": 1,
                  \"next\": \"https://api.bitbucket.org/2.0/repositories/atlassian/aui/refs/branches?pagelen=1&page=2\"
                }
                ```
        
                Branches support [filtering and sorting](/cloud/bitbucket/rest/intro/#filtering)
                that can be used to search for specific branches. For instance, to find
                all branches that have \"stab\" in their name:
        
                ```
                curl -s https://api.bitbucket.org/2.0/repositories/atlassian/aui/refs/branches -G --data-urlencode 'q=name ~ \"stab\"'
                ```
        
                By default, results will be in the order the underlying source control system returns them and identical to
                the ordering one sees when running \"$ git branch --list\". Note that this follows simple
                lexical ordering of the ref names.
        
                This can be undesirable as it does apply any natural sorting semantics, meaning for instance that tags are
                sorted [\"v10\", \"v11\", \"v9\"] instead of [\"v9\", \"v10\", \"v11\"].
        
                Sorting can be changed using the ?q= query parameter. When using ?q=name to explicitly sort on ref name,
                Bitbucket will apply natural sorting and interpret numerical values as numbers instead of strings.
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.GetRepositoriesWorkspaceRepoSlugRefsBranchesRequest, base_url, '/repositories/{workspace}/{repo_slug}/refs/branches', request)
        
        query_params = utils.get_query_params(operations.GetRepositoriesWorkspaceRepoSlugRefsBranchesRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetRepositoriesWorkspaceRepoSlugRefsBranchesResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.PaginatedBranches])
                res.paginated_branches = out
        elif http_res.status_code in [403, 404]:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[dict[str, Any]])
                res.error = out

        return res

    def get_repositories_workspace_repo_slug_refs_branches_name_(self, request: operations.GetRepositoriesWorkspaceRepoSlugRefsBranchesNameRequest, security: operations.GetRepositoriesWorkspaceRepoSlugRefsBranchesNameSecurity) -> operations.GetRepositoriesWorkspaceRepoSlugRefsBranchesNameResponse:
        r"""Get a branch
        Returns a branch object within the specified repository.
        
                ```
                $ curl -s https://api.bitbucket.org/2.0/repositories/atlassian/aui/refs/branches/master | jq .
                {
                  \"name\": \"master\",
                  \"links\": {
                    \"commits\": {
                      \"href\": \"https://api.bitbucket.org/2.0/repositories/atlassian/aui/commits/master\"
                    },
                    \"self\": {
                      \"href\": \"https://api.bitbucket.org/2.0/repositories/atlassian/aui/refs/branches/master\"
                    },
                    \"html\": {
                      \"href\": \"https://bitbucket.org/atlassian/aui/branch/master\"
                    }
                  },
                  \"default_merge_strategy\": \"squash\",
                  \"merge_strategies\": [
                    \"merge_commit\",
                    \"squash\",
                    \"fast_forward\"
                  ],
                  \"type\": \"branch\",
                  \"target\": {
                    \"hash\": \"e7d158ff7ed5538c28f94cd97a9ad569680fc94e\",
                    \"repository\": {
                      \"links\": {
                        \"self\": {
                          \"href\": \"https://api.bitbucket.org/2.0/repositories/atlassian/aui\"
                        },
                        \"html\": {
                          \"href\": \"https://bitbucket.org/atlassian/aui\"
                        },
                        \"avatar\": {
                          \"href\": \"https://bytebucket.org/ravatar/%7B585074de-7b60-4fd1-81ed-e0bc7fafbda5%7D?ts=86317\"
                        }
                      },
                      \"type\": \"repository\",
                      \"name\": \"aui\",
                      \"full_name\": \"atlassian/aui\",
                      \"uuid\": \"{585074de-7b60-4fd1-81ed-e0bc7fafbda5}\"
                    },
                    \"links\": {
                      \"self\": {
                        \"href\": \"https://api.bitbucket.org/2.0/repositories/atlassian/aui/commit/e7d158ff7ed5538c28f94cd97a9ad569680fc94e\"
                      },
                      \"comments\": {
                        \"href\": \"https://api.bitbucket.org/2.0/repositories/atlassian/aui/commit/e7d158ff7ed5538c28f94cd97a9ad569680fc94e/comments\"
                      },
                      \"patch\": {
                        \"href\": \"https://api.bitbucket.org/2.0/repositories/atlassian/aui/patch/e7d158ff7ed5538c28f94cd97a9ad569680fc94e\"
                      },
                      \"html\": {
                        \"href\": \"https://bitbucket.org/atlassian/aui/commits/e7d158ff7ed5538c28f94cd97a9ad569680fc94e\"
                      },
                      \"diff\": {
                        \"href\": \"https://api.bitbucket.org/2.0/repositories/atlassian/aui/diff/e7d158ff7ed5538c28f94cd97a9ad569680fc94e\"
                      },
                      \"approve\": {
                        \"href\": \"https://api.bitbucket.org/2.0/repositories/atlassian/aui/commit/e7d158ff7ed5538c28f94cd97a9ad569680fc94e/approve\"
                      },
                      \"statuses\": {
                        \"href\": \"https://api.bitbucket.org/2.0/repositories/atlassian/aui/commit/e7d158ff7ed5538c28f94cd97a9ad569680fc94e/statuses\"
                      }
                    },
                    \"author\": {
                      \"raw\": \"psre-renovate-bot <psre-renovate-bot@atlassian.com>\",
                      \"type\": \"author\",
                      \"user\": {
                        \"display_name\": \"psre-renovate-bot\",
                        \"uuid\": \"{250a442a-3ab3-4fcb-87c3-3c8f3df65ec7}\",
                        \"links\": {
                          \"self\": {
                            \"href\": \"https://api.bitbucket.org/2.0/users/%7B250a442a-3ab3-4fcb-87c3-3c8f3df65ec7%7D\"
                          },
                          \"html\": {
                            \"href\": \"https://bitbucket.org/%7B250a442a-3ab3-4fcb-87c3-3c8f3df65ec7%7D/\"
                          },
                          \"avatar\": {
                            \"href\": \"https://secure.gravatar.com/avatar/6972ee037c9f36360170a86f544071a2?d=https%3A%2F%2Favatar-management--avatars.us-west-2.prod.public.atl-paas.net%2Finitials%2FP-3.png\"
                          }
                        },
                        \"nickname\": \"Renovate Bot\",
                        \"type\": \"user\",
                        \"account_id\": \"5d5355e8c6b9320d9ea5b28d\"
                      }
                    },
                    \"parents\": [
                      {
                        \"hash\": \"eab868a309e75733de80969a7bed1ec6d4651e06\",
                        \"type\": \"commit\",
                        \"links\": {
                          \"self\": {
                            \"href\": \"https://api.bitbucket.org/2.0/repositories/atlassian/aui/commit/eab868a309e75733de80969a7bed1ec6d4651e06\"
                          },
                          \"html\": {
                            \"href\": \"https://bitbucket.org/atlassian/aui/commits/eab868a309e75733de80969a7bed1ec6d4651e06\"
                          }
                        }
                      }
                    ],
                    \"date\": \"2021-04-12T06:44:38+00:00\",
                    \"message\": \"Merged in issue/NONE-renovate-master-babel-monorepo (pull request #2883)
        
        chore(deps): update babel monorepo to v7.13.15 (master)
        
        Approved-by: Chris \"Daz\" Darroch
        \",
                    \"type\": \"commit\"
                  }
                }
                ```
        
                This call requires authentication. Private repositories require the
                caller to authenticate with an account that has appropriate
                authorization.
        
                For Git, the branch name should not include any prefixes (e.g.
                refs/heads).
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.GetRepositoriesWorkspaceRepoSlugRefsBranchesNameRequest, base_url, '/repositories/{workspace}/{repo_slug}/refs/branches/{name}', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetRepositoriesWorkspaceRepoSlugRefsBranchesNameResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[dict[str, Any]])
                res.branch = out
        elif http_res.status_code in [403, 404]:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[dict[str, Any]])
                res.error = out

        return res

    def get_repositories_workspace_repo_slug_refs_tags(self, request: operations.GetRepositoriesWorkspaceRepoSlugRefsTagsRequest, security: operations.GetRepositoriesWorkspaceRepoSlugRefsTagsSecurity) -> operations.GetRepositoriesWorkspaceRepoSlugRefsTagsResponse:
        r"""List tags
        Returns the tags in the repository.
        
        By default, results will be in the order the underlying source control system returns them and identical to
        the ordering one sees when running \"$ git tag --list\". Note that this follows simple
        lexical ordering of the ref names.
        
        This can be undesirable as it does apply any natural sorting semantics, meaning for instance that tags are
        sorted [\"v10\", \"v11\", \"v9\"] instead of [\"v9\", \"v10\", \"v11\"].
        
        Sorting can be changed using the ?sort= query parameter. When using ?sort=name to explicitly sort on ref name,
        Bitbucket will apply natural sorting and interpret numerical values as numbers instead of strings.
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.GetRepositoriesWorkspaceRepoSlugRefsTagsRequest, base_url, '/repositories/{workspace}/{repo_slug}/refs/tags', request)
        
        query_params = utils.get_query_params(operations.GetRepositoriesWorkspaceRepoSlugRefsTagsRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetRepositoriesWorkspaceRepoSlugRefsTagsResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.PaginatedTags])
                res.paginated_tags = out
        elif http_res.status_code in [403, 404]:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[dict[str, Any]])
                res.error = out

        return res

    def get_repositories_workspace_repo_slug_refs_tags_name_(self, request: operations.GetRepositoriesWorkspaceRepoSlugRefsTagsNameRequest, security: operations.GetRepositoriesWorkspaceRepoSlugRefsTagsNameSecurity) -> operations.GetRepositoriesWorkspaceRepoSlugRefsTagsNameResponse:
        r"""Get a tag
        Returns the specified tag.
        
        ```
        $ curl -s https://api.bitbucket.org/2.0/repositories/seanfarley/hg/refs/tags/3.8 -G | jq .
        {
          \"name\": \"3.8\",
          \"links\": {
            \"commits\": {
              \"href\": \"https://api.bitbucket.org/2.0/repositories/seanfarley/hg/commits/3.8\"
            },
            \"self\": {
              \"href\": \"https://api.bitbucket.org/2.0/repositories/seanfarley/hg/refs/tags/3.8\"
            },
            \"html\": {
              \"href\": \"https://bitbucket.org/seanfarley/hg/commits/tag/3.8\"
            }
          },
          \"tagger\": {
            \"raw\": \"Matt Mackall <mpm@selenic.com>\",
            \"type\": \"author\",
            \"user\": {
              \"username\": \"mpmselenic\",
              \"nickname\": \"mpmselenic\",
              \"display_name\": \"Matt Mackall\",
              \"type\": \"user\",
              \"uuid\": \"{a4934530-db4c-419c-a478-9ab4964c2ee7}\",
              \"links\": {
                \"self\": {
                  \"href\": \"https://api.bitbucket.org/2.0/users/mpmselenic\"
                },
                \"html\": {
                  \"href\": \"https://bitbucket.org/mpmselenic/\"
                },
                \"avatar\": {
                  \"href\": \"https://bitbucket.org/account/mpmselenic/avatar/32/\"
                }
              }
            }
          },
          \"date\": \"2016-05-01T18:52:25+00:00\",
          \"message\": \"Added tag 3.8 for changeset f85de28eae32\",
          \"type\": \"tag\",
          \"target\": {
            \"hash\": \"f85de28eae32e7d3064b1a1321309071bbaaa069\",
            \"repository\": {
              \"links\": {
                \"self\": {
                  \"href\": \"https://api.bitbucket.org/2.0/repositories/seanfarley/hg\"
                },
                \"html\": {
                  \"href\": \"https://bitbucket.org/seanfarley/hg\"
                },
                \"avatar\": {
                  \"href\": \"https://bitbucket.org/seanfarley/hg/avatar/32/\"
                }
              },
              \"type\": \"repository\",
              \"name\": \"hg\",
              \"full_name\": \"seanfarley/hg\",
              \"uuid\": \"{c75687fb-e99d-4579-9087-190dbd406d30}\"
            },
            \"links\": {
              \"self\": {
                \"href\": \"https://api.bitbucket.org/2.0/repositories/seanfarley/hg/commit/f85de28eae32e7d3064b1a1321309071bbaaa069\"
              },
              \"comments\": {
                \"href\": \"https://api.bitbucket.org/2.0/repositories/seanfarley/hg/commit/f85de28eae32e7d3064b1a1321309071bbaaa069/comments\"
              },
              \"patch\": {
                \"href\": \"https://api.bitbucket.org/2.0/repositories/seanfarley/hg/patch/f85de28eae32e7d3064b1a1321309071bbaaa069\"
              },
              \"html\": {
                \"href\": \"https://bitbucket.org/seanfarley/hg/commits/f85de28eae32e7d3064b1a1321309071bbaaa069\"
              },
              \"diff\": {
                \"href\": \"https://api.bitbucket.org/2.0/repositories/seanfarley/hg/diff/f85de28eae32e7d3064b1a1321309071bbaaa069\"
              },
              \"approve\": {
                \"href\": \"https://api.bitbucket.org/2.0/repositories/seanfarley/hg/commit/f85de28eae32e7d3064b1a1321309071bbaaa069/approve\"
              },
              \"statuses\": {
                \"href\": \"https://api.bitbucket.org/2.0/repositories/seanfarley/hg/commit/f85de28eae32e7d3064b1a1321309071bbaaa069/statuses\"
              }
            },
            \"author\": {
              \"raw\": \"Sean Farley <sean@farley.io>\",
              \"type\": \"author\",
              \"user\": {
                \"username\": \"seanfarley\",
                \"nickname\": \"seanfarley\",
                \"display_name\": \"Sean Farley\",
                \"type\": \"user\",
                \"uuid\": \"{a295f8a8-5876-4d43-89b5-3ad8c6c3c51d}\",
                \"links\": {
                  \"self\": {
                    \"href\": \"https://api.bitbucket.org/2.0/users/seanfarley\"
                  },
                  \"html\": {
                    \"href\": \"https://bitbucket.org/seanfarley/\"
                  },
                  \"avatar\": {
                    \"href\": \"https://bitbucket.org/account/seanfarley/avatar/32/\"
                  }
                }
              }
            },
            \"parents\": [
              {
                \"hash\": \"9a98d0e5b07fc60887f9d3d34d9ac7d536f470d2\",
                \"type\": \"commit\",
                \"links\": {
                  \"self\": {
                    \"href\": \"https://api.bitbucket.org/2.0/repositories/seanfarley/hg/commit/9a98d0e5b07fc60887f9d3d34d9ac7d536f470d2\"
                  },
                  \"html\": {
                    \"href\": \"https://bitbucket.org/seanfarley/hg/commits/9a98d0e5b07fc60887f9d3d34d9ac7d536f470d2\"
                  }
                }
              }
            ],
            \"date\": \"2016-05-01T04:21:17+00:00\",
            \"message\": \"debian: alphabetize build deps\",
            \"type\": \"commit\"
          }
        }
        ```
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.GetRepositoriesWorkspaceRepoSlugRefsTagsNameRequest, base_url, '/repositories/{workspace}/{repo_slug}/refs/tags/{name}', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetRepositoriesWorkspaceRepoSlugRefsTagsNameResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[dict[str, Any]])
                res.tag = out
        elif http_res.status_code in [403, 404]:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[dict[str, Any]])
                res.error = out

        return res

    def post_repositories_workspace_repo_slug_refs_branches(self, request: operations.PostRepositoriesWorkspaceRepoSlugRefsBranchesRequest, security: operations.PostRepositoriesWorkspaceRepoSlugRefsBranchesSecurity) -> operations.PostRepositoriesWorkspaceRepoSlugRefsBranchesResponse:
        r"""Create a branch
        Creates a new branch in the specified repository.
        
        The payload of the POST should consist of a JSON document that
        contains the name of the tag and the target hash.
        
        ```
        curl https://api.bitbucket.org/2.0/repositories/seanfarley/hg/refs/branches \
        -s -u seanfarley -X POST -H \"Content-Type: application/json\" \
        -d '{
            \"name\" : \"smf/create-feature\",
            \"target\" : {
                \"hash\" : \"default\",
            }
        }'
        ```
        
        This call requires authentication. Private repositories require the
        caller to authenticate with an account that has appropriate
        authorization.
        
        The branch name should not include any prefixes (e.g.
        refs/heads). This endpoint does support using short hash prefixes for
        the commit hash, but it may return a 400 response if the provided
        prefix is ambiguous. Using a full commit hash is the preferred
        approach.
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.PostRepositoriesWorkspaceRepoSlugRefsBranchesRequest, base_url, '/repositories/{workspace}/{repo_slug}/refs/branches', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.PostRepositoriesWorkspaceRepoSlugRefsBranchesResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 201:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[dict[str, Any]])
                res.branch = out
        elif http_res.status_code in [403, 404]:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[dict[str, Any]])
                res.error = out

        return res

    def post_repositories_workspace_repo_slug_refs_tags(self, request: operations.PostRepositoriesWorkspaceRepoSlugRefsTagsRequest, security: operations.PostRepositoriesWorkspaceRepoSlugRefsTagsSecurity) -> operations.PostRepositoriesWorkspaceRepoSlugRefsTagsResponse:
        r"""Create a tag
        Creates a new tag in the specified repository.
        
        The payload of the POST should consist of a JSON document that
        contains the name of the tag and the target hash.
        
        ```
        curl https://api.bitbucket.org/2.0/repositories/jdoe/myrepo/refs/tags \
        -s -u jdoe -X POST -H \"Content-Type: application/json\" \
        -d '{
            \"name\" : \"new-tag-name\",
            \"target\" : {
                \"hash\" : \"a1b2c3d4e5f6\",
            }
        }'
        ```
        
        This endpoint does support using short hash prefixes for the commit
        hash, but it may return a 400 response if the provided prefix is
        ambiguous. Using a full commit hash is the preferred approach.
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.PostRepositoriesWorkspaceRepoSlugRefsTagsRequest, base_url, '/repositories/{workspace}/{repo_slug}/refs/tags', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.PostRepositoriesWorkspaceRepoSlugRefsTagsResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 201:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[dict[str, Any]])
                res.tag = out
        elif http_res.status_code == 400:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[dict[str, Any]])
                res.error = out

        return res

    