// Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.

package shared

import (
	"encoding/json"
	"fmt"
)

// ProductSearchCorrection - Object with information of misspelled terms.
type ProductSearchCorrection struct {
	// Whether the term is misspelled (`true`) or not (`false`).
	Misspelled *bool `json:"misspelled,omitempty"`
}

// ProductSearchOperatorEnum - Indicates how the search-engine dealt with the fullText when there is more than one word.
//   - `and` - It means that the products contains all the words in the query.
//   - `or` - It means that the results will contain at least one word from the original search query. If `and` was not possible, `or` will be the fallback.
type ProductSearchOperatorEnum string

const (
	ProductSearchOperatorEnumAnd ProductSearchOperatorEnum = "and"
	ProductSearchOperatorEnumOr  ProductSearchOperatorEnum = "or"
)

func (e ProductSearchOperatorEnum) ToPointer() *ProductSearchOperatorEnum {
	return &e
}

func (e *ProductSearchOperatorEnum) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "and":
		fallthrough
	case "or":
		*e = ProductSearchOperatorEnum(v)
		return nil
	default:
		return fmt.Errorf("invalid value for ProductSearchOperatorEnum: %v", v)
	}
}

// ProductSearch - List of products for the given query.
type ProductSearch struct {
	// Object with information of misspelled terms.
	Correction *ProductSearchCorrection `json:"correction,omitempty"`
	// Indicates how the search engine corrected the misspelled word by using fuzzy logic. It can be a number representing the max number of misspelled letters, or the string `auto` suggesting that the search-engine should set this value by itself.
	Fuzzy *string `json:"fuzzy,omitempty"`
	// Indicates how the search-engine dealt with the fullText when there is more than one word.
	//  * `and` - It means that the products contains all the words in the query.
	//  * `or` - It means that the results will contain at least one word from the original search query. If `and` was not possible, `or` will be the fallback.
	Operator *ProductSearchOperatorEnum `json:"operator,omitempty"`
	// List of products
	Products []map[string]interface{} `json:"products,omitempty"`
	// Total number of products.
	RecordsFiltered *float64 `json:"recordsFiltered,omitempty"`
	// Whether the list of products was translated by the IS (`true`) or not (`false`).
	Translated *bool `json:"translated,omitempty"`
}
