/*
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

import * as utils from "../internal/utils";
import * as operations from "./models/operations";
import * as shared from "./models/shared";
import axios from "axios";
import { AxiosInstance, AxiosRequestConfig, AxiosResponse } from "axios";

/**
 * Contains the list of servers available to the SDK
 */
export const ServerList = ["https://messaging.twilio.com"] as const;

/**
 * The available configuration options for the SDK
 */
export type SDKProps = {
  /**
   * Allows overriding the default axios client used by the SDK
   */
  defaultClient?: AxiosInstance;
  /**
   * Allows overriding the default server URL used by the SDK
   */
  serverURL?: string;
};

/**
 * This is the public Twilio REST API.
 */
export class SDK {
  public _defaultClient: AxiosInstance;
  public _securityClient: AxiosInstance;
  public _serverURL: string;
  private _language = "typescript";
  private _sdkVersion = "0.0.1";
  private _genVersion = "internal";
  private _globals: any;

  constructor(props?: SDKProps) {
    this._serverURL = props?.serverURL ?? ServerList[0];

    this._defaultClient =
      props?.defaultClient ?? axios.create({ baseURL: this._serverURL });
    this._securityClient = this._defaultClient;
  }

  createAlphaSender(
    req: operations.CreateAlphaSenderRequest,
    security: operations.CreateAlphaSenderSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.CreateAlphaSenderResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CreateAlphaSenderRequest(req);
    }

    let baseURL: string = operations.CreateAlphaSenderServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v1/Services/{ServiceSid}/AlphaSenders",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "form"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.CreateAlphaSenderSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CreateAlphaSenderResponse =
        new operations.CreateAlphaSenderResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.messagingV1ServiceAlphaSender = utils.objectToClass(
              httpRes?.data,
              shared.MessagingV1ServiceAlphaSender
            );
          }
          break;
      }

      return res;
    });
  }

  createBrandRegistrations(
    req: operations.CreateBrandRegistrationsCreateBrandRegistrationsRequest,
    security: operations.CreateBrandRegistrationsSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.CreateBrandRegistrationsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.CreateBrandRegistrationsCreateBrandRegistrationsRequest(
          req
        );
    }

    let baseURL: string = operations.CreateBrandRegistrationsServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string =
      baseURL.replace(/\/$/, "") + "/v1/a2p/BrandRegistrations";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "request",
        "form"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.CreateBrandRegistrationsSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CreateBrandRegistrationsResponse =
        new operations.CreateBrandRegistrationsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.messagingV1BrandRegistrations = utils.objectToClass(
              httpRes?.data,
              shared.MessagingV1BrandRegistrations
            );
          }
          break;
      }

      return res;
    });
  }

  createBrandVetting(
    req: operations.CreateBrandVettingRequest,
    security: operations.CreateBrandVettingSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.CreateBrandVettingResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CreateBrandVettingRequest(req);
    }

    let baseURL: string = operations.CreateBrandVettingServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v1/a2p/BrandRegistrations/{BrandSid}/Vettings",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "form"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.CreateBrandVettingSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CreateBrandVettingResponse =
        new operations.CreateBrandVettingResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.messagingV1BrandRegistrationsBrandVetting = utils.objectToClass(
              httpRes?.data,
              shared.MessagingV1BrandRegistrationsBrandVetting
            );
          }
          break;
      }

      return res;
    });
  }

  createExternalCampaign(
    req: operations.CreateExternalCampaignCreateExternalCampaignRequest,
    security: operations.CreateExternalCampaignSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.CreateExternalCampaignResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CreateExternalCampaignCreateExternalCampaignRequest(
        req
      );
    }

    let baseURL: string = operations.CreateExternalCampaignServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string =
      baseURL.replace(/\/$/, "") + "/v1/Services/PreregisteredUsa2p";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "request",
        "form"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.CreateExternalCampaignSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CreateExternalCampaignResponse =
        new operations.CreateExternalCampaignResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.messagingV1ExternalCampaign = utils.objectToClass(
              httpRes?.data,
              shared.MessagingV1ExternalCampaign
            );
          }
          break;
      }

      return res;
    });
  }

  createLinkshorteningMessagingService(
    req: operations.CreateLinkshorteningMessagingServiceRequest,
    security: operations.CreateLinkshorteningMessagingServiceSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.CreateLinkshorteningMessagingServiceResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CreateLinkshorteningMessagingServiceRequest(req);
    }

    let baseURL: string =
      operations.CreateLinkshorteningMessagingServiceServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v1/LinkShortening/Domains/{DomainSid}/MessagingServices/{MessagingServiceSid}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.CreateLinkshorteningMessagingServiceSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "post",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CreateLinkshorteningMessagingServiceResponse =
        new operations.CreateLinkshorteningMessagingServiceResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.messagingV1LinkshorteningMessagingService = utils.objectToClass(
              httpRes?.data,
              shared.MessagingV1LinkshorteningMessagingService
            );
          }
          break;
      }

      return res;
    });
  }

  createPhoneNumber(
    req: operations.CreatePhoneNumberRequest,
    security: operations.CreatePhoneNumberSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.CreatePhoneNumberResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CreatePhoneNumberRequest(req);
    }

    let baseURL: string = operations.CreatePhoneNumberServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v1/Services/{ServiceSid}/PhoneNumbers",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "form"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.CreatePhoneNumberSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CreatePhoneNumberResponse =
        new operations.CreatePhoneNumberResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.messagingV1ServicePhoneNumber = utils.objectToClass(
              httpRes?.data,
              shared.MessagingV1ServicePhoneNumber
            );
          }
          break;
      }

      return res;
    });
  }

  createService(
    req: operations.CreateServiceCreateServiceRequest,
    security: operations.CreateServiceSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.CreateServiceResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CreateServiceCreateServiceRequest(req);
    }

    let baseURL: string = operations.CreateServiceServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = baseURL.replace(/\/$/, "") + "/v1/Services";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "request",
        "form"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.CreateServiceSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CreateServiceResponse =
        new operations.CreateServiceResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.messagingV1Service = utils.objectToClass(
              httpRes?.data,
              shared.MessagingV1Service
            );
          }
          break;
      }

      return res;
    });
  }

  createShortCode(
    req: operations.CreateShortCodeRequest,
    security: operations.CreateShortCodeSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.CreateShortCodeResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CreateShortCodeRequest(req);
    }

    let baseURL: string = operations.CreateShortCodeServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v1/Services/{ServiceSid}/ShortCodes",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "form"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.CreateShortCodeSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CreateShortCodeResponse =
        new operations.CreateShortCodeResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.messagingV1ServiceShortCode = utils.objectToClass(
              httpRes?.data,
              shared.MessagingV1ServiceShortCode
            );
          }
          break;
      }

      return res;
    });
  }

  createTollfreeVerification(
    req: operations.CreateTollfreeVerificationCreateTollfreeVerificationRequest,
    security: operations.CreateTollfreeVerificationSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.CreateTollfreeVerificationResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.CreateTollfreeVerificationCreateTollfreeVerificationRequest(
          req
        );
    }

    let baseURL: string = operations.CreateTollfreeVerificationServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string =
      baseURL.replace(/\/$/, "") + "/v1/Tollfree/Verifications";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "request",
        "form"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.CreateTollfreeVerificationSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CreateTollfreeVerificationResponse =
        new operations.CreateTollfreeVerificationResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.messagingV1TollfreeVerification = utils.objectToClass(
              httpRes?.data,
              shared.MessagingV1TollfreeVerification
            );
          }
          break;
      }

      return res;
    });
  }

  createUsAppToPerson(
    req: operations.CreateUsAppToPersonRequest,
    security: operations.CreateUsAppToPersonSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.CreateUsAppToPersonResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CreateUsAppToPersonRequest(req);
    }

    let baseURL: string = operations.CreateUsAppToPersonServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v1/Services/{MessagingServiceSid}/Compliance/Usa2p",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "form"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.CreateUsAppToPersonSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CreateUsAppToPersonResponse =
        new operations.CreateUsAppToPersonResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.messagingV1ServiceUsAppToPerson = utils.objectToClass(
              httpRes?.data,
              shared.MessagingV1ServiceUsAppToPerson
            );
          }
          break;
      }

      return res;
    });
  }

  deleteAlphaSender(
    req: operations.DeleteAlphaSenderRequest,
    security: operations.DeleteAlphaSenderSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.DeleteAlphaSenderResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DeleteAlphaSenderRequest(req);
    }

    let baseURL: string = operations.DeleteAlphaSenderServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v1/Services/{ServiceSid}/AlphaSenders/{Sid}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.DeleteAlphaSenderSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DeleteAlphaSenderResponse =
        new operations.DeleteAlphaSenderResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
      }

      return res;
    });
  }

  deleteDomainCertV4(
    req: operations.DeleteDomainCertV4Request,
    security: operations.DeleteDomainCertV4Security,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.DeleteDomainCertV4Response> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DeleteDomainCertV4Request(req);
    }

    let baseURL: string = operations.DeleteDomainCertV4ServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v1/LinkShortening/Domains/{DomainSid}/Certificate",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.DeleteDomainCertV4Security(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DeleteDomainCertV4Response =
        new operations.DeleteDomainCertV4Response({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
      }

      return res;
    });
  }

  deleteLinkshorteningMessagingService(
    req: operations.DeleteLinkshorteningMessagingServiceRequest,
    security: operations.DeleteLinkshorteningMessagingServiceSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.DeleteLinkshorteningMessagingServiceResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DeleteLinkshorteningMessagingServiceRequest(req);
    }

    let baseURL: string =
      operations.DeleteLinkshorteningMessagingServiceServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v1/LinkShortening/Domains/{DomainSid}/MessagingServices/{MessagingServiceSid}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.DeleteLinkshorteningMessagingServiceSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DeleteLinkshorteningMessagingServiceResponse =
        new operations.DeleteLinkshorteningMessagingServiceResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
      }

      return res;
    });
  }

  deletePhoneNumber(
    req: operations.DeletePhoneNumberRequest,
    security: operations.DeletePhoneNumberSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.DeletePhoneNumberResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DeletePhoneNumberRequest(req);
    }

    let baseURL: string = operations.DeletePhoneNumberServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v1/Services/{ServiceSid}/PhoneNumbers/{Sid}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.DeletePhoneNumberSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DeletePhoneNumberResponse =
        new operations.DeletePhoneNumberResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
      }

      return res;
    });
  }

  deleteService(
    req: operations.DeleteServiceRequest,
    security: operations.DeleteServiceSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.DeleteServiceResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DeleteServiceRequest(req);
    }

    let baseURL: string = operations.DeleteServiceServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(baseURL, "/v1/Services/{Sid}", req);
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.DeleteServiceSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DeleteServiceResponse =
        new operations.DeleteServiceResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
      }

      return res;
    });
  }

  deleteShortCode(
    req: operations.DeleteShortCodeRequest,
    security: operations.DeleteShortCodeSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.DeleteShortCodeResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DeleteShortCodeRequest(req);
    }

    let baseURL: string = operations.DeleteShortCodeServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v1/Services/{ServiceSid}/ShortCodes/{Sid}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.DeleteShortCodeSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DeleteShortCodeResponse =
        new operations.DeleteShortCodeResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
      }

      return res;
    });
  }

  deleteUsAppToPerson(
    req: operations.DeleteUsAppToPersonRequest,
    security: operations.DeleteUsAppToPersonSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.DeleteUsAppToPersonResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DeleteUsAppToPersonRequest(req);
    }

    let baseURL: string = operations.DeleteUsAppToPersonServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v1/Services/{MessagingServiceSid}/Compliance/Usa2p/{Sid}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.DeleteUsAppToPersonSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DeleteUsAppToPersonResponse =
        new operations.DeleteUsAppToPersonResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
      }

      return res;
    });
  }

  fetchAlphaSender(
    req: operations.FetchAlphaSenderRequest,
    security: operations.FetchAlphaSenderSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.FetchAlphaSenderResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.FetchAlphaSenderRequest(req);
    }

    let baseURL: string = operations.FetchAlphaSenderServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v1/Services/{ServiceSid}/AlphaSenders/{Sid}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.FetchAlphaSenderSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.FetchAlphaSenderResponse =
        new operations.FetchAlphaSenderResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.messagingV1ServiceAlphaSender = utils.objectToClass(
              httpRes?.data,
              shared.MessagingV1ServiceAlphaSender
            );
          }
          break;
      }

      return res;
    });
  }

  fetchBrandRegistrations(
    req: operations.FetchBrandRegistrationsRequest,
    security: operations.FetchBrandRegistrationsSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.FetchBrandRegistrationsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.FetchBrandRegistrationsRequest(req);
    }

    let baseURL: string = operations.FetchBrandRegistrationsServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v1/a2p/BrandRegistrations/{Sid}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.FetchBrandRegistrationsSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.FetchBrandRegistrationsResponse =
        new operations.FetchBrandRegistrationsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.messagingV1BrandRegistrations = utils.objectToClass(
              httpRes?.data,
              shared.MessagingV1BrandRegistrations
            );
          }
          break;
      }

      return res;
    });
  }

  fetchBrandVetting(
    req: operations.FetchBrandVettingRequest,
    security: operations.FetchBrandVettingSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.FetchBrandVettingResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.FetchBrandVettingRequest(req);
    }

    let baseURL: string = operations.FetchBrandVettingServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v1/a2p/BrandRegistrations/{BrandSid}/Vettings/{BrandVettingSid}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.FetchBrandVettingSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.FetchBrandVettingResponse =
        new operations.FetchBrandVettingResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.messagingV1BrandRegistrationsBrandVetting = utils.objectToClass(
              httpRes?.data,
              shared.MessagingV1BrandRegistrationsBrandVetting
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Fetch a list of all United States numbers that have been deactivated on a specific date.
   */
  fetchDeactivation(
    req: operations.FetchDeactivationRequest,
    security: operations.FetchDeactivationSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.FetchDeactivationResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.FetchDeactivationRequest(req);
    }

    let baseURL: string = operations.FetchDeactivationServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = baseURL.replace(/\/$/, "") + "/v1/Deactivations";
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.FetchDeactivationSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.FetchDeactivationResponse =
        new operations.FetchDeactivationResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 307:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.messagingV1Deactivation = utils.objectToClass(
              httpRes?.data,
              shared.MessagingV1Deactivation
            );
          }
          break;
      }

      return res;
    });
  }

  fetchDomainCertV4(
    req: operations.FetchDomainCertV4Request,
    security: operations.FetchDomainCertV4Security,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.FetchDomainCertV4Response> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.FetchDomainCertV4Request(req);
    }

    let baseURL: string = operations.FetchDomainCertV4ServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v1/LinkShortening/Domains/{DomainSid}/Certificate",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.FetchDomainCertV4Security(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.FetchDomainCertV4Response =
        new operations.FetchDomainCertV4Response({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.messagingV1DomainCertV4 = utils.objectToClass(
              httpRes?.data,
              shared.MessagingV1DomainCertV4
            );
          }
          break;
      }

      return res;
    });
  }

  fetchDomainConfig(
    req: operations.FetchDomainConfigRequest,
    security: operations.FetchDomainConfigSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.FetchDomainConfigResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.FetchDomainConfigRequest(req);
    }

    let baseURL: string = operations.FetchDomainConfigServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v1/LinkShortening/Domains/{DomainSid}/Config",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.FetchDomainConfigSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.FetchDomainConfigResponse =
        new operations.FetchDomainConfigResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.messagingV1DomainConfig = utils.objectToClass(
              httpRes?.data,
              shared.MessagingV1DomainConfig
            );
          }
          break;
      }

      return res;
    });
  }

  fetchDomainConfigMessagingService(
    req: operations.FetchDomainConfigMessagingServiceRequest,
    security: operations.FetchDomainConfigMessagingServiceSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.FetchDomainConfigMessagingServiceResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.FetchDomainConfigMessagingServiceRequest(req);
    }

    let baseURL: string =
      operations.FetchDomainConfigMessagingServiceServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v1/LinkShortening/MessagingService/{MessagingServiceSid}/DomainConfig",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.FetchDomainConfigMessagingServiceSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.FetchDomainConfigMessagingServiceResponse =
        new operations.FetchDomainConfigMessagingServiceResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.messagingV1DomainConfigMessagingService = utils.objectToClass(
              httpRes?.data,
              shared.MessagingV1DomainConfigMessagingService
            );
          }
          break;
      }

      return res;
    });
  }

  fetchPhoneNumber(
    req: operations.FetchPhoneNumberRequest,
    security: operations.FetchPhoneNumberSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.FetchPhoneNumberResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.FetchPhoneNumberRequest(req);
    }

    let baseURL: string = operations.FetchPhoneNumberServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v1/Services/{ServiceSid}/PhoneNumbers/{Sid}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.FetchPhoneNumberSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.FetchPhoneNumberResponse =
        new operations.FetchPhoneNumberResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.messagingV1ServicePhoneNumber = utils.objectToClass(
              httpRes?.data,
              shared.MessagingV1ServicePhoneNumber
            );
          }
          break;
      }

      return res;
    });
  }

  fetchService(
    req: operations.FetchServiceRequest,
    security: operations.FetchServiceSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.FetchServiceResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.FetchServiceRequest(req);
    }

    let baseURL: string = operations.FetchServiceServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(baseURL, "/v1/Services/{Sid}", req);
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.FetchServiceSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.FetchServiceResponse =
        new operations.FetchServiceResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.messagingV1Service = utils.objectToClass(
              httpRes?.data,
              shared.MessagingV1Service
            );
          }
          break;
      }

      return res;
    });
  }

  fetchShortCode(
    req: operations.FetchShortCodeRequest,
    security: operations.FetchShortCodeSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.FetchShortCodeResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.FetchShortCodeRequest(req);
    }

    let baseURL: string = operations.FetchShortCodeServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v1/Services/{ServiceSid}/ShortCodes/{Sid}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.FetchShortCodeSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.FetchShortCodeResponse =
        new operations.FetchShortCodeResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.messagingV1ServiceShortCode = utils.objectToClass(
              httpRes?.data,
              shared.MessagingV1ServiceShortCode
            );
          }
          break;
      }

      return res;
    });
  }

  fetchTollfreeVerification(
    req: operations.FetchTollfreeVerificationRequest,
    security: operations.FetchTollfreeVerificationSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.FetchTollfreeVerificationResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.FetchTollfreeVerificationRequest(req);
    }

    let baseURL: string = operations.FetchTollfreeVerificationServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v1/Tollfree/Verifications/{Sid}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.FetchTollfreeVerificationSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.FetchTollfreeVerificationResponse =
        new operations.FetchTollfreeVerificationResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.messagingV1TollfreeVerification = utils.objectToClass(
              httpRes?.data,
              shared.MessagingV1TollfreeVerification
            );
          }
          break;
      }

      return res;
    });
  }

  fetchUsAppToPerson(
    req: operations.FetchUsAppToPersonRequest,
    security: operations.FetchUsAppToPersonSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.FetchUsAppToPersonResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.FetchUsAppToPersonRequest(req);
    }

    let baseURL: string = operations.FetchUsAppToPersonServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v1/Services/{MessagingServiceSid}/Compliance/Usa2p/{Sid}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.FetchUsAppToPersonSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.FetchUsAppToPersonResponse =
        new operations.FetchUsAppToPersonResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.messagingV1ServiceUsAppToPerson = utils.objectToClass(
              httpRes?.data,
              shared.MessagingV1ServiceUsAppToPerson
            );
          }
          break;
      }

      return res;
    });
  }

  fetchUsAppToPersonUsecase(
    req: operations.FetchUsAppToPersonUsecaseRequest,
    security: operations.FetchUsAppToPersonUsecaseSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.FetchUsAppToPersonUsecaseResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.FetchUsAppToPersonUsecaseRequest(req);
    }

    let baseURL: string = operations.FetchUsAppToPersonUsecaseServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v1/Services/{MessagingServiceSid}/Compliance/Usa2p/Usecases",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.FetchUsAppToPersonUsecaseSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.FetchUsAppToPersonUsecaseResponse =
        new operations.FetchUsAppToPersonUsecaseResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.messagingV1ServiceUsAppToPersonUsecase = utils.objectToClass(
              httpRes?.data,
              shared.MessagingV1ServiceUsAppToPersonUsecase
            );
          }
          break;
      }

      return res;
    });
  }

  fetchUsecase(
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.FetchUsecaseResponse> {
    let baseURL: string = operations.FetchUsecaseServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = baseURL.replace(/\/$/, "") + "/v1/Services/Usecases";

    const client: AxiosInstance = this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.FetchUsecaseResponse =
        new operations.FetchUsecaseResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.messagingV1Usecase = utils.objectToClass(
              httpRes?.data,
              shared.MessagingV1Usecase
            );
          }
          break;
      }

      return res;
    });
  }

  listAlphaSender(
    req: operations.ListAlphaSenderRequest,
    security: operations.ListAlphaSenderSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.ListAlphaSenderResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ListAlphaSenderRequest(req);
    }

    let baseURL: string = operations.ListAlphaSenderServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v1/Services/{ServiceSid}/AlphaSenders",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ListAlphaSenderSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ListAlphaSenderResponse =
        new operations.ListAlphaSenderResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listAlphaSenderResponse = utils.objectToClass(
              httpRes?.data,
              operations.ListAlphaSenderListAlphaSenderResponse
            );
          }
          break;
      }

      return res;
    });
  }

  listBrandRegistrations(
    req: operations.ListBrandRegistrationsRequest,
    security: operations.ListBrandRegistrationsSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.ListBrandRegistrationsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ListBrandRegistrationsRequest(req);
    }

    let baseURL: string = operations.ListBrandRegistrationsServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string =
      baseURL.replace(/\/$/, "") + "/v1/a2p/BrandRegistrations";
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ListBrandRegistrationsSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ListBrandRegistrationsResponse =
        new operations.ListBrandRegistrationsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listBrandRegistrationsResponse = utils.objectToClass(
              httpRes?.data,
              operations.ListBrandRegistrationsListBrandRegistrationsResponse
            );
          }
          break;
      }

      return res;
    });
  }

  listBrandVetting(
    req: operations.ListBrandVettingRequest,
    security: operations.ListBrandVettingSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.ListBrandVettingResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ListBrandVettingRequest(req);
    }

    let baseURL: string = operations.ListBrandVettingServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v1/a2p/BrandRegistrations/{BrandSid}/Vettings",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ListBrandVettingSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ListBrandVettingResponse =
        new operations.ListBrandVettingResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listBrandVettingResponse = utils.objectToClass(
              httpRes?.data,
              operations.ListBrandVettingListBrandVettingResponse
            );
          }
          break;
      }

      return res;
    });
  }

  listPhoneNumber(
    req: operations.ListPhoneNumberRequest,
    security: operations.ListPhoneNumberSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.ListPhoneNumberResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ListPhoneNumberRequest(req);
    }

    let baseURL: string = operations.ListPhoneNumberServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v1/Services/{ServiceSid}/PhoneNumbers",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ListPhoneNumberSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ListPhoneNumberResponse =
        new operations.ListPhoneNumberResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listPhoneNumberResponse = utils.objectToClass(
              httpRes?.data,
              operations.ListPhoneNumberListPhoneNumberResponse
            );
          }
          break;
      }

      return res;
    });
  }

  listService(
    req: operations.ListServiceRequest,
    security: operations.ListServiceSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.ListServiceResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ListServiceRequest(req);
    }

    let baseURL: string = operations.ListServiceServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = baseURL.replace(/\/$/, "") + "/v1/Services";
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ListServiceSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ListServiceResponse =
        new operations.ListServiceResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listServiceResponse = utils.objectToClass(
              httpRes?.data,
              operations.ListServiceListServiceResponse
            );
          }
          break;
      }

      return res;
    });
  }

  listShortCode(
    req: operations.ListShortCodeRequest,
    security: operations.ListShortCodeSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.ListShortCodeResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ListShortCodeRequest(req);
    }

    let baseURL: string = operations.ListShortCodeServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v1/Services/{ServiceSid}/ShortCodes",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ListShortCodeSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ListShortCodeResponse =
        new operations.ListShortCodeResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listShortCodeResponse = utils.objectToClass(
              httpRes?.data,
              operations.ListShortCodeListShortCodeResponse
            );
          }
          break;
      }

      return res;
    });
  }

  listTollfreeVerification(
    req: operations.ListTollfreeVerificationRequest,
    security: operations.ListTollfreeVerificationSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.ListTollfreeVerificationResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ListTollfreeVerificationRequest(req);
    }

    let baseURL: string = operations.ListTollfreeVerificationServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string =
      baseURL.replace(/\/$/, "") + "/v1/Tollfree/Verifications";
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ListTollfreeVerificationSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ListTollfreeVerificationResponse =
        new operations.ListTollfreeVerificationResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listTollfreeVerificationResponse = utils.objectToClass(
              httpRes?.data,
              operations.ListTollfreeVerificationListTollfreeVerificationResponse
            );
          }
          break;
      }

      return res;
    });
  }

  listUsAppToPerson(
    req: operations.ListUsAppToPersonRequest,
    security: operations.ListUsAppToPersonSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.ListUsAppToPersonResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ListUsAppToPersonRequest(req);
    }

    let baseURL: string = operations.ListUsAppToPersonServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v1/Services/{MessagingServiceSid}/Compliance/Usa2p",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ListUsAppToPersonSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ListUsAppToPersonResponse =
        new operations.ListUsAppToPersonResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listUsAppToPersonResponse = utils.objectToClass(
              httpRes?.data,
              operations.ListUsAppToPersonListUsAppToPersonResponse
            );
          }
          break;
      }

      return res;
    });
  }

  updateBrandRegistrations(
    req: operations.UpdateBrandRegistrationsRequest,
    security: operations.UpdateBrandRegistrationsSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.UpdateBrandRegistrationsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.UpdateBrandRegistrationsRequest(req);
    }

    let baseURL: string = operations.UpdateBrandRegistrationsServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v1/a2p/BrandRegistrations/{Sid}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.UpdateBrandRegistrationsSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "post",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UpdateBrandRegistrationsResponse =
        new operations.UpdateBrandRegistrationsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 202:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.messagingV1BrandRegistrations = utils.objectToClass(
              httpRes?.data,
              shared.MessagingV1BrandRegistrations
            );
          }
          break;
      }

      return res;
    });
  }

  updateDomainCertV4(
    req: operations.UpdateDomainCertV4Request,
    security: operations.UpdateDomainCertV4Security,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.UpdateDomainCertV4Response> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.UpdateDomainCertV4Request(req);
    }

    let baseURL: string = operations.UpdateDomainCertV4ServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v1/LinkShortening/Domains/{DomainSid}/Certificate",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "form"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.UpdateDomainCertV4Security(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UpdateDomainCertV4Response =
        new operations.UpdateDomainCertV4Response({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case [200, 201].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.messagingV1DomainCertV4 = utils.objectToClass(
              httpRes?.data,
              shared.MessagingV1DomainCertV4
            );
          }
          break;
      }

      return res;
    });
  }

  updateDomainConfig(
    req: operations.UpdateDomainConfigRequest,
    security: operations.UpdateDomainConfigSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.UpdateDomainConfigResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.UpdateDomainConfigRequest(req);
    }

    let baseURL: string = operations.UpdateDomainConfigServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v1/LinkShortening/Domains/{DomainSid}/Config",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "form"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.UpdateDomainConfigSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UpdateDomainConfigResponse =
        new operations.UpdateDomainConfigResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case [200, 201].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.messagingV1DomainConfig = utils.objectToClass(
              httpRes?.data,
              shared.MessagingV1DomainConfig
            );
          }
          break;
      }

      return res;
    });
  }

  updateService(
    req: operations.UpdateServiceRequest,
    security: operations.UpdateServiceSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.UpdateServiceResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.UpdateServiceRequest(req);
    }

    let baseURL: string = operations.UpdateServiceServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(baseURL, "/v1/Services/{Sid}", req);

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "form"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.UpdateServiceSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UpdateServiceResponse =
        new operations.UpdateServiceResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.messagingV1Service = utils.objectToClass(
              httpRes?.data,
              shared.MessagingV1Service
            );
          }
          break;
      }

      return res;
    });
  }

  updateTollfreeVerification(
    req: operations.UpdateTollfreeVerificationRequest,
    security: operations.UpdateTollfreeVerificationSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.UpdateTollfreeVerificationResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.UpdateTollfreeVerificationRequest(req);
    }

    let baseURL: string = operations.UpdateTollfreeVerificationServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v1/Tollfree/Verifications/{Sid}",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "form"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.UpdateTollfreeVerificationSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UpdateTollfreeVerificationResponse =
        new operations.UpdateTollfreeVerificationResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 202:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.messagingV1TollfreeVerification = utils.objectToClass(
              httpRes?.data,
              shared.MessagingV1TollfreeVerification
            );
          }
          break;
      }

      return res;
    });
  }
}
