/*
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

import { SpeakeasyBase, SpeakeasyMetadata } from "../../../internal/utils";
import {
  LinkedLedgerAccount,
  LinkedLedgerAccountInput,
} from "./linkedledgeraccount";
import { LinkedTaxRate, LinkedTaxRateInput } from "./linkedtaxrate";
import { Expose, Transform, Type } from "class-transformer";

export class InvoiceItemPurchaseDetailsInput extends SpeakeasyBase {
  /**
   * Amounts are including tax
   */
  @SpeakeasyMetadata()
  @Expose({ name: "tax_inclusive" })
  taxInclusive?: boolean;

  @SpeakeasyMetadata()
  @Expose({ name: "tax_rate" })
  @Type(() => LinkedTaxRateInput)
  taxRate?: LinkedTaxRateInput;

  /**
   * Description of the unit type the item is sold as, ie: kg, hour.
   */
  @SpeakeasyMetadata()
  @Expose({ name: "unit_of_measure" })
  unitOfMeasure?: string;

  @SpeakeasyMetadata()
  @Expose({ name: "unit_price" })
  unitPrice?: number;
}

export class InvoiceItemSalesDetailsInput extends SpeakeasyBase {
  /**
   * Amounts are including tax
   */
  @SpeakeasyMetadata()
  @Expose({ name: "tax_inclusive" })
  taxInclusive?: boolean;

  @SpeakeasyMetadata()
  @Expose({ name: "tax_rate" })
  @Type(() => LinkedTaxRateInput)
  taxRate?: LinkedTaxRateInput;

  /**
   * Description of the unit type the item is sold as, ie: kg, hour.
   */
  @SpeakeasyMetadata()
  @Expose({ name: "unit_of_measure" })
  unitOfMeasure?: string;

  @SpeakeasyMetadata()
  @Expose({ name: "unit_price" })
  unitPrice?: number;
}

/**
 * Item type
 */
export enum InvoiceItemTypeEnum {
  Inventory = "inventory",
  Service = "service",
  Other = "other",
}

export class InvoiceItemInput extends SpeakeasyBase {
  @SpeakeasyMetadata()
  @Expose({ name: "active" })
  active?: boolean;

  @SpeakeasyMetadata()
  @Expose({ name: "asset_account" })
  @Type(() => LinkedLedgerAccountInput)
  assetAccount?: LinkedLedgerAccountInput;

  /**
   * User defined item code
   */
  @SpeakeasyMetadata()
  @Expose({ name: "code" })
  code?: string;

  /**
   * A short description of the item
   */
  @SpeakeasyMetadata()
  @Expose({ name: "description" })
  description?: string;

  @SpeakeasyMetadata()
  @Expose({ name: "expense_account" })
  @Type(() => LinkedLedgerAccountInput)
  expenseAccount?: LinkedLedgerAccountInput;

  @SpeakeasyMetadata()
  @Expose({ name: "income_account" })
  @Type(() => LinkedLedgerAccountInput)
  incomeAccount?: LinkedLedgerAccountInput;

  /**
   * The date of opening balance if inventory item is tracked - YYYY-MM-DD.
   */
  @SpeakeasyMetadata()
  @Expose({ name: "inventory_date" })
  @Transform(({ value }) => new Date(value), { toClassOnly: true })
  inventoryDate?: Date;

  /**
   * Item name
   */
  @SpeakeasyMetadata()
  @Expose({ name: "name" })
  name?: string;

  @SpeakeasyMetadata()
  @Expose({ name: "purchase_details" })
  @Type(() => InvoiceItemPurchaseDetailsInput)
  purchaseDetails?: InvoiceItemPurchaseDetailsInput;

  /**
   * Item is available for purchase transactions
   */
  @SpeakeasyMetadata()
  @Expose({ name: "purchased" })
  purchased?: boolean;

  @SpeakeasyMetadata()
  @Expose({ name: "quantity" })
  quantity?: number;

  /**
   * A binary value used to detect updates to a object and prevent data conflicts. It is incremented each time an update is made to the object.
   */
  @SpeakeasyMetadata()
  @Expose({ name: "row_version" })
  rowVersion?: string;

  @SpeakeasyMetadata()
  @Expose({ name: "sales_details" })
  @Type(() => InvoiceItemSalesDetailsInput)
  salesDetails?: InvoiceItemSalesDetailsInput;

  /**
   * Item will be available on sales transactions
   */
  @SpeakeasyMetadata()
  @Expose({ name: "sold" })
  sold?: boolean;

  /**
   * Item is inventoried
   */
  @SpeakeasyMetadata()
  @Expose({ name: "tracked" })
  tracked?: boolean;

  /**
   * Item type
   */
  @SpeakeasyMetadata()
  @Expose({ name: "type" })
  type?: InvoiceItemTypeEnum;

  @SpeakeasyMetadata()
  @Expose({ name: "unit_price" })
  unitPrice?: number;
}

export class InvoiceItemPurchaseDetails extends SpeakeasyBase {
  /**
   * Amounts are including tax
   */
  @SpeakeasyMetadata()
  @Expose({ name: "tax_inclusive" })
  taxInclusive?: boolean;

  @SpeakeasyMetadata()
  @Expose({ name: "tax_rate" })
  @Type(() => LinkedTaxRate)
  taxRate?: LinkedTaxRate;

  /**
   * Description of the unit type the item is sold as, ie: kg, hour.
   */
  @SpeakeasyMetadata()
  @Expose({ name: "unit_of_measure" })
  unitOfMeasure?: string;

  @SpeakeasyMetadata()
  @Expose({ name: "unit_price" })
  unitPrice?: number;
}

export class InvoiceItemSalesDetails extends SpeakeasyBase {
  /**
   * Amounts are including tax
   */
  @SpeakeasyMetadata()
  @Expose({ name: "tax_inclusive" })
  taxInclusive?: boolean;

  @SpeakeasyMetadata()
  @Expose({ name: "tax_rate" })
  @Type(() => LinkedTaxRate)
  taxRate?: LinkedTaxRate;

  /**
   * Description of the unit type the item is sold as, ie: kg, hour.
   */
  @SpeakeasyMetadata()
  @Expose({ name: "unit_of_measure" })
  unitOfMeasure?: string;

  @SpeakeasyMetadata()
  @Expose({ name: "unit_price" })
  unitPrice?: number;
}

export class InvoiceItem extends SpeakeasyBase {
  @SpeakeasyMetadata()
  @Expose({ name: "active" })
  active?: boolean;

  @SpeakeasyMetadata()
  @Expose({ name: "asset_account" })
  @Type(() => LinkedLedgerAccount)
  assetAccount?: LinkedLedgerAccount;

  /**
   * User defined item code
   */
  @SpeakeasyMetadata()
  @Expose({ name: "code" })
  code?: string;

  /**
   * The date and time when the object was created.
   */
  @SpeakeasyMetadata()
  @Expose({ name: "created_at" })
  @Transform(({ value }) => new Date(value), { toClassOnly: true })
  createdAt?: Date;

  /**
   * The user who created the object.
   */
  @SpeakeasyMetadata()
  @Expose({ name: "created_by" })
  createdBy?: string;

  /**
   * A short description of the item
   */
  @SpeakeasyMetadata()
  @Expose({ name: "description" })
  description?: string;

  @SpeakeasyMetadata()
  @Expose({ name: "expense_account" })
  @Type(() => LinkedLedgerAccount)
  expenseAccount?: LinkedLedgerAccount;

  /**
   * The ID of the item.
   */
  @SpeakeasyMetadata()
  @Expose({ name: "id" })
  id?: string;

  @SpeakeasyMetadata()
  @Expose({ name: "income_account" })
  @Type(() => LinkedLedgerAccount)
  incomeAccount?: LinkedLedgerAccount;

  /**
   * The date of opening balance if inventory item is tracked - YYYY-MM-DD.
   */
  @SpeakeasyMetadata()
  @Expose({ name: "inventory_date" })
  @Transform(({ value }) => new Date(value), { toClassOnly: true })
  inventoryDate?: Date;

  /**
   * Item name
   */
  @SpeakeasyMetadata()
  @Expose({ name: "name" })
  name?: string;

  @SpeakeasyMetadata()
  @Expose({ name: "purchase_details" })
  @Type(() => InvoiceItemPurchaseDetails)
  purchaseDetails?: InvoiceItemPurchaseDetails;

  /**
   * Item is available for purchase transactions
   */
  @SpeakeasyMetadata()
  @Expose({ name: "purchased" })
  purchased?: boolean;

  @SpeakeasyMetadata()
  @Expose({ name: "quantity" })
  quantity?: number;

  /**
   * A binary value used to detect updates to a object and prevent data conflicts. It is incremented each time an update is made to the object.
   */
  @SpeakeasyMetadata()
  @Expose({ name: "row_version" })
  rowVersion?: string;

  @SpeakeasyMetadata()
  @Expose({ name: "sales_details" })
  @Type(() => InvoiceItemSalesDetails)
  salesDetails?: InvoiceItemSalesDetails;

  /**
   * Item will be available on sales transactions
   */
  @SpeakeasyMetadata()
  @Expose({ name: "sold" })
  sold?: boolean;

  /**
   * Item is inventoried
   */
  @SpeakeasyMetadata()
  @Expose({ name: "tracked" })
  tracked?: boolean;

  /**
   * Item type
   */
  @SpeakeasyMetadata()
  @Expose({ name: "type" })
  type?: InvoiceItemTypeEnum;

  @SpeakeasyMetadata()
  @Expose({ name: "unit_price" })
  unitPrice?: number;

  /**
   * The date and time when the object was last updated.
   */
  @SpeakeasyMetadata()
  @Expose({ name: "updated_at" })
  @Transform(({ value }) => new Date(value), { toClassOnly: true })
  updatedAt?: Date;

  /**
   * The user who last updated the object.
   */
  @SpeakeasyMetadata()
  @Expose({ name: "updated_by" })
  updatedBy?: string;
}
