/*
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

import { SpeakeasyBase, SpeakeasyMetadata } from "../../../internal/utils";
import { AxiosResponse } from "axios";
import { Expose, Type } from "class-transformer";

/**
 * Access Type of the policy. Automatically 'Hybrid authentication' when hostMode is 'Multi-Domain'.
 */
export enum UpdateNetworkSwitchAccessPolicyRequestBodyAccessPolicyTypeEnum {
  EightHundredAndTwo1x = "802.1x",
  HybridAuthentication = "Hybrid authentication",
  MACAuthenticationBypass = "MAC authentication bypass",
}

/**
 * Supports either 'both' or 'inbound'. Set to 'inbound' to allow unauthorized egress on the switchport. Set to 'both' to control both traffic directions with authorization. Defaults to 'both'
 */
export enum UpdateNetworkSwitchAccessPolicyRequestBodyDot1xControlDirectionEnum {
  Both = "both",
  Inbound = "inbound",
}

/**
 * 802.1x Settings
 */
export class UpdateNetworkSwitchAccessPolicyRequestBodyDot1x extends SpeakeasyBase {
  /**
   * Supports either 'both' or 'inbound'. Set to 'inbound' to allow unauthorized egress on the switchport. Set to 'both' to control both traffic directions with authorization. Defaults to 'both'
   */
  @SpeakeasyMetadata()
  @Expose({ name: "controlDirection" })
  controlDirection?: UpdateNetworkSwitchAccessPolicyRequestBodyDot1xControlDirectionEnum;
}

/**
 * Choose the Host Mode for the access policy.
 */
export enum UpdateNetworkSwitchAccessPolicyRequestBodyHostModeEnum {
  MultiAuth = "Multi-Auth",
  MultiDomain = "Multi-Domain",
  MultiHost = "Multi-Host",
  SingleHost = "Single-Host",
}

/**
 * Critical auth settings for when authentication is rejected by the RADIUS server
 */
export class UpdateNetworkSwitchAccessPolicyRequestBodyRadiusCriticalAuth extends SpeakeasyBase {
  /**
   * VLAN that clients who use data will be placed on when RADIUS authentication fails. Will be null if hostMode is Multi-Auth
   */
  @SpeakeasyMetadata()
  @Expose({ name: "dataVlanId" })
  dataVlanId?: number;

  /**
   * Enable to suspend port bounce when RADIUS servers are unreachable
   */
  @SpeakeasyMetadata()
  @Expose({ name: "suspendPortBounce" })
  suspendPortBounce?: boolean;

  /**
   * VLAN that clients who use voice will be placed on when RADIUS authentication fails. Will be null if hostMode is Multi-Auth
   */
  @SpeakeasyMetadata()
  @Expose({ name: "voiceVlanId" })
  voiceVlanId?: number;
}

/**
 * Object for RADIUS Settings
 */
export class UpdateNetworkSwitchAccessPolicyRequestBodyRadius extends SpeakeasyBase {
  /**
   * Critical auth settings for when authentication is rejected by the RADIUS server
   */
  @SpeakeasyMetadata()
  @Expose({ name: "criticalAuth" })
  @Type(() => UpdateNetworkSwitchAccessPolicyRequestBodyRadiusCriticalAuth)
  criticalAuth?: UpdateNetworkSwitchAccessPolicyRequestBodyRadiusCriticalAuth;

  /**
   * VLAN that clients will be placed on when RADIUS authentication fails. Will be null if hostMode is Multi-Auth
   */
  @SpeakeasyMetadata()
  @Expose({ name: "failedAuthVlanId" })
  failedAuthVlanId?: number;

  /**
   * Re-authentication period in seconds. Will be null if hostMode is Multi-Auth
   */
  @SpeakeasyMetadata()
  @Expose({ name: "reAuthenticationInterval" })
  reAuthenticationInterval?: number;
}

export class UpdateNetworkSwitchAccessPolicyRequestBodyRadiusAccountingServers extends SpeakeasyBase {
  /**
   * Public IP address of the RADIUS accounting server
   */
  @SpeakeasyMetadata()
  @Expose({ name: "host" })
  host: string;

  /**
   * UDP port that the RADIUS Accounting server listens on for access requests
   */
  @SpeakeasyMetadata()
  @Expose({ name: "port" })
  port: number;

  /**
   * RADIUS client shared secret
   */
  @SpeakeasyMetadata()
  @Expose({ name: "secret" })
  secret: string;
}

export class UpdateNetworkSwitchAccessPolicyRequestBodyRadiusServers extends SpeakeasyBase {
  /**
   * Public IP address of the RADIUS server
   */
  @SpeakeasyMetadata()
  @Expose({ name: "host" })
  host: string;

  /**
   * UDP port that the RADIUS server listens on for access requests
   */
  @SpeakeasyMetadata()
  @Expose({ name: "port" })
  port: number;

  /**
   * RADIUS client shared secret
   */
  @SpeakeasyMetadata()
  @Expose({ name: "secret" })
  secret: string;
}

export class UpdateNetworkSwitchAccessPolicyRequestBody extends SpeakeasyBase {
  /**
   * Access Type of the policy. Automatically 'Hybrid authentication' when hostMode is 'Multi-Domain'.
   */
  @SpeakeasyMetadata()
  @Expose({ name: "accessPolicyType" })
  accessPolicyType?: UpdateNetworkSwitchAccessPolicyRequestBodyAccessPolicyTypeEnum;

  /**
   * 802.1x Settings
   */
  @SpeakeasyMetadata()
  @Expose({ name: "dot1x" })
  @Type(() => UpdateNetworkSwitchAccessPolicyRequestBodyDot1x)
  dot1x?: UpdateNetworkSwitchAccessPolicyRequestBodyDot1x;

  /**
   * ID for the guest VLAN allow unauthorized devices access to limited network resources
   */
  @SpeakeasyMetadata()
  @Expose({ name: "guestVlanId" })
  guestVlanId?: number;

  /**
   * Choose the Host Mode for the access policy.
   */
  @SpeakeasyMetadata()
  @Expose({ name: "hostMode" })
  hostMode?: UpdateNetworkSwitchAccessPolicyRequestBodyHostModeEnum;

  /**
   * Enabling this option will make switches execute 802.1X and MAC-bypass authentication simultaneously so that clients authenticate faster. Only required when accessPolicyType is 'Hybrid Authentication.
   */
  @SpeakeasyMetadata()
  @Expose({ name: "increaseAccessSpeed" })
  increaseAccessSpeed?: boolean;

  /**
   * Name of the access policy
   */
  @SpeakeasyMetadata()
  @Expose({ name: "name" })
  name?: string;

  /**
   * Object for RADIUS Settings
   */
  @SpeakeasyMetadata()
  @Expose({ name: "radius" })
  @Type(() => UpdateNetworkSwitchAccessPolicyRequestBodyRadius)
  radius?: UpdateNetworkSwitchAccessPolicyRequestBodyRadius;

  /**
   * Enable to send start, interim-update and stop messages to a configured RADIUS accounting server for tracking connected clients
   */
  @SpeakeasyMetadata()
  @Expose({ name: "radiusAccountingEnabled" })
  radiusAccountingEnabled?: boolean;

  /**
   * List of RADIUS accounting servers to require connecting devices to authenticate against before granting network access
   */
  @SpeakeasyMetadata({
    elemType: UpdateNetworkSwitchAccessPolicyRequestBodyRadiusAccountingServers,
  })
  @Expose({ name: "radiusAccountingServers" })
  @Type(() => UpdateNetworkSwitchAccessPolicyRequestBodyRadiusAccountingServers)
  radiusAccountingServers?: UpdateNetworkSwitchAccessPolicyRequestBodyRadiusAccountingServers[];

  /**
   * Change of authentication for RADIUS re-authentication and disconnection
   */
  @SpeakeasyMetadata()
  @Expose({ name: "radiusCoaSupportEnabled" })
  radiusCoaSupportEnabled?: boolean;

  /**
   * Acceptable values are `""` for None, or `"11"` for Group Policies ACL
   */
  @SpeakeasyMetadata()
  @Expose({ name: "radiusGroupAttribute" })
  radiusGroupAttribute?: string;

  /**
   * List of RADIUS servers to require connecting devices to authenticate against before granting network access
   */
  @SpeakeasyMetadata({
    elemType: UpdateNetworkSwitchAccessPolicyRequestBodyRadiusServers,
  })
  @Expose({ name: "radiusServers" })
  @Type(() => UpdateNetworkSwitchAccessPolicyRequestBodyRadiusServers)
  radiusServers?: UpdateNetworkSwitchAccessPolicyRequestBodyRadiusServers[];

  /**
   * If enabled, Meraki devices will periodically send access-request messages to these RADIUS servers
   */
  @SpeakeasyMetadata()
  @Expose({ name: "radiusTestingEnabled" })
  radiusTestingEnabled?: boolean;

  /**
   * Enable to restrict access for clients to a specific set of IP addresses or hostnames prior to authentication
   */
  @SpeakeasyMetadata()
  @Expose({ name: "urlRedirectWalledGardenEnabled" })
  urlRedirectWalledGardenEnabled?: boolean;

  /**
   * IP address ranges, in CIDR notation, to restrict access for clients to a specific set of IP addresses or hostnames prior to authentication
   */
  @SpeakeasyMetadata()
  @Expose({ name: "urlRedirectWalledGardenRanges" })
  urlRedirectWalledGardenRanges?: string[];

  /**
   * CDP/LLDP capable voice clients will be able to use this VLAN. Automatically true when hostMode is 'Multi-Domain'.
   */
  @SpeakeasyMetadata()
  @Expose({ name: "voiceVlanClients" })
  voiceVlanClients?: boolean;
}

export class UpdateNetworkSwitchAccessPolicyRequest extends SpeakeasyBase {
  @SpeakeasyMetadata({ data: "request, media_type=application/json" })
  requestBody?: UpdateNetworkSwitchAccessPolicyRequestBody;

  @SpeakeasyMetadata({
    data: "pathParam, style=simple;explode=false;name=accessPolicyNumber",
  })
  accessPolicyNumber: string;

  @SpeakeasyMetadata({
    data: "pathParam, style=simple;explode=false;name=networkId",
  })
  networkId: string;
}

/**
 * Access Type of the policy. Automatically 'Hybrid authentication' when hostMode is 'Multi-Domain'.
 */
export enum UpdateNetworkSwitchAccessPolicy200ApplicationJSONAccessPolicyTypeEnum {
  EightHundredAndTwo1x = "802.1x",
  HybridAuthentication = "Hybrid authentication",
  MACAuthenticationBypass = "MAC authentication bypass",
}

/**
 * Supports either 'both' or 'inbound'. Set to 'inbound' to allow unauthorized egress on the switchport. Set to 'both' to control both traffic directions with authorization. Defaults to 'both'
 */
export enum UpdateNetworkSwitchAccessPolicy200ApplicationJSONDot1xControlDirectionEnum {
  Both = "both",
  Inbound = "inbound",
}

/**
 * 802.1x Settings
 */
export class UpdateNetworkSwitchAccessPolicy200ApplicationJSONDot1x extends SpeakeasyBase {
  /**
   * Supports either 'both' or 'inbound'. Set to 'inbound' to allow unauthorized egress on the switchport. Set to 'both' to control both traffic directions with authorization. Defaults to 'both'
   */
  @SpeakeasyMetadata()
  @Expose({ name: "controlDirection" })
  controlDirection?: UpdateNetworkSwitchAccessPolicy200ApplicationJSONDot1xControlDirectionEnum;
}

/**
 * Choose the Host Mode for the access policy.
 */
export enum UpdateNetworkSwitchAccessPolicy200ApplicationJSONHostModeEnum {
  MultiAuth = "Multi-Auth",
  MultiDomain = "Multi-Domain",
  MultiHost = "Multi-Host",
  SingleHost = "Single-Host",
}

/**
 * Critical auth settings for when authentication is rejected by the RADIUS server
 */
export class UpdateNetworkSwitchAccessPolicy200ApplicationJSONRadiusCriticalAuth extends SpeakeasyBase {
  /**
   * VLAN that clients who use data will be placed on when RADIUS authentication fails. Will be null if hostMode is Multi-Auth
   */
  @SpeakeasyMetadata()
  @Expose({ name: "dataVlanId" })
  dataVlanId?: number;

  /**
   * Enable to suspend port bounce when RADIUS servers are unreachable
   */
  @SpeakeasyMetadata()
  @Expose({ name: "suspendPortBounce" })
  suspendPortBounce?: boolean;

  /**
   * VLAN that clients who use voice will be placed on when RADIUS authentication fails. Will be null if hostMode is Multi-Auth
   */
  @SpeakeasyMetadata()
  @Expose({ name: "voiceVlanId" })
  voiceVlanId?: number;
}

/**
 * Object for RADIUS Settings
 */
export class UpdateNetworkSwitchAccessPolicy200ApplicationJSONRadius extends SpeakeasyBase {
  /**
   * Critical auth settings for when authentication is rejected by the RADIUS server
   */
  @SpeakeasyMetadata()
  @Expose({ name: "criticalAuth" })
  @Type(
    () => UpdateNetworkSwitchAccessPolicy200ApplicationJSONRadiusCriticalAuth
  )
  criticalAuth?: UpdateNetworkSwitchAccessPolicy200ApplicationJSONRadiusCriticalAuth;

  /**
   * VLAN that clients will be placed on when RADIUS authentication fails. Will be null if hostMode is Multi-Auth
   */
  @SpeakeasyMetadata()
  @Expose({ name: "failedAuthVlanId" })
  failedAuthVlanId?: number;

  /**
   * Re-authentication period in seconds. Will be null if hostMode is Multi-Auth
   */
  @SpeakeasyMetadata()
  @Expose({ name: "reAuthenticationInterval" })
  reAuthenticationInterval?: number;
}

export class UpdateNetworkSwitchAccessPolicy200ApplicationJSONRadiusAccountingServers extends SpeakeasyBase {
  /**
   * Public IP address of the RADIUS accounting server
   */
  @SpeakeasyMetadata()
  @Expose({ name: "host" })
  host?: string;

  /**
   * UDP port that the RADIUS Accounting server listens on for access requests
   */
  @SpeakeasyMetadata()
  @Expose({ name: "port" })
  port?: number;
}

export class UpdateNetworkSwitchAccessPolicy200ApplicationJSONRadiusServers extends SpeakeasyBase {
  /**
   * Public IP address of the RADIUS server
   */
  @SpeakeasyMetadata()
  @Expose({ name: "host" })
  host?: string;

  /**
   * UDP port that the RADIUS server listens on for access requests
   */
  @SpeakeasyMetadata()
  @Expose({ name: "port" })
  port?: number;
}

/**
 * Successful operation
 */
export class UpdateNetworkSwitchAccessPolicy200ApplicationJSON extends SpeakeasyBase {
  /**
   * Access Type of the policy. Automatically 'Hybrid authentication' when hostMode is 'Multi-Domain'.
   */
  @SpeakeasyMetadata()
  @Expose({ name: "accessPolicyType" })
  accessPolicyType?: UpdateNetworkSwitchAccessPolicy200ApplicationJSONAccessPolicyTypeEnum;

  /**
   * 802.1x Settings
   */
  @SpeakeasyMetadata()
  @Expose({ name: "dot1x" })
  @Type(() => UpdateNetworkSwitchAccessPolicy200ApplicationJSONDot1x)
  dot1x?: UpdateNetworkSwitchAccessPolicy200ApplicationJSONDot1x;

  /**
   * ID for the guest VLAN allow unauthorized devices access to limited network resources
   */
  @SpeakeasyMetadata()
  @Expose({ name: "guestVlanId" })
  guestVlanId?: number;

  /**
   * Choose the Host Mode for the access policy.
   */
  @SpeakeasyMetadata()
  @Expose({ name: "hostMode" })
  hostMode?: UpdateNetworkSwitchAccessPolicy200ApplicationJSONHostModeEnum;

  /**
   * Enabling this option will make switches execute 802.1X and MAC-bypass authentication simultaneously so that clients authenticate faster. Only required when accessPolicyType is 'Hybrid Authentication.
   */
  @SpeakeasyMetadata()
  @Expose({ name: "increaseAccessSpeed" })
  increaseAccessSpeed?: boolean;

  /**
   * Name of the access policy
   */
  @SpeakeasyMetadata()
  @Expose({ name: "name" })
  name?: string;

  /**
   * Object for RADIUS Settings
   */
  @SpeakeasyMetadata()
  @Expose({ name: "radius" })
  @Type(() => UpdateNetworkSwitchAccessPolicy200ApplicationJSONRadius)
  radius?: UpdateNetworkSwitchAccessPolicy200ApplicationJSONRadius;

  /**
   * Enable to send start, interim-update and stop messages to a configured RADIUS accounting server for tracking connected clients
   */
  @SpeakeasyMetadata()
  @Expose({ name: "radiusAccountingEnabled" })
  radiusAccountingEnabled?: boolean;

  /**
   * List of RADIUS accounting servers to require connecting devices to authenticate against before granting network access
   */
  @SpeakeasyMetadata({
    elemType:
      UpdateNetworkSwitchAccessPolicy200ApplicationJSONRadiusAccountingServers,
  })
  @Expose({ name: "radiusAccountingServers" })
  @Type(
    () =>
      UpdateNetworkSwitchAccessPolicy200ApplicationJSONRadiusAccountingServers
  )
  radiusAccountingServers?: UpdateNetworkSwitchAccessPolicy200ApplicationJSONRadiusAccountingServers[];

  /**
   * Change of authentication for RADIUS re-authentication and disconnection
   */
  @SpeakeasyMetadata()
  @Expose({ name: "radiusCoaSupportEnabled" })
  radiusCoaSupportEnabled?: boolean;

  /**
   * Acceptable values are `""` for None, or `"11"` for Group Policies ACL
   */
  @SpeakeasyMetadata()
  @Expose({ name: "radiusGroupAttribute" })
  radiusGroupAttribute?: string;

  /**
   * List of RADIUS servers to require connecting devices to authenticate against before granting network access
   */
  @SpeakeasyMetadata({
    elemType: UpdateNetworkSwitchAccessPolicy200ApplicationJSONRadiusServers,
  })
  @Expose({ name: "radiusServers" })
  @Type(() => UpdateNetworkSwitchAccessPolicy200ApplicationJSONRadiusServers)
  radiusServers?: UpdateNetworkSwitchAccessPolicy200ApplicationJSONRadiusServers[];

  /**
   * If enabled, Meraki devices will periodically send access-request messages to these RADIUS servers
   */
  @SpeakeasyMetadata()
  @Expose({ name: "radiusTestingEnabled" })
  radiusTestingEnabled?: boolean;

  /**
   * Enable to restrict access for clients to a response_objectific set of IP addresses or hostnames prior to authentication
   */
  @SpeakeasyMetadata()
  @Expose({ name: "urlRedirectWalledGardenEnabled" })
  urlRedirectWalledGardenEnabled?: boolean;

  /**
   * IP address ranges, in CIDR notation, to restrict access for clients to a specific set of IP addresses or hostnames prior to authentication
   */
  @SpeakeasyMetadata()
  @Expose({ name: "urlRedirectWalledGardenRanges" })
  urlRedirectWalledGardenRanges?: string[];

  /**
   * CDP/LLDP capable voice clients will be able to use this VLAN. Automatically true when hostMode is 'Multi-Domain'.
   */
  @SpeakeasyMetadata()
  @Expose({ name: "voiceVlanClients" })
  voiceVlanClients?: boolean;
}

export class UpdateNetworkSwitchAccessPolicyResponse extends SpeakeasyBase {
  @SpeakeasyMetadata()
  contentType: string;

  @SpeakeasyMetadata()
  statusCode: number;

  @SpeakeasyMetadata()
  rawResponse?: AxiosResponse;

  /**
   * Successful operation
   */
  @SpeakeasyMetadata()
  updateNetworkSwitchAccessPolicy200ApplicationJSONObject?: UpdateNetworkSwitchAccessPolicy200ApplicationJSON;
}
