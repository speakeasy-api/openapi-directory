/*
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

import * as utils from "../internal/utils";
import * as operations from "./models/operations";
import * as shared from "./models/shared";
import { AxiosInstance, AxiosRequestConfig, AxiosResponse } from "axios";

/**
 * API methods responsible for managing conference rooms
 */
export class Conference {
  _defaultClient: AxiosInstance;
  _securityClient: AxiosInstance;
  _serverURL: string;
  _language: string;
  _sdkVersion: string;
  _genVersion: string;

  constructor(
    defaultClient: AxiosInstance,
    securityClient: AxiosInstance,
    serverURL: string,
    language: string,
    sdkVersion: string,
    genVersion: string
  ) {
    this._defaultClient = defaultClient;
    this._securityClient = securityClient;
    this._serverURL = serverURL;
    this._language = language;
    this._sdkVersion = sdkVersion;
    this._genVersion = genVersion;
  }

  /**
   * /v0.1/ConferenceDeaf/
   *
   * @remarks
   * Blocks audio to one or more conference members
   */
  postV01ConferenceDeaf(
    req: shared.ConferenceDeafParameters,
    security: operations.PostV01ConferenceDeafSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.PostV01ConferenceDeafResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new shared.ConferenceDeafParameters(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/v0.1/ConferenceDeaf/";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "request",
        "form"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.PostV01ConferenceDeafSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PostV01ConferenceDeafResponse =
        new operations.PostV01ConferenceDeafResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.conferenceDeafResponse = utils.objectToClass(
              httpRes?.data,
              shared.ConferenceDeafResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * /v0.1/ConferenceHangup/
   *
   * @remarks
   * Kicks one or more conference members, without playing the kick sound
   */
  postV01ConferenceHangup(
    req: shared.ConferenceHangupParameters,
    security: operations.PostV01ConferenceHangupSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.PostV01ConferenceHangupResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new shared.ConferenceHangupParameters(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/v0.1/ConferenceHangup/";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "request",
        "form"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.PostV01ConferenceHangupSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PostV01ConferenceHangupResponse =
        new operations.PostV01ConferenceHangupResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.conferenceHangupResponse = utils.objectToClass(
              httpRes?.data,
              shared.ConferenceHangupResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * /v0.1/ConferenceKick/
   *
   * @remarks
   * Kicks one or more conference members
   */
  postV01ConferenceKick(
    req: shared.ConferenceKickParameters,
    security: operations.PostV01ConferenceKickSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.PostV01ConferenceKickResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new shared.ConferenceKickParameters(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/v0.1/ConferenceKick/";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "request",
        "form"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.PostV01ConferenceKickSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PostV01ConferenceKickResponse =
        new operations.PostV01ConferenceKickResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.conferenceKickResponse = utils.objectToClass(
              httpRes?.data,
              shared.ConferenceKickResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * /v0.1/ConferenceList/
   *
   * @remarks
   * Returns a list of all established conferences
   */
  postV01ConferenceList(
    req: shared.ConferenceListParameters,
    security: operations.PostV01ConferenceListSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.PostV01ConferenceListResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new shared.ConferenceListParameters(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/v0.1/ConferenceList/";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "request",
        "form"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.PostV01ConferenceListSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PostV01ConferenceListResponse =
        new operations.PostV01ConferenceListResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.conferenceListResponse = utils.objectToClass(
              httpRes?.data,
              shared.ConferenceListResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * /v0.1/ConferenceListMembers/
   *
   * @remarks
   * Retrieves the member list for a given conference
   */
  postV01ConferenceListMembers(
    req: shared.ConferenceListMembersParameters,
    security: operations.PostV01ConferenceListMembersSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.PostV01ConferenceListMembersResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new shared.ConferenceListMembersParameters(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/v0.1/ConferenceListMembers/";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "request",
        "form"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.PostV01ConferenceListMembersSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PostV01ConferenceListMembersResponse =
        new operations.PostV01ConferenceListMembersResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.conferenceListMembersResponse = utils.objectToClass(
              httpRes?.data,
              shared.ConferenceListMembersResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * /v0.1/ConferenceMute/
   *
   * @remarks
   * Blocks audio from one or more conference members
   */
  postV01ConferenceMute(
    req: shared.ConferenceMuteParameters,
    security: operations.PostV01ConferenceMuteSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.PostV01ConferenceMuteResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new shared.ConferenceMuteParameters(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/v0.1/ConferenceMute/";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "request",
        "form"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.PostV01ConferenceMuteSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PostV01ConferenceMuteResponse =
        new operations.PostV01ConferenceMuteResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.conferenceMuteResponse = utils.objectToClass(
              httpRes?.data,
              shared.ConferenceMuteResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * /v0.1/ConferencePlay/
   *
   * @remarks
   * Plays media to one or more conference members
   */
  postV01ConferencePlay(
    req: shared.ConferencePlayParameters,
    security: operations.PostV01ConferencePlaySecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.PostV01ConferencePlayResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new shared.ConferencePlayParameters(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/v0.1/ConferencePlay/";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "request",
        "form"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.PostV01ConferencePlaySecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PostV01ConferencePlayResponse =
        new operations.PostV01ConferencePlayResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.conferencePlayResponse = utils.objectToClass(
              httpRes?.data,
              shared.ConferencePlayResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * /v0.1/ConferenceRecordStart/
   *
   * @remarks
   * Initiates a conference recording
   */
  postV01ConferenceRecordStart(
    req: shared.ConferenceRecordStartParameters,
    security: operations.PostV01ConferenceRecordStartSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.PostV01ConferenceRecordStartResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new shared.ConferenceRecordStartParameters(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/v0.1/ConferenceRecordStart/";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "request",
        "form"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.PostV01ConferenceRecordStartSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PostV01ConferenceRecordStartResponse =
        new operations.PostV01ConferenceRecordStartResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.conferenceRecordStartResponse = utils.objectToClass(
              httpRes?.data,
              shared.ConferenceRecordStartResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * /v0.1/ConferenceRecordStop/
   *
   * @remarks
   * Stops a conference recording
   */
  postV01ConferenceRecordStop(
    req: shared.ConferenceRecordStopParameters,
    security: operations.PostV01ConferenceRecordStopSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.PostV01ConferenceRecordStopResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new shared.ConferenceRecordStopParameters(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/v0.1/ConferenceRecordStop/";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "request",
        "form"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.PostV01ConferenceRecordStopSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PostV01ConferenceRecordStopResponse =
        new operations.PostV01ConferenceRecordStopResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.conferenceRecordStopResponse = utils.objectToClass(
              httpRes?.data,
              shared.ConferenceRecordStopResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * /v0.1/ConferenceSpeak/
   *
   * @remarks
   * Plays synthesized speech into a conference
   */
  postV01ConferenceSpeak(
    req: shared.ConferenceSpeakParameters,
    security: operations.PostV01ConferenceSpeakSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.PostV01ConferenceSpeakResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new shared.ConferenceSpeakParameters(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/v0.1/ConferenceSpeak/";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "request",
        "form"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.PostV01ConferenceSpeakSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PostV01ConferenceSpeakResponse =
        new operations.PostV01ConferenceSpeakResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.conferenceSpeakResponse = utils.objectToClass(
              httpRes?.data,
              shared.ConferenceSpeakResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * /v0.1/ConferenceUndeaf/
   *
   * @remarks
   * Restores audio to one or more conference members
   */
  postV01ConferenceUndeaf(
    req: shared.ConferenceUndeafParameters,
    security: operations.PostV01ConferenceUndeafSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.PostV01ConferenceUndeafResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new shared.ConferenceUndeafParameters(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/v0.1/ConferenceUndeaf/";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "request",
        "form"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.PostV01ConferenceUndeafSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PostV01ConferenceUndeafResponse =
        new operations.PostV01ConferenceUndeafResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.conferenceUndeafResponse = utils.objectToClass(
              httpRes?.data,
              shared.ConferenceUndeafResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * /v0.1/ConferenceUnmute/
   *
   * @remarks
   * Restores audio from one or more conference members
   */
  postV01ConferenceUnmute(
    req: shared.ConferenceUnmuteParameters,
    security: operations.PostV01ConferenceUnmuteSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.PostV01ConferenceUnmuteResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new shared.ConferenceUnmuteParameters(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/v0.1/ConferenceUnmute/";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "request",
        "form"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.PostV01ConferenceUnmuteSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PostV01ConferenceUnmuteResponse =
        new operations.PostV01ConferenceUnmuteResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.conferenceUnmuteResponse = utils.objectToClass(
              httpRes?.data,
              shared.ConferenceUnmuteResponse
            );
          }
          break;
      }

      return res;
    });
  }
}
