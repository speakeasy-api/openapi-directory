"""Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT."""

import requests as requests_http
from . import utils
from sdk.models import operations, shared
from typing import Any, Optional

class Projects:
    _client: requests_http.Session
    _security_client: requests_http.Session
    _server_url: str
    _language: str
    _sdk_version: str
    _gen_version: str

    def __init__(self, client: requests_http.Session, security_client: requests_http.Session, server_url: str, language: str, sdk_version: str, gen_version: str) -> None:
        self._client = client
        self._security_client = security_client
        self._server_url = server_url
        self._language = language
        self._sdk_version = sdk_version
        self._gen_version = gen_version
        
    def managedidentities_projects_locations_global_domains_attach_trust(self, request: operations.ManagedidentitiesProjectsLocationsGlobalDomainsAttachTrustRequest, security: operations.ManagedidentitiesProjectsLocationsGlobalDomainsAttachTrustSecurity) -> operations.ManagedidentitiesProjectsLocationsGlobalDomainsAttachTrustResponse:
        r"""Adds an AD trust to a domain."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.ManagedidentitiesProjectsLocationsGlobalDomainsAttachTrustRequest, base_url, '/v1/{name}:attachTrust', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "attach_trust_request_input", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        query_params = utils.get_query_params(operations.ManagedidentitiesProjectsLocationsGlobalDomainsAttachTrustRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, params=query_params, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ManagedidentitiesProjectsLocationsGlobalDomainsAttachTrustResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Operation])
                res.operation = out

        return res

    def managedidentities_projects_locations_global_domains_backups_create(self, request: operations.ManagedidentitiesProjectsLocationsGlobalDomainsBackupsCreateRequest, security: operations.ManagedidentitiesProjectsLocationsGlobalDomainsBackupsCreateSecurity) -> operations.ManagedidentitiesProjectsLocationsGlobalDomainsBackupsCreateResponse:
        r"""Creates a Backup for a domain."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.ManagedidentitiesProjectsLocationsGlobalDomainsBackupsCreateRequest, base_url, '/v1/{parent}/backups', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "backup_input", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        query_params = utils.get_query_params(operations.ManagedidentitiesProjectsLocationsGlobalDomainsBackupsCreateRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, params=query_params, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ManagedidentitiesProjectsLocationsGlobalDomainsBackupsCreateResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Operation])
                res.operation = out

        return res

    def managedidentities_projects_locations_global_domains_backups_list(self, request: operations.ManagedidentitiesProjectsLocationsGlobalDomainsBackupsListRequest, security: operations.ManagedidentitiesProjectsLocationsGlobalDomainsBackupsListSecurity) -> operations.ManagedidentitiesProjectsLocationsGlobalDomainsBackupsListResponse:
        r"""Lists Backup in a given project."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.ManagedidentitiesProjectsLocationsGlobalDomainsBackupsListRequest, base_url, '/v1/{parent}/backups', request)
        
        query_params = utils.get_query_params(operations.ManagedidentitiesProjectsLocationsGlobalDomainsBackupsListRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ManagedidentitiesProjectsLocationsGlobalDomainsBackupsListResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ListBackupsResponse])
                res.list_backups_response = out

        return res

    def managedidentities_projects_locations_global_domains_create(self, request: operations.ManagedidentitiesProjectsLocationsGlobalDomainsCreateRequest, security: operations.ManagedidentitiesProjectsLocationsGlobalDomainsCreateSecurity) -> operations.ManagedidentitiesProjectsLocationsGlobalDomainsCreateResponse:
        r"""Creates a Microsoft AD domain."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.ManagedidentitiesProjectsLocationsGlobalDomainsCreateRequest, base_url, '/v1/{parent}/domains', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "domain_input", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        query_params = utils.get_query_params(operations.ManagedidentitiesProjectsLocationsGlobalDomainsCreateRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, params=query_params, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ManagedidentitiesProjectsLocationsGlobalDomainsCreateResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Operation])
                res.operation = out

        return res

    def managedidentities_projects_locations_global_domains_detach_trust(self, request: operations.ManagedidentitiesProjectsLocationsGlobalDomainsDetachTrustRequest, security: operations.ManagedidentitiesProjectsLocationsGlobalDomainsDetachTrustSecurity) -> operations.ManagedidentitiesProjectsLocationsGlobalDomainsDetachTrustResponse:
        r"""Removes an AD trust."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.ManagedidentitiesProjectsLocationsGlobalDomainsDetachTrustRequest, base_url, '/v1/{name}:detachTrust', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "detach_trust_request_input", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        query_params = utils.get_query_params(operations.ManagedidentitiesProjectsLocationsGlobalDomainsDetachTrustRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, params=query_params, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ManagedidentitiesProjectsLocationsGlobalDomainsDetachTrustResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Operation])
                res.operation = out

        return res

    def managedidentities_projects_locations_global_domains_extend_schema(self, request: operations.ManagedidentitiesProjectsLocationsGlobalDomainsExtendSchemaRequest, security: operations.ManagedidentitiesProjectsLocationsGlobalDomainsExtendSchemaSecurity) -> operations.ManagedidentitiesProjectsLocationsGlobalDomainsExtendSchemaResponse:
        r"""Extend Schema for Domain"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.ManagedidentitiesProjectsLocationsGlobalDomainsExtendSchemaRequest, base_url, '/v1/{domain}:extendSchema', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "extend_schema_request", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        query_params = utils.get_query_params(operations.ManagedidentitiesProjectsLocationsGlobalDomainsExtendSchemaRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, params=query_params, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ManagedidentitiesProjectsLocationsGlobalDomainsExtendSchemaResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Operation])
                res.operation = out

        return res

    def managedidentities_projects_locations_global_domains_get_ldapssettings(self, request: operations.ManagedidentitiesProjectsLocationsGlobalDomainsGetLdapssettingsRequest, security: operations.ManagedidentitiesProjectsLocationsGlobalDomainsGetLdapssettingsSecurity) -> operations.ManagedidentitiesProjectsLocationsGlobalDomainsGetLdapssettingsResponse:
        r"""Gets the domain ldaps settings."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.ManagedidentitiesProjectsLocationsGlobalDomainsGetLdapssettingsRequest, base_url, '/v1/{name}/ldapssettings', request)
        
        query_params = utils.get_query_params(operations.ManagedidentitiesProjectsLocationsGlobalDomainsGetLdapssettingsRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ManagedidentitiesProjectsLocationsGlobalDomainsGetLdapssettingsResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.LDAPSSettings])
                res.ldaps_settings = out

        return res

    def managedidentities_projects_locations_global_domains_list(self, request: operations.ManagedidentitiesProjectsLocationsGlobalDomainsListRequest, security: operations.ManagedidentitiesProjectsLocationsGlobalDomainsListSecurity) -> operations.ManagedidentitiesProjectsLocationsGlobalDomainsListResponse:
        r"""Lists domains in a project."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.ManagedidentitiesProjectsLocationsGlobalDomainsListRequest, base_url, '/v1/{parent}/domains', request)
        
        query_params = utils.get_query_params(operations.ManagedidentitiesProjectsLocationsGlobalDomainsListRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ManagedidentitiesProjectsLocationsGlobalDomainsListResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ListDomainsResponse])
                res.list_domains_response = out

        return res

    def managedidentities_projects_locations_global_domains_reconfigure_trust(self, request: operations.ManagedidentitiesProjectsLocationsGlobalDomainsReconfigureTrustRequest, security: operations.ManagedidentitiesProjectsLocationsGlobalDomainsReconfigureTrustSecurity) -> operations.ManagedidentitiesProjectsLocationsGlobalDomainsReconfigureTrustResponse:
        r"""Updates the DNS conditional forwarder."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.ManagedidentitiesProjectsLocationsGlobalDomainsReconfigureTrustRequest, base_url, '/v1/{name}:reconfigureTrust', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "reconfigure_trust_request", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        query_params = utils.get_query_params(operations.ManagedidentitiesProjectsLocationsGlobalDomainsReconfigureTrustRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, params=query_params, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ManagedidentitiesProjectsLocationsGlobalDomainsReconfigureTrustResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Operation])
                res.operation = out

        return res

    def managedidentities_projects_locations_global_domains_reset_admin_password(self, request: operations.ManagedidentitiesProjectsLocationsGlobalDomainsResetAdminPasswordRequest, security: operations.ManagedidentitiesProjectsLocationsGlobalDomainsResetAdminPasswordSecurity) -> operations.ManagedidentitiesProjectsLocationsGlobalDomainsResetAdminPasswordResponse:
        r"""Resets a domain's administrator password."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.ManagedidentitiesProjectsLocationsGlobalDomainsResetAdminPasswordRequest, base_url, '/v1/{name}:resetAdminPassword', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        query_params = utils.get_query_params(operations.ManagedidentitiesProjectsLocationsGlobalDomainsResetAdminPasswordRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, params=query_params, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ManagedidentitiesProjectsLocationsGlobalDomainsResetAdminPasswordResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ResetAdminPasswordResponse])
                res.reset_admin_password_response = out

        return res

    def managedidentities_projects_locations_global_domains_restore(self, request: operations.ManagedidentitiesProjectsLocationsGlobalDomainsRestoreRequest, security: operations.ManagedidentitiesProjectsLocationsGlobalDomainsRestoreSecurity) -> operations.ManagedidentitiesProjectsLocationsGlobalDomainsRestoreResponse:
        r"""RestoreDomain restores domain backup mentioned in the RestoreDomainRequest"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.ManagedidentitiesProjectsLocationsGlobalDomainsRestoreRequest, base_url, '/v1/{name}:restore', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "restore_domain_request", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        query_params = utils.get_query_params(operations.ManagedidentitiesProjectsLocationsGlobalDomainsRestoreRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, params=query_params, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ManagedidentitiesProjectsLocationsGlobalDomainsRestoreResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Operation])
                res.operation = out

        return res

    def managedidentities_projects_locations_global_domains_sql_integrations_list(self, request: operations.ManagedidentitiesProjectsLocationsGlobalDomainsSQLIntegrationsListRequest, security: operations.ManagedidentitiesProjectsLocationsGlobalDomainsSQLIntegrationsListSecurity) -> operations.ManagedidentitiesProjectsLocationsGlobalDomainsSQLIntegrationsListResponse:
        r"""Lists SqlIntegrations in a given domain."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.ManagedidentitiesProjectsLocationsGlobalDomainsSQLIntegrationsListRequest, base_url, '/v1/{parent}/sqlIntegrations', request)
        
        query_params = utils.get_query_params(operations.ManagedidentitiesProjectsLocationsGlobalDomainsSQLIntegrationsListRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ManagedidentitiesProjectsLocationsGlobalDomainsSQLIntegrationsListResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ListSQLIntegrationsResponse])
                res.list_sql_integrations_response = out

        return res

    def managedidentities_projects_locations_global_domains_update_ldapssettings(self, request: operations.ManagedidentitiesProjectsLocationsGlobalDomainsUpdateLdapssettingsRequest, security: operations.ManagedidentitiesProjectsLocationsGlobalDomainsUpdateLdapssettingsSecurity) -> operations.ManagedidentitiesProjectsLocationsGlobalDomainsUpdateLdapssettingsResponse:
        r"""Patches a single ldaps settings."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.ManagedidentitiesProjectsLocationsGlobalDomainsUpdateLdapssettingsRequest, base_url, '/v1/{name}/ldapssettings', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "ldaps_settings_input", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        query_params = utils.get_query_params(operations.ManagedidentitiesProjectsLocationsGlobalDomainsUpdateLdapssettingsRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('PATCH', url, params=query_params, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ManagedidentitiesProjectsLocationsGlobalDomainsUpdateLdapssettingsResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Operation])
                res.operation = out

        return res

    def managedidentities_projects_locations_global_domains_validate_trust(self, request: operations.ManagedidentitiesProjectsLocationsGlobalDomainsValidateTrustRequest, security: operations.ManagedidentitiesProjectsLocationsGlobalDomainsValidateTrustSecurity) -> operations.ManagedidentitiesProjectsLocationsGlobalDomainsValidateTrustResponse:
        r"""Validates a trust state, that the target domain is reachable, and that the target domain is able to accept incoming trust requests."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.ManagedidentitiesProjectsLocationsGlobalDomainsValidateTrustRequest, base_url, '/v1/{name}:validateTrust', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "validate_trust_request_input", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        query_params = utils.get_query_params(operations.ManagedidentitiesProjectsLocationsGlobalDomainsValidateTrustRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, params=query_params, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ManagedidentitiesProjectsLocationsGlobalDomainsValidateTrustResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Operation])
                res.operation = out

        return res

    def managedidentities_projects_locations_global_operations_cancel(self, request: operations.ManagedidentitiesProjectsLocationsGlobalOperationsCancelRequest, security: operations.ManagedidentitiesProjectsLocationsGlobalOperationsCancelSecurity) -> operations.ManagedidentitiesProjectsLocationsGlobalOperationsCancelResponse:
        r"""Starts asynchronous cancellation on a long-running operation. The server makes a best effort to cancel the operation, but success is not guaranteed. If the server doesn't support this method, it returns `google.rpc.Code.UNIMPLEMENTED`. Clients can use Operations.GetOperation or other methods to check whether the cancellation succeeded or whether the operation completed despite cancellation. On successful cancellation, the operation is not deleted; instead, it becomes an operation with an Operation.error value with a google.rpc.Status.code of 1, corresponding to `Code.CANCELLED`."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.ManagedidentitiesProjectsLocationsGlobalOperationsCancelRequest, base_url, '/v1/{name}:cancel', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        query_params = utils.get_query_params(operations.ManagedidentitiesProjectsLocationsGlobalOperationsCancelRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, params=query_params, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ManagedidentitiesProjectsLocationsGlobalOperationsCancelResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[dict[str, Any]])
                res.empty = out

        return res

    def managedidentities_projects_locations_global_peerings_create(self, request: operations.ManagedidentitiesProjectsLocationsGlobalPeeringsCreateRequest, security: operations.ManagedidentitiesProjectsLocationsGlobalPeeringsCreateSecurity) -> operations.ManagedidentitiesProjectsLocationsGlobalPeeringsCreateResponse:
        r"""Creates a Peering for Managed AD instance."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.ManagedidentitiesProjectsLocationsGlobalPeeringsCreateRequest, base_url, '/v1/{parent}/peerings', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "peering_input", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        query_params = utils.get_query_params(operations.ManagedidentitiesProjectsLocationsGlobalPeeringsCreateRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, params=query_params, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ManagedidentitiesProjectsLocationsGlobalPeeringsCreateResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Operation])
                res.operation = out

        return res

    def managedidentities_projects_locations_global_peerings_delete(self, request: operations.ManagedidentitiesProjectsLocationsGlobalPeeringsDeleteRequest, security: operations.ManagedidentitiesProjectsLocationsGlobalPeeringsDeleteSecurity) -> operations.ManagedidentitiesProjectsLocationsGlobalPeeringsDeleteResponse:
        r"""Deletes identified Peering."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.ManagedidentitiesProjectsLocationsGlobalPeeringsDeleteRequest, base_url, '/v1/{name}', request)
        
        query_params = utils.get_query_params(operations.ManagedidentitiesProjectsLocationsGlobalPeeringsDeleteRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('DELETE', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ManagedidentitiesProjectsLocationsGlobalPeeringsDeleteResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Operation])
                res.operation = out

        return res

    def managedidentities_projects_locations_global_peerings_get(self, request: operations.ManagedidentitiesProjectsLocationsGlobalPeeringsGetRequest, security: operations.ManagedidentitiesProjectsLocationsGlobalPeeringsGetSecurity) -> operations.ManagedidentitiesProjectsLocationsGlobalPeeringsGetResponse:
        r"""Gets details of a single Peering."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.ManagedidentitiesProjectsLocationsGlobalPeeringsGetRequest, base_url, '/v1/{name}', request)
        
        query_params = utils.get_query_params(operations.ManagedidentitiesProjectsLocationsGlobalPeeringsGetRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ManagedidentitiesProjectsLocationsGlobalPeeringsGetResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Peering])
                res.peering = out

        return res

    def managedidentities_projects_locations_global_peerings_get_iam_policy(self, request: operations.ManagedidentitiesProjectsLocationsGlobalPeeringsGetIamPolicyRequest, security: operations.ManagedidentitiesProjectsLocationsGlobalPeeringsGetIamPolicySecurity) -> operations.ManagedidentitiesProjectsLocationsGlobalPeeringsGetIamPolicyResponse:
        r"""Gets the access control policy for a resource. Returns an empty policy if the resource exists and does not have a policy set."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.ManagedidentitiesProjectsLocationsGlobalPeeringsGetIamPolicyRequest, base_url, '/v1/{resource}:getIamPolicy', request)
        
        query_params = utils.get_query_params(operations.ManagedidentitiesProjectsLocationsGlobalPeeringsGetIamPolicyRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ManagedidentitiesProjectsLocationsGlobalPeeringsGetIamPolicyResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Policy])
                res.policy = out

        return res

    def managedidentities_projects_locations_global_peerings_list(self, request: operations.ManagedidentitiesProjectsLocationsGlobalPeeringsListRequest, security: operations.ManagedidentitiesProjectsLocationsGlobalPeeringsListSecurity) -> operations.ManagedidentitiesProjectsLocationsGlobalPeeringsListResponse:
        r"""Lists Peerings in a given project."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.ManagedidentitiesProjectsLocationsGlobalPeeringsListRequest, base_url, '/v1/{parent}/peerings', request)
        
        query_params = utils.get_query_params(operations.ManagedidentitiesProjectsLocationsGlobalPeeringsListRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ManagedidentitiesProjectsLocationsGlobalPeeringsListResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ListPeeringsResponse])
                res.list_peerings_response = out

        return res

    def managedidentities_projects_locations_global_peerings_patch(self, request: operations.ManagedidentitiesProjectsLocationsGlobalPeeringsPatchRequest, security: operations.ManagedidentitiesProjectsLocationsGlobalPeeringsPatchSecurity) -> operations.ManagedidentitiesProjectsLocationsGlobalPeeringsPatchResponse:
        r"""Updates the labels for specified Peering."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.ManagedidentitiesProjectsLocationsGlobalPeeringsPatchRequest, base_url, '/v1/{name}', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "peering_input", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        query_params = utils.get_query_params(operations.ManagedidentitiesProjectsLocationsGlobalPeeringsPatchRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('PATCH', url, params=query_params, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ManagedidentitiesProjectsLocationsGlobalPeeringsPatchResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Operation])
                res.operation = out

        return res

    def managedidentities_projects_locations_global_peerings_set_iam_policy(self, request: operations.ManagedidentitiesProjectsLocationsGlobalPeeringsSetIamPolicyRequest, security: operations.ManagedidentitiesProjectsLocationsGlobalPeeringsSetIamPolicySecurity) -> operations.ManagedidentitiesProjectsLocationsGlobalPeeringsSetIamPolicyResponse:
        r"""Sets the access control policy on the specified resource. Replaces any existing policy. Can return `NOT_FOUND`, `INVALID_ARGUMENT`, and `PERMISSION_DENIED` errors."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.ManagedidentitiesProjectsLocationsGlobalPeeringsSetIamPolicyRequest, base_url, '/v1/{resource}:setIamPolicy', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "set_iam_policy_request", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        query_params = utils.get_query_params(operations.ManagedidentitiesProjectsLocationsGlobalPeeringsSetIamPolicyRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, params=query_params, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ManagedidentitiesProjectsLocationsGlobalPeeringsSetIamPolicyResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Policy])
                res.policy = out

        return res

    def managedidentities_projects_locations_global_peerings_test_iam_permissions(self, request: operations.ManagedidentitiesProjectsLocationsGlobalPeeringsTestIamPermissionsRequest, security: operations.ManagedidentitiesProjectsLocationsGlobalPeeringsTestIamPermissionsSecurity) -> operations.ManagedidentitiesProjectsLocationsGlobalPeeringsTestIamPermissionsResponse:
        r"""Returns permissions that a caller has on the specified resource. If the resource does not exist, this will return an empty set of permissions, not a `NOT_FOUND` error. Note: This operation is designed to be used for building permission-aware UIs and command-line tools, not for authorization checking. This operation may \\"fail open\\" without warning."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.ManagedidentitiesProjectsLocationsGlobalPeeringsTestIamPermissionsRequest, base_url, '/v1/{resource}:testIamPermissions', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "test_iam_permissions_request", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        query_params = utils.get_query_params(operations.ManagedidentitiesProjectsLocationsGlobalPeeringsTestIamPermissionsRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, params=query_params, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ManagedidentitiesProjectsLocationsGlobalPeeringsTestIamPermissionsResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.TestIamPermissionsResponse])
                res.test_iam_permissions_response = out

        return res

    def managedidentities_projects_locations_list(self, request: operations.ManagedidentitiesProjectsLocationsListRequest, security: operations.ManagedidentitiesProjectsLocationsListSecurity) -> operations.ManagedidentitiesProjectsLocationsListResponse:
        r"""Lists information about the supported locations for this service."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.ManagedidentitiesProjectsLocationsListRequest, base_url, '/v1/{name}/locations', request)
        
        query_params = utils.get_query_params(operations.ManagedidentitiesProjectsLocationsListRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ManagedidentitiesProjectsLocationsListResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ListLocationsResponse])
                res.list_locations_response = out

        return res

    