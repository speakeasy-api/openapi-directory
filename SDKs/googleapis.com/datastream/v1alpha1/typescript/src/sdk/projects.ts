/*
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

import * as utils from "../internal/utils";
import * as operations from "./models/operations";
import * as shared from "./models/shared";
import { AxiosInstance, AxiosRequestConfig, AxiosResponse } from "axios";

export class Projects {
  _defaultClient: AxiosInstance;
  _securityClient: AxiosInstance;
  _serverURL: string;
  _language: string;
  _sdkVersion: string;
  _genVersion: string;

  constructor(
    defaultClient: AxiosInstance,
    securityClient: AxiosInstance,
    serverURL: string,
    language: string,
    sdkVersion: string,
    genVersion: string
  ) {
    this._defaultClient = defaultClient;
    this._securityClient = securityClient;
    this._serverURL = serverURL;
    this._language = language;
    this._sdkVersion = sdkVersion;
    this._genVersion = genVersion;
  }

  /**
   * Use this method to create a connection profile in a project and location.
   */
  datastreamProjectsLocationsConnectionProfilesCreate(
    req: operations.DatastreamProjectsLocationsConnectionProfilesCreateRequest,
    security: operations.DatastreamProjectsLocationsConnectionProfilesCreateSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.DatastreamProjectsLocationsConnectionProfilesCreateResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.DatastreamProjectsLocationsConnectionProfilesCreateRequest(
          req
        );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v1alpha1/{parent}/connectionProfiles",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "connectionProfileInput",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.DatastreamProjectsLocationsConnectionProfilesCreateSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DatastreamProjectsLocationsConnectionProfilesCreateResponse =
        new operations.DatastreamProjectsLocationsConnectionProfilesCreateResponse(
          {
            statusCode: httpRes.status,
            contentType: contentType,
            rawResponse: httpRes,
          }
        );
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.operation = utils.objectToClass(
              httpRes?.data,
              shared.Operation
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Use this method to discover a connection profile. The discover API call exposes the data objects and metadata belonging to the profile. Typically, a request returns children data objects under a parent data object that's optionally supplied in the request.
   */
  datastreamProjectsLocationsConnectionProfilesDiscover(
    req: operations.DatastreamProjectsLocationsConnectionProfilesDiscoverRequest,
    security: operations.DatastreamProjectsLocationsConnectionProfilesDiscoverSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.DatastreamProjectsLocationsConnectionProfilesDiscoverResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.DatastreamProjectsLocationsConnectionProfilesDiscoverRequest(
          req
        );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v1alpha1/{parent}/connectionProfiles:discover",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "discoverConnectionProfileRequestInput",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.DatastreamProjectsLocationsConnectionProfilesDiscoverSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DatastreamProjectsLocationsConnectionProfilesDiscoverResponse =
        new operations.DatastreamProjectsLocationsConnectionProfilesDiscoverResponse(
          {
            statusCode: httpRes.status,
            contentType: contentType,
            rawResponse: httpRes,
          }
        );
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.discoverConnectionProfileResponse = utils.objectToClass(
              httpRes?.data,
              shared.DiscoverConnectionProfileResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Use this method to list connection profiles created in a project and location.
   */
  datastreamProjectsLocationsConnectionProfilesList(
    req: operations.DatastreamProjectsLocationsConnectionProfilesListRequest,
    security: operations.DatastreamProjectsLocationsConnectionProfilesListSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.DatastreamProjectsLocationsConnectionProfilesListResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.DatastreamProjectsLocationsConnectionProfilesListRequest(
          req
        );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v1alpha1/{parent}/connectionProfiles",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.DatastreamProjectsLocationsConnectionProfilesListSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DatastreamProjectsLocationsConnectionProfilesListResponse =
        new operations.DatastreamProjectsLocationsConnectionProfilesListResponse(
          {
            statusCode: httpRes.status,
            contentType: contentType,
            rawResponse: httpRes,
          }
        );
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listConnectionProfilesResponse = utils.objectToClass(
              httpRes?.data,
              shared.ListConnectionProfilesResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * The FetchStaticIps API call exposes the static IP addresses used by Datastream.
   */
  datastreamProjectsLocationsFetchStaticIps(
    req: operations.DatastreamProjectsLocationsFetchStaticIpsRequest,
    security: operations.DatastreamProjectsLocationsFetchStaticIpsSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.DatastreamProjectsLocationsFetchStaticIpsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DatastreamProjectsLocationsFetchStaticIpsRequest(
        req
      );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v1alpha1/{name}:fetchStaticIps",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.DatastreamProjectsLocationsFetchStaticIpsSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DatastreamProjectsLocationsFetchStaticIpsResponse =
        new operations.DatastreamProjectsLocationsFetchStaticIpsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.fetchStaticIpsResponse = utils.objectToClass(
              httpRes?.data,
              shared.FetchStaticIpsResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Lists information about the supported locations for this service.
   */
  datastreamProjectsLocationsList(
    req: operations.DatastreamProjectsLocationsListRequest,
    security: operations.DatastreamProjectsLocationsListSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.DatastreamProjectsLocationsListResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DatastreamProjectsLocationsListRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v1alpha1/{name}/locations",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.DatastreamProjectsLocationsListSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DatastreamProjectsLocationsListResponse =
        new operations.DatastreamProjectsLocationsListResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listLocationsResponse = utils.objectToClass(
              httpRes?.data,
              shared.ListLocationsResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Starts asynchronous cancellation on a long-running operation. The server makes a best effort to cancel the operation, but success is not guaranteed. If the server doesn't support this method, it returns `google.rpc.Code.UNIMPLEMENTED`. Clients can use Operations.GetOperation or other methods to check whether the cancellation succeeded or whether the operation completed despite cancellation. On successful cancellation, the operation is not deleted; instead, it becomes an operation with an Operation.error value with a google.rpc.Status.code of 1, corresponding to `Code.CANCELLED`.
   */
  datastreamProjectsLocationsOperationsCancel(
    req: operations.DatastreamProjectsLocationsOperationsCancelRequest,
    security: operations.DatastreamProjectsLocationsOperationsCancelSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.DatastreamProjectsLocationsOperationsCancelResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DatastreamProjectsLocationsOperationsCancelRequest(
        req
      );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v1alpha1/{name}:cancel",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.DatastreamProjectsLocationsOperationsCancelSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DatastreamProjectsLocationsOperationsCancelResponse =
        new operations.DatastreamProjectsLocationsOperationsCancelResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.empty = utils.objectToClass(httpRes?.data);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Lists operations that match the specified filter in the request. If the server doesn't support this method, it returns `UNIMPLEMENTED`.
   */
  datastreamProjectsLocationsOperationsList(
    req: operations.DatastreamProjectsLocationsOperationsListRequest,
    security: operations.DatastreamProjectsLocationsOperationsListSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.DatastreamProjectsLocationsOperationsListResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DatastreamProjectsLocationsOperationsListRequest(
        req
      );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v1alpha1/{name}/operations",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.DatastreamProjectsLocationsOperationsListSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DatastreamProjectsLocationsOperationsListResponse =
        new operations.DatastreamProjectsLocationsOperationsListResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listOperationsResponse = utils.objectToClass(
              httpRes?.data,
              shared.ListOperationsResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Use this method to create a private connectivity configuration.
   */
  datastreamProjectsLocationsPrivateConnectionsCreate(
    req: operations.DatastreamProjectsLocationsPrivateConnectionsCreateRequest,
    security: operations.DatastreamProjectsLocationsPrivateConnectionsCreateSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.DatastreamProjectsLocationsPrivateConnectionsCreateResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.DatastreamProjectsLocationsPrivateConnectionsCreateRequest(
          req
        );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v1alpha1/{parent}/privateConnections",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "privateConnectionInput",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.DatastreamProjectsLocationsPrivateConnectionsCreateSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DatastreamProjectsLocationsPrivateConnectionsCreateResponse =
        new operations.DatastreamProjectsLocationsPrivateConnectionsCreateResponse(
          {
            statusCode: httpRes.status,
            contentType: contentType,
            rawResponse: httpRes,
          }
        );
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.operation = utils.objectToClass(
              httpRes?.data,
              shared.Operation
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Use this method to list private connectivity configurations in a project and location.
   */
  datastreamProjectsLocationsPrivateConnectionsList(
    req: operations.DatastreamProjectsLocationsPrivateConnectionsListRequest,
    security: operations.DatastreamProjectsLocationsPrivateConnectionsListSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.DatastreamProjectsLocationsPrivateConnectionsListResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.DatastreamProjectsLocationsPrivateConnectionsListRequest(
          req
        );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v1alpha1/{parent}/privateConnections",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.DatastreamProjectsLocationsPrivateConnectionsListSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DatastreamProjectsLocationsPrivateConnectionsListResponse =
        new operations.DatastreamProjectsLocationsPrivateConnectionsListResponse(
          {
            statusCode: httpRes.status,
            contentType: contentType,
            rawResponse: httpRes,
          }
        );
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listPrivateConnectionsResponse = utils.objectToClass(
              httpRes?.data,
              shared.ListPrivateConnectionsResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Use this method to create a route for a private connectivity in a project and location.
   */
  datastreamProjectsLocationsPrivateConnectionsRoutesCreate(
    req: operations.DatastreamProjectsLocationsPrivateConnectionsRoutesCreateRequest,
    security: operations.DatastreamProjectsLocationsPrivateConnectionsRoutesCreateSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.DatastreamProjectsLocationsPrivateConnectionsRoutesCreateResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.DatastreamProjectsLocationsPrivateConnectionsRoutesCreateRequest(
          req
        );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v1alpha1/{parent}/routes",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "routeInput",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.DatastreamProjectsLocationsPrivateConnectionsRoutesCreateSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DatastreamProjectsLocationsPrivateConnectionsRoutesCreateResponse =
        new operations.DatastreamProjectsLocationsPrivateConnectionsRoutesCreateResponse(
          {
            statusCode: httpRes.status,
            contentType: contentType,
            rawResponse: httpRes,
          }
        );
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.operation = utils.objectToClass(
              httpRes?.data,
              shared.Operation
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Use this method to list routes created for a private connectivity in a project and location.
   */
  datastreamProjectsLocationsPrivateConnectionsRoutesList(
    req: operations.DatastreamProjectsLocationsPrivateConnectionsRoutesListRequest,
    security: operations.DatastreamProjectsLocationsPrivateConnectionsRoutesListSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.DatastreamProjectsLocationsPrivateConnectionsRoutesListResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.DatastreamProjectsLocationsPrivateConnectionsRoutesListRequest(
          req
        );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v1alpha1/{parent}/routes",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.DatastreamProjectsLocationsPrivateConnectionsRoutesListSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DatastreamProjectsLocationsPrivateConnectionsRoutesListResponse =
        new operations.DatastreamProjectsLocationsPrivateConnectionsRoutesListResponse(
          {
            statusCode: httpRes.status,
            contentType: contentType,
            rawResponse: httpRes,
          }
        );
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listRoutesResponse = utils.objectToClass(
              httpRes?.data,
              shared.ListRoutesResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Use this method to create a stream.
   */
  datastreamProjectsLocationsStreamsCreate(
    req: operations.DatastreamProjectsLocationsStreamsCreateRequest,
    security: operations.DatastreamProjectsLocationsStreamsCreateSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.DatastreamProjectsLocationsStreamsCreateResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DatastreamProjectsLocationsStreamsCreateRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v1alpha1/{parent}/streams",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "streamInput",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.DatastreamProjectsLocationsStreamsCreateSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DatastreamProjectsLocationsStreamsCreateResponse =
        new operations.DatastreamProjectsLocationsStreamsCreateResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.operation = utils.objectToClass(
              httpRes?.data,
              shared.Operation
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Use this method to delete a stream.
   */
  datastreamProjectsLocationsStreamsDelete(
    req: operations.DatastreamProjectsLocationsStreamsDeleteRequest,
    security: operations.DatastreamProjectsLocationsStreamsDeleteSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.DatastreamProjectsLocationsStreamsDeleteResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DatastreamProjectsLocationsStreamsDeleteRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(baseURL, "/v1alpha1/{name}", req);
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.DatastreamProjectsLocationsStreamsDeleteSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DatastreamProjectsLocationsStreamsDeleteResponse =
        new operations.DatastreamProjectsLocationsStreamsDeleteResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.operation = utils.objectToClass(
              httpRes?.data,
              shared.Operation
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Use this method to fetch any errors associated with a stream.
   */
  datastreamProjectsLocationsStreamsFetchErrors(
    req: operations.DatastreamProjectsLocationsStreamsFetchErrorsRequest,
    security: operations.DatastreamProjectsLocationsStreamsFetchErrorsSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.DatastreamProjectsLocationsStreamsFetchErrorsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DatastreamProjectsLocationsStreamsFetchErrorsRequest(
        req
      );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v1alpha1/{stream}:fetchErrors",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.DatastreamProjectsLocationsStreamsFetchErrorsSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DatastreamProjectsLocationsStreamsFetchErrorsResponse =
        new operations.DatastreamProjectsLocationsStreamsFetchErrorsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.operation = utils.objectToClass(
              httpRes?.data,
              shared.Operation
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Use this method to list streams in a project and location.
   */
  datastreamProjectsLocationsStreamsList(
    req: operations.DatastreamProjectsLocationsStreamsListRequest,
    security: operations.DatastreamProjectsLocationsStreamsListSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.DatastreamProjectsLocationsStreamsListResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DatastreamProjectsLocationsStreamsListRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v1alpha1/{parent}/streams",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.DatastreamProjectsLocationsStreamsListSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DatastreamProjectsLocationsStreamsListResponse =
        new operations.DatastreamProjectsLocationsStreamsListResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listStreamsResponse = utils.objectToClass(
              httpRes?.data,
              shared.ListStreamsResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Use this method to get details about a stream object.
   */
  datastreamProjectsLocationsStreamsObjectsGet(
    req: operations.DatastreamProjectsLocationsStreamsObjectsGetRequest,
    security: operations.DatastreamProjectsLocationsStreamsObjectsGetSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.DatastreamProjectsLocationsStreamsObjectsGetResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DatastreamProjectsLocationsStreamsObjectsGetRequest(
        req
      );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(baseURL, "/v1alpha1/{name}", req);
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.DatastreamProjectsLocationsStreamsObjectsGetSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DatastreamProjectsLocationsStreamsObjectsGetResponse =
        new operations.DatastreamProjectsLocationsStreamsObjectsGetResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.streamObject = utils.objectToClass(
              httpRes?.data,
              shared.StreamObject
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Use this method to list the objects of a specific stream.
   */
  datastreamProjectsLocationsStreamsObjectsList(
    req: operations.DatastreamProjectsLocationsStreamsObjectsListRequest,
    security: operations.DatastreamProjectsLocationsStreamsObjectsListSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.DatastreamProjectsLocationsStreamsObjectsListResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DatastreamProjectsLocationsStreamsObjectsListRequest(
        req
      );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v1alpha1/{parent}/objects",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.DatastreamProjectsLocationsStreamsObjectsListSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DatastreamProjectsLocationsStreamsObjectsListResponse =
        new operations.DatastreamProjectsLocationsStreamsObjectsListResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listStreamObjectsResponse = utils.objectToClass(
              httpRes?.data,
              shared.ListStreamObjectsResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Starts backfill job for the specified stream object.
   */
  datastreamProjectsLocationsStreamsObjectsStartBackfillJob(
    req: operations.DatastreamProjectsLocationsStreamsObjectsStartBackfillJobRequest,
    security: operations.DatastreamProjectsLocationsStreamsObjectsStartBackfillJobSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.DatastreamProjectsLocationsStreamsObjectsStartBackfillJobResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.DatastreamProjectsLocationsStreamsObjectsStartBackfillJobRequest(
          req
        );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v1alpha1/{object}:startBackfillJob",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.DatastreamProjectsLocationsStreamsObjectsStartBackfillJobSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "post",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DatastreamProjectsLocationsStreamsObjectsStartBackfillJobResponse =
        new operations.DatastreamProjectsLocationsStreamsObjectsStartBackfillJobResponse(
          {
            statusCode: httpRes.status,
            contentType: contentType,
            rawResponse: httpRes,
          }
        );
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.startBackfillJobResponse = utils.objectToClass(
              httpRes?.data,
              shared.StartBackfillJobResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Stops the backfill job for the specified stream object.
   */
  datastreamProjectsLocationsStreamsObjectsStopBackfillJob(
    req: operations.DatastreamProjectsLocationsStreamsObjectsStopBackfillJobRequest,
    security: operations.DatastreamProjectsLocationsStreamsObjectsStopBackfillJobSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.DatastreamProjectsLocationsStreamsObjectsStopBackfillJobResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.DatastreamProjectsLocationsStreamsObjectsStopBackfillJobRequest(
          req
        );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v1alpha1/{object}:stopBackfillJob",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.DatastreamProjectsLocationsStreamsObjectsStopBackfillJobSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "post",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DatastreamProjectsLocationsStreamsObjectsStopBackfillJobResponse =
        new operations.DatastreamProjectsLocationsStreamsObjectsStopBackfillJobResponse(
          {
            statusCode: httpRes.status,
            contentType: contentType,
            rawResponse: httpRes,
          }
        );
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.stopBackfillJobResponse = utils.objectToClass(
              httpRes?.data,
              shared.StopBackfillJobResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Use this method to update the configuration of a stream.
   */
  datastreamProjectsLocationsStreamsPatch(
    req: operations.DatastreamProjectsLocationsStreamsPatchRequest,
    security: operations.DatastreamProjectsLocationsStreamsPatchSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.DatastreamProjectsLocationsStreamsPatchResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DatastreamProjectsLocationsStreamsPatchRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(baseURL, "/v1alpha1/{name}", req);

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "streamInput",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.DatastreamProjectsLocationsStreamsPatchSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "patch",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DatastreamProjectsLocationsStreamsPatchResponse =
        new operations.DatastreamProjectsLocationsStreamsPatchResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.operation = utils.objectToClass(
              httpRes?.data,
              shared.Operation
            );
          }
          break;
      }

      return res;
    });
  }
}
