"""Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT."""

from __future__ import annotations
import dataclasses
import requests as requests_http
from ..shared import searchresponse as shared_searchresponse
from enum import Enum
from typing import Optional

class SearchSafeModeEnum(str, Enum):
    r"""Whether or not to exclude podcasts/episodes with explicit language. 1 is yes and 0 is no. It works only when **type** is *episode* or *podcast*."""
    ZERO = '0'
    ONE = '1'

class SearchSortByDateEnum(str, Enum):
    r"""Sort by date or not? If 0, then sort by relevance. If 1, then sort by date."""
    ZERO = '0'
    ONE = '1'

class SearchTypeEnum(str, Enum):
    r"""What type of contents do you want to search for?"""
    EPISODE = 'episode'
    PODCAST = 'podcast'
    CURATED = 'curated'

class SearchUniquePodcastsEnum(str, Enum):
    r"""Whether or not to keep only one episode per podcast in search results. 1 is yes and 0 is no. It works only when **type** is *episode*."""
    ZERO = '0'
    ONE = '1'


@dataclasses.dataclass
class SearchRequest:
    
    q: str = dataclasses.field(metadata={'query_param': { 'field_name': 'q', 'style': 'form', 'explode': True }})
    r"""Search term, e.g., person, place, topic... You can use double quotes to do verbatim match, e.g., \\"game of thrones\\". Otherwise, it's fuzzy search."""  
    x_listen_api_key: str = dataclasses.field(metadata={'header': { 'field_name': 'X-ListenAPI-Key', 'style': 'simple', 'explode': False }})
    r"""Get API Key on listennotes.com/api"""  
    episode_count_max: Optional[int] = dataclasses.field(default=None, metadata={'query_param': { 'field_name': 'episode_count_max', 'style': 'form', 'explode': True }})
    r"""Maximum number of episodes. Applicable only when type parameter is **podcast**."""  
    episode_count_min: Optional[int] = dataclasses.field(default=None, metadata={'query_param': { 'field_name': 'episode_count_min', 'style': 'form', 'explode': True }})
    r"""Minimum number of episodes. Applicable only when type parameter is **podcast**."""  
    genre_ids: Optional[str] = dataclasses.field(default=None, metadata={'query_param': { 'field_name': 'genre_ids', 'style': 'form', 'explode': True }})
    r"""A comma-delimited string of a list of genre ids. If not specified, then all genres are included. You can find the id and the name of all genres from `GET /genres`. It works only when **type** is *episode* or *podcast*."""  
    language: Optional[str] = dataclasses.field(default=None, metadata={'query_param': { 'field_name': 'language', 'style': 'form', 'explode': True }})
    r"""Limit search results to a specific language. If not specified, it'll be any language. You can get a list of supported languages from `GET /languages`. It works only when **type** is *episode* or *podcast*."""  
    len_max: Optional[int] = dataclasses.field(default=None, metadata={'query_param': { 'field_name': 'len_max', 'style': 'form', 'explode': True }})
    r"""Maximum audio length in minutes. Applicable only when **type** parameter is **episode** or **podcast**.
    If **type** parameter is **episode**, it's for audio length of an episode.
    If **type** parameter is **podcast**, it's for average audio length of all episodes in a podcast.
    """  
    len_min: Optional[int] = dataclasses.field(default=None, metadata={'query_param': { 'field_name': 'len_min', 'style': 'form', 'explode': True }})
    r"""Minimum audio length in minutes. Applicable only when **type** parameter is **episode** or **podcast**.
    If **type** parameter is **episode**, it's for audio length of an episode.
    If **type** parameter is **podcast**, it's for average audio length of all episodes in a podcast.
    """  
    ncid: Optional[str] = dataclasses.field(default=None, metadata={'query_param': { 'field_name': 'ncid', 'style': 'form', 'explode': True }})
    r"""A comma-delimited string of podcast ids (up to 5 podcasts) - you can get a podcast id from the **podcast_id** field in response. This parameter is to exclude search results of a few specific podcasts. It works only when **type** is *episode*."""  
    ocid: Optional[str] = dataclasses.field(default=None, metadata={'query_param': { 'field_name': 'ocid', 'style': 'form', 'explode': True }})
    r"""A comma-delimited string of podcast ids (up to 5 podcasts) - you can get a podcast id from the **podcast_id** field in response. This parameter is to limit search results from only a few specific podcasts. It works only when **type** is *episode*."""  
    offset: Optional[int] = dataclasses.field(default=None, metadata={'query_param': { 'field_name': 'offset', 'style': 'form', 'explode': True }})
    r"""Offset for search results, for pagination. You'll use **next_offset** from response for this parameter."""  
    only_in: Optional[str] = dataclasses.field(default=None, metadata={'query_param': { 'field_name': 'only_in', 'style': 'form', 'explode': True }})
    r"""A comma-delimited string to search only in specific fields. Allowed values are title, description, author, and audio. If not specified, then search every fields."""  
    published_after: Optional[int] = dataclasses.field(default=None, metadata={'query_param': { 'field_name': 'published_after', 'style': 'form', 'explode': True }})
    r"""Only show episodes/podcasts/curated lists published after this timestamp (in milliseconds). If **published_before** & **published_after** are used at the same time, **published_before** should be bigger than **published_after**."""  
    published_before: Optional[int] = dataclasses.field(default=None, metadata={'query_param': { 'field_name': 'published_before', 'style': 'form', 'explode': True }})
    r"""Only show episodes/podcasts/curated lists published before this timestamp (in milliseconds). If **published_before** & **published_after** are used at the same time, **published_before** should be bigger than **published_after**."""  
    region: Optional[str] = dataclasses.field(default=None, metadata={'query_param': { 'field_name': 'region', 'style': 'form', 'explode': True }})
    r"""Limit search results to a specific region (e.g., us, gb, in...). If not specified, it'll be any region. You can get the supported country codes from `GET /regions`. It works only when **type** is *episode* or *podcast*."""  
    safe_mode: Optional[SearchSafeModeEnum] = dataclasses.field(default=None, metadata={'query_param': { 'field_name': 'safe_mode', 'style': 'form', 'explode': True }})
    r"""Whether or not to exclude podcasts/episodes with explicit language. 1 is yes and 0 is no. It works only when **type** is *episode* or *podcast*."""  
    sort_by_date: Optional[SearchSortByDateEnum] = dataclasses.field(default=None, metadata={'query_param': { 'field_name': 'sort_by_date', 'style': 'form', 'explode': True }})
    r"""Sort by date or not? If 0, then sort by relevance. If 1, then sort by date."""  
    type: Optional[SearchTypeEnum] = dataclasses.field(default=None, metadata={'query_param': { 'field_name': 'type', 'style': 'form', 'explode': True }})
    r"""What type of contents do you want to search for?"""  
    unique_podcasts: Optional[SearchUniquePodcastsEnum] = dataclasses.field(default=None, metadata={'query_param': { 'field_name': 'unique_podcasts', 'style': 'form', 'explode': True }})
    r"""Whether or not to keep only one episode per podcast in search results. 1 is yes and 0 is no. It works only when **type** is *episode*."""  
    update_freq_max: Optional[int] = dataclasses.field(default=None, metadata={'query_param': { 'field_name': 'update_freq_max', 'style': 'form', 'explode': True }})
    r"""Maximum update frequency in hours (how frequently does a podcast release a new episode). For example, if you want to find \\"weekly\\" podcasts, then you can set **update_freq_min**=144 hours (or 6 days) and **update_freq_max**=192 hours (or 8 days). Applicable only when type parameter is **podcast**."""  
    update_freq_min: Optional[int] = dataclasses.field(default=None, metadata={'query_param': { 'field_name': 'update_freq_min', 'style': 'form', 'explode': True }})
    r"""Minimum update frequency in hours (how frequently does a podcast release a new episode). For example, if you want to find \\"weekly\\" podcasts, then you can set **update_freq_min**=144 hours (or 6 days) and **update_freq_max**=192 hours (or 8 days). Applicable only when type parameter is **podcast**."""  
    

@dataclasses.dataclass
class SearchResponse:
    
    content_type: str = dataclasses.field()  
    status_code: int = dataclasses.field()  
    headers: Optional[dict[str, list[str]]] = dataclasses.field(default=None)  
    raw_response: Optional[requests_http.Response] = dataclasses.field(default=None)  
    search_response: Optional[shared_searchresponse.SearchResponse] = dataclasses.field(default=None)
    r"""OK"""  
    