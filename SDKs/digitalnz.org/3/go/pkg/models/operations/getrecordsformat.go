// Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.

package operations

import (
	"encoding/json"
	"fmt"
	"net/http"
	"openapi/pkg/models/shared"
)

type GetRecordsFormatPathParams struct {
	// Note - There is a small difference with some field names in the response between JSON and XML.
	// When a field name has more than one word, JSON format will separate the words with an underscore, eg. "content_partner", whereas XML uses a hyphenated naming convention, eg. "content-partner".
	//
	Format shared.FormatEnum `pathParam:"style=simple,explode=false,name=format"`
}

// GetRecordsFormatAndCategoryEnum - These are the same categories that are used across the tabs in [digitalnz.org](https://digitalnz.org/records?text=&tab=Videos)
type GetRecordsFormatAndCategoryEnum string

const (
	GetRecordsFormatAndCategoryEnumNewspapers       GetRecordsFormatAndCategoryEnum = "Newspapers"
	GetRecordsFormatAndCategoryEnumImages           GetRecordsFormatAndCategoryEnum = "Images"
	GetRecordsFormatAndCategoryEnumBooks            GetRecordsFormatAndCategoryEnum = "Books"
	GetRecordsFormatAndCategoryEnumArticles         GetRecordsFormatAndCategoryEnum = "Articles"
	GetRecordsFormatAndCategoryEnumJournals         GetRecordsFormatAndCategoryEnum = "Journals"
	GetRecordsFormatAndCategoryEnumArchives         GetRecordsFormatAndCategoryEnum = "Archives"
	GetRecordsFormatAndCategoryEnumAudio            GetRecordsFormatAndCategoryEnum = "Audio"
	GetRecordsFormatAndCategoryEnumOther            GetRecordsFormatAndCategoryEnum = "Other"
	GetRecordsFormatAndCategoryEnumManuscripts      GetRecordsFormatAndCategoryEnum = "Manuscripts"
	GetRecordsFormatAndCategoryEnumReferenceSources GetRecordsFormatAndCategoryEnum = "Reference sources"
	GetRecordsFormatAndCategoryEnumResearchPapers   GetRecordsFormatAndCategoryEnum = "Research papers"
	GetRecordsFormatAndCategoryEnumVideos           GetRecordsFormatAndCategoryEnum = "Videos"
	GetRecordsFormatAndCategoryEnumMusicScore       GetRecordsFormatAndCategoryEnum = "Music Score"
	GetRecordsFormatAndCategoryEnumGroups           GetRecordsFormatAndCategoryEnum = "Groups"
	GetRecordsFormatAndCategoryEnumData             GetRecordsFormatAndCategoryEnum = "Data"
	GetRecordsFormatAndCategoryEnumWebsites         GetRecordsFormatAndCategoryEnum = "Websites"
	GetRecordsFormatAndCategoryEnumSets             GetRecordsFormatAndCategoryEnum = "Sets"
)

func (e *GetRecordsFormatAndCategoryEnum) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return err
	}
	switch s {
	case "Newspapers":
		fallthrough
	case "Images":
		fallthrough
	case "Books":
		fallthrough
	case "Articles":
		fallthrough
	case "Journals":
		fallthrough
	case "Archives":
		fallthrough
	case "Audio":
		fallthrough
	case "Other":
		fallthrough
	case "Manuscripts":
		fallthrough
	case "Reference sources":
		fallthrough
	case "Research papers":
		fallthrough
	case "Videos":
		fallthrough
	case "Music Score":
		fallthrough
	case "Groups":
		fallthrough
	case "Data":
		fallthrough
	case "Websites":
		fallthrough
	case "Sets":
		*e = GetRecordsFormatAndCategoryEnum(s)
		return nil
	default:
		return fmt.Errorf("invalid value for GetRecordsFormatAndCategoryEnum: %s", s)
	}
}

// GetRecordsFormatAndHasLargeThumbnailURLEnum - Filters results to only those records that have an image available in the *large_thumbnail_url* field.
// **Note:** There is an issue with this field where, in order to get results, it needs to be specified with "Y" or not specified at all.
type GetRecordsFormatAndHasLargeThumbnailURLEnum string

const (
	GetRecordsFormatAndHasLargeThumbnailURLEnumY GetRecordsFormatAndHasLargeThumbnailURLEnum = "Y"
)

func (e *GetRecordsFormatAndHasLargeThumbnailURLEnum) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return err
	}
	switch s {
	case "Y":
		*e = GetRecordsFormatAndHasLargeThumbnailURLEnum(s)
		return nil
	default:
		return fmt.Errorf("invalid value for GetRecordsFormatAndHasLargeThumbnailURLEnum: %s", s)
	}
}

// GetRecordsFormatAndHasLatLngEnum - Filters results to only those records that have latitude and longitude coordinates present in the metadata.
//
// *Tip* - To see the location metadata you'll need to specifically request that field using the *fields* parameter - *"&fields=verbose,locations"*  as it is not part of the default, or verbose field sets.
type GetRecordsFormatAndHasLatLngEnum string

const (
	GetRecordsFormatAndHasLatLngEnumTrue  GetRecordsFormatAndHasLatLngEnum = "true"
	GetRecordsFormatAndHasLatLngEnumFalse GetRecordsFormatAndHasLatLngEnum = "false"
)

func (e *GetRecordsFormatAndHasLatLngEnum) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return err
	}
	switch s {
	case "true":
		fallthrough
	case "false":
		*e = GetRecordsFormatAndHasLatLngEnum(s)
		return nil
	default:
		return fmt.Errorf("invalid value for GetRecordsFormatAndHasLatLngEnum: %s", s)
	}
}

// GetRecordsFormatAndUsageEnum
type GetRecordsFormatAndUsageEnum string

const (
	GetRecordsFormatAndUsageEnumShare             GetRecordsFormatAndUsageEnum = "Share"
	GetRecordsFormatAndUsageEnumModify            GetRecordsFormatAndUsageEnum = "Modify"
	GetRecordsFormatAndUsageEnumUseCommercially   GetRecordsFormatAndUsageEnum = "Use commercially"
	GetRecordsFormatAndUsageEnumAllRightsReserved GetRecordsFormatAndUsageEnum = "All rights reserved"
	GetRecordsFormatAndUsageEnumUnknown           GetRecordsFormatAndUsageEnum = "Unknown"
)

func (e *GetRecordsFormatAndUsageEnum) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return err
	}
	switch s {
	case "Share":
		fallthrough
	case "Modify":
		fallthrough
	case "Use commercially":
		fallthrough
	case "All rights reserved":
		fallthrough
	case "Unknown":
		*e = GetRecordsFormatAndUsageEnum(s)
		return nil
	default:
		return fmt.Errorf("invalid value for GetRecordsFormatAndUsageEnum: %s", s)
	}
}

// GetRecordsFormatDirectionEnum - Used in conjunction with *sort* to order the results
//   - *asc* - Ascending, oldest first.
//   - *desc* - Descending, newest first.
type GetRecordsFormatDirectionEnum string

const (
	GetRecordsFormatDirectionEnumAsc  GetRecordsFormatDirectionEnum = "asc"
	GetRecordsFormatDirectionEnumDesc GetRecordsFormatDirectionEnum = "desc"
)

func (e *GetRecordsFormatDirectionEnum) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return err
	}
	switch s {
	case "asc":
		fallthrough
	case "desc":
		*e = GetRecordsFormatDirectionEnum(s)
		return nil
	default:
		return fmt.Errorf("invalid value for GetRecordsFormatDirectionEnum: %s", s)
	}
}

type GetRecordsFormatFacetsEnum string

const (
	GetRecordsFormatFacetsEnumCategory          GetRecordsFormatFacetsEnum = "category"
	GetRecordsFormatFacetsEnumContentPartner    GetRecordsFormatFacetsEnum = "content_partner"
	GetRecordsFormatFacetsEnumDisplayCollection GetRecordsFormatFacetsEnum = "display_collection"
	GetRecordsFormatFacetsEnumCollection        GetRecordsFormatFacetsEnum = "collection"
	GetRecordsFormatFacetsEnumCreator           GetRecordsFormatFacetsEnum = "creator"
	GetRecordsFormatFacetsEnumPlacename         GetRecordsFormatFacetsEnum = "placename"
	GetRecordsFormatFacetsEnumDate              GetRecordsFormatFacetsEnum = "date"
	GetRecordsFormatFacetsEnumYear              GetRecordsFormatFacetsEnum = "year"
	GetRecordsFormatFacetsEnumDecade            GetRecordsFormatFacetsEnum = "decade"
	GetRecordsFormatFacetsEnumCentury           GetRecordsFormatFacetsEnum = "century"
	GetRecordsFormatFacetsEnumLanguage          GetRecordsFormatFacetsEnum = "language"
	GetRecordsFormatFacetsEnumRights            GetRecordsFormatFacetsEnum = "rights"
	GetRecordsFormatFacetsEnumUsage             GetRecordsFormatFacetsEnum = "usage"
	GetRecordsFormatFacetsEnumCopyright         GetRecordsFormatFacetsEnum = "copyright"
	GetRecordsFormatFacetsEnumSubject           GetRecordsFormatFacetsEnum = "subject"
	GetRecordsFormatFacetsEnumFormat            GetRecordsFormatFacetsEnum = "format"
	GetRecordsFormatFacetsEnumDcType            GetRecordsFormatFacetsEnum = "dc_type"
)

func (e *GetRecordsFormatFacetsEnum) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return err
	}
	switch s {
	case "category":
		fallthrough
	case "content_partner":
		fallthrough
	case "display_collection":
		fallthrough
	case "collection":
		fallthrough
	case "creator":
		fallthrough
	case "placename":
		fallthrough
	case "date":
		fallthrough
	case "year":
		fallthrough
	case "decade":
		fallthrough
	case "century":
		fallthrough
	case "language":
		fallthrough
	case "rights":
		fallthrough
	case "usage":
		fallthrough
	case "copyright":
		fallthrough
	case "subject":
		fallthrough
	case "format":
		fallthrough
	case "dc_type":
		*e = GetRecordsFormatFacetsEnum(s)
		return nil
	default:
		return fmt.Errorf("invalid value for GetRecordsFormatFacetsEnum: %s", s)
	}
}

// GetRecordsFormatSortEnum - Used to control the order of the results in conjunction with the *direction* field.
//   - *syndication_date* - is the creation date of the record within DigitalNZ, ie. when DigitalNZ first harvested the record.
//   - *date* - is the date metadata (if present) associated with the record.
//
// To sort the search results with newest records at the top use: "&sort=syndication_date&direction=desc"
type GetRecordsFormatSortEnum string

const (
	GetRecordsFormatSortEnumSyndicationDate GetRecordsFormatSortEnum = "syndication_date"
	GetRecordsFormatSortEnumDate            GetRecordsFormatSortEnum = "date"
)

func (e *GetRecordsFormatSortEnum) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return err
	}
	switch s {
	case "syndication_date":
		fallthrough
	case "date":
		*e = GetRecordsFormatSortEnum(s)
		return nil
	default:
		return fmt.Errorf("invalid value for GetRecordsFormatSortEnum: %s", s)
	}
}

type GetRecordsFormatQueryParams struct {
	// These are the same categories that are used across the tabs in [digitalnz.org](https://digitalnz.org/records?text=&tab=Videos)
	AndCategory *GetRecordsFormatAndCategoryEnum `queryParam:"style=form,explode=true,name=and[category][]"`
	// This field allows searching specifically by century. The metadata is derived from the same date information that is searchable and returned in the date field.
	// Example: `"1900"` `"2000"`
	//
	AndCentury *string `queryParam:"style=form,explode=true,name=and[century]"`
	// Allows filtering for records from a particular Collection. Collections can be thought of as sub-collections or groupings under Primary_Collections.
	// Examples: `"Music 101"` `"Mollusks"` `"Wairarapa Daily Times"`
	//
	// *Tip* - To see a list of Collections available for filtering use the *facets* parameter, eg. *"&facets=collection"*.
	//
	AndCollection *string `queryParam:"style=form,explode=true,name=and[collection][]"`
	// Allows filtering for records from a particular Content Partner.
	// Examples: `"Ministry for Culture and Heritage"` `"Trove"` `"V.C. Browne & Son"`
	//
	// *Tip* - To see a list of Content Partners available for filtering use the *facets* parameter, eg. *"&facets=content_partner"*.
	//
	AndContentPartner *string `queryParam:"style=form,explode=true,name=and[content_partner][]"`
	// Examples: `"Revelle Jackson"` `"Nicholas Chevalier"` `"Rita Angus"`
	//
	AndCreator *string `queryParam:"style=form,explode=true,name=and[creator][]"`
	// This field can be useful for querying and sorting (see the 'sort' param further down). But it should be noted that, as with some other fields, **not all records have date metadata associated**. There is good coverage of date metadata within certain collections, but there are plenty with no date information at all. So, if you query for records from a specific date you may get some matching results, but might also be missing other potentially relevant records that don't have date metadata available.
	// Example: `"1970-12-25"`
	//
	// *Tip* - There is a related (but not searchable) field that is returned on each record (where available), that often has a more human readable version of the date information, called 'display_date'.
	//
	AndDate *string `queryParam:"style=form,explode=true,name=and[date]"`
	// Examples: `"Conference item"` `"Magazines"`
	//
	AndDcType *string `queryParam:"style=form,explode=true,name=and[dc_type][]"`
	// This field allows searching specifically by decade. The metadata is derived from the same date information that is searchable and returned in the date field.
	// Example: `"1850"` `"1990"`
	//
	AndDecade *string `queryParam:"style=form,explode=true,name=and[decade]"`
	// Examples: `"Photolithographs"` `"Glass*"`
	//
	AndFormat *string `queryParam:"style=form,explode=true,name=and[format][]"`
	// Filters results to only those records that have an image available in the *large_thumbnail_url* field.
	// **Note:** There is an issue with this field where, in order to get results, it needs to be specified with "Y" or not specified at all.
	//
	AndHasLargeThumbnailURL *GetRecordsFormatAndHasLargeThumbnailURLEnum `queryParam:"style=form,explode=true,name=and[has_large_thumbnail_url]"`
	// Filters results to only those records that have latitude and longitude coordinates present in the metadata.
	//
	// *Tip* - To see the location metadata you'll need to specifically request that field using the *fields* parameter - *"&fields=verbose,locations"*  as it is not part of the default, or verbose field sets.
	//
	AndHasLatLng *GetRecordsFormatAndHasLatLngEnum `queryParam:"style=form,explode=true,name=and[has_lat_lng]"`
	// Some DigitalNZ partners offer their metadata for use in commercial applications. This content can be identified through the *is_commercial_use* flag. Only API results where the *is_commercial_use* field set to True can be used for commercial purposes. Check out the [terms of use](https://digitalnz.org/about/terms-of-use/developer-api-terms-of-use#commercial_use_terms) for more information.
	//
	AndIsCommercialUse *bool `queryParam:"style=form,explode=true,name=and[is_commercial_use]"`
	// All of the above `and[___][]` filters in this document are also able to be used with the `and[or][___][]` syntax to allow multi-select *OR* queries within one field.
	// Basic example:
	// - To filter your results to only those with a category or Audio or Videos:
	// `&and[or][category][]=Audio&and[or][category][]=Videos`
	//
	// In order to combine *OR* filters across multiple fields the syntax needs to be nested as follows
	// Nested examples:
	//  - To search for *(year is 2014 OR 2015) AND (primary_collection is TAPUHI OR Public Address)*
	//  `&and[or][year][]=2015&and[or][year][]=2014&and[and][or][primary_collection][]=TAPUHI&and[and][or][primary_collection][]=Public+Address`
	//  - To search for *(category is Images OR Video) AND (subject is cat OR cats)*
	//  `&and[or][category][]=Images&and[or][category][]=Videos&and[and][or][subject][]=cat&and[and][or][subject][]=cats`
	//
	AndOrFilterField *string `queryParam:"style=form,explode=true,name=and[or][{filter_field}][]"`
	// This field can be used for text-based location search. For a more advanced coordinate-based search, see the "geo_bbox" field below.
	// Examples: `"Scott Base"` `"Wainuiomata"` `"castle*"`
	//
	AndPlacename *string `queryParam:"style=form,explode=true,name=and[placename][]"`
	// Allows filtering for records from a particular *primary_collection*.
	// Examples: `"Puke Ariki"` `"NZHistory"` `"TAPUHI"`
	//
	// *Tip* - To see a list of Primary_Collections available for filtering use the *facets* parameter, eg. *"&facets=primary_collection"*.
	//
	AndPrimaryCollection *string `queryParam:"style=form,explode=true,name=and[primary_collection][]"`
	// Examples: `"Cats"` `"Weddings"` `"climb*"`
	//
	AndSubject *string `queryParam:"style=form,explode=true,name=and[subject][]"`
	// Examples: `"Pukeko"` `"Club"` `"Break*"`"
	//
	AndTitle *string                       `queryParam:"style=form,explode=true,name=and[title][]"`
	AndUsage *GetRecordsFormatAndUsageEnum `queryParam:"style=form,explode=true,name=and[usage][]"`
	// This field allows searching specifically by year. The metadata is derived from the same date information that is searchable and returned in the date field. It is possible to search across a range using syntax the following syntax `[{start year} TO {end year}]`.
	// Example: `"1893"` `"[1982 TO 1987]"`
	//
	AndYear *string `queryParam:"style=form,explode=true,name=and[year]"`
	// To access the API you will need your own DigitalNZ account and [API key](https://digitalnz.org/api_keys/edit).
	APIKey string `queryParam:"style=form,explode=true,name=api_key"`
	// Used in conjunction with *sort* to order the results
	//  - *asc* - Ascending, oldest first.
	//  - *desc* - Descending, newest first.
	//
	Direction *GetRecordsFormatDirectionEnum `queryParam:"style=form,explode=true,name=direction"`
	// This field can be used when filtering into some facets, to maintain the context of the wider facet values. A common use case is to allow the results of a search to be filtered down into a specific category (eg Audio), while still showing the other possible filter options as facet counts (eg. Images, Audio, Video, etc). Setting this to 'true' will not effect the search results returned but will ignore all search filters (eg. "and[category]=Audio") when calculating the facet counts.
	//
	ExcludeFiltersFromFacets *bool `queryParam:"style=form,explode=true,name=exclude_filters_from_facets"`
	// Shows a breakdown of record counts for the specified facets based on the current result set. In the [DigitalNZ search interface](https://digitalnz.org/records) these facets are used to list the values filterable for each field. A comma-separated list will return multiple facets in one call.
	//
	Facets []GetRecordsFormatFacetsEnum `queryParam:"style=form,explode=false,name=facets"`
	// This value specifies which page of facet results to return. Allowing pagination through large lists of facet values.
	FacetsPage *int64 `queryParam:"style=form,explode=true,name=facets_page"`
	// The number of facets to return per page of facet results.
	FacetsPerPage *int64 `queryParam:"style=form,explode=true,name=facets_per_page"`
	// Comma-separated whitelist of fields to be returned. The syntax *"&fields=verbose"* can be used to return the bulk of the fields, or you can customise which fields you are interested in, eg. *"&fields=id,title,subject,collection,landing_url,locations"*.
	//
	Fields *string `queryParam:"style=form,explode=false,name=fields"`
	// A geographic bounding box scoping a search to a geographic region. Order of latitude-longitude coordinates is north, west, south, east.   For example, filtering the Wellington region would be *"&geo_bbox=-41,174,-42,175"*
	//
	GeoBbox *string `queryParam:"style=form,explode=true,name=geo_bbox"`
	// Specify which page of results to return.
	Page *int64 `queryParam:"style=form,explode=true,name=page"`
	// The number of records to return per page of search results.
	PerPage *int64 `queryParam:"style=form,explode=true,name=per_page"`
	// Used to control the order of the results in conjunction with the *direction* field.
	//   - *syndication_date* - is the creation date of the record within DigitalNZ, ie. when DigitalNZ first harvested the record.
	//   - *date* - is the date metadata (if present) associated with the record.
	//
	// To sort the search results with newest records at the top use: "&sort=syndication_date&direction=desc"
	//
	Sort *GetRecordsFormatSortEnum `queryParam:"style=form,explode=true,name=sort"`
	// This field enables queries based on one or more search terms and provides the functionality of the main search box on [digitalnz.org](https://digitalnz.org). Search terms can be combined with boolean operators (AND, OR).
	// A minus sign excludes certain terms, eg. "-horse".
	// An asterisk (\*) acts as a wildcard, eg. "ted*".
	// Multiple search terms are combined with an AND by default.
	// Examples: `"moustache"`, `"Wanganui OR Whanganui"`,  `"-paperspast"`, `"ted*"`
	//
	Text *string `queryParam:"style=form,explode=true,name=text"`
	// All of the above `and[___][]` filters in this document are also able to be used with this syntax to exclude specific matches. For example to exclude Papers Past content `&without[primary_collection]=Papers+Past`
	//
	WithoutFilterField *string `queryParam:"style=form,explode=true,name=without[{filter_field}]"`
}

type GetRecordsFormatRequest struct {
	PathParams  GetRecordsFormatPathParams
	QueryParams GetRecordsFormatQueryParams
}

// GetRecordsFormat200ApplicationJSON - search results matching criteria
type GetRecordsFormat200ApplicationJSON struct {
	// Each field you request from the list of facetable fields will be returned as separate elements. Each of those will contain a sorted list of elements that are made up of a value (eg collection name, subject, date) and the number of results associated with that value.
	//
	Facets map[string]map[string]int64 `json:"facets,omitempty"`
	// Current page.
	Page *int64 `json:"page,omitempty"`
	// Requested amount of records shown per page of results.
	PerPage *int64          `json:"per_page,omitempty"`
	Records []shared.Record `json:"records,omitempty"`
	// The URL of current page of results.
	RequestURL *string `json:"request_url,omitempty"`
	// Total number of matching search results.
	ResultCount *int64 `json:"result_count,omitempty"`
}

type GetRecordsFormatResponse struct {
	Body        []byte
	ContentType string
	StatusCode  int
	RawResponse *http.Response
	// search results matching criteria
	GetRecordsFormat200ApplicationJSONObject *GetRecordsFormat200ApplicationJSON
	// Incorrect field specified in the request.
	GetRecordsFormat400ApplicationJSONObject map[string]interface{}
	// API Key is missing or invalid.
	GetRecordsFormat403ApplicationJSONObject map[string]interface{}
}
