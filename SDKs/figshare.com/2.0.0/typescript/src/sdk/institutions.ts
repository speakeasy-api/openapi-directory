/*
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

import * as utils from "../internal/utils";
import * as operations from "./models/operations";
import * as shared from "./models/shared";
import { AxiosInstance, AxiosRequestConfig, AxiosResponse } from "axios";

export class Institutions {
  _defaultClient: AxiosInstance;
  _securityClient: AxiosInstance;
  _serverURL: string;
  _language: string;
  _sdkVersion: string;
  _genVersion: string;

  constructor(
    defaultClient: AxiosInstance,
    securityClient: AxiosInstance,
    serverURL: string,
    language: string,
    sdkVersion: string,
    genVersion: string
  ) {
    this._defaultClient = defaultClient;
    this._securityClient = securityClient;
    this._serverURL = serverURL;
    this._language = language;
    this._sdkVersion = sdkVersion;
    this._genVersion = genVersion;
  }

  /**
   * Institution Curation Review
   *
   * @remarks
   * Retrieve a certain curation review by its ID
   */
  accountInstitutionCuration(
    req: operations.AccountInstitutionCurationRequest,
    security: operations.AccountInstitutionCurationSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.AccountInstitutionCurationResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.AccountInstitutionCurationRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/account/institution/review/{curation_id}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.AccountInstitutionCurationSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.AccountInstitutionCurationResponse =
        new operations.AccountInstitutionCurationResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.curationDetail = utils.objectToClass(
              httpRes?.data,
              shared.CurationDetail
            );
          }
          break;
        case [400, 404, 500].includes(httpRes?.status):
          break;
        case httpRes?.status == 403:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorMessage = utils.objectToClass(
              httpRes?.data,
              shared.ErrorMessage
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Institution Curation Review Comments
   *
   * @remarks
   * Retrieve a certain curation review's comments.
   */
  accountInstitutionCurationComments(
    req: operations.AccountInstitutionCurationCommentsRequest,
    security: operations.AccountInstitutionCurationCommentsSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.AccountInstitutionCurationCommentsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.AccountInstitutionCurationCommentsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/account/institution/review/{curation_id}/comments",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.AccountInstitutionCurationCommentsSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.AccountInstitutionCurationCommentsResponse =
        new operations.AccountInstitutionCurationCommentsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.curationComment = utils.objectToClass(
              httpRes?.data,
              shared.CurationComment
            );
          }
          break;
        case [400, 404, 500].includes(httpRes?.status):
          break;
        case httpRes?.status == 403:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorMessage = utils.objectToClass(
              httpRes?.data,
              shared.ErrorMessage
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Institution Curation Reviews
   *
   * @remarks
   * Retrieve a list of curation reviews for this institution
   */
  accountInstitutionCurations(
    req: operations.AccountInstitutionCurationsRequest,
    security: operations.AccountInstitutionCurationsSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.AccountInstitutionCurationsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.AccountInstitutionCurationsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/account/institution/reviews";
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.AccountInstitutionCurationsSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.AccountInstitutionCurationsResponse =
        new operations.AccountInstitutionCurationsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.curation = utils.objectToClass(httpRes?.data, shared.Curation);
          }
          break;
        case [400, 404, 500].includes(httpRes?.status):
          break;
        case httpRes?.status == 403:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorMessage = utils.objectToClass(
              httpRes?.data,
              shared.ErrorMessage
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Private account institution group custom fields
   *
   * @remarks
   * Returns the custom fields in the group the user belongs to, or the ones in the group specified, if the user has access.
   */
  customFieldsList(
    req: operations.CustomFieldsListRequest,
    security: operations.CustomFieldsListSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.CustomFieldsListResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CustomFieldsListRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/account/institution/custom_fields";
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.CustomFieldsListSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CustomFieldsListResponse =
        new operations.CustomFieldsListResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.shortCustomFields = [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.shortCustomFields = utils.objectToClass(
              httpRes?.data,
              shared.ShortCustomField,
              resFieldDepth
            );
          }
          break;
        case [400, 500].includes(httpRes?.status):
          break;
        case httpRes?.status == 403:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorMessage = utils.objectToClass(
              httpRes?.data,
              shared.ErrorMessage
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Custom fields values files upload
   *
   * @remarks
   * Uploads a CSV containing values for a specific custom field of type <b>dropdown_large_list</b>. More details in the <a href="#custom_fields">Custom Fields section</a>
   */
  customFieldsUpload(
    req: operations.CustomFieldsUploadRequest,
    security: operations.CustomFieldsUploadSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.CustomFieldsUploadResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CustomFieldsUploadRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/account/institution/custom_fields/{custom_field_id}/items/upload",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "multipart"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.CustomFieldsUploadSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CustomFieldsUploadResponse =
        new operations.CustomFieldsUploadResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.customFieldsUpload200ApplicationJSONObject =
              utils.objectToClass(httpRes?.data);
          }
          break;
        case [400, 409, 500].includes(httpRes?.status):
          break;
        case httpRes?.status == 403:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorMessage = utils.objectToClass(
              httpRes?.data,
              shared.ErrorMessage
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Public Licenses
   *
   * @remarks
   * Returns a list of articles belonging to the institution
   */
  institutionArticles(
    req: operations.InstitutionArticlesRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.InstitutionArticlesResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.InstitutionArticlesRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/institutions/{institution_string_id}/articles/filter-by",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.InstitutionArticlesResponse =
        new operations.InstitutionArticlesResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.articles = [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.articles = utils.objectToClass(
              httpRes?.data,
              shared.Article,
              resFieldDepth
            );
          }
          break;
        case httpRes?.status == 500:
          break;
      }

      return res;
    });
  }

  /**
   * Private Institution HRfeed Upload
   *
   * @remarks
   * More info in the <a href="#hr_feed">HR Feed section</a>
   */
  institutionHrfeedUpload(
    req: operations.InstitutionHrfeedUploadRequestBody,
    security: operations.InstitutionHrfeedUploadSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.InstitutionHrfeedUploadResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.InstitutionHrfeedUploadRequestBody(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/institution/hrfeed/upload";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "request",
        "multipart"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.InstitutionHrfeedUploadSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.InstitutionHrfeedUploadResponse =
        new operations.InstitutionHrfeedUploadResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.responseMessage = utils.objectToClass(
              httpRes?.data,
              shared.ResponseMessage
            );
          }
          break;
        case [400, 500].includes(httpRes?.status):
          break;
        case httpRes?.status == 403:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorMessage = utils.objectToClass(
              httpRes?.data,
              shared.ErrorMessage
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * POST Institution Curation Review Comment
   *
   * @remarks
   * Add a new comment to the review.
   */
  postAccountInstitutionReviewCurationIdComments(
    req: operations.PostAccountInstitutionReviewCurationIdCommentsRequest,
    security: operations.PostAccountInstitutionReviewCurationIdCommentsSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.PostAccountInstitutionReviewCurationIdCommentsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.PostAccountInstitutionReviewCurationIdCommentsRequest(
          req
        );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/account/institution/review/{curation_id}/comments",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "curationCommentCreate",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.PostAccountInstitutionReviewCurationIdCommentsSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PostAccountInstitutionReviewCurationIdCommentsResponse =
        new operations.PostAccountInstitutionReviewCurationIdCommentsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case [200, 400, 404, 500].includes(httpRes?.status):
          break;
        case httpRes?.status == 403:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorMessage = utils.objectToClass(
              httpRes?.data,
              shared.ErrorMessage
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Private Account Institution User
   *
   * @remarks
   * Retrieve institution user information using the account_id
   */
  privateAccountInstitutionUser(
    req: operations.PrivateAccountInstitutionUserRequest,
    security: operations.PrivateAccountInstitutionUserSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.PrivateAccountInstitutionUserResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PrivateAccountInstitutionUserRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/account/institution/users/{account_id}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.PrivateAccountInstitutionUserSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PrivateAccountInstitutionUserResponse =
        new operations.PrivateAccountInstitutionUserResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.user = utils.objectToClass(httpRes?.data, shared.User);
          }
          break;
        case [400, 404, 500].includes(httpRes?.status):
          break;
        case httpRes?.status == 403:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorMessage = utils.objectToClass(
              httpRes?.data,
              shared.ErrorMessage
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Private Account Categories
   *
   * @remarks
   * List institution categories (including parent Categories)
   */
  privateCategoriesList(
    config?: AxiosRequestConfig
  ): Promise<operations.PrivateCategoriesListResponse> {
    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/account/categories";

    const client: AxiosInstance = this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PrivateCategoriesListResponse =
        new operations.PrivateCategoriesListResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.categories = [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.categories = utils.objectToClass(
              httpRes?.data,
              shared.Category,
              resFieldDepth
            );
          }
          break;
        case [400, 500].includes(httpRes?.status):
          break;
        case httpRes?.status == 403:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorMessage = utils.objectToClass(
              httpRes?.data,
              shared.ErrorMessage
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Private Account Institution Group Embargo Options
   *
   * @remarks
   * Account institution group embargo options details
   */
  privateGroupEmbargoOptionsDetails(
    req: operations.PrivateGroupEmbargoOptionsDetailsRequest,
    security: operations.PrivateGroupEmbargoOptionsDetailsSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.PrivateGroupEmbargoOptionsDetailsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PrivateGroupEmbargoOptionsDetailsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/account/institution/groups/{group_id}/embargo_options",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.PrivateGroupEmbargoOptionsDetailsSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PrivateGroupEmbargoOptionsDetailsResponse =
        new operations.PrivateGroupEmbargoOptionsDetailsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.groupEmbargoOptions = [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.groupEmbargoOptions = utils.objectToClass(
              httpRes?.data,
              shared.GroupEmbargoOptions,
              resFieldDepth
            );
          }
          break;
        case [400, 500].includes(httpRes?.status):
          break;
        case httpRes?.status == 403:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorMessage = utils.objectToClass(
              httpRes?.data,
              shared.ErrorMessage
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Delete Institution Account Group Role
   *
   * @remarks
   * Delete Institution Account Group Role
   */
  privateInstitutionAccountGroupRoleDelete(
    req: operations.PrivateInstitutionAccountGroupRoleDeleteRequest,
    security: operations.PrivateInstitutionAccountGroupRoleDeleteSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.PrivateInstitutionAccountGroupRoleDeleteResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PrivateInstitutionAccountGroupRoleDeleteRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/account/institution/roles/{account_id}/{group_id}/{role_id}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.PrivateInstitutionAccountGroupRoleDeleteSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PrivateInstitutionAccountGroupRoleDeleteResponse =
        new operations.PrivateInstitutionAccountGroupRoleDeleteResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case [204, 400, 404, 500].includes(httpRes?.status):
          break;
        case httpRes?.status == 403:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorMessage = utils.objectToClass(
              httpRes?.data,
              shared.ErrorMessage
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * List Institution Account Group Roles
   *
   * @remarks
   * List Institution Account Group Roles
   */
  privateInstitutionAccountGroupRoles(
    req: operations.PrivateInstitutionAccountGroupRolesRequest,
    security: operations.PrivateInstitutionAccountGroupRolesSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.PrivateInstitutionAccountGroupRolesResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PrivateInstitutionAccountGroupRolesRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/account/institution/roles/{account_id}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.PrivateInstitutionAccountGroupRolesSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PrivateInstitutionAccountGroupRolesResponse =
        new operations.PrivateInstitutionAccountGroupRolesResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.accountGroupRoles = utils.objectToClass(httpRes?.data);
          }
          break;
        case [400, 404, 500].includes(httpRes?.status):
          break;
        case httpRes?.status == 403:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorMessage = utils.objectToClass(
              httpRes?.data,
              shared.ErrorMessage
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Add Institution Account Group Roles
   *
   * @remarks
   * Add Institution Account Group Roles
   */
  privateInstitutionAccountGroupRolesCreate(
    req: operations.PrivateInstitutionAccountGroupRolesCreateRequest,
    security: operations.PrivateInstitutionAccountGroupRolesCreateSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.PrivateInstitutionAccountGroupRolesCreateResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PrivateInstitutionAccountGroupRolesCreateRequest(
        req
      );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/account/institution/roles/{account_id}",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.PrivateInstitutionAccountGroupRolesCreateSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PrivateInstitutionAccountGroupRolesCreateResponse =
        new operations.PrivateInstitutionAccountGroupRolesCreateResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case [201, 400, 500].includes(httpRes?.status):
          break;
        case httpRes?.status == 403:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorMessage = utils.objectToClass(
              httpRes?.data,
              shared.ErrorMessage
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Create new Institution Account
   *
   * @remarks
   * Create a new Account by sending account information
   */
  privateInstitutionAccountsCreate(
    req: shared.AccountCreate,
    security: operations.PrivateInstitutionAccountsCreateSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.PrivateInstitutionAccountsCreateResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new shared.AccountCreate(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/account/institution/accounts";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "request",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.PrivateInstitutionAccountsCreateSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PrivateInstitutionAccountsCreateResponse =
        new operations.PrivateInstitutionAccountsCreateResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case [201, 400, 500].includes(httpRes?.status):
          break;
        case httpRes?.status == 403:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorMessage = utils.objectToClass(
              httpRes?.data,
              shared.ErrorMessage
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Private Account Institution Accounts
   *
   * @remarks
   * Returns the accounts for which the account has administrative privileges (assigned and inherited).
   */
  privateInstitutionAccountsList(
    req: operations.PrivateInstitutionAccountsListRequest,
    security: operations.PrivateInstitutionAccountsListSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.PrivateInstitutionAccountsListResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PrivateInstitutionAccountsListRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/account/institution/accounts";
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.PrivateInstitutionAccountsListSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PrivateInstitutionAccountsListResponse =
        new operations.PrivateInstitutionAccountsListResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.shortAccounts = [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.shortAccounts = utils.objectToClass(
              httpRes?.data,
              shared.ShortAccount,
              resFieldDepth
            );
          }
          break;
        case [400, 500].includes(httpRes?.status):
          break;
        case httpRes?.status == 403:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorMessage = utils.objectToClass(
              httpRes?.data,
              shared.ErrorMessage
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Private Account Institution Accounts Search
   *
   * @remarks
   * Returns the accounts for which the account has administrative privileges (assigned and inherited).
   */
  privateInstitutionAccountsSearch(
    req: shared.InstitutionAccountsSearch,
    security: operations.PrivateInstitutionAccountsSearchSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.PrivateInstitutionAccountsSearchResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new shared.InstitutionAccountsSearch(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/account/institution/accounts/search";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "request",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.PrivateInstitutionAccountsSearchSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PrivateInstitutionAccountsSearchResponse =
        new operations.PrivateInstitutionAccountsSearchResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.shortAccounts = [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.shortAccounts = utils.objectToClass(
              httpRes?.data,
              shared.ShortAccount,
              resFieldDepth
            );
          }
          break;
        case [400, 500].includes(httpRes?.status):
          break;
        case httpRes?.status == 403:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorMessage = utils.objectToClass(
              httpRes?.data,
              shared.ErrorMessage
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Update Institution Account
   *
   * @remarks
   * Update Institution Account
   */
  privateInstitutionAccountsUpdate(
    req: operations.PrivateInstitutionAccountsUpdateRequest,
    security: operations.PrivateInstitutionAccountsUpdateSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.PrivateInstitutionAccountsUpdateResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PrivateInstitutionAccountsUpdateRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/account/institution/accounts/{account_id}",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "accountUpdate",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.PrivateInstitutionAccountsUpdateSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "put",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PrivateInstitutionAccountsUpdateResponse =
        new operations.PrivateInstitutionAccountsUpdateResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
          headers: utils.getHeadersFromResponse(httpRes.headers),
        });
      switch (true) {
        case httpRes?.status == 205:
          break;
        case [400, 404, 500].includes(httpRes?.status):
          break;
        case httpRes?.status == 403:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorMessage = utils.objectToClass(
              httpRes?.data,
              shared.ErrorMessage
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Private Institution Articles
   *
   * @remarks
   * Get Articles from own institution. User must be administrator of the institution
   */
  privateInstitutionArticles(
    req: operations.PrivateInstitutionArticlesRequest,
    security: operations.PrivateInstitutionArticlesSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.PrivateInstitutionArticlesResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PrivateInstitutionArticlesRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/account/institution/articles";
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.PrivateInstitutionArticlesSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PrivateInstitutionArticlesResponse =
        new operations.PrivateInstitutionArticlesResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.articles = [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.articles = utils.objectToClass(
              httpRes?.data,
              shared.Article,
              resFieldDepth
            );
          }
          break;
        case [400, 500].includes(httpRes?.status):
          break;
        case httpRes?.status == 403:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorMessage = utils.objectToClass(
              httpRes?.data,
              shared.ErrorMessage
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Private Account Institutions
   *
   * @remarks
   * Account institution details
   */
  privateInstitutionDetails(
    config?: AxiosRequestConfig
  ): Promise<operations.PrivateInstitutionDetailsResponse> {
    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/account/institution";

    const client: AxiosInstance = this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PrivateInstitutionDetailsResponse =
        new operations.PrivateInstitutionDetailsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.institution = utils.objectToClass(
              httpRes?.data,
              shared.Institution
            );
          }
          break;
        case [400, 500].includes(httpRes?.status):
          break;
        case httpRes?.status == 403:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorMessage = utils.objectToClass(
              httpRes?.data,
              shared.ErrorMessage
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Private Account Institution embargo options
   *
   * @remarks
   * Account institution embargo options details
   */
  privateInstitutionEmbargoOptionsDetails(
    config?: AxiosRequestConfig
  ): Promise<operations.PrivateInstitutionEmbargoOptionsDetailsResponse> {
    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/account/institution/embargo_options";

    const client: AxiosInstance = this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PrivateInstitutionEmbargoOptionsDetailsResponse =
        new operations.PrivateInstitutionEmbargoOptionsDetailsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.groupEmbargoOptions = [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.groupEmbargoOptions = utils.objectToClass(
              httpRes?.data,
              shared.GroupEmbargoOptions,
              resFieldDepth
            );
          }
          break;
        case [400, 500].includes(httpRes?.status):
          break;
        case httpRes?.status == 403:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorMessage = utils.objectToClass(
              httpRes?.data,
              shared.ErrorMessage
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Private Account Institution Groups
   *
   * @remarks
   * Returns the groups for which the account has administrative privileges (assigned and inherited).
   */
  privateInstitutionGroupsList(
    config?: AxiosRequestConfig
  ): Promise<operations.PrivateInstitutionGroupsListResponse> {
    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/account/institution/groups";

    const client: AxiosInstance = this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PrivateInstitutionGroupsListResponse =
        new operations.PrivateInstitutionGroupsListResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.groups = [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.groups = utils.objectToClass(
              httpRes?.data,
              shared.Group,
              resFieldDepth
            );
          }
          break;
        case [400, 500].includes(httpRes?.status):
          break;
        case httpRes?.status == 403:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorMessage = utils.objectToClass(
              httpRes?.data,
              shared.ErrorMessage
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Private Account Institution Roles
   *
   * @remarks
   * Returns the roles available for groups and the institution group.
   */
  privateInstitutionRolesList(
    config?: AxiosRequestConfig
  ): Promise<operations.PrivateInstitutionRolesListResponse> {
    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/account/institution/roles";

    const client: AxiosInstance = this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PrivateInstitutionRolesListResponse =
        new operations.PrivateInstitutionRolesListResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.roles = [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.roles = utils.objectToClass(
              httpRes?.data,
              shared.Role,
              resFieldDepth
            );
          }
          break;
        case [400, 500].includes(httpRes?.status):
          break;
        case httpRes?.status == 403:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorMessage = utils.objectToClass(
              httpRes?.data,
              shared.ErrorMessage
            );
          }
          break;
      }

      return res;
    });
  }
}
