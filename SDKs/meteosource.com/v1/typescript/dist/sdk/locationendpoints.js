"use strict";
/*
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.LocationEndpoints = void 0;
var utils = __importStar(require("../internal/utils"));
var operations = __importStar(require("./models/operations"));
var shared = __importStar(require("./models/shared"));
var LocationEndpoints = /** @class */ (function () {
    function LocationEndpoints(defaultClient, securityClient, serverURL, language, sdkVersion, genVersion) {
        this._defaultClient = defaultClient;
        this._securityClient = securityClient;
        this._serverURL = serverURL;
        this._language = language;
        this._sdkVersion = sdkVersion;
        this._genVersion = genVersion;
    }
    /**
     * Search for places. Complete words required.
     *
     * @remarks
     * ## Search for places
     *
     * You can use this endpoint to obtain `place_id` of the location you want, to be used in `point` endpoint.
     * The response also contains detailed information about the location, such as coordinates, timezone and the country the place belongs to.
     *
     * Unlike the `/find_place_prefix` endpoint, complete words are required here. You can search for cities,
     * mountains, lakes, countries, ZIP codes, etc. The response can contain multiple places, sorted by relevance.
     * You can then identify the one you want by coordinates, country, or the administrative area.
     *
     */
    LocationEndpoints.prototype.findPlacesFindPlacesGet = function (req, security, config) {
        if (!(req instanceof utils.SpeakeasyBase)) {
            req = new operations.FindPlacesFindPlacesGetRequest(req);
        }
        var baseURL = this._serverURL;
        var url = baseURL.replace(/\/$/, "") + "/find_places";
        if (!(security instanceof utils.SpeakeasyBase)) {
            security = new operations.FindPlacesFindPlacesGetSecurity(security);
        }
        var client = utils.createSecurityClient(this._defaultClient, security);
        var queryParams = utils.serializeQueryParams(req);
        var r = client.request(__assign({ url: url + queryParams, method: "get" }, config));
        return r.then(function (httpRes) {
            var _a, _b;
            var contentType = (_b = (_a = httpRes === null || httpRes === void 0 ? void 0 : httpRes.headers) === null || _a === void 0 ? void 0 : _a["content-type"]) !== null && _b !== void 0 ? _b : "";
            if ((httpRes === null || httpRes === void 0 ? void 0 : httpRes.status) == null)
                throw new Error("status code not found in response: ".concat(httpRes));
            var res = new operations.FindPlacesFindPlacesGetResponse({
                statusCode: httpRes.status,
                contentType: contentType,
                rawResponse: httpRes,
            });
            switch (true) {
                case (httpRes === null || httpRes === void 0 ? void 0 : httpRes.status) == 200:
                    if (utils.matchContentType(contentType, "application/json")) {
                        res.findPlacesModels = [];
                        var resFieldDepth = utils.getResFieldDepth(res);
                        res.findPlacesModels = utils.objectToClass(httpRes === null || httpRes === void 0 ? void 0 : httpRes.data, shared.FindPlacesModel, resFieldDepth);
                    }
                    break;
                case [400, 402, 403, 429].includes(httpRes === null || httpRes === void 0 ? void 0 : httpRes.status):
                    if (utils.matchContentType(contentType, "application/json")) {
                        res.generalRequestError = utils.objectToClass(httpRes === null || httpRes === void 0 ? void 0 : httpRes.data, shared.GeneralRequestError);
                    }
                    break;
                case (httpRes === null || httpRes === void 0 ? void 0 : httpRes.status) == 422:
                    if (utils.matchContentType(contentType, "application/json")) {
                        res.httpValidationError = utils.objectToClass(httpRes === null || httpRes === void 0 ? void 0 : httpRes.data, shared.HTTPValidationError);
                    }
                    break;
            }
            return res;
        });
    };
    /**
     * Prefix search for places. Useful for autocomplete forms.
     *
     * @remarks
     * ## Search for places by prefix
     *
     * You can use this endpoint to obtain `place_id` of the location you want, to be used in `point` endpoint. The response also contains detailed information about the location, such as coordinates, timezone and the country the place belongs to.
     *
     * Unlike the `/find_places` endpoint, you should only specify the prefix of the place you are looking for. This is particularly useful for autocomplete forms. You can search for cities, mountains, lakes, countries, ZIP codes, etc. The response can contain multiple places, sorted by relevance. You can then identify the one you want by coordinates, country, or the administrative area.
     *
     */
    LocationEndpoints.prototype.findPlacesPrefixFindPlacesPrefixGet = function (req, security, config) {
        if (!(req instanceof utils.SpeakeasyBase)) {
            req = new operations.FindPlacesPrefixFindPlacesPrefixGetRequest(req);
        }
        var baseURL = this._serverURL;
        var url = baseURL.replace(/\/$/, "") + "/find_places_prefix";
        if (!(security instanceof utils.SpeakeasyBase)) {
            security = new operations.FindPlacesPrefixFindPlacesPrefixGetSecurity(security);
        }
        var client = utils.createSecurityClient(this._defaultClient, security);
        var queryParams = utils.serializeQueryParams(req);
        var r = client.request(__assign({ url: url + queryParams, method: "get" }, config));
        return r.then(function (httpRes) {
            var _a, _b;
            var contentType = (_b = (_a = httpRes === null || httpRes === void 0 ? void 0 : httpRes.headers) === null || _a === void 0 ? void 0 : _a["content-type"]) !== null && _b !== void 0 ? _b : "";
            if ((httpRes === null || httpRes === void 0 ? void 0 : httpRes.status) == null)
                throw new Error("status code not found in response: ".concat(httpRes));
            var res = new operations.FindPlacesPrefixFindPlacesPrefixGetResponse({
                statusCode: httpRes.status,
                contentType: contentType,
                rawResponse: httpRes,
            });
            switch (true) {
                case (httpRes === null || httpRes === void 0 ? void 0 : httpRes.status) == 200:
                    if (utils.matchContentType(contentType, "application/json")) {
                        res.findPlacesModels = [];
                        var resFieldDepth = utils.getResFieldDepth(res);
                        res.findPlacesModels = utils.objectToClass(httpRes === null || httpRes === void 0 ? void 0 : httpRes.data, shared.FindPlacesModel, resFieldDepth);
                    }
                    break;
                case [400, 402, 403, 429].includes(httpRes === null || httpRes === void 0 ? void 0 : httpRes.status):
                    if (utils.matchContentType(contentType, "application/json")) {
                        res.generalRequestError = utils.objectToClass(httpRes === null || httpRes === void 0 ? void 0 : httpRes.data, shared.GeneralRequestError);
                    }
                    break;
                case (httpRes === null || httpRes === void 0 ? void 0 : httpRes.status) == 422:
                    if (utils.matchContentType(contentType, "application/json")) {
                        res.httpValidationError = utils.objectToClass(httpRes === null || httpRes === void 0 ? void 0 : httpRes.data, shared.HTTPValidationError);
                    }
                    break;
            }
            return res;
        });
    };
    /**
     * Returns the nearest named location for a given GPS coordinates.
     *
     * @remarks
     * ## Search for nearest place by coordinates
     *
     * You can use this endpoint to find the nearest place from given coordinates.
     *
     * *Note: If you specify coordinates of a secluded place (e.g. middle of the ocean), the nearest point can be very far from the coordinates.*
     *
     */
    LocationEndpoints.prototype.nearestPlaceNearestPlaceGet = function (req, security, config) {
        if (!(req instanceof utils.SpeakeasyBase)) {
            req = new operations.NearestPlaceNearestPlaceGetRequest(req);
        }
        var baseURL = this._serverURL;
        var url = baseURL.replace(/\/$/, "") + "/nearest_place";
        if (!(security instanceof utils.SpeakeasyBase)) {
            security = new operations.NearestPlaceNearestPlaceGetSecurity(security);
        }
        var client = utils.createSecurityClient(this._defaultClient, security);
        var queryParams = utils.serializeQueryParams(req);
        var r = client.request(__assign({ url: url + queryParams, method: "get" }, config));
        return r.then(function (httpRes) {
            var _a, _b;
            var contentType = (_b = (_a = httpRes === null || httpRes === void 0 ? void 0 : httpRes.headers) === null || _a === void 0 ? void 0 : _a["content-type"]) !== null && _b !== void 0 ? _b : "";
            if ((httpRes === null || httpRes === void 0 ? void 0 : httpRes.status) == null)
                throw new Error("status code not found in response: ".concat(httpRes));
            var res = new operations.NearestPlaceNearestPlaceGetResponse({
                statusCode: httpRes.status,
                contentType: contentType,
                rawResponse: httpRes,
            });
            switch (true) {
                case (httpRes === null || httpRes === void 0 ? void 0 : httpRes.status) == 200:
                    if (utils.matchContentType(contentType, "application/json")) {
                        res.findPlacesModel = utils.objectToClass(httpRes === null || httpRes === void 0 ? void 0 : httpRes.data, shared.FindPlacesModel);
                    }
                    break;
                case [400, 402, 403, 429].includes(httpRes === null || httpRes === void 0 ? void 0 : httpRes.status):
                    if (utils.matchContentType(contentType, "application/json")) {
                        res.generalRequestError = utils.objectToClass(httpRes === null || httpRes === void 0 ? void 0 : httpRes.data, shared.GeneralRequestError);
                    }
                    break;
                case (httpRes === null || httpRes === void 0 ? void 0 : httpRes.status) == 422:
                    if (utils.matchContentType(contentType, "application/json")) {
                        res.httpValidationError = utils.objectToClass(httpRes === null || httpRes === void 0 ? void 0 : httpRes.data, shared.HTTPValidationError);
                    }
                    break;
            }
            return res;
        });
    };
    return LocationEndpoints;
}());
exports.LocationEndpoints = LocationEndpoints;
