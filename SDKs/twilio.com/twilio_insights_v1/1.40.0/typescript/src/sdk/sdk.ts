/*
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

import * as utils from "../internal/utils";
import * as operations from "./models/operations";
import * as shared from "./models/shared";
import axios from "axios";
import { AxiosInstance, AxiosRequestConfig, AxiosResponse } from "axios";

/**
 * Contains the list of servers available to the SDK
 */
export const ServerList = ["https://insights.twilio.com"] as const;

/**
 * The available configuration options for the SDK
 */
export type SDKProps = {
  /**
   * Allows overriding the default axios client used by the SDK
   */
  defaultClient?: AxiosInstance;
  /**
   * Allows overriding the default server URL used by the SDK
   */
  serverURL?: string;
};

/**
 * This is the public Twilio REST API.
 */
export class SDK {
  public _defaultClient: AxiosInstance;
  public _securityClient: AxiosInstance;
  public _serverURL: string;
  private _language = "typescript";
  private _sdkVersion = "0.0.1";
  private _genVersion = "internal";
  private _globals: any;

  constructor(props?: SDKProps) {
    this._serverURL = props?.serverURL ?? ServerList[0];

    this._defaultClient =
      props?.defaultClient ?? axios.create({ baseURL: this._serverURL });
    this._securityClient = this._defaultClient;
  }

  fetchAccountSettings(
    req: operations.FetchAccountSettingsRequest,
    security: operations.FetchAccountSettingsSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.FetchAccountSettingsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.FetchAccountSettingsRequest(req);
    }

    let baseURL: string = operations.FetchAccountSettingsServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = baseURL.replace(/\/$/, "") + "/v1/Voice/Settings";
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.FetchAccountSettingsSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.FetchAccountSettingsResponse =
        new operations.FetchAccountSettingsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.insightsV1AccountSettings = utils.objectToClass(
              httpRes?.data,
              shared.InsightsV1AccountSettings
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Fetch a specific Annotation.
   */
  fetchAnnotation(
    req: operations.FetchAnnotationRequest,
    security: operations.FetchAnnotationSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.FetchAnnotationResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.FetchAnnotationRequest(req);
    }

    let baseURL: string = operations.FetchAnnotationServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v1/Voice/{CallSid}/Annotation",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.FetchAnnotationSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.FetchAnnotationResponse =
        new operations.FetchAnnotationResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.insightsV1CallAnnotation = utils.objectToClass(
              httpRes?.data,
              shared.InsightsV1CallAnnotation
            );
          }
          break;
      }

      return res;
    });
  }

  fetchCall(
    req: operations.FetchCallRequest,
    security: operations.FetchCallSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.FetchCallResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.FetchCallRequest(req);
    }

    let baseURL: string = operations.FetchCallServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(baseURL, "/v1/Voice/{Sid}", req);
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.FetchCallSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.FetchCallResponse =
        new operations.FetchCallResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.insightsV1Call = utils.objectToClass(
              httpRes?.data,
              shared.InsightsV1Call
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Fetch a specific Conference.
   */
  fetchConference(
    req: operations.FetchConferenceRequest,
    security: operations.FetchConferenceSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.FetchConferenceResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.FetchConferenceRequest(req);
    }

    let baseURL: string = operations.FetchConferenceServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v1/Conferences/{ConferenceSid}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.FetchConferenceSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.FetchConferenceResponse =
        new operations.FetchConferenceResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.insightsV1Conference = utils.objectToClass(
              httpRes?.data,
              shared.InsightsV1Conference
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Fetch a specific Conference Participant Summary.
   */
  fetchConferenceParticipant(
    req: operations.FetchConferenceParticipantRequest,
    security: operations.FetchConferenceParticipantSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.FetchConferenceParticipantResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.FetchConferenceParticipantRequest(req);
    }

    let baseURL: string = operations.FetchConferenceParticipantServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v1/Conferences/{ConferenceSid}/Participants/{ParticipantSid}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.FetchConferenceParticipantSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.FetchConferenceParticipantResponse =
        new operations.FetchConferenceParticipantResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.insightsV1ConferenceConferenceParticipant = utils.objectToClass(
              httpRes?.data,
              shared.InsightsV1ConferenceConferenceParticipant
            );
          }
          break;
      }

      return res;
    });
  }

  fetchSummary(
    req: operations.FetchSummaryRequest,
    security: operations.FetchSummarySecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.FetchSummaryResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.FetchSummaryRequest(req);
    }

    let baseURL: string = operations.FetchSummaryServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v1/Voice/{CallSid}/Summary",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.FetchSummarySecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.FetchSummaryResponse =
        new operations.FetchSummaryResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.insightsV1CallSummary = utils.objectToClass(
              httpRes?.data,
              shared.InsightsV1CallSummary
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Get Video Log Analyzer data for a Room Participant.
   */
  fetchVideoParticipantSummary(
    req: operations.FetchVideoParticipantSummaryRequest,
    security: operations.FetchVideoParticipantSummarySecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.FetchVideoParticipantSummaryResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.FetchVideoParticipantSummaryRequest(req);
    }

    let baseURL: string = operations.FetchVideoParticipantSummaryServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v1/Video/Rooms/{RoomSid}/Participants/{ParticipantSid}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.FetchVideoParticipantSummarySecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.FetchVideoParticipantSummaryResponse =
        new operations.FetchVideoParticipantSummaryResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.insightsV1VideoRoomSummaryVideoParticipantSummary =
              utils.objectToClass(
                httpRes?.data,
                shared.InsightsV1VideoRoomSummaryVideoParticipantSummary
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Get Video Log Analyzer data for a Room.
   */
  fetchVideoRoomSummary(
    req: operations.FetchVideoRoomSummaryRequest,
    security: operations.FetchVideoRoomSummarySecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.FetchVideoRoomSummaryResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.FetchVideoRoomSummaryRequest(req);
    }

    let baseURL: string = operations.FetchVideoRoomSummaryServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v1/Video/Rooms/{RoomSid}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.FetchVideoRoomSummarySecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.FetchVideoRoomSummaryResponse =
        new operations.FetchVideoRoomSummaryResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.insightsV1VideoRoomSummary = utils.objectToClass(
              httpRes?.data,
              shared.InsightsV1VideoRoomSummary
            );
          }
          break;
      }

      return res;
    });
  }

  listCallSummaries(
    req: operations.ListCallSummariesRequest,
    security: operations.ListCallSummariesSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.ListCallSummariesResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ListCallSummariesRequest(req);
    }

    let baseURL: string = operations.ListCallSummariesServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = baseURL.replace(/\/$/, "") + "/v1/Voice/Summaries";
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ListCallSummariesSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ListCallSummariesResponse =
        new operations.ListCallSummariesResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listCallSummariesResponse = utils.objectToClass(
              httpRes?.data,
              operations.ListCallSummariesListCallSummariesResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Retrieve a list of Conferences.
   */
  listConference(
    req: operations.ListConferenceRequest,
    security: operations.ListConferenceSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.ListConferenceResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ListConferenceRequest(req);
    }

    let baseURL: string = operations.ListConferenceServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = baseURL.replace(/\/$/, "") + "/v1/Conferences";
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ListConferenceSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ListConferenceResponse =
        new operations.ListConferenceResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listConferenceResponse = utils.objectToClass(
              httpRes?.data,
              operations.ListConferenceListConferenceResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * List Conference Participants.
   */
  listConferenceParticipant(
    req: operations.ListConferenceParticipantRequest,
    security: operations.ListConferenceParticipantSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.ListConferenceParticipantResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ListConferenceParticipantRequest(req);
    }

    let baseURL: string = operations.ListConferenceParticipantServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v1/Conferences/{ConferenceSid}/Participants",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ListConferenceParticipantSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ListConferenceParticipantResponse =
        new operations.ListConferenceParticipantResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listConferenceParticipantResponse = utils.objectToClass(
              httpRes?.data,
              operations.ListConferenceParticipantListConferenceParticipantResponse
            );
          }
          break;
      }

      return res;
    });
  }

  listEvent(
    req: operations.ListEventRequest,
    security: operations.ListEventSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.ListEventResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ListEventRequest(req);
    }

    let baseURL: string = operations.ListEventServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v1/Voice/{CallSid}/Events",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ListEventSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ListEventResponse =
        new operations.ListEventResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listEventResponse = utils.objectToClass(
              httpRes?.data,
              operations.ListEventListEventResponse
            );
          }
          break;
      }

      return res;
    });
  }

  listMetric(
    req: operations.ListMetricRequest,
    security: operations.ListMetricSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.ListMetricResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ListMetricRequest(req);
    }

    let baseURL: string = operations.ListMetricServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v1/Voice/{CallSid}/Metrics",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ListMetricSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ListMetricResponse =
        new operations.ListMetricResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listMetricResponse = utils.objectToClass(
              httpRes?.data,
              operations.ListMetricListMetricResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Get a list of room participants.
   */
  listVideoParticipantSummary(
    req: operations.ListVideoParticipantSummaryRequest,
    security: operations.ListVideoParticipantSummarySecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.ListVideoParticipantSummaryResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ListVideoParticipantSummaryRequest(req);
    }

    let baseURL: string = operations.ListVideoParticipantSummaryServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v1/Video/Rooms/{RoomSid}/Participants",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ListVideoParticipantSummarySecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ListVideoParticipantSummaryResponse =
        new operations.ListVideoParticipantSummaryResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listVideoParticipantSummaryResponse = utils.objectToClass(
              httpRes?.data,
              operations.ListVideoParticipantSummaryListVideoParticipantSummaryResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Get a list of Programmable Video Rooms.
   */
  listVideoRoomSummary(
    req: operations.ListVideoRoomSummaryRequest,
    security: operations.ListVideoRoomSummarySecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.ListVideoRoomSummaryResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ListVideoRoomSummaryRequest(req);
    }

    let baseURL: string = operations.ListVideoRoomSummaryServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = baseURL.replace(/\/$/, "") + "/v1/Video/Rooms";
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ListVideoRoomSummarySecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ListVideoRoomSummaryResponse =
        new operations.ListVideoRoomSummaryResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listVideoRoomSummaryResponse = utils.objectToClass(
              httpRes?.data,
              operations.ListVideoRoomSummaryListVideoRoomSummaryResponse
            );
          }
          break;
      }

      return res;
    });
  }

  updateAccountSettings(
    req: operations.UpdateAccountSettingsUpdateAccountSettingsRequest,
    security: operations.UpdateAccountSettingsSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.UpdateAccountSettingsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.UpdateAccountSettingsUpdateAccountSettingsRequest(
        req
      );
    }

    let baseURL: string = operations.UpdateAccountSettingsServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = baseURL.replace(/\/$/, "") + "/v1/Voice/Settings";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "request",
        "form"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.UpdateAccountSettingsSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UpdateAccountSettingsResponse =
        new operations.UpdateAccountSettingsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.insightsV1AccountSettings = utils.objectToClass(
              httpRes?.data,
              shared.InsightsV1AccountSettings
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Create/Update the annotation for the call
   */
  updateAnnotation(
    req: operations.UpdateAnnotationRequest,
    security: operations.UpdateAnnotationSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.UpdateAnnotationResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.UpdateAnnotationRequest(req);
    }

    let baseURL: string = operations.UpdateAnnotationServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v1/Voice/{CallSid}/Annotation",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "form"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.UpdateAnnotationSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UpdateAnnotationResponse =
        new operations.UpdateAnnotationResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.insightsV1CallAnnotation = utils.objectToClass(
              httpRes?.data,
              shared.InsightsV1CallAnnotation
            );
          }
          break;
      }

      return res;
    });
  }
}
