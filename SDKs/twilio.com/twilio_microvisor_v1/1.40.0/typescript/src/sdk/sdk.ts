/*
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

import * as utils from "../internal/utils";
import * as operations from "./models/operations";
import * as shared from "./models/shared";
import axios from "axios";
import { AxiosInstance, AxiosRequestConfig, AxiosResponse } from "axios";

/**
 * Contains the list of servers available to the SDK
 */
export const ServerList = ["https://microvisor.twilio.com"] as const;

/**
 * The available configuration options for the SDK
 */
export type SDKProps = {
  /**
   * Allows overriding the default axios client used by the SDK
   */
  defaultClient?: AxiosInstance;
  /**
   * Allows overriding the default server URL used by the SDK
   */
  serverURL?: string;
};

/**
 * This is the public Twilio REST API.
 */
export class SDK {
  public _defaultClient: AxiosInstance;
  public _securityClient: AxiosInstance;
  public _serverURL: string;
  private _language = "typescript";
  private _sdkVersion = "0.0.1";
  private _genVersion = "internal";
  private _globals: any;

  constructor(props?: SDKProps) {
    this._serverURL = props?.serverURL ?? ServerList[0];

    this._defaultClient =
      props?.defaultClient ?? axios.create({ baseURL: this._serverURL });
    this._securityClient = this._defaultClient;
  }

  /**
   * Create a config for an Account.
   */
  createAccountConfig(
    req: operations.CreateAccountConfigCreateAccountConfigRequest,
    security: operations.CreateAccountConfigSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.CreateAccountConfigResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CreateAccountConfigCreateAccountConfigRequest(req);
    }

    let baseURL: string = operations.CreateAccountConfigServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = baseURL.replace(/\/$/, "") + "/v1/Configs";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "request",
        "form"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.CreateAccountConfigSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CreateAccountConfigResponse =
        new operations.CreateAccountConfigResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.microvisorV1AccountConfig = utils.objectToClass(
              httpRes?.data,
              shared.MicrovisorV1AccountConfig
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Create a secret for an Account.
   */
  createAccountSecret(
    req: operations.CreateAccountSecretCreateAccountSecretRequest,
    security: operations.CreateAccountSecretSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.CreateAccountSecretResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CreateAccountSecretCreateAccountSecretRequest(req);
    }

    let baseURL: string = operations.CreateAccountSecretServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = baseURL.replace(/\/$/, "") + "/v1/Secrets";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "request",
        "form"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.CreateAccountSecretSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CreateAccountSecretResponse =
        new operations.CreateAccountSecretResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.microvisorV1AccountSecret = utils.objectToClass(
              httpRes?.data,
              shared.MicrovisorV1AccountSecret
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Create a config for a Microvisor Device.
   */
  createDeviceConfig(
    req: operations.CreateDeviceConfigRequest,
    security: operations.CreateDeviceConfigSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.CreateDeviceConfigResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CreateDeviceConfigRequest(req);
    }

    let baseURL: string = operations.CreateDeviceConfigServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v1/Devices/{DeviceSid}/Configs",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "form"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.CreateDeviceConfigSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CreateDeviceConfigResponse =
        new operations.CreateDeviceConfigResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.microvisorV1DeviceDeviceConfig = utils.objectToClass(
              httpRes?.data,
              shared.MicrovisorV1DeviceDeviceConfig
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Create a secret for a Microvisor Device.
   */
  createDeviceSecret(
    req: operations.CreateDeviceSecretRequest,
    security: operations.CreateDeviceSecretSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.CreateDeviceSecretResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CreateDeviceSecretRequest(req);
    }

    let baseURL: string = operations.CreateDeviceSecretServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v1/Devices/{DeviceSid}/Secrets",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "form"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.CreateDeviceSecretSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CreateDeviceSecretResponse =
        new operations.CreateDeviceSecretResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.microvisorV1DeviceDeviceSecret = utils.objectToClass(
              httpRes?.data,
              shared.MicrovisorV1DeviceDeviceSecret
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Delete a config for an Account.
   */
  deleteAccountConfig(
    req: operations.DeleteAccountConfigRequest,
    security: operations.DeleteAccountConfigSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.DeleteAccountConfigResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DeleteAccountConfigRequest(req);
    }

    let baseURL: string = operations.DeleteAccountConfigServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(baseURL, "/v1/Configs/{Key}", req);
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.DeleteAccountConfigSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DeleteAccountConfigResponse =
        new operations.DeleteAccountConfigResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
      }

      return res;
    });
  }

  /**
   * Delete a secret for an Account.
   */
  deleteAccountSecret(
    req: operations.DeleteAccountSecretRequest,
    security: operations.DeleteAccountSecretSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.DeleteAccountSecretResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DeleteAccountSecretRequest(req);
    }

    let baseURL: string = operations.DeleteAccountSecretServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(baseURL, "/v1/Secrets/{Key}", req);
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.DeleteAccountSecretSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DeleteAccountSecretResponse =
        new operations.DeleteAccountSecretResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
      }

      return res;
    });
  }

  /**
   * Delete a specific App.
   */
  deleteApp(
    req: operations.DeleteAppRequest,
    security: operations.DeleteAppSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.DeleteAppResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DeleteAppRequest(req);
    }

    let baseURL: string = operations.DeleteAppServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(baseURL, "/v1/Apps/{Sid}", req);
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.DeleteAppSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DeleteAppResponse =
        new operations.DeleteAppResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
      }

      return res;
    });
  }

  /**
   * Delete a config for a Microvisor Device.
   */
  deleteDeviceConfig(
    req: operations.DeleteDeviceConfigRequest,
    security: operations.DeleteDeviceConfigSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.DeleteDeviceConfigResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DeleteDeviceConfigRequest(req);
    }

    let baseURL: string = operations.DeleteDeviceConfigServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v1/Devices/{DeviceSid}/Configs/{Key}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.DeleteDeviceConfigSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DeleteDeviceConfigResponse =
        new operations.DeleteDeviceConfigResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
      }

      return res;
    });
  }

  /**
   * Delete a secret for a Microvisor Device.
   */
  deleteDeviceSecret(
    req: operations.DeleteDeviceSecretRequest,
    security: operations.DeleteDeviceSecretSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.DeleteDeviceSecretResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DeleteDeviceSecretRequest(req);
    }

    let baseURL: string = operations.DeleteDeviceSecretServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v1/Devices/{DeviceSid}/Secrets/{Key}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.DeleteDeviceSecretSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DeleteDeviceSecretResponse =
        new operations.DeleteDeviceSecretResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
      }

      return res;
    });
  }

  /**
   * Retrieve a Config for an Account.
   */
  fetchAccountConfig(
    req: operations.FetchAccountConfigRequest,
    security: operations.FetchAccountConfigSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.FetchAccountConfigResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.FetchAccountConfigRequest(req);
    }

    let baseURL: string = operations.FetchAccountConfigServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(baseURL, "/v1/Configs/{Key}", req);
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.FetchAccountConfigSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.FetchAccountConfigResponse =
        new operations.FetchAccountConfigResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.microvisorV1AccountConfig = utils.objectToClass(
              httpRes?.data,
              shared.MicrovisorV1AccountConfig
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Retrieve a Secret for an Account.
   */
  fetchAccountSecret(
    req: operations.FetchAccountSecretRequest,
    security: operations.FetchAccountSecretSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.FetchAccountSecretResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.FetchAccountSecretRequest(req);
    }

    let baseURL: string = operations.FetchAccountSecretServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(baseURL, "/v1/Secrets/{Key}", req);
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.FetchAccountSecretSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.FetchAccountSecretResponse =
        new operations.FetchAccountSecretResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.microvisorV1AccountSecret = utils.objectToClass(
              httpRes?.data,
              shared.MicrovisorV1AccountSecret
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Fetch a specific App.
   */
  fetchApp(
    req: operations.FetchAppRequest,
    security: operations.FetchAppSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.FetchAppResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.FetchAppRequest(req);
    }

    let baseURL: string = operations.FetchAppServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(baseURL, "/v1/Apps/{Sid}", req);
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.FetchAppSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.FetchAppResponse = new operations.FetchAppResponse({
        statusCode: httpRes.status,
        contentType: contentType,
        rawResponse: httpRes,
      });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.microvisorV1App = utils.objectToClass(
              httpRes?.data,
              shared.MicrovisorV1App
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Retrieve the Manifest for an App.
   */
  fetchAppManifest(
    req: operations.FetchAppManifestRequest,
    security: operations.FetchAppManifestSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.FetchAppManifestResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.FetchAppManifestRequest(req);
    }

    let baseURL: string = operations.FetchAppManifestServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v1/Apps/{AppSid}/Manifest",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.FetchAppManifestSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.FetchAppManifestResponse =
        new operations.FetchAppManifestResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.microvisorV1AppAppManifest = utils.objectToClass(
              httpRes?.data,
              shared.MicrovisorV1AppAppManifest
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Fetch a specific Device.
   */
  fetchDevice(
    req: operations.FetchDeviceRequest,
    security: operations.FetchDeviceSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.FetchDeviceResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.FetchDeviceRequest(req);
    }

    let baseURL: string = operations.FetchDeviceServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(baseURL, "/v1/Devices/{Sid}", req);
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.FetchDeviceSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.FetchDeviceResponse =
        new operations.FetchDeviceResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.microvisorV1Device = utils.objectToClass(
              httpRes?.data,
              shared.MicrovisorV1Device
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Retrieve a Config for a Device.
   */
  fetchDeviceConfig(
    req: operations.FetchDeviceConfigRequest,
    security: operations.FetchDeviceConfigSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.FetchDeviceConfigResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.FetchDeviceConfigRequest(req);
    }

    let baseURL: string = operations.FetchDeviceConfigServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v1/Devices/{DeviceSid}/Configs/{Key}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.FetchDeviceConfigSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.FetchDeviceConfigResponse =
        new operations.FetchDeviceConfigResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.microvisorV1DeviceDeviceConfig = utils.objectToClass(
              httpRes?.data,
              shared.MicrovisorV1DeviceDeviceConfig
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Retrieve a Secret for a Device.
   */
  fetchDeviceSecret(
    req: operations.FetchDeviceSecretRequest,
    security: operations.FetchDeviceSecretSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.FetchDeviceSecretResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.FetchDeviceSecretRequest(req);
    }

    let baseURL: string = operations.FetchDeviceSecretServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v1/Devices/{DeviceSid}/Secrets/{Key}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.FetchDeviceSecretSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.FetchDeviceSecretResponse =
        new operations.FetchDeviceSecretResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.microvisorV1DeviceDeviceSecret = utils.objectToClass(
              httpRes?.data,
              shared.MicrovisorV1DeviceDeviceSecret
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Retrieve a list of all Configs for an Account.
   */
  listAccountConfig(
    req: operations.ListAccountConfigRequest,
    security: operations.ListAccountConfigSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.ListAccountConfigResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ListAccountConfigRequest(req);
    }

    let baseURL: string = operations.ListAccountConfigServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = baseURL.replace(/\/$/, "") + "/v1/Configs";
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ListAccountConfigSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ListAccountConfigResponse =
        new operations.ListAccountConfigResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listAccountConfigResponse = utils.objectToClass(
              httpRes?.data,
              operations.ListAccountConfigListAccountConfigResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Retrieve a list of all Secrets for an Account.
   */
  listAccountSecret(
    req: operations.ListAccountSecretRequest,
    security: operations.ListAccountSecretSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.ListAccountSecretResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ListAccountSecretRequest(req);
    }

    let baseURL: string = operations.ListAccountSecretServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = baseURL.replace(/\/$/, "") + "/v1/Secrets";
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ListAccountSecretSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ListAccountSecretResponse =
        new operations.ListAccountSecretResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listAccountSecretResponse = utils.objectToClass(
              httpRes?.data,
              operations.ListAccountSecretListAccountSecretResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Retrieve a list of all Apps for an Account.
   */
  listApp(
    req: operations.ListAppRequest,
    security: operations.ListAppSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.ListAppResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ListAppRequest(req);
    }

    let baseURL: string = operations.ListAppServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = baseURL.replace(/\/$/, "") + "/v1/Apps";
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ListAppSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ListAppResponse = new operations.ListAppResponse({
        statusCode: httpRes.status,
        contentType: contentType,
        rawResponse: httpRes,
      });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listAppResponse = utils.objectToClass(
              httpRes?.data,
              operations.ListAppListAppResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Retrieve a list of all Devices registered with the Account.
   */
  listDevice(
    req: operations.ListDeviceRequest,
    security: operations.ListDeviceSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.ListDeviceResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ListDeviceRequest(req);
    }

    let baseURL: string = operations.ListDeviceServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = baseURL.replace(/\/$/, "") + "/v1/Devices";
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ListDeviceSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ListDeviceResponse =
        new operations.ListDeviceResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listDeviceResponse = utils.objectToClass(
              httpRes?.data,
              operations.ListDeviceListDeviceResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Retrieve a list of all Configs for a Device.
   */
  listDeviceConfig(
    req: operations.ListDeviceConfigRequest,
    security: operations.ListDeviceConfigSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.ListDeviceConfigResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ListDeviceConfigRequest(req);
    }

    let baseURL: string = operations.ListDeviceConfigServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v1/Devices/{DeviceSid}/Configs",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ListDeviceConfigSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ListDeviceConfigResponse =
        new operations.ListDeviceConfigResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listDeviceConfigResponse = utils.objectToClass(
              httpRes?.data,
              operations.ListDeviceConfigListDeviceConfigResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Retrieve a list of all Secrets for a Device.
   */
  listDeviceSecret(
    req: operations.ListDeviceSecretRequest,
    security: operations.ListDeviceSecretSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.ListDeviceSecretResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ListDeviceSecretRequest(req);
    }

    let baseURL: string = operations.ListDeviceSecretServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v1/Devices/{DeviceSid}/Secrets",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ListDeviceSecretSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ListDeviceSecretResponse =
        new operations.ListDeviceSecretResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listDeviceSecretResponse = utils.objectToClass(
              httpRes?.data,
              operations.ListDeviceSecretListDeviceSecretResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Update a config for an Account.
   */
  updateAccountConfig(
    req: operations.UpdateAccountConfigRequest,
    security: operations.UpdateAccountConfigSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.UpdateAccountConfigResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.UpdateAccountConfigRequest(req);
    }

    let baseURL: string = operations.UpdateAccountConfigServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(baseURL, "/v1/Configs/{Key}", req);

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "form"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.UpdateAccountConfigSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UpdateAccountConfigResponse =
        new operations.UpdateAccountConfigResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.microvisorV1AccountConfig = utils.objectToClass(
              httpRes?.data,
              shared.MicrovisorV1AccountConfig
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Update a secret for an Account.
   */
  updateAccountSecret(
    req: operations.UpdateAccountSecretRequest,
    security: operations.UpdateAccountSecretSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.UpdateAccountSecretResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.UpdateAccountSecretRequest(req);
    }

    let baseURL: string = operations.UpdateAccountSecretServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(baseURL, "/v1/Secrets/{Key}", req);

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "form"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.UpdateAccountSecretSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UpdateAccountSecretResponse =
        new operations.UpdateAccountSecretResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.microvisorV1AccountSecret = utils.objectToClass(
              httpRes?.data,
              shared.MicrovisorV1AccountSecret
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Update a specific Device.
   */
  updateDevice(
    req: operations.UpdateDeviceRequest,
    security: operations.UpdateDeviceSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.UpdateDeviceResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.UpdateDeviceRequest(req);
    }

    let baseURL: string = operations.UpdateDeviceServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(baseURL, "/v1/Devices/{Sid}", req);

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "form"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.UpdateDeviceSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UpdateDeviceResponse =
        new operations.UpdateDeviceResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.microvisorV1Device = utils.objectToClass(
              httpRes?.data,
              shared.MicrovisorV1Device
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Update a config for a Microvisor Device.
   */
  updateDeviceConfig(
    req: operations.UpdateDeviceConfigRequest,
    security: operations.UpdateDeviceConfigSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.UpdateDeviceConfigResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.UpdateDeviceConfigRequest(req);
    }

    let baseURL: string = operations.UpdateDeviceConfigServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v1/Devices/{DeviceSid}/Configs/{Key}",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "form"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.UpdateDeviceConfigSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UpdateDeviceConfigResponse =
        new operations.UpdateDeviceConfigResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.microvisorV1DeviceDeviceConfig = utils.objectToClass(
              httpRes?.data,
              shared.MicrovisorV1DeviceDeviceConfig
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Update a secret for a Microvisor Device.
   */
  updateDeviceSecret(
    req: operations.UpdateDeviceSecretRequest,
    security: operations.UpdateDeviceSecretSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.UpdateDeviceSecretResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.UpdateDeviceSecretRequest(req);
    }

    let baseURL: string = operations.UpdateDeviceSecretServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v1/Devices/{DeviceSid}/Secrets/{Key}",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "form"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.UpdateDeviceSecretSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UpdateDeviceSecretResponse =
        new operations.UpdateDeviceSecretResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.microvisorV1DeviceDeviceSecret = utils.objectToClass(
              httpRes?.data,
              shared.MicrovisorV1DeviceDeviceSecret
            );
          }
          break;
      }

      return res;
    });
  }
}
