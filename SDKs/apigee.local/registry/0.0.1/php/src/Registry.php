<?php

/**
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

declare(strict_types=1);

namespace OpenAPI\OpenAPI;

class Registry 
{

	// SDK private variables namespaced with _ to avoid conflicts with API models
	private \GuzzleHttp\ClientInterface $_defaultClient;
	private \GuzzleHttp\ClientInterface $_securityClient;
	private string $_serverUrl;
	private string $_language;
	private string $_sdkVersion;
	private string $_genVersion;	

	/**
	 * @param \GuzzleHttp\ClientInterface $defaultClient
	 * @param \GuzzleHttp\ClientInterface $securityClient
	 * @param string $serverUrl
	 * @param string $language
	 * @param string $sdkVersion
	 * @param string $genVersion
	 */
	public function __construct(\GuzzleHttp\ClientInterface $defaultClient, \GuzzleHttp\ClientInterface $securityClient, string $serverUrl, string $language, string $sdkVersion, string $genVersion)
	{
		$this->_defaultClient = $defaultClient;
		$this->_securityClient = $securityClient;
		$this->_serverUrl = $serverUrl;
		$this->_language = $language;
		$this->_sdkVersion = $sdkVersion;
		$this->_genVersion = $genVersion;
	}
	
    /**
     * CreateApi creates a specified API.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\RegistryCreateApiRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\RegistryCreateApiResponse
     */
	public function registryCreateApi(
        \OpenAPI\OpenAPI\Models\Operations\RegistryCreateApiRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\RegistryCreateApiResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v1/projects/{project}/locations/{location}/apis', \OpenAPI\OpenAPI\Models\Operations\RegistryCreateApiRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "apiInput", "json");
        if ($body === null) {
            throw new \Exception('Request body is required');
        }
        $options = array_merge_recursive($options, $body);
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\RegistryCreateApiRequest::class, $request, null));
        
        $httpResponse = $this->_defaultClient->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\RegistryCreateApiResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->api = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\Api', 'json');
            }
        }
        else {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->status = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\Status', 'json');
            }
        }

        return $response;
    }
	
    /**
     * CreateApiDeployment creates a specified deployment.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\RegistryCreateApiDeploymentRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\RegistryCreateApiDeploymentResponse
     */
	public function registryCreateApiDeployment(
        \OpenAPI\OpenAPI\Models\Operations\RegistryCreateApiDeploymentRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\RegistryCreateApiDeploymentResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v1/projects/{project}/locations/{location}/apis/{api}/deployments', \OpenAPI\OpenAPI\Models\Operations\RegistryCreateApiDeploymentRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "apiDeploymentInput", "json");
        if ($body === null) {
            throw new \Exception('Request body is required');
        }
        $options = array_merge_recursive($options, $body);
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\RegistryCreateApiDeploymentRequest::class, $request, null));
        
        $httpResponse = $this->_defaultClient->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\RegistryCreateApiDeploymentResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->apiDeployment = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\ApiDeployment', 'json');
            }
        }
        else {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->status = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\Status', 'json');
            }
        }

        return $response;
    }
	
    /**
     * CreateApiSpec creates a specified spec.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\RegistryCreateApiSpecRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\RegistryCreateApiSpecResponse
     */
	public function registryCreateApiSpec(
        \OpenAPI\OpenAPI\Models\Operations\RegistryCreateApiSpecRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\RegistryCreateApiSpecResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v1/projects/{project}/locations/{location}/apis/{api}/versions/{version}/specs', \OpenAPI\OpenAPI\Models\Operations\RegistryCreateApiSpecRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "apiSpecInput", "json");
        if ($body === null) {
            throw new \Exception('Request body is required');
        }
        $options = array_merge_recursive($options, $body);
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\RegistryCreateApiSpecRequest::class, $request, null));
        
        $httpResponse = $this->_defaultClient->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\RegistryCreateApiSpecResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->apiSpec = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\ApiSpecOutput', 'json');
            }
        }
        else {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->status = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\Status', 'json');
            }
        }

        return $response;
    }
	
    /**
     * CreateApiVersion creates a specified version.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\RegistryCreateApiVersionRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\RegistryCreateApiVersionResponse
     */
	public function registryCreateApiVersion(
        \OpenAPI\OpenAPI\Models\Operations\RegistryCreateApiVersionRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\RegistryCreateApiVersionResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v1/projects/{project}/locations/{location}/apis/{api}/versions', \OpenAPI\OpenAPI\Models\Operations\RegistryCreateApiVersionRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "apiVersionInput", "json");
        if ($body === null) {
            throw new \Exception('Request body is required');
        }
        $options = array_merge_recursive($options, $body);
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\RegistryCreateApiVersionRequest::class, $request, null));
        
        $httpResponse = $this->_defaultClient->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\RegistryCreateApiVersionResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->apiVersion = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\ApiVersion', 'json');
            }
        }
        else {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->status = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\Status', 'json');
            }
        }

        return $response;
    }
	
    /**
     * CreateArtifact creates a specified artifact.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\RegistryCreateArtifactRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\RegistryCreateArtifactResponse
     */
	public function registryCreateArtifact(
        \OpenAPI\OpenAPI\Models\Operations\RegistryCreateArtifactRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\RegistryCreateArtifactResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v1/projects/{project}/locations/{location}/artifacts', \OpenAPI\OpenAPI\Models\Operations\RegistryCreateArtifactRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "artifactInput", "json");
        if ($body === null) {
            throw new \Exception('Request body is required');
        }
        $options = array_merge_recursive($options, $body);
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\RegistryCreateArtifactRequest::class, $request, null));
        
        $httpResponse = $this->_defaultClient->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\RegistryCreateArtifactResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->artifact = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\ArtifactOutput', 'json');
            }
        }
        else {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->status = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\Status', 'json');
            }
        }

        return $response;
    }
	
    /**
     * DeleteApi removes a specified API and all of the resources that it
     *  owns.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\RegistryDeleteApiRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\RegistryDeleteApiResponse
     */
	public function registryDeleteApi(
        \OpenAPI\OpenAPI\Models\Operations\RegistryDeleteApiRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\RegistryDeleteApiResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v1/projects/{project}/locations/{location}/apis/{api}', \OpenAPI\OpenAPI\Models\Operations\RegistryDeleteApiRequest::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\RegistryDeleteApiRequest::class, $request, null));
        
        $httpResponse = $this->_defaultClient->request('DELETE', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\RegistryDeleteApiResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
        }
        else {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->status = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\Status', 'json');
            }
        }

        return $response;
    }
	
    /**
     * DeleteApiDeployment removes a specified deployment, all revisions, and all
     *  child resources (e.g. artifacts).
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\RegistryDeleteApiDeploymentRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\RegistryDeleteApiDeploymentResponse
     */
	public function registryDeleteApiDeployment(
        \OpenAPI\OpenAPI\Models\Operations\RegistryDeleteApiDeploymentRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\RegistryDeleteApiDeploymentResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v1/projects/{project}/locations/{location}/apis/{api}/deployments/{deployment}', \OpenAPI\OpenAPI\Models\Operations\RegistryDeleteApiDeploymentRequest::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\RegistryDeleteApiDeploymentRequest::class, $request, null));
        
        $httpResponse = $this->_defaultClient->request('DELETE', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\RegistryDeleteApiDeploymentResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
        }
        else {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->status = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\Status', 'json');
            }
        }

        return $response;
    }
	
    /**
     * DeleteApiDeploymentRevision deletes a revision of a deployment.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\RegistryDeleteApiDeploymentRevisionRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\RegistryDeleteApiDeploymentRevisionResponse
     */
	public function registryDeleteApiDeploymentRevision(
        \OpenAPI\OpenAPI\Models\Operations\RegistryDeleteApiDeploymentRevisionRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\RegistryDeleteApiDeploymentRevisionResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v1/projects/{project}/locations/{location}/apis/{api}/deployments/{deployment}:deleteRevision', \OpenAPI\OpenAPI\Models\Operations\RegistryDeleteApiDeploymentRevisionRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_defaultClient->request('DELETE', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\RegistryDeleteApiDeploymentRevisionResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->apiDeployment = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\ApiDeployment', 'json');
            }
        }
        else {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->status = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\Status', 'json');
            }
        }

        return $response;
    }
	
    /**
     * DeleteApiSpec removes a specified spec, all revisions, and all child
     *  resources (e.g. artifacts).
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\RegistryDeleteApiSpecRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\RegistryDeleteApiSpecResponse
     */
	public function registryDeleteApiSpec(
        \OpenAPI\OpenAPI\Models\Operations\RegistryDeleteApiSpecRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\RegistryDeleteApiSpecResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v1/projects/{project}/locations/{location}/apis/{api}/versions/{version}/specs/{spec}', \OpenAPI\OpenAPI\Models\Operations\RegistryDeleteApiSpecRequest::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\RegistryDeleteApiSpecRequest::class, $request, null));
        
        $httpResponse = $this->_defaultClient->request('DELETE', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\RegistryDeleteApiSpecResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
        }
        else {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->status = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\Status', 'json');
            }
        }

        return $response;
    }
	
    /**
     * DeleteApiSpecRevision deletes a revision of a spec.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\RegistryDeleteApiSpecRevisionRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\RegistryDeleteApiSpecRevisionResponse
     */
	public function registryDeleteApiSpecRevision(
        \OpenAPI\OpenAPI\Models\Operations\RegistryDeleteApiSpecRevisionRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\RegistryDeleteApiSpecRevisionResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v1/projects/{project}/locations/{location}/apis/{api}/versions/{version}/specs/{spec}:deleteRevision', \OpenAPI\OpenAPI\Models\Operations\RegistryDeleteApiSpecRevisionRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_defaultClient->request('DELETE', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\RegistryDeleteApiSpecRevisionResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->apiSpec = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\ApiSpecOutput', 'json');
            }
        }
        else {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->status = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\Status', 'json');
            }
        }

        return $response;
    }
	
    /**
     * DeleteApiVersion removes a specified version and all of the resources that
     *  it owns.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\RegistryDeleteApiVersionRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\RegistryDeleteApiVersionResponse
     */
	public function registryDeleteApiVersion(
        \OpenAPI\OpenAPI\Models\Operations\RegistryDeleteApiVersionRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\RegistryDeleteApiVersionResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v1/projects/{project}/locations/{location}/apis/{api}/versions/{version}', \OpenAPI\OpenAPI\Models\Operations\RegistryDeleteApiVersionRequest::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\RegistryDeleteApiVersionRequest::class, $request, null));
        
        $httpResponse = $this->_defaultClient->request('DELETE', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\RegistryDeleteApiVersionResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
        }
        else {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->status = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\Status', 'json');
            }
        }

        return $response;
    }
	
    /**
     * DeleteArtifact removes a specified artifact.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\RegistryDeleteArtifactRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\RegistryDeleteArtifactResponse
     */
	public function registryDeleteArtifact(
        \OpenAPI\OpenAPI\Models\Operations\RegistryDeleteArtifactRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\RegistryDeleteArtifactResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v1/projects/{project}/locations/{location}/artifacts/{artifact}', \OpenAPI\OpenAPI\Models\Operations\RegistryDeleteArtifactRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_defaultClient->request('DELETE', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\RegistryDeleteArtifactResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
        }
        else {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->status = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\Status', 'json');
            }
        }

        return $response;
    }
	
    /**
     * GetApi returns a specified API.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\RegistryGetApiRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\RegistryGetApiResponse
     */
	public function registryGetApi(
        \OpenAPI\OpenAPI\Models\Operations\RegistryGetApiRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\RegistryGetApiResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v1/projects/{project}/locations/{location}/apis/{api}', \OpenAPI\OpenAPI\Models\Operations\RegistryGetApiRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_defaultClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\RegistryGetApiResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->api = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\Api', 'json');
            }
        }
        else {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->status = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\Status', 'json');
            }
        }

        return $response;
    }
	
    /**
     * GetApiDeployment returns a specified deployment.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\RegistryGetApiDeploymentRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\RegistryGetApiDeploymentResponse
     */
	public function registryGetApiDeployment(
        \OpenAPI\OpenAPI\Models\Operations\RegistryGetApiDeploymentRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\RegistryGetApiDeploymentResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v1/projects/{project}/locations/{location}/apis/{api}/deployments/{deployment}', \OpenAPI\OpenAPI\Models\Operations\RegistryGetApiDeploymentRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_defaultClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\RegistryGetApiDeploymentResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->apiDeployment = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\ApiDeployment', 'json');
            }
        }
        else {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->status = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\Status', 'json');
            }
        }

        return $response;
    }
	
    /**
     * GetApiSpec returns a specified spec.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\RegistryGetApiSpecRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\RegistryGetApiSpecResponse
     */
	public function registryGetApiSpec(
        \OpenAPI\OpenAPI\Models\Operations\RegistryGetApiSpecRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\RegistryGetApiSpecResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v1/projects/{project}/locations/{location}/apis/{api}/versions/{version}/specs/{spec}', \OpenAPI\OpenAPI\Models\Operations\RegistryGetApiSpecRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_defaultClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\RegistryGetApiSpecResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->apiSpec = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\ApiSpecOutput', 'json');
            }
        }
        else {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->status = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\Status', 'json');
            }
        }

        return $response;
    }
	
    /**
     * GetApiSpecContents returns the contents of a specified spec.
     *  If specs are stored with GZip compression, the default behavior
     *  is to return the spec uncompressed (the mime_type response field
     *  indicates the exact format returned).
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\RegistryGetApiSpecContentsRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\RegistryGetApiSpecContentsResponse
     */
	public function registryGetApiSpecContents(
        \OpenAPI\OpenAPI\Models\Operations\RegistryGetApiSpecContentsRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\RegistryGetApiSpecContentsResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v1/projects/{project}/locations/{location}/apis/{api}/versions/{version}/specs/{spec}:getContents', \OpenAPI\OpenAPI\Models\Operations\RegistryGetApiSpecContentsRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_defaultClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\RegistryGetApiSpecContentsResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
        }
        else {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->status = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\Status', 'json');
            }
        }

        return $response;
    }
	
    /**
     * GetApiVersion returns a specified version.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\RegistryGetApiVersionRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\RegistryGetApiVersionResponse
     */
	public function registryGetApiVersion(
        \OpenAPI\OpenAPI\Models\Operations\RegistryGetApiVersionRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\RegistryGetApiVersionResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v1/projects/{project}/locations/{location}/apis/{api}/versions/{version}', \OpenAPI\OpenAPI\Models\Operations\RegistryGetApiVersionRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_defaultClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\RegistryGetApiVersionResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->apiVersion = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\ApiVersion', 'json');
            }
        }
        else {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->status = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\Status', 'json');
            }
        }

        return $response;
    }
	
    /**
     * GetArtifact returns a specified artifact.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\RegistryGetArtifactRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\RegistryGetArtifactResponse
     */
	public function registryGetArtifact(
        \OpenAPI\OpenAPI\Models\Operations\RegistryGetArtifactRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\RegistryGetArtifactResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v1/projects/{project}/locations/{location}/artifacts/{artifact}', \OpenAPI\OpenAPI\Models\Operations\RegistryGetArtifactRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_defaultClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\RegistryGetArtifactResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->artifact = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\ArtifactOutput', 'json');
            }
        }
        else {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->status = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\Status', 'json');
            }
        }

        return $response;
    }
	
    /**
     * GetArtifactContents returns the contents of a specified artifact.
     *  If artifacts are stored with GZip compression, the default behavior
     *  is to return the artifact uncompressed (the mime_type response field
     *  indicates the exact format returned).
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\RegistryGetArtifactContentsRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\RegistryGetArtifactContentsResponse
     */
	public function registryGetArtifactContents(
        \OpenAPI\OpenAPI\Models\Operations\RegistryGetArtifactContentsRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\RegistryGetArtifactContentsResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v1/projects/{project}/locations/{location}/artifacts/{artifact}:getContents', \OpenAPI\OpenAPI\Models\Operations\RegistryGetArtifactContentsRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_defaultClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\RegistryGetArtifactContentsResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
        }
        else {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->status = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\Status', 'json');
            }
        }

        return $response;
    }
	
    /**
     * ListApiDeploymentRevisions lists all revisions of a deployment.
     *  Revisions are returned in descending order of revision creation time.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\RegistryListApiDeploymentRevisionsRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\RegistryListApiDeploymentRevisionsResponse
     */
	public function registryListApiDeploymentRevisions(
        \OpenAPI\OpenAPI\Models\Operations\RegistryListApiDeploymentRevisionsRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\RegistryListApiDeploymentRevisionsResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v1/projects/{project}/locations/{location}/apis/{api}/deployments/{deployment}:listRevisions', \OpenAPI\OpenAPI\Models\Operations\RegistryListApiDeploymentRevisionsRequest::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\RegistryListApiDeploymentRevisionsRequest::class, $request, null));
        
        $httpResponse = $this->_defaultClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\RegistryListApiDeploymentRevisionsResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->listApiDeploymentRevisionsResponse = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\ListApiDeploymentRevisionsResponse', 'json');
            }
        }
        else {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->status = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\Status', 'json');
            }
        }

        return $response;
    }
	
    /**
     * ListApiDeployments returns matching deployments.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\RegistryListApiDeploymentsRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\RegistryListApiDeploymentsResponse
     */
	public function registryListApiDeployments(
        \OpenAPI\OpenAPI\Models\Operations\RegistryListApiDeploymentsRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\RegistryListApiDeploymentsResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v1/projects/{project}/locations/{location}/apis/{api}/deployments', \OpenAPI\OpenAPI\Models\Operations\RegistryListApiDeploymentsRequest::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\RegistryListApiDeploymentsRequest::class, $request, null));
        
        $httpResponse = $this->_defaultClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\RegistryListApiDeploymentsResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->listApiDeploymentsResponse = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\ListApiDeploymentsResponse', 'json');
            }
        }
        else {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->status = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\Status', 'json');
            }
        }

        return $response;
    }
	
    /**
     * ListApiSpecRevisions lists all revisions of a spec.
     *  Revisions are returned in descending order of revision creation time.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\RegistryListApiSpecRevisionsRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\RegistryListApiSpecRevisionsResponse
     */
	public function registryListApiSpecRevisions(
        \OpenAPI\OpenAPI\Models\Operations\RegistryListApiSpecRevisionsRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\RegistryListApiSpecRevisionsResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v1/projects/{project}/locations/{location}/apis/{api}/versions/{version}/specs/{spec}:listRevisions', \OpenAPI\OpenAPI\Models\Operations\RegistryListApiSpecRevisionsRequest::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\RegistryListApiSpecRevisionsRequest::class, $request, null));
        
        $httpResponse = $this->_defaultClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\RegistryListApiSpecRevisionsResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->listApiSpecRevisionsResponse = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\ListApiSpecRevisionsResponse', 'json');
            }
        }
        else {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->status = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\Status', 'json');
            }
        }

        return $response;
    }
	
    /**
     * ListApiSpecs returns matching specs.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\RegistryListApiSpecsRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\RegistryListApiSpecsResponse
     */
	public function registryListApiSpecs(
        \OpenAPI\OpenAPI\Models\Operations\RegistryListApiSpecsRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\RegistryListApiSpecsResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v1/projects/{project}/locations/{location}/apis/{api}/versions/{version}/specs', \OpenAPI\OpenAPI\Models\Operations\RegistryListApiSpecsRequest::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\RegistryListApiSpecsRequest::class, $request, null));
        
        $httpResponse = $this->_defaultClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\RegistryListApiSpecsResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->listApiSpecsResponse = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\ListApiSpecsResponse', 'json');
            }
        }
        else {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->status = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\Status', 'json');
            }
        }

        return $response;
    }
	
    /**
     * ListApiVersions returns matching versions.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\RegistryListApiVersionsRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\RegistryListApiVersionsResponse
     */
	public function registryListApiVersions(
        \OpenAPI\OpenAPI\Models\Operations\RegistryListApiVersionsRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\RegistryListApiVersionsResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v1/projects/{project}/locations/{location}/apis/{api}/versions', \OpenAPI\OpenAPI\Models\Operations\RegistryListApiVersionsRequest::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\RegistryListApiVersionsRequest::class, $request, null));
        
        $httpResponse = $this->_defaultClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\RegistryListApiVersionsResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->listApiVersionsResponse = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\ListApiVersionsResponse', 'json');
            }
        }
        else {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->status = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\Status', 'json');
            }
        }

        return $response;
    }
	
    /**
     * ListApis returns matching APIs.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\RegistryListApisRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\RegistryListApisResponse
     */
	public function registryListApis(
        \OpenAPI\OpenAPI\Models\Operations\RegistryListApisRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\RegistryListApisResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v1/projects/{project}/locations/{location}/apis', \OpenAPI\OpenAPI\Models\Operations\RegistryListApisRequest::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\RegistryListApisRequest::class, $request, null));
        
        $httpResponse = $this->_defaultClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\RegistryListApisResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->listApisResponse = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\ListApisResponse', 'json');
            }
        }
        else {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->status = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\Status', 'json');
            }
        }

        return $response;
    }
	
    /**
     * ListArtifacts returns matching artifacts.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\RegistryListArtifactsRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\RegistryListArtifactsResponse
     */
	public function registryListArtifacts(
        \OpenAPI\OpenAPI\Models\Operations\RegistryListArtifactsRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\RegistryListArtifactsResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v1/projects/{project}/locations/{location}/artifacts', \OpenAPI\OpenAPI\Models\Operations\RegistryListArtifactsRequest::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\RegistryListArtifactsRequest::class, $request, null));
        
        $httpResponse = $this->_defaultClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\RegistryListArtifactsResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->listArtifactsResponse = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\ListArtifactsResponse', 'json');
            }
        }
        else {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->status = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\Status', 'json');
            }
        }

        return $response;
    }
	
    /**
     * ReplaceArtifact can be used to replace a specified artifact.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\RegistryReplaceArtifactRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\RegistryReplaceArtifactResponse
     */
	public function registryReplaceArtifact(
        \OpenAPI\OpenAPI\Models\Operations\RegistryReplaceArtifactRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\RegistryReplaceArtifactResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v1/projects/{project}/locations/{location}/artifacts/{artifact}', \OpenAPI\OpenAPI\Models\Operations\RegistryReplaceArtifactRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "artifactInput", "json");
        if ($body === null) {
            throw new \Exception('Request body is required');
        }
        $options = array_merge_recursive($options, $body);
        
        $httpResponse = $this->_defaultClient->request('PUT', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\RegistryReplaceArtifactResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->artifact = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\ArtifactOutput', 'json');
            }
        }
        else {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->status = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\Status', 'json');
            }
        }

        return $response;
    }
	
    /**
     * RollbackApiDeployment sets the current revision to a specified prior
     *  revision. Note that this creates a new revision with a new revision ID.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\RegistryRollbackApiDeploymentRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\RegistryRollbackApiDeploymentResponse
     */
	public function registryRollbackApiDeployment(
        \OpenAPI\OpenAPI\Models\Operations\RegistryRollbackApiDeploymentRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\RegistryRollbackApiDeploymentResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v1/projects/{project}/locations/{location}/apis/{api}/deployments/{deployment}:rollback', \OpenAPI\OpenAPI\Models\Operations\RegistryRollbackApiDeploymentRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "rollbackApiDeploymentRequest", "json");
        if ($body === null) {
            throw new \Exception('Request body is required');
        }
        $options = array_merge_recursive($options, $body);
        
        $httpResponse = $this->_defaultClient->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\RegistryRollbackApiDeploymentResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->apiDeployment = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\ApiDeployment', 'json');
            }
        }
        else {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->status = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\Status', 'json');
            }
        }

        return $response;
    }
	
    /**
     * RollbackApiSpec sets the current revision to a specified prior revision.
     *  Note that this creates a new revision with a new revision ID.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\RegistryRollbackApiSpecRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\RegistryRollbackApiSpecResponse
     */
	public function registryRollbackApiSpec(
        \OpenAPI\OpenAPI\Models\Operations\RegistryRollbackApiSpecRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\RegistryRollbackApiSpecResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v1/projects/{project}/locations/{location}/apis/{api}/versions/{version}/specs/{spec}:rollback', \OpenAPI\OpenAPI\Models\Operations\RegistryRollbackApiSpecRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "rollbackApiSpecRequest", "json");
        if ($body === null) {
            throw new \Exception('Request body is required');
        }
        $options = array_merge_recursive($options, $body);
        
        $httpResponse = $this->_defaultClient->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\RegistryRollbackApiSpecResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->apiSpec = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\ApiSpecOutput', 'json');
            }
        }
        else {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->status = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\Status', 'json');
            }
        }

        return $response;
    }
	
    /**
     * TagApiDeploymentRevision adds a tag to a specified revision of a
     *  deployment.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\RegistryTagApiDeploymentRevisionRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\RegistryTagApiDeploymentRevisionResponse
     */
	public function registryTagApiDeploymentRevision(
        \OpenAPI\OpenAPI\Models\Operations\RegistryTagApiDeploymentRevisionRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\RegistryTagApiDeploymentRevisionResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v1/projects/{project}/locations/{location}/apis/{api}/deployments/{deployment}:tagRevision', \OpenAPI\OpenAPI\Models\Operations\RegistryTagApiDeploymentRevisionRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "tagApiDeploymentRevisionRequest", "json");
        if ($body === null) {
            throw new \Exception('Request body is required');
        }
        $options = array_merge_recursive($options, $body);
        
        $httpResponse = $this->_defaultClient->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\RegistryTagApiDeploymentRevisionResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->apiDeployment = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\ApiDeployment', 'json');
            }
        }
        else {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->status = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\Status', 'json');
            }
        }

        return $response;
    }
	
    /**
     * TagApiSpecRevision adds a tag to a specified revision of a spec.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\RegistryTagApiSpecRevisionRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\RegistryTagApiSpecRevisionResponse
     */
	public function registryTagApiSpecRevision(
        \OpenAPI\OpenAPI\Models\Operations\RegistryTagApiSpecRevisionRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\RegistryTagApiSpecRevisionResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v1/projects/{project}/locations/{location}/apis/{api}/versions/{version}/specs/{spec}:tagRevision', \OpenAPI\OpenAPI\Models\Operations\RegistryTagApiSpecRevisionRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "tagApiSpecRevisionRequest", "json");
        if ($body === null) {
            throw new \Exception('Request body is required');
        }
        $options = array_merge_recursive($options, $body);
        
        $httpResponse = $this->_defaultClient->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\RegistryTagApiSpecRevisionResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->apiSpec = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\ApiSpecOutput', 'json');
            }
        }
        else {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->status = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\Status', 'json');
            }
        }

        return $response;
    }
	
    /**
     * UpdateApi can be used to modify a specified API.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\RegistryUpdateApiRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\RegistryUpdateApiResponse
     */
	public function registryUpdateApi(
        \OpenAPI\OpenAPI\Models\Operations\RegistryUpdateApiRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\RegistryUpdateApiResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v1/projects/{project}/locations/{location}/apis/{api}', \OpenAPI\OpenAPI\Models\Operations\RegistryUpdateApiRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "apiInput", "json");
        if ($body === null) {
            throw new \Exception('Request body is required');
        }
        $options = array_merge_recursive($options, $body);
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\RegistryUpdateApiRequest::class, $request, null));
        
        $httpResponse = $this->_defaultClient->request('PATCH', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\RegistryUpdateApiResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->api = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\Api', 'json');
            }
        }
        else {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->status = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\Status', 'json');
            }
        }

        return $response;
    }
	
    /**
     * UpdateApiDeployment can be used to modify a specified deployment.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\RegistryUpdateApiDeploymentRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\RegistryUpdateApiDeploymentResponse
     */
	public function registryUpdateApiDeployment(
        \OpenAPI\OpenAPI\Models\Operations\RegistryUpdateApiDeploymentRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\RegistryUpdateApiDeploymentResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v1/projects/{project}/locations/{location}/apis/{api}/deployments/{deployment}', \OpenAPI\OpenAPI\Models\Operations\RegistryUpdateApiDeploymentRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "apiDeploymentInput", "json");
        if ($body === null) {
            throw new \Exception('Request body is required');
        }
        $options = array_merge_recursive($options, $body);
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\RegistryUpdateApiDeploymentRequest::class, $request, null));
        
        $httpResponse = $this->_defaultClient->request('PATCH', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\RegistryUpdateApiDeploymentResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->apiDeployment = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\ApiDeployment', 'json');
            }
        }
        else {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->status = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\Status', 'json');
            }
        }

        return $response;
    }
	
    /**
     * UpdateApiSpec can be used to modify a specified spec.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\RegistryUpdateApiSpecRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\RegistryUpdateApiSpecResponse
     */
	public function registryUpdateApiSpec(
        \OpenAPI\OpenAPI\Models\Operations\RegistryUpdateApiSpecRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\RegistryUpdateApiSpecResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v1/projects/{project}/locations/{location}/apis/{api}/versions/{version}/specs/{spec}', \OpenAPI\OpenAPI\Models\Operations\RegistryUpdateApiSpecRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "apiSpecInput", "json");
        if ($body === null) {
            throw new \Exception('Request body is required');
        }
        $options = array_merge_recursive($options, $body);
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\RegistryUpdateApiSpecRequest::class, $request, null));
        
        $httpResponse = $this->_defaultClient->request('PATCH', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\RegistryUpdateApiSpecResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->apiSpec = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\ApiSpecOutput', 'json');
            }
        }
        else {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->status = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\Status', 'json');
            }
        }

        return $response;
    }
	
    /**
     * UpdateApiVersion can be used to modify a specified version.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\RegistryUpdateApiVersionRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\RegistryUpdateApiVersionResponse
     */
	public function registryUpdateApiVersion(
        \OpenAPI\OpenAPI\Models\Operations\RegistryUpdateApiVersionRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\RegistryUpdateApiVersionResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v1/projects/{project}/locations/{location}/apis/{api}/versions/{version}', \OpenAPI\OpenAPI\Models\Operations\RegistryUpdateApiVersionRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "apiVersionInput", "json");
        if ($body === null) {
            throw new \Exception('Request body is required');
        }
        $options = array_merge_recursive($options, $body);
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\RegistryUpdateApiVersionRequest::class, $request, null));
        
        $httpResponse = $this->_defaultClient->request('PATCH', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\RegistryUpdateApiVersionResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->apiVersion = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\ApiVersion', 'json');
            }
        }
        else {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->status = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\Status', 'json');
            }
        }

        return $response;
    }
}