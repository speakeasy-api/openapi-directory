/* 
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

package org.openapis.openapi.models.shared;

import com.fasterxml.jackson.annotation.JsonInclude.Include;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;

/**
 * Routing - This contains all routing specific configurations.
 */
public class Routing {
    /**
     * It lets you specify whether the API should provide you with route geometries for vehicle routes or not. Thus, you do not need to do extra routing to get the polyline for each route.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("calc_points")
    public Boolean calcPoints;

    public Routing withCalcPoints(Boolean calcPoints) {
        this.calcPoints = calcPoints;
        return this;
    }
    
    /**
     * indicates whether historical traffic information should be considered
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("consider_traffic")
    public Boolean considerTraffic;

    public Routing withConsiderTraffic(Boolean considerTraffic) {
        this.considerTraffic = considerTraffic;
        return this;
    }
    
    /**
     * In some cases curbside constraints cannot be fulfilled. For example in one-way streets you cannot arrive at a building that is on the left side of the street such that the building is to the right of you (unless you drove the one-way street the wrong/illegal way). You can set the `curbside_strictness` to `soft` to ignore the curbside constraint in such cases or set it to `strict` to get an error response instead. You can also set it to `ignore` to ignore all curbside constraints (this is useful to compare the results with and without constraints without modifying every single address).
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("curbside_strictness")
    public RoutingCurbsideStrictnessEnum curbsideStrictness;

    public Routing withCurbsideStrictness(RoutingCurbsideStrictnessEnum curbsideStrictness) {
        this.curbsideStrictness = curbsideStrictness;
        return this;
    }
    
    /**
     * indicates whether matrix calculation should fail fast when points cannot be connected
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("fail_fast")
    public Boolean failFast;

    public Routing withFailFast(Boolean failFast) {
        this.failFast = failFast;
        return this;
    }
    
    /**
     * specifies the data provider, read more about it [here](#section/Map-Data-and-Routing-Profiles).
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("network_data_provider")
    public RoutingNetworkDataProviderEnum networkDataProvider;

    public Routing withNetworkDataProvider(RoutingNetworkDataProviderEnum networkDataProvider) {
        this.networkDataProvider = networkDataProvider;
        return this;
    }
    
    /**
     * Indicates whether a solution includes snapped waypoints. In contrary to the address coordinate a snapped waypoint is the access point to the (road) network.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("return_snapped_waypoints")
    public Boolean returnSnappedWaypoints;

    public Routing withReturnSnappedWaypoints(Boolean returnSnappedWaypoints) {
        this.returnSnappedWaypoints = returnSnappedWaypoints;
        return this;
    }
    
    /**
     * Prevents snapping locations to road links of specified road types, e.g. to motorway.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("snap_preventions")
    public RoutingSnapPreventionsEnum[] snapPreventions;

    public Routing withSnapPreventions(RoutingSnapPreventionsEnum[] snapPreventions) {
        this.snapPreventions = snapPreventions;
        return this;
    }
    
    public Routing(){}
}
