"""Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT."""

import requests as requests_http
from . import utils
from sdk.models import operations, shared
from typing import Optional

SERVERS = [
    "https://conversations.twilio.com",
]
"""Contains the list of servers available to the SDK"""

class SDK:
    r"""This is the public Twilio REST API."""

    _client: requests_http.Session
    _security_client: requests_http.Session
    _server_url: str = SERVERS[0]
    _language: str = "python"
    _sdk_version: str = "0.0.1"
    _gen_version: str = "internal"

    def __init__(self,
                 server_url: str = None,
                 url_params: dict[str, str] = None,
                 client: requests_http.Session = None
                 ) -> None:
        """Instantiates the SDK configuring it with the provided parameters.
        
        :param server_url: The server URL to use for all operations
        :type server_url: str
        :param url_params: Parameters to optionally template the server URL with
        :type url_params: dict[str, str]
        :param client: The requests.Session HTTP client to use for all operations
        :type client: requests_http.Session        
        """
        self._client = requests_http.Session()
        
        
        if server_url is not None:
            if url_params is not None:
                self._server_url = utils.template_url(server_url, url_params)
            else:
                self._server_url = server_url

        if client is not None:
            self._client = client
        
        self._security_client = self._client
        

        
    
    
    def create_configuration_address(self, request: operations.CreateConfigurationAddressCreateConfigurationAddressRequest, security: operations.CreateConfigurationAddressSecurity, server_url: Optional[str] = None) -> operations.CreateConfigurationAddressResponse:
        r"""Create a new address configuration"""
        base_url = operations.CREATE_CONFIGURATION_ADDRESS_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = base_url.removesuffix('/') + '/v1/Configuration/Addresses'
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request", 'form')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.CreateConfigurationAddressResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 201:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ConversationsV1ConfigurationAddress])
                res.conversations_v1_configuration_address = out

        return res

    def create_conversation(self, request: operations.CreateConversationRequest, security: operations.CreateConversationSecurity, server_url: Optional[str] = None) -> operations.CreateConversationResponse:
        r"""Create a new conversation in your account's default service"""
        base_url = operations.CREATE_CONVERSATION_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = base_url.removesuffix('/') + '/v1/Conversations'
        
        headers = utils.get_headers(request)
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'form')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.CreateConversationResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 201:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ConversationsV1Conversation])
                res.conversations_v1_conversation = out

        return res

    def create_conversation_message(self, request: operations.CreateConversationMessageRequest, security: operations.CreateConversationMessageSecurity, server_url: Optional[str] = None) -> operations.CreateConversationMessageResponse:
        r"""Add a new message to the conversation"""
        base_url = operations.CREATE_CONVERSATION_MESSAGE_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.CreateConversationMessageRequest, base_url, '/v1/Conversations/{ConversationSid}/Messages', request)
        
        headers = utils.get_headers(request)
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'form')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.CreateConversationMessageResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 201:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ConversationsV1ConversationConversationMessage])
                res.conversations_v1_conversation_conversation_message = out

        return res

    def create_conversation_participant(self, request: operations.CreateConversationParticipantRequest, security: operations.CreateConversationParticipantSecurity, server_url: Optional[str] = None) -> operations.CreateConversationParticipantResponse:
        r"""Add a new participant to the conversation"""
        base_url = operations.CREATE_CONVERSATION_PARTICIPANT_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.CreateConversationParticipantRequest, base_url, '/v1/Conversations/{ConversationSid}/Participants', request)
        
        headers = utils.get_headers(request)
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'form')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.CreateConversationParticipantResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 201:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ConversationsV1ConversationConversationParticipant])
                res.conversations_v1_conversation_conversation_participant = out

        return res

    def create_conversation_scoped_webhook(self, request: operations.CreateConversationScopedWebhookRequest, security: operations.CreateConversationScopedWebhookSecurity, server_url: Optional[str] = None) -> operations.CreateConversationScopedWebhookResponse:
        r"""Create a new webhook scoped to the conversation"""
        base_url = operations.CREATE_CONVERSATION_SCOPED_WEBHOOK_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.CreateConversationScopedWebhookRequest, base_url, '/v1/Conversations/{ConversationSid}/Webhooks', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'form')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.CreateConversationScopedWebhookResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 201:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ConversationsV1ConversationConversationScopedWebhook])
                res.conversations_v1_conversation_conversation_scoped_webhook = out

        return res

    def create_credential(self, request: operations.CreateCredentialCreateCredentialRequest, security: operations.CreateCredentialSecurity, server_url: Optional[str] = None) -> operations.CreateCredentialResponse:
        r"""Add a new push notification credential to your account"""
        base_url = operations.CREATE_CREDENTIAL_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = base_url.removesuffix('/') + '/v1/Credentials'
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request", 'form')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.CreateCredentialResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 201:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ConversationsV1Credential])
                res.conversations_v1_credential = out

        return res

    def create_role(self, request: operations.CreateRoleCreateRoleRequest, security: operations.CreateRoleSecurity, server_url: Optional[str] = None) -> operations.CreateRoleResponse:
        r"""Create a new user role in your account's default service"""
        base_url = operations.CREATE_ROLE_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = base_url.removesuffix('/') + '/v1/Roles'
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request", 'form')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.CreateRoleResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 201:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ConversationsV1Role])
                res.conversations_v1_role = out

        return res

    def create_service(self, request: operations.CreateServiceCreateServiceRequest, security: operations.CreateServiceSecurity, server_url: Optional[str] = None) -> operations.CreateServiceResponse:
        r"""Create a new conversation service on your account"""
        base_url = operations.CREATE_SERVICE_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = base_url.removesuffix('/') + '/v1/Services'
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request", 'form')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.CreateServiceResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 201:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ConversationsV1Service])
                res.conversations_v1_service = out

        return res

    def create_service_conversation(self, request: operations.CreateServiceConversationRequest, security: operations.CreateServiceConversationSecurity, server_url: Optional[str] = None) -> operations.CreateServiceConversationResponse:
        r"""Create a new conversation in your service"""
        base_url = operations.CREATE_SERVICE_CONVERSATION_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.CreateServiceConversationRequest, base_url, '/v1/Services/{ChatServiceSid}/Conversations', request)
        
        headers = utils.get_headers(request)
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'form')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.CreateServiceConversationResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 201:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ConversationsV1ServiceServiceConversation])
                res.conversations_v1_service_service_conversation = out

        return res

    def create_service_conversation_message(self, request: operations.CreateServiceConversationMessageRequest, security: operations.CreateServiceConversationMessageSecurity, server_url: Optional[str] = None) -> operations.CreateServiceConversationMessageResponse:
        r"""Add a new message to the conversation in a specific service"""
        base_url = operations.CREATE_SERVICE_CONVERSATION_MESSAGE_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.CreateServiceConversationMessageRequest, base_url, '/v1/Services/{ChatServiceSid}/Conversations/{ConversationSid}/Messages', request)
        
        headers = utils.get_headers(request)
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'form')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.CreateServiceConversationMessageResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 201:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ConversationsV1ServiceServiceConversationServiceConversationMessage])
                res.conversations_v1_service_service_conversation_service_conversation_message = out

        return res

    def create_service_conversation_participant(self, request: operations.CreateServiceConversationParticipantRequest, security: operations.CreateServiceConversationParticipantSecurity, server_url: Optional[str] = None) -> operations.CreateServiceConversationParticipantResponse:
        r"""Add a new participant to the conversation in a specific service"""
        base_url = operations.CREATE_SERVICE_CONVERSATION_PARTICIPANT_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.CreateServiceConversationParticipantRequest, base_url, '/v1/Services/{ChatServiceSid}/Conversations/{ConversationSid}/Participants', request)
        
        headers = utils.get_headers(request)
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'form')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.CreateServiceConversationParticipantResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 201:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ConversationsV1ServiceServiceConversationServiceConversationParticipant])
                res.conversations_v1_service_service_conversation_service_conversation_participant = out

        return res

    def create_service_conversation_scoped_webhook(self, request: operations.CreateServiceConversationScopedWebhookRequest, security: operations.CreateServiceConversationScopedWebhookSecurity, server_url: Optional[str] = None) -> operations.CreateServiceConversationScopedWebhookResponse:
        r"""Create a new webhook scoped to the conversation in a specific service"""
        base_url = operations.CREATE_SERVICE_CONVERSATION_SCOPED_WEBHOOK_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.CreateServiceConversationScopedWebhookRequest, base_url, '/v1/Services/{ChatServiceSid}/Conversations/{ConversationSid}/Webhooks', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'form')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.CreateServiceConversationScopedWebhookResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 201:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ConversationsV1ServiceServiceConversationServiceConversationScopedWebhook])
                res.conversations_v1_service_service_conversation_service_conversation_scoped_webhook = out

        return res

    def create_service_role(self, request: operations.CreateServiceRoleRequest, security: operations.CreateServiceRoleSecurity, server_url: Optional[str] = None) -> operations.CreateServiceRoleResponse:
        r"""Create a new user role in your service"""
        base_url = operations.CREATE_SERVICE_ROLE_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.CreateServiceRoleRequest, base_url, '/v1/Services/{ChatServiceSid}/Roles', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'form')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.CreateServiceRoleResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 201:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ConversationsV1ServiceServiceRole])
                res.conversations_v1_service_service_role = out

        return res

    def create_service_user(self, request: operations.CreateServiceUserRequest, security: operations.CreateServiceUserSecurity, server_url: Optional[str] = None) -> operations.CreateServiceUserResponse:
        r"""Add a new conversation user to your service"""
        base_url = operations.CREATE_SERVICE_USER_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.CreateServiceUserRequest, base_url, '/v1/Services/{ChatServiceSid}/Users', request)
        
        headers = utils.get_headers(request)
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'form')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.CreateServiceUserResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 201:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ConversationsV1ServiceServiceUser])
                res.conversations_v1_service_service_user = out

        return res

    def create_user(self, request: operations.CreateUserRequest, security: operations.CreateUserSecurity, server_url: Optional[str] = None) -> operations.CreateUserResponse:
        r"""Add a new conversation user to your account's default service"""
        base_url = operations.CREATE_USER_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = base_url.removesuffix('/') + '/v1/Users'
        
        headers = utils.get_headers(request)
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'form')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.CreateUserResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 201:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ConversationsV1User])
                res.conversations_v1_user = out

        return res

    def delete_configuration_address(self, request: operations.DeleteConfigurationAddressRequest, security: operations.DeleteConfigurationAddressSecurity, server_url: Optional[str] = None) -> operations.DeleteConfigurationAddressResponse:
        r"""Remove an existing address configuration"""
        base_url = operations.DELETE_CONFIGURATION_ADDRESS_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.DeleteConfigurationAddressRequest, base_url, '/v1/Configuration/Addresses/{Sid}', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('DELETE', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DeleteConfigurationAddressResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        

        return res

    def delete_conversation(self, request: operations.DeleteConversationRequest, security: operations.DeleteConversationSecurity, server_url: Optional[str] = None) -> operations.DeleteConversationResponse:
        r"""Remove a conversation from your account's default service"""
        base_url = operations.DELETE_CONVERSATION_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.DeleteConversationRequest, base_url, '/v1/Conversations/{Sid}', request)
        
        headers = utils.get_headers(request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('DELETE', url, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DeleteConversationResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        

        return res

    def delete_conversation_message(self, request: operations.DeleteConversationMessageRequest, security: operations.DeleteConversationMessageSecurity, server_url: Optional[str] = None) -> operations.DeleteConversationMessageResponse:
        r"""Remove a message from the conversation"""
        base_url = operations.DELETE_CONVERSATION_MESSAGE_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.DeleteConversationMessageRequest, base_url, '/v1/Conversations/{ConversationSid}/Messages/{Sid}', request)
        
        headers = utils.get_headers(request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('DELETE', url, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DeleteConversationMessageResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        

        return res

    def delete_conversation_participant(self, request: operations.DeleteConversationParticipantRequest, security: operations.DeleteConversationParticipantSecurity, server_url: Optional[str] = None) -> operations.DeleteConversationParticipantResponse:
        r"""Remove a participant from the conversation"""
        base_url = operations.DELETE_CONVERSATION_PARTICIPANT_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.DeleteConversationParticipantRequest, base_url, '/v1/Conversations/{ConversationSid}/Participants/{Sid}', request)
        
        headers = utils.get_headers(request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('DELETE', url, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DeleteConversationParticipantResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        

        return res

    def delete_conversation_scoped_webhook(self, request: operations.DeleteConversationScopedWebhookRequest, security: operations.DeleteConversationScopedWebhookSecurity, server_url: Optional[str] = None) -> operations.DeleteConversationScopedWebhookResponse:
        r"""Remove an existing webhook scoped to the conversation"""
        base_url = operations.DELETE_CONVERSATION_SCOPED_WEBHOOK_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.DeleteConversationScopedWebhookRequest, base_url, '/v1/Conversations/{ConversationSid}/Webhooks/{Sid}', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('DELETE', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DeleteConversationScopedWebhookResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        

        return res

    def delete_credential(self, request: operations.DeleteCredentialRequest, security: operations.DeleteCredentialSecurity, server_url: Optional[str] = None) -> operations.DeleteCredentialResponse:
        r"""Remove a push notification credential from your account"""
        base_url = operations.DELETE_CREDENTIAL_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.DeleteCredentialRequest, base_url, '/v1/Credentials/{Sid}', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('DELETE', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DeleteCredentialResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        

        return res

    def delete_role(self, request: operations.DeleteRoleRequest, security: operations.DeleteRoleSecurity, server_url: Optional[str] = None) -> operations.DeleteRoleResponse:
        r"""Remove a user role from your account's default service"""
        base_url = operations.DELETE_ROLE_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.DeleteRoleRequest, base_url, '/v1/Roles/{Sid}', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('DELETE', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DeleteRoleResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        

        return res

    def delete_service(self, request: operations.DeleteServiceRequest, security: operations.DeleteServiceSecurity, server_url: Optional[str] = None) -> operations.DeleteServiceResponse:
        r"""Remove a conversation service with all its nested resources from your account"""
        base_url = operations.DELETE_SERVICE_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.DeleteServiceRequest, base_url, '/v1/Services/{Sid}', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('DELETE', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DeleteServiceResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        

        return res

    def delete_service_binding(self, request: operations.DeleteServiceBindingRequest, security: operations.DeleteServiceBindingSecurity, server_url: Optional[str] = None) -> operations.DeleteServiceBindingResponse:
        r"""Remove a push notification binding from the conversation service"""
        base_url = operations.DELETE_SERVICE_BINDING_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.DeleteServiceBindingRequest, base_url, '/v1/Services/{ChatServiceSid}/Bindings/{Sid}', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('DELETE', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DeleteServiceBindingResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        

        return res

    def delete_service_conversation(self, request: operations.DeleteServiceConversationRequest, security: operations.DeleteServiceConversationSecurity, server_url: Optional[str] = None) -> operations.DeleteServiceConversationResponse:
        r"""Remove a conversation from your service"""
        base_url = operations.DELETE_SERVICE_CONVERSATION_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.DeleteServiceConversationRequest, base_url, '/v1/Services/{ChatServiceSid}/Conversations/{Sid}', request)
        
        headers = utils.get_headers(request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('DELETE', url, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DeleteServiceConversationResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        

        return res

    def delete_service_conversation_message(self, request: operations.DeleteServiceConversationMessageRequest, security: operations.DeleteServiceConversationMessageSecurity, server_url: Optional[str] = None) -> operations.DeleteServiceConversationMessageResponse:
        r"""Remove a message from the conversation"""
        base_url = operations.DELETE_SERVICE_CONVERSATION_MESSAGE_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.DeleteServiceConversationMessageRequest, base_url, '/v1/Services/{ChatServiceSid}/Conversations/{ConversationSid}/Messages/{Sid}', request)
        
        headers = utils.get_headers(request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('DELETE', url, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DeleteServiceConversationMessageResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        

        return res

    def delete_service_conversation_participant(self, request: operations.DeleteServiceConversationParticipantRequest, security: operations.DeleteServiceConversationParticipantSecurity, server_url: Optional[str] = None) -> operations.DeleteServiceConversationParticipantResponse:
        r"""Remove a participant from the conversation"""
        base_url = operations.DELETE_SERVICE_CONVERSATION_PARTICIPANT_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.DeleteServiceConversationParticipantRequest, base_url, '/v1/Services/{ChatServiceSid}/Conversations/{ConversationSid}/Participants/{Sid}', request)
        
        headers = utils.get_headers(request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('DELETE', url, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DeleteServiceConversationParticipantResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        

        return res

    def delete_service_conversation_scoped_webhook(self, request: operations.DeleteServiceConversationScopedWebhookRequest, security: operations.DeleteServiceConversationScopedWebhookSecurity, server_url: Optional[str] = None) -> operations.DeleteServiceConversationScopedWebhookResponse:
        r"""Remove an existing webhook scoped to the conversation"""
        base_url = operations.DELETE_SERVICE_CONVERSATION_SCOPED_WEBHOOK_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.DeleteServiceConversationScopedWebhookRequest, base_url, '/v1/Services/{ChatServiceSid}/Conversations/{ConversationSid}/Webhooks/{Sid}', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('DELETE', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DeleteServiceConversationScopedWebhookResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        

        return res

    def delete_service_role(self, request: operations.DeleteServiceRoleRequest, security: operations.DeleteServiceRoleSecurity, server_url: Optional[str] = None) -> operations.DeleteServiceRoleResponse:
        r"""Remove a user role from your service"""
        base_url = operations.DELETE_SERVICE_ROLE_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.DeleteServiceRoleRequest, base_url, '/v1/Services/{ChatServiceSid}/Roles/{Sid}', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('DELETE', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DeleteServiceRoleResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        

        return res

    def delete_service_user(self, request: operations.DeleteServiceUserRequest, security: operations.DeleteServiceUserSecurity, server_url: Optional[str] = None) -> operations.DeleteServiceUserResponse:
        r"""Remove a conversation user from your service"""
        base_url = operations.DELETE_SERVICE_USER_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.DeleteServiceUserRequest, base_url, '/v1/Services/{ChatServiceSid}/Users/{Sid}', request)
        
        headers = utils.get_headers(request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('DELETE', url, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DeleteServiceUserResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        

        return res

    def delete_service_user_conversation(self, request: operations.DeleteServiceUserConversationRequest, security: operations.DeleteServiceUserConversationSecurity, server_url: Optional[str] = None) -> operations.DeleteServiceUserConversationResponse:
        r"""Delete a specific User Conversation."""
        base_url = operations.DELETE_SERVICE_USER_CONVERSATION_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.DeleteServiceUserConversationRequest, base_url, '/v1/Services/{ChatServiceSid}/Users/{UserSid}/Conversations/{ConversationSid}', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('DELETE', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DeleteServiceUserConversationResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        

        return res

    def delete_user(self, request: operations.DeleteUserRequest, security: operations.DeleteUserSecurity, server_url: Optional[str] = None) -> operations.DeleteUserResponse:
        r"""Remove a conversation user from your account's default service"""
        base_url = operations.DELETE_USER_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.DeleteUserRequest, base_url, '/v1/Users/{Sid}', request)
        
        headers = utils.get_headers(request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('DELETE', url, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DeleteUserResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        

        return res

    def delete_user_conversation(self, request: operations.DeleteUserConversationRequest, security: operations.DeleteUserConversationSecurity, server_url: Optional[str] = None) -> operations.DeleteUserConversationResponse:
        r"""Delete a specific User Conversation."""
        base_url = operations.DELETE_USER_CONVERSATION_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.DeleteUserConversationRequest, base_url, '/v1/Users/{UserSid}/Conversations/{ConversationSid}', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('DELETE', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DeleteUserConversationResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        

        return res

    def fetch_configuration(self, server_url: Optional[str] = None) -> operations.FetchConfigurationResponse:
        r"""Fetch the global configuration of conversations on your account"""
        base_url = operations.FETCH_CONFIGURATION_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = base_url.removesuffix('/') + '/v1/Configuration'
        
        
        client = self._client
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.FetchConfigurationResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ConversationsV1Configuration])
                res.conversations_v1_configuration = out

        return res

    def fetch_configuration_address(self, request: operations.FetchConfigurationAddressRequest, security: operations.FetchConfigurationAddressSecurity, server_url: Optional[str] = None) -> operations.FetchConfigurationAddressResponse:
        r"""Fetch an address configuration"""
        base_url = operations.FETCH_CONFIGURATION_ADDRESS_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.FetchConfigurationAddressRequest, base_url, '/v1/Configuration/Addresses/{Sid}', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.FetchConfigurationAddressResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ConversationsV1ConfigurationAddress])
                res.conversations_v1_configuration_address = out

        return res

    def fetch_configuration_webhook(self, server_url: Optional[str] = None) -> operations.FetchConfigurationWebhookResponse:
        base_url = operations.FETCH_CONFIGURATION_WEBHOOK_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = base_url.removesuffix('/') + '/v1/Configuration/Webhooks'
        
        
        client = self._client
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.FetchConfigurationWebhookResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ConversationsV1ConfigurationConfigurationWebhook])
                res.conversations_v1_configuration_configuration_webhook = out

        return res

    def fetch_conversation(self, request: operations.FetchConversationRequest, security: operations.FetchConversationSecurity, server_url: Optional[str] = None) -> operations.FetchConversationResponse:
        r"""Fetch a conversation from your account's default service"""
        base_url = operations.FETCH_CONVERSATION_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.FetchConversationRequest, base_url, '/v1/Conversations/{Sid}', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.FetchConversationResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ConversationsV1Conversation])
                res.conversations_v1_conversation = out

        return res

    def fetch_conversation_message(self, request: operations.FetchConversationMessageRequest, security: operations.FetchConversationMessageSecurity, server_url: Optional[str] = None) -> operations.FetchConversationMessageResponse:
        r"""Fetch a message from the conversation"""
        base_url = operations.FETCH_CONVERSATION_MESSAGE_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.FetchConversationMessageRequest, base_url, '/v1/Conversations/{ConversationSid}/Messages/{Sid}', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.FetchConversationMessageResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ConversationsV1ConversationConversationMessage])
                res.conversations_v1_conversation_conversation_message = out

        return res

    def fetch_conversation_message_receipt(self, request: operations.FetchConversationMessageReceiptRequest, security: operations.FetchConversationMessageReceiptSecurity, server_url: Optional[str] = None) -> operations.FetchConversationMessageReceiptResponse:
        r"""Fetch the delivery and read receipts of the conversation message"""
        base_url = operations.FETCH_CONVERSATION_MESSAGE_RECEIPT_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.FetchConversationMessageReceiptRequest, base_url, '/v1/Conversations/{ConversationSid}/Messages/{MessageSid}/Receipts/{Sid}', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.FetchConversationMessageReceiptResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ConversationsV1ConversationConversationMessageConversationMessageReceipt])
                res.conversations_v1_conversation_conversation_message_conversation_message_receipt = out

        return res

    def fetch_conversation_participant(self, request: operations.FetchConversationParticipantRequest, security: operations.FetchConversationParticipantSecurity, server_url: Optional[str] = None) -> operations.FetchConversationParticipantResponse:
        r"""Fetch a participant of the conversation"""
        base_url = operations.FETCH_CONVERSATION_PARTICIPANT_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.FetchConversationParticipantRequest, base_url, '/v1/Conversations/{ConversationSid}/Participants/{Sid}', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.FetchConversationParticipantResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ConversationsV1ConversationConversationParticipant])
                res.conversations_v1_conversation_conversation_participant = out

        return res

    def fetch_conversation_scoped_webhook(self, request: operations.FetchConversationScopedWebhookRequest, security: operations.FetchConversationScopedWebhookSecurity, server_url: Optional[str] = None) -> operations.FetchConversationScopedWebhookResponse:
        r"""Fetch the configuration of a conversation-scoped webhook"""
        base_url = operations.FETCH_CONVERSATION_SCOPED_WEBHOOK_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.FetchConversationScopedWebhookRequest, base_url, '/v1/Conversations/{ConversationSid}/Webhooks/{Sid}', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.FetchConversationScopedWebhookResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ConversationsV1ConversationConversationScopedWebhook])
                res.conversations_v1_conversation_conversation_scoped_webhook = out

        return res

    def fetch_credential(self, request: operations.FetchCredentialRequest, security: operations.FetchCredentialSecurity, server_url: Optional[str] = None) -> operations.FetchCredentialResponse:
        r"""Fetch a push notification credential from your account"""
        base_url = operations.FETCH_CREDENTIAL_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.FetchCredentialRequest, base_url, '/v1/Credentials/{Sid}', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.FetchCredentialResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ConversationsV1Credential])
                res.conversations_v1_credential = out

        return res

    def fetch_role(self, request: operations.FetchRoleRequest, security: operations.FetchRoleSecurity, server_url: Optional[str] = None) -> operations.FetchRoleResponse:
        r"""Fetch a user role from your account's default service"""
        base_url = operations.FETCH_ROLE_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.FetchRoleRequest, base_url, '/v1/Roles/{Sid}', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.FetchRoleResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ConversationsV1Role])
                res.conversations_v1_role = out

        return res

    def fetch_service(self, request: operations.FetchServiceRequest, security: operations.FetchServiceSecurity, server_url: Optional[str] = None) -> operations.FetchServiceResponse:
        r"""Fetch a conversation service from your account"""
        base_url = operations.FETCH_SERVICE_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.FetchServiceRequest, base_url, '/v1/Services/{Sid}', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.FetchServiceResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ConversationsV1Service])
                res.conversations_v1_service = out

        return res

    def fetch_service_binding(self, request: operations.FetchServiceBindingRequest, security: operations.FetchServiceBindingSecurity, server_url: Optional[str] = None) -> operations.FetchServiceBindingResponse:
        r"""Fetch a push notification binding from the conversation service"""
        base_url = operations.FETCH_SERVICE_BINDING_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.FetchServiceBindingRequest, base_url, '/v1/Services/{ChatServiceSid}/Bindings/{Sid}', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.FetchServiceBindingResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ConversationsV1ServiceServiceBinding])
                res.conversations_v1_service_service_binding = out

        return res

    def fetch_service_configuration(self, request: operations.FetchServiceConfigurationRequest, security: operations.FetchServiceConfigurationSecurity, server_url: Optional[str] = None) -> operations.FetchServiceConfigurationResponse:
        r"""Fetch the configuration of a conversation service"""
        base_url = operations.FETCH_SERVICE_CONFIGURATION_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.FetchServiceConfigurationRequest, base_url, '/v1/Services/{ChatServiceSid}/Configuration', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.FetchServiceConfigurationResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ConversationsV1ServiceServiceConfiguration])
                res.conversations_v1_service_service_configuration = out

        return res

    def fetch_service_conversation(self, request: operations.FetchServiceConversationRequest, security: operations.FetchServiceConversationSecurity, server_url: Optional[str] = None) -> operations.FetchServiceConversationResponse:
        r"""Fetch a conversation from your service"""
        base_url = operations.FETCH_SERVICE_CONVERSATION_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.FetchServiceConversationRequest, base_url, '/v1/Services/{ChatServiceSid}/Conversations/{Sid}', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.FetchServiceConversationResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ConversationsV1ServiceServiceConversation])
                res.conversations_v1_service_service_conversation = out

        return res

    def fetch_service_conversation_message(self, request: operations.FetchServiceConversationMessageRequest, security: operations.FetchServiceConversationMessageSecurity, server_url: Optional[str] = None) -> operations.FetchServiceConversationMessageResponse:
        r"""Fetch a message from the conversation"""
        base_url = operations.FETCH_SERVICE_CONVERSATION_MESSAGE_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.FetchServiceConversationMessageRequest, base_url, '/v1/Services/{ChatServiceSid}/Conversations/{ConversationSid}/Messages/{Sid}', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.FetchServiceConversationMessageResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ConversationsV1ServiceServiceConversationServiceConversationMessage])
                res.conversations_v1_service_service_conversation_service_conversation_message = out

        return res

    def fetch_service_conversation_message_receipt(self, request: operations.FetchServiceConversationMessageReceiptRequest, security: operations.FetchServiceConversationMessageReceiptSecurity, server_url: Optional[str] = None) -> operations.FetchServiceConversationMessageReceiptResponse:
        r"""Fetch the delivery and read receipts of the conversation message"""
        base_url = operations.FETCH_SERVICE_CONVERSATION_MESSAGE_RECEIPT_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.FetchServiceConversationMessageReceiptRequest, base_url, '/v1/Services/{ChatServiceSid}/Conversations/{ConversationSid}/Messages/{MessageSid}/Receipts/{Sid}', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.FetchServiceConversationMessageReceiptResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ConversationsV1ServiceServiceConversationServiceConversationMessageServiceConversationMessageReceipt])
                res.conversations_v1_service_service_conversation_service_conversation_message_service_conversation_message_receipt = out

        return res

    def fetch_service_conversation_participant(self, request: operations.FetchServiceConversationParticipantRequest, security: operations.FetchServiceConversationParticipantSecurity, server_url: Optional[str] = None) -> operations.FetchServiceConversationParticipantResponse:
        r"""Fetch a participant of the conversation"""
        base_url = operations.FETCH_SERVICE_CONVERSATION_PARTICIPANT_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.FetchServiceConversationParticipantRequest, base_url, '/v1/Services/{ChatServiceSid}/Conversations/{ConversationSid}/Participants/{Sid}', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.FetchServiceConversationParticipantResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ConversationsV1ServiceServiceConversationServiceConversationParticipant])
                res.conversations_v1_service_service_conversation_service_conversation_participant = out

        return res

    def fetch_service_conversation_scoped_webhook(self, request: operations.FetchServiceConversationScopedWebhookRequest, security: operations.FetchServiceConversationScopedWebhookSecurity, server_url: Optional[str] = None) -> operations.FetchServiceConversationScopedWebhookResponse:
        r"""Fetch the configuration of a conversation-scoped webhook"""
        base_url = operations.FETCH_SERVICE_CONVERSATION_SCOPED_WEBHOOK_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.FetchServiceConversationScopedWebhookRequest, base_url, '/v1/Services/{ChatServiceSid}/Conversations/{ConversationSid}/Webhooks/{Sid}', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.FetchServiceConversationScopedWebhookResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ConversationsV1ServiceServiceConversationServiceConversationScopedWebhook])
                res.conversations_v1_service_service_conversation_service_conversation_scoped_webhook = out

        return res

    def fetch_service_notification(self, request: operations.FetchServiceNotificationRequest, security: operations.FetchServiceNotificationSecurity, server_url: Optional[str] = None) -> operations.FetchServiceNotificationResponse:
        r"""Fetch push notification service settings"""
        base_url = operations.FETCH_SERVICE_NOTIFICATION_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.FetchServiceNotificationRequest, base_url, '/v1/Services/{ChatServiceSid}/Configuration/Notifications', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.FetchServiceNotificationResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ConversationsV1ServiceServiceConfigurationServiceNotification])
                res.conversations_v1_service_service_configuration_service_notification = out

        return res

    def fetch_service_role(self, request: operations.FetchServiceRoleRequest, security: operations.FetchServiceRoleSecurity, server_url: Optional[str] = None) -> operations.FetchServiceRoleResponse:
        r"""Fetch a user role from your service"""
        base_url = operations.FETCH_SERVICE_ROLE_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.FetchServiceRoleRequest, base_url, '/v1/Services/{ChatServiceSid}/Roles/{Sid}', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.FetchServiceRoleResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ConversationsV1ServiceServiceRole])
                res.conversations_v1_service_service_role = out

        return res

    def fetch_service_user(self, request: operations.FetchServiceUserRequest, security: operations.FetchServiceUserSecurity, server_url: Optional[str] = None) -> operations.FetchServiceUserResponse:
        r"""Fetch a conversation user from your service"""
        base_url = operations.FETCH_SERVICE_USER_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.FetchServiceUserRequest, base_url, '/v1/Services/{ChatServiceSid}/Users/{Sid}', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.FetchServiceUserResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ConversationsV1ServiceServiceUser])
                res.conversations_v1_service_service_user = out

        return res

    def fetch_service_user_conversation(self, request: operations.FetchServiceUserConversationRequest, security: operations.FetchServiceUserConversationSecurity, server_url: Optional[str] = None) -> operations.FetchServiceUserConversationResponse:
        r"""Fetch a specific User Conversation."""
        base_url = operations.FETCH_SERVICE_USER_CONVERSATION_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.FetchServiceUserConversationRequest, base_url, '/v1/Services/{ChatServiceSid}/Users/{UserSid}/Conversations/{ConversationSid}', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.FetchServiceUserConversationResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ConversationsV1ServiceServiceUserServiceUserConversation])
                res.conversations_v1_service_service_user_service_user_conversation = out

        return res

    def fetch_service_webhook_configuration(self, request: operations.FetchServiceWebhookConfigurationRequest, security: operations.FetchServiceWebhookConfigurationSecurity, server_url: Optional[str] = None) -> operations.FetchServiceWebhookConfigurationResponse:
        r"""Fetch a specific service webhook configuration."""
        base_url = operations.FETCH_SERVICE_WEBHOOK_CONFIGURATION_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.FetchServiceWebhookConfigurationRequest, base_url, '/v1/Services/{ChatServiceSid}/Configuration/Webhooks', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.FetchServiceWebhookConfigurationResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ConversationsV1ServiceServiceConfigurationServiceWebhookConfiguration])
                res.conversations_v1_service_service_configuration_service_webhook_configuration = out

        return res

    def fetch_user(self, request: operations.FetchUserRequest, security: operations.FetchUserSecurity, server_url: Optional[str] = None) -> operations.FetchUserResponse:
        r"""Fetch a conversation user from your account's default service"""
        base_url = operations.FETCH_USER_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.FetchUserRequest, base_url, '/v1/Users/{Sid}', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.FetchUserResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ConversationsV1User])
                res.conversations_v1_user = out

        return res

    def fetch_user_conversation(self, request: operations.FetchUserConversationRequest, security: operations.FetchUserConversationSecurity, server_url: Optional[str] = None) -> operations.FetchUserConversationResponse:
        r"""Fetch a specific User Conversation."""
        base_url = operations.FETCH_USER_CONVERSATION_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.FetchUserConversationRequest, base_url, '/v1/Users/{UserSid}/Conversations/{ConversationSid}', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.FetchUserConversationResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ConversationsV1UserUserConversation])
                res.conversations_v1_user_user_conversation = out

        return res

    def list_configuration_address(self, request: operations.ListConfigurationAddressRequest, security: operations.ListConfigurationAddressSecurity, server_url: Optional[str] = None) -> operations.ListConfigurationAddressResponse:
        r"""Retrieve a list of address configurations for an account"""
        base_url = operations.LIST_CONFIGURATION_ADDRESS_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = base_url.removesuffix('/') + '/v1/Configuration/Addresses'
        
        query_params = utils.get_query_params(operations.ListConfigurationAddressRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ListConfigurationAddressResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.ListConfigurationAddressListConfigurationAddressResponse])
                res.list_configuration_address_response = out

        return res

    def list_conversation(self, request: operations.ListConversationRequest, security: operations.ListConversationSecurity, server_url: Optional[str] = None) -> operations.ListConversationResponse:
        r"""Retrieve a list of conversations in your account's default service"""
        base_url = operations.LIST_CONVERSATION_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = base_url.removesuffix('/') + '/v1/Conversations'
        
        query_params = utils.get_query_params(operations.ListConversationRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ListConversationResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.ListConversationListConversationResponse])
                res.list_conversation_response = out

        return res

    def list_conversation_message(self, request: operations.ListConversationMessageRequest, security: operations.ListConversationMessageSecurity, server_url: Optional[str] = None) -> operations.ListConversationMessageResponse:
        r"""Retrieve a list of all messages in the conversation"""
        base_url = operations.LIST_CONVERSATION_MESSAGE_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.ListConversationMessageRequest, base_url, '/v1/Conversations/{ConversationSid}/Messages', request)
        
        query_params = utils.get_query_params(operations.ListConversationMessageRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ListConversationMessageResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.ListConversationMessageListConversationMessageResponse])
                res.list_conversation_message_response = out

        return res

    def list_conversation_message_receipt(self, request: operations.ListConversationMessageReceiptRequest, security: operations.ListConversationMessageReceiptSecurity, server_url: Optional[str] = None) -> operations.ListConversationMessageReceiptResponse:
        r"""Retrieve a list of all delivery and read receipts of the conversation message"""
        base_url = operations.LIST_CONVERSATION_MESSAGE_RECEIPT_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.ListConversationMessageReceiptRequest, base_url, '/v1/Conversations/{ConversationSid}/Messages/{MessageSid}/Receipts', request)
        
        query_params = utils.get_query_params(operations.ListConversationMessageReceiptRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ListConversationMessageReceiptResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.ListConversationMessageReceiptListConversationMessageReceiptResponse])
                res.list_conversation_message_receipt_response = out

        return res

    def list_conversation_participant(self, request: operations.ListConversationParticipantRequest, security: operations.ListConversationParticipantSecurity, server_url: Optional[str] = None) -> operations.ListConversationParticipantResponse:
        r"""Retrieve a list of all participants of the conversation"""
        base_url = operations.LIST_CONVERSATION_PARTICIPANT_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.ListConversationParticipantRequest, base_url, '/v1/Conversations/{ConversationSid}/Participants', request)
        
        query_params = utils.get_query_params(operations.ListConversationParticipantRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ListConversationParticipantResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.ListConversationParticipantListConversationParticipantResponse])
                res.list_conversation_participant_response = out

        return res

    def list_conversation_scoped_webhook(self, request: operations.ListConversationScopedWebhookRequest, security: operations.ListConversationScopedWebhookSecurity, server_url: Optional[str] = None) -> operations.ListConversationScopedWebhookResponse:
        r"""Retrieve a list of all webhooks scoped to the conversation"""
        base_url = operations.LIST_CONVERSATION_SCOPED_WEBHOOK_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.ListConversationScopedWebhookRequest, base_url, '/v1/Conversations/{ConversationSid}/Webhooks', request)
        
        query_params = utils.get_query_params(operations.ListConversationScopedWebhookRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ListConversationScopedWebhookResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.ListConversationScopedWebhookListConversationScopedWebhookResponse])
                res.list_conversation_scoped_webhook_response = out

        return res

    def list_credential(self, request: operations.ListCredentialRequest, security: operations.ListCredentialSecurity, server_url: Optional[str] = None) -> operations.ListCredentialResponse:
        r"""Retrieve a list of all push notification credentials on your account"""
        base_url = operations.LIST_CREDENTIAL_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = base_url.removesuffix('/') + '/v1/Credentials'
        
        query_params = utils.get_query_params(operations.ListCredentialRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ListCredentialResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.ListCredentialListCredentialResponse])
                res.list_credential_response = out

        return res

    def list_participant_conversation(self, request: operations.ListParticipantConversationRequest, security: operations.ListParticipantConversationSecurity, server_url: Optional[str] = None) -> operations.ListParticipantConversationResponse:
        r"""Retrieve a list of all Conversations that this Participant belongs to by identity or by address. Only one parameter should be specified."""
        base_url = operations.LIST_PARTICIPANT_CONVERSATION_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = base_url.removesuffix('/') + '/v1/ParticipantConversations'
        
        query_params = utils.get_query_params(operations.ListParticipantConversationRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ListParticipantConversationResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.ListParticipantConversationListParticipantConversationResponse])
                res.list_participant_conversation_response = out

        return res

    def list_role(self, request: operations.ListRoleRequest, security: operations.ListRoleSecurity, server_url: Optional[str] = None) -> operations.ListRoleResponse:
        r"""Retrieve a list of all user roles in your account's default service"""
        base_url = operations.LIST_ROLE_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = base_url.removesuffix('/') + '/v1/Roles'
        
        query_params = utils.get_query_params(operations.ListRoleRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ListRoleResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.ListRoleListRoleResponse])
                res.list_role_response = out

        return res

    def list_service(self, request: operations.ListServiceRequest, security: operations.ListServiceSecurity, server_url: Optional[str] = None) -> operations.ListServiceResponse:
        r"""Retrieve a list of all conversation services on your account"""
        base_url = operations.LIST_SERVICE_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = base_url.removesuffix('/') + '/v1/Services'
        
        query_params = utils.get_query_params(operations.ListServiceRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ListServiceResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.ListServiceListServiceResponse])
                res.list_service_response = out

        return res

    def list_service_binding(self, request: operations.ListServiceBindingRequest, security: operations.ListServiceBindingSecurity, server_url: Optional[str] = None) -> operations.ListServiceBindingResponse:
        r"""Retrieve a list of all push notification bindings in the conversation service"""
        base_url = operations.LIST_SERVICE_BINDING_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.ListServiceBindingRequest, base_url, '/v1/Services/{ChatServiceSid}/Bindings', request)
        
        query_params = utils.get_query_params(operations.ListServiceBindingRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ListServiceBindingResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.ListServiceBindingListServiceBindingResponse])
                res.list_service_binding_response = out

        return res

    def list_service_conversation(self, request: operations.ListServiceConversationRequest, security: operations.ListServiceConversationSecurity, server_url: Optional[str] = None) -> operations.ListServiceConversationResponse:
        r"""Retrieve a list of conversations in your service"""
        base_url = operations.LIST_SERVICE_CONVERSATION_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.ListServiceConversationRequest, base_url, '/v1/Services/{ChatServiceSid}/Conversations', request)
        
        query_params = utils.get_query_params(operations.ListServiceConversationRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ListServiceConversationResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.ListServiceConversationListServiceConversationResponse])
                res.list_service_conversation_response = out

        return res

    def list_service_conversation_message(self, request: operations.ListServiceConversationMessageRequest, security: operations.ListServiceConversationMessageSecurity, server_url: Optional[str] = None) -> operations.ListServiceConversationMessageResponse:
        r"""Retrieve a list of all messages in the conversation"""
        base_url = operations.LIST_SERVICE_CONVERSATION_MESSAGE_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.ListServiceConversationMessageRequest, base_url, '/v1/Services/{ChatServiceSid}/Conversations/{ConversationSid}/Messages', request)
        
        query_params = utils.get_query_params(operations.ListServiceConversationMessageRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ListServiceConversationMessageResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.ListServiceConversationMessageListServiceConversationMessageResponse])
                res.list_service_conversation_message_response = out

        return res

    def list_service_conversation_message_receipt(self, request: operations.ListServiceConversationMessageReceiptRequest, security: operations.ListServiceConversationMessageReceiptSecurity, server_url: Optional[str] = None) -> operations.ListServiceConversationMessageReceiptResponse:
        r"""Retrieve a list of all delivery and read receipts of the conversation message"""
        base_url = operations.LIST_SERVICE_CONVERSATION_MESSAGE_RECEIPT_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.ListServiceConversationMessageReceiptRequest, base_url, '/v1/Services/{ChatServiceSid}/Conversations/{ConversationSid}/Messages/{MessageSid}/Receipts', request)
        
        query_params = utils.get_query_params(operations.ListServiceConversationMessageReceiptRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ListServiceConversationMessageReceiptResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.ListServiceConversationMessageReceiptListServiceConversationMessageReceiptResponse])
                res.list_service_conversation_message_receipt_response = out

        return res

    def list_service_conversation_participant(self, request: operations.ListServiceConversationParticipantRequest, security: operations.ListServiceConversationParticipantSecurity, server_url: Optional[str] = None) -> operations.ListServiceConversationParticipantResponse:
        r"""Retrieve a list of all participants of the conversation"""
        base_url = operations.LIST_SERVICE_CONVERSATION_PARTICIPANT_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.ListServiceConversationParticipantRequest, base_url, '/v1/Services/{ChatServiceSid}/Conversations/{ConversationSid}/Participants', request)
        
        query_params = utils.get_query_params(operations.ListServiceConversationParticipantRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ListServiceConversationParticipantResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.ListServiceConversationParticipantListServiceConversationParticipantResponse])
                res.list_service_conversation_participant_response = out

        return res

    def list_service_conversation_scoped_webhook(self, request: operations.ListServiceConversationScopedWebhookRequest, security: operations.ListServiceConversationScopedWebhookSecurity, server_url: Optional[str] = None) -> operations.ListServiceConversationScopedWebhookResponse:
        r"""Retrieve a list of all webhooks scoped to the conversation"""
        base_url = operations.LIST_SERVICE_CONVERSATION_SCOPED_WEBHOOK_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.ListServiceConversationScopedWebhookRequest, base_url, '/v1/Services/{ChatServiceSid}/Conversations/{ConversationSid}/Webhooks', request)
        
        query_params = utils.get_query_params(operations.ListServiceConversationScopedWebhookRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ListServiceConversationScopedWebhookResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.ListServiceConversationScopedWebhookListServiceConversationScopedWebhookResponse])
                res.list_service_conversation_scoped_webhook_response = out

        return res

    def list_service_participant_conversation(self, request: operations.ListServiceParticipantConversationRequest, security: operations.ListServiceParticipantConversationSecurity, server_url: Optional[str] = None) -> operations.ListServiceParticipantConversationResponse:
        r"""Retrieve a list of all Conversations that this Participant belongs to by identity or by address. Only one parameter should be specified."""
        base_url = operations.LIST_SERVICE_PARTICIPANT_CONVERSATION_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.ListServiceParticipantConversationRequest, base_url, '/v1/Services/{ChatServiceSid}/ParticipantConversations', request)
        
        query_params = utils.get_query_params(operations.ListServiceParticipantConversationRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ListServiceParticipantConversationResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.ListServiceParticipantConversationListServiceParticipantConversationResponse])
                res.list_service_participant_conversation_response = out

        return res

    def list_service_role(self, request: operations.ListServiceRoleRequest, security: operations.ListServiceRoleSecurity, server_url: Optional[str] = None) -> operations.ListServiceRoleResponse:
        r"""Retrieve a list of all user roles in your service"""
        base_url = operations.LIST_SERVICE_ROLE_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.ListServiceRoleRequest, base_url, '/v1/Services/{ChatServiceSid}/Roles', request)
        
        query_params = utils.get_query_params(operations.ListServiceRoleRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ListServiceRoleResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.ListServiceRoleListServiceRoleResponse])
                res.list_service_role_response = out

        return res

    def list_service_user(self, request: operations.ListServiceUserRequest, security: operations.ListServiceUserSecurity, server_url: Optional[str] = None) -> operations.ListServiceUserResponse:
        r"""Retrieve a list of all conversation users in your service"""
        base_url = operations.LIST_SERVICE_USER_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.ListServiceUserRequest, base_url, '/v1/Services/{ChatServiceSid}/Users', request)
        
        query_params = utils.get_query_params(operations.ListServiceUserRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ListServiceUserResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.ListServiceUserListServiceUserResponse])
                res.list_service_user_response = out

        return res

    def list_service_user_conversation(self, request: operations.ListServiceUserConversationRequest, security: operations.ListServiceUserConversationSecurity, server_url: Optional[str] = None) -> operations.ListServiceUserConversationResponse:
        r"""Retrieve a list of all User Conversations for the User."""
        base_url = operations.LIST_SERVICE_USER_CONVERSATION_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.ListServiceUserConversationRequest, base_url, '/v1/Services/{ChatServiceSid}/Users/{UserSid}/Conversations', request)
        
        query_params = utils.get_query_params(operations.ListServiceUserConversationRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ListServiceUserConversationResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.ListServiceUserConversationListServiceUserConversationResponse])
                res.list_service_user_conversation_response = out

        return res

    def list_user(self, request: operations.ListUserRequest, security: operations.ListUserSecurity, server_url: Optional[str] = None) -> operations.ListUserResponse:
        r"""Retrieve a list of all conversation users in your account's default service"""
        base_url = operations.LIST_USER_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = base_url.removesuffix('/') + '/v1/Users'
        
        query_params = utils.get_query_params(operations.ListUserRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ListUserResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.ListUserListUserResponse])
                res.list_user_response = out

        return res

    def list_user_conversation(self, request: operations.ListUserConversationRequest, security: operations.ListUserConversationSecurity, server_url: Optional[str] = None) -> operations.ListUserConversationResponse:
        r"""Retrieve a list of all User Conversations for the User."""
        base_url = operations.LIST_USER_CONVERSATION_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.ListUserConversationRequest, base_url, '/v1/Users/{UserSid}/Conversations', request)
        
        query_params = utils.get_query_params(operations.ListUserConversationRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ListUserConversationResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.ListUserConversationListUserConversationResponse])
                res.list_user_conversation_response = out

        return res

    def update_configuration(self, request: operations.UpdateConfigurationUpdateConfigurationRequest, security: operations.UpdateConfigurationSecurity, server_url: Optional[str] = None) -> operations.UpdateConfigurationResponse:
        r"""Update the global configuration of conversations on your account"""
        base_url = operations.UPDATE_CONFIGURATION_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = base_url.removesuffix('/') + '/v1/Configuration'
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request", 'form')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.UpdateConfigurationResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ConversationsV1Configuration])
                res.conversations_v1_configuration = out

        return res

    def update_configuration_address(self, request: operations.UpdateConfigurationAddressRequest, security: operations.UpdateConfigurationAddressSecurity, server_url: Optional[str] = None) -> operations.UpdateConfigurationAddressResponse:
        r"""Update an existing address configuration"""
        base_url = operations.UPDATE_CONFIGURATION_ADDRESS_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.UpdateConfigurationAddressRequest, base_url, '/v1/Configuration/Addresses/{Sid}', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'form')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.UpdateConfigurationAddressResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ConversationsV1ConfigurationAddress])
                res.conversations_v1_configuration_address = out

        return res

    def update_configuration_webhook(self, request: operations.UpdateConfigurationWebhookUpdateConfigurationWebhookRequest, security: operations.UpdateConfigurationWebhookSecurity, server_url: Optional[str] = None) -> operations.UpdateConfigurationWebhookResponse:
        base_url = operations.UPDATE_CONFIGURATION_WEBHOOK_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = base_url.removesuffix('/') + '/v1/Configuration/Webhooks'
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request", 'form')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.UpdateConfigurationWebhookResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ConversationsV1ConfigurationConfigurationWebhook])
                res.conversations_v1_configuration_configuration_webhook = out

        return res

    def update_conversation(self, request: operations.UpdateConversationRequest, security: operations.UpdateConversationSecurity, server_url: Optional[str] = None) -> operations.UpdateConversationResponse:
        r"""Update an existing conversation in your account's default service"""
        base_url = operations.UPDATE_CONVERSATION_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.UpdateConversationRequest, base_url, '/v1/Conversations/{Sid}', request)
        
        headers = utils.get_headers(request)
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'form')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.UpdateConversationResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ConversationsV1Conversation])
                res.conversations_v1_conversation = out

        return res

    def update_conversation_message(self, request: operations.UpdateConversationMessageRequest, security: operations.UpdateConversationMessageSecurity, server_url: Optional[str] = None) -> operations.UpdateConversationMessageResponse:
        r"""Update an existing message in the conversation"""
        base_url = operations.UPDATE_CONVERSATION_MESSAGE_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.UpdateConversationMessageRequest, base_url, '/v1/Conversations/{ConversationSid}/Messages/{Sid}', request)
        
        headers = utils.get_headers(request)
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'form')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.UpdateConversationMessageResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ConversationsV1ConversationConversationMessage])
                res.conversations_v1_conversation_conversation_message = out

        return res

    def update_conversation_participant(self, request: operations.UpdateConversationParticipantRequest, security: operations.UpdateConversationParticipantSecurity, server_url: Optional[str] = None) -> operations.UpdateConversationParticipantResponse:
        r"""Update an existing participant in the conversation"""
        base_url = operations.UPDATE_CONVERSATION_PARTICIPANT_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.UpdateConversationParticipantRequest, base_url, '/v1/Conversations/{ConversationSid}/Participants/{Sid}', request)
        
        headers = utils.get_headers(request)
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'form')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.UpdateConversationParticipantResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ConversationsV1ConversationConversationParticipant])
                res.conversations_v1_conversation_conversation_participant = out

        return res

    def update_conversation_scoped_webhook(self, request: operations.UpdateConversationScopedWebhookRequest, security: operations.UpdateConversationScopedWebhookSecurity, server_url: Optional[str] = None) -> operations.UpdateConversationScopedWebhookResponse:
        r"""Update an existing conversation-scoped webhook"""
        base_url = operations.UPDATE_CONVERSATION_SCOPED_WEBHOOK_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.UpdateConversationScopedWebhookRequest, base_url, '/v1/Conversations/{ConversationSid}/Webhooks/{Sid}', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'form')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.UpdateConversationScopedWebhookResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ConversationsV1ConversationConversationScopedWebhook])
                res.conversations_v1_conversation_conversation_scoped_webhook = out

        return res

    def update_credential(self, request: operations.UpdateCredentialRequest, security: operations.UpdateCredentialSecurity, server_url: Optional[str] = None) -> operations.UpdateCredentialResponse:
        r"""Update an existing push notification credential on your account"""
        base_url = operations.UPDATE_CREDENTIAL_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.UpdateCredentialRequest, base_url, '/v1/Credentials/{Sid}', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'form')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.UpdateCredentialResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ConversationsV1Credential])
                res.conversations_v1_credential = out

        return res

    def update_role(self, request: operations.UpdateRoleRequest, security: operations.UpdateRoleSecurity, server_url: Optional[str] = None) -> operations.UpdateRoleResponse:
        r"""Update an existing user role in your account's default service"""
        base_url = operations.UPDATE_ROLE_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.UpdateRoleRequest, base_url, '/v1/Roles/{Sid}', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'form')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.UpdateRoleResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ConversationsV1Role])
                res.conversations_v1_role = out

        return res

    def update_service_configuration(self, request: operations.UpdateServiceConfigurationRequest, security: operations.UpdateServiceConfigurationSecurity, server_url: Optional[str] = None) -> operations.UpdateServiceConfigurationResponse:
        r"""Update configuration settings of a conversation service"""
        base_url = operations.UPDATE_SERVICE_CONFIGURATION_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.UpdateServiceConfigurationRequest, base_url, '/v1/Services/{ChatServiceSid}/Configuration', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'form')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.UpdateServiceConfigurationResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ConversationsV1ServiceServiceConfiguration])
                res.conversations_v1_service_service_configuration = out

        return res

    def update_service_conversation(self, request: operations.UpdateServiceConversationRequest, security: operations.UpdateServiceConversationSecurity, server_url: Optional[str] = None) -> operations.UpdateServiceConversationResponse:
        r"""Update an existing conversation in your service"""
        base_url = operations.UPDATE_SERVICE_CONVERSATION_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.UpdateServiceConversationRequest, base_url, '/v1/Services/{ChatServiceSid}/Conversations/{Sid}', request)
        
        headers = utils.get_headers(request)
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'form')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.UpdateServiceConversationResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ConversationsV1ServiceServiceConversation])
                res.conversations_v1_service_service_conversation = out

        return res

    def update_service_conversation_message(self, request: operations.UpdateServiceConversationMessageRequest, security: operations.UpdateServiceConversationMessageSecurity, server_url: Optional[str] = None) -> operations.UpdateServiceConversationMessageResponse:
        r"""Update an existing message in the conversation"""
        base_url = operations.UPDATE_SERVICE_CONVERSATION_MESSAGE_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.UpdateServiceConversationMessageRequest, base_url, '/v1/Services/{ChatServiceSid}/Conversations/{ConversationSid}/Messages/{Sid}', request)
        
        headers = utils.get_headers(request)
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'form')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.UpdateServiceConversationMessageResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ConversationsV1ServiceServiceConversationServiceConversationMessage])
                res.conversations_v1_service_service_conversation_service_conversation_message = out

        return res

    def update_service_conversation_participant(self, request: operations.UpdateServiceConversationParticipantRequest, security: operations.UpdateServiceConversationParticipantSecurity, server_url: Optional[str] = None) -> operations.UpdateServiceConversationParticipantResponse:
        r"""Update an existing participant in the conversation"""
        base_url = operations.UPDATE_SERVICE_CONVERSATION_PARTICIPANT_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.UpdateServiceConversationParticipantRequest, base_url, '/v1/Services/{ChatServiceSid}/Conversations/{ConversationSid}/Participants/{Sid}', request)
        
        headers = utils.get_headers(request)
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'form')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.UpdateServiceConversationParticipantResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ConversationsV1ServiceServiceConversationServiceConversationParticipant])
                res.conversations_v1_service_service_conversation_service_conversation_participant = out

        return res

    def update_service_conversation_scoped_webhook(self, request: operations.UpdateServiceConversationScopedWebhookRequest, security: operations.UpdateServiceConversationScopedWebhookSecurity, server_url: Optional[str] = None) -> operations.UpdateServiceConversationScopedWebhookResponse:
        r"""Update an existing conversation-scoped webhook"""
        base_url = operations.UPDATE_SERVICE_CONVERSATION_SCOPED_WEBHOOK_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.UpdateServiceConversationScopedWebhookRequest, base_url, '/v1/Services/{ChatServiceSid}/Conversations/{ConversationSid}/Webhooks/{Sid}', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'form')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.UpdateServiceConversationScopedWebhookResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ConversationsV1ServiceServiceConversationServiceConversationScopedWebhook])
                res.conversations_v1_service_service_conversation_service_conversation_scoped_webhook = out

        return res

    def update_service_notification(self, request: operations.UpdateServiceNotificationRequest, security: operations.UpdateServiceNotificationSecurity, server_url: Optional[str] = None) -> operations.UpdateServiceNotificationResponse:
        r"""Update push notification service settings"""
        base_url = operations.UPDATE_SERVICE_NOTIFICATION_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.UpdateServiceNotificationRequest, base_url, '/v1/Services/{ChatServiceSid}/Configuration/Notifications', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'form')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.UpdateServiceNotificationResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ConversationsV1ServiceServiceConfigurationServiceNotification])
                res.conversations_v1_service_service_configuration_service_notification = out

        return res

    def update_service_role(self, request: operations.UpdateServiceRoleRequest, security: operations.UpdateServiceRoleSecurity, server_url: Optional[str] = None) -> operations.UpdateServiceRoleResponse:
        r"""Update an existing user role in your service"""
        base_url = operations.UPDATE_SERVICE_ROLE_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.UpdateServiceRoleRequest, base_url, '/v1/Services/{ChatServiceSid}/Roles/{Sid}', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'form')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.UpdateServiceRoleResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ConversationsV1ServiceServiceRole])
                res.conversations_v1_service_service_role = out

        return res

    def update_service_user(self, request: operations.UpdateServiceUserRequest, security: operations.UpdateServiceUserSecurity, server_url: Optional[str] = None) -> operations.UpdateServiceUserResponse:
        r"""Update an existing conversation user in your service"""
        base_url = operations.UPDATE_SERVICE_USER_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.UpdateServiceUserRequest, base_url, '/v1/Services/{ChatServiceSid}/Users/{Sid}', request)
        
        headers = utils.get_headers(request)
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'form')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.UpdateServiceUserResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ConversationsV1ServiceServiceUser])
                res.conversations_v1_service_service_user = out

        return res

    def update_service_user_conversation(self, request: operations.UpdateServiceUserConversationRequest, security: operations.UpdateServiceUserConversationSecurity, server_url: Optional[str] = None) -> operations.UpdateServiceUserConversationResponse:
        r"""Update a specific User Conversation."""
        base_url = operations.UPDATE_SERVICE_USER_CONVERSATION_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.UpdateServiceUserConversationRequest, base_url, '/v1/Services/{ChatServiceSid}/Users/{UserSid}/Conversations/{ConversationSid}', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'form')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.UpdateServiceUserConversationResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ConversationsV1ServiceServiceUserServiceUserConversation])
                res.conversations_v1_service_service_user_service_user_conversation = out

        return res

    def update_service_webhook_configuration(self, request: operations.UpdateServiceWebhookConfigurationRequest, security: operations.UpdateServiceWebhookConfigurationSecurity, server_url: Optional[str] = None) -> operations.UpdateServiceWebhookConfigurationResponse:
        r"""Update a specific Webhook."""
        base_url = operations.UPDATE_SERVICE_WEBHOOK_CONFIGURATION_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.UpdateServiceWebhookConfigurationRequest, base_url, '/v1/Services/{ChatServiceSid}/Configuration/Webhooks', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'form')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.UpdateServiceWebhookConfigurationResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ConversationsV1ServiceServiceConfigurationServiceWebhookConfiguration])
                res.conversations_v1_service_service_configuration_service_webhook_configuration = out

        return res

    def update_user(self, request: operations.UpdateUserRequest, security: operations.UpdateUserSecurity, server_url: Optional[str] = None) -> operations.UpdateUserResponse:
        r"""Update an existing conversation user in your account's default service"""
        base_url = operations.UPDATE_USER_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.UpdateUserRequest, base_url, '/v1/Users/{Sid}', request)
        
        headers = utils.get_headers(request)
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'form')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.UpdateUserResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ConversationsV1User])
                res.conversations_v1_user = out

        return res

    def update_user_conversation(self, request: operations.UpdateUserConversationRequest, security: operations.UpdateUserConversationSecurity, server_url: Optional[str] = None) -> operations.UpdateUserConversationResponse:
        r"""Update a specific User Conversation."""
        base_url = operations.UPDATE_USER_CONVERSATION_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.UpdateUserConversationRequest, base_url, '/v1/Users/{UserSid}/Conversations/{ConversationSid}', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'form')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.UpdateUserConversationResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ConversationsV1UserUserConversation])
                res.conversations_v1_user_user_conversation = out

        return res

    