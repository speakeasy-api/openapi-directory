/*
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

import * as utils from "../internal/utils";
import * as operations from "./models/operations";
import * as shared from "./models/shared";
import { AxiosInstance, AxiosRequestConfig, AxiosResponse } from "axios";

/**
 * To change the description use /examples/TagsDescriptions.json
 */
export class ProjectsClassic {
  _defaultClient: AxiosInstance;
  _securityClient: AxiosInstance;
  _serverURL: string;
  _language: string;
  _sdkVersion: string;
  _genVersion: string;

  constructor(
    defaultClient: AxiosInstance,
    securityClient: AxiosInstance,
    serverURL: string,
    language: string,
    sdkVersion: string,
    genVersion: string
  ) {
    this._defaultClient = defaultClient;
    this._securityClient = securityClient;
    this._serverURL = serverURL;
    this._language = language;
    this._sdkVersion = sdkVersion;
    this._genVersion = genVersion;
  }

  /**
   * Creates a new language combination for a given project without creating a task.
   *
   * @remarks
   * Creates a new language combination for a given project without creating a task.
   */
  createLanguageCombination(
    req: operations.CreateLanguageCombinationRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.CreateLanguageCombinationResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CreateLanguageCombinationRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/projects/{projectId}/languageCombinations",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "commonLanguageCombinationDTO",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CreateLanguageCombinationResponse =
        new operations.CreateLanguageCombinationResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        default:
          if (
            utils.matchContentType(
              contentType,
              `application/vnd.xtrf-v1+json;charset=UTF-8`
            )
          ) {
            res.commonLanguageCombinationDTO = utils.objectToClass(
              httpRes?.data,
              shared.CommonLanguageCombinationDTO
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Adds a payable to a project.
   *
   * @remarks
   * Adds a payable to a project.
   */
  createPayable(
    req: operations.CreatePayableRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.CreatePayableResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CreatePayableRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/projects/{projectId}/finance/payables",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "payableCreateDTO",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CreatePayableResponse =
        new operations.CreatePayableResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        default:
          if (
            utils.matchContentType(
              contentType,
              `application/json;charset=UTF-8`
            )
          ) {
            res.payableDTO = utils.objectToClass(
              httpRes?.data,
              shared.PayableDTO
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Adds a receivable to a project.
   *
   * @remarks
   * Adds a receivable to a project.
   */
  createReceivable(
    req: operations.CreateReceivableRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.CreateReceivableResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CreateReceivableRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/projects/{projectId}/finance/receivables",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "receivableCreateDTO",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CreateReceivableResponse =
        new operations.CreateReceivableResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        default:
          if (
            utils.matchContentType(
              contentType,
              `application/json;charset=UTF-8`
            )
          ) {
            res.receivableDTO = utils.objectToClass(
              httpRes?.data,
              shared.ReceivableDTO
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Creates a new task for a given project.
   *
   * @remarks
   * Creates a new task for a given project.<p>
   *   Required fields:
   *   <ul>
   *     <li>languageCombination</li>
   *     <li>specializationId</li>
   *     <li>workflowId</li>
   *   </ul>
   * </p>
   *
   */
  createTask(
    req: operations.CreateTaskRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.CreateTaskResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CreateTaskRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/projects/{projectId}/tasks",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "taskCreateDTO",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CreateTaskResponse =
        new operations.CreateTaskResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        default:
          if (
            utils.matchContentType(
              contentType,
              `application/vnd.xtrf-v1+json;charset=UTF-8`
            )
          ) {
            res.taskDTO = utils.objectToClass(httpRes?.data, shared.TaskDTO);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Creates a new Classic Project.
   *
   * @remarks
   * Creates a new Classic Project. If the specified service ID refers to Smart Project, 400 Bad Request is returned instead.
   */
  create5(
    req: shared.ClassicProjectCreateDTO,
    config?: AxiosRequestConfig
  ): Promise<operations.Create5Response> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new shared.ClassicProjectCreateDTO(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/projects";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "request",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.Create5Response = new operations.Create5Response({
        statusCode: httpRes.status,
        contentType: contentType,
        rawResponse: httpRes,
      });
      switch (true) {
        default:
          if (
            utils.matchContentType(
              contentType,
              `application/vnd.xtrf-v1+json;charset=UTF-8`
            )
          ) {
            res.projectDTOv1 = utils.objectToClass(
              httpRes?.data,
              shared.ProjectDTOv1
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Deletes a payable.
   *
   * @remarks
   * Deletes a payable.
   */
  deletePayable(
    req: operations.DeletePayableRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.DeletePayableResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DeletePayableRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/projects/{projectId}/finance/payables/{payableId}",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DeletePayableResponse =
        new operations.DeletePayableResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
      }

      return res;
    });
  }

  /**
   * Deletes a receivable.
   *
   * @remarks
   * Deletes a receivable.
   */
  deleteReceivable(
    req: operations.DeleteReceivableRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.DeleteReceivableResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DeleteReceivableRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/projects/{projectId}/finance/receivables/{receivableId}",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DeleteReceivableResponse =
        new operations.DeleteReceivableResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
      }

      return res;
    });
  }

  /**
   * Removes a project.
   *
   * @remarks
   * Removes a project.
   */
  delete12(
    req: operations.Delete12Request,
    config?: AxiosRequestConfig
  ): Promise<operations.Delete12Response> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.Delete12Request(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/projects/{projectId}",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.Delete12Response = new operations.Delete12Response({
        statusCode: httpRes.status,
        contentType: contentType,
        rawResponse: httpRes,
      });
      switch (true) {
        case httpRes?.status == 204:
          break;
      }

      return res;
    });
  }

  /**
   * Returns projects' internal identifiers.
   *
   * @remarks
   * Returns projects' internal identifiers.
   */
  getAllIds6(
    req: operations.GetAllIds6Request,
    config?: AxiosRequestConfig
  ): Promise<operations.GetAllIds6Response> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetAllIds6Request(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/projects/ids";

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetAllIds6Response =
        new operations.GetAllIds6Response({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        default:
          if (
            utils.matchContentType(
              contentType,
              `application/vnd.xtrf-v1+json;charset=UTF-8`
            )
          ) {
            res.getAllIds6DefaultApplicationVndXtrfV1PlusJsonInt32Integers =
              utils.objectToClass(httpRes?.data);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Returns project details.
   *
   * @remarks
   * Returns project details. If the specified project ID refers to Smart Project, 400 Bad Request is returned instead.
   */
  getById7(
    req: operations.GetById7Request,
    config?: AxiosRequestConfig
  ): Promise<operations.GetById7Response> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetById7Request(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/projects/{projectId}",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetById7Response = new operations.GetById7Response({
        statusCode: httpRes.status,
        contentType: contentType,
        rawResponse: httpRes,
      });
      switch (true) {
        default:
          if (
            utils.matchContentType(
              contentType,
              `application/vnd.xtrf-v1+json;charset=UTF-8`
            )
          ) {
            res.projectDTOv1 = utils.objectToClass(
              httpRes?.data,
              shared.ProjectDTOv1
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Returns contacts of a given project.
   *
   * @remarks
   * Returns contacts of a given project.
   */
  getContacts(
    req: operations.GetContactsRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetContactsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetContactsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/projects/{projectId}/contacts",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetContactsResponse =
        new operations.GetContactsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        default:
          if (
            utils.matchContentType(
              contentType,
              `application/vnd.xtrf-v1+json;charset=UTF-8`
            )
          ) {
            res.contactsDTO = utils.objectToClass(
              httpRes?.data,
              shared.ContactsDTO
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Returns custom fields of a given project.
   *
   * @remarks
   * Returns custom fields of a given project.
   */
  getCustomFields5(
    req: operations.GetCustomFields5Request,
    config?: AxiosRequestConfig
  ): Promise<operations.GetCustomFields5Response> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetCustomFields5Request(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/projects/{projectId}/customFields",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetCustomFields5Response =
        new operations.GetCustomFields5Response({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        default:
          if (
            utils.matchContentType(
              contentType,
              `application/vnd.xtrf-v1+json;charset=UTF-8`
            )
          ) {
            res.customFieldsDTO = [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.customFieldsDTO = utils.objectToClass(
              httpRes?.data,
              shared.CustomFieldDTO,
              resFieldDepth
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Returns dates of a given project.
   *
   * @remarks
   * Returns dates of a given project.
   */
  getDates1(
    req: operations.GetDates1Request,
    config?: AxiosRequestConfig
  ): Promise<operations.GetDates1Response> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetDates1Request(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/projects/{projectId}/dates",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetDates1Response =
        new operations.GetDates1Response({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        default:
          if (
            utils.matchContentType(
              contentType,
              `application/vnd.xtrf-v1+json;charset=UTF-8`
            )
          ) {
            res.projectDatesDTO = utils.objectToClass(
              httpRes?.data,
              shared.ProjectDatesDTO
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Downloads a file.
   *
   * @remarks
   * Downloads a file.
   */
  getFileById(
    req: operations.GetFileByIdRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetFileByIdResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetFileByIdRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/projects/files/{fileId}/download",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetFileByIdResponse =
        new operations.GetFileByIdResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        default:
          break;
      }

      return res;
    });
  }

  /**
   * Returns finance of a given project.
   *
   * @remarks
   * Returns finance of a given project.
   */
  getFinance(
    req: operations.GetFinanceRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetFinanceResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetFinanceRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/projects/{projectId}/finance",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetFinanceResponse =
        new operations.GetFinanceResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        default:
          if (
            utils.matchContentType(
              contentType,
              `application/vnd.xtrf-v1+json;charset=UTF-8`
            )
          ) {
            res.financeDTO = utils.objectToClass(
              httpRes?.data,
              shared.FinanceDTO
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Returns instructions of a given project.
   *
   * @remarks
   * Returns instructions of a given project.
   */
  getInstructions(
    req: operations.GetInstructionsRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetInstructionsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetInstructionsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/projects/{projectId}/instructions",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetInstructionsResponse =
        new operations.GetInstructionsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        default:
          if (
            utils.matchContentType(
              contentType,
              `application/vnd.xtrf-v1+json;charset=UTF-8`
            )
          ) {
            res.instructionsDTO = utils.objectToClass(
              httpRes?.data,
              shared.InstructionsDTO
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Updates contacts of a given project.
   *
   * @remarks
   * Updates contacts of a given project.
   */
  updateContacts(
    req: operations.UpdateContactsRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.UpdateContactsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.UpdateContactsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/projects/{projectId}/contacts",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "contactsDTO",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "put",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UpdateContactsResponse =
        new operations.UpdateContactsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        default:
          if (
            utils.matchContentType(
              contentType,
              `application/vnd.xtrf-v1+json;charset=UTF-8`
            )
          ) {
            res.contactsDTO = utils.objectToClass(
              httpRes?.data,
              shared.ContactsDTO
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Updates custom fields of a given project.
   *
   * @remarks
   * Updates custom fields of a given project.
   */
  updateCustomFields3(
    req: operations.UpdateCustomFields3Request,
    config?: AxiosRequestConfig
  ): Promise<operations.UpdateCustomFields3Response> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.UpdateCustomFields3Request(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/projects/{projectId}/customFields",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "put",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UpdateCustomFields3Response =
        new operations.UpdateCustomFields3Response({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        default:
          if (
            utils.matchContentType(
              contentType,
              `application/vnd.xtrf-v1+json;charset=UTF-8`
            )
          ) {
            res.customFieldsDTO = [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.customFieldsDTO = utils.objectToClass(
              httpRes?.data,
              shared.CustomFieldDTO,
              resFieldDepth
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Updates dates of a given project.
   *
   * @remarks
   * Updates dates of a given project.
   */
  updateDates1(
    req: operations.UpdateDates1Request,
    config?: AxiosRequestConfig
  ): Promise<operations.UpdateDates1Response> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.UpdateDates1Request(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/projects/{projectId}/dates",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "projectDatesDTO",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "put",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UpdateDates1Response =
        new operations.UpdateDates1Response({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        default:
          if (
            utils.matchContentType(
              contentType,
              `application/vnd.xtrf-v1+json;charset=UTF-8`
            )
          ) {
            res.projectDatesDTO = utils.objectToClass(
              httpRes?.data,
              shared.ProjectDatesDTO
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Updates instructions of a given project.
   *
   * @remarks
   * Updates instructions of a given project.
   */
  updateInstructions1(
    req: operations.UpdateInstructions1Request,
    config?: AxiosRequestConfig
  ): Promise<operations.UpdateInstructions1Response> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.UpdateInstructions1Request(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/projects/{projectId}/instructions",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "instructionsDTO",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "put",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UpdateInstructions1Response =
        new operations.UpdateInstructions1Response({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        default:
          if (
            utils.matchContentType(
              contentType,
              `application/vnd.xtrf-v1+json;charset=UTF-8`
            )
          ) {
            res.instructionsDTO = utils.objectToClass(
              httpRes?.data,
              shared.InstructionsDTO
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Updates a payable.
   *
   * @remarks
   * Updates a payable.
   */
  updatePayable(
    req: operations.UpdatePayableRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.UpdatePayableResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.UpdatePayableRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/projects/{projectId}/finance/payables/{payableId}",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "payableDTO",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "put",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UpdatePayableResponse =
        new operations.UpdatePayableResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        default:
          if (
            utils.matchContentType(
              contentType,
              `application/json;charset=UTF-8`
            )
          ) {
            res.payableDTO = utils.objectToClass(
              httpRes?.data,
              shared.PayableDTO
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Updates a receivable.
   *
   * @remarks
   * Updates a receivable.
   */
  updateReceivable(
    req: operations.UpdateReceivableRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.UpdateReceivableResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.UpdateReceivableRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/projects/{projectId}/finance/receivables/{receivableId}",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "receivableDTO",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "put",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UpdateReceivableResponse =
        new operations.UpdateReceivableResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        default:
          if (
            utils.matchContentType(
              contentType,
              `application/json;charset=UTF-8`
            )
          ) {
            res.receivableDTO = utils.objectToClass(
              httpRes?.data,
              shared.ReceivableDTO
            );
          }
          break;
      }

      return res;
    });
  }
}
