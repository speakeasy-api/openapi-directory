<?php

/**
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

declare(strict_types=1);

namespace OpenAPI\OpenAPI;

class Projects 
{

	// SDK private variables namespaced with _ to avoid conflicts with API models
	private \GuzzleHttp\ClientInterface $_defaultClient;
	private \GuzzleHttp\ClientInterface $_securityClient;
	private string $_serverUrl;
	private string $_language;
	private string $_sdkVersion;
	private string $_genVersion;	

	/**
	 * @param \GuzzleHttp\ClientInterface $defaultClient
	 * @param \GuzzleHttp\ClientInterface $securityClient
	 * @param string $serverUrl
	 * @param string $language
	 * @param string $sdkVersion
	 * @param string $genVersion
	 */
	public function __construct(\GuzzleHttp\ClientInterface $defaultClient, \GuzzleHttp\ClientInterface $securityClient, string $serverUrl, string $language, string $sdkVersion, string $genVersion)
	{
		$this->_defaultClient = $defaultClient;
		$this->_securityClient = $securityClient;
		$this->_serverUrl = $serverUrl;
		$this->_language = $language;
		$this->_sdkVersion = $sdkVersion;
		$this->_genVersion = $genVersion;
	}
	
    /**
     * Constructs a new OAuth brand for the project if one does not exist. The created brand is "internal only", meaning that OAuth clients created under it only accept requests from users who belong to the same Google Workspace organization as the project. The brand is created in an un-reviewed status. NOTE: The "internal only" status can be manually changed in the Google Cloud Console. Requires that a brand does not already exist for the project, and that the specified support email is owned by the caller.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\IapProjectsBrandsCreateRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\IapProjectsBrandsCreateSecurity $security
     * @return \OpenAPI\OpenAPI\Models\Operations\IapProjectsBrandsCreateResponse
     */
	public function iapProjectsBrandsCreate(
        \OpenAPI\OpenAPI\Models\Operations\IapProjectsBrandsCreateRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\IapProjectsBrandsCreateSecurity $security,
    ): \OpenAPI\OpenAPI\Models\Operations\IapProjectsBrandsCreateResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v1/{parent}/brands', \OpenAPI\OpenAPI\Models\Operations\IapProjectsBrandsCreateRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "brandInput", "json");
        $options = array_merge_recursive($options, $body);
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\IapProjectsBrandsCreateRequest::class, $request, null));
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\IapProjectsBrandsCreateResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->brand = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\Brand', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Creates an Identity Aware Proxy (IAP) OAuth client. The client is owned by IAP. Requires that the brand for the project exists and that it is set for internal-only use.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\IapProjectsBrandsIdentityAwareProxyClientsCreateRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\IapProjectsBrandsIdentityAwareProxyClientsCreateSecurity $security
     * @return \OpenAPI\OpenAPI\Models\Operations\IapProjectsBrandsIdentityAwareProxyClientsCreateResponse
     */
	public function iapProjectsBrandsIdentityAwareProxyClientsCreate(
        \OpenAPI\OpenAPI\Models\Operations\IapProjectsBrandsIdentityAwareProxyClientsCreateRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\IapProjectsBrandsIdentityAwareProxyClientsCreateSecurity $security,
    ): \OpenAPI\OpenAPI\Models\Operations\IapProjectsBrandsIdentityAwareProxyClientsCreateResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v1/{parent}/identityAwareProxyClients', \OpenAPI\OpenAPI\Models\Operations\IapProjectsBrandsIdentityAwareProxyClientsCreateRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "identityAwareProxyClientInput", "json");
        $options = array_merge_recursive($options, $body);
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\IapProjectsBrandsIdentityAwareProxyClientsCreateRequest::class, $request, null));
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\IapProjectsBrandsIdentityAwareProxyClientsCreateResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->identityAwareProxyClient = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\IdentityAwareProxyClient', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Lists the existing clients for the brand.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\IapProjectsBrandsIdentityAwareProxyClientsListRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\IapProjectsBrandsIdentityAwareProxyClientsListSecurity $security
     * @return \OpenAPI\OpenAPI\Models\Operations\IapProjectsBrandsIdentityAwareProxyClientsListResponse
     */
	public function iapProjectsBrandsIdentityAwareProxyClientsList(
        \OpenAPI\OpenAPI\Models\Operations\IapProjectsBrandsIdentityAwareProxyClientsListRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\IapProjectsBrandsIdentityAwareProxyClientsListSecurity $security,
    ): \OpenAPI\OpenAPI\Models\Operations\IapProjectsBrandsIdentityAwareProxyClientsListResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v1/{parent}/identityAwareProxyClients', \OpenAPI\OpenAPI\Models\Operations\IapProjectsBrandsIdentityAwareProxyClientsListRequest::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\IapProjectsBrandsIdentityAwareProxyClientsListRequest::class, $request, null));
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\IapProjectsBrandsIdentityAwareProxyClientsListResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->listIdentityAwareProxyClientsResponse = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\ListIdentityAwareProxyClientsResponse', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Resets an Identity Aware Proxy (IAP) OAuth client secret. Useful if the secret was compromised. Requires that the client is owned by IAP.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\IapProjectsBrandsIdentityAwareProxyClientsResetSecretRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\IapProjectsBrandsIdentityAwareProxyClientsResetSecretSecurity $security
     * @return \OpenAPI\OpenAPI\Models\Operations\IapProjectsBrandsIdentityAwareProxyClientsResetSecretResponse
     */
	public function iapProjectsBrandsIdentityAwareProxyClientsResetSecret(
        \OpenAPI\OpenAPI\Models\Operations\IapProjectsBrandsIdentityAwareProxyClientsResetSecretRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\IapProjectsBrandsIdentityAwareProxyClientsResetSecretSecurity $security,
    ): \OpenAPI\OpenAPI\Models\Operations\IapProjectsBrandsIdentityAwareProxyClientsResetSecretResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v1/{name}:resetSecret', \OpenAPI\OpenAPI\Models\Operations\IapProjectsBrandsIdentityAwareProxyClientsResetSecretRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "requestBody", "json");
        $options = array_merge_recursive($options, $body);
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\IapProjectsBrandsIdentityAwareProxyClientsResetSecretRequest::class, $request, null));
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\IapProjectsBrandsIdentityAwareProxyClientsResetSecretResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->identityAwareProxyClient = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\IdentityAwareProxyClient', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Lists the existing brands for the project.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\IapProjectsBrandsListRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\IapProjectsBrandsListSecurity $security
     * @return \OpenAPI\OpenAPI\Models\Operations\IapProjectsBrandsListResponse
     */
	public function iapProjectsBrandsList(
        \OpenAPI\OpenAPI\Models\Operations\IapProjectsBrandsListRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\IapProjectsBrandsListSecurity $security,
    ): \OpenAPI\OpenAPI\Models\Operations\IapProjectsBrandsListResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v1/{parent}/brands', \OpenAPI\OpenAPI\Models\Operations\IapProjectsBrandsListRequest::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\IapProjectsBrandsListRequest::class, $request, null));
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\IapProjectsBrandsListResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->listBrandsResponse = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\ListBrandsResponse', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Creates a new TunnelDestGroup.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\IapProjectsIapTunnelLocationsDestGroupsCreateRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\IapProjectsIapTunnelLocationsDestGroupsCreateSecurity $security
     * @return \OpenAPI\OpenAPI\Models\Operations\IapProjectsIapTunnelLocationsDestGroupsCreateResponse
     */
	public function iapProjectsIapTunnelLocationsDestGroupsCreate(
        \OpenAPI\OpenAPI\Models\Operations\IapProjectsIapTunnelLocationsDestGroupsCreateRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\IapProjectsIapTunnelLocationsDestGroupsCreateSecurity $security,
    ): \OpenAPI\OpenAPI\Models\Operations\IapProjectsIapTunnelLocationsDestGroupsCreateResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v1/{parent}/destGroups', \OpenAPI\OpenAPI\Models\Operations\IapProjectsIapTunnelLocationsDestGroupsCreateRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "tunnelDestGroup", "json");
        $options = array_merge_recursive($options, $body);
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\IapProjectsIapTunnelLocationsDestGroupsCreateRequest::class, $request, null));
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\IapProjectsIapTunnelLocationsDestGroupsCreateResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->tunnelDestGroup = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\TunnelDestGroup', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Deletes a TunnelDestGroup.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\IapProjectsIapTunnelLocationsDestGroupsDeleteRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\IapProjectsIapTunnelLocationsDestGroupsDeleteSecurity $security
     * @return \OpenAPI\OpenAPI\Models\Operations\IapProjectsIapTunnelLocationsDestGroupsDeleteResponse
     */
	public function iapProjectsIapTunnelLocationsDestGroupsDelete(
        \OpenAPI\OpenAPI\Models\Operations\IapProjectsIapTunnelLocationsDestGroupsDeleteRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\IapProjectsIapTunnelLocationsDestGroupsDeleteSecurity $security,
    ): \OpenAPI\OpenAPI\Models\Operations\IapProjectsIapTunnelLocationsDestGroupsDeleteResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v1/{name}', \OpenAPI\OpenAPI\Models\Operations\IapProjectsIapTunnelLocationsDestGroupsDeleteRequest::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\IapProjectsIapTunnelLocationsDestGroupsDeleteRequest::class, $request, null));
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('DELETE', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\IapProjectsIapTunnelLocationsDestGroupsDeleteResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->empty = $serializer->deserialize((string)$httpResponse->getBody(), 'array<string, mixed>', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Retrieves an existing TunnelDestGroup.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\IapProjectsIapTunnelLocationsDestGroupsGetRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\IapProjectsIapTunnelLocationsDestGroupsGetSecurity $security
     * @return \OpenAPI\OpenAPI\Models\Operations\IapProjectsIapTunnelLocationsDestGroupsGetResponse
     */
	public function iapProjectsIapTunnelLocationsDestGroupsGet(
        \OpenAPI\OpenAPI\Models\Operations\IapProjectsIapTunnelLocationsDestGroupsGetRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\IapProjectsIapTunnelLocationsDestGroupsGetSecurity $security,
    ): \OpenAPI\OpenAPI\Models\Operations\IapProjectsIapTunnelLocationsDestGroupsGetResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v1/{name}', \OpenAPI\OpenAPI\Models\Operations\IapProjectsIapTunnelLocationsDestGroupsGetRequest::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\IapProjectsIapTunnelLocationsDestGroupsGetRequest::class, $request, null));
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\IapProjectsIapTunnelLocationsDestGroupsGetResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->tunnelDestGroup = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\TunnelDestGroup', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Lists the existing TunnelDestGroups. To group across all locations, use a `-` as the location ID. For example: `/v1/projects/123/iap_tunnel/locations/-/destGroups`
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\IapProjectsIapTunnelLocationsDestGroupsListRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\IapProjectsIapTunnelLocationsDestGroupsListSecurity $security
     * @return \OpenAPI\OpenAPI\Models\Operations\IapProjectsIapTunnelLocationsDestGroupsListResponse
     */
	public function iapProjectsIapTunnelLocationsDestGroupsList(
        \OpenAPI\OpenAPI\Models\Operations\IapProjectsIapTunnelLocationsDestGroupsListRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\IapProjectsIapTunnelLocationsDestGroupsListSecurity $security,
    ): \OpenAPI\OpenAPI\Models\Operations\IapProjectsIapTunnelLocationsDestGroupsListResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v1/{parent}/destGroups', \OpenAPI\OpenAPI\Models\Operations\IapProjectsIapTunnelLocationsDestGroupsListRequest::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\IapProjectsIapTunnelLocationsDestGroupsListRequest::class, $request, null));
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\IapProjectsIapTunnelLocationsDestGroupsListResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->listTunnelDestGroupsResponse = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\ListTunnelDestGroupsResponse', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Updates a TunnelDestGroup.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\IapProjectsIapTunnelLocationsDestGroupsPatchRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\IapProjectsIapTunnelLocationsDestGroupsPatchSecurity $security
     * @return \OpenAPI\OpenAPI\Models\Operations\IapProjectsIapTunnelLocationsDestGroupsPatchResponse
     */
	public function iapProjectsIapTunnelLocationsDestGroupsPatch(
        \OpenAPI\OpenAPI\Models\Operations\IapProjectsIapTunnelLocationsDestGroupsPatchRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\IapProjectsIapTunnelLocationsDestGroupsPatchSecurity $security,
    ): \OpenAPI\OpenAPI\Models\Operations\IapProjectsIapTunnelLocationsDestGroupsPatchResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v1/{name}', \OpenAPI\OpenAPI\Models\Operations\IapProjectsIapTunnelLocationsDestGroupsPatchRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "tunnelDestGroup", "json");
        $options = array_merge_recursive($options, $body);
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\IapProjectsIapTunnelLocationsDestGroupsPatchRequest::class, $request, null));
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('PATCH', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\IapProjectsIapTunnelLocationsDestGroupsPatchResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->tunnelDestGroup = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\TunnelDestGroup', 'json');
            }
        }

        return $response;
    }
}