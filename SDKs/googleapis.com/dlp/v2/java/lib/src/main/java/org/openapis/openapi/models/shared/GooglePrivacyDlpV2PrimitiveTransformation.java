/* 
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

package org.openapis.openapi.models.shared;

import com.fasterxml.jackson.annotation.JsonInclude.Include;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;

/**
 * GooglePrivacyDlpV2PrimitiveTransformation - A rule for transforming a value.
 */
public class GooglePrivacyDlpV2PrimitiveTransformation {
    /**
     * Generalization function that buckets values based on ranges. The ranges and replacement values are dynamically provided by the user for custom behavior, such as 1-30 -&gt; LOW 31-65 -&gt; MEDIUM 66-100 -&gt; HIGH This can be used on data of type: number, long, string, timestamp. If the bound `Value` type differs from the type of data being transformed, we will first attempt converting the type of the data to be transformed to match the type of the bound before comparing. See https://cloud.google.com/dlp/docs/concepts-bucketing to learn more.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("bucketingConfig")
    public GooglePrivacyDlpV2BucketingConfig bucketingConfig;

    public GooglePrivacyDlpV2PrimitiveTransformation withBucketingConfig(GooglePrivacyDlpV2BucketingConfig bucketingConfig) {
        this.bucketingConfig = bucketingConfig;
        return this;
    }
    
    /**
     * Partially mask a string by replacing a given number of characters with a fixed character. Masking can start from the beginning or end of the string. This can be used on data of any type (numbers, longs, and so on) and when de-identifying structured data we'll attempt to preserve the original data's type. (This allows you to take a long like 123 and modify it to a string like **3.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("characterMaskConfig")
    public GooglePrivacyDlpV2CharacterMaskConfig characterMaskConfig;

    public GooglePrivacyDlpV2PrimitiveTransformation withCharacterMaskConfig(GooglePrivacyDlpV2CharacterMaskConfig characterMaskConfig) {
        this.characterMaskConfig = characterMaskConfig;
        return this;
    }
    
    /**
     * Pseudonymization method that generates deterministic encryption for the given input. Outputs a base64 encoded representation of the encrypted output. Uses AES-SIV based on the RFC https://tools.ietf.org/html/rfc5297.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("cryptoDeterministicConfig")
    public GooglePrivacyDlpV2CryptoDeterministicConfig cryptoDeterministicConfig;

    public GooglePrivacyDlpV2PrimitiveTransformation withCryptoDeterministicConfig(GooglePrivacyDlpV2CryptoDeterministicConfig cryptoDeterministicConfig) {
        this.cryptoDeterministicConfig = cryptoDeterministicConfig;
        return this;
    }
    
    /**
     * Pseudonymization method that generates surrogates via cryptographic hashing. Uses SHA-256. The key size must be either 32 or 64 bytes. Outputs a base64 encoded representation of the hashed output (for example, L7k0BHmF1ha5U3NfGykjro4xWi1MPVQPjhMAZbSV9mM=). Currently, only string and integer values can be hashed. See https://cloud.google.com/dlp/docs/pseudonymization to learn more.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("cryptoHashConfig")
    public GooglePrivacyDlpV2CryptoHashConfig cryptoHashConfig;

    public GooglePrivacyDlpV2PrimitiveTransformation withCryptoHashConfig(GooglePrivacyDlpV2CryptoHashConfig cryptoHashConfig) {
        this.cryptoHashConfig = cryptoHashConfig;
        return this;
    }
    
    /**
     * Replaces an identifier with a surrogate using Format Preserving Encryption (FPE) with the FFX mode of operation; however when used in the `ReidentifyContent` API method, it serves the opposite function by reversing the surrogate back into the original identifier. The identifier must be encoded as ASCII. For a given crypto key and context, the same identifier will be replaced with the same surrogate. Identifiers must be at least two characters long. In the case that the identifier is the empty string, it will be skipped. See https://cloud.google.com/dlp/docs/pseudonymization to learn more. Note: We recommend using CryptoDeterministicConfig for all use cases which do not require preserving the input alphabet space and size, plus warrant referential integrity.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("cryptoReplaceFfxFpeConfig")
    public GooglePrivacyDlpV2CryptoReplaceFfxFpeConfig cryptoReplaceFfxFpeConfig;

    public GooglePrivacyDlpV2PrimitiveTransformation withCryptoReplaceFfxFpeConfig(GooglePrivacyDlpV2CryptoReplaceFfxFpeConfig cryptoReplaceFfxFpeConfig) {
        this.cryptoReplaceFfxFpeConfig = cryptoReplaceFfxFpeConfig;
        return this;
    }
    
    /**
     * Shifts dates by random number of days, with option to be consistent for the same context. See https://cloud.google.com/dlp/docs/concepts-date-shifting to learn more.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("dateShiftConfig")
    public GooglePrivacyDlpV2DateShiftConfig dateShiftConfig;

    public GooglePrivacyDlpV2PrimitiveTransformation withDateShiftConfig(GooglePrivacyDlpV2DateShiftConfig dateShiftConfig) {
        this.dateShiftConfig = dateShiftConfig;
        return this;
    }
    
    /**
     * Buckets values based on fixed size ranges. The Bucketing transformation can provide all of this functionality, but requires more configuration. This message is provided as a convenience to the user for simple bucketing strategies. The transformed value will be a hyphenated string of {lower_bound}-{upper_bound}. For example, if lower_bound = 10 and upper_bound = 20, all values that are within this bucket will be replaced with "10-20". This can be used on data of type: double, long. If the bound Value type differs from the type of data being transformed, we will first attempt converting the type of the data to be transformed to match the type of the bound before comparing. See https://cloud.google.com/dlp/docs/concepts-bucketing to learn more.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("fixedSizeBucketingConfig")
    public GooglePrivacyDlpV2FixedSizeBucketingConfig fixedSizeBucketingConfig;

    public GooglePrivacyDlpV2PrimitiveTransformation withFixedSizeBucketingConfig(GooglePrivacyDlpV2FixedSizeBucketingConfig fixedSizeBucketingConfig) {
        this.fixedSizeBucketingConfig = fixedSizeBucketingConfig;
        return this;
    }
    
    /**
     * Redact a given value. For example, if used with an `InfoTypeTransformation` transforming PHONE_NUMBER, and input 'My phone number is 206-555-0123', the output would be 'My phone number is '.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("redactConfig")
    public java.util.Map<String, Object> redactConfig;

    public GooglePrivacyDlpV2PrimitiveTransformation withRedactConfig(java.util.Map<String, Object> redactConfig) {
        this.redactConfig = redactConfig;
        return this;
    }
    
    /**
     * Replace each input value with a given `Value`.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("replaceConfig")
    public GooglePrivacyDlpV2ReplaceValueConfig replaceConfig;

    public GooglePrivacyDlpV2PrimitiveTransformation withReplaceConfig(GooglePrivacyDlpV2ReplaceValueConfig replaceConfig) {
        this.replaceConfig = replaceConfig;
        return this;
    }
    
    /**
     * Replace each input value with a value randomly selected from the dictionary.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("replaceDictionaryConfig")
    public GooglePrivacyDlpV2ReplaceDictionaryConfig replaceDictionaryConfig;

    public GooglePrivacyDlpV2PrimitiveTransformation withReplaceDictionaryConfig(GooglePrivacyDlpV2ReplaceDictionaryConfig replaceDictionaryConfig) {
        this.replaceDictionaryConfig = replaceDictionaryConfig;
        return this;
    }
    
    /**
     * Replace each matching finding with the name of the info_type.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("replaceWithInfoTypeConfig")
    public java.util.Map<String, Object> replaceWithInfoTypeConfig;

    public GooglePrivacyDlpV2PrimitiveTransformation withReplaceWithInfoTypeConfig(java.util.Map<String, Object> replaceWithInfoTypeConfig) {
        this.replaceWithInfoTypeConfig = replaceWithInfoTypeConfig;
        return this;
    }
    
    /**
     * For use with `Date`, `Timestamp`, and `TimeOfDay`, extract or preserve a portion of the value.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("timePartConfig")
    public GooglePrivacyDlpV2TimePartConfig timePartConfig;

    public GooglePrivacyDlpV2PrimitiveTransformation withTimePartConfig(GooglePrivacyDlpV2TimePartConfig timePartConfig) {
        this.timePartConfig = timePartConfig;
        return this;
    }
    
    public GooglePrivacyDlpV2PrimitiveTransformation(){}
}
