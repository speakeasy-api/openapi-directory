/*
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

import * as utils from "../internal/utils";
import * as operations from "./models/operations";
import * as shared from "./models/shared";
import { AxiosInstance, AxiosRequestConfig, AxiosResponse } from "axios";

export class Projects {
  _defaultClient: AxiosInstance;
  _securityClient: AxiosInstance;
  _serverURL: string;
  _language: string;
  _sdkVersion: string;
  _genVersion: string;

  constructor(
    defaultClient: AxiosInstance,
    securityClient: AxiosInstance,
    serverURL: string,
    language: string,
    sdkVersion: string,
    genVersion: string
  ) {
    this._defaultClient = defaultClient;
    this._securityClient = securityClient;
    this._serverURL = serverURL;
    this._language = language;
    this._sdkVersion = sdkVersion;
    this._genVersion = genVersion;
  }

  /**
   * Aggregates the requested fields based on provided function.
   */
  migrationcenterProjectsLocationsAssetsAggregateValues(
    req: operations.MigrationcenterProjectsLocationsAssetsAggregateValuesRequest,
    security: operations.MigrationcenterProjectsLocationsAssetsAggregateValuesSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.MigrationcenterProjectsLocationsAssetsAggregateValuesResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.MigrationcenterProjectsLocationsAssetsAggregateValuesRequest(
          req
        );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v1alpha1/{parent}/assets:aggregateValues",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "aggregateAssetsValuesRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.MigrationcenterProjectsLocationsAssetsAggregateValuesSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.MigrationcenterProjectsLocationsAssetsAggregateValuesResponse =
        new operations.MigrationcenterProjectsLocationsAssetsAggregateValuesResponse(
          {
            statusCode: httpRes.status,
            contentType: contentType,
            rawResponse: httpRes,
          }
        );
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.aggregateAssetsValuesResponse = utils.objectToClass(
              httpRes?.data,
              shared.AggregateAssetsValuesResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Deletes list of Assets.
   */
  migrationcenterProjectsLocationsAssetsBatchDelete(
    req: operations.MigrationcenterProjectsLocationsAssetsBatchDeleteRequest,
    security: operations.MigrationcenterProjectsLocationsAssetsBatchDeleteSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.MigrationcenterProjectsLocationsAssetsBatchDeleteResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.MigrationcenterProjectsLocationsAssetsBatchDeleteRequest(
          req
        );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v1alpha1/{parent}/assets:batchDelete",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "batchDeleteAssetsRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.MigrationcenterProjectsLocationsAssetsBatchDeleteSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.MigrationcenterProjectsLocationsAssetsBatchDeleteResponse =
        new operations.MigrationcenterProjectsLocationsAssetsBatchDeleteResponse(
          {
            statusCode: httpRes.status,
            contentType: contentType,
            rawResponse: httpRes,
          }
        );
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.empty = utils.objectToClass(httpRes?.data);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Updates the parameters of a list of assets.
   */
  migrationcenterProjectsLocationsAssetsBatchUpdate(
    req: operations.MigrationcenterProjectsLocationsAssetsBatchUpdateRequest,
    security: operations.MigrationcenterProjectsLocationsAssetsBatchUpdateSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.MigrationcenterProjectsLocationsAssetsBatchUpdateResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.MigrationcenterProjectsLocationsAssetsBatchUpdateRequest(
          req
        );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v1alpha1/{parent}/assets:batchUpdate",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "batchUpdateAssetsRequestInput",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.MigrationcenterProjectsLocationsAssetsBatchUpdateSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.MigrationcenterProjectsLocationsAssetsBatchUpdateResponse =
        new operations.MigrationcenterProjectsLocationsAssetsBatchUpdateResponse(
          {
            statusCode: httpRes.status,
            contentType: contentType,
            rawResponse: httpRes,
          }
        );
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.batchUpdateAssetsResponse = utils.objectToClass(
              httpRes?.data,
              shared.BatchUpdateAssetsResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Lists all the assets in a given project and location.
   */
  migrationcenterProjectsLocationsAssetsList(
    req: operations.MigrationcenterProjectsLocationsAssetsListRequest,
    security: operations.MigrationcenterProjectsLocationsAssetsListSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.MigrationcenterProjectsLocationsAssetsListResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.MigrationcenterProjectsLocationsAssetsListRequest(
        req
      );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v1alpha1/{parent}/assets",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.MigrationcenterProjectsLocationsAssetsListSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.MigrationcenterProjectsLocationsAssetsListResponse =
        new operations.MigrationcenterProjectsLocationsAssetsListResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listAssetsResponse = utils.objectToClass(
              httpRes?.data,
              shared.ListAssetsResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Reports a set of frames.
   */
  migrationcenterProjectsLocationsAssetsReportAssetFrames(
    req: operations.MigrationcenterProjectsLocationsAssetsReportAssetFramesRequest,
    security: operations.MigrationcenterProjectsLocationsAssetsReportAssetFramesSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.MigrationcenterProjectsLocationsAssetsReportAssetFramesResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.MigrationcenterProjectsLocationsAssetsReportAssetFramesRequest(
          req
        );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v1alpha1/{parent}/assets:reportAssetFrames",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "frames",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.MigrationcenterProjectsLocationsAssetsReportAssetFramesSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.MigrationcenterProjectsLocationsAssetsReportAssetFramesResponse =
        new operations.MigrationcenterProjectsLocationsAssetsReportAssetFramesResponse(
          {
            statusCode: httpRes.status,
            contentType: contentType,
            rawResponse: httpRes,
          }
        );
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.reportAssetFramesResponse = utils.objectToClass(httpRes?.data);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Adds assets to a group.
   */
  migrationcenterProjectsLocationsGroupsAddAssets(
    req: operations.MigrationcenterProjectsLocationsGroupsAddAssetsRequest,
    security: operations.MigrationcenterProjectsLocationsGroupsAddAssetsSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.MigrationcenterProjectsLocationsGroupsAddAssetsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.MigrationcenterProjectsLocationsGroupsAddAssetsRequest(
          req
        );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v1alpha1/{group}:addAssets",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "addAssetsToGroupRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.MigrationcenterProjectsLocationsGroupsAddAssetsSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.MigrationcenterProjectsLocationsGroupsAddAssetsResponse =
        new operations.MigrationcenterProjectsLocationsGroupsAddAssetsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.operation = utils.objectToClass(
              httpRes?.data,
              shared.Operation
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Creates a new group in a given project and location.
   */
  migrationcenterProjectsLocationsGroupsCreate(
    req: operations.MigrationcenterProjectsLocationsGroupsCreateRequest,
    security: operations.MigrationcenterProjectsLocationsGroupsCreateSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.MigrationcenterProjectsLocationsGroupsCreateResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.MigrationcenterProjectsLocationsGroupsCreateRequest(
        req
      );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v1alpha1/{parent}/groups",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "groupInput",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.MigrationcenterProjectsLocationsGroupsCreateSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.MigrationcenterProjectsLocationsGroupsCreateResponse =
        new operations.MigrationcenterProjectsLocationsGroupsCreateResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.operation = utils.objectToClass(
              httpRes?.data,
              shared.Operation
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Lists all groups in a given project and location.
   */
  migrationcenterProjectsLocationsGroupsList(
    req: operations.MigrationcenterProjectsLocationsGroupsListRequest,
    security: operations.MigrationcenterProjectsLocationsGroupsListSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.MigrationcenterProjectsLocationsGroupsListResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.MigrationcenterProjectsLocationsGroupsListRequest(
        req
      );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v1alpha1/{parent}/groups",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.MigrationcenterProjectsLocationsGroupsListSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.MigrationcenterProjectsLocationsGroupsListResponse =
        new operations.MigrationcenterProjectsLocationsGroupsListResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listGroupsResponse = utils.objectToClass(
              httpRes?.data,
              shared.ListGroupsResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Removes assets from a group.
   */
  migrationcenterProjectsLocationsGroupsRemoveAssets(
    req: operations.MigrationcenterProjectsLocationsGroupsRemoveAssetsRequest,
    security: operations.MigrationcenterProjectsLocationsGroupsRemoveAssetsSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.MigrationcenterProjectsLocationsGroupsRemoveAssetsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.MigrationcenterProjectsLocationsGroupsRemoveAssetsRequest(
          req
        );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v1alpha1/{group}:removeAssets",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "removeAssetsFromGroupRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.MigrationcenterProjectsLocationsGroupsRemoveAssetsSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.MigrationcenterProjectsLocationsGroupsRemoveAssetsResponse =
        new operations.MigrationcenterProjectsLocationsGroupsRemoveAssetsResponse(
          {
            statusCode: httpRes.status,
            contentType: contentType,
            rawResponse: httpRes,
          }
        );
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.operation = utils.objectToClass(
              httpRes?.data,
              shared.Operation
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Creates an import job.
   */
  migrationcenterProjectsLocationsImportJobsCreate(
    req: operations.MigrationcenterProjectsLocationsImportJobsCreateRequest,
    security: operations.MigrationcenterProjectsLocationsImportJobsCreateSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.MigrationcenterProjectsLocationsImportJobsCreateResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.MigrationcenterProjectsLocationsImportJobsCreateRequest(
          req
        );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v1alpha1/{parent}/importJobs",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "importJobInput",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.MigrationcenterProjectsLocationsImportJobsCreateSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.MigrationcenterProjectsLocationsImportJobsCreateResponse =
        new operations.MigrationcenterProjectsLocationsImportJobsCreateResponse(
          {
            statusCode: httpRes.status,
            contentType: contentType,
            rawResponse: httpRes,
          }
        );
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.operation = utils.objectToClass(
              httpRes?.data,
              shared.Operation
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Creates an import data file.
   */
  migrationcenterProjectsLocationsImportJobsImportDataFilesCreate(
    req: operations.MigrationcenterProjectsLocationsImportJobsImportDataFilesCreateRequest,
    security: operations.MigrationcenterProjectsLocationsImportJobsImportDataFilesCreateSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.MigrationcenterProjectsLocationsImportJobsImportDataFilesCreateResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.MigrationcenterProjectsLocationsImportJobsImportDataFilesCreateRequest(
          req
        );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v1alpha1/{parent}/importDataFiles",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "importDataFileInput",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.MigrationcenterProjectsLocationsImportJobsImportDataFilesCreateSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.MigrationcenterProjectsLocationsImportJobsImportDataFilesCreateResponse =
        new operations.MigrationcenterProjectsLocationsImportJobsImportDataFilesCreateResponse(
          {
            statusCode: httpRes.status,
            contentType: contentType,
            rawResponse: httpRes,
          }
        );
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.operation = utils.objectToClass(
              httpRes?.data,
              shared.Operation
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * List import data files.
   */
  migrationcenterProjectsLocationsImportJobsImportDataFilesList(
    req: operations.MigrationcenterProjectsLocationsImportJobsImportDataFilesListRequest,
    security: operations.MigrationcenterProjectsLocationsImportJobsImportDataFilesListSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.MigrationcenterProjectsLocationsImportJobsImportDataFilesListResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.MigrationcenterProjectsLocationsImportJobsImportDataFilesListRequest(
          req
        );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v1alpha1/{parent}/importDataFiles",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.MigrationcenterProjectsLocationsImportJobsImportDataFilesListSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.MigrationcenterProjectsLocationsImportJobsImportDataFilesListResponse =
        new operations.MigrationcenterProjectsLocationsImportJobsImportDataFilesListResponse(
          {
            statusCode: httpRes.status,
            contentType: contentType,
            rawResponse: httpRes,
          }
        );
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listImportDataFilesResponse = utils.objectToClass(
              httpRes?.data,
              shared.ListImportDataFilesResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Lists all import jobs.
   */
  migrationcenterProjectsLocationsImportJobsList(
    req: operations.MigrationcenterProjectsLocationsImportJobsListRequest,
    security: operations.MigrationcenterProjectsLocationsImportJobsListSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.MigrationcenterProjectsLocationsImportJobsListResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.MigrationcenterProjectsLocationsImportJobsListRequest(
          req
        );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v1alpha1/{parent}/importJobs",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.MigrationcenterProjectsLocationsImportJobsListSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.MigrationcenterProjectsLocationsImportJobsListResponse =
        new operations.MigrationcenterProjectsLocationsImportJobsListResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listImportJobsResponse = utils.objectToClass(
              httpRes?.data,
              shared.ListImportJobsResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Runs an import job.
   */
  migrationcenterProjectsLocationsImportJobsRun(
    req: operations.MigrationcenterProjectsLocationsImportJobsRunRequest,
    security: operations.MigrationcenterProjectsLocationsImportJobsRunSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.MigrationcenterProjectsLocationsImportJobsRunResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.MigrationcenterProjectsLocationsImportJobsRunRequest(
        req
      );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(baseURL, "/v1alpha1/{name}:run", req);

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "runImportJobRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.MigrationcenterProjectsLocationsImportJobsRunSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.MigrationcenterProjectsLocationsImportJobsRunResponse =
        new operations.MigrationcenterProjectsLocationsImportJobsRunResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.operation = utils.objectToClass(
              httpRes?.data,
              shared.Operation
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Validates an import job.
   */
  migrationcenterProjectsLocationsImportJobsValidate(
    req: operations.MigrationcenterProjectsLocationsImportJobsValidateRequest,
    security: operations.MigrationcenterProjectsLocationsImportJobsValidateSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.MigrationcenterProjectsLocationsImportJobsValidateResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.MigrationcenterProjectsLocationsImportJobsValidateRequest(
          req
        );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v1alpha1/{name}:validate",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "validateImportJobRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.MigrationcenterProjectsLocationsImportJobsValidateSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.MigrationcenterProjectsLocationsImportJobsValidateResponse =
        new operations.MigrationcenterProjectsLocationsImportJobsValidateResponse(
          {
            statusCode: httpRes.status,
            contentType: contentType,
            rawResponse: httpRes,
          }
        );
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.operation = utils.objectToClass(
              httpRes?.data,
              shared.Operation
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Lists information about the supported locations for this service.
   */
  migrationcenterProjectsLocationsList(
    req: operations.MigrationcenterProjectsLocationsListRequest,
    security: operations.MigrationcenterProjectsLocationsListSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.MigrationcenterProjectsLocationsListResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.MigrationcenterProjectsLocationsListRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v1alpha1/{name}/locations",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.MigrationcenterProjectsLocationsListSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.MigrationcenterProjectsLocationsListResponse =
        new operations.MigrationcenterProjectsLocationsListResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listLocationsResponse = utils.objectToClass(
              httpRes?.data,
              shared.ListLocationsResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Starts asynchronous cancellation on a long-running operation. The server makes a best effort to cancel the operation, but success is not guaranteed. If the server doesn't support this method, it returns `google.rpc.Code.UNIMPLEMENTED`. Clients can use Operations.GetOperation or other methods to check whether the cancellation succeeded or whether the operation completed despite cancellation. On successful cancellation, the operation is not deleted; instead, it becomes an operation with an Operation.error value with a google.rpc.Status.code of 1, corresponding to `Code.CANCELLED`.
   */
  migrationcenterProjectsLocationsOperationsCancel(
    req: operations.MigrationcenterProjectsLocationsOperationsCancelRequest,
    security: operations.MigrationcenterProjectsLocationsOperationsCancelSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.MigrationcenterProjectsLocationsOperationsCancelResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.MigrationcenterProjectsLocationsOperationsCancelRequest(
          req
        );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v1alpha1/{name}:cancel",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.MigrationcenterProjectsLocationsOperationsCancelSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.MigrationcenterProjectsLocationsOperationsCancelResponse =
        new operations.MigrationcenterProjectsLocationsOperationsCancelResponse(
          {
            statusCode: httpRes.status,
            contentType: contentType,
            rawResponse: httpRes,
          }
        );
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.empty = utils.objectToClass(httpRes?.data);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Lists operations that match the specified filter in the request. If the server doesn't support this method, it returns `UNIMPLEMENTED`.
   */
  migrationcenterProjectsLocationsOperationsList(
    req: operations.MigrationcenterProjectsLocationsOperationsListRequest,
    security: operations.MigrationcenterProjectsLocationsOperationsListSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.MigrationcenterProjectsLocationsOperationsListResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.MigrationcenterProjectsLocationsOperationsListRequest(
          req
        );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v1alpha1/{name}/operations",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.MigrationcenterProjectsLocationsOperationsListSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.MigrationcenterProjectsLocationsOperationsListResponse =
        new operations.MigrationcenterProjectsLocationsOperationsListResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listOperationsResponse = utils.objectToClass(
              httpRes?.data,
              shared.ListOperationsResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Creates a new preference set in a given project and location.
   */
  migrationcenterProjectsLocationsPreferenceSetsCreate(
    req: operations.MigrationcenterProjectsLocationsPreferenceSetsCreateRequest,
    security: operations.MigrationcenterProjectsLocationsPreferenceSetsCreateSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.MigrationcenterProjectsLocationsPreferenceSetsCreateResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.MigrationcenterProjectsLocationsPreferenceSetsCreateRequest(
          req
        );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v1alpha1/{parent}/preferenceSets",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "preferenceSetInput",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.MigrationcenterProjectsLocationsPreferenceSetsCreateSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.MigrationcenterProjectsLocationsPreferenceSetsCreateResponse =
        new operations.MigrationcenterProjectsLocationsPreferenceSetsCreateResponse(
          {
            statusCode: httpRes.status,
            contentType: contentType,
            rawResponse: httpRes,
          }
        );
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.operation = utils.objectToClass(
              httpRes?.data,
              shared.Operation
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Lists all the preference sets in a given project and location.
   */
  migrationcenterProjectsLocationsPreferenceSetsList(
    req: operations.MigrationcenterProjectsLocationsPreferenceSetsListRequest,
    security: operations.MigrationcenterProjectsLocationsPreferenceSetsListSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.MigrationcenterProjectsLocationsPreferenceSetsListResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.MigrationcenterProjectsLocationsPreferenceSetsListRequest(
          req
        );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v1alpha1/{parent}/preferenceSets",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.MigrationcenterProjectsLocationsPreferenceSetsListSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.MigrationcenterProjectsLocationsPreferenceSetsListResponse =
        new operations.MigrationcenterProjectsLocationsPreferenceSetsListResponse(
          {
            statusCode: httpRes.status,
            contentType: contentType,
            rawResponse: httpRes,
          }
        );
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listPreferenceSetsResponse = utils.objectToClass(
              httpRes?.data,
              shared.ListPreferenceSetsResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Creates a new source in a given project and location.
   */
  migrationcenterProjectsLocationsSourcesCreate(
    req: operations.MigrationcenterProjectsLocationsSourcesCreateRequest,
    security: operations.MigrationcenterProjectsLocationsSourcesCreateSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.MigrationcenterProjectsLocationsSourcesCreateResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.MigrationcenterProjectsLocationsSourcesCreateRequest(
        req
      );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v1alpha1/{parent}/sources",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "sourceInput",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.MigrationcenterProjectsLocationsSourcesCreateSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.MigrationcenterProjectsLocationsSourcesCreateResponse =
        new operations.MigrationcenterProjectsLocationsSourcesCreateResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.operation = utils.objectToClass(
              httpRes?.data,
              shared.Operation
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Deletes a source.
   */
  migrationcenterProjectsLocationsSourcesDelete(
    req: operations.MigrationcenterProjectsLocationsSourcesDeleteRequest,
    security: operations.MigrationcenterProjectsLocationsSourcesDeleteSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.MigrationcenterProjectsLocationsSourcesDeleteResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.MigrationcenterProjectsLocationsSourcesDeleteRequest(
        req
      );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(baseURL, "/v1alpha1/{name}", req);
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.MigrationcenterProjectsLocationsSourcesDeleteSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.MigrationcenterProjectsLocationsSourcesDeleteResponse =
        new operations.MigrationcenterProjectsLocationsSourcesDeleteResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.operation = utils.objectToClass(
              httpRes?.data,
              shared.Operation
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Gets the details of a source.
   */
  migrationcenterProjectsLocationsSourcesGet(
    req: operations.MigrationcenterProjectsLocationsSourcesGetRequest,
    security: operations.MigrationcenterProjectsLocationsSourcesGetSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.MigrationcenterProjectsLocationsSourcesGetResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.MigrationcenterProjectsLocationsSourcesGetRequest(
        req
      );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(baseURL, "/v1alpha1/{name}", req);
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.MigrationcenterProjectsLocationsSourcesGetSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.MigrationcenterProjectsLocationsSourcesGetResponse =
        new operations.MigrationcenterProjectsLocationsSourcesGetResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.source = utils.objectToClass(httpRes?.data, shared.Source);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Lists all the sources in a given project and location.
   */
  migrationcenterProjectsLocationsSourcesList(
    req: operations.MigrationcenterProjectsLocationsSourcesListRequest,
    security: operations.MigrationcenterProjectsLocationsSourcesListSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.MigrationcenterProjectsLocationsSourcesListResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.MigrationcenterProjectsLocationsSourcesListRequest(
        req
      );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v1alpha1/{parent}/sources",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.MigrationcenterProjectsLocationsSourcesListSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.MigrationcenterProjectsLocationsSourcesListResponse =
        new operations.MigrationcenterProjectsLocationsSourcesListResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listSourcesResponse = utils.objectToClass(
              httpRes?.data,
              shared.ListSourcesResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Updates the parameters of a source.
   */
  migrationcenterProjectsLocationsSourcesPatch(
    req: operations.MigrationcenterProjectsLocationsSourcesPatchRequest,
    security: operations.MigrationcenterProjectsLocationsSourcesPatchSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.MigrationcenterProjectsLocationsSourcesPatchResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.MigrationcenterProjectsLocationsSourcesPatchRequest(
        req
      );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(baseURL, "/v1alpha1/{name}", req);

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "sourceInput",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.MigrationcenterProjectsLocationsSourcesPatchSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "patch",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.MigrationcenterProjectsLocationsSourcesPatchResponse =
        new operations.MigrationcenterProjectsLocationsSourcesPatchResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.operation = utils.objectToClass(
              httpRes?.data,
              shared.Operation
            );
          }
          break;
      }

      return res;
    });
  }
}
