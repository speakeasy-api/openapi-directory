// Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.

package sdk

import (
	"context"
	"fmt"
	"net/http"
	"openapi/pkg/models/operations"
	"openapi/pkg/models/shared"
	"openapi/pkg/utils"
)

type customers struct {
	defaultClient  HTTPClient
	securityClient HTTPClient
	serverURL      string
	language       string
	sdkVersion     string
	genVersion     string
}

func newCustomers(defaultClient, securityClient HTTPClient, serverURL, language, sdkVersion, genVersion string) *customers {
	return &customers{
		defaultClient:  defaultClient,
		securityClient: securityClient,
		serverURL:      serverURL,
		language:       language,
		sdkVersion:     sdkVersion,
		genVersion:     genVersion,
	}
}

// ChromemanagementCustomersAppsCountChromeAppRequests - Generate summary of app installation requests.
func (s *customers) ChromemanagementCustomersAppsCountChromeAppRequests(ctx context.Context, request operations.ChromemanagementCustomersAppsCountChromeAppRequestsRequest, security operations.ChromemanagementCustomersAppsCountChromeAppRequestsSecurity) (*operations.ChromemanagementCustomersAppsCountChromeAppRequestsResponse, error) {
	baseURL := s.serverURL
	url := utils.GenerateURL(ctx, baseURL, "/v1/{customer}/apps:countChromeAppRequests", request, nil)

	req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	if err := utils.PopulateQueryParams(ctx, req, request, nil); err != nil {
		return nil, fmt.Errorf("error populating query params: %w", err)
	}

	client := utils.ConfigureSecurityClient(s.defaultClient, security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.ChromemanagementCustomersAppsCountChromeAppRequestsResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *shared.GoogleChromeManagementV1CountChromeAppRequestsResponse
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.GoogleChromeManagementV1CountChromeAppRequestsResponse = out
		}
	}

	return res, nil
}

// ChromemanagementCustomersReportsCountChromeBrowsersNeedingAttention - Count of Chrome Browsers that have been recently enrolled, have new policy to be synced, or have no recent activity.
func (s *customers) ChromemanagementCustomersReportsCountChromeBrowsersNeedingAttention(ctx context.Context, request operations.ChromemanagementCustomersReportsCountChromeBrowsersNeedingAttentionRequest, security operations.ChromemanagementCustomersReportsCountChromeBrowsersNeedingAttentionSecurity) (*operations.ChromemanagementCustomersReportsCountChromeBrowsersNeedingAttentionResponse, error) {
	baseURL := s.serverURL
	url := utils.GenerateURL(ctx, baseURL, "/v1/{customer}/reports:countChromeBrowsersNeedingAttention", request, nil)

	req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	if err := utils.PopulateQueryParams(ctx, req, request, nil); err != nil {
		return nil, fmt.Errorf("error populating query params: %w", err)
	}

	client := utils.ConfigureSecurityClient(s.defaultClient, security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.ChromemanagementCustomersReportsCountChromeBrowsersNeedingAttentionResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *shared.GoogleChromeManagementV1CountChromeBrowsersNeedingAttentionResponse
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.GoogleChromeManagementV1CountChromeBrowsersNeedingAttentionResponse = out
		}
	}

	return res, nil
}

// ChromemanagementCustomersReportsCountChromeDevicesReachingAutoExpirationDate - Generate report of the number of devices expiring in each month of the selected time frame. Devices are grouped by auto update expiration date and model. Further information can be found [here](https://support.google.com/chrome/a/answer/10564947).
func (s *customers) ChromemanagementCustomersReportsCountChromeDevicesReachingAutoExpirationDate(ctx context.Context, request operations.ChromemanagementCustomersReportsCountChromeDevicesReachingAutoExpirationDateRequest, security operations.ChromemanagementCustomersReportsCountChromeDevicesReachingAutoExpirationDateSecurity) (*operations.ChromemanagementCustomersReportsCountChromeDevicesReachingAutoExpirationDateResponse, error) {
	baseURL := s.serverURL
	url := utils.GenerateURL(ctx, baseURL, "/v1/{customer}/reports:countChromeDevicesReachingAutoExpirationDate", request, nil)

	req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	if err := utils.PopulateQueryParams(ctx, req, request, nil); err != nil {
		return nil, fmt.Errorf("error populating query params: %w", err)
	}

	client := utils.ConfigureSecurityClient(s.defaultClient, security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.ChromemanagementCustomersReportsCountChromeDevicesReachingAutoExpirationDateResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *shared.GoogleChromeManagementV1CountChromeDevicesReachingAutoExpirationDateResponse
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.GoogleChromeManagementV1CountChromeDevicesReachingAutoExpirationDateResponse = out
		}
	}

	return res, nil
}

// ChromemanagementCustomersReportsCountChromeDevicesThatNeedAttention - Counts of ChromeOS devices that have not synced policies or have lacked user activity in the past 28 days, are out of date, or are not complaint. Further information can be found here https://support.google.com/chrome/a/answer/10564947
func (s *customers) ChromemanagementCustomersReportsCountChromeDevicesThatNeedAttention(ctx context.Context, request operations.ChromemanagementCustomersReportsCountChromeDevicesThatNeedAttentionRequest, security operations.ChromemanagementCustomersReportsCountChromeDevicesThatNeedAttentionSecurity) (*operations.ChromemanagementCustomersReportsCountChromeDevicesThatNeedAttentionResponse, error) {
	baseURL := s.serverURL
	url := utils.GenerateURL(ctx, baseURL, "/v1/{customer}/reports:countChromeDevicesThatNeedAttention", request, nil)

	req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	if err := utils.PopulateQueryParams(ctx, req, request, nil); err != nil {
		return nil, fmt.Errorf("error populating query params: %w", err)
	}

	client := utils.ConfigureSecurityClient(s.defaultClient, security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.ChromemanagementCustomersReportsCountChromeDevicesThatNeedAttentionResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *shared.GoogleChromeManagementV1CountChromeDevicesThatNeedAttentionResponse
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.GoogleChromeManagementV1CountChromeDevicesThatNeedAttentionResponse = out
		}
	}

	return res, nil
}

// ChromemanagementCustomersReportsCountChromeHardwareFleetDevices - Counts of devices with a specific hardware specification from the requested hardware type (for example model name, processor type). Further information can be found here https://support.google.com/chrome/a/answer/10564947
func (s *customers) ChromemanagementCustomersReportsCountChromeHardwareFleetDevices(ctx context.Context, request operations.ChromemanagementCustomersReportsCountChromeHardwareFleetDevicesRequest, security operations.ChromemanagementCustomersReportsCountChromeHardwareFleetDevicesSecurity) (*operations.ChromemanagementCustomersReportsCountChromeHardwareFleetDevicesResponse, error) {
	baseURL := s.serverURL
	url := utils.GenerateURL(ctx, baseURL, "/v1/{customer}/reports:countChromeHardwareFleetDevices", request, nil)

	req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	if err := utils.PopulateQueryParams(ctx, req, request, nil); err != nil {
		return nil, fmt.Errorf("error populating query params: %w", err)
	}

	client := utils.ConfigureSecurityClient(s.defaultClient, security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.ChromemanagementCustomersReportsCountChromeHardwareFleetDevicesResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *shared.GoogleChromeManagementV1CountChromeHardwareFleetDevicesResponse
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.GoogleChromeManagementV1CountChromeHardwareFleetDevicesResponse = out
		}
	}

	return res, nil
}

// ChromemanagementCustomersReportsCountChromeVersions - Generate report of installed Chrome versions.
func (s *customers) ChromemanagementCustomersReportsCountChromeVersions(ctx context.Context, request operations.ChromemanagementCustomersReportsCountChromeVersionsRequest, security operations.ChromemanagementCustomersReportsCountChromeVersionsSecurity) (*operations.ChromemanagementCustomersReportsCountChromeVersionsResponse, error) {
	baseURL := s.serverURL
	url := utils.GenerateURL(ctx, baseURL, "/v1/{customer}/reports:countChromeVersions", request, nil)

	req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	if err := utils.PopulateQueryParams(ctx, req, request, nil); err != nil {
		return nil, fmt.Errorf("error populating query params: %w", err)
	}

	client := utils.ConfigureSecurityClient(s.defaultClient, security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.ChromemanagementCustomersReportsCountChromeVersionsResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *shared.GoogleChromeManagementV1CountChromeVersionsResponse
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.GoogleChromeManagementV1CountChromeVersionsResponse = out
		}
	}

	return res, nil
}

// ChromemanagementCustomersReportsCountInstalledApps - Generate report of app installations.
func (s *customers) ChromemanagementCustomersReportsCountInstalledApps(ctx context.Context, request operations.ChromemanagementCustomersReportsCountInstalledAppsRequest, security operations.ChromemanagementCustomersReportsCountInstalledAppsSecurity) (*operations.ChromemanagementCustomersReportsCountInstalledAppsResponse, error) {
	baseURL := s.serverURL
	url := utils.GenerateURL(ctx, baseURL, "/v1/{customer}/reports:countInstalledApps", request, nil)

	req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	if err := utils.PopulateQueryParams(ctx, req, request, nil); err != nil {
		return nil, fmt.Errorf("error populating query params: %w", err)
	}

	client := utils.ConfigureSecurityClient(s.defaultClient, security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.ChromemanagementCustomersReportsCountInstalledAppsResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *shared.GoogleChromeManagementV1CountInstalledAppsResponse
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.GoogleChromeManagementV1CountInstalledAppsResponse = out
		}
	}

	return res, nil
}

// ChromemanagementCustomersReportsCountPrintJobsByPrinter - Get a summary of printing done by each printer.
func (s *customers) ChromemanagementCustomersReportsCountPrintJobsByPrinter(ctx context.Context, request operations.ChromemanagementCustomersReportsCountPrintJobsByPrinterRequest, security operations.ChromemanagementCustomersReportsCountPrintJobsByPrinterSecurity) (*operations.ChromemanagementCustomersReportsCountPrintJobsByPrinterResponse, error) {
	baseURL := s.serverURL
	url := utils.GenerateURL(ctx, baseURL, "/v1/{customer}/reports:countPrintJobsByPrinter", request, nil)

	req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	if err := utils.PopulateQueryParams(ctx, req, request, nil); err != nil {
		return nil, fmt.Errorf("error populating query params: %w", err)
	}

	client := utils.ConfigureSecurityClient(s.defaultClient, security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.ChromemanagementCustomersReportsCountPrintJobsByPrinterResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *shared.GoogleChromeManagementV1CountPrintJobsByPrinterResponse
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.GoogleChromeManagementV1CountPrintJobsByPrinterResponse = out
		}
	}

	return res, nil
}

// ChromemanagementCustomersReportsCountPrintJobsByUser - Get a summary of printing done by each user.
func (s *customers) ChromemanagementCustomersReportsCountPrintJobsByUser(ctx context.Context, request operations.ChromemanagementCustomersReportsCountPrintJobsByUserRequest, security operations.ChromemanagementCustomersReportsCountPrintJobsByUserSecurity) (*operations.ChromemanagementCustomersReportsCountPrintJobsByUserResponse, error) {
	baseURL := s.serverURL
	url := utils.GenerateURL(ctx, baseURL, "/v1/{customer}/reports:countPrintJobsByUser", request, nil)

	req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	if err := utils.PopulateQueryParams(ctx, req, request, nil); err != nil {
		return nil, fmt.Errorf("error populating query params: %w", err)
	}

	client := utils.ConfigureSecurityClient(s.defaultClient, security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.ChromemanagementCustomersReportsCountPrintJobsByUserResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *shared.GoogleChromeManagementV1CountPrintJobsByUserResponse
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.GoogleChromeManagementV1CountPrintJobsByUserResponse = out
		}
	}

	return res, nil
}

// ChromemanagementCustomersReportsFindInstalledAppDevices - Generate report of managed Chrome browser devices that have a specified app installed.
func (s *customers) ChromemanagementCustomersReportsFindInstalledAppDevices(ctx context.Context, request operations.ChromemanagementCustomersReportsFindInstalledAppDevicesRequest, security operations.ChromemanagementCustomersReportsFindInstalledAppDevicesSecurity) (*operations.ChromemanagementCustomersReportsFindInstalledAppDevicesResponse, error) {
	baseURL := s.serverURL
	url := utils.GenerateURL(ctx, baseURL, "/v1/{customer}/reports:findInstalledAppDevices", request, nil)

	req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	if err := utils.PopulateQueryParams(ctx, req, request, nil); err != nil {
		return nil, fmt.Errorf("error populating query params: %w", err)
	}

	client := utils.ConfigureSecurityClient(s.defaultClient, security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.ChromemanagementCustomersReportsFindInstalledAppDevicesResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *shared.GoogleChromeManagementV1FindInstalledAppDevicesResponse
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.GoogleChromeManagementV1FindInstalledAppDevicesResponse = out
		}
	}

	return res, nil
}

// ChromemanagementCustomersTelemetryDevicesList - List all telemetry devices.
func (s *customers) ChromemanagementCustomersTelemetryDevicesList(ctx context.Context, request operations.ChromemanagementCustomersTelemetryDevicesListRequest, security operations.ChromemanagementCustomersTelemetryDevicesListSecurity) (*operations.ChromemanagementCustomersTelemetryDevicesListResponse, error) {
	baseURL := s.serverURL
	url := utils.GenerateURL(ctx, baseURL, "/v1/{parent}/telemetry/devices", request, nil)

	req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	if err := utils.PopulateQueryParams(ctx, req, request, nil); err != nil {
		return nil, fmt.Errorf("error populating query params: %w", err)
	}

	client := utils.ConfigureSecurityClient(s.defaultClient, security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.ChromemanagementCustomersTelemetryDevicesListResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *shared.GoogleChromeManagementV1ListTelemetryDevicesResponse
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.GoogleChromeManagementV1ListTelemetryDevicesResponse = out
		}
	}

	return res, nil
}

// ChromemanagementCustomersTelemetryEventsList - List telemetry events.
func (s *customers) ChromemanagementCustomersTelemetryEventsList(ctx context.Context, request operations.ChromemanagementCustomersTelemetryEventsListRequest, security operations.ChromemanagementCustomersTelemetryEventsListSecurity) (*operations.ChromemanagementCustomersTelemetryEventsListResponse, error) {
	baseURL := s.serverURL
	url := utils.GenerateURL(ctx, baseURL, "/v1/{parent}/telemetry/events", request, nil)

	req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	if err := utils.PopulateQueryParams(ctx, req, request, nil); err != nil {
		return nil, fmt.Errorf("error populating query params: %w", err)
	}

	client := utils.ConfigureSecurityClient(s.defaultClient, security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.ChromemanagementCustomersTelemetryEventsListResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *shared.GoogleChromeManagementV1ListTelemetryEventsResponse
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.GoogleChromeManagementV1ListTelemetryEventsResponse = out
		}
	}

	return res, nil
}

// ChromemanagementCustomersTelemetryUsersGet - Get telemetry user.
func (s *customers) ChromemanagementCustomersTelemetryUsersGet(ctx context.Context, request operations.ChromemanagementCustomersTelemetryUsersGetRequest, security operations.ChromemanagementCustomersTelemetryUsersGetSecurity) (*operations.ChromemanagementCustomersTelemetryUsersGetResponse, error) {
	baseURL := s.serverURL
	url := utils.GenerateURL(ctx, baseURL, "/v1/{name}", request, nil)

	req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	if err := utils.PopulateQueryParams(ctx, req, request, nil); err != nil {
		return nil, fmt.Errorf("error populating query params: %w", err)
	}

	client := utils.ConfigureSecurityClient(s.defaultClient, security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.ChromemanagementCustomersTelemetryUsersGetResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *shared.GoogleChromeManagementV1TelemetryUser
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.GoogleChromeManagementV1TelemetryUser = out
		}
	}

	return res, nil
}

// ChromemanagementCustomersTelemetryUsersList - List all telemetry users.
func (s *customers) ChromemanagementCustomersTelemetryUsersList(ctx context.Context, request operations.ChromemanagementCustomersTelemetryUsersListRequest, security operations.ChromemanagementCustomersTelemetryUsersListSecurity) (*operations.ChromemanagementCustomersTelemetryUsersListResponse, error) {
	baseURL := s.serverURL
	url := utils.GenerateURL(ctx, baseURL, "/v1/{parent}/telemetry/users", request, nil)

	req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	if err := utils.PopulateQueryParams(ctx, req, request, nil); err != nil {
		return nil, fmt.Errorf("error populating query params: %w", err)
	}

	client := utils.ConfigureSecurityClient(s.defaultClient, security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.ChromemanagementCustomersTelemetryUsersListResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *shared.GoogleChromeManagementV1ListTelemetryUsersResponse
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.GoogleChromeManagementV1ListTelemetryUsersResponse = out
		}
	}

	return res, nil
}
