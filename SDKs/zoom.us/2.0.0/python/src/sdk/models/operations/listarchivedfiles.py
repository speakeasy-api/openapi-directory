"""Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT."""

from __future__ import annotations
import dataclasses
import requests as requests_http
from dataclasses_json import Undefined, dataclass_json
from enum import Enum
from sdk import utils
from typing import Optional

class ListArchivedFilesQueryDataTypeEnum(str, Enum):
    r"""Query data type for `from` and `to`."""
    MEETING_START_TIME = 'meeting_start_time'
    ARCHIVE_COMPLETE_TIME = 'archive_complete_time'


@dataclasses.dataclass
class ListArchivedFilesRequest:
    
    from_: Optional[str] = dataclasses.field(default=None, metadata={'query_param': { 'field_name': 'from', 'style': 'form', 'explode': True }})
    r"""Start date for the query in \\"yyyy-MM-dd'T'HH:mm:ss'Z'\\" format. The duration for the query defined using the \\"from\\" and \\"to\\" parameters should not exceed 7 days as this API only provides a week's data at once."""  
    next_page_token: Optional[str] = dataclasses.field(default=None, metadata={'query_param': { 'field_name': 'next_page_token', 'style': 'form', 'explode': True }})
    r"""The next page token is used to paginate through large result sets. A next page token will be returned whenever the set of available results exceeds the current page size. The expiration period for this token is 15 minutes."""  
    page_size: Optional[int] = dataclasses.field(default=None, metadata={'query_param': { 'field_name': 'page_size', 'style': 'form', 'explode': True }})
    r"""The number of records returned within a single API call."""  
    query_data_type: Optional[ListArchivedFilesQueryDataTypeEnum] = dataclasses.field(default=None, metadata={'query_param': { 'field_name': 'query_data_type', 'style': 'form', 'explode': True }})
    r"""Query data type for `from` and `to`."""  
    to: Optional[str] = dataclasses.field(default=None, metadata={'query_param': { 'field_name': 'to', 'style': 'form', 'explode': True }})
    r"""End date for the query in \\"yyyy-MM-dd'T'HH:mm:ss'Z'\\" format."""  
    

@dataclasses.dataclass
class ListArchivedFiles200ApplicationXMLMeetingsArchiveFiles:
    
    download_url: Optional[str] = dataclasses.field(default=None)
    r"""The URL using which the archived file can be downloaded. To download the archived file of a meeting or a webinar hosted in your account, create a [Zoom JWT App Type](https://marketplace.zoom.us/docs/guides/getting-started/app-types/create-jwt-app). Use the generated JWT token as the value of the access_token query parameter and include this query parameter at the end of the URL as shown in the example.
     
    Example: `https://{{base-domain}}/rec/archive/download/xxx?access_token={{Your-JWT}}`
    
    If a user has authorized and installed your OAuth app that supports archiving, use the user’s [OAuth access token](https://marketplace.zoom.us/docs/guides/auth/oauth) to download the file.
    
    Example: `https://{{base-domain}}/rec/archive/download/xxx?access_token={{ OAuth Access Token }}`
    """  
    file_extension: Optional[str] = dataclasses.field(default=None)
    r"""Extension of the recording file."""  
    file_size: Optional[int] = dataclasses.field(default=None)
    r"""The recording file size."""  
    file_type: Optional[str] = dataclasses.field(default=None)
    r"""Recorded file type. The value of this field could be one of the following:
    
    `MP4`: Video file of the recording.<br>
    `M4A`: Audio-only file of the recording.<br>
    `TRANSCRIPT`: Transcription file of the recording in VTT format.
    CHAT: A TXT file containing in-meeting chat messages that were sent during the meeting.<br>
    `CC`: File containing closed captions of the recording in VTT file format.<br>
    `CSV`: File containing polling data in csv format.
    """  
    id: Optional[str] = dataclasses.field(default=None)
    r"""Unique identifier of the archived file."""  
    recording_type: Optional[str] = dataclasses.field(default=None)
    r"""The recording type. The value of this field can be one of the following:
    * `shared_screen_with_speaker_view(CC)`
    * `shared_screen_with_speaker_view`
    * `shared_screen_with_gallery_view`
    * `speaker_view`
    * `gallery_view`
    * `shared_screen`
    * `audio_only`
    * `audio_transcript`
    * `chat_file`,
    * `active_speaker`
    * `host_video`
    """  
    status: Optional[str] = dataclasses.field(default=None)
    r"""Status of the archived file."""  
    

@dataclasses.dataclass
class ListArchivedFiles200ApplicationXMLMeetings:
    
    archive_files: Optional[list[ListArchivedFiles200ApplicationXMLMeetingsArchiveFiles]] = dataclasses.field(default=None)  
    duration: Optional[int] = dataclasses.field(default=None)
    r"""Scheduled duration of the meeting or the webinar."""  
    host_id: Optional[str] = dataclasses.field(default=None)
    r"""ID of the user set as the host of meeting or the webinar that was archived."""  
    id: Optional[int] = dataclasses.field(default=None)
    r"""Unique identifier of the meeting(meetingId) or the webinar(webinarId)."""  
    recording_count: Optional[int] = dataclasses.field(default=None)
    r"""Number of recording files returned in the response of this API call."""  
    start_time: Optional[str] = dataclasses.field(default=None)
    r"""The time at which the meeting or the webinar started."""  
    timezone: Optional[str] = dataclasses.field(default=None)
    r"""Timezone of the host."""  
    topic: Optional[str] = dataclasses.field(default=None)
    r"""Meeting or webinar topic."""  
    total_size: Optional[int] = dataclasses.field(default=None)
    r"""Total size of the archive."""  
    type: Optional[int] = dataclasses.field(default=None)
    r"""Type of the meeting or the webinar that was archived.<br>
    <br>Meeting types:<br>
    `1` - Instant meeting<br>
    `2` - Scheduled meeting<br>
    `3` - Recurring meeting with no fixed time<br>
    8 - Recurring meeting with fixed time
     
    Webinar types:<br>
    `5` - Webinar<br>
    `6` - Recurring webinar with no fixed time<br>
    `9` - Recurring webinar with a fixed time
    """  
    uuid: Optional[str] = dataclasses.field(default=None)
    r"""Unique identifier of the meeting instance or the webinar instance during which the archiving took place. Each instance of the meeting will have its own UUID."""  
    

@dataclasses.dataclass
class ListArchivedFiles200ApplicationXML:
    r"""**HTTP Status Code:** `200` **OK**
    Archived files returned.
    """
    
    from_: Optional[str] = dataclasses.field(default=None)
    r"""Start date for the query in \\"yyyy-MM-dd'T'HH:mm:ss'Z'\\" format. The duration for the query defined using the \\"from\\" and \\"to\\" parameters should not exceed 7 days as this API only provides a week's data at once."""  
    meetings: Optional[list[ListArchivedFiles200ApplicationXMLMeetings]] = dataclasses.field(default=None)  
    next_page_token: Optional[str] = dataclasses.field(default=None)
    r"""The next page token is used to paginate through large result sets. A next page token will be returned whenever the set of available results exceeds the current page size. The expiration period for this token is 15 minutes."""  
    page_size: Optional[int] = dataclasses.field(default=None)
    r"""The number of records returned within a single API call."""  
    to: Optional[str] = dataclasses.field(default=None)
    r"""End date for the query in \\"yyyy-MM-dd'T'HH:mm:ss'Z'\\" format."""  
    

@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class ListArchivedFiles200ApplicationJSONMeetingsArchiveFiles:
    
    download_url: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('download_url'), 'exclude': lambda f: f is None }})
    r"""The URL using which the archived file can be downloaded. To download the archived file of a meeting or a webinar hosted in your account, create a [Zoom JWT App Type](https://marketplace.zoom.us/docs/guides/getting-started/app-types/create-jwt-app). Use the generated JWT token as the value of the access_token query parameter and include this query parameter at the end of the URL as shown in the example.
     
    Example: `https://{{base-domain}}/rec/archive/download/xxx?access_token={{Your-JWT}}`
    
    If a user has authorized and installed your OAuth app that supports archiving, use the user’s [OAuth access token](https://marketplace.zoom.us/docs/guides/auth/oauth) to download the file.
    
    Example: `https://{{base-domain}}/rec/archive/download/xxx?access_token={{ OAuth Access Token }}`
    """  
    file_extension: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('file_extension'), 'exclude': lambda f: f is None }})
    r"""Extension of the recording file."""  
    file_size: Optional[int] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('file_size'), 'exclude': lambda f: f is None }})
    r"""The recording file size."""  
    file_type: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('file_type'), 'exclude': lambda f: f is None }})
    r"""Recorded file type. The value of this field could be one of the following:
    
    `MP4`: Video file of the recording.<br>
    `M4A`: Audio-only file of the recording.<br>
    `TRANSCRIPT`: Transcription file of the recording in VTT format.
    CHAT: A TXT file containing in-meeting chat messages that were sent during the meeting.<br>
    `CC`: File containing closed captions of the recording in VTT file format.<br>
    `CSV`: File containing polling data in csv format.
    """  
    id: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('id'), 'exclude': lambda f: f is None }})
    r"""Unique identifier of the archived file."""  
    recording_type: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('recording_type'), 'exclude': lambda f: f is None }})
    r"""The recording type. The value of this field can be one of the following:
    * `shared_screen_with_speaker_view(CC)`
    * `shared_screen_with_speaker_view`
    * `shared_screen_with_gallery_view`
    * `speaker_view`
    * `gallery_view`
    * `shared_screen`
    * `audio_only`
    * `audio_transcript`
    * `chat_file`,
    * `active_speaker`
    * `host_video`
    """  
    status: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('status'), 'exclude': lambda f: f is None }})
    r"""Status of the archived file."""  
    

@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class ListArchivedFiles200ApplicationJSONMeetings:
    
    archive_files: Optional[list[ListArchivedFiles200ApplicationJSONMeetingsArchiveFiles]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('archive_files'), 'exclude': lambda f: f is None }})  
    duration: Optional[int] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('duration'), 'exclude': lambda f: f is None }})
    r"""Scheduled duration of the meeting or the webinar."""  
    host_id: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('host_id'), 'exclude': lambda f: f is None }})
    r"""ID of the user set as the host of meeting or the webinar that was archived."""  
    id: Optional[int] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('id'), 'exclude': lambda f: f is None }})
    r"""Unique identifier of the meeting(meetingId) or the webinar(webinarId)."""  
    recording_count: Optional[int] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('recording_count'), 'exclude': lambda f: f is None }})
    r"""Number of recording files returned in the response of this API call."""  
    start_time: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('start_time'), 'exclude': lambda f: f is None }})
    r"""The time at which the meeting or the webinar started."""  
    timezone: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('timezone'), 'exclude': lambda f: f is None }})
    r"""Timezone of the host."""  
    topic: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('topic'), 'exclude': lambda f: f is None }})
    r"""Meeting or webinar topic."""  
    total_size: Optional[int] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('total_size'), 'exclude': lambda f: f is None }})
    r"""Total size of the archive."""  
    type: Optional[int] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('type'), 'exclude': lambda f: f is None }})
    r"""Type of the meeting or the webinar that was archived.<br>
    <br>Meeting types:<br>
    `1` - Instant meeting<br>
    `2` - Scheduled meeting<br>
    `3` - Recurring meeting with no fixed time<br>
    8 - Recurring meeting with fixed time
     
    Webinar types:<br>
    `5` - Webinar<br>
    `6` - Recurring webinar with no fixed time<br>
    `9` - Recurring webinar with a fixed time
    """  
    uuid: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('uuid'), 'exclude': lambda f: f is None }})
    r"""Unique identifier of the meeting instance or the webinar instance during which the archiving took place. Each instance of the meeting will have its own UUID."""  
    

@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class ListArchivedFiles200ApplicationJSON:
    r"""**HTTP Status Code:** `200` **OK**
    Archived files returned.
    """
    
    from_: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('from'), 'exclude': lambda f: f is None }})
    r"""Start date for the query in \\"yyyy-MM-dd'T'HH:mm:ss'Z'\\" format. The duration for the query defined using the \\"from\\" and \\"to\\" parameters should not exceed 7 days as this API only provides a week's data at once."""  
    meetings: Optional[list[ListArchivedFiles200ApplicationJSONMeetings]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('meetings'), 'exclude': lambda f: f is None }})  
    next_page_token: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('next_page_token'), 'exclude': lambda f: f is None }})
    r"""The next page token is used to paginate through large result sets. A next page token will be returned whenever the set of available results exceeds the current page size. The expiration period for this token is 15 minutes."""  
    page_size: Optional[int] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('page_size'), 'exclude': lambda f: f is None }})
    r"""The number of records returned within a single API call."""  
    to: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('to'), 'exclude': lambda f: f is None }})
    r"""End date for the query in \\"yyyy-MM-dd'T'HH:mm:ss'Z'\\" format."""  
    

@dataclasses.dataclass
class ListArchivedFilesResponse:
    
    content_type: str = dataclasses.field()  
    status_code: int = dataclasses.field()  
    body: Optional[bytes] = dataclasses.field(default=None)  
    list_archived_files_200_application_json_object: Optional[ListArchivedFiles200ApplicationJSON] = dataclasses.field(default=None)
    r"""**HTTP Status Code:** `200` **OK**
    Archived files returned.
    """  
    raw_response: Optional[requests_http.Response] = dataclasses.field(default=None)  
    