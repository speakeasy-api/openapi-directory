"use strict";
/*
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SDK = exports.ServerList = void 0;
var action_1 = require("./action");
var bundle_1 = require("./bundle");
var calendarevent_1 = require("./calendarevent");
var calendareventresponse_1 = require("./calendareventresponse");
var coach_1 = require("./coach");
var emailhistory_1 = require("./emailhistory");
var group_1 = require("./group");
var healthprofile_1 = require("./healthprofile");
var healthprofileanswer_1 = require("./healthprofileanswer");
var healthprofilequestion_1 = require("./healthprofilequestion");
var healthquestiondefinition_1 = require("./healthquestiondefinition");
var metric_1 = require("./metric");
var oauth_1 = require("./oauth");
var organization_1 = require("./organization");
var patient_1 = require("./patient");
var plan_1 = require("./plan");
var result_1 = require("./result");
var reward_1 = require("./reward");
var rewardearning_1 = require("./rewardearning");
var rewardearningfulfillment_1 = require("./rewardearningfulfillment");
var rewardprogram_1 = require("./rewardprogram");
var rewardprogramactivation_1 = require("./rewardprogramactivation");
var axios_1 = __importDefault(require("axios"));
/**
 * Contains the list of servers available to the SDK
 */
exports.ServerList = ["https://api.twinehealth.com/pub"];
/**
 * # Overview
 *
 * @remarks
 * The Fitbit Plus API is a RESTful API. The requests and responses are formated according to the
 * [JSON API](http://jsonapi.org/format/1.0/) specification.
 *
 * In addition to this documentation, we also provide an
 * [OpenAPI](https://github.com/OAI/OpenAPI-Specification/blob/master/versions/2.0.md) "yaml" file describing the API:
 * [Fitbit Plus API Specification](swagger.yaml).
 *
 * # Authentication
 * Authentication for the Fitbit Plus API is based on the
 * [OAuth 2.0 Authorization Framework](https://tools.ietf.org/html/rfc6749). Fitbit Plus currently supports grant
 * types of **client_credentials** and **refresh_token**.
 *
 * See [POST /oauth/token](#operation/createToken) for details on the request and response formats.
 * <!-- ReDoc-Inject: <security-definitions> -->
 *
 * ## Building Integrations
 * We will provide customers with unique client credentials for each application/integration they build, allowing us
 * to enforce appropriate access controls and monitor API usage.
 * The client credentials will be scoped to the organization, and allow full access to all patients and related data
 * within that organization.
 *
 * These credentials are appropriate for creating an integration that does one of the following:
 *  - background reporting/analysis
 *  - synchronizing data with another system (such as an EMR)
 *
 * The API credentials and oauth flows we currently support are **not** well suited for creating a user-facing
 * application that allows a user (patient, coach, or admin) to login and have access to data which is appropriate to
 * that specific user. It is possible to build such an application, but it is not possible to use Fitbit Plus as a
 * federated identity provider. You would need to have a separate means of verifying a user's identity. We do not
 * currently support the required password-based oauth flow to make this possible.
 *
 * # Paging
 * The Fitbit Plus API supports two different pagination strategies for GET collection endpoints.
 *
 * #### Skip-based paging
 *
 * Skip-based paging uses the query parameters `page[size]` and `page[number]` to specify the max number of resources returned and the page number. We default to skip-based paging if there are no page parameters. The response will include a `links` object containing links to the first, last, prev, and next pages of data.
 *
 * If the contents of the collection change while you are iterating through the collection, you will see duplicate or missing documents. For example, if you are iterating through the `calender_event` resource via `GET /pub/calendar_event?sort=start_at&page[size]=50&page[number]=1`, and a new `calendar_event` is created that has a `start_at` value before the first `calendar_event`, when you fetch the next page at `GET /pub/calendar_event?sort=start_at&page[size]=50&page[number]=2`, the first entry in the second response will be a duplicate of the last entry in the first response.
 *
 * #### Cursor-based paging
 * Cursor-based paging uses the query parameters `page[limit]` and `page[after]` to specify the max number of entries returned and identify where to begin the next page. Add `page[limit]` to the parameters to use cursor-based paging. The response will include a `links` object containing a link to the next page of data, if the next page exists.
 *
 * Cursor-based paging is not subject to duplication if new resources are added to the collection. For example, if you are iterating through the `calender_event` resource via `GET /pub/calendar_event?sort=start_at&page[limit]=50`, and a new `calendar_event` is created that has a `start_at` value before the first `calendar_event`, you will not see a duplicate entry when you fetch the next page at `GET /pub/calendar_event?sort=start_at&page[limit]=50&page[after]=<cursor>`.
 *
 * We encourage the use of cursor-based paging for performance reasons.
 *
 * In either form of paging, you can determine whether any resources were missed by comparing the number of fetched resources against `meta.count`. Set `page[size]` or `page[limit]` to 0 to get only the count.
 *
 * It is not valid to mix the two strategies.
 *
 */
var SDK = /** @class */ (function () {
    function SDK(props) {
        var _a, _b;
        this._language = "typescript";
        this._sdkVersion = "0.0.1";
        this._genVersion = "internal";
        this._serverURL = (_a = props === null || props === void 0 ? void 0 : props.serverURL) !== null && _a !== void 0 ? _a : exports.ServerList[0];
        this._defaultClient =
            (_b = props === null || props === void 0 ? void 0 : props.defaultClient) !== null && _b !== void 0 ? _b : axios_1.default.create({ baseURL: this._serverURL });
        this._securityClient = this._defaultClient;
        this.action = new action_1.Action(this._defaultClient, this._securityClient, this._serverURL, this._language, this._sdkVersion, this._genVersion);
        this.bundle = new bundle_1.Bundle(this._defaultClient, this._securityClient, this._serverURL, this._language, this._sdkVersion, this._genVersion);
        this.calendarEvent = new calendarevent_1.CalendarEvent(this._defaultClient, this._securityClient, this._serverURL, this._language, this._sdkVersion, this._genVersion);
        this.calendarEventResponse = new calendareventresponse_1.CalendarEventResponse(this._defaultClient, this._securityClient, this._serverURL, this._language, this._sdkVersion, this._genVersion);
        this.coach = new coach_1.Coach(this._defaultClient, this._securityClient, this._serverURL, this._language, this._sdkVersion, this._genVersion);
        this.emailHistory = new emailhistory_1.EmailHistory(this._defaultClient, this._securityClient, this._serverURL, this._language, this._sdkVersion, this._genVersion);
        this.group = new group_1.Group(this._defaultClient, this._securityClient, this._serverURL, this._language, this._sdkVersion, this._genVersion);
        this.healthProfile = new healthprofile_1.HealthProfile(this._defaultClient, this._securityClient, this._serverURL, this._language, this._sdkVersion, this._genVersion);
        this.healthProfileAnswer = new healthprofileanswer_1.HealthProfileAnswer(this._defaultClient, this._securityClient, this._serverURL, this._language, this._sdkVersion, this._genVersion);
        this.healthProfileQuestion = new healthprofilequestion_1.HealthProfileQuestion(this._defaultClient, this._securityClient, this._serverURL, this._language, this._sdkVersion, this._genVersion);
        this.healthQuestionDefinition = new healthquestiondefinition_1.HealthQuestionDefinition(this._defaultClient, this._securityClient, this._serverURL, this._language, this._sdkVersion, this._genVersion);
        this.metric = new metric_1.Metric(this._defaultClient, this._securityClient, this._serverURL, this._language, this._sdkVersion, this._genVersion);
        this.oauth = new oauth_1.Oauth(this._defaultClient, this._securityClient, this._serverURL, this._language, this._sdkVersion, this._genVersion);
        this.organization = new organization_1.Organization(this._defaultClient, this._securityClient, this._serverURL, this._language, this._sdkVersion, this._genVersion);
        this.patient = new patient_1.Patient(this._defaultClient, this._securityClient, this._serverURL, this._language, this._sdkVersion, this._genVersion);
        this.plan = new plan_1.Plan(this._defaultClient, this._securityClient, this._serverURL, this._language, this._sdkVersion, this._genVersion);
        this.result = new result_1.Result(this._defaultClient, this._securityClient, this._serverURL, this._language, this._sdkVersion, this._genVersion);
        this.reward = new reward_1.Reward(this._defaultClient, this._securityClient, this._serverURL, this._language, this._sdkVersion, this._genVersion);
        this.rewardEarning = new rewardearning_1.RewardEarning(this._defaultClient, this._securityClient, this._serverURL, this._language, this._sdkVersion, this._genVersion);
        this.rewardEarningFulfillment = new rewardearningfulfillment_1.RewardEarningFulfillment(this._defaultClient, this._securityClient, this._serverURL, this._language, this._sdkVersion, this._genVersion);
        this.rewardProgram = new rewardprogram_1.RewardProgram(this._defaultClient, this._securityClient, this._serverURL, this._language, this._sdkVersion, this._genVersion);
        this.rewardProgramActivation = new rewardprogramactivation_1.RewardProgramActivation(this._defaultClient, this._securityClient, this._serverURL, this._language, this._sdkVersion, this._genVersion);
    }
    return SDK;
}());
exports.SDK = SDK;
