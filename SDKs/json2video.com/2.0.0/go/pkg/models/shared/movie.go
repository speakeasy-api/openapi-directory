// Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.

package shared

import (
	"bytes"
	"encoding/json"
	"errors"
	"fmt"
)

// MovieDraftEnum - Draft movies include a watermark. Check your plan how many draft and final movies you have
type MovieDraftEnum string

const (
	MovieDraftEnumTrue  MovieDraftEnum = "true"
	MovieDraftEnumFalse MovieDraftEnum = "false"
)

func (e *MovieDraftEnum) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return err
	}
	switch s {
	case "true":
		fallthrough
	case "false":
		*e = MovieDraftEnum(s)
		return nil
	default:
		return fmt.Errorf("invalid value for MovieDraftEnum: %s", s)
	}
}

type MovieElementsType string

const (
	MovieElementsTypeVideo     MovieElementsType = "video"
	MovieElementsTypeImage     MovieElementsType = "image"
	MovieElementsTypeText      MovieElementsType = "text"
	MovieElementsTypeHTML      MovieElementsType = "html"
	MovieElementsTypeComponent MovieElementsType = "component"
	MovieElementsTypeTemplate  MovieElementsType = "template"
	MovieElementsTypeAudio     MovieElementsType = "audio"
	MovieElementsTypeVoice     MovieElementsType = "voice"
)

type MovieElements struct {
	Video     *Video
	Image     *Image
	Text      *Text
	HTML      *HTML
	Component *Component
	Template  *Template
	Audio     *Audio
	Voice     *Voice

	Type MovieElementsType
}

func CreateMovieElementsVideo(video Video) MovieElements {
	typ := MovieElementsTypeVideo
	typStr := VideoTypeEnum(typ)
	video.Type = typStr

	return MovieElements{
		Video: &video,
		Type:  typ,
	}
}

func CreateMovieElementsImage(image Image) MovieElements {
	typ := MovieElementsTypeImage
	typStr := ImageTypeEnum(typ)
	image.Type = &typStr

	return MovieElements{
		Image: &image,
		Type:  typ,
	}
}

func CreateMovieElementsText(text Text) MovieElements {
	typ := MovieElementsTypeText
	typStr := TextTypeEnum(typ)
	text.Type = typStr

	return MovieElements{
		Text: &text,
		Type: typ,
	}
}

func CreateMovieElementsHTML(html HTML) MovieElements {
	typ := MovieElementsTypeHTML
	typStr := HTMLTypeEnum(typ)
	html.Type = typStr

	return MovieElements{
		HTML: &html,
		Type: typ,
	}
}

func CreateMovieElementsComponent(component Component) MovieElements {
	typ := MovieElementsTypeComponent
	typStr := ComponentTypeEnum(typ)
	component.Type = typStr

	return MovieElements{
		Component: &component,
		Type:      typ,
	}
}

func CreateMovieElementsTemplate(template Template) MovieElements {
	typ := MovieElementsTypeTemplate
	typStr := TemplateTypeEnum(typ)
	template.Type = typStr

	return MovieElements{
		Template: &template,
		Type:     typ,
	}
}

func CreateMovieElementsAudio(audio Audio) MovieElements {
	typ := MovieElementsTypeAudio
	typStr := AudioTypeEnum(typ)
	audio.Type = &typStr

	return MovieElements{
		Audio: &audio,
		Type:  typ,
	}
}

func CreateMovieElementsVoice(voice Voice) MovieElements {
	typ := MovieElementsTypeVoice
	typStr := VoiceTypeEnum(typ)
	voice.Type = typStr

	return MovieElements{
		Voice: &voice,
		Type:  typ,
	}
}

func (u *MovieElements) UnmarshalJSON(data []byte) error {
	var d *json.Decoder

	type discriminator struct {
		Type string
	}

	dis := new(discriminator)
	if err := json.Unmarshal(data, &dis); err != nil {
		return fmt.Errorf("could not unmarshal discriminator: %w", err)
	}

	switch dis.Type {
	case "video":
		d = json.NewDecoder(bytes.NewReader(data))
		d.DisallowUnknownFields()
		video := new(Video)
		if err := d.Decode(&video); err != nil {
			return fmt.Errorf("could not unmarshal expected type: %w", err)
		}

		u.Video = video
		u.Type = MovieElementsTypeVideo
		return nil
	case "image":
		d = json.NewDecoder(bytes.NewReader(data))
		d.DisallowUnknownFields()
		image := new(Image)
		if err := d.Decode(&image); err != nil {
			return fmt.Errorf("could not unmarshal expected type: %w", err)
		}

		u.Image = image
		u.Type = MovieElementsTypeImage
		return nil
	case "text":
		d = json.NewDecoder(bytes.NewReader(data))
		d.DisallowUnknownFields()
		text := new(Text)
		if err := d.Decode(&text); err != nil {
			return fmt.Errorf("could not unmarshal expected type: %w", err)
		}

		u.Text = text
		u.Type = MovieElementsTypeText
		return nil
	case "html":
		d = json.NewDecoder(bytes.NewReader(data))
		d.DisallowUnknownFields()
		html := new(HTML)
		if err := d.Decode(&html); err != nil {
			return fmt.Errorf("could not unmarshal expected type: %w", err)
		}

		u.HTML = html
		u.Type = MovieElementsTypeHTML
		return nil
	case "component":
		d = json.NewDecoder(bytes.NewReader(data))
		d.DisallowUnknownFields()
		component := new(Component)
		if err := d.Decode(&component); err != nil {
			return fmt.Errorf("could not unmarshal expected type: %w", err)
		}

		u.Component = component
		u.Type = MovieElementsTypeComponent
		return nil
	case "template":
		d = json.NewDecoder(bytes.NewReader(data))
		d.DisallowUnknownFields()
		template := new(Template)
		if err := d.Decode(&template); err != nil {
			return fmt.Errorf("could not unmarshal expected type: %w", err)
		}

		u.Template = template
		u.Type = MovieElementsTypeTemplate
		return nil
	case "audio":
		d = json.NewDecoder(bytes.NewReader(data))
		d.DisallowUnknownFields()
		audio := new(Audio)
		if err := d.Decode(&audio); err != nil {
			return fmt.Errorf("could not unmarshal expected type: %w", err)
		}

		u.Audio = audio
		u.Type = MovieElementsTypeAudio
		return nil
	case "voice":
		d = json.NewDecoder(bytes.NewReader(data))
		d.DisallowUnknownFields()
		voice := new(Voice)
		if err := d.Decode(&voice); err != nil {
			return fmt.Errorf("could not unmarshal expected type: %w", err)
		}

		u.Voice = voice
		u.Type = MovieElementsTypeVoice
		return nil
	}

	return errors.New("could not unmarshal into supported union types")
}

func (u MovieElements) MarshalJSON() ([]byte, error) {
	if u.Video != nil {
		return json.Marshal(u.Video)
	}

	if u.Image != nil {
		return json.Marshal(u.Image)
	}

	if u.Text != nil {
		return json.Marshal(u.Text)
	}

	if u.HTML != nil {
		return json.Marshal(u.HTML)
	}

	if u.Component != nil {
		return json.Marshal(u.Component)
	}

	if u.Template != nil {
		return json.Marshal(u.Template)
	}

	if u.Audio != nil {
		return json.Marshal(u.Audio)
	}

	if u.Voice != nil {
		return json.Marshal(u.Voice)
	}

	return nil, nil
}

type MovieQualityEnum string

const (
	MovieQualityEnumLow    MovieQualityEnum = "low"
	MovieQualityEnumMedium MovieQualityEnum = "medium"
	MovieQualityEnumHigh   MovieQualityEnum = "high"
)

func (e *MovieQualityEnum) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return err
	}
	switch s {
	case "low":
		fallthrough
	case "medium":
		fallthrough
	case "high":
		*e = MovieQualityEnum(s)
		return nil
	default:
		return fmt.Errorf("invalid value for MovieQualityEnum: %s", s)
	}
}

type MovieResolutionEnum string

const (
	MovieResolutionEnumSd               MovieResolutionEnum = "sd"
	MovieResolutionEnumHd               MovieResolutionEnum = "hd"
	MovieResolutionEnumFullHd           MovieResolutionEnum = "full-hd"
	MovieResolutionEnumSquared          MovieResolutionEnum = "squared"
	MovieResolutionEnumInstagramStory   MovieResolutionEnum = "instagram-story"
	MovieResolutionEnumInstagramFeed    MovieResolutionEnum = "instagram-feed"
	MovieResolutionEnumTwitterLandscape MovieResolutionEnum = "twitter-landscape"
	MovieResolutionEnumTwitterPortrait  MovieResolutionEnum = "twitter-portrait"
)

func (e *MovieResolutionEnum) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return err
	}
	switch s {
	case "sd":
		fallthrough
	case "hd":
		fallthrough
	case "full-hd":
		fallthrough
	case "squared":
		fallthrough
	case "instagram-story":
		fallthrough
	case "instagram-feed":
		fallthrough
	case "twitter-landscape":
		fallthrough
	case "twitter-portrait":
		*e = MovieResolutionEnum(s)
		return nil
	default:
		return fmt.Errorf("invalid value for MovieResolutionEnum: %s", s)
	}
}

// Movie - Object defining the movie to be rendered
type Movie struct {
	Cache *bool `json:"cache,omitempty"`
	// Used for adding your comments
	Comment *string `json:"comment,omitempty"`
	// Draft movies include a watermark. Check your plan how many draft and final movies you have
	Draft    *MovieDraftEnum `json:"draft,omitempty"`
	Elements []MovieElements `json:"elements,omitempty"`
	// Frames per second
	Fps        *int64               `json:"fps,omitempty"`
	Height     *int64               `json:"height,omitempty"`
	Quality    *MovieQualityEnum    `json:"quality,omitempty"`
	Resolution *MovieResolutionEnum `json:"resolution,omitempty"`
	Scenes     []Scene              `json:"scenes"`
	// Movie advanced settings
	Settings map[string]interface{} `json:"settings,omitempty"`
	Width    *int64                 `json:"width,omitempty"`
}
