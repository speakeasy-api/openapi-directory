/*
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

import * as utils from "../internal/utils";
import * as operations from "./models/operations";
import * as shared from "./models/shared";
import axios, { AxiosInstance, AxiosRequestConfig, AxiosResponse } from "axios";

/**
 * Contains the list of servers available to the SDK
 */
export const ServerList = [
  /**
   * The imagebuilder multi-region endpoint
   */
  "http://imagebuilder.{region}.amazonaws.com",
  /**
   * The imagebuilder multi-region endpoint
   */
  "https://imagebuilder.{region}.amazonaws.com",
  /**
   * The imagebuilder endpoint for China (Beijing) and China (Ningxia)
   */
  "http://imagebuilder.{region}.amazonaws.com.cn",
  /**
   * The imagebuilder endpoint for China (Beijing) and China (Ningxia)
   */
  "https://imagebuilder.{region}.amazonaws.com.cn",
] as const;

/**
 * The available configuration options for the SDK
 */
export type SDKProps = {
  /**
   * The security details required to authenticate the SDK
   */
  security?: shared.Security;
  /**
   * Allows overriding the default axios client used by the SDK
   */
  defaultClient?: AxiosInstance;
  /**
   * Allows overriding the default server URL used by the SDK
   */
  serverURL?: string;
};

/**
 * EC2 Image Builder is a fully managed Amazon Web Services service that makes it easier to automate the creation, management, and deployment of customized, secure, and up-to-date "golden" server images that are pre-installed and pre-configured with software and settings to meet specific IT standards.
 *
 * @see {@link https://docs.aws.amazon.com/imagebuilder/} - Amazon Web Services documentation
 */
export class SDK {
  public _defaultClient: AxiosInstance;
  public _securityClient: AxiosInstance;
  public _serverURL: string;
  private _language = "typescript";
  private _sdkVersion = "0.0.1";
  private _genVersion = "internal";
  private _globals: any;

  constructor(props?: SDKProps) {
    this._serverURL = props?.serverURL ?? ServerList[0];

    this._defaultClient =
      props?.defaultClient ?? axios.create({ baseURL: this._serverURL });
    if (props?.security) {
      let security: shared.Security = props.security;
      if (!(props.security instanceof utils.SpeakeasyBase))
        security = new shared.Security(props.security);
      this._securityClient = utils.createSecurityClient(
        this._defaultClient,
        security
      );
    } else {
      this._securityClient = this._defaultClient;
    }
  }

  /**
   * CancelImageCreation cancels the creation of Image. This operation can only be used on images in a non-terminal state.
   */
  cancelImageCreation(
    req: operations.CancelImageCreationRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.CancelImageCreationResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CancelImageCreationRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/CancelImageCreation";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "put",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CancelImageCreationResponse =
        new operations.CancelImageCreationResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.cancelImageCreationResponse = utils.objectToClass(
              httpRes?.data,
              shared.CancelImageCreationResponse
            );
          }
          break;
        case httpRes?.status == 480:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.serviceException = httpRes?.data;
          }
          break;
        case httpRes?.status == 481:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.clientException = httpRes?.data;
          }
          break;
        case httpRes?.status == 482:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.serviceUnavailableException = httpRes?.data;
          }
          break;
        case httpRes?.status == 483:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.invalidRequestException = httpRes?.data;
          }
          break;
        case httpRes?.status == 484:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.idempotentParameterMismatchException = httpRes?.data;
          }
          break;
        case httpRes?.status == 485:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.forbiddenException = httpRes?.data;
          }
          break;
        case httpRes?.status == 486:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.callRateLimitExceededException = httpRes?.data;
          }
          break;
        case httpRes?.status == 487:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.resourceInUseException = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * <p>Creates a new component that can be used to build, validate, test, and assess your image. The component is based on a YAML document that you specify using exactly one of the following methods:</p> <ul> <li> <p>Inline, using the <code>data</code> property in the request body.</p> </li> <li> <p>A URL that points to a YAML document file stored in Amazon S3, using the <code>uri</code> property in the request body.</p> </li> </ul>
   */
  createComponent(
    req: operations.CreateComponentRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.CreateComponentResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CreateComponentRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/CreateComponent";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "put",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CreateComponentResponse =
        new operations.CreateComponentResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.createComponentResponse = utils.objectToClass(
              httpRes?.data,
              shared.CreateComponentResponse
            );
          }
          break;
        case httpRes?.status == 480:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.serviceException = httpRes?.data;
          }
          break;
        case httpRes?.status == 481:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.clientException = httpRes?.data;
          }
          break;
        case httpRes?.status == 482:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.serviceUnavailableException = httpRes?.data;
          }
          break;
        case httpRes?.status == 483:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.invalidRequestException = httpRes?.data;
          }
          break;
        case httpRes?.status == 484:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.idempotentParameterMismatchException = httpRes?.data;
          }
          break;
        case httpRes?.status == 485:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.forbiddenException = httpRes?.data;
          }
          break;
        case httpRes?.status == 486:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.callRateLimitExceededException = httpRes?.data;
          }
          break;
        case httpRes?.status == 487:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.invalidVersionNumberException = httpRes?.data;
          }
          break;
        case httpRes?.status == 488:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.resourceInUseException = httpRes?.data;
          }
          break;
        case httpRes?.status == 489:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.invalidParameterCombinationException = httpRes?.data;
          }
          break;
        case httpRes?.status == 490:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.serviceQuotaExceededException = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * Creates a new container recipe. Container recipes define how images are configured, tested, and assessed.
   */
  createContainerRecipe(
    req: operations.CreateContainerRecipeRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.CreateContainerRecipeResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CreateContainerRecipeRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/CreateContainerRecipe";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "put",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CreateContainerRecipeResponse =
        new operations.CreateContainerRecipeResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.createContainerRecipeResponse = utils.objectToClass(
              httpRes?.data,
              shared.CreateContainerRecipeResponse
            );
          }
          break;
        case httpRes?.status == 480:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.serviceException = httpRes?.data;
          }
          break;
        case httpRes?.status == 481:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.clientException = httpRes?.data;
          }
          break;
        case httpRes?.status == 482:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.serviceUnavailableException = httpRes?.data;
          }
          break;
        case httpRes?.status == 483:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.invalidRequestException = httpRes?.data;
          }
          break;
        case httpRes?.status == 484:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.idempotentParameterMismatchException = httpRes?.data;
          }
          break;
        case httpRes?.status == 485:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.forbiddenException = httpRes?.data;
          }
          break;
        case httpRes?.status == 486:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.callRateLimitExceededException = httpRes?.data;
          }
          break;
        case httpRes?.status == 487:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.invalidVersionNumberException = httpRes?.data;
          }
          break;
        case httpRes?.status == 488:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.resourceInUseException = httpRes?.data;
          }
          break;
        case httpRes?.status == 489:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.resourceAlreadyExistsException = httpRes?.data;
          }
          break;
        case httpRes?.status == 490:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.serviceQuotaExceededException = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * Creates a new distribution configuration. Distribution configurations define and configure the outputs of your pipeline.
   */
  createDistributionConfiguration(
    req: operations.CreateDistributionConfigurationRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.CreateDistributionConfigurationResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CreateDistributionConfigurationRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/CreateDistributionConfiguration";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "put",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CreateDistributionConfigurationResponse =
        new operations.CreateDistributionConfigurationResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.createDistributionConfigurationResponse = utils.objectToClass(
              httpRes?.data,
              shared.CreateDistributionConfigurationResponse
            );
          }
          break;
        case httpRes?.status == 480:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.serviceException = httpRes?.data;
          }
          break;
        case httpRes?.status == 481:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.clientException = httpRes?.data;
          }
          break;
        case httpRes?.status == 482:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.serviceUnavailableException = httpRes?.data;
          }
          break;
        case httpRes?.status == 483:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.invalidRequestException = httpRes?.data;
          }
          break;
        case httpRes?.status == 484:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.idempotentParameterMismatchException = httpRes?.data;
          }
          break;
        case httpRes?.status == 485:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.forbiddenException = httpRes?.data;
          }
          break;
        case httpRes?.status == 486:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.callRateLimitExceededException = httpRes?.data;
          }
          break;
        case httpRes?.status == 487:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.resourceInUseException = httpRes?.data;
          }
          break;
        case httpRes?.status == 488:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.resourceAlreadyExistsException = httpRes?.data;
          }
          break;
        case httpRes?.status == 489:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.invalidParameterCombinationException = httpRes?.data;
          }
          break;
        case httpRes?.status == 490:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.serviceQuotaExceededException = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   *  Creates a new image. This request will create a new image along with all of the configured output resources defined in the distribution configuration. You must specify exactly one recipe for your image, using either a ContainerRecipeArn or an ImageRecipeArn.
   */
  createImage(
    req: operations.CreateImageRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.CreateImageResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CreateImageRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/CreateImage";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "put",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CreateImageResponse =
        new operations.CreateImageResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.createImageResponse = utils.objectToClass(
              httpRes?.data,
              shared.CreateImageResponse
            );
          }
          break;
        case httpRes?.status == 480:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.serviceException = httpRes?.data;
          }
          break;
        case httpRes?.status == 481:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.clientException = httpRes?.data;
          }
          break;
        case httpRes?.status == 482:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.serviceUnavailableException = httpRes?.data;
          }
          break;
        case httpRes?.status == 483:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.invalidRequestException = httpRes?.data;
          }
          break;
        case httpRes?.status == 484:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.idempotentParameterMismatchException = httpRes?.data;
          }
          break;
        case httpRes?.status == 485:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.forbiddenException = httpRes?.data;
          }
          break;
        case httpRes?.status == 486:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.callRateLimitExceededException = httpRes?.data;
          }
          break;
        case httpRes?.status == 487:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.resourceInUseException = httpRes?.data;
          }
          break;
        case httpRes?.status == 488:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.serviceQuotaExceededException = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   *  Creates a new image pipeline. Image pipelines enable you to automate the creation and distribution of images.
   */
  createImagePipeline(
    req: operations.CreateImagePipelineRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.CreateImagePipelineResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CreateImagePipelineRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/CreateImagePipeline";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "put",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CreateImagePipelineResponse =
        new operations.CreateImagePipelineResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.createImagePipelineResponse = utils.objectToClass(
              httpRes?.data,
              shared.CreateImagePipelineResponse
            );
          }
          break;
        case httpRes?.status == 480:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.serviceException = httpRes?.data;
          }
          break;
        case httpRes?.status == 481:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.clientException = httpRes?.data;
          }
          break;
        case httpRes?.status == 482:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.serviceUnavailableException = httpRes?.data;
          }
          break;
        case httpRes?.status == 483:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.invalidRequestException = httpRes?.data;
          }
          break;
        case httpRes?.status == 484:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.idempotentParameterMismatchException = httpRes?.data;
          }
          break;
        case httpRes?.status == 485:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.forbiddenException = httpRes?.data;
          }
          break;
        case httpRes?.status == 486:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.callRateLimitExceededException = httpRes?.data;
          }
          break;
        case httpRes?.status == 487:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.resourceInUseException = httpRes?.data;
          }
          break;
        case httpRes?.status == 488:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.resourceAlreadyExistsException = httpRes?.data;
          }
          break;
        case httpRes?.status == 489:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.serviceQuotaExceededException = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   *  Creates a new image recipe. Image recipes define how images are configured, tested, and assessed.
   */
  createImageRecipe(
    req: operations.CreateImageRecipeRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.CreateImageRecipeResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CreateImageRecipeRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/CreateImageRecipe";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "put",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CreateImageRecipeResponse =
        new operations.CreateImageRecipeResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.createImageRecipeResponse = utils.objectToClass(
              httpRes?.data,
              shared.CreateImageRecipeResponse
            );
          }
          break;
        case httpRes?.status == 480:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.serviceException = httpRes?.data;
          }
          break;
        case httpRes?.status == 481:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.clientException = httpRes?.data;
          }
          break;
        case httpRes?.status == 482:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.serviceUnavailableException = httpRes?.data;
          }
          break;
        case httpRes?.status == 483:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.invalidRequestException = httpRes?.data;
          }
          break;
        case httpRes?.status == 484:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.idempotentParameterMismatchException = httpRes?.data;
          }
          break;
        case httpRes?.status == 485:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.forbiddenException = httpRes?.data;
          }
          break;
        case httpRes?.status == 486:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.callRateLimitExceededException = httpRes?.data;
          }
          break;
        case httpRes?.status == 487:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.invalidVersionNumberException = httpRes?.data;
          }
          break;
        case httpRes?.status == 488:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.resourceInUseException = httpRes?.data;
          }
          break;
        case httpRes?.status == 489:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.resourceAlreadyExistsException = httpRes?.data;
          }
          break;
        case httpRes?.status == 490:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.serviceQuotaExceededException = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   *  Creates a new infrastructure configuration. An infrastructure configuration defines the environment in which your image will be built and tested.
   */
  createInfrastructureConfiguration(
    req: operations.CreateInfrastructureConfigurationRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.CreateInfrastructureConfigurationResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CreateInfrastructureConfigurationRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/CreateInfrastructureConfiguration";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "put",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CreateInfrastructureConfigurationResponse =
        new operations.CreateInfrastructureConfigurationResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.createInfrastructureConfigurationResponse = utils.objectToClass(
              httpRes?.data,
              shared.CreateInfrastructureConfigurationResponse
            );
          }
          break;
        case httpRes?.status == 480:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.serviceException = httpRes?.data;
          }
          break;
        case httpRes?.status == 481:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.clientException = httpRes?.data;
          }
          break;
        case httpRes?.status == 482:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.serviceUnavailableException = httpRes?.data;
          }
          break;
        case httpRes?.status == 483:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.invalidRequestException = httpRes?.data;
          }
          break;
        case httpRes?.status == 484:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.idempotentParameterMismatchException = httpRes?.data;
          }
          break;
        case httpRes?.status == 485:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.forbiddenException = httpRes?.data;
          }
          break;
        case httpRes?.status == 486:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.callRateLimitExceededException = httpRes?.data;
          }
          break;
        case httpRes?.status == 487:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.resourceInUseException = httpRes?.data;
          }
          break;
        case httpRes?.status == 488:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.resourceAlreadyExistsException = httpRes?.data;
          }
          break;
        case httpRes?.status == 489:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.serviceQuotaExceededException = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   *  Deletes a component build version.
   */
  deleteComponent(
    req: operations.DeleteComponentRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.DeleteComponentResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DeleteComponentRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/DeleteComponent#componentBuildVersionArn";

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "delete",
      headers: headers,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DeleteComponentResponse =
        new operations.DeleteComponentResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.deleteComponentResponse = utils.objectToClass(
              httpRes?.data,
              shared.DeleteComponentResponse
            );
          }
          break;
        case httpRes?.status == 480:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.serviceException = httpRes?.data;
          }
          break;
        case httpRes?.status == 481:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.clientException = httpRes?.data;
          }
          break;
        case httpRes?.status == 482:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.serviceUnavailableException = httpRes?.data;
          }
          break;
        case httpRes?.status == 483:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.invalidRequestException = httpRes?.data;
          }
          break;
        case httpRes?.status == 484:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.forbiddenException = httpRes?.data;
          }
          break;
        case httpRes?.status == 485:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.callRateLimitExceededException = httpRes?.data;
          }
          break;
        case httpRes?.status == 486:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.resourceDependencyException = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * Deletes a container recipe.
   */
  deleteContainerRecipe(
    req: operations.DeleteContainerRecipeRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.DeleteContainerRecipeResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DeleteContainerRecipeRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/DeleteContainerRecipe#containerRecipeArn";

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "delete",
      headers: headers,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DeleteContainerRecipeResponse =
        new operations.DeleteContainerRecipeResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.deleteContainerRecipeResponse = utils.objectToClass(
              httpRes?.data,
              shared.DeleteContainerRecipeResponse
            );
          }
          break;
        case httpRes?.status == 480:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.serviceException = httpRes?.data;
          }
          break;
        case httpRes?.status == 481:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.clientException = httpRes?.data;
          }
          break;
        case httpRes?.status == 482:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.serviceUnavailableException = httpRes?.data;
          }
          break;
        case httpRes?.status == 483:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.invalidRequestException = httpRes?.data;
          }
          break;
        case httpRes?.status == 484:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.forbiddenException = httpRes?.data;
          }
          break;
        case httpRes?.status == 485:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.callRateLimitExceededException = httpRes?.data;
          }
          break;
        case httpRes?.status == 486:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.resourceDependencyException = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   *  Deletes a distribution configuration.
   */
  deleteDistributionConfiguration(
    req: operations.DeleteDistributionConfigurationRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.DeleteDistributionConfigurationResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DeleteDistributionConfigurationRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") +
      "/DeleteDistributionConfiguration#distributionConfigurationArn";

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "delete",
      headers: headers,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DeleteDistributionConfigurationResponse =
        new operations.DeleteDistributionConfigurationResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.deleteDistributionConfigurationResponse = utils.objectToClass(
              httpRes?.data,
              shared.DeleteDistributionConfigurationResponse
            );
          }
          break;
        case httpRes?.status == 480:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.serviceException = httpRes?.data;
          }
          break;
        case httpRes?.status == 481:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.clientException = httpRes?.data;
          }
          break;
        case httpRes?.status == 482:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.invalidRequestException = httpRes?.data;
          }
          break;
        case httpRes?.status == 483:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.serviceUnavailableException = httpRes?.data;
          }
          break;
        case httpRes?.status == 484:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.forbiddenException = httpRes?.data;
          }
          break;
        case httpRes?.status == 485:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.callRateLimitExceededException = httpRes?.data;
          }
          break;
        case httpRes?.status == 486:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.resourceDependencyException = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * <p>Deletes an Image Builder image resource. This does not delete any EC2 AMIs or ECR container images that are created during the image build process. You must clean those up separately, using the appropriate Amazon EC2 or Amazon ECR console actions, or API or CLI commands.</p> <ul> <li> <p>To deregister an EC2 Linux AMI, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/deregister-ami.html">Deregister your Linux AMI</a> in the <i> <i>Amazon EC2 User Guide</i> </i>.</p> </li> <li> <p>To deregister an EC2 Windows AMI, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/WindowsGuide/deregister-ami.html">Deregister your Windows AMI</a> in the <i> <i>Amazon EC2 Windows Guide</i> </i>.</p> </li> <li> <p>To delete a container image from Amazon ECR, see <a href="https://docs.aws.amazon.com/AmazonECR/latest/userguide/delete_image.html">Deleting an image</a> in the <i>Amazon ECR User Guide</i>.</p> </li> </ul>
   */
  deleteImage(
    req: operations.DeleteImageRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.DeleteImageResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DeleteImageRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/DeleteImage#imageBuildVersionArn";

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "delete",
      headers: headers,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DeleteImageResponse =
        new operations.DeleteImageResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.deleteImageResponse = utils.objectToClass(
              httpRes?.data,
              shared.DeleteImageResponse
            );
          }
          break;
        case httpRes?.status == 480:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.serviceException = httpRes?.data;
          }
          break;
        case httpRes?.status == 481:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.clientException = httpRes?.data;
          }
          break;
        case httpRes?.status == 482:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.invalidRequestException = httpRes?.data;
          }
          break;
        case httpRes?.status == 483:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.serviceUnavailableException = httpRes?.data;
          }
          break;
        case httpRes?.status == 484:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.forbiddenException = httpRes?.data;
          }
          break;
        case httpRes?.status == 485:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.callRateLimitExceededException = httpRes?.data;
          }
          break;
        case httpRes?.status == 486:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.resourceDependencyException = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   *  Deletes an image pipeline.
   */
  deleteImagePipeline(
    req: operations.DeleteImagePipelineRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.DeleteImagePipelineResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DeleteImagePipelineRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/DeleteImagePipeline#imagePipelineArn";

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "delete",
      headers: headers,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DeleteImagePipelineResponse =
        new operations.DeleteImagePipelineResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.deleteImagePipelineResponse = utils.objectToClass(
              httpRes?.data,
              shared.DeleteImagePipelineResponse
            );
          }
          break;
        case httpRes?.status == 480:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.serviceException = httpRes?.data;
          }
          break;
        case httpRes?.status == 481:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.clientException = httpRes?.data;
          }
          break;
        case httpRes?.status == 482:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.serviceUnavailableException = httpRes?.data;
          }
          break;
        case httpRes?.status == 483:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.invalidRequestException = httpRes?.data;
          }
          break;
        case httpRes?.status == 484:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.forbiddenException = httpRes?.data;
          }
          break;
        case httpRes?.status == 485:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.callRateLimitExceededException = httpRes?.data;
          }
          break;
        case httpRes?.status == 486:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.resourceDependencyException = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   *  Deletes an image recipe.
   */
  deleteImageRecipe(
    req: operations.DeleteImageRecipeRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.DeleteImageRecipeResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DeleteImageRecipeRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/DeleteImageRecipe#imageRecipeArn";

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "delete",
      headers: headers,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DeleteImageRecipeResponse =
        new operations.DeleteImageRecipeResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.deleteImageRecipeResponse = utils.objectToClass(
              httpRes?.data,
              shared.DeleteImageRecipeResponse
            );
          }
          break;
        case httpRes?.status == 480:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.serviceException = httpRes?.data;
          }
          break;
        case httpRes?.status == 481:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.clientException = httpRes?.data;
          }
          break;
        case httpRes?.status == 482:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.serviceUnavailableException = httpRes?.data;
          }
          break;
        case httpRes?.status == 483:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.invalidRequestException = httpRes?.data;
          }
          break;
        case httpRes?.status == 484:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.forbiddenException = httpRes?.data;
          }
          break;
        case httpRes?.status == 485:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.callRateLimitExceededException = httpRes?.data;
          }
          break;
        case httpRes?.status == 486:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.resourceDependencyException = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   *  Deletes an infrastructure configuration.
   */
  deleteInfrastructureConfiguration(
    req: operations.DeleteInfrastructureConfigurationRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.DeleteInfrastructureConfigurationResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DeleteInfrastructureConfigurationRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") +
      "/DeleteInfrastructureConfiguration#infrastructureConfigurationArn";

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "delete",
      headers: headers,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DeleteInfrastructureConfigurationResponse =
        new operations.DeleteInfrastructureConfigurationResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.deleteInfrastructureConfigurationResponse = utils.objectToClass(
              httpRes?.data,
              shared.DeleteInfrastructureConfigurationResponse
            );
          }
          break;
        case httpRes?.status == 480:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.serviceException = httpRes?.data;
          }
          break;
        case httpRes?.status == 481:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.clientException = httpRes?.data;
          }
          break;
        case httpRes?.status == 482:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.serviceUnavailableException = httpRes?.data;
          }
          break;
        case httpRes?.status == 483:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.invalidRequestException = httpRes?.data;
          }
          break;
        case httpRes?.status == 484:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.forbiddenException = httpRes?.data;
          }
          break;
        case httpRes?.status == 485:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.callRateLimitExceededException = httpRes?.data;
          }
          break;
        case httpRes?.status == 486:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.resourceDependencyException = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   *  Gets a component object.
   */
  getComponent(
    req: operations.GetComponentRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetComponentResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetComponentRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/GetComponent#componentBuildVersionArn";

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      headers: headers,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetComponentResponse =
        new operations.GetComponentResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getComponentResponse = utils.objectToClass(
              httpRes?.data,
              shared.GetComponentResponse
            );
          }
          break;
        case httpRes?.status == 480:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.serviceException = httpRes?.data;
          }
          break;
        case httpRes?.status == 481:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.clientException = httpRes?.data;
          }
          break;
        case httpRes?.status == 482:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.serviceUnavailableException = httpRes?.data;
          }
          break;
        case httpRes?.status == 483:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.invalidRequestException = httpRes?.data;
          }
          break;
        case httpRes?.status == 484:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.forbiddenException = httpRes?.data;
          }
          break;
        case httpRes?.status == 485:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.callRateLimitExceededException = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   *  Gets a component policy.
   */
  getComponentPolicy(
    req: operations.GetComponentPolicyRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetComponentPolicyResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetComponentPolicyRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/GetComponentPolicy#componentArn";

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      headers: headers,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetComponentPolicyResponse =
        new operations.GetComponentPolicyResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getComponentPolicyResponse = utils.objectToClass(
              httpRes?.data,
              shared.GetComponentPolicyResponse
            );
          }
          break;
        case httpRes?.status == 480:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.serviceException = httpRes?.data;
          }
          break;
        case httpRes?.status == 481:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.serviceUnavailableException = httpRes?.data;
          }
          break;
        case httpRes?.status == 482:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.resourceNotFoundException = httpRes?.data;
          }
          break;
        case httpRes?.status == 483:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.invalidRequestException = httpRes?.data;
          }
          break;
        case httpRes?.status == 484:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.forbiddenException = httpRes?.data;
          }
          break;
        case httpRes?.status == 485:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.callRateLimitExceededException = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * Retrieves a container recipe.
   */
  getContainerRecipe(
    req: operations.GetContainerRecipeRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetContainerRecipeResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetContainerRecipeRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/GetContainerRecipe#containerRecipeArn";

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      headers: headers,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetContainerRecipeResponse =
        new operations.GetContainerRecipeResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getContainerRecipeResponse = utils.objectToClass(
              httpRes?.data,
              shared.GetContainerRecipeResponse
            );
          }
          break;
        case httpRes?.status == 480:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.serviceException = httpRes?.data;
          }
          break;
        case httpRes?.status == 481:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.clientException = httpRes?.data;
          }
          break;
        case httpRes?.status == 482:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.serviceUnavailableException = httpRes?.data;
          }
          break;
        case httpRes?.status == 483:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.invalidRequestException = httpRes?.data;
          }
          break;
        case httpRes?.status == 484:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.forbiddenException = httpRes?.data;
          }
          break;
        case httpRes?.status == 485:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.callRateLimitExceededException = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * Retrieves the policy for a container recipe.
   */
  getContainerRecipePolicy(
    req: operations.GetContainerRecipePolicyRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetContainerRecipePolicyResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetContainerRecipePolicyRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") +
      "/GetContainerRecipePolicy#containerRecipeArn";

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      headers: headers,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetContainerRecipePolicyResponse =
        new operations.GetContainerRecipePolicyResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getContainerRecipePolicyResponse = utils.objectToClass(
              httpRes?.data,
              shared.GetContainerRecipePolicyResponse
            );
          }
          break;
        case httpRes?.status == 480:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.serviceException = httpRes?.data;
          }
          break;
        case httpRes?.status == 481:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.serviceUnavailableException = httpRes?.data;
          }
          break;
        case httpRes?.status == 482:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.invalidRequestException = httpRes?.data;
          }
          break;
        case httpRes?.status == 483:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.resourceNotFoundException = httpRes?.data;
          }
          break;
        case httpRes?.status == 484:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.forbiddenException = httpRes?.data;
          }
          break;
        case httpRes?.status == 485:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.callRateLimitExceededException = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   *  Gets a distribution configuration.
   */
  getDistributionConfiguration(
    req: operations.GetDistributionConfigurationRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetDistributionConfigurationResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetDistributionConfigurationRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") +
      "/GetDistributionConfiguration#distributionConfigurationArn";

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      headers: headers,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetDistributionConfigurationResponse =
        new operations.GetDistributionConfigurationResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getDistributionConfigurationResponse = utils.objectToClass(
              httpRes?.data,
              shared.GetDistributionConfigurationResponse
            );
          }
          break;
        case httpRes?.status == 480:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.serviceException = httpRes?.data;
          }
          break;
        case httpRes?.status == 481:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.clientException = httpRes?.data;
          }
          break;
        case httpRes?.status == 482:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.serviceUnavailableException = httpRes?.data;
          }
          break;
        case httpRes?.status == 483:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.invalidRequestException = httpRes?.data;
          }
          break;
        case httpRes?.status == 484:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.forbiddenException = httpRes?.data;
          }
          break;
        case httpRes?.status == 485:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.callRateLimitExceededException = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   *  Gets an image.
   */
  getImage(
    req: operations.GetImageRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetImageResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetImageRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/GetImage#imageBuildVersionArn";

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      headers: headers,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetImageResponse = new operations.GetImageResponse({
        statusCode: httpRes.status,
        contentType: contentType,
        rawResponse: httpRes,
      });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getImageResponse = utils.objectToClass(
              httpRes?.data,
              shared.GetImageResponse
            );
          }
          break;
        case httpRes?.status == 480:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.serviceException = httpRes?.data;
          }
          break;
        case httpRes?.status == 481:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.clientException = httpRes?.data;
          }
          break;
        case httpRes?.status == 482:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.serviceUnavailableException = httpRes?.data;
          }
          break;
        case httpRes?.status == 483:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.invalidRequestException = httpRes?.data;
          }
          break;
        case httpRes?.status == 484:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.forbiddenException = httpRes?.data;
          }
          break;
        case httpRes?.status == 485:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.callRateLimitExceededException = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   *  Gets an image pipeline.
   */
  getImagePipeline(
    req: operations.GetImagePipelineRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetImagePipelineResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetImagePipelineRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/GetImagePipeline#imagePipelineArn";

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      headers: headers,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetImagePipelineResponse =
        new operations.GetImagePipelineResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getImagePipelineResponse = utils.objectToClass(
              httpRes?.data,
              shared.GetImagePipelineResponse
            );
          }
          break;
        case httpRes?.status == 480:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.serviceException = httpRes?.data;
          }
          break;
        case httpRes?.status == 481:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.clientException = httpRes?.data;
          }
          break;
        case httpRes?.status == 482:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.serviceUnavailableException = httpRes?.data;
          }
          break;
        case httpRes?.status == 483:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.invalidRequestException = httpRes?.data;
          }
          break;
        case httpRes?.status == 484:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.forbiddenException = httpRes?.data;
          }
          break;
        case httpRes?.status == 485:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.callRateLimitExceededException = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   *  Gets an image policy.
   */
  getImagePolicy(
    req: operations.GetImagePolicyRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetImagePolicyResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetImagePolicyRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/GetImagePolicy#imageArn";

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      headers: headers,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetImagePolicyResponse =
        new operations.GetImagePolicyResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getImagePolicyResponse = utils.objectToClass(
              httpRes?.data,
              shared.GetImagePolicyResponse
            );
          }
          break;
        case httpRes?.status == 480:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.serviceException = httpRes?.data;
          }
          break;
        case httpRes?.status == 481:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.serviceUnavailableException = httpRes?.data;
          }
          break;
        case httpRes?.status == 482:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.resourceNotFoundException = httpRes?.data;
          }
          break;
        case httpRes?.status == 483:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.invalidRequestException = httpRes?.data;
          }
          break;
        case httpRes?.status == 484:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.forbiddenException = httpRes?.data;
          }
          break;
        case httpRes?.status == 485:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.callRateLimitExceededException = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   *  Gets an image recipe.
   */
  getImageRecipe(
    req: operations.GetImageRecipeRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetImageRecipeResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetImageRecipeRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/GetImageRecipe#imageRecipeArn";

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      headers: headers,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetImageRecipeResponse =
        new operations.GetImageRecipeResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getImageRecipeResponse = utils.objectToClass(
              httpRes?.data,
              shared.GetImageRecipeResponse
            );
          }
          break;
        case httpRes?.status == 480:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.serviceException = httpRes?.data;
          }
          break;
        case httpRes?.status == 481:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.clientException = httpRes?.data;
          }
          break;
        case httpRes?.status == 482:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.serviceUnavailableException = httpRes?.data;
          }
          break;
        case httpRes?.status == 483:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.invalidRequestException = httpRes?.data;
          }
          break;
        case httpRes?.status == 484:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.forbiddenException = httpRes?.data;
          }
          break;
        case httpRes?.status == 485:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.callRateLimitExceededException = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   *  Gets an image recipe policy.
   */
  getImageRecipePolicy(
    req: operations.GetImageRecipePolicyRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetImageRecipePolicyResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetImageRecipePolicyRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/GetImageRecipePolicy#imageRecipeArn";

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      headers: headers,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetImageRecipePolicyResponse =
        new operations.GetImageRecipePolicyResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getImageRecipePolicyResponse = utils.objectToClass(
              httpRes?.data,
              shared.GetImageRecipePolicyResponse
            );
          }
          break;
        case httpRes?.status == 480:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.serviceException = httpRes?.data;
          }
          break;
        case httpRes?.status == 481:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.serviceUnavailableException = httpRes?.data;
          }
          break;
        case httpRes?.status == 482:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.invalidRequestException = httpRes?.data;
          }
          break;
        case httpRes?.status == 483:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.resourceNotFoundException = httpRes?.data;
          }
          break;
        case httpRes?.status == 484:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.forbiddenException = httpRes?.data;
          }
          break;
        case httpRes?.status == 485:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.callRateLimitExceededException = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   *  Gets an infrastructure configuration.
   */
  getInfrastructureConfiguration(
    req: operations.GetInfrastructureConfigurationRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetInfrastructureConfigurationResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetInfrastructureConfigurationRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") +
      "/GetInfrastructureConfiguration#infrastructureConfigurationArn";

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      headers: headers,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetInfrastructureConfigurationResponse =
        new operations.GetInfrastructureConfigurationResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getInfrastructureConfigurationResponse = utils.objectToClass(
              httpRes?.data,
              shared.GetInfrastructureConfigurationResponse
            );
          }
          break;
        case httpRes?.status == 480:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.serviceException = httpRes?.data;
          }
          break;
        case httpRes?.status == 481:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.clientException = httpRes?.data;
          }
          break;
        case httpRes?.status == 482:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.serviceUnavailableException = httpRes?.data;
          }
          break;
        case httpRes?.status == 483:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.invalidRequestException = httpRes?.data;
          }
          break;
        case httpRes?.status == 484:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.forbiddenException = httpRes?.data;
          }
          break;
        case httpRes?.status == 485:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.callRateLimitExceededException = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * Imports a component and transforms its data into a component document.
   */
  importComponent(
    req: operations.ImportComponentRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.ImportComponentResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ImportComponentRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/ImportComponent";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "put",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ImportComponentResponse =
        new operations.ImportComponentResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.importComponentResponse = utils.objectToClass(
              httpRes?.data,
              shared.ImportComponentResponse
            );
          }
          break;
        case httpRes?.status == 480:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.serviceException = httpRes?.data;
          }
          break;
        case httpRes?.status == 481:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.clientException = httpRes?.data;
          }
          break;
        case httpRes?.status == 482:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.serviceUnavailableException = httpRes?.data;
          }
          break;
        case httpRes?.status == 483:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.invalidRequestException = httpRes?.data;
          }
          break;
        case httpRes?.status == 484:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.idempotentParameterMismatchException = httpRes?.data;
          }
          break;
        case httpRes?.status == 485:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.forbiddenException = httpRes?.data;
          }
          break;
        case httpRes?.status == 486:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.callRateLimitExceededException = httpRes?.data;
          }
          break;
        case httpRes?.status == 487:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.invalidVersionNumberException = httpRes?.data;
          }
          break;
        case httpRes?.status == 488:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.resourceInUseException = httpRes?.data;
          }
          break;
        case httpRes?.status == 489:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.invalidParameterCombinationException = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * <p>When you export your virtual machine (VM) from its virtualization environment, that process creates a set of one or more disk container files that act as snapshots of your VMs environment, settings, and data. The Amazon EC2 API <a href="https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_ImportImage.html">ImportImage</a> action uses those files to import your VM and create an AMI. To import using the CLI command, see <a href="https://docs.aws.amazon.com/cli/latest/reference/ec2/import-image.html">import-image</a> </p> <p>You can reference the task ID from the VM import to pull in the AMI that the import created as the base image for your Image Builder recipe.</p>
   */
  importVmImage(
    req: operations.ImportVmImageRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.ImportVmImageResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ImportVmImageRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/ImportVmImage";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "put",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ImportVmImageResponse =
        new operations.ImportVmImageResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.importVmImageResponse = utils.objectToClass(
              httpRes?.data,
              shared.ImportVmImageResponse
            );
          }
          break;
        case httpRes?.status == 480:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.serviceException = httpRes?.data;
          }
          break;
        case httpRes?.status == 481:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.clientException = httpRes?.data;
          }
          break;
        case httpRes?.status == 482:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.serviceUnavailableException = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * <p> Returns the list of component build versions for the specified semantic version.</p> <note> <p>The semantic version has four nodes: &lt;major&gt;.&lt;minor&gt;.&lt;patch&gt;/&lt;build&gt;. You can assign values for the first three, and can filter on all of them.</p> <p> <b>Filtering:</b> With semantic versioning, you have the flexibility to use wildcards (x) to specify the most recent versions or nodes when selecting the base image or components for your recipe. When you use a wildcard in any node, all nodes to the right of the first wildcard must also be wildcards.</p> </note>
   */
  listComponentBuildVersions(
    req: operations.ListComponentBuildVersionsRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.ListComponentBuildVersionsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ListComponentBuildVersionsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/ListComponentBuildVersions";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };
    const queryParams: string = utils.serializeQueryParams(req);
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url + queryParams,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ListComponentBuildVersionsResponse =
        new operations.ListComponentBuildVersionsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listComponentBuildVersionsResponse = utils.objectToClass(
              httpRes?.data,
              shared.ListComponentBuildVersionsResponse
            );
          }
          break;
        case httpRes?.status == 480:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.serviceException = httpRes?.data;
          }
          break;
        case httpRes?.status == 481:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.clientException = httpRes?.data;
          }
          break;
        case httpRes?.status == 482:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.serviceUnavailableException = httpRes?.data;
          }
          break;
        case httpRes?.status == 483:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.invalidRequestException = httpRes?.data;
          }
          break;
        case httpRes?.status == 484:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.invalidPaginationTokenException = httpRes?.data;
          }
          break;
        case httpRes?.status == 485:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.forbiddenException = httpRes?.data;
          }
          break;
        case httpRes?.status == 486:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.callRateLimitExceededException = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * <p>Returns the list of components that can be filtered by name, or by using the listed <code>filters</code> to streamline results. Newly created components can take up to two minutes to appear in the ListComponents API Results.</p> <note> <p>The semantic version has four nodes: &lt;major&gt;.&lt;minor&gt;.&lt;patch&gt;/&lt;build&gt;. You can assign values for the first three, and can filter on all of them.</p> <p> <b>Filtering:</b> With semantic versioning, you have the flexibility to use wildcards (x) to specify the most recent versions or nodes when selecting the base image or components for your recipe. When you use a wildcard in any node, all nodes to the right of the first wildcard must also be wildcards.</p> </note>
   */
  listComponents(
    req: operations.ListComponentsRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.ListComponentsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ListComponentsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/ListComponents";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };
    const queryParams: string = utils.serializeQueryParams(req);
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url + queryParams,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ListComponentsResponse =
        new operations.ListComponentsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listComponentsResponse = utils.objectToClass(
              httpRes?.data,
              shared.ListComponentsResponse
            );
          }
          break;
        case httpRes?.status == 480:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.serviceException = httpRes?.data;
          }
          break;
        case httpRes?.status == 481:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.clientException = httpRes?.data;
          }
          break;
        case httpRes?.status == 482:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.serviceUnavailableException = httpRes?.data;
          }
          break;
        case httpRes?.status == 483:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.invalidRequestException = httpRes?.data;
          }
          break;
        case httpRes?.status == 484:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.invalidPaginationTokenException = httpRes?.data;
          }
          break;
        case httpRes?.status == 485:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.forbiddenException = httpRes?.data;
          }
          break;
        case httpRes?.status == 486:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.callRateLimitExceededException = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * Returns a list of container recipes.
   */
  listContainerRecipes(
    req: operations.ListContainerRecipesRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.ListContainerRecipesResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ListContainerRecipesRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/ListContainerRecipes";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };
    const queryParams: string = utils.serializeQueryParams(req);
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url + queryParams,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ListContainerRecipesResponse =
        new operations.ListContainerRecipesResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listContainerRecipesResponse = utils.objectToClass(
              httpRes?.data,
              shared.ListContainerRecipesResponse
            );
          }
          break;
        case httpRes?.status == 480:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.serviceException = httpRes?.data;
          }
          break;
        case httpRes?.status == 481:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.clientException = httpRes?.data;
          }
          break;
        case httpRes?.status == 482:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.serviceUnavailableException = httpRes?.data;
          }
          break;
        case httpRes?.status == 483:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.invalidRequestException = httpRes?.data;
          }
          break;
        case httpRes?.status == 484:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.invalidPaginationTokenException = httpRes?.data;
          }
          break;
        case httpRes?.status == 485:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.forbiddenException = httpRes?.data;
          }
          break;
        case httpRes?.status == 486:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.callRateLimitExceededException = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * Returns a list of distribution configurations.
   */
  listDistributionConfigurations(
    req: operations.ListDistributionConfigurationsRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.ListDistributionConfigurationsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ListDistributionConfigurationsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/ListDistributionConfigurations";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };
    const queryParams: string = utils.serializeQueryParams(req);
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url + queryParams,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ListDistributionConfigurationsResponse =
        new operations.ListDistributionConfigurationsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listDistributionConfigurationsResponse = utils.objectToClass(
              httpRes?.data,
              shared.ListDistributionConfigurationsResponse
            );
          }
          break;
        case httpRes?.status == 480:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.serviceException = httpRes?.data;
          }
          break;
        case httpRes?.status == 481:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.clientException = httpRes?.data;
          }
          break;
        case httpRes?.status == 482:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.serviceUnavailableException = httpRes?.data;
          }
          break;
        case httpRes?.status == 483:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.invalidRequestException = httpRes?.data;
          }
          break;
        case httpRes?.status == 484:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.invalidPaginationTokenException = httpRes?.data;
          }
          break;
        case httpRes?.status == 485:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.forbiddenException = httpRes?.data;
          }
          break;
        case httpRes?.status == 486:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.callRateLimitExceededException = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   *  Returns a list of image build versions.
   */
  listImageBuildVersions(
    req: operations.ListImageBuildVersionsRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.ListImageBuildVersionsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ListImageBuildVersionsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/ListImageBuildVersions";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };
    const queryParams: string = utils.serializeQueryParams(req);
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url + queryParams,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ListImageBuildVersionsResponse =
        new operations.ListImageBuildVersionsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listImageBuildVersionsResponse = utils.objectToClass(
              httpRes?.data,
              shared.ListImageBuildVersionsResponse
            );
          }
          break;
        case httpRes?.status == 480:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.serviceException = httpRes?.data;
          }
          break;
        case httpRes?.status == 481:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.clientException = httpRes?.data;
          }
          break;
        case httpRes?.status == 482:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.serviceUnavailableException = httpRes?.data;
          }
          break;
        case httpRes?.status == 483:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.invalidRequestException = httpRes?.data;
          }
          break;
        case httpRes?.status == 484:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.invalidPaginationTokenException = httpRes?.data;
          }
          break;
        case httpRes?.status == 485:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.forbiddenException = httpRes?.data;
          }
          break;
        case httpRes?.status == 486:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.callRateLimitExceededException = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * List the Packages that are associated with an Image Build Version, as determined by Amazon Web Services Systems Manager Inventory at build time.
   */
  listImagePackages(
    req: operations.ListImagePackagesRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.ListImagePackagesResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ListImagePackagesRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/ListImagePackages";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };
    const queryParams: string = utils.serializeQueryParams(req);
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url + queryParams,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ListImagePackagesResponse =
        new operations.ListImagePackagesResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listImagePackagesResponse = utils.objectToClass(
              httpRes?.data,
              shared.ListImagePackagesResponse
            );
          }
          break;
        case httpRes?.status == 480:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.serviceException = httpRes?.data;
          }
          break;
        case httpRes?.status == 481:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.clientException = httpRes?.data;
          }
          break;
        case httpRes?.status == 482:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.serviceUnavailableException = httpRes?.data;
          }
          break;
        case httpRes?.status == 483:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.invalidRequestException = httpRes?.data;
          }
          break;
        case httpRes?.status == 484:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.invalidPaginationTokenException = httpRes?.data;
          }
          break;
        case httpRes?.status == 485:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.resourceNotFoundException = httpRes?.data;
          }
          break;
        case httpRes?.status == 486:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.forbiddenException = httpRes?.data;
          }
          break;
        case httpRes?.status == 487:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.callRateLimitExceededException = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * Returns a list of images created by the specified pipeline.
   */
  listImagePipelineImages(
    req: operations.ListImagePipelineImagesRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.ListImagePipelineImagesResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ListImagePipelineImagesRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/ListImagePipelineImages";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };
    const queryParams: string = utils.serializeQueryParams(req);
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url + queryParams,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ListImagePipelineImagesResponse =
        new operations.ListImagePipelineImagesResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listImagePipelineImagesResponse = utils.objectToClass(
              httpRes?.data,
              shared.ListImagePipelineImagesResponse
            );
          }
          break;
        case httpRes?.status == 480:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.serviceException = httpRes?.data;
          }
          break;
        case httpRes?.status == 481:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.clientException = httpRes?.data;
          }
          break;
        case httpRes?.status == 482:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.serviceUnavailableException = httpRes?.data;
          }
          break;
        case httpRes?.status == 483:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.invalidRequestException = httpRes?.data;
          }
          break;
        case httpRes?.status == 484:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.invalidPaginationTokenException = httpRes?.data;
          }
          break;
        case httpRes?.status == 485:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.resourceNotFoundException = httpRes?.data;
          }
          break;
        case httpRes?.status == 486:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.forbiddenException = httpRes?.data;
          }
          break;
        case httpRes?.status == 487:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.callRateLimitExceededException = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * Returns a list of image pipelines.
   */
  listImagePipelines(
    req: operations.ListImagePipelinesRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.ListImagePipelinesResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ListImagePipelinesRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/ListImagePipelines";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };
    const queryParams: string = utils.serializeQueryParams(req);
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url + queryParams,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ListImagePipelinesResponse =
        new operations.ListImagePipelinesResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listImagePipelinesResponse = utils.objectToClass(
              httpRes?.data,
              shared.ListImagePipelinesResponse
            );
          }
          break;
        case httpRes?.status == 480:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.serviceException = httpRes?.data;
          }
          break;
        case httpRes?.status == 481:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.clientException = httpRes?.data;
          }
          break;
        case httpRes?.status == 482:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.serviceUnavailableException = httpRes?.data;
          }
          break;
        case httpRes?.status == 483:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.invalidRequestException = httpRes?.data;
          }
          break;
        case httpRes?.status == 484:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.invalidPaginationTokenException = httpRes?.data;
          }
          break;
        case httpRes?.status == 485:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.forbiddenException = httpRes?.data;
          }
          break;
        case httpRes?.status == 486:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.callRateLimitExceededException = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   *  Returns a list of image recipes.
   */
  listImageRecipes(
    req: operations.ListImageRecipesRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.ListImageRecipesResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ListImageRecipesRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/ListImageRecipes";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };
    const queryParams: string = utils.serializeQueryParams(req);
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url + queryParams,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ListImageRecipesResponse =
        new operations.ListImageRecipesResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listImageRecipesResponse = utils.objectToClass(
              httpRes?.data,
              shared.ListImageRecipesResponse
            );
          }
          break;
        case httpRes?.status == 480:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.serviceException = httpRes?.data;
          }
          break;
        case httpRes?.status == 481:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.clientException = httpRes?.data;
          }
          break;
        case httpRes?.status == 482:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.serviceUnavailableException = httpRes?.data;
          }
          break;
        case httpRes?.status == 483:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.invalidRequestException = httpRes?.data;
          }
          break;
        case httpRes?.status == 484:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.invalidPaginationTokenException = httpRes?.data;
          }
          break;
        case httpRes?.status == 485:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.forbiddenException = httpRes?.data;
          }
          break;
        case httpRes?.status == 486:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.callRateLimitExceededException = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * Returns the list of images that you have access to. Newly created images can take up to two minutes to appear in the ListImages API Results.
   */
  listImages(
    req: operations.ListImagesRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.ListImagesResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ListImagesRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/ListImages";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };
    const queryParams: string = utils.serializeQueryParams(req);
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url + queryParams,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ListImagesResponse =
        new operations.ListImagesResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listImagesResponse = utils.objectToClass(
              httpRes?.data,
              shared.ListImagesResponse
            );
          }
          break;
        case httpRes?.status == 480:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.serviceException = httpRes?.data;
          }
          break;
        case httpRes?.status == 481:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.clientException = httpRes?.data;
          }
          break;
        case httpRes?.status == 482:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.serviceUnavailableException = httpRes?.data;
          }
          break;
        case httpRes?.status == 483:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.invalidRequestException = httpRes?.data;
          }
          break;
        case httpRes?.status == 484:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.invalidPaginationTokenException = httpRes?.data;
          }
          break;
        case httpRes?.status == 485:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.forbiddenException = httpRes?.data;
          }
          break;
        case httpRes?.status == 486:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.callRateLimitExceededException = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   *  Returns a list of infrastructure configurations.
   */
  listInfrastructureConfigurations(
    req: operations.ListInfrastructureConfigurationsRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.ListInfrastructureConfigurationsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ListInfrastructureConfigurationsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/ListInfrastructureConfigurations";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };
    const queryParams: string = utils.serializeQueryParams(req);
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url + queryParams,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ListInfrastructureConfigurationsResponse =
        new operations.ListInfrastructureConfigurationsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listInfrastructureConfigurationsResponse = utils.objectToClass(
              httpRes?.data,
              shared.ListInfrastructureConfigurationsResponse
            );
          }
          break;
        case httpRes?.status == 480:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.serviceException = httpRes?.data;
          }
          break;
        case httpRes?.status == 481:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.clientException = httpRes?.data;
          }
          break;
        case httpRes?.status == 482:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.serviceUnavailableException = httpRes?.data;
          }
          break;
        case httpRes?.status == 483:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.invalidRequestException = httpRes?.data;
          }
          break;
        case httpRes?.status == 484:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.invalidPaginationTokenException = httpRes?.data;
          }
          break;
        case httpRes?.status == 485:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.forbiddenException = httpRes?.data;
          }
          break;
        case httpRes?.status == 486:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.callRateLimitExceededException = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   *  Returns the list of tags for the specified resource.
   */
  listTagsForResource(
    req: operations.ListTagsForResourceRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.ListTagsForResourceResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ListTagsForResourceRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(baseURL, "/tags/{resourceArn}", req);

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };

    const r = client.request({
      url: url,
      method: "get",
      headers: headers,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ListTagsForResourceResponse =
        new operations.ListTagsForResourceResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listTagsForResourceResponse = utils.objectToClass(
              httpRes?.data,
              shared.ListTagsForResourceResponse
            );
          }
          break;
        case httpRes?.status == 480:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.serviceException = httpRes?.data;
          }
          break;
        case httpRes?.status == 481:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.invalidParameterException = httpRes?.data;
          }
          break;
        case httpRes?.status == 482:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.resourceNotFoundException = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   *  Applies a policy to a component. We recommend that you call the RAM API <a href="https://docs.aws.amazon.com/ram/latest/APIReference/API_CreateResourceShare.html">CreateResourceShare</a> to share resources. If you call the Image Builder API <code>PutComponentPolicy</code>, you must also call the RAM API <a href="https://docs.aws.amazon.com/ram/latest/APIReference/API_PromoteResourceShareCreatedFromPolicy.html">PromoteResourceShareCreatedFromPolicy</a> in order for the resource to be visible to all principals with whom the resource is shared.
   */
  putComponentPolicy(
    req: operations.PutComponentPolicyRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.PutComponentPolicyResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PutComponentPolicyRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/PutComponentPolicy";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "put",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PutComponentPolicyResponse =
        new operations.PutComponentPolicyResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.putComponentPolicyResponse = utils.objectToClass(
              httpRes?.data,
              shared.PutComponentPolicyResponse
            );
          }
          break;
        case httpRes?.status == 480:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.serviceException = httpRes?.data;
          }
          break;
        case httpRes?.status == 481:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.clientException = httpRes?.data;
          }
          break;
        case httpRes?.status == 482:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.serviceUnavailableException = httpRes?.data;
          }
          break;
        case httpRes?.status == 483:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.invalidRequestException = httpRes?.data;
          }
          break;
        case httpRes?.status == 484:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.invalidParameterValueException = httpRes?.data;
          }
          break;
        case httpRes?.status == 485:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.resourceNotFoundException = httpRes?.data;
          }
          break;
        case httpRes?.status == 486:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.forbiddenException = httpRes?.data;
          }
          break;
        case httpRes?.status == 487:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.callRateLimitExceededException = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * Applies a policy to a container image. We recommend that you call the RAM API CreateResourceShare (https://docs.aws.amazon.com//ram/latest/APIReference/API_CreateResourceShare.html) to share resources. If you call the Image Builder API <code>PutContainerImagePolicy</code>, you must also call the RAM API PromoteResourceShareCreatedFromPolicy (https://docs.aws.amazon.com//ram/latest/APIReference/API_PromoteResourceShareCreatedFromPolicy.html) in order for the resource to be visible to all principals with whom the resource is shared.
   */
  putContainerRecipePolicy(
    req: operations.PutContainerRecipePolicyRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.PutContainerRecipePolicyResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PutContainerRecipePolicyRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/PutContainerRecipePolicy";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "put",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PutContainerRecipePolicyResponse =
        new operations.PutContainerRecipePolicyResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.putContainerRecipePolicyResponse = utils.objectToClass(
              httpRes?.data,
              shared.PutContainerRecipePolicyResponse
            );
          }
          break;
        case httpRes?.status == 480:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.serviceException = httpRes?.data;
          }
          break;
        case httpRes?.status == 481:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.clientException = httpRes?.data;
          }
          break;
        case httpRes?.status == 482:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.serviceUnavailableException = httpRes?.data;
          }
          break;
        case httpRes?.status == 483:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.invalidRequestException = httpRes?.data;
          }
          break;
        case httpRes?.status == 484:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.invalidParameterValueException = httpRes?.data;
          }
          break;
        case httpRes?.status == 485:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.resourceNotFoundException = httpRes?.data;
          }
          break;
        case httpRes?.status == 486:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.forbiddenException = httpRes?.data;
          }
          break;
        case httpRes?.status == 487:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.callRateLimitExceededException = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * Applies a policy to an image. We recommend that you call the RAM API <a href="https://docs.aws.amazon.com/ram/latest/APIReference/API_CreateResourceShare.html">CreateResourceShare</a> to share resources. If you call the Image Builder API <code>PutImagePolicy</code>, you must also call the RAM API <a href="https://docs.aws.amazon.com/ram/latest/APIReference/API_PromoteResourceShareCreatedFromPolicy.html">PromoteResourceShareCreatedFromPolicy</a> in order for the resource to be visible to all principals with whom the resource is shared.
   */
  putImagePolicy(
    req: operations.PutImagePolicyRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.PutImagePolicyResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PutImagePolicyRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/PutImagePolicy";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "put",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PutImagePolicyResponse =
        new operations.PutImagePolicyResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.putImagePolicyResponse = utils.objectToClass(
              httpRes?.data,
              shared.PutImagePolicyResponse
            );
          }
          break;
        case httpRes?.status == 480:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.serviceException = httpRes?.data;
          }
          break;
        case httpRes?.status == 481:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.clientException = httpRes?.data;
          }
          break;
        case httpRes?.status == 482:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.serviceUnavailableException = httpRes?.data;
          }
          break;
        case httpRes?.status == 483:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.invalidRequestException = httpRes?.data;
          }
          break;
        case httpRes?.status == 484:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.invalidParameterValueException = httpRes?.data;
          }
          break;
        case httpRes?.status == 485:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.resourceNotFoundException = httpRes?.data;
          }
          break;
        case httpRes?.status == 486:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.forbiddenException = httpRes?.data;
          }
          break;
        case httpRes?.status == 487:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.callRateLimitExceededException = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   *  Applies a policy to an image recipe. We recommend that you call the RAM API <a href="https://docs.aws.amazon.com/ram/latest/APIReference/API_CreateResourceShare.html">CreateResourceShare</a> to share resources. If you call the Image Builder API <code>PutImageRecipePolicy</code>, you must also call the RAM API <a href="https://docs.aws.amazon.com/ram/latest/APIReference/API_PromoteResourceShareCreatedFromPolicy.html">PromoteResourceShareCreatedFromPolicy</a> in order for the resource to be visible to all principals with whom the resource is shared.
   */
  putImageRecipePolicy(
    req: operations.PutImageRecipePolicyRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.PutImageRecipePolicyResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PutImageRecipePolicyRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/PutImageRecipePolicy";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "put",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PutImageRecipePolicyResponse =
        new operations.PutImageRecipePolicyResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.putImageRecipePolicyResponse = utils.objectToClass(
              httpRes?.data,
              shared.PutImageRecipePolicyResponse
            );
          }
          break;
        case httpRes?.status == 480:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.serviceException = httpRes?.data;
          }
          break;
        case httpRes?.status == 481:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.clientException = httpRes?.data;
          }
          break;
        case httpRes?.status == 482:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.serviceUnavailableException = httpRes?.data;
          }
          break;
        case httpRes?.status == 483:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.invalidRequestException = httpRes?.data;
          }
          break;
        case httpRes?.status == 484:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.invalidParameterValueException = httpRes?.data;
          }
          break;
        case httpRes?.status == 485:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.resourceNotFoundException = httpRes?.data;
          }
          break;
        case httpRes?.status == 486:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.forbiddenException = httpRes?.data;
          }
          break;
        case httpRes?.status == 487:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.callRateLimitExceededException = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   *  Manually triggers a pipeline to create an image.
   */
  startImagePipelineExecution(
    req: operations.StartImagePipelineExecutionRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.StartImagePipelineExecutionResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.StartImagePipelineExecutionRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/StartImagePipelineExecution";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "put",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.StartImagePipelineExecutionResponse =
        new operations.StartImagePipelineExecutionResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.startImagePipelineExecutionResponse = utils.objectToClass(
              httpRes?.data,
              shared.StartImagePipelineExecutionResponse
            );
          }
          break;
        case httpRes?.status == 480:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.serviceException = httpRes?.data;
          }
          break;
        case httpRes?.status == 481:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.clientException = httpRes?.data;
          }
          break;
        case httpRes?.status == 482:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.serviceUnavailableException = httpRes?.data;
          }
          break;
        case httpRes?.status == 483:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.invalidRequestException = httpRes?.data;
          }
          break;
        case httpRes?.status == 484:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.resourceNotFoundException = httpRes?.data;
          }
          break;
        case httpRes?.status == 485:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.idempotentParameterMismatchException = httpRes?.data;
          }
          break;
        case httpRes?.status == 486:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.forbiddenException = httpRes?.data;
          }
          break;
        case httpRes?.status == 487:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.callRateLimitExceededException = httpRes?.data;
          }
          break;
        case httpRes?.status == 488:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.resourceInUseException = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   *  Adds a tag to a resource.
   */
  tagResource(
    req: operations.TagResourceRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.TagResourceResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.TagResourceRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(baseURL, "/tags/{resourceArn}", req);

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.TagResourceResponse =
        new operations.TagResourceResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.tagResourceResponse = utils.objectToClass(httpRes?.data);
          }
          break;
        case httpRes?.status == 480:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.serviceException = httpRes?.data;
          }
          break;
        case httpRes?.status == 481:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.invalidParameterException = httpRes?.data;
          }
          break;
        case httpRes?.status == 482:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.resourceNotFoundException = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   *  Removes a tag from a resource.
   */
  untagResource(
    req: operations.UntagResourceRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.UntagResourceResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.UntagResourceRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/tags/{resourceArn}#tagKeys",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "delete",
      headers: headers,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UntagResourceResponse =
        new operations.UntagResourceResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.untagResourceResponse = utils.objectToClass(httpRes?.data);
          }
          break;
        case httpRes?.status == 480:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.serviceException = httpRes?.data;
          }
          break;
        case httpRes?.status == 481:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.invalidParameterException = httpRes?.data;
          }
          break;
        case httpRes?.status == 482:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.resourceNotFoundException = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   *  Updates a new distribution configuration. Distribution configurations define and configure the outputs of your pipeline.
   */
  updateDistributionConfiguration(
    req: operations.UpdateDistributionConfigurationRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.UpdateDistributionConfigurationResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.UpdateDistributionConfigurationRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/UpdateDistributionConfiguration";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "put",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UpdateDistributionConfigurationResponse =
        new operations.UpdateDistributionConfigurationResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.updateDistributionConfigurationResponse = utils.objectToClass(
              httpRes?.data,
              shared.UpdateDistributionConfigurationResponse
            );
          }
          break;
        case httpRes?.status == 480:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.serviceException = httpRes?.data;
          }
          break;
        case httpRes?.status == 481:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.clientException = httpRes?.data;
          }
          break;
        case httpRes?.status == 482:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.serviceUnavailableException = httpRes?.data;
          }
          break;
        case httpRes?.status == 483:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.invalidRequestException = httpRes?.data;
          }
          break;
        case httpRes?.status == 484:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.idempotentParameterMismatchException = httpRes?.data;
          }
          break;
        case httpRes?.status == 485:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.forbiddenException = httpRes?.data;
          }
          break;
        case httpRes?.status == 486:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.callRateLimitExceededException = httpRes?.data;
          }
          break;
        case httpRes?.status == 487:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.resourceInUseException = httpRes?.data;
          }
          break;
        case httpRes?.status == 488:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.invalidParameterCombinationException = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * <p> Updates an image pipeline. Image pipelines enable you to automate the creation and distribution of images.</p> <note> <p>UpdateImagePipeline does not support selective updates for the pipeline. You must specify all of the required properties in the update request, not just the properties that have changed.</p> </note>
   */
  updateImagePipeline(
    req: operations.UpdateImagePipelineRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.UpdateImagePipelineResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.UpdateImagePipelineRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/UpdateImagePipeline";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "put",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UpdateImagePipelineResponse =
        new operations.UpdateImagePipelineResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.updateImagePipelineResponse = utils.objectToClass(
              httpRes?.data,
              shared.UpdateImagePipelineResponse
            );
          }
          break;
        case httpRes?.status == 480:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.serviceException = httpRes?.data;
          }
          break;
        case httpRes?.status == 481:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.clientException = httpRes?.data;
          }
          break;
        case httpRes?.status == 482:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.serviceUnavailableException = httpRes?.data;
          }
          break;
        case httpRes?.status == 483:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.invalidRequestException = httpRes?.data;
          }
          break;
        case httpRes?.status == 484:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.idempotentParameterMismatchException = httpRes?.data;
          }
          break;
        case httpRes?.status == 485:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.forbiddenException = httpRes?.data;
          }
          break;
        case httpRes?.status == 486:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.callRateLimitExceededException = httpRes?.data;
          }
          break;
        case httpRes?.status == 487:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.resourceInUseException = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   *  Updates a new infrastructure configuration. An infrastructure configuration defines the environment in which your image will be built and tested.
   */
  updateInfrastructureConfiguration(
    req: operations.UpdateInfrastructureConfigurationRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.UpdateInfrastructureConfigurationResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.UpdateInfrastructureConfigurationRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/UpdateInfrastructureConfiguration";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "put",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UpdateInfrastructureConfigurationResponse =
        new operations.UpdateInfrastructureConfigurationResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.updateInfrastructureConfigurationResponse = utils.objectToClass(
              httpRes?.data,
              shared.UpdateInfrastructureConfigurationResponse
            );
          }
          break;
        case httpRes?.status == 480:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.serviceException = httpRes?.data;
          }
          break;
        case httpRes?.status == 481:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.clientException = httpRes?.data;
          }
          break;
        case httpRes?.status == 482:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.serviceUnavailableException = httpRes?.data;
          }
          break;
        case httpRes?.status == 483:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.invalidRequestException = httpRes?.data;
          }
          break;
        case httpRes?.status == 484:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.idempotentParameterMismatchException = httpRes?.data;
          }
          break;
        case httpRes?.status == 485:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.forbiddenException = httpRes?.data;
          }
          break;
        case httpRes?.status == 486:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.callRateLimitExceededException = httpRes?.data;
          }
          break;
        case httpRes?.status == 487:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.resourceInUseException = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }
}
