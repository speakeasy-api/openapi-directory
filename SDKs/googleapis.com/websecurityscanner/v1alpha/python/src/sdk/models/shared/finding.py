"""Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT."""

from __future__ import annotations
import dataclasses
from ..shared import outdatedlibrary as shared_outdatedlibrary
from ..shared import violatingresource as shared_violatingresource
from ..shared import vulnerableheaders as shared_vulnerableheaders
from ..shared import vulnerableparameters as shared_vulnerableparameters
from ..shared import xss as shared_xss
from dataclasses_json import Undefined, dataclass_json
from enum import Enum
from sdk import utils
from typing import Optional

class FindingFindingTypeEnum(str, Enum):
    r"""The type of the Finding."""
    FINDING_TYPE_UNSPECIFIED = 'FINDING_TYPE_UNSPECIFIED'
    MIXED_CONTENT = 'MIXED_CONTENT'
    OUTDATED_LIBRARY = 'OUTDATED_LIBRARY'
    ROSETTA_FLASH = 'ROSETTA_FLASH'
    XSS_CALLBACK = 'XSS_CALLBACK'
    XSS_ERROR = 'XSS_ERROR'
    CLEAR_TEXT_PASSWORD = 'CLEAR_TEXT_PASSWORD'
    INVALID_CONTENT_TYPE = 'INVALID_CONTENT_TYPE'
    XSS_ANGULAR_CALLBACK = 'XSS_ANGULAR_CALLBACK'
    INVALID_HEADER = 'INVALID_HEADER'
    MISSPELLED_SECURITY_HEADER_NAME = 'MISSPELLED_SECURITY_HEADER_NAME'
    MISMATCHING_SECURITY_HEADER_VALUES = 'MISMATCHING_SECURITY_HEADER_VALUES'


@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class Finding:
    r"""A Finding resource represents a vulnerability instance identified during a ScanRun."""
    
    body: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('body'), 'exclude': lambda f: f is None }})
    r"""The body of the request that triggered the vulnerability."""  
    description: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('description'), 'exclude': lambda f: f is None }})
    r"""The description of the vulnerability."""  
    final_url: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('finalUrl'), 'exclude': lambda f: f is None }})
    r"""The URL where the browser lands when the vulnerability is detected."""  
    finding_type: Optional[FindingFindingTypeEnum] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('findingType'), 'exclude': lambda f: f is None }})
    r"""The type of the Finding."""  
    frame_url: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('frameUrl'), 'exclude': lambda f: f is None }})
    r"""If the vulnerability was originated from nested IFrame, the immediate parent IFrame is reported."""  
    fuzzed_url: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('fuzzedUrl'), 'exclude': lambda f: f is None }})
    r"""The URL produced by the server-side fuzzer and used in the request that triggered the vulnerability."""  
    http_method: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('httpMethod'), 'exclude': lambda f: f is None }})
    r"""The http method of the request that triggered the vulnerability, in uppercase."""  
    name: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('name'), 'exclude': lambda f: f is None }})
    r"""The resource name of the Finding. The name follows the format of 'projects/{projectId}/scanConfigs/{scanConfigId}/scanruns/{scanRunId}/findings/{findingId}'. The finding IDs are generated by the system."""  
    outdated_library: Optional[shared_outdatedlibrary.OutdatedLibrary] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('outdatedLibrary'), 'exclude': lambda f: f is None }})
    r"""Information reported for an outdated library."""  
    reproduction_url: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('reproductionUrl'), 'exclude': lambda f: f is None }})
    r"""The URL containing human-readable payload that user can leverage to reproduce the vulnerability."""  
    tracking_id: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('trackingId'), 'exclude': lambda f: f is None }})
    r"""The tracking ID uniquely identifies a vulnerability instance across multiple ScanRuns."""  
    violating_resource: Optional[shared_violatingresource.ViolatingResource] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('violatingResource'), 'exclude': lambda f: f is None }})
    r"""Information regarding any resource causing the vulnerability such as JavaScript sources, image, audio files, etc."""  
    vulnerable_headers: Optional[shared_vulnerableheaders.VulnerableHeaders] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('vulnerableHeaders'), 'exclude': lambda f: f is None }})
    r"""Information about vulnerable or missing HTTP Headers."""  
    vulnerable_parameters: Optional[shared_vulnerableparameters.VulnerableParameters] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('vulnerableParameters'), 'exclude': lambda f: f is None }})
    r"""Information about vulnerable request parameters."""  
    xss: Optional[shared_xss.XSS] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('xss'), 'exclude': lambda f: f is None }})
    r"""Information reported for an XSS."""  
    