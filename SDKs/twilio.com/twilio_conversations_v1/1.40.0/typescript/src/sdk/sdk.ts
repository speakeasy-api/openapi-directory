/*
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

import * as utils from "../internal/utils";
import * as operations from "./models/operations";
import * as shared from "./models/shared";
import axios from "axios";
import { AxiosInstance, AxiosRequestConfig, AxiosResponse } from "axios";

/**
 * Contains the list of servers available to the SDK
 */
export const ServerList = ["https://conversations.twilio.com"] as const;

/**
 * The available configuration options for the SDK
 */
export type SDKProps = {
  /**
   * Allows overriding the default axios client used by the SDK
   */
  defaultClient?: AxiosInstance;
  /**
   * Allows overriding the default server URL used by the SDK
   */
  serverURL?: string;
};

/**
 * This is the public Twilio REST API.
 */
export class SDK {
  public _defaultClient: AxiosInstance;
  public _securityClient: AxiosInstance;
  public _serverURL: string;
  private _language = "typescript";
  private _sdkVersion = "0.0.1";
  private _genVersion = "internal";
  private _globals: any;

  constructor(props?: SDKProps) {
    this._serverURL = props?.serverURL ?? ServerList[0];

    this._defaultClient =
      props?.defaultClient ?? axios.create({ baseURL: this._serverURL });
    this._securityClient = this._defaultClient;
  }

  /**
   * Create a new address configuration
   */
  createConfigurationAddress(
    req: operations.CreateConfigurationAddressCreateConfigurationAddressRequest,
    security: operations.CreateConfigurationAddressSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.CreateConfigurationAddressResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.CreateConfigurationAddressCreateConfigurationAddressRequest(
          req
        );
    }

    let baseURL: string = operations.CreateConfigurationAddressServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string =
      baseURL.replace(/\/$/, "") + "/v1/Configuration/Addresses";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "request",
        "form"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.CreateConfigurationAddressSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CreateConfigurationAddressResponse =
        new operations.CreateConfigurationAddressResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.conversationsV1ConfigurationAddress = utils.objectToClass(
              httpRes?.data,
              shared.ConversationsV1ConfigurationAddress
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Create a new conversation in your account's default service
   */
  createConversation(
    req: operations.CreateConversationRequest,
    security: operations.CreateConversationSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.CreateConversationResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CreateConversationRequest(req);
    }

    let baseURL: string = operations.CreateConversationServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = baseURL.replace(/\/$/, "") + "/v1/Conversations";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "form"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.CreateConversationSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CreateConversationResponse =
        new operations.CreateConversationResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.conversationsV1Conversation = utils.objectToClass(
              httpRes?.data,
              shared.ConversationsV1Conversation
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Add a new message to the conversation
   */
  createConversationMessage(
    req: operations.CreateConversationMessageRequest,
    security: operations.CreateConversationMessageSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.CreateConversationMessageResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CreateConversationMessageRequest(req);
    }

    let baseURL: string = operations.CreateConversationMessageServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v1/Conversations/{ConversationSid}/Messages",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "form"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.CreateConversationMessageSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CreateConversationMessageResponse =
        new operations.CreateConversationMessageResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.conversationsV1ConversationConversationMessage =
              utils.objectToClass(
                httpRes?.data,
                shared.ConversationsV1ConversationConversationMessage
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Add a new participant to the conversation
   */
  createConversationParticipant(
    req: operations.CreateConversationParticipantRequest,
    security: operations.CreateConversationParticipantSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.CreateConversationParticipantResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CreateConversationParticipantRequest(req);
    }

    let baseURL: string = operations.CreateConversationParticipantServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v1/Conversations/{ConversationSid}/Participants",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "form"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.CreateConversationParticipantSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CreateConversationParticipantResponse =
        new operations.CreateConversationParticipantResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.conversationsV1ConversationConversationParticipant =
              utils.objectToClass(
                httpRes?.data,
                shared.ConversationsV1ConversationConversationParticipant
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Create a new webhook scoped to the conversation
   */
  createConversationScopedWebhook(
    req: operations.CreateConversationScopedWebhookRequest,
    security: operations.CreateConversationScopedWebhookSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.CreateConversationScopedWebhookResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CreateConversationScopedWebhookRequest(req);
    }

    let baseURL: string =
      operations.CreateConversationScopedWebhookServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v1/Conversations/{ConversationSid}/Webhooks",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "form"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.CreateConversationScopedWebhookSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CreateConversationScopedWebhookResponse =
        new operations.CreateConversationScopedWebhookResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.conversationsV1ConversationConversationScopedWebhook =
              utils.objectToClass(
                httpRes?.data,
                shared.ConversationsV1ConversationConversationScopedWebhook
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Add a new push notification credential to your account
   */
  createCredential(
    req: operations.CreateCredentialCreateCredentialRequest,
    security: operations.CreateCredentialSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.CreateCredentialResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CreateCredentialCreateCredentialRequest(req);
    }

    let baseURL: string = operations.CreateCredentialServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = baseURL.replace(/\/$/, "") + "/v1/Credentials";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "request",
        "form"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.CreateCredentialSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CreateCredentialResponse =
        new operations.CreateCredentialResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.conversationsV1Credential = utils.objectToClass(
              httpRes?.data,
              shared.ConversationsV1Credential
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Create a new user role in your account's default service
   */
  createRole(
    req: operations.CreateRoleCreateRoleRequest,
    security: operations.CreateRoleSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.CreateRoleResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CreateRoleCreateRoleRequest(req);
    }

    let baseURL: string = operations.CreateRoleServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = baseURL.replace(/\/$/, "") + "/v1/Roles";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "request",
        "form"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.CreateRoleSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CreateRoleResponse =
        new operations.CreateRoleResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.conversationsV1Role = utils.objectToClass(
              httpRes?.data,
              shared.ConversationsV1Role
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Create a new conversation service on your account
   */
  createService(
    req: operations.CreateServiceCreateServiceRequest,
    security: operations.CreateServiceSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.CreateServiceResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CreateServiceCreateServiceRequest(req);
    }

    let baseURL: string = operations.CreateServiceServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = baseURL.replace(/\/$/, "") + "/v1/Services";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "request",
        "form"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.CreateServiceSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CreateServiceResponse =
        new operations.CreateServiceResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.conversationsV1Service = utils.objectToClass(
              httpRes?.data,
              shared.ConversationsV1Service
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Create a new conversation in your service
   */
  createServiceConversation(
    req: operations.CreateServiceConversationRequest,
    security: operations.CreateServiceConversationSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.CreateServiceConversationResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CreateServiceConversationRequest(req);
    }

    let baseURL: string = operations.CreateServiceConversationServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v1/Services/{ChatServiceSid}/Conversations",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "form"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.CreateServiceConversationSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CreateServiceConversationResponse =
        new operations.CreateServiceConversationResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.conversationsV1ServiceServiceConversation = utils.objectToClass(
              httpRes?.data,
              shared.ConversationsV1ServiceServiceConversation
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Add a new message to the conversation in a specific service
   */
  createServiceConversationMessage(
    req: operations.CreateServiceConversationMessageRequest,
    security: operations.CreateServiceConversationMessageSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.CreateServiceConversationMessageResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CreateServiceConversationMessageRequest(req);
    }

    let baseURL: string =
      operations.CreateServiceConversationMessageServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v1/Services/{ChatServiceSid}/Conversations/{ConversationSid}/Messages",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "form"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.CreateServiceConversationMessageSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CreateServiceConversationMessageResponse =
        new operations.CreateServiceConversationMessageResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.conversationsV1ServiceServiceConversationServiceConversationMessage =
              utils.objectToClass(
                httpRes?.data,
                shared.ConversationsV1ServiceServiceConversationServiceConversationMessage
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Add a new participant to the conversation in a specific service
   */
  createServiceConversationParticipant(
    req: operations.CreateServiceConversationParticipantRequest,
    security: operations.CreateServiceConversationParticipantSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.CreateServiceConversationParticipantResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CreateServiceConversationParticipantRequest(req);
    }

    let baseURL: string =
      operations.CreateServiceConversationParticipantServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v1/Services/{ChatServiceSid}/Conversations/{ConversationSid}/Participants",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "form"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.CreateServiceConversationParticipantSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CreateServiceConversationParticipantResponse =
        new operations.CreateServiceConversationParticipantResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.conversationsV1ServiceServiceConversationServiceConversationParticipant =
              utils.objectToClass(
                httpRes?.data,
                shared.ConversationsV1ServiceServiceConversationServiceConversationParticipant
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Create a new webhook scoped to the conversation in a specific service
   */
  createServiceConversationScopedWebhook(
    req: operations.CreateServiceConversationScopedWebhookRequest,
    security: operations.CreateServiceConversationScopedWebhookSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.CreateServiceConversationScopedWebhookResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CreateServiceConversationScopedWebhookRequest(req);
    }

    let baseURL: string =
      operations.CreateServiceConversationScopedWebhookServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v1/Services/{ChatServiceSid}/Conversations/{ConversationSid}/Webhooks",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "form"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.CreateServiceConversationScopedWebhookSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CreateServiceConversationScopedWebhookResponse =
        new operations.CreateServiceConversationScopedWebhookResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.conversationsV1ServiceServiceConversationServiceConversationScopedWebhook =
              utils.objectToClass(
                httpRes?.data,
                shared.ConversationsV1ServiceServiceConversationServiceConversationScopedWebhook
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Create a new user role in your service
   */
  createServiceRole(
    req: operations.CreateServiceRoleRequest,
    security: operations.CreateServiceRoleSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.CreateServiceRoleResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CreateServiceRoleRequest(req);
    }

    let baseURL: string = operations.CreateServiceRoleServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v1/Services/{ChatServiceSid}/Roles",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "form"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.CreateServiceRoleSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CreateServiceRoleResponse =
        new operations.CreateServiceRoleResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.conversationsV1ServiceServiceRole = utils.objectToClass(
              httpRes?.data,
              shared.ConversationsV1ServiceServiceRole
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Add a new conversation user to your service
   */
  createServiceUser(
    req: operations.CreateServiceUserRequest,
    security: operations.CreateServiceUserSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.CreateServiceUserResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CreateServiceUserRequest(req);
    }

    let baseURL: string = operations.CreateServiceUserServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v1/Services/{ChatServiceSid}/Users",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "form"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.CreateServiceUserSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CreateServiceUserResponse =
        new operations.CreateServiceUserResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.conversationsV1ServiceServiceUser = utils.objectToClass(
              httpRes?.data,
              shared.ConversationsV1ServiceServiceUser
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Add a new conversation user to your account's default service
   */
  createUser(
    req: operations.CreateUserRequest,
    security: operations.CreateUserSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.CreateUserResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CreateUserRequest(req);
    }

    let baseURL: string = operations.CreateUserServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = baseURL.replace(/\/$/, "") + "/v1/Users";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "form"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.CreateUserSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CreateUserResponse =
        new operations.CreateUserResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.conversationsV1User = utils.objectToClass(
              httpRes?.data,
              shared.ConversationsV1User
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Remove an existing address configuration
   */
  deleteConfigurationAddress(
    req: operations.DeleteConfigurationAddressRequest,
    security: operations.DeleteConfigurationAddressSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.DeleteConfigurationAddressResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DeleteConfigurationAddressRequest(req);
    }

    let baseURL: string = operations.DeleteConfigurationAddressServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v1/Configuration/Addresses/{Sid}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.DeleteConfigurationAddressSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DeleteConfigurationAddressResponse =
        new operations.DeleteConfigurationAddressResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
      }

      return res;
    });
  }

  /**
   * Remove a conversation from your account's default service
   */
  deleteConversation(
    req: operations.DeleteConversationRequest,
    security: operations.DeleteConversationSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.DeleteConversationResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DeleteConversationRequest(req);
    }

    let baseURL: string = operations.DeleteConversationServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v1/Conversations/{Sid}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.DeleteConversationSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };

    const r = client.request({
      url: url,
      method: "delete",
      headers: headers,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DeleteConversationResponse =
        new operations.DeleteConversationResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
      }

      return res;
    });
  }

  /**
   * Remove a message from the conversation
   */
  deleteConversationMessage(
    req: operations.DeleteConversationMessageRequest,
    security: operations.DeleteConversationMessageSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.DeleteConversationMessageResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DeleteConversationMessageRequest(req);
    }

    let baseURL: string = operations.DeleteConversationMessageServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v1/Conversations/{ConversationSid}/Messages/{Sid}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.DeleteConversationMessageSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };

    const r = client.request({
      url: url,
      method: "delete",
      headers: headers,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DeleteConversationMessageResponse =
        new operations.DeleteConversationMessageResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
      }

      return res;
    });
  }

  /**
   * Remove a participant from the conversation
   */
  deleteConversationParticipant(
    req: operations.DeleteConversationParticipantRequest,
    security: operations.DeleteConversationParticipantSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.DeleteConversationParticipantResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DeleteConversationParticipantRequest(req);
    }

    let baseURL: string = operations.DeleteConversationParticipantServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v1/Conversations/{ConversationSid}/Participants/{Sid}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.DeleteConversationParticipantSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };

    const r = client.request({
      url: url,
      method: "delete",
      headers: headers,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DeleteConversationParticipantResponse =
        new operations.DeleteConversationParticipantResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
      }

      return res;
    });
  }

  /**
   * Remove an existing webhook scoped to the conversation
   */
  deleteConversationScopedWebhook(
    req: operations.DeleteConversationScopedWebhookRequest,
    security: operations.DeleteConversationScopedWebhookSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.DeleteConversationScopedWebhookResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DeleteConversationScopedWebhookRequest(req);
    }

    let baseURL: string =
      operations.DeleteConversationScopedWebhookServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v1/Conversations/{ConversationSid}/Webhooks/{Sid}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.DeleteConversationScopedWebhookSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DeleteConversationScopedWebhookResponse =
        new operations.DeleteConversationScopedWebhookResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
      }

      return res;
    });
  }

  /**
   * Remove a push notification credential from your account
   */
  deleteCredential(
    req: operations.DeleteCredentialRequest,
    security: operations.DeleteCredentialSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.DeleteCredentialResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DeleteCredentialRequest(req);
    }

    let baseURL: string = operations.DeleteCredentialServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v1/Credentials/{Sid}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.DeleteCredentialSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DeleteCredentialResponse =
        new operations.DeleteCredentialResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
      }

      return res;
    });
  }

  /**
   * Remove a user role from your account's default service
   */
  deleteRole(
    req: operations.DeleteRoleRequest,
    security: operations.DeleteRoleSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.DeleteRoleResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DeleteRoleRequest(req);
    }

    let baseURL: string = operations.DeleteRoleServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(baseURL, "/v1/Roles/{Sid}", req);
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.DeleteRoleSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DeleteRoleResponse =
        new operations.DeleteRoleResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
      }

      return res;
    });
  }

  /**
   * Remove a conversation service with all its nested resources from your account
   */
  deleteService(
    req: operations.DeleteServiceRequest,
    security: operations.DeleteServiceSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.DeleteServiceResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DeleteServiceRequest(req);
    }

    let baseURL: string = operations.DeleteServiceServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(baseURL, "/v1/Services/{Sid}", req);
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.DeleteServiceSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DeleteServiceResponse =
        new operations.DeleteServiceResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
      }

      return res;
    });
  }

  /**
   * Remove a push notification binding from the conversation service
   */
  deleteServiceBinding(
    req: operations.DeleteServiceBindingRequest,
    security: operations.DeleteServiceBindingSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.DeleteServiceBindingResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DeleteServiceBindingRequest(req);
    }

    let baseURL: string = operations.DeleteServiceBindingServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v1/Services/{ChatServiceSid}/Bindings/{Sid}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.DeleteServiceBindingSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DeleteServiceBindingResponse =
        new operations.DeleteServiceBindingResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
      }

      return res;
    });
  }

  /**
   * Remove a conversation from your service
   */
  deleteServiceConversation(
    req: operations.DeleteServiceConversationRequest,
    security: operations.DeleteServiceConversationSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.DeleteServiceConversationResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DeleteServiceConversationRequest(req);
    }

    let baseURL: string = operations.DeleteServiceConversationServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v1/Services/{ChatServiceSid}/Conversations/{Sid}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.DeleteServiceConversationSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };

    const r = client.request({
      url: url,
      method: "delete",
      headers: headers,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DeleteServiceConversationResponse =
        new operations.DeleteServiceConversationResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
      }

      return res;
    });
  }

  /**
   * Remove a message from the conversation
   */
  deleteServiceConversationMessage(
    req: operations.DeleteServiceConversationMessageRequest,
    security: operations.DeleteServiceConversationMessageSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.DeleteServiceConversationMessageResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DeleteServiceConversationMessageRequest(req);
    }

    let baseURL: string =
      operations.DeleteServiceConversationMessageServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v1/Services/{ChatServiceSid}/Conversations/{ConversationSid}/Messages/{Sid}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.DeleteServiceConversationMessageSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };

    const r = client.request({
      url: url,
      method: "delete",
      headers: headers,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DeleteServiceConversationMessageResponse =
        new operations.DeleteServiceConversationMessageResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
      }

      return res;
    });
  }

  /**
   * Remove a participant from the conversation
   */
  deleteServiceConversationParticipant(
    req: operations.DeleteServiceConversationParticipantRequest,
    security: operations.DeleteServiceConversationParticipantSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.DeleteServiceConversationParticipantResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DeleteServiceConversationParticipantRequest(req);
    }

    let baseURL: string =
      operations.DeleteServiceConversationParticipantServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v1/Services/{ChatServiceSid}/Conversations/{ConversationSid}/Participants/{Sid}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.DeleteServiceConversationParticipantSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };

    const r = client.request({
      url: url,
      method: "delete",
      headers: headers,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DeleteServiceConversationParticipantResponse =
        new operations.DeleteServiceConversationParticipantResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
      }

      return res;
    });
  }

  /**
   * Remove an existing webhook scoped to the conversation
   */
  deleteServiceConversationScopedWebhook(
    req: operations.DeleteServiceConversationScopedWebhookRequest,
    security: operations.DeleteServiceConversationScopedWebhookSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.DeleteServiceConversationScopedWebhookResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DeleteServiceConversationScopedWebhookRequest(req);
    }

    let baseURL: string =
      operations.DeleteServiceConversationScopedWebhookServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v1/Services/{ChatServiceSid}/Conversations/{ConversationSid}/Webhooks/{Sid}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.DeleteServiceConversationScopedWebhookSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DeleteServiceConversationScopedWebhookResponse =
        new operations.DeleteServiceConversationScopedWebhookResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
      }

      return res;
    });
  }

  /**
   * Remove a user role from your service
   */
  deleteServiceRole(
    req: operations.DeleteServiceRoleRequest,
    security: operations.DeleteServiceRoleSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.DeleteServiceRoleResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DeleteServiceRoleRequest(req);
    }

    let baseURL: string = operations.DeleteServiceRoleServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v1/Services/{ChatServiceSid}/Roles/{Sid}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.DeleteServiceRoleSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DeleteServiceRoleResponse =
        new operations.DeleteServiceRoleResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
      }

      return res;
    });
  }

  /**
   * Remove a conversation user from your service
   */
  deleteServiceUser(
    req: operations.DeleteServiceUserRequest,
    security: operations.DeleteServiceUserSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.DeleteServiceUserResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DeleteServiceUserRequest(req);
    }

    let baseURL: string = operations.DeleteServiceUserServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v1/Services/{ChatServiceSid}/Users/{Sid}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.DeleteServiceUserSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };

    const r = client.request({
      url: url,
      method: "delete",
      headers: headers,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DeleteServiceUserResponse =
        new operations.DeleteServiceUserResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
      }

      return res;
    });
  }

  /**
   * Delete a specific User Conversation.
   */
  deleteServiceUserConversation(
    req: operations.DeleteServiceUserConversationRequest,
    security: operations.DeleteServiceUserConversationSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.DeleteServiceUserConversationResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DeleteServiceUserConversationRequest(req);
    }

    let baseURL: string = operations.DeleteServiceUserConversationServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v1/Services/{ChatServiceSid}/Users/{UserSid}/Conversations/{ConversationSid}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.DeleteServiceUserConversationSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DeleteServiceUserConversationResponse =
        new operations.DeleteServiceUserConversationResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
      }

      return res;
    });
  }

  /**
   * Remove a conversation user from your account's default service
   */
  deleteUser(
    req: operations.DeleteUserRequest,
    security: operations.DeleteUserSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.DeleteUserResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DeleteUserRequest(req);
    }

    let baseURL: string = operations.DeleteUserServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(baseURL, "/v1/Users/{Sid}", req);
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.DeleteUserSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };

    const r = client.request({
      url: url,
      method: "delete",
      headers: headers,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DeleteUserResponse =
        new operations.DeleteUserResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
      }

      return res;
    });
  }

  /**
   * Delete a specific User Conversation.
   */
  deleteUserConversation(
    req: operations.DeleteUserConversationRequest,
    security: operations.DeleteUserConversationSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.DeleteUserConversationResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DeleteUserConversationRequest(req);
    }

    let baseURL: string = operations.DeleteUserConversationServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v1/Users/{UserSid}/Conversations/{ConversationSid}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.DeleteUserConversationSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DeleteUserConversationResponse =
        new operations.DeleteUserConversationResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
      }

      return res;
    });
  }

  /**
   * Fetch the global configuration of conversations on your account
   */
  fetchConfiguration(
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.FetchConfigurationResponse> {
    let baseURL: string = operations.FetchConfigurationServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = baseURL.replace(/\/$/, "") + "/v1/Configuration";

    const client: AxiosInstance = this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.FetchConfigurationResponse =
        new operations.FetchConfigurationResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.conversationsV1Configuration = utils.objectToClass(
              httpRes?.data,
              shared.ConversationsV1Configuration
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Fetch an address configuration
   */
  fetchConfigurationAddress(
    req: operations.FetchConfigurationAddressRequest,
    security: operations.FetchConfigurationAddressSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.FetchConfigurationAddressResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.FetchConfigurationAddressRequest(req);
    }

    let baseURL: string = operations.FetchConfigurationAddressServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v1/Configuration/Addresses/{Sid}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.FetchConfigurationAddressSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.FetchConfigurationAddressResponse =
        new operations.FetchConfigurationAddressResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.conversationsV1ConfigurationAddress = utils.objectToClass(
              httpRes?.data,
              shared.ConversationsV1ConfigurationAddress
            );
          }
          break;
      }

      return res;
    });
  }

  fetchConfigurationWebhook(
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.FetchConfigurationWebhookResponse> {
    let baseURL: string = operations.FetchConfigurationWebhookServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string =
      baseURL.replace(/\/$/, "") + "/v1/Configuration/Webhooks";

    const client: AxiosInstance = this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.FetchConfigurationWebhookResponse =
        new operations.FetchConfigurationWebhookResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.conversationsV1ConfigurationConfigurationWebhook =
              utils.objectToClass(
                httpRes?.data,
                shared.ConversationsV1ConfigurationConfigurationWebhook
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Fetch a conversation from your account's default service
   */
  fetchConversation(
    req: operations.FetchConversationRequest,
    security: operations.FetchConversationSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.FetchConversationResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.FetchConversationRequest(req);
    }

    let baseURL: string = operations.FetchConversationServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v1/Conversations/{Sid}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.FetchConversationSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.FetchConversationResponse =
        new operations.FetchConversationResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.conversationsV1Conversation = utils.objectToClass(
              httpRes?.data,
              shared.ConversationsV1Conversation
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Fetch a message from the conversation
   */
  fetchConversationMessage(
    req: operations.FetchConversationMessageRequest,
    security: operations.FetchConversationMessageSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.FetchConversationMessageResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.FetchConversationMessageRequest(req);
    }

    let baseURL: string = operations.FetchConversationMessageServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v1/Conversations/{ConversationSid}/Messages/{Sid}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.FetchConversationMessageSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.FetchConversationMessageResponse =
        new operations.FetchConversationMessageResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.conversationsV1ConversationConversationMessage =
              utils.objectToClass(
                httpRes?.data,
                shared.ConversationsV1ConversationConversationMessage
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Fetch the delivery and read receipts of the conversation message
   */
  fetchConversationMessageReceipt(
    req: operations.FetchConversationMessageReceiptRequest,
    security: operations.FetchConversationMessageReceiptSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.FetchConversationMessageReceiptResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.FetchConversationMessageReceiptRequest(req);
    }

    let baseURL: string =
      operations.FetchConversationMessageReceiptServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v1/Conversations/{ConversationSid}/Messages/{MessageSid}/Receipts/{Sid}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.FetchConversationMessageReceiptSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.FetchConversationMessageReceiptResponse =
        new operations.FetchConversationMessageReceiptResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.conversationsV1ConversationConversationMessageConversationMessageReceipt =
              utils.objectToClass(
                httpRes?.data,
                shared.ConversationsV1ConversationConversationMessageConversationMessageReceipt
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Fetch a participant of the conversation
   */
  fetchConversationParticipant(
    req: operations.FetchConversationParticipantRequest,
    security: operations.FetchConversationParticipantSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.FetchConversationParticipantResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.FetchConversationParticipantRequest(req);
    }

    let baseURL: string = operations.FetchConversationParticipantServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v1/Conversations/{ConversationSid}/Participants/{Sid}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.FetchConversationParticipantSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.FetchConversationParticipantResponse =
        new operations.FetchConversationParticipantResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.conversationsV1ConversationConversationParticipant =
              utils.objectToClass(
                httpRes?.data,
                shared.ConversationsV1ConversationConversationParticipant
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Fetch the configuration of a conversation-scoped webhook
   */
  fetchConversationScopedWebhook(
    req: operations.FetchConversationScopedWebhookRequest,
    security: operations.FetchConversationScopedWebhookSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.FetchConversationScopedWebhookResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.FetchConversationScopedWebhookRequest(req);
    }

    let baseURL: string =
      operations.FetchConversationScopedWebhookServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v1/Conversations/{ConversationSid}/Webhooks/{Sid}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.FetchConversationScopedWebhookSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.FetchConversationScopedWebhookResponse =
        new operations.FetchConversationScopedWebhookResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.conversationsV1ConversationConversationScopedWebhook =
              utils.objectToClass(
                httpRes?.data,
                shared.ConversationsV1ConversationConversationScopedWebhook
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Fetch a push notification credential from your account
   */
  fetchCredential(
    req: operations.FetchCredentialRequest,
    security: operations.FetchCredentialSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.FetchCredentialResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.FetchCredentialRequest(req);
    }

    let baseURL: string = operations.FetchCredentialServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v1/Credentials/{Sid}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.FetchCredentialSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.FetchCredentialResponse =
        new operations.FetchCredentialResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.conversationsV1Credential = utils.objectToClass(
              httpRes?.data,
              shared.ConversationsV1Credential
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Fetch a user role from your account's default service
   */
  fetchRole(
    req: operations.FetchRoleRequest,
    security: operations.FetchRoleSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.FetchRoleResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.FetchRoleRequest(req);
    }

    let baseURL: string = operations.FetchRoleServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(baseURL, "/v1/Roles/{Sid}", req);
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.FetchRoleSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.FetchRoleResponse =
        new operations.FetchRoleResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.conversationsV1Role = utils.objectToClass(
              httpRes?.data,
              shared.ConversationsV1Role
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Fetch a conversation service from your account
   */
  fetchService(
    req: operations.FetchServiceRequest,
    security: operations.FetchServiceSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.FetchServiceResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.FetchServiceRequest(req);
    }

    let baseURL: string = operations.FetchServiceServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(baseURL, "/v1/Services/{Sid}", req);
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.FetchServiceSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.FetchServiceResponse =
        new operations.FetchServiceResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.conversationsV1Service = utils.objectToClass(
              httpRes?.data,
              shared.ConversationsV1Service
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Fetch a push notification binding from the conversation service
   */
  fetchServiceBinding(
    req: operations.FetchServiceBindingRequest,
    security: operations.FetchServiceBindingSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.FetchServiceBindingResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.FetchServiceBindingRequest(req);
    }

    let baseURL: string = operations.FetchServiceBindingServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v1/Services/{ChatServiceSid}/Bindings/{Sid}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.FetchServiceBindingSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.FetchServiceBindingResponse =
        new operations.FetchServiceBindingResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.conversationsV1ServiceServiceBinding = utils.objectToClass(
              httpRes?.data,
              shared.ConversationsV1ServiceServiceBinding
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Fetch the configuration of a conversation service
   */
  fetchServiceConfiguration(
    req: operations.FetchServiceConfigurationRequest,
    security: operations.FetchServiceConfigurationSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.FetchServiceConfigurationResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.FetchServiceConfigurationRequest(req);
    }

    let baseURL: string = operations.FetchServiceConfigurationServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v1/Services/{ChatServiceSid}/Configuration",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.FetchServiceConfigurationSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.FetchServiceConfigurationResponse =
        new operations.FetchServiceConfigurationResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.conversationsV1ServiceServiceConfiguration =
              utils.objectToClass(
                httpRes?.data,
                shared.ConversationsV1ServiceServiceConfiguration
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Fetch a conversation from your service
   */
  fetchServiceConversation(
    req: operations.FetchServiceConversationRequest,
    security: operations.FetchServiceConversationSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.FetchServiceConversationResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.FetchServiceConversationRequest(req);
    }

    let baseURL: string = operations.FetchServiceConversationServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v1/Services/{ChatServiceSid}/Conversations/{Sid}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.FetchServiceConversationSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.FetchServiceConversationResponse =
        new operations.FetchServiceConversationResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.conversationsV1ServiceServiceConversation = utils.objectToClass(
              httpRes?.data,
              shared.ConversationsV1ServiceServiceConversation
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Fetch a message from the conversation
   */
  fetchServiceConversationMessage(
    req: operations.FetchServiceConversationMessageRequest,
    security: operations.FetchServiceConversationMessageSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.FetchServiceConversationMessageResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.FetchServiceConversationMessageRequest(req);
    }

    let baseURL: string =
      operations.FetchServiceConversationMessageServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v1/Services/{ChatServiceSid}/Conversations/{ConversationSid}/Messages/{Sid}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.FetchServiceConversationMessageSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.FetchServiceConversationMessageResponse =
        new operations.FetchServiceConversationMessageResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.conversationsV1ServiceServiceConversationServiceConversationMessage =
              utils.objectToClass(
                httpRes?.data,
                shared.ConversationsV1ServiceServiceConversationServiceConversationMessage
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Fetch the delivery and read receipts of the conversation message
   */
  fetchServiceConversationMessageReceipt(
    req: operations.FetchServiceConversationMessageReceiptRequest,
    security: operations.FetchServiceConversationMessageReceiptSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.FetchServiceConversationMessageReceiptResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.FetchServiceConversationMessageReceiptRequest(req);
    }

    let baseURL: string =
      operations.FetchServiceConversationMessageReceiptServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v1/Services/{ChatServiceSid}/Conversations/{ConversationSid}/Messages/{MessageSid}/Receipts/{Sid}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.FetchServiceConversationMessageReceiptSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.FetchServiceConversationMessageReceiptResponse =
        new operations.FetchServiceConversationMessageReceiptResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.conversationsV1ServiceServiceConversationServiceConversationMessageServiceConversationMessageReceipt =
              utils.objectToClass(
                httpRes?.data,
                shared.ConversationsV1ServiceServiceConversationServiceConversationMessageServiceConversationMessageReceipt
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Fetch a participant of the conversation
   */
  fetchServiceConversationParticipant(
    req: operations.FetchServiceConversationParticipantRequest,
    security: operations.FetchServiceConversationParticipantSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.FetchServiceConversationParticipantResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.FetchServiceConversationParticipantRequest(req);
    }

    let baseURL: string =
      operations.FetchServiceConversationParticipantServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v1/Services/{ChatServiceSid}/Conversations/{ConversationSid}/Participants/{Sid}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.FetchServiceConversationParticipantSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.FetchServiceConversationParticipantResponse =
        new operations.FetchServiceConversationParticipantResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.conversationsV1ServiceServiceConversationServiceConversationParticipant =
              utils.objectToClass(
                httpRes?.data,
                shared.ConversationsV1ServiceServiceConversationServiceConversationParticipant
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Fetch the configuration of a conversation-scoped webhook
   */
  fetchServiceConversationScopedWebhook(
    req: operations.FetchServiceConversationScopedWebhookRequest,
    security: operations.FetchServiceConversationScopedWebhookSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.FetchServiceConversationScopedWebhookResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.FetchServiceConversationScopedWebhookRequest(req);
    }

    let baseURL: string =
      operations.FetchServiceConversationScopedWebhookServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v1/Services/{ChatServiceSid}/Conversations/{ConversationSid}/Webhooks/{Sid}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.FetchServiceConversationScopedWebhookSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.FetchServiceConversationScopedWebhookResponse =
        new operations.FetchServiceConversationScopedWebhookResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.conversationsV1ServiceServiceConversationServiceConversationScopedWebhook =
              utils.objectToClass(
                httpRes?.data,
                shared.ConversationsV1ServiceServiceConversationServiceConversationScopedWebhook
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Fetch push notification service settings
   */
  fetchServiceNotification(
    req: operations.FetchServiceNotificationRequest,
    security: operations.FetchServiceNotificationSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.FetchServiceNotificationResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.FetchServiceNotificationRequest(req);
    }

    let baseURL: string = operations.FetchServiceNotificationServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v1/Services/{ChatServiceSid}/Configuration/Notifications",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.FetchServiceNotificationSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.FetchServiceNotificationResponse =
        new operations.FetchServiceNotificationResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.conversationsV1ServiceServiceConfigurationServiceNotification =
              utils.objectToClass(
                httpRes?.data,
                shared.ConversationsV1ServiceServiceConfigurationServiceNotification
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Fetch a user role from your service
   */
  fetchServiceRole(
    req: operations.FetchServiceRoleRequest,
    security: operations.FetchServiceRoleSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.FetchServiceRoleResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.FetchServiceRoleRequest(req);
    }

    let baseURL: string = operations.FetchServiceRoleServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v1/Services/{ChatServiceSid}/Roles/{Sid}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.FetchServiceRoleSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.FetchServiceRoleResponse =
        new operations.FetchServiceRoleResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.conversationsV1ServiceServiceRole = utils.objectToClass(
              httpRes?.data,
              shared.ConversationsV1ServiceServiceRole
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Fetch a conversation user from your service
   */
  fetchServiceUser(
    req: operations.FetchServiceUserRequest,
    security: operations.FetchServiceUserSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.FetchServiceUserResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.FetchServiceUserRequest(req);
    }

    let baseURL: string = operations.FetchServiceUserServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v1/Services/{ChatServiceSid}/Users/{Sid}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.FetchServiceUserSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.FetchServiceUserResponse =
        new operations.FetchServiceUserResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.conversationsV1ServiceServiceUser = utils.objectToClass(
              httpRes?.data,
              shared.ConversationsV1ServiceServiceUser
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Fetch a specific User Conversation.
   */
  fetchServiceUserConversation(
    req: operations.FetchServiceUserConversationRequest,
    security: operations.FetchServiceUserConversationSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.FetchServiceUserConversationResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.FetchServiceUserConversationRequest(req);
    }

    let baseURL: string = operations.FetchServiceUserConversationServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v1/Services/{ChatServiceSid}/Users/{UserSid}/Conversations/{ConversationSid}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.FetchServiceUserConversationSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.FetchServiceUserConversationResponse =
        new operations.FetchServiceUserConversationResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.conversationsV1ServiceServiceUserServiceUserConversation =
              utils.objectToClass(
                httpRes?.data,
                shared.ConversationsV1ServiceServiceUserServiceUserConversation
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Fetch a specific service webhook configuration.
   */
  fetchServiceWebhookConfiguration(
    req: operations.FetchServiceWebhookConfigurationRequest,
    security: operations.FetchServiceWebhookConfigurationSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.FetchServiceWebhookConfigurationResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.FetchServiceWebhookConfigurationRequest(req);
    }

    let baseURL: string =
      operations.FetchServiceWebhookConfigurationServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v1/Services/{ChatServiceSid}/Configuration/Webhooks",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.FetchServiceWebhookConfigurationSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.FetchServiceWebhookConfigurationResponse =
        new operations.FetchServiceWebhookConfigurationResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.conversationsV1ServiceServiceConfigurationServiceWebhookConfiguration =
              utils.objectToClass(
                httpRes?.data,
                shared.ConversationsV1ServiceServiceConfigurationServiceWebhookConfiguration
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Fetch a conversation user from your account's default service
   */
  fetchUser(
    req: operations.FetchUserRequest,
    security: operations.FetchUserSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.FetchUserResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.FetchUserRequest(req);
    }

    let baseURL: string = operations.FetchUserServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(baseURL, "/v1/Users/{Sid}", req);
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.FetchUserSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.FetchUserResponse =
        new operations.FetchUserResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.conversationsV1User = utils.objectToClass(
              httpRes?.data,
              shared.ConversationsV1User
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Fetch a specific User Conversation.
   */
  fetchUserConversation(
    req: operations.FetchUserConversationRequest,
    security: operations.FetchUserConversationSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.FetchUserConversationResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.FetchUserConversationRequest(req);
    }

    let baseURL: string = operations.FetchUserConversationServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v1/Users/{UserSid}/Conversations/{ConversationSid}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.FetchUserConversationSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.FetchUserConversationResponse =
        new operations.FetchUserConversationResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.conversationsV1UserUserConversation = utils.objectToClass(
              httpRes?.data,
              shared.ConversationsV1UserUserConversation
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Retrieve a list of address configurations for an account
   */
  listConfigurationAddress(
    req: operations.ListConfigurationAddressRequest,
    security: operations.ListConfigurationAddressSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.ListConfigurationAddressResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ListConfigurationAddressRequest(req);
    }

    let baseURL: string = operations.ListConfigurationAddressServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string =
      baseURL.replace(/\/$/, "") + "/v1/Configuration/Addresses";
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ListConfigurationAddressSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ListConfigurationAddressResponse =
        new operations.ListConfigurationAddressResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listConfigurationAddressResponse = utils.objectToClass(
              httpRes?.data,
              operations.ListConfigurationAddressListConfigurationAddressResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Retrieve a list of conversations in your account's default service
   */
  listConversation(
    req: operations.ListConversationRequest,
    security: operations.ListConversationSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.ListConversationResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ListConversationRequest(req);
    }

    let baseURL: string = operations.ListConversationServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = baseURL.replace(/\/$/, "") + "/v1/Conversations";
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ListConversationSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ListConversationResponse =
        new operations.ListConversationResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listConversationResponse = utils.objectToClass(
              httpRes?.data,
              operations.ListConversationListConversationResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Retrieve a list of all messages in the conversation
   */
  listConversationMessage(
    req: operations.ListConversationMessageRequest,
    security: operations.ListConversationMessageSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.ListConversationMessageResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ListConversationMessageRequest(req);
    }

    let baseURL: string = operations.ListConversationMessageServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v1/Conversations/{ConversationSid}/Messages",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ListConversationMessageSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ListConversationMessageResponse =
        new operations.ListConversationMessageResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listConversationMessageResponse = utils.objectToClass(
              httpRes?.data,
              operations.ListConversationMessageListConversationMessageResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Retrieve a list of all delivery and read receipts of the conversation message
   */
  listConversationMessageReceipt(
    req: operations.ListConversationMessageReceiptRequest,
    security: operations.ListConversationMessageReceiptSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.ListConversationMessageReceiptResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ListConversationMessageReceiptRequest(req);
    }

    let baseURL: string =
      operations.ListConversationMessageReceiptServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v1/Conversations/{ConversationSid}/Messages/{MessageSid}/Receipts",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ListConversationMessageReceiptSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ListConversationMessageReceiptResponse =
        new operations.ListConversationMessageReceiptResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listConversationMessageReceiptResponse = utils.objectToClass(
              httpRes?.data,
              operations.ListConversationMessageReceiptListConversationMessageReceiptResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Retrieve a list of all participants of the conversation
   */
  listConversationParticipant(
    req: operations.ListConversationParticipantRequest,
    security: operations.ListConversationParticipantSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.ListConversationParticipantResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ListConversationParticipantRequest(req);
    }

    let baseURL: string = operations.ListConversationParticipantServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v1/Conversations/{ConversationSid}/Participants",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ListConversationParticipantSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ListConversationParticipantResponse =
        new operations.ListConversationParticipantResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listConversationParticipantResponse = utils.objectToClass(
              httpRes?.data,
              operations.ListConversationParticipantListConversationParticipantResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Retrieve a list of all webhooks scoped to the conversation
   */
  listConversationScopedWebhook(
    req: operations.ListConversationScopedWebhookRequest,
    security: operations.ListConversationScopedWebhookSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.ListConversationScopedWebhookResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ListConversationScopedWebhookRequest(req);
    }

    let baseURL: string = operations.ListConversationScopedWebhookServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v1/Conversations/{ConversationSid}/Webhooks",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ListConversationScopedWebhookSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ListConversationScopedWebhookResponse =
        new operations.ListConversationScopedWebhookResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listConversationScopedWebhookResponse = utils.objectToClass(
              httpRes?.data,
              operations.ListConversationScopedWebhookListConversationScopedWebhookResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Retrieve a list of all push notification credentials on your account
   */
  listCredential(
    req: operations.ListCredentialRequest,
    security: operations.ListCredentialSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.ListCredentialResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ListCredentialRequest(req);
    }

    let baseURL: string = operations.ListCredentialServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = baseURL.replace(/\/$/, "") + "/v1/Credentials";
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ListCredentialSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ListCredentialResponse =
        new operations.ListCredentialResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listCredentialResponse = utils.objectToClass(
              httpRes?.data,
              operations.ListCredentialListCredentialResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Retrieve a list of all Conversations that this Participant belongs to by identity or by address. Only one parameter should be specified.
   */
  listParticipantConversation(
    req: operations.ListParticipantConversationRequest,
    security: operations.ListParticipantConversationSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.ListParticipantConversationResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ListParticipantConversationRequest(req);
    }

    let baseURL: string = operations.ListParticipantConversationServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string =
      baseURL.replace(/\/$/, "") + "/v1/ParticipantConversations";
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ListParticipantConversationSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ListParticipantConversationResponse =
        new operations.ListParticipantConversationResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listParticipantConversationResponse = utils.objectToClass(
              httpRes?.data,
              operations.ListParticipantConversationListParticipantConversationResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Retrieve a list of all user roles in your account's default service
   */
  listRole(
    req: operations.ListRoleRequest,
    security: operations.ListRoleSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.ListRoleResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ListRoleRequest(req);
    }

    let baseURL: string = operations.ListRoleServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = baseURL.replace(/\/$/, "") + "/v1/Roles";
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ListRoleSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ListRoleResponse = new operations.ListRoleResponse({
        statusCode: httpRes.status,
        contentType: contentType,
        rawResponse: httpRes,
      });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listRoleResponse = utils.objectToClass(
              httpRes?.data,
              operations.ListRoleListRoleResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Retrieve a list of all conversation services on your account
   */
  listService(
    req: operations.ListServiceRequest,
    security: operations.ListServiceSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.ListServiceResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ListServiceRequest(req);
    }

    let baseURL: string = operations.ListServiceServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = baseURL.replace(/\/$/, "") + "/v1/Services";
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ListServiceSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ListServiceResponse =
        new operations.ListServiceResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listServiceResponse = utils.objectToClass(
              httpRes?.data,
              operations.ListServiceListServiceResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Retrieve a list of all push notification bindings in the conversation service
   */
  listServiceBinding(
    req: operations.ListServiceBindingRequest,
    security: operations.ListServiceBindingSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.ListServiceBindingResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ListServiceBindingRequest(req);
    }

    let baseURL: string = operations.ListServiceBindingServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v1/Services/{ChatServiceSid}/Bindings",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ListServiceBindingSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ListServiceBindingResponse =
        new operations.ListServiceBindingResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listServiceBindingResponse = utils.objectToClass(
              httpRes?.data,
              operations.ListServiceBindingListServiceBindingResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Retrieve a list of conversations in your service
   */
  listServiceConversation(
    req: operations.ListServiceConversationRequest,
    security: operations.ListServiceConversationSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.ListServiceConversationResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ListServiceConversationRequest(req);
    }

    let baseURL: string = operations.ListServiceConversationServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v1/Services/{ChatServiceSid}/Conversations",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ListServiceConversationSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ListServiceConversationResponse =
        new operations.ListServiceConversationResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listServiceConversationResponse = utils.objectToClass(
              httpRes?.data,
              operations.ListServiceConversationListServiceConversationResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Retrieve a list of all messages in the conversation
   */
  listServiceConversationMessage(
    req: operations.ListServiceConversationMessageRequest,
    security: operations.ListServiceConversationMessageSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.ListServiceConversationMessageResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ListServiceConversationMessageRequest(req);
    }

    let baseURL: string =
      operations.ListServiceConversationMessageServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v1/Services/{ChatServiceSid}/Conversations/{ConversationSid}/Messages",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ListServiceConversationMessageSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ListServiceConversationMessageResponse =
        new operations.ListServiceConversationMessageResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listServiceConversationMessageResponse = utils.objectToClass(
              httpRes?.data,
              operations.ListServiceConversationMessageListServiceConversationMessageResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Retrieve a list of all delivery and read receipts of the conversation message
   */
  listServiceConversationMessageReceipt(
    req: operations.ListServiceConversationMessageReceiptRequest,
    security: operations.ListServiceConversationMessageReceiptSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.ListServiceConversationMessageReceiptResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ListServiceConversationMessageReceiptRequest(req);
    }

    let baseURL: string =
      operations.ListServiceConversationMessageReceiptServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v1/Services/{ChatServiceSid}/Conversations/{ConversationSid}/Messages/{MessageSid}/Receipts",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ListServiceConversationMessageReceiptSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ListServiceConversationMessageReceiptResponse =
        new operations.ListServiceConversationMessageReceiptResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listServiceConversationMessageReceiptResponse =
              utils.objectToClass(
                httpRes?.data,
                operations.ListServiceConversationMessageReceiptListServiceConversationMessageReceiptResponse
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Retrieve a list of all participants of the conversation
   */
  listServiceConversationParticipant(
    req: operations.ListServiceConversationParticipantRequest,
    security: operations.ListServiceConversationParticipantSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.ListServiceConversationParticipantResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ListServiceConversationParticipantRequest(req);
    }

    let baseURL: string =
      operations.ListServiceConversationParticipantServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v1/Services/{ChatServiceSid}/Conversations/{ConversationSid}/Participants",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ListServiceConversationParticipantSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ListServiceConversationParticipantResponse =
        new operations.ListServiceConversationParticipantResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listServiceConversationParticipantResponse =
              utils.objectToClass(
                httpRes?.data,
                operations.ListServiceConversationParticipantListServiceConversationParticipantResponse
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Retrieve a list of all webhooks scoped to the conversation
   */
  listServiceConversationScopedWebhook(
    req: operations.ListServiceConversationScopedWebhookRequest,
    security: operations.ListServiceConversationScopedWebhookSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.ListServiceConversationScopedWebhookResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ListServiceConversationScopedWebhookRequest(req);
    }

    let baseURL: string =
      operations.ListServiceConversationScopedWebhookServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v1/Services/{ChatServiceSid}/Conversations/{ConversationSid}/Webhooks",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ListServiceConversationScopedWebhookSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ListServiceConversationScopedWebhookResponse =
        new operations.ListServiceConversationScopedWebhookResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listServiceConversationScopedWebhookResponse =
              utils.objectToClass(
                httpRes?.data,
                operations.ListServiceConversationScopedWebhookListServiceConversationScopedWebhookResponse
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Retrieve a list of all Conversations that this Participant belongs to by identity or by address. Only one parameter should be specified.
   */
  listServiceParticipantConversation(
    req: operations.ListServiceParticipantConversationRequest,
    security: operations.ListServiceParticipantConversationSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.ListServiceParticipantConversationResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ListServiceParticipantConversationRequest(req);
    }

    let baseURL: string =
      operations.ListServiceParticipantConversationServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v1/Services/{ChatServiceSid}/ParticipantConversations",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ListServiceParticipantConversationSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ListServiceParticipantConversationResponse =
        new operations.ListServiceParticipantConversationResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listServiceParticipantConversationResponse =
              utils.objectToClass(
                httpRes?.data,
                operations.ListServiceParticipantConversationListServiceParticipantConversationResponse
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Retrieve a list of all user roles in your service
   */
  listServiceRole(
    req: operations.ListServiceRoleRequest,
    security: operations.ListServiceRoleSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.ListServiceRoleResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ListServiceRoleRequest(req);
    }

    let baseURL: string = operations.ListServiceRoleServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v1/Services/{ChatServiceSid}/Roles",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ListServiceRoleSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ListServiceRoleResponse =
        new operations.ListServiceRoleResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listServiceRoleResponse = utils.objectToClass(
              httpRes?.data,
              operations.ListServiceRoleListServiceRoleResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Retrieve a list of all conversation users in your service
   */
  listServiceUser(
    req: operations.ListServiceUserRequest,
    security: operations.ListServiceUserSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.ListServiceUserResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ListServiceUserRequest(req);
    }

    let baseURL: string = operations.ListServiceUserServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v1/Services/{ChatServiceSid}/Users",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ListServiceUserSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ListServiceUserResponse =
        new operations.ListServiceUserResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listServiceUserResponse = utils.objectToClass(
              httpRes?.data,
              operations.ListServiceUserListServiceUserResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Retrieve a list of all User Conversations for the User.
   */
  listServiceUserConversation(
    req: operations.ListServiceUserConversationRequest,
    security: operations.ListServiceUserConversationSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.ListServiceUserConversationResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ListServiceUserConversationRequest(req);
    }

    let baseURL: string = operations.ListServiceUserConversationServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v1/Services/{ChatServiceSid}/Users/{UserSid}/Conversations",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ListServiceUserConversationSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ListServiceUserConversationResponse =
        new operations.ListServiceUserConversationResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listServiceUserConversationResponse = utils.objectToClass(
              httpRes?.data,
              operations.ListServiceUserConversationListServiceUserConversationResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Retrieve a list of all conversation users in your account's default service
   */
  listUser(
    req: operations.ListUserRequest,
    security: operations.ListUserSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.ListUserResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ListUserRequest(req);
    }

    let baseURL: string = operations.ListUserServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = baseURL.replace(/\/$/, "") + "/v1/Users";
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ListUserSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ListUserResponse = new operations.ListUserResponse({
        statusCode: httpRes.status,
        contentType: contentType,
        rawResponse: httpRes,
      });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listUserResponse = utils.objectToClass(
              httpRes?.data,
              operations.ListUserListUserResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Retrieve a list of all User Conversations for the User.
   */
  listUserConversation(
    req: operations.ListUserConversationRequest,
    security: operations.ListUserConversationSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.ListUserConversationResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ListUserConversationRequest(req);
    }

    let baseURL: string = operations.ListUserConversationServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v1/Users/{UserSid}/Conversations",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ListUserConversationSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ListUserConversationResponse =
        new operations.ListUserConversationResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listUserConversationResponse = utils.objectToClass(
              httpRes?.data,
              operations.ListUserConversationListUserConversationResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Update the global configuration of conversations on your account
   */
  updateConfiguration(
    req: operations.UpdateConfigurationUpdateConfigurationRequest,
    security: operations.UpdateConfigurationSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.UpdateConfigurationResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.UpdateConfigurationUpdateConfigurationRequest(req);
    }

    let baseURL: string = operations.UpdateConfigurationServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = baseURL.replace(/\/$/, "") + "/v1/Configuration";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "request",
        "form"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.UpdateConfigurationSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UpdateConfigurationResponse =
        new operations.UpdateConfigurationResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.conversationsV1Configuration = utils.objectToClass(
              httpRes?.data,
              shared.ConversationsV1Configuration
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Update an existing address configuration
   */
  updateConfigurationAddress(
    req: operations.UpdateConfigurationAddressRequest,
    security: operations.UpdateConfigurationAddressSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.UpdateConfigurationAddressResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.UpdateConfigurationAddressRequest(req);
    }

    let baseURL: string = operations.UpdateConfigurationAddressServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v1/Configuration/Addresses/{Sid}",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "form"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.UpdateConfigurationAddressSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UpdateConfigurationAddressResponse =
        new operations.UpdateConfigurationAddressResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.conversationsV1ConfigurationAddress = utils.objectToClass(
              httpRes?.data,
              shared.ConversationsV1ConfigurationAddress
            );
          }
          break;
      }

      return res;
    });
  }

  updateConfigurationWebhook(
    req: operations.UpdateConfigurationWebhookUpdateConfigurationWebhookRequest,
    security: operations.UpdateConfigurationWebhookSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.UpdateConfigurationWebhookResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.UpdateConfigurationWebhookUpdateConfigurationWebhookRequest(
          req
        );
    }

    let baseURL: string = operations.UpdateConfigurationWebhookServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string =
      baseURL.replace(/\/$/, "") + "/v1/Configuration/Webhooks";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "request",
        "form"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.UpdateConfigurationWebhookSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UpdateConfigurationWebhookResponse =
        new operations.UpdateConfigurationWebhookResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.conversationsV1ConfigurationConfigurationWebhook =
              utils.objectToClass(
                httpRes?.data,
                shared.ConversationsV1ConfigurationConfigurationWebhook
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Update an existing conversation in your account's default service
   */
  updateConversation(
    req: operations.UpdateConversationRequest,
    security: operations.UpdateConversationSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.UpdateConversationResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.UpdateConversationRequest(req);
    }

    let baseURL: string = operations.UpdateConversationServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v1/Conversations/{Sid}",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "form"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.UpdateConversationSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UpdateConversationResponse =
        new operations.UpdateConversationResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.conversationsV1Conversation = utils.objectToClass(
              httpRes?.data,
              shared.ConversationsV1Conversation
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Update an existing message in the conversation
   */
  updateConversationMessage(
    req: operations.UpdateConversationMessageRequest,
    security: operations.UpdateConversationMessageSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.UpdateConversationMessageResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.UpdateConversationMessageRequest(req);
    }

    let baseURL: string = operations.UpdateConversationMessageServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v1/Conversations/{ConversationSid}/Messages/{Sid}",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "form"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.UpdateConversationMessageSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UpdateConversationMessageResponse =
        new operations.UpdateConversationMessageResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.conversationsV1ConversationConversationMessage =
              utils.objectToClass(
                httpRes?.data,
                shared.ConversationsV1ConversationConversationMessage
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Update an existing participant in the conversation
   */
  updateConversationParticipant(
    req: operations.UpdateConversationParticipantRequest,
    security: operations.UpdateConversationParticipantSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.UpdateConversationParticipantResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.UpdateConversationParticipantRequest(req);
    }

    let baseURL: string = operations.UpdateConversationParticipantServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v1/Conversations/{ConversationSid}/Participants/{Sid}",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "form"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.UpdateConversationParticipantSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UpdateConversationParticipantResponse =
        new operations.UpdateConversationParticipantResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.conversationsV1ConversationConversationParticipant =
              utils.objectToClass(
                httpRes?.data,
                shared.ConversationsV1ConversationConversationParticipant
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Update an existing conversation-scoped webhook
   */
  updateConversationScopedWebhook(
    req: operations.UpdateConversationScopedWebhookRequest,
    security: operations.UpdateConversationScopedWebhookSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.UpdateConversationScopedWebhookResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.UpdateConversationScopedWebhookRequest(req);
    }

    let baseURL: string =
      operations.UpdateConversationScopedWebhookServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v1/Conversations/{ConversationSid}/Webhooks/{Sid}",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "form"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.UpdateConversationScopedWebhookSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UpdateConversationScopedWebhookResponse =
        new operations.UpdateConversationScopedWebhookResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.conversationsV1ConversationConversationScopedWebhook =
              utils.objectToClass(
                httpRes?.data,
                shared.ConversationsV1ConversationConversationScopedWebhook
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Update an existing push notification credential on your account
   */
  updateCredential(
    req: operations.UpdateCredentialRequest,
    security: operations.UpdateCredentialSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.UpdateCredentialResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.UpdateCredentialRequest(req);
    }

    let baseURL: string = operations.UpdateCredentialServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v1/Credentials/{Sid}",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "form"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.UpdateCredentialSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UpdateCredentialResponse =
        new operations.UpdateCredentialResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.conversationsV1Credential = utils.objectToClass(
              httpRes?.data,
              shared.ConversationsV1Credential
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Update an existing user role in your account's default service
   */
  updateRole(
    req: operations.UpdateRoleRequest,
    security: operations.UpdateRoleSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.UpdateRoleResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.UpdateRoleRequest(req);
    }

    let baseURL: string = operations.UpdateRoleServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(baseURL, "/v1/Roles/{Sid}", req);

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "form"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.UpdateRoleSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UpdateRoleResponse =
        new operations.UpdateRoleResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.conversationsV1Role = utils.objectToClass(
              httpRes?.data,
              shared.ConversationsV1Role
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Update configuration settings of a conversation service
   */
  updateServiceConfiguration(
    req: operations.UpdateServiceConfigurationRequest,
    security: operations.UpdateServiceConfigurationSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.UpdateServiceConfigurationResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.UpdateServiceConfigurationRequest(req);
    }

    let baseURL: string = operations.UpdateServiceConfigurationServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v1/Services/{ChatServiceSid}/Configuration",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "form"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.UpdateServiceConfigurationSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UpdateServiceConfigurationResponse =
        new operations.UpdateServiceConfigurationResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.conversationsV1ServiceServiceConfiguration =
              utils.objectToClass(
                httpRes?.data,
                shared.ConversationsV1ServiceServiceConfiguration
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Update an existing conversation in your service
   */
  updateServiceConversation(
    req: operations.UpdateServiceConversationRequest,
    security: operations.UpdateServiceConversationSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.UpdateServiceConversationResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.UpdateServiceConversationRequest(req);
    }

    let baseURL: string = operations.UpdateServiceConversationServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v1/Services/{ChatServiceSid}/Conversations/{Sid}",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "form"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.UpdateServiceConversationSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UpdateServiceConversationResponse =
        new operations.UpdateServiceConversationResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.conversationsV1ServiceServiceConversation = utils.objectToClass(
              httpRes?.data,
              shared.ConversationsV1ServiceServiceConversation
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Update an existing message in the conversation
   */
  updateServiceConversationMessage(
    req: operations.UpdateServiceConversationMessageRequest,
    security: operations.UpdateServiceConversationMessageSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.UpdateServiceConversationMessageResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.UpdateServiceConversationMessageRequest(req);
    }

    let baseURL: string =
      operations.UpdateServiceConversationMessageServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v1/Services/{ChatServiceSid}/Conversations/{ConversationSid}/Messages/{Sid}",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "form"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.UpdateServiceConversationMessageSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UpdateServiceConversationMessageResponse =
        new operations.UpdateServiceConversationMessageResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.conversationsV1ServiceServiceConversationServiceConversationMessage =
              utils.objectToClass(
                httpRes?.data,
                shared.ConversationsV1ServiceServiceConversationServiceConversationMessage
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Update an existing participant in the conversation
   */
  updateServiceConversationParticipant(
    req: operations.UpdateServiceConversationParticipantRequest,
    security: operations.UpdateServiceConversationParticipantSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.UpdateServiceConversationParticipantResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.UpdateServiceConversationParticipantRequest(req);
    }

    let baseURL: string =
      operations.UpdateServiceConversationParticipantServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v1/Services/{ChatServiceSid}/Conversations/{ConversationSid}/Participants/{Sid}",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "form"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.UpdateServiceConversationParticipantSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UpdateServiceConversationParticipantResponse =
        new operations.UpdateServiceConversationParticipantResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.conversationsV1ServiceServiceConversationServiceConversationParticipant =
              utils.objectToClass(
                httpRes?.data,
                shared.ConversationsV1ServiceServiceConversationServiceConversationParticipant
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Update an existing conversation-scoped webhook
   */
  updateServiceConversationScopedWebhook(
    req: operations.UpdateServiceConversationScopedWebhookRequest,
    security: operations.UpdateServiceConversationScopedWebhookSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.UpdateServiceConversationScopedWebhookResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.UpdateServiceConversationScopedWebhookRequest(req);
    }

    let baseURL: string =
      operations.UpdateServiceConversationScopedWebhookServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v1/Services/{ChatServiceSid}/Conversations/{ConversationSid}/Webhooks/{Sid}",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "form"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.UpdateServiceConversationScopedWebhookSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UpdateServiceConversationScopedWebhookResponse =
        new operations.UpdateServiceConversationScopedWebhookResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.conversationsV1ServiceServiceConversationServiceConversationScopedWebhook =
              utils.objectToClass(
                httpRes?.data,
                shared.ConversationsV1ServiceServiceConversationServiceConversationScopedWebhook
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Update push notification service settings
   */
  updateServiceNotification(
    req: operations.UpdateServiceNotificationRequest,
    security: operations.UpdateServiceNotificationSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.UpdateServiceNotificationResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.UpdateServiceNotificationRequest(req);
    }

    let baseURL: string = operations.UpdateServiceNotificationServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v1/Services/{ChatServiceSid}/Configuration/Notifications",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "form"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.UpdateServiceNotificationSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UpdateServiceNotificationResponse =
        new operations.UpdateServiceNotificationResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.conversationsV1ServiceServiceConfigurationServiceNotification =
              utils.objectToClass(
                httpRes?.data,
                shared.ConversationsV1ServiceServiceConfigurationServiceNotification
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Update an existing user role in your service
   */
  updateServiceRole(
    req: operations.UpdateServiceRoleRequest,
    security: operations.UpdateServiceRoleSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.UpdateServiceRoleResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.UpdateServiceRoleRequest(req);
    }

    let baseURL: string = operations.UpdateServiceRoleServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v1/Services/{ChatServiceSid}/Roles/{Sid}",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "form"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.UpdateServiceRoleSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UpdateServiceRoleResponse =
        new operations.UpdateServiceRoleResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.conversationsV1ServiceServiceRole = utils.objectToClass(
              httpRes?.data,
              shared.ConversationsV1ServiceServiceRole
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Update an existing conversation user in your service
   */
  updateServiceUser(
    req: operations.UpdateServiceUserRequest,
    security: operations.UpdateServiceUserSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.UpdateServiceUserResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.UpdateServiceUserRequest(req);
    }

    let baseURL: string = operations.UpdateServiceUserServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v1/Services/{ChatServiceSid}/Users/{Sid}",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "form"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.UpdateServiceUserSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UpdateServiceUserResponse =
        new operations.UpdateServiceUserResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.conversationsV1ServiceServiceUser = utils.objectToClass(
              httpRes?.data,
              shared.ConversationsV1ServiceServiceUser
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Update a specific User Conversation.
   */
  updateServiceUserConversation(
    req: operations.UpdateServiceUserConversationRequest,
    security: operations.UpdateServiceUserConversationSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.UpdateServiceUserConversationResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.UpdateServiceUserConversationRequest(req);
    }

    let baseURL: string = operations.UpdateServiceUserConversationServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v1/Services/{ChatServiceSid}/Users/{UserSid}/Conversations/{ConversationSid}",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "form"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.UpdateServiceUserConversationSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UpdateServiceUserConversationResponse =
        new operations.UpdateServiceUserConversationResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.conversationsV1ServiceServiceUserServiceUserConversation =
              utils.objectToClass(
                httpRes?.data,
                shared.ConversationsV1ServiceServiceUserServiceUserConversation
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Update a specific Webhook.
   */
  updateServiceWebhookConfiguration(
    req: operations.UpdateServiceWebhookConfigurationRequest,
    security: operations.UpdateServiceWebhookConfigurationSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.UpdateServiceWebhookConfigurationResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.UpdateServiceWebhookConfigurationRequest(req);
    }

    let baseURL: string =
      operations.UpdateServiceWebhookConfigurationServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v1/Services/{ChatServiceSid}/Configuration/Webhooks",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "form"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.UpdateServiceWebhookConfigurationSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UpdateServiceWebhookConfigurationResponse =
        new operations.UpdateServiceWebhookConfigurationResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.conversationsV1ServiceServiceConfigurationServiceWebhookConfiguration =
              utils.objectToClass(
                httpRes?.data,
                shared.ConversationsV1ServiceServiceConfigurationServiceWebhookConfiguration
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Update an existing conversation user in your account's default service
   */
  updateUser(
    req: operations.UpdateUserRequest,
    security: operations.UpdateUserSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.UpdateUserResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.UpdateUserRequest(req);
    }

    let baseURL: string = operations.UpdateUserServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(baseURL, "/v1/Users/{Sid}", req);

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "form"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.UpdateUserSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UpdateUserResponse =
        new operations.UpdateUserResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.conversationsV1User = utils.objectToClass(
              httpRes?.data,
              shared.ConversationsV1User
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Update a specific User Conversation.
   */
  updateUserConversation(
    req: operations.UpdateUserConversationRequest,
    security: operations.UpdateUserConversationSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.UpdateUserConversationResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.UpdateUserConversationRequest(req);
    }

    let baseURL: string = operations.UpdateUserConversationServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v1/Users/{UserSid}/Conversations/{ConversationSid}",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "form"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.UpdateUserConversationSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UpdateUserConversationResponse =
        new operations.UpdateUserConversationResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.conversationsV1UserUserConversation = utils.objectToClass(
              httpRes?.data,
              shared.ConversationsV1UserUserConversation
            );
          }
          break;
      }

      return res;
    });
  }
}
