/* 
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

package org.openapis.openapi.models.shared;

import com.fasterxml.jackson.annotation.JsonInclude.Include;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.databind.annotation.JsonDeserialize;
import com.fasterxml.jackson.databind.annotation.JsonSerialize;
import java.time.OffsetDateTime;
import org.openapis.openapi.utils.DateTimeDeserializer;
import org.openapis.openapi.utils.DateTimeSerializer;

public class Activity {
    /**
     * Address of activity
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("address")
    public ResponseAddress address;
    public Activity withAddress(ResponseAddress address) {
        this.address = address;
        return this;
    }
    
    /**
     * Arrival date time with offset like this 1970-01-01T01:00+01:00. If you do not use time-dependent optimization, this is `null`.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonSerialize(using = DateTimeSerializer.class)
    @JsonDeserialize(using = DateTimeDeserializer.class)
    @JsonProperty("arr_date_time")
    public OffsetDateTime arrDateTime;
    public Activity withArrDateTime(OffsetDateTime arrDateTime) {
        this.arrDateTime = arrDateTime;
        return this;
    }
    
    /**
     * Arrival time at this activity in seconds. If type is `start`, this is not available (since it makes no sense to have `arr_time` at start). However, `end_time` is available and actually means \"departure time\" at start location. It is important to note that `arr_time` does not necessarily mean \"start of underlying activity\", it solely means arrival time at activity location. If this activity has no time windows and if there are no further preparation times, `arr_time` is equal to activity start time.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("arr_time")
    public Long arrTime;
    public Activity withArrTime(Long arrTime) {
        this.arrTime = arrTime;
        return this;
    }
    
    /**
     * cumulated distance from start to this activity in m
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("distance")
    public Long distance;
    public Activity withDistance(Long distance) {
        this.distance = distance;
        return this;
    }
    
    /**
     * cumulated driving time from start to this driver activity in seconds
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("driving_time")
    public Long drivingTime;
    public Activity withDrivingTime(Long drivingTime) {
        this.drivingTime = drivingTime;
        return this;
    }
    
    /**
     * End date time with offset like this 1970-01-01T01:00+01:00. If you do not use time-dependent optimization, this is `null`.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonSerialize(using = DateTimeSerializer.class)
    @JsonDeserialize(using = DateTimeDeserializer.class)
    @JsonProperty("end_date_time")
    public OffsetDateTime endDateTime;
    public Activity withEndDateTime(OffsetDateTime endDateTime) {
        this.endDateTime = endDateTime;
        return this;
    }
    
    /**
     * End time of and thus departure time at this activity. If type is `end`, this is not available (since it makes no sense to have an `end_time` at end) `end_time` at each activity is equal to the departure time at the activity location.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("end_time")
    public Long endTime;
    public Activity withEndTime(Long endTime) {
        this.endTime = endTime;
        return this;
    }
    
    /**
     * Id referring to the underlying service or shipment, i.e. the shipment or service this activity belongs to
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("id")
    public String id;
    public Activity withId(String id) {
        this.id = id;
        return this;
    }
    
    /**
     * Array with size/capacity dimensions after this activity
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("load_after")
    public Integer[] loadAfter;
    public Activity withLoadAfter(Integer[] loadAfter) {
        this.loadAfter = loadAfter;
        return this;
    }
    
    /**
     * Array with size/capacity dimensions before this activity
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("load_before")
    public Integer[] loadBefore;
    public Activity withLoadBefore(Integer[] loadBefore) {
        this.loadBefore = loadBefore;
        return this;
    }
    
    /**
     * Id that refers to address
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("location_id")
    public String locationId;
    public Activity withLocationId(String locationId) {
        this.locationId = locationId;
        return this;
    }
    
    /**
     * preparation time at this activity in seconds
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("preparation_time")
    public Long preparationTime;
    public Activity withPreparationTime(Long preparationTime) {
        this.preparationTime = preparationTime;
        return this;
    }
    
    /**
     * type of activity
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("type")
    public ActivityTypeEnum type;
    public Activity withType(ActivityTypeEnum type) {
        this.type = type;
        return this;
    }
    
    /**
     * Waiting time at this activity in seconds. A waiting time can occur if the activity has at least one time window. If `arr_time` &lt; `time_window.earliest` a waiting time of `time_window_earliest` - `arr_time` occurs.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("waiting_time")
    public Long waitingTime;
    public Activity withWaitingTime(Long waitingTime) {
        this.waitingTime = waitingTime;
        return this;
    }
    
}
