// Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.

package shared

import (
	"bytes"
	"encoding/json"
	"errors"
	"fmt"
)

// CreateCallRequestNccoEventMethodEnum - The HTTP method used to send event information to `event_url`.
type CreateCallRequestNccoEventMethodEnum string

const (
	CreateCallRequestNccoEventMethodEnumPost CreateCallRequestNccoEventMethodEnum = "POST"
	CreateCallRequestNccoEventMethodEnumGet  CreateCallRequestNccoEventMethodEnum = "GET"
)

func (e CreateCallRequestNccoEventMethodEnum) ToPointer() *CreateCallRequestNccoEventMethodEnum {
	return &e
}

func (e *CreateCallRequestNccoEventMethodEnum) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "POST":
		fallthrough
	case "GET":
		*e = CreateCallRequestNccoEventMethodEnum(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CreateCallRequestNccoEventMethodEnum: %v", v)
	}
}

// CreateCallRequestNccoMachineDetectionEnum - Configure the behavior when Vonage detects that the call is answered by voicemail. If `continue`, Vonage sends an HTTP request to `event_url` with the Call event machine. If `hangup`, Vonage ends the call.
type CreateCallRequestNccoMachineDetectionEnum string

const (
	CreateCallRequestNccoMachineDetectionEnumContinue CreateCallRequestNccoMachineDetectionEnum = "continue"
	CreateCallRequestNccoMachineDetectionEnumHangup   CreateCallRequestNccoMachineDetectionEnum = "hangup"
)

func (e CreateCallRequestNccoMachineDetectionEnum) ToPointer() *CreateCallRequestNccoMachineDetectionEnum {
	return &e
}

func (e *CreateCallRequestNccoMachineDetectionEnum) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "continue":
		fallthrough
	case "hangup":
		*e = CreateCallRequestNccoMachineDetectionEnum(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CreateCallRequestNccoMachineDetectionEnum: %v", v)
	}
}

type CreateCallRequestNccoToType string

const (
	CreateCallRequestNccoToTypeEndpointPhoneTo      CreateCallRequestNccoToType = "EndpointPhoneTo"
	CreateCallRequestNccoToTypeEndpointSip          CreateCallRequestNccoToType = "EndpointSip"
	CreateCallRequestNccoToTypeEndpointWebsocket    CreateCallRequestNccoToType = "EndpointWebsocket"
	CreateCallRequestNccoToTypeEndpointVBCExtension CreateCallRequestNccoToType = "EndpointVBCExtension"
)

type CreateCallRequestNccoTo struct {
	EndpointPhoneTo      *EndpointPhoneTo
	EndpointSip          *EndpointSip
	EndpointWebsocket    *EndpointWebsocket
	EndpointVBCExtension *EndpointVBCExtension

	Type CreateCallRequestNccoToType
}

func CreateCreateCallRequestNccoToEndpointPhoneTo(endpointPhoneTo EndpointPhoneTo) CreateCallRequestNccoTo {
	typ := CreateCallRequestNccoToTypeEndpointPhoneTo

	return CreateCallRequestNccoTo{
		EndpointPhoneTo: &endpointPhoneTo,
		Type:            typ,
	}
}

func CreateCreateCallRequestNccoToEndpointSip(endpointSip EndpointSip) CreateCallRequestNccoTo {
	typ := CreateCallRequestNccoToTypeEndpointSip

	return CreateCallRequestNccoTo{
		EndpointSip: &endpointSip,
		Type:        typ,
	}
}

func CreateCreateCallRequestNccoToEndpointWebsocket(endpointWebsocket EndpointWebsocket) CreateCallRequestNccoTo {
	typ := CreateCallRequestNccoToTypeEndpointWebsocket

	return CreateCallRequestNccoTo{
		EndpointWebsocket: &endpointWebsocket,
		Type:              typ,
	}
}

func CreateCreateCallRequestNccoToEndpointVBCExtension(endpointVBCExtension EndpointVBCExtension) CreateCallRequestNccoTo {
	typ := CreateCallRequestNccoToTypeEndpointVBCExtension

	return CreateCallRequestNccoTo{
		EndpointVBCExtension: &endpointVBCExtension,
		Type:                 typ,
	}
}

func (u *CreateCallRequestNccoTo) UnmarshalJSON(data []byte) error {
	var d *json.Decoder

	endpointPhoneTo := new(EndpointPhoneTo)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&endpointPhoneTo); err == nil {
		u.EndpointPhoneTo = endpointPhoneTo
		u.Type = CreateCallRequestNccoToTypeEndpointPhoneTo
		return nil
	}

	endpointSip := new(EndpointSip)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&endpointSip); err == nil {
		u.EndpointSip = endpointSip
		u.Type = CreateCallRequestNccoToTypeEndpointSip
		return nil
	}

	endpointWebsocket := new(EndpointWebsocket)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&endpointWebsocket); err == nil {
		u.EndpointWebsocket = endpointWebsocket
		u.Type = CreateCallRequestNccoToTypeEndpointWebsocket
		return nil
	}

	endpointVBCExtension := new(EndpointVBCExtension)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&endpointVBCExtension); err == nil {
		u.EndpointVBCExtension = endpointVBCExtension
		u.Type = CreateCallRequestNccoToTypeEndpointVBCExtension
		return nil
	}

	return errors.New("could not unmarshal into supported union types")
}

func (u CreateCallRequestNccoTo) MarshalJSON() ([]byte, error) {
	if u.EndpointPhoneTo != nil {
		return json.Marshal(u.EndpointPhoneTo)
	}

	if u.EndpointSip != nil {
		return json.Marshal(u.EndpointSip)
	}

	if u.EndpointWebsocket != nil {
		return json.Marshal(u.EndpointWebsocket)
	}

	if u.EndpointVBCExtension != nil {
		return json.Marshal(u.EndpointVBCExtension)
	}

	return nil, nil
}

type CreateCallRequestNcco struct {
	// The HTTP method used to send event information to `event_url`.
	EventMethod *CreateCallRequestNccoEventMethodEnum `json:"event_method,omitempty"`
	// **Required** unless `event_url` is configured at the application
	// level, see [Create an Application](/api/application.v2#createApplication)
	//
	// The webhook endpoint where call progress events are
	// sent to. For more information about the values sent, see
	// [Event webhook](/voice/voice-api/webhook-reference#event-webhook).
	//
	EventURL []string `json:"event_url,omitempty"`
	// Connect to a Phone (PSTN) number
	From EndpointPhoneFrom `json:"from"`
	// Set the number of seconds that elapse before Vonage hangs up after the call state changes to answered.
	LengthTimer *int64 `json:"length_timer,omitempty"`
	// Configure the behavior when Vonage detects that the call is answered by voicemail. If `continue`, Vonage sends an HTTP request to `event_url` with the Call event machine. If `hangup`, Vonage ends the call.
	MachineDetection *CreateCallRequestNccoMachineDetectionEnum `json:"machine_detection,omitempty"`
	// The [Nexmo Call Control Object](/voice/voice-api/ncco-reference) to use for this call.
	//
	Ncco []map[string]interface{} `json:"ncco"`
	// Set to `true` to use random phone number as `from`. The number will be selected from the list of the numbers assigned to the current application. `random_from_number: true` cannot be used together with `from`.
	RandomFromNumber *bool `json:"random_from_number,omitempty"`
	// Set the number of seconds that elapse before Vonage hangs up after the call state changes to ‘ringing’.
	RingingTimer *int64                    `json:"ringing_timer,omitempty"`
	To           []CreateCallRequestNccoTo `json:"to"`
}
