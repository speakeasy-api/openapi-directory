<?php

/**
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

declare(strict_types=1);

namespace OpenAPI\OpenAPI;

/**
 * SDK - RiteKit API is based on REST principles.
 * 
 * 
 * Authentication uses standard OAuth 2.0 process
 * 
 * ##Getting started
 * 
 * 1. Sign up for [RiteKit](https://ritekit.com/)
 * 
 * 1. Go to [developer dashboard](https://ritekit.com/developer/dashboard/)
 * 
 * 1. Click "Create a token" button to get your **Client ID** and **Client secret**
 * 
 * 1. When you reach your free limit of calls per month, [upgrade to paid tiers](https://ritekit.com/developer/)
 * 
 * ## Options for authorizing API Calls
 * 
 * #### Using Client ID directly
 * 
 * You can directly connect to our API using your **client ID** by sending it as a GET query parameter. This option is simple (no need for oAuth) but it should be used only in case the Client ID is not exposed publicly.
 * 
 * GET  https://api.ritekit.com/v1/stats/multiple-hashtags?tags=php&client_id=292c6912e7710c838347ae178b4a
 * 
 * @package OpenAPI\OpenAPI
 * @access public
 */
class SDK
{
	public const SERVERS = [
		'https://api.ritekit.com',
	];
  		
	// SDK private variables namespaced with _ to avoid conflicts with API models
	private ?\GuzzleHttp\ClientInterface $_defaultClient;
	private ?\GuzzleHttp\ClientInterface $_securityClient;
	
	private string $_serverUrl;
	private string $_language = 'php';
	private string $_sdkVersion = '0.0.1';
	private string $_genVersion = 'internal';

	/**
	 * Returns a new instance of the SDK builder used to configure and create the SDK instance.
	 * 
	 * @return SDKBuilder
	 */
	public static function builder(): SDKBuilder
	{
		return new SDKBuilder();
	}

	/**
	 * @param \GuzzleHttp\ClientInterface|null $client
	 * @param string $serverUrl
	 * @param array<string, string>|null $params
	 */
	public function __construct(?\GuzzleHttp\ClientInterface $client, string $serverUrl, ?array $params)
	{
		$this->_defaultClient = $client;
		
		if ($this->_defaultClient === null) {
			$this->_defaultClient = new \GuzzleHttp\Client([
				'timeout' => 60,
			]);
		}

		$this->_securityClient = null;
		if ($this->_securityClient === null) {
			$this->_securityClient = $this->_defaultClient;
		}

		if (!empty($serverUrl)) {
			$this->_serverUrl = Utils\Utils::templateUrl($serverUrl, $params);
		}
		
		if (empty($this->_serverUrl)) {
			$this->_serverUrl = $this::SERVERS[0];
		}
	}
	
    /**
     * Animate Image
     * 
     * Returns URL of an animated GIF.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\AnimateImageRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\AnimateImageResponse
     */
	public function animateImage(
        \OpenAPI\OpenAPI\Models\Operations\AnimateImageRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\AnimateImageResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v1/images/animate');
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\AnimateImageRequest::class, $request, null));
        
        $httpResponse = $this->_defaultClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\AnimateImageResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
        }

        return $response;
    }
	
    /**
     * Auto-Emojify
     * 
     * Returns text of the post with emoji added
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\AutoEmojifyRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\AutoEmojifyResponse
     */
	public function autoEmojify(
        \OpenAPI\OpenAPI\Models\Operations\AutoEmojifyRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\AutoEmojifyResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v1/emoji/auto-emojify');
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\AutoEmojifyRequest::class, $request, null));
        
        $httpResponse = $this->_defaultClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\AutoEmojifyResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
        }

        return $response;
    }
	
    /**
     * Auto-Hashtag
     * 
     * Returns auto-hashtagged text of the post.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\AutoHashtagRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\AutoHashtagResponse
     */
	public function autoHashtag(
        \OpenAPI\OpenAPI\Models\Operations\AutoHashtagRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\AutoHashtagResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v1/stats/auto-hashtag');
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\AutoHashtagRequest::class, $request, null));
        
        $httpResponse = $this->_defaultClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\AutoHashtagResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
        }

        return $response;
    }
	
    /**
     * Company Logo
     * 
     * Returns a company logo based on website domain. If the logo is not in our database yet, it will be extracted from the site on the fly. White logo background is automatically removed to make the logo look better on color backgrounds.
     * 
     * Note: It is not possible to access our company logo API publicly without authentication. If you wish to do so, you have to create proxy on your own server that calls our API from the server side.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\CompanyLogoRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\CompanyLogoResponse
     */
	public function companyLogo(
        \OpenAPI\OpenAPI\Models\Operations\CompanyLogoRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\CompanyLogoResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v1/images/logo');
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\CompanyLogoRequest::class, $request, null));
        
        $httpResponse = $this->_defaultClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\CompanyLogoResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
        }

        return $response;
    }
	
    /**
     * Emoji Suggestions
     * 
     * Returns list of emoji suggestions for a given text of the post
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\EmojiSuggestionsRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\EmojiSuggestionsResponse
     */
	public function emojiSuggestions(
        \OpenAPI\OpenAPI\Models\Operations\EmojiSuggestionsRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\EmojiSuggestionsResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v1/emoji/suggestions');
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\EmojiSuggestionsRequest::class, $request, null));
        
        $httpResponse = $this->_defaultClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\EmojiSuggestionsResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
        }

        return $response;
    }
	
    /**
     * Hashtag History
     * 
     * Returns historical stats for a given hashtag from the last 30 days
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\HashtagHistoryRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\HashtagHistoryResponse
     */
	public function hashtagHistory(
        \OpenAPI\OpenAPI\Models\Operations\HashtagHistoryRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\HashtagHistoryResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v1/stats/history/{hashtag}', \OpenAPI\OpenAPI\Models\Operations\HashtagHistoryRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_defaultClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\HashtagHistoryResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
        }

        return $response;
    }
	
    /**
     * Hashtag Stats
     * 
     * Returns real-time stats for up to 100 hashtags (updated hourly).
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\HashtagStatsRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\HashtagStatsResponse
     */
	public function hashtagStats(
        \OpenAPI\OpenAPI\Models\Operations\HashtagStatsRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\HashtagStatsResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v1/stats/multiple-hashtags');
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\HashtagStatsRequest::class, $request, null));
        
        $httpResponse = $this->_defaultClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\HashtagStatsResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
        }

        return $response;
    }
	
    /**
     * Hashtag Suggestions
     * 
     * Returns list of hashtag suggestions for a single-word topic or a shorter text up to 1000 characters. Takes into account both semantic relevancy and real-time hashtag popularity.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\HashtagSuggestionsRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\HashtagSuggestionsResponse
     */
	public function hashtagSuggestions(
        \OpenAPI\OpenAPI\Models\Operations\HashtagSuggestionsRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\HashtagSuggestionsResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v1/stats/hashtag-suggestions');
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\HashtagSuggestionsRequest::class, $request, null));
        
        $httpResponse = $this->_defaultClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\HashtagSuggestionsResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
        }

        return $response;
    }
	
    /**
     * Hashtags cleaner
     * 
     * Remove banned hashtags before posting to Instagram
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\HashtagsCleanerRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\HashtagsCleanerResponse
     */
	public function hashtagsCleaner(
        \OpenAPI\OpenAPI\Models\Operations\HashtagsCleanerRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\HashtagsCleanerResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v2/instagram/hashtags-cleaner');
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\HashtagsCleanerRequest::class, $request, null));
        
        $httpResponse = $this->_defaultClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\HashtagsCleanerResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
        }

        return $response;
    }
	
    /**
     * List of CTAs
     * 
     * Returns list of available CTA for current user. Requires each user to authenticate with RiteKit
     * 
     * @return \OpenAPI\OpenAPI\Models\Operations\ListOfCTAsResponse
     */
	public function listOfCTAs(
    ): \OpenAPI\OpenAPI\Models\Operations\ListOfCTAsResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v1/link/cta');
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_defaultClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\ListOfCTAsResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
        }

        return $response;
    }
	
    /**
     * Shorten Link
     * 
     * Returns a shorten link with a given CTA.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\ShortenLinkRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\ShortenLinkResponse
     */
	public function shortenLink(
        \OpenAPI\OpenAPI\Models\Operations\ShortenLinkRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\ShortenLinkResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v1/link/short-link');
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\ShortenLinkRequest::class, $request, null));
        
        $httpResponse = $this->_defaultClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\ShortenLinkResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
        }

        return $response;
    }
	
    /**
     * Text to Image
     * 
     * Returns URL of an image created from text according to given style parameters
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\TextToImageRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\TextToImageResponse
     */
	public function textToImage(
        \OpenAPI\OpenAPI\Models\Operations\TextToImageRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\TextToImageResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v1/images/quote');
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\TextToImageRequest::class, $request, null));
        
        $httpResponse = $this->_defaultClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\TextToImageResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
        }

        return $response;
    }
	
    /**
     * Trending Hashtags
     * 
     * Returns list of hashtags currently trending on Twitter
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\TrendingHashtagsRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\TrendingHashtagsResponse
     */
	public function trendingHashtags(
        \OpenAPI\OpenAPI\Models\Operations\TrendingHashtagsRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\TrendingHashtagsResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v1/search/trending');
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\TrendingHashtagsRequest::class, $request, null));
        
        $httpResponse = $this->_defaultClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\TrendingHashtagsResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
        }

        return $response;
    }
}