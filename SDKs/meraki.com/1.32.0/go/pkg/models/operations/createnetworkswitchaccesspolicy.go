// Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.

package operations

import (
	"encoding/json"
	"fmt"
	"net/http"
)

// CreateNetworkSwitchAccessPolicyRequestBodyAccessPolicyTypeEnum - Access Type of the policy. Automatically 'Hybrid authentication' when hostMode is 'Multi-Domain'.
type CreateNetworkSwitchAccessPolicyRequestBodyAccessPolicyTypeEnum string

const (
	CreateNetworkSwitchAccessPolicyRequestBodyAccessPolicyTypeEnumEightHundredAndTwo1x    CreateNetworkSwitchAccessPolicyRequestBodyAccessPolicyTypeEnum = "802.1x"
	CreateNetworkSwitchAccessPolicyRequestBodyAccessPolicyTypeEnumHybridAuthentication    CreateNetworkSwitchAccessPolicyRequestBodyAccessPolicyTypeEnum = "Hybrid authentication"
	CreateNetworkSwitchAccessPolicyRequestBodyAccessPolicyTypeEnumMacAuthenticationBypass CreateNetworkSwitchAccessPolicyRequestBodyAccessPolicyTypeEnum = "MAC authentication bypass"
)

func (e CreateNetworkSwitchAccessPolicyRequestBodyAccessPolicyTypeEnum) ToPointer() *CreateNetworkSwitchAccessPolicyRequestBodyAccessPolicyTypeEnum {
	return &e
}

func (e *CreateNetworkSwitchAccessPolicyRequestBodyAccessPolicyTypeEnum) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "802.1x":
		fallthrough
	case "Hybrid authentication":
		fallthrough
	case "MAC authentication bypass":
		*e = CreateNetworkSwitchAccessPolicyRequestBodyAccessPolicyTypeEnum(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CreateNetworkSwitchAccessPolicyRequestBodyAccessPolicyTypeEnum: %v", v)
	}
}

// CreateNetworkSwitchAccessPolicyRequestBodyDot1xControlDirectionEnum - Supports either 'both' or 'inbound'. Set to 'inbound' to allow unauthorized egress on the switchport. Set to 'both' to control both traffic directions with authorization. Defaults to 'both'
type CreateNetworkSwitchAccessPolicyRequestBodyDot1xControlDirectionEnum string

const (
	CreateNetworkSwitchAccessPolicyRequestBodyDot1xControlDirectionEnumBoth    CreateNetworkSwitchAccessPolicyRequestBodyDot1xControlDirectionEnum = "both"
	CreateNetworkSwitchAccessPolicyRequestBodyDot1xControlDirectionEnumInbound CreateNetworkSwitchAccessPolicyRequestBodyDot1xControlDirectionEnum = "inbound"
)

func (e CreateNetworkSwitchAccessPolicyRequestBodyDot1xControlDirectionEnum) ToPointer() *CreateNetworkSwitchAccessPolicyRequestBodyDot1xControlDirectionEnum {
	return &e
}

func (e *CreateNetworkSwitchAccessPolicyRequestBodyDot1xControlDirectionEnum) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "both":
		fallthrough
	case "inbound":
		*e = CreateNetworkSwitchAccessPolicyRequestBodyDot1xControlDirectionEnum(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CreateNetworkSwitchAccessPolicyRequestBodyDot1xControlDirectionEnum: %v", v)
	}
}

// CreateNetworkSwitchAccessPolicyRequestBodyDot1x - 802.1x Settings
type CreateNetworkSwitchAccessPolicyRequestBodyDot1x struct {
	// Supports either 'both' or 'inbound'. Set to 'inbound' to allow unauthorized egress on the switchport. Set to 'both' to control both traffic directions with authorization. Defaults to 'both'
	ControlDirection *CreateNetworkSwitchAccessPolicyRequestBodyDot1xControlDirectionEnum `json:"controlDirection,omitempty"`
}

// CreateNetworkSwitchAccessPolicyRequestBodyHostModeEnum - Choose the Host Mode for the access policy.
type CreateNetworkSwitchAccessPolicyRequestBodyHostModeEnum string

const (
	CreateNetworkSwitchAccessPolicyRequestBodyHostModeEnumMultiAuth   CreateNetworkSwitchAccessPolicyRequestBodyHostModeEnum = "Multi-Auth"
	CreateNetworkSwitchAccessPolicyRequestBodyHostModeEnumMultiDomain CreateNetworkSwitchAccessPolicyRequestBodyHostModeEnum = "Multi-Domain"
	CreateNetworkSwitchAccessPolicyRequestBodyHostModeEnumMultiHost   CreateNetworkSwitchAccessPolicyRequestBodyHostModeEnum = "Multi-Host"
	CreateNetworkSwitchAccessPolicyRequestBodyHostModeEnumSingleHost  CreateNetworkSwitchAccessPolicyRequestBodyHostModeEnum = "Single-Host"
)

func (e CreateNetworkSwitchAccessPolicyRequestBodyHostModeEnum) ToPointer() *CreateNetworkSwitchAccessPolicyRequestBodyHostModeEnum {
	return &e
}

func (e *CreateNetworkSwitchAccessPolicyRequestBodyHostModeEnum) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "Multi-Auth":
		fallthrough
	case "Multi-Domain":
		fallthrough
	case "Multi-Host":
		fallthrough
	case "Single-Host":
		*e = CreateNetworkSwitchAccessPolicyRequestBodyHostModeEnum(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CreateNetworkSwitchAccessPolicyRequestBodyHostModeEnum: %v", v)
	}
}

// CreateNetworkSwitchAccessPolicyRequestBodyRadiusCriticalAuth - Critical auth settings for when authentication is rejected by the RADIUS server
type CreateNetworkSwitchAccessPolicyRequestBodyRadiusCriticalAuth struct {
	// VLAN that clients who use data will be placed on when RADIUS authentication fails. Will be null if hostMode is Multi-Auth
	DataVlanID *int64 `json:"dataVlanId,omitempty"`
	// Enable to suspend port bounce when RADIUS servers are unreachable
	SuspendPortBounce *bool `json:"suspendPortBounce,omitempty"`
	// VLAN that clients who use voice will be placed on when RADIUS authentication fails. Will be null if hostMode is Multi-Auth
	VoiceVlanID *int64 `json:"voiceVlanId,omitempty"`
}

// CreateNetworkSwitchAccessPolicyRequestBodyRadius - Object for RADIUS Settings
type CreateNetworkSwitchAccessPolicyRequestBodyRadius struct {
	// Critical auth settings for when authentication is rejected by the RADIUS server
	CriticalAuth *CreateNetworkSwitchAccessPolicyRequestBodyRadiusCriticalAuth `json:"criticalAuth,omitempty"`
	// VLAN that clients will be placed on when RADIUS authentication fails. Will be null if hostMode is Multi-Auth
	FailedAuthVlanID *int64 `json:"failedAuthVlanId,omitempty"`
	// Re-authentication period in seconds. Will be null if hostMode is Multi-Auth
	ReAuthenticationInterval *int64 `json:"reAuthenticationInterval,omitempty"`
}

type CreateNetworkSwitchAccessPolicyRequestBodyRadiusAccountingServers struct {
	// Public IP address of the RADIUS accounting server
	Host string `json:"host"`
	// UDP port that the RADIUS Accounting server listens on for access requests
	Port int64 `json:"port"`
	// RADIUS client shared secret
	Secret string `json:"secret"`
}

type CreateNetworkSwitchAccessPolicyRequestBodyRadiusServers struct {
	// Public IP address of the RADIUS server
	Host string `json:"host"`
	// UDP port that the RADIUS server listens on for access requests
	Port int64 `json:"port"`
	// RADIUS client shared secret
	Secret string `json:"secret"`
}

type CreateNetworkSwitchAccessPolicyRequestBody struct {
	// Access Type of the policy. Automatically 'Hybrid authentication' when hostMode is 'Multi-Domain'.
	AccessPolicyType *CreateNetworkSwitchAccessPolicyRequestBodyAccessPolicyTypeEnum `json:"accessPolicyType,omitempty"`
	// 802.1x Settings
	Dot1x *CreateNetworkSwitchAccessPolicyRequestBodyDot1x `json:"dot1x,omitempty"`
	// If enabled, Meraki devices will periodically send access-request messages to these RADIUS servers
	GuestPortBouncing *bool `json:"guestPortBouncing,omitempty"`
	// ID for the guest VLAN allow unauthorized devices access to limited network resources
	GuestVlanID *int64 `json:"guestVlanId,omitempty"`
	// Choose the Host Mode for the access policy.
	HostMode CreateNetworkSwitchAccessPolicyRequestBodyHostModeEnum `json:"hostMode"`
	// Enabling this option will make switches execute 802.1X and MAC-bypass authentication simultaneously so that clients authenticate faster. Only required when accessPolicyType is 'Hybrid Authentication.
	IncreaseAccessSpeed *bool `json:"increaseAccessSpeed,omitempty"`
	// Name of the access policy
	Name string `json:"name"`
	// Object for RADIUS Settings
	Radius *CreateNetworkSwitchAccessPolicyRequestBodyRadius `json:"radius,omitempty"`
	// Enable to send start, interim-update and stop messages to a configured RADIUS accounting server for tracking connected clients
	RadiusAccountingEnabled bool `json:"radiusAccountingEnabled"`
	// List of RADIUS accounting servers to require connecting devices to authenticate against before granting network access
	RadiusAccountingServers []CreateNetworkSwitchAccessPolicyRequestBodyRadiusAccountingServers `json:"radiusAccountingServers,omitempty"`
	// Change of authentication for RADIUS re-authentication and disconnection
	RadiusCoaSupportEnabled bool `json:"radiusCoaSupportEnabled"`
	// Acceptable values are `""` for None, or `"11"` for Group Policies ACL
	RadiusGroupAttribute *string `json:"radiusGroupAttribute,omitempty"`
	// List of RADIUS servers to require connecting devices to authenticate against before granting network access
	RadiusServers []CreateNetworkSwitchAccessPolicyRequestBodyRadiusServers `json:"radiusServers"`
	// If enabled, Meraki devices will periodically send access-request messages to these RADIUS servers
	RadiusTestingEnabled bool `json:"radiusTestingEnabled"`
	// Enable to restrict access for clients to a specific set of IP addresses or hostnames prior to authentication
	URLRedirectWalledGardenEnabled bool `json:"urlRedirectWalledGardenEnabled"`
	// IP address ranges, in CIDR notation, to restrict access for clients to a specific set of IP addresses or hostnames prior to authentication
	URLRedirectWalledGardenRanges []string `json:"urlRedirectWalledGardenRanges,omitempty"`
	// CDP/LLDP capable voice clients will be able to use this VLAN. Automatically true when hostMode is 'Multi-Domain'.
	VoiceVlanClients *bool `json:"voiceVlanClients,omitempty"`
}

type CreateNetworkSwitchAccessPolicyRequest struct {
	RequestBody CreateNetworkSwitchAccessPolicyRequestBody `request:"mediaType=application/json"`
	NetworkID   string                                     `pathParam:"style=simple,explode=false,name=networkId"`
}

// CreateNetworkSwitchAccessPolicy201ApplicationJSONAccessPolicyTypeEnum - Access Type of the policy. Automatically 'Hybrid authentication' when hostMode is 'Multi-Domain'.
type CreateNetworkSwitchAccessPolicy201ApplicationJSONAccessPolicyTypeEnum string

const (
	CreateNetworkSwitchAccessPolicy201ApplicationJSONAccessPolicyTypeEnumEightHundredAndTwo1x    CreateNetworkSwitchAccessPolicy201ApplicationJSONAccessPolicyTypeEnum = "802.1x"
	CreateNetworkSwitchAccessPolicy201ApplicationJSONAccessPolicyTypeEnumHybridAuthentication    CreateNetworkSwitchAccessPolicy201ApplicationJSONAccessPolicyTypeEnum = "Hybrid authentication"
	CreateNetworkSwitchAccessPolicy201ApplicationJSONAccessPolicyTypeEnumMacAuthenticationBypass CreateNetworkSwitchAccessPolicy201ApplicationJSONAccessPolicyTypeEnum = "MAC authentication bypass"
)

func (e CreateNetworkSwitchAccessPolicy201ApplicationJSONAccessPolicyTypeEnum) ToPointer() *CreateNetworkSwitchAccessPolicy201ApplicationJSONAccessPolicyTypeEnum {
	return &e
}

func (e *CreateNetworkSwitchAccessPolicy201ApplicationJSONAccessPolicyTypeEnum) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "802.1x":
		fallthrough
	case "Hybrid authentication":
		fallthrough
	case "MAC authentication bypass":
		*e = CreateNetworkSwitchAccessPolicy201ApplicationJSONAccessPolicyTypeEnum(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CreateNetworkSwitchAccessPolicy201ApplicationJSONAccessPolicyTypeEnum: %v", v)
	}
}

// CreateNetworkSwitchAccessPolicy201ApplicationJSONDot1xControlDirectionEnum - Supports either 'both' or 'inbound'. Set to 'inbound' to allow unauthorized egress on the switchport. Set to 'both' to control both traffic directions with authorization. Defaults to 'both'
type CreateNetworkSwitchAccessPolicy201ApplicationJSONDot1xControlDirectionEnum string

const (
	CreateNetworkSwitchAccessPolicy201ApplicationJSONDot1xControlDirectionEnumBoth    CreateNetworkSwitchAccessPolicy201ApplicationJSONDot1xControlDirectionEnum = "both"
	CreateNetworkSwitchAccessPolicy201ApplicationJSONDot1xControlDirectionEnumInbound CreateNetworkSwitchAccessPolicy201ApplicationJSONDot1xControlDirectionEnum = "inbound"
)

func (e CreateNetworkSwitchAccessPolicy201ApplicationJSONDot1xControlDirectionEnum) ToPointer() *CreateNetworkSwitchAccessPolicy201ApplicationJSONDot1xControlDirectionEnum {
	return &e
}

func (e *CreateNetworkSwitchAccessPolicy201ApplicationJSONDot1xControlDirectionEnum) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "both":
		fallthrough
	case "inbound":
		*e = CreateNetworkSwitchAccessPolicy201ApplicationJSONDot1xControlDirectionEnum(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CreateNetworkSwitchAccessPolicy201ApplicationJSONDot1xControlDirectionEnum: %v", v)
	}
}

// CreateNetworkSwitchAccessPolicy201ApplicationJSONDot1x - 802.1x Settings
type CreateNetworkSwitchAccessPolicy201ApplicationJSONDot1x struct {
	// Supports either 'both' or 'inbound'. Set to 'inbound' to allow unauthorized egress on the switchport. Set to 'both' to control both traffic directions with authorization. Defaults to 'both'
	ControlDirection *CreateNetworkSwitchAccessPolicy201ApplicationJSONDot1xControlDirectionEnum `json:"controlDirection,omitempty"`
}

// CreateNetworkSwitchAccessPolicy201ApplicationJSONHostModeEnum - Choose the Host Mode for the access policy.
type CreateNetworkSwitchAccessPolicy201ApplicationJSONHostModeEnum string

const (
	CreateNetworkSwitchAccessPolicy201ApplicationJSONHostModeEnumMultiAuth   CreateNetworkSwitchAccessPolicy201ApplicationJSONHostModeEnum = "Multi-Auth"
	CreateNetworkSwitchAccessPolicy201ApplicationJSONHostModeEnumMultiDomain CreateNetworkSwitchAccessPolicy201ApplicationJSONHostModeEnum = "Multi-Domain"
	CreateNetworkSwitchAccessPolicy201ApplicationJSONHostModeEnumMultiHost   CreateNetworkSwitchAccessPolicy201ApplicationJSONHostModeEnum = "Multi-Host"
	CreateNetworkSwitchAccessPolicy201ApplicationJSONHostModeEnumSingleHost  CreateNetworkSwitchAccessPolicy201ApplicationJSONHostModeEnum = "Single-Host"
)

func (e CreateNetworkSwitchAccessPolicy201ApplicationJSONHostModeEnum) ToPointer() *CreateNetworkSwitchAccessPolicy201ApplicationJSONHostModeEnum {
	return &e
}

func (e *CreateNetworkSwitchAccessPolicy201ApplicationJSONHostModeEnum) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "Multi-Auth":
		fallthrough
	case "Multi-Domain":
		fallthrough
	case "Multi-Host":
		fallthrough
	case "Single-Host":
		*e = CreateNetworkSwitchAccessPolicy201ApplicationJSONHostModeEnum(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CreateNetworkSwitchAccessPolicy201ApplicationJSONHostModeEnum: %v", v)
	}
}

// CreateNetworkSwitchAccessPolicy201ApplicationJSONRadiusCriticalAuth - Critical auth settings for when authentication is rejected by the RADIUS server
type CreateNetworkSwitchAccessPolicy201ApplicationJSONRadiusCriticalAuth struct {
	// VLAN that clients who use data will be placed on when RADIUS authentication fails. Will be null if hostMode is Multi-Auth
	DataVlanID *int64 `json:"dataVlanId,omitempty"`
	// Enable to suspend port bounce when RADIUS servers are unreachable
	SuspendPortBounce *bool `json:"suspendPortBounce,omitempty"`
	// VLAN that clients who use voice will be placed on when RADIUS authentication fails. Will be null if hostMode is Multi-Auth
	VoiceVlanID *int64 `json:"voiceVlanId,omitempty"`
}

// CreateNetworkSwitchAccessPolicy201ApplicationJSONRadius - Object for RADIUS Settings
type CreateNetworkSwitchAccessPolicy201ApplicationJSONRadius struct {
	// Critical auth settings for when authentication is rejected by the RADIUS server
	CriticalAuth *CreateNetworkSwitchAccessPolicy201ApplicationJSONRadiusCriticalAuth `json:"criticalAuth,omitempty"`
	// VLAN that clients will be placed on when RADIUS authentication fails. Will be null if hostMode is Multi-Auth
	FailedAuthVlanID *int64 `json:"failedAuthVlanId,omitempty"`
	// Re-authentication period in seconds. Will be null if hostMode is Multi-Auth
	ReAuthenticationInterval *int64 `json:"reAuthenticationInterval,omitempty"`
}

type CreateNetworkSwitchAccessPolicy201ApplicationJSONRadiusAccountingServers struct {
	// Public IP address of the RADIUS accounting server
	Host *string `json:"host,omitempty"`
	// UDP port that the RADIUS Accounting server listens on for access requests
	Port *int64 `json:"port,omitempty"`
}

type CreateNetworkSwitchAccessPolicy201ApplicationJSONRadiusServers struct {
	// Public IP address of the RADIUS server
	Host *string `json:"host,omitempty"`
	// UDP port that the RADIUS server listens on for access requests
	Port *int64 `json:"port,omitempty"`
}

// CreateNetworkSwitchAccessPolicy201ApplicationJSON - Successful operation
type CreateNetworkSwitchAccessPolicy201ApplicationJSON struct {
	// Access Type of the policy. Automatically 'Hybrid authentication' when hostMode is 'Multi-Domain'.
	AccessPolicyType *CreateNetworkSwitchAccessPolicy201ApplicationJSONAccessPolicyTypeEnum `json:"accessPolicyType,omitempty"`
	// 802.1x Settings
	Dot1x *CreateNetworkSwitchAccessPolicy201ApplicationJSONDot1x `json:"dot1x,omitempty"`
	// If enabled, Meraki devices will periodically send access-request messages to these RADIUS servers
	GuestPortBouncing *bool `json:"guestPortBouncing,omitempty"`
	// ID for the guest VLAN allow unauthorized devices access to limited network resources
	GuestVlanID *int64 `json:"guestVlanId,omitempty"`
	// Choose the Host Mode for the access policy.
	HostMode *CreateNetworkSwitchAccessPolicy201ApplicationJSONHostModeEnum `json:"hostMode,omitempty"`
	// Enabling this option will make switches execute 802.1X and MAC-bypass authentication simultaneously so that clients authenticate faster. Only required when accessPolicyType is 'Hybrid Authentication.
	IncreaseAccessSpeed *bool `json:"increaseAccessSpeed,omitempty"`
	// Name of the access policy
	Name *string `json:"name,omitempty"`
	// Object for RADIUS Settings
	Radius *CreateNetworkSwitchAccessPolicy201ApplicationJSONRadius `json:"radius,omitempty"`
	// Enable to send start, interim-update and stop messages to a configured RADIUS accounting server for tracking connected clients
	RadiusAccountingEnabled *bool `json:"radiusAccountingEnabled,omitempty"`
	// List of RADIUS accounting servers to require connecting devices to authenticate against before granting network access
	RadiusAccountingServers []CreateNetworkSwitchAccessPolicy201ApplicationJSONRadiusAccountingServers `json:"radiusAccountingServers,omitempty"`
	// Change of authentication for RADIUS re-authentication and disconnection
	RadiusCoaSupportEnabled *bool `json:"radiusCoaSupportEnabled,omitempty"`
	// Acceptable values are `""` for None, or `"11"` for Group Policies ACL
	RadiusGroupAttribute *string `json:"radiusGroupAttribute,omitempty"`
	// List of RADIUS servers to require connecting devices to authenticate against before granting network access
	RadiusServers []CreateNetworkSwitchAccessPolicy201ApplicationJSONRadiusServers `json:"radiusServers,omitempty"`
	// If enabled, Meraki devices will periodically send access-request messages to these RADIUS servers
	RadiusTestingEnabled *bool `json:"radiusTestingEnabled,omitempty"`
	// Enable to restrict access for clients to a response_objectific set of IP addresses or hostnames prior to authentication
	URLRedirectWalledGardenEnabled *bool `json:"urlRedirectWalledGardenEnabled,omitempty"`
	// IP address ranges, in CIDR notation, to restrict access for clients to a specific set of IP addresses or hostnames prior to authentication
	URLRedirectWalledGardenRanges []string `json:"urlRedirectWalledGardenRanges,omitempty"`
	// CDP/LLDP capable voice clients will be able to use this VLAN. Automatically true when hostMode is 'Multi-Domain'.
	VoiceVlanClients *bool `json:"voiceVlanClients,omitempty"`
}

type CreateNetworkSwitchAccessPolicyResponse struct {
	ContentType string
	StatusCode  int
	RawResponse *http.Response
	// Successful operation
	CreateNetworkSwitchAccessPolicy201ApplicationJSONObject *CreateNetworkSwitchAccessPolicy201ApplicationJSON
}
