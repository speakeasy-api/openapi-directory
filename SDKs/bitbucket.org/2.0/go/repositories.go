// Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.

package sdk

import (
	"context"
	"fmt"
	"net/http"
	"openapi/pkg/models/operations"
	"openapi/pkg/models/shared"
	"openapi/pkg/utils"
	"strings"
)

// repositories - A Git repository is a virtual storage of your project. It
// allows you to save versions of your code, which you can access
// when needed. The repo resource allows you to access public repos,
// or repos that belong to a specific workspace.
type repositories struct {
	defaultClient  HTTPClient
	securityClient HTTPClient
	serverURL      string
	language       string
	sdkVersion     string
	genVersion     string
}

func newRepositories(defaultClient, securityClient HTTPClient, serverURL, language, sdkVersion, genVersion string) *repositories {
	return &repositories{
		defaultClient:  defaultClient,
		securityClient: securityClient,
		serverURL:      serverURL,
		language:       language,
		sdkVersion:     sdkVersion,
		genVersion:     genVersion,
	}
}

// DeleteRepositoriesWorkspaceRepoSlug - Deletes the repository. This is an irreversible operation.
//
// This does not affect its forks.
func (s *repositories) DeleteRepositoriesWorkspaceRepoSlug(ctx context.Context, request operations.DeleteRepositoriesWorkspaceRepoSlugRequest) (*operations.DeleteRepositoriesWorkspaceRepoSlugResponse, error) {
	baseURL := s.serverURL
	url := utils.GenerateURL(ctx, baseURL, "/repositories/{workspace}/{repo_slug}", request.PathParams, nil)

	req, err := http.NewRequestWithContext(ctx, "DELETE", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	if err := utils.PopulateQueryParams(ctx, req, request.QueryParams, nil); err != nil {
		return nil, fmt.Errorf("error populating query params: %w", err)
	}

	client := utils.ConfigureSecurityClient(s.defaultClient, request.Security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.DeleteRepositoriesWorkspaceRepoSlugResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 204:
	case httpRes.StatusCode == 403:
		fallthrough
	case httpRes.StatusCode == 404:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out map[string]interface{}
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.Error = out
		}
	}

	return res, nil
}

// DeleteRepositoriesWorkspaceRepoSlugHooksUID - Deletes the specified webhook subscription from the given
// repository.
func (s *repositories) DeleteRepositoriesWorkspaceRepoSlugHooksUID(ctx context.Context, request operations.DeleteRepositoriesWorkspaceRepoSlugHooksUIDRequest) (*operations.DeleteRepositoriesWorkspaceRepoSlugHooksUIDResponse, error) {
	baseURL := s.serverURL
	url := utils.GenerateURL(ctx, baseURL, "/repositories/{workspace}/{repo_slug}/hooks/{uid}", request.PathParams, nil)

	req, err := http.NewRequestWithContext(ctx, "DELETE", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	client := utils.ConfigureSecurityClient(s.defaultClient, request.Security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.DeleteRepositoriesWorkspaceRepoSlugHooksUIDResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 204:
	case httpRes.StatusCode == 403:
		fallthrough
	case httpRes.StatusCode == 404:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out map[string]interface{}
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.Error = out
		}
	}

	return res, nil
}

// GetRepositories - Returns a paginated list of all public repositories.
//
// This endpoint also supports filtering and sorting of the results. See
// [filtering and sorting](../meta/filtering) for more details.
func (s *repositories) GetRepositories(ctx context.Context, request operations.GetRepositoriesRequest) (*operations.GetRepositoriesResponse, error) {
	baseURL := s.serverURL
	url := strings.TrimSuffix(baseURL, "/") + "/repositories"

	req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	if err := utils.PopulateQueryParams(ctx, req, request.QueryParams, nil); err != nil {
		return nil, fmt.Errorf("error populating query params: %w", err)
	}

	client := utils.ConfigureSecurityClient(s.defaultClient, request.Security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.GetRepositoriesResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *shared.PaginatedRepositories
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.PaginatedRepositories = out
		}
	}

	return res, nil
}

// GetRepositoriesWorkspace - Returns a paginated list of all repositories owned by the specified
// account or UUID.
//
// The result can be narrowed down based on the authenticated user's role.
//
// E.g. with `?role=contributor`, only those repositories that the
// authenticated user has write access to are returned (this includes any
// repo the user is an admin on, as that implies write access).
//
// This endpoint also supports filtering and sorting of the results. See
// [filtering and sorting](../../meta/filtering) for more details.
func (s *repositories) GetRepositoriesWorkspace(ctx context.Context, request operations.GetRepositoriesWorkspaceRequest) (*operations.GetRepositoriesWorkspaceResponse, error) {
	baseURL := s.serverURL
	url := utils.GenerateURL(ctx, baseURL, "/repositories/{workspace}", request.PathParams, nil)

	req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	if err := utils.PopulateQueryParams(ctx, req, request.QueryParams, nil); err != nil {
		return nil, fmt.Errorf("error populating query params: %w", err)
	}

	client := utils.ConfigureSecurityClient(s.defaultClient, request.Security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.GetRepositoriesWorkspaceResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *shared.PaginatedRepositories
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.PaginatedRepositories = out
		}
	case httpRes.StatusCode == 404:
		fallthrough
	case httpRes.StatusCode == 410:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out map[string]interface{}
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.Error = out
		}
	}

	return res, nil
}

// GetRepositoriesWorkspaceRepoSlug - Returns the object describing this repository.
func (s *repositories) GetRepositoriesWorkspaceRepoSlug(ctx context.Context, request operations.GetRepositoriesWorkspaceRepoSlugRequest) (*operations.GetRepositoriesWorkspaceRepoSlugResponse, error) {
	baseURL := s.serverURL
	url := utils.GenerateURL(ctx, baseURL, "/repositories/{workspace}/{repo_slug}", request.PathParams, nil)

	req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	client := utils.ConfigureSecurityClient(s.defaultClient, request.Security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.GetRepositoriesWorkspaceRepoSlugResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out map[string]interface{}
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.Repository = out
		}
	case httpRes.StatusCode == 403:
		fallthrough
	case httpRes.StatusCode == 404:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out map[string]interface{}
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.Error = out
		}
	}

	return res, nil
}

// GetRepositoriesWorkspaceRepoSlugCommitCommitStatuses - Returns all statuses (e.g. build results) for a specific commit.
func (s *repositories) GetRepositoriesWorkspaceRepoSlugCommitCommitStatuses(ctx context.Context, request operations.GetRepositoriesWorkspaceRepoSlugCommitCommitStatusesRequest) (*operations.GetRepositoriesWorkspaceRepoSlugCommitCommitStatusesResponse, error) {
	baseURL := s.serverURL
	url := utils.GenerateURL(ctx, baseURL, "/repositories/{workspace}/{repo_slug}/commit/{commit}/statuses", request.PathParams, nil)

	req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	if err := utils.PopulateQueryParams(ctx, req, request.QueryParams, nil); err != nil {
		return nil, fmt.Errorf("error populating query params: %w", err)
	}

	client := utils.ConfigureSecurityClient(s.defaultClient, request.Security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.GetRepositoriesWorkspaceRepoSlugCommitCommitStatusesResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *shared.PaginatedCommitstatuses
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.PaginatedCommitstatuses = out
		}
	case httpRes.StatusCode == 401:
	case httpRes.StatusCode == 404:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out map[string]interface{}
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.Error = out
		}
	}

	return res, nil
}

// GetRepositoriesWorkspaceRepoSlugCommitCommitStatusesBuildKey - Returns the specified build status for a commit.
func (s *repositories) GetRepositoriesWorkspaceRepoSlugCommitCommitStatusesBuildKey(ctx context.Context, request operations.GetRepositoriesWorkspaceRepoSlugCommitCommitStatusesBuildKeyRequest) (*operations.GetRepositoriesWorkspaceRepoSlugCommitCommitStatusesBuildKeyResponse, error) {
	baseURL := s.serverURL
	url := utils.GenerateURL(ctx, baseURL, "/repositories/{workspace}/{repo_slug}/commit/{commit}/statuses/build/{key}", request.PathParams, nil)

	req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	client := utils.ConfigureSecurityClient(s.defaultClient, request.Security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.GetRepositoriesWorkspaceRepoSlugCommitCommitStatusesBuildKeyResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out map[string]interface{}
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.Commitstatus = out
		}
	case httpRes.StatusCode == 401:
	case httpRes.StatusCode == 404:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out map[string]interface{}
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.Error = out
		}
	}

	return res, nil
}

// GetRepositoriesWorkspaceRepoSlugFilehistoryCommitPath - Returns a paginated list of commits that modified the specified file.
//
// Commits are returned in reverse chronological order. This is roughly
// equivalent to the following commands:
//
//	$ git log --follow --date-order <sha> <path>
//
//	$ hg log --follow <path>
//
// By default, Bitbucket will follow renames and the path name in the
// returned entries reflects that. This can be turned off using the
// `?renames=false` query parameter.
//
// Results are returned in descending chronological order by default, and
// like most endpoints you can
// [filter and sort](../../../../../../meta/filtering) the response to
// only provide exactly the data you want.
//
// For example, if you wanted to find commits made before 2011-05-18
// against a file named `README.rst`, but you only wanted the path and
// date, your query would look like this:
//
// ```
//
//	$ curl 'https://api.bitbucket.org/2.0/repositories/evzijst/dogslow/filehistory/master/README.rst'\
//	  '?fields=values.next,values.path,values.commit.date&q=commit.date<=2011-05-18'
//
//	{
//	  "values": [
//	    {
//	      "commit": {
//	        "date": "2011-05-17T07:32:09+00:00"
//	      },
//	      "path": "README.rst"
//	    },
//	    {
//	      "commit": {
//	        "date": "2011-05-16T06:33:28+00:00"
//	      },
//	      "path": "README.txt"
//	    },
//	    {
//	      "commit": {
//	        "date": "2011-05-16T06:15:39+00:00"
//	      },
//	      "path": "README.txt"
//	    }
//	  ]
//	}
//
// ```
//
// In the response you can see that the file was renamed to `README.rst`
// by the commit made on 2011-05-16, and was previously named `README.txt`.
func (s *repositories) GetRepositoriesWorkspaceRepoSlugFilehistoryCommitPath(ctx context.Context, request operations.GetRepositoriesWorkspaceRepoSlugFilehistoryCommitPathRequest) (*operations.GetRepositoriesWorkspaceRepoSlugFilehistoryCommitPathResponse, error) {
	baseURL := s.serverURL
	url := utils.GenerateURL(ctx, baseURL, "/repositories/{workspace}/{repo_slug}/filehistory/{commit}/{path}", request.PathParams, nil)

	req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	if err := utils.PopulateQueryParams(ctx, req, request.QueryParams, nil); err != nil {
		return nil, fmt.Errorf("error populating query params: %w", err)
	}

	client := utils.ConfigureSecurityClient(s.defaultClient, request.Security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.GetRepositoriesWorkspaceRepoSlugFilehistoryCommitPathResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *shared.PaginatedFiles
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.PaginatedFiles = out
		}
	case httpRes.StatusCode == 404:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out map[string]interface{}
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.Error = out
		}
	}

	return res, nil
}

// GetRepositoriesWorkspaceRepoSlugForks - Returns a paginated list of all the forks of the specified
// repository.
func (s *repositories) GetRepositoriesWorkspaceRepoSlugForks(ctx context.Context, request operations.GetRepositoriesWorkspaceRepoSlugForksRequest) (*operations.GetRepositoriesWorkspaceRepoSlugForksResponse, error) {
	baseURL := s.serverURL
	url := utils.GenerateURL(ctx, baseURL, "/repositories/{workspace}/{repo_slug}/forks", request.PathParams, nil)

	req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	if err := utils.PopulateQueryParams(ctx, req, request.QueryParams, nil); err != nil {
		return nil, fmt.Errorf("error populating query params: %w", err)
	}

	client := utils.ConfigureSecurityClient(s.defaultClient, request.Security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.GetRepositoriesWorkspaceRepoSlugForksResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *shared.PaginatedRepositories
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.PaginatedRepositories = out
		}
	}

	return res, nil
}

// GetRepositoriesWorkspaceRepoSlugHooks - Returns a paginated list of webhooks installed on this repository.
func (s *repositories) GetRepositoriesWorkspaceRepoSlugHooks(ctx context.Context, request operations.GetRepositoriesWorkspaceRepoSlugHooksRequest) (*operations.GetRepositoriesWorkspaceRepoSlugHooksResponse, error) {
	baseURL := s.serverURL
	url := utils.GenerateURL(ctx, baseURL, "/repositories/{workspace}/{repo_slug}/hooks", request.PathParams, nil)

	req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	client := utils.ConfigureSecurityClient(s.defaultClient, request.Security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.GetRepositoriesWorkspaceRepoSlugHooksResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *shared.PaginatedWebhookSubscriptions
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.PaginatedWebhookSubscriptions = out
		}
	case httpRes.StatusCode == 403:
		fallthrough
	case httpRes.StatusCode == 404:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out map[string]interface{}
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.Error = out
		}
	}

	return res, nil
}

// GetRepositoriesWorkspaceRepoSlugHooksUID - Returns the webhook with the specified id installed on the specified
// repository.
func (s *repositories) GetRepositoriesWorkspaceRepoSlugHooksUID(ctx context.Context, request operations.GetRepositoriesWorkspaceRepoSlugHooksUIDRequest) (*operations.GetRepositoriesWorkspaceRepoSlugHooksUIDResponse, error) {
	baseURL := s.serverURL
	url := utils.GenerateURL(ctx, baseURL, "/repositories/{workspace}/{repo_slug}/hooks/{uid}", request.PathParams, nil)

	req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	client := utils.ConfigureSecurityClient(s.defaultClient, request.Security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.GetRepositoriesWorkspaceRepoSlugHooksUIDResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out map[string]interface{}
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.WebhookSubscription = out
		}
	case httpRes.StatusCode == 404:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out map[string]interface{}
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.Error = out
		}
	}

	return res, nil
}

// GetRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIDStatuses - Returns all statuses (e.g. build results) for the given pull
// request.
func (s *repositories) GetRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIDStatuses(ctx context.Context, request operations.GetRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIDStatusesRequest) (*operations.GetRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIDStatusesResponse, error) {
	baseURL := s.serverURL
	url := utils.GenerateURL(ctx, baseURL, "/repositories/{workspace}/{repo_slug}/pullrequests/{pull_request_id}/statuses", request.PathParams, nil)

	req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	if err := utils.PopulateQueryParams(ctx, req, request.QueryParams, nil); err != nil {
		return nil, fmt.Errorf("error populating query params: %w", err)
	}

	client := utils.ConfigureSecurityClient(s.defaultClient, request.Security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.GetRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIDStatusesResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *shared.PaginatedCommitstatuses
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.PaginatedCommitstatuses = out
		}
	case httpRes.StatusCode == 401:
	case httpRes.StatusCode == 404:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out map[string]interface{}
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.Error = out
		}
	}

	return res, nil
}

// GetRepositoriesWorkspaceRepoSlugSrc - This endpoint redirects the client to the directory listing of the
// root directory on the main branch.
//
// This is equivalent to directly hitting
// [/2.0/repositories/{username}/{repo_slug}/src/{commit}/{path}](src/%7Bcommit%7D/%7Bpath%7D)
// without having to know the name or SHA1 of the repo's main branch.
//
// To create new commits, [POST to this endpoint](#post)
func (s *repositories) GetRepositoriesWorkspaceRepoSlugSrc(ctx context.Context, request operations.GetRepositoriesWorkspaceRepoSlugSrcRequest) (*operations.GetRepositoriesWorkspaceRepoSlugSrcResponse, error) {
	baseURL := s.serverURL
	url := utils.GenerateURL(ctx, baseURL, "/repositories/{workspace}/{repo_slug}/src", request.PathParams, nil)

	req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	if err := utils.PopulateQueryParams(ctx, req, request.QueryParams, nil); err != nil {
		return nil, fmt.Errorf("error populating query params: %w", err)
	}

	client := utils.ConfigureSecurityClient(s.defaultClient, request.Security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.GetRepositoriesWorkspaceRepoSlugSrcResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *shared.PaginatedTreeentries
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.PaginatedTreeentries = out
		}
	case httpRes.StatusCode == 404:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out map[string]interface{}
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.Error = out
		}
	}

	return res, nil
}

// GetRepositoriesWorkspaceRepoSlugSrcCommitPath - This endpoints is used to retrieve the contents of a single file,
// or the contents of a directory at a specified revision.
//
// ## Raw file contents
//
// When `path` points to a file, this endpoint returns the raw contents.
// The response's Content-Type is derived from the filename
// extension (not from the contents). The file contents are not processed
// and no character encoding/recoding is performed and as a result no
// character encoding is included as part of the Content-Type.
//
// The `Content-Disposition` header will be "attachment" to prevent
// browsers from running executable files.
//
// If the file is managed by LFS, then a 301 redirect pointing to
// Atlassian's media services platform is returned.
//
// The response includes an ETag that is based on the contents of the file
// and its attributes. This means that an empty `__init__.py` always
// returns the same ETag, regardless on the directory it lives in, or the
// commit it is on.
//
// ## File meta data
//
// When the request for a file path includes the query parameter
// `?format=meta`, instead of returning the file's raw contents, Bitbucket
// instead returns the JSON object describing the file's properties:
//
// ```javascript
// $ curl https://api.bitbucket.org/2.0/repositories/atlassian/bbql/src/eefd5ef/tests/__init__.py?format=meta
//
//	{
//	  "links": {
//	    "self": {
//	      "href": "https://api.bitbucket.org/2.0/repositories/atlassian/bbql/src/eefd5ef5d3df01aed629f650959d6706d54cd335/tests/__init__.py"
//	    },
//	    "meta": {
//	      "href": "https://api.bitbucket.org/2.0/repositories/atlassian/bbql/src/eefd5ef5d3df01aed629f650959d6706d54cd335/tests/__init__.py?format=meta"
//	    }
//	  },
//	  "path": "tests/__init__.py",
//	  "commit": {
//	    "type": "commit",
//	    "hash": "eefd5ef5d3df01aed629f650959d6706d54cd335",
//	    "links": {
//	      "self": {
//	        "href": "https://api.bitbucket.org/2.0/repositories/atlassian/bbql/commit/eefd5ef5d3df01aed629f650959d6706d54cd335"
//	      },
//	      "html": {
//	        "href": "https://bitbucket.org/atlassian/bbql/commits/eefd5ef5d3df01aed629f650959d6706d54cd335"
//	      }
//	    }
//	  },
//	  "attributes": [],
//	  "type": "commit_file",
//	  "size": 0
//	}
//
// ```
//
// File objects contain an `attributes` element that contains a list of
// possible modifiers. Currently defined values are:
//
//   - `link` -- indicates that the entry is a symbolic link. The contents
//     of the file represent the path the link points to.
//   - `executable` -- indicates that the file has the executable bit set.
//   - `subrepository` -- indicates that the entry points to a submodule or
//     subrepo. The contents of the file is the SHA1 of the repository
//     pointed to.
//   - `binary` -- indicates whether Bitbucket thinks the file is binary.
//
// This endpoint can provide an alternative to how a HEAD request can be
// used to check for the existence of a file, or a file's size without
// incurring the overhead of receiving its full contents.
//
// ## Directory listings
//
// When `path` points to a directory instead of a file, the response is a
// paginated list of directory and file objects in the same order as the
// underlying SCM system would return them.
//
// For example:
//
// ```javascript
// $ curl https://api.bitbucket.org/2.0/repositories/atlassian/bbql/src/eefd5ef/tests
//
//	{
//	  "pagelen": 10,
//	  "values": [
//	    {
//	      "path": "tests/test_project",
//	      "type": "commit_directory",
//	      "links": {
//	        "self": {
//	          "href": "https://api.bitbucket.org/2.0/repositories/atlassian/bbql/src/eefd5ef5d3df01aed629f650959d6706d54cd335/tests/test_project/"
//	        },
//	        "meta": {
//	          "href": "https://api.bitbucket.org/2.0/repositories/atlassian/bbql/src/eefd5ef5d3df01aed629f650959d6706d54cd335/tests/test_project/?format=meta"
//	        }
//	      },
//	      "commit": {
//	        "type": "commit",
//	        "hash": "eefd5ef5d3df01aed629f650959d6706d54cd335",
//	        "links": {
//	          "self": {
//	            "href": "https://api.bitbucket.org/2.0/repositories/atlassian/bbql/commit/eefd5ef5d3df01aed629f650959d6706d54cd335"
//	          },
//	          "html": {
//	            "href": "https://bitbucket.org/atlassian/bbql/commits/eefd5ef5d3df01aed629f650959d6706d54cd335"
//	          }
//	        }
//	      }
//	    },
//	    {
//	      "links": {
//	        "self": {
//	          "href": "https://api.bitbucket.org/2.0/repositories/atlassian/bbql/src/eefd5ef5d3df01aed629f650959d6706d54cd335/tests/__init__.py"
//	        },
//	        "meta": {
//	          "href": "https://api.bitbucket.org/2.0/repositories/atlassian/bbql/src/eefd5ef5d3df01aed629f650959d6706d54cd335/tests/__init__.py?format=meta"
//	        }
//	      },
//	      "path": "tests/__init__.py",
//	      "commit": {
//	        "type": "commit",
//	        "hash": "eefd5ef5d3df01aed629f650959d6706d54cd335",
//	        "links": {
//	          "self": {
//	            "href": "https://api.bitbucket.org/2.0/repositories/atlassian/bbql/commit/eefd5ef5d3df01aed629f650959d6706d54cd335"
//	          },
//	          "html": {
//	            "href": "https://bitbucket.org/atlassian/bbql/commits/eefd5ef5d3df01aed629f650959d6706d54cd335"
//	          }
//	        }
//	      },
//	      "attributes": [],
//	      "type": "commit_file",
//	      "size": 0
//	    }
//	  ],
//	  "page": 1,
//	  "size": 2
//	}
//
// ```
//
// When listing the contents of the repo's root directory, the use of a
// trailing slash at the end of the URL is required.
//
// The response by default is not recursive, meaning that only the direct contents of
// a path are returned. The response does not recurse down into
// subdirectories. In order to "walk" the entire directory tree, the
// client can either parse each response and follow the `self` links of each
// `commit_directory` object, or can specify a `max_depth` to recurse to.
//
// The max_depth parameter will do a breadth-first search to return the contents of the subdirectories
// up to the depth specified. Breadth-first search was chosen as it leads to the least amount of
// file system operations for git. If the `max_depth` parameter is specified to be too
// large, the call will time out and return a 555.
//
// Each returned object is either a `commit_file`, or a `commit_directory`,
// both of which contain a `path` element. This path is the absolute path
// from the root of the repository. Each object also contains a `commit`
// object which embeds the commit the file is on. Note that this is merely
// the commit that was used in the URL. It is *not* the commit that last
// modified the file.
//
// Directory objects have 2 representations. Their `self` link returns the
// paginated contents of the directory. The `meta` link on the other hand
// returns the actual `directory` object itself, e.g.:
//
// ```javascript
//
//	{
//	  "path": "tests/test_project",
//	  "type": "commit_directory",
//	  "links": {
//	    "self": {
//	      "href": "https://api.bitbucket.org/2.0/repositories/atlassian/bbql/src/eefd5ef5d3df01aed629f650959d6706d54cd335/tests/test_project/"
//	    },
//	    "meta": {
//	      "href": "https://api.bitbucket.org/2.0/repositories/atlassian/bbql/src/eefd5ef5d3df01aed629f650959d6706d54cd335/tests/test_project/?format=meta"
//	    }
//	  },
//	  "commit": { ... }
//	}
//
// ```
//
// ## Querying, filtering and sorting
//
// Like most API endpoints, this API supports the Bitbucket
// querying/filtering syntax and so you could filter a directory listing
// to only include entries that match certain criteria. For instance, to
// list all binary files over 1kb use the expression:
//
// `size > 1024 and attributes = "binary"`
//
// which after urlencoding yields the query string:
//
// `?q=size%3E1024+and+attributes%3D%22binary%22`
//
// To change the ordering of the response, use the `?sort` parameter:
//
// `.../src/eefd5ef/?sort=-size`
//
// See [filtering and sorting](../../../../../../meta/filtering) for more
// details.
func (s *repositories) GetRepositoriesWorkspaceRepoSlugSrcCommitPath(ctx context.Context, request operations.GetRepositoriesWorkspaceRepoSlugSrcCommitPathRequest) (*operations.GetRepositoriesWorkspaceRepoSlugSrcCommitPathResponse, error) {
	baseURL := s.serverURL
	url := utils.GenerateURL(ctx, baseURL, "/repositories/{workspace}/{repo_slug}/src/{commit}/{path}", request.PathParams, nil)

	req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	if err := utils.PopulateQueryParams(ctx, req, request.QueryParams, nil); err != nil {
		return nil, fmt.Errorf("error populating query params: %w", err)
	}

	client := utils.ConfigureSecurityClient(s.defaultClient, request.Security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.GetRepositoriesWorkspaceRepoSlugSrcCommitPathResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *shared.PaginatedTreeentries
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.PaginatedTreeentries = out
		}
	case httpRes.StatusCode == 404:
		fallthrough
	case httpRes.StatusCode == 555:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out map[string]interface{}
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.Error = out
		}
	}

	return res, nil
}

// GetRepositoriesWorkspaceRepoSlugWatchers - Returns a paginated list of all the watchers on the specified
// repository.
func (s *repositories) GetRepositoriesWorkspaceRepoSlugWatchers(ctx context.Context, request operations.GetRepositoriesWorkspaceRepoSlugWatchersRequest) (*operations.GetRepositoriesWorkspaceRepoSlugWatchersResponse, error) {
	baseURL := s.serverURL
	url := utils.GenerateURL(ctx, baseURL, "/repositories/{workspace}/{repo_slug}/watchers", request.PathParams, nil)

	req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	client := utils.ConfigureSecurityClient(s.defaultClient, request.Security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.GetRepositoriesWorkspaceRepoSlugWatchersResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
	}

	return res, nil
}

// GetUserPermissionsRepositories - Returns an object for each repository the caller has explicit access
// to and their effective permission — the highest level of permission the
// caller has. This does not return public repositories that the user was
// not granted any specific permission in, and does not distinguish between
// direct and indirect privileges.
//
// Permissions can be:
//
// * `admin`
// * `write`
// * `read`
//
// Example:
//
// ```
// $ curl https://api.bitbucket.org/2.0/user/permissions/repositories
//
//	{
//	  "pagelen": 10,
//	  "values": [
//	    {
//	      "type": "repository_permission",
//	      "user": {
//	        "type": "user",
//	        "nickname": "evzijst",
//	        "display_name": "Erik van Zijst",
//	        "uuid": "{d301aafa-d676-4ee0-88be-962be7417567}"
//	      },
//	      "repository": {
//	        "type": "repository",
//	        "name": "geordi",
//	        "full_name": "bitbucket/geordi",
//	        "uuid": "{85d08b4e-571d-44e9-a507-fa476535aa98}"
//	      },
//	      "permission": "admin"
//	    }
//	  ],
//	  "page": 1,
//	  "size": 1
//	}
//
// ```
//
// Results may be further [filtered or sorted](../../../meta/filtering) by
// repository or permission by adding the following query string
// parameters:
//
// * `q=repository.name="geordi"` or `q=permission>"read"`
// * `sort=repository.name`
//
// Note that the query parameter values need to be URL escaped so that `=`
// would become `%3D`.
func (s *repositories) GetUserPermissionsRepositories(ctx context.Context, request operations.GetUserPermissionsRepositoriesRequest) (*operations.GetUserPermissionsRepositoriesResponse, error) {
	baseURL := s.serverURL
	url := strings.TrimSuffix(baseURL, "/") + "/user/permissions/repositories"

	req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	if err := utils.PopulateQueryParams(ctx, req, request.QueryParams, nil); err != nil {
		return nil, fmt.Errorf("error populating query params: %w", err)
	}

	client := utils.ConfigureSecurityClient(s.defaultClient, request.Security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.GetUserPermissionsRepositoriesResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *shared.PaginatedRepositoryPermissions
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.PaginatedRepositoryPermissions = out
		}
	}

	return res, nil
}

// PostRepositoriesWorkspaceRepoSlug - Creates a new repository.
//
// Note: In order to set the project for the newly created repository,
// pass in either the project key or the project UUID as part of the
// request body as shown in the examples below:
//
// ```
//
//	$ curl -X POST -H "Content-Type: application/json" -d '{
//	    "scm": "git",
//	    "project": {
//	        "key": "MARS"
//	    }
//	}' https://api.bitbucket.org/2.0/repositories/teamsinspace/hablanding
//
// ```
//
// or
//
// ```
//
//	$ curl -X POST -H "Content-Type: application/json" -d '{
//	    "scm": "git",
//	    "project": {
//	        "key": "{ba516952-992a-4c2d-acbd-17d502922f96}"
//	    }
//	}' https://api.bitbucket.org/2.0/repositories/teamsinspace/hablanding
//
// ```
//
// The project must be assigned for all repositories. If the project is not provided,
// the repository is automatically assigned to the oldest project in the workspace.
//
// Note: In the examples above, the workspace ID `teamsinspace`,
// and/or the repository name `hablanding` can be replaced by UUIDs.
func (s *repositories) PostRepositoriesWorkspaceRepoSlug(ctx context.Context, request operations.PostRepositoriesWorkspaceRepoSlugRequest) (*operations.PostRepositoriesWorkspaceRepoSlugResponse, error) {
	baseURL := s.serverURL
	url := utils.GenerateURL(ctx, baseURL, "/repositories/{workspace}/{repo_slug}", request.PathParams, nil)

	bodyReader, reqContentType, err := utils.SerializeRequestBody(ctx, request, "Request", "json")
	if err != nil {
		return nil, fmt.Errorf("error serializing request body: %w", err)
	}

	req, err := http.NewRequestWithContext(ctx, "POST", url, bodyReader)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	req.Header.Set("Content-Type", reqContentType)

	client := utils.ConfigureSecurityClient(s.defaultClient, request.Security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.PostRepositoriesWorkspaceRepoSlugResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out map[string]interface{}
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.Repository = out
		}
	case httpRes.StatusCode == 400:
		fallthrough
	case httpRes.StatusCode == 401:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out map[string]interface{}
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.Error = out
		}
	}

	return res, nil
}

// PostRepositoriesWorkspaceRepoSlugCommitCommitStatusesBuild - Creates a new build status against the specified commit.
//
// If the specified key already exists, the existing status object will
// be overwritten.
//
// Example:
//
// ```
//
//	curl https://api.bitbucket.org/2.0/repositories/my-workspace/my-repo/commit/e10dae226959c2194f2b07b077c07762d93821cf/statuses/build/           -X POST -u jdoe -H 'Content-Type: application/json'           -d '{
//	    "key": "MY-BUILD",
//	    "state": "SUCCESSFUL",
//	    "description": "42 tests passed",
//	    "url": "https://www.example.org/my-build-result"
//	  }'
//
// ```
//
// When creating a new commit status, you can use a URI template for the URL.
// Templates are URLs that contain variable names that Bitbucket will
// evaluate at runtime whenever the URL is displayed anywhere similar to
// parameter substitution in
// [Bitbucket Connect](https://developer.atlassian.com/bitbucket/concepts/context-parameters.html).
// For example, one could use `https://foo.com/builds/{repository.full_name}`
// which Bitbucket will turn into `https://foo.com/builds/foo/bar` at render time.
// The context variables available are `repository` and `commit`.
func (s *repositories) PostRepositoriesWorkspaceRepoSlugCommitCommitStatusesBuild(ctx context.Context, request operations.PostRepositoriesWorkspaceRepoSlugCommitCommitStatusesBuildRequest) (*operations.PostRepositoriesWorkspaceRepoSlugCommitCommitStatusesBuildResponse, error) {
	baseURL := s.serverURL
	url := utils.GenerateURL(ctx, baseURL, "/repositories/{workspace}/{repo_slug}/commit/{commit}/statuses/build", request.PathParams, nil)

	bodyReader, reqContentType, err := utils.SerializeRequestBody(ctx, request, "Request", "json")
	if err != nil {
		return nil, fmt.Errorf("error serializing request body: %w", err)
	}

	req, err := http.NewRequestWithContext(ctx, "POST", url, bodyReader)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	req.Header.Set("Content-Type", reqContentType)

	client := utils.ConfigureSecurityClient(s.defaultClient, request.Security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.PostRepositoriesWorkspaceRepoSlugCommitCommitStatusesBuildResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 201:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out map[string]interface{}
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.Commitstatus = out
		}
	case httpRes.StatusCode == 401:
	case httpRes.StatusCode == 404:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out map[string]interface{}
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.Error = out
		}
	}

	return res, nil
}

// PostRepositoriesWorkspaceRepoSlugForks - Creates a new fork of the specified repository.
//
// ## Forking a repository
//
// To create a fork, specify the workspace explicitly as part of the
// request body:
//
// ```
//
//	$ curl -X POST -u jdoe https://api.bitbucket.org/2.0/repositories/atlassian/bbql/forks \
//	  -H 'Content-Type: application/json' -d '{
//	    "name": "bbql_fork",
//	    "workspace": {
//	      "slug": "atlassian"
//	    }
//	}'
//
// ```
//
// To fork a repository into the same workspace, also specify a new `name`.
//
// When you specify a value for `name`, it will also affect the `slug`.
// The `slug` is reflected in the repository URL of the new fork. It is
// derived from `name` by substituting non-ASCII characters, removes
// whitespace, and changes characters to lower case. For example,
// `My repo` would turn into `my_repo`.
//
// You need contributor access to create new forks within a workspace.
//
// ## Change the properties of a new fork
//
// By default the fork inherits most of its properties from the parent.
// However, since the optional POST body document follows the normal
// `repository` JSON schema and you can override the new fork's
// properties.
//
// Properties that can be overridden include:
//
//   - description
//   - fork_policy
//   - language
//   - mainbranch
//   - is_private (note that a private repo's fork_policy might prohibit
//     the creation of public forks, in which `is_private=False` would fail)
//   - has_issues (to initialize or disable the new repo's issue tracker --
//     note that the actual contents of the parent repository's issue
//     tracker are not copied during forking)
//   - has_wiki (to initialize or disable the new repo's wiki --
//     note that the actual contents of the parent repository's wiki are not
//     copied during forking)
//   - project (when forking into a private project, the fork's `is_private`
//     must be `true`)
//
// Properties that cannot be modified include:
//
// * scm
// * parent
// * full_name
func (s *repositories) PostRepositoriesWorkspaceRepoSlugForks(ctx context.Context, request operations.PostRepositoriesWorkspaceRepoSlugForksRequest) (*operations.PostRepositoriesWorkspaceRepoSlugForksResponse, error) {
	baseURL := s.serverURL
	url := utils.GenerateURL(ctx, baseURL, "/repositories/{workspace}/{repo_slug}/forks", request.PathParams, nil)

	bodyReader, reqContentType, err := utils.SerializeRequestBody(ctx, request, "Request", "json")
	if err != nil {
		return nil, fmt.Errorf("error serializing request body: %w", err)
	}

	req, err := http.NewRequestWithContext(ctx, "POST", url, bodyReader)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	req.Header.Set("Content-Type", reqContentType)

	client := utils.ConfigureSecurityClient(s.defaultClient, request.Security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.PostRepositoriesWorkspaceRepoSlugForksResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 201:
		res.Headers = httpRes.Header

		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out map[string]interface{}
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.Repository = out
		}
	}

	return res, nil
}

// PostRepositoriesWorkspaceRepoSlugHooks - Creates a new webhook on the specified repository.
//
// Example:
//
// ```
// $ curl -X POST -u credentials -H 'Content-Type: application/json'
//
//	https://api.bitbucket.org/2.0/repositories/my-workspace/my-repo-slug/hooks
//	-d '
//	  {
//	    "description": "Webhook Description",
//	    "url": "https://example.com/",
//	    "active": true,
//	    "events": [
//	      "repo:push",
//	      "issue:created",
//	      "issue:updated"
//	    ]
//	  }'
//
// ```
//
// Note that this call requires the webhook scope, as well as any scope
// that applies to the events that the webhook subscribes to. In the
// example above that means: `webhook`, `repository` and `issue`.
//
// Also note that the `url` must properly resolve and cannot be an
// internal, non-routed address.
func (s *repositories) PostRepositoriesWorkspaceRepoSlugHooks(ctx context.Context, request operations.PostRepositoriesWorkspaceRepoSlugHooksRequest) (*operations.PostRepositoriesWorkspaceRepoSlugHooksResponse, error) {
	baseURL := s.serverURL
	url := utils.GenerateURL(ctx, baseURL, "/repositories/{workspace}/{repo_slug}/hooks", request.PathParams, nil)

	req, err := http.NewRequestWithContext(ctx, "POST", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	client := utils.ConfigureSecurityClient(s.defaultClient, request.Security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.PostRepositoriesWorkspaceRepoSlugHooksResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 201:
		res.Headers = httpRes.Header

		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out map[string]interface{}
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.WebhookSubscription = out
		}
	case httpRes.StatusCode == 403:
		fallthrough
	case httpRes.StatusCode == 404:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out map[string]interface{}
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.Error = out
		}
	}

	return res, nil
}

// PostRepositoriesWorkspaceRepoSlugSrc - This endpoint is used to create new commits in the repository by
// uploading files.
//
// To add a new file to a repository:
//
// ```
//
//	$ curl https://api.bitbucket.org/2.0/repositories/username/slug/src \
//	  -F /repo/path/to/image.png=@image.png
//
// ```
//
// This will create a new commit on top of the main branch, inheriting the
// contents of the main branch, but adding (or overwriting) the
// `image.png` file to the repository in the `/repo/path/to` directory.
//
// To create a commit that deletes files, use the `files` parameter:
//
// ```
//
//	$ curl https://api.bitbucket.org/2.0/repositories/username/slug/src \
//	  -F files=/file/to/delete/1.txt \
//	  -F files=/file/to/delete/2.txt
//
// ```
//
// You can add/modify/delete multiple files in a request. Rename/move a
// file by deleting the old path and adding the content at the new path.
//
// This endpoint accepts `multipart/form-data` (as in the examples above),
// as well as `application/x-www-form-urlencoded`.
//
// ## multipart/form-data
//
// A `multipart/form-data` post contains a series of "form fields" that
// identify both the individual files that are being uploaded, as well as
// additional, optional meta data.
//
// Files are uploaded in file form fields (those that have a
// `Content-Disposition` parameter) whose field names point to the remote
// path in the repository where the file should be stored. Path field
// names are always interpreted to be absolute from the root of the
// repository, regardless whether the client uses a leading slash (as the
// above `curl` example did).
//
// File contents are treated as bytes and are not decoded as text.
//
// The commit message, as well as other non-file meta data for the
// request, is sent along as normal form field elements. Meta data fields
// share the same namespace as the file objects. For `multipart/form-data`
// bodies that should not lead to any ambiguity, as the
// `Content-Disposition` header will contain the `filename` parameter to
// distinguish between a file named "message" and the commit message field.
//
// ## application/x-www-form-urlencoded
//
// It is also possible to upload new files using a simple
// `application/x-www-form-urlencoded` POST. This can be convenient when
// uploading pure text files:
//
// ```
//
//	$ curl https://api.bitbucket.org/2.0/repositories/atlassian/bbql/src \
//	  --data-urlencode "/path/to/me.txt=Lorem ipsum." \
//	  --data-urlencode "message=Initial commit" \
//	  --data-urlencode "author=Erik van Zijst <erik.van.zijst@gmail.com>"
//
// ```
//
// There could be a field name clash if a client were to upload a file
// named "message", as this filename clashes with the meta data property
// for the commit message. To avoid this and to upload files whose names
// clash with the meta data properties, use a leading slash for the files,
// e.g. `curl --data-urlencode "/message=file contents"`.
//
// When an explicit slash is omitted for a file whose path matches that of
// a meta data parameter, then it is interpreted as meta data, not as a
// file.
//
// ## Executables and links
//
// While this API aims to facilitate the most common use cases, it is
// possible to perform some more advanced operations like creating a new
// symlink in the repository, or creating an executable file.
//
// Files can be supplied with a `x-attributes` value in the
// `Content-Disposition` header. For example, to upload an executable
// file, as well as create a symlink from `README.txt` to `README`:
//
// ```
// --===============1438169132528273974==
// Content-Type: text/plain; charset="us-ascii"
// MIME-Version: 1.0
// Content-Transfer-Encoding: 7bit
// Content-ID: "bin/shutdown.sh"
// Content-Disposition: attachment; filename="shutdown.sh"; x-attributes:"executable"
//
// #!/bin/sh
// halt
//
// --===============1438169132528273974==
// Content-Type: text/plain; charset="us-ascii"
// MIME-Version: 1.0
// Content-Transfer-Encoding: 7bit
// Content-ID: "/README.txt"
// Content-Disposition: attachment; filename="README.txt"; x-attributes:"link"
//
// README
// --===============1438169132528273974==--
// ```
//
// Links are files that contain the target path and have
// `x-attributes:"link"` set.
//
// When overwriting links with files, or vice versa, the newly uploaded
// file determines both the new contents, as well as the attributes. That
// means uploading a file without specifying `x-attributes="link"` will
// create a regular file, even if the parent commit hosted a symlink at
// the same path.
//
// The same applies to executables. When modifying an existing executable
// file, the form-data file element must include
// `x-attributes="executable"` in order to preserve the executable status
// of the file.
//
// Note that this API does not support the creation or manipulation of
// subrepos / submodules.
func (s *repositories) PostRepositoriesWorkspaceRepoSlugSrc(ctx context.Context, request operations.PostRepositoriesWorkspaceRepoSlugSrcRequest) (*operations.PostRepositoriesWorkspaceRepoSlugSrcResponse, error) {
	baseURL := s.serverURL
	url := utils.GenerateURL(ctx, baseURL, "/repositories/{workspace}/{repo_slug}/src", request.PathParams, nil)

	req, err := http.NewRequestWithContext(ctx, "POST", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	if err := utils.PopulateQueryParams(ctx, req, request.QueryParams, nil); err != nil {
		return nil, fmt.Errorf("error populating query params: %w", err)
	}

	client := utils.ConfigureSecurityClient(s.defaultClient, request.Security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.PostRepositoriesWorkspaceRepoSlugSrcResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 201:
	case httpRes.StatusCode == 403:
		fallthrough
	case httpRes.StatusCode == 404:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out map[string]interface{}
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.Error = out
		}
	}

	return res, nil
}

// PutRepositoriesWorkspaceRepoSlug - Since this endpoint can be used to both update and to create a
// repository, the request body depends on the intent.
//
// ### Creation
//
// See the POST documentation for the repository endpoint for an example
// of the request body.
//
// ### Update
//
// Note: Changing the `name` of the repository will cause the location to
// be changed. This is because the URL of the repo is derived from the
// name (a process called slugification). In such a scenario, it is
// possible for the request to fail if the newly created slug conflicts
// with an existing repository's slug. But if there is no conflict,
// the new location will be returned in the `Location` header of the
// response.
func (s *repositories) PutRepositoriesWorkspaceRepoSlug(ctx context.Context, request operations.PutRepositoriesWorkspaceRepoSlugRequest) (*operations.PutRepositoriesWorkspaceRepoSlugResponse, error) {
	baseURL := s.serverURL
	url := utils.GenerateURL(ctx, baseURL, "/repositories/{workspace}/{repo_slug}", request.PathParams, nil)

	bodyReader, reqContentType, err := utils.SerializeRequestBody(ctx, request, "Request", "json")
	if err != nil {
		return nil, fmt.Errorf("error serializing request body: %w", err)
	}

	req, err := http.NewRequestWithContext(ctx, "PUT", url, bodyReader)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	req.Header.Set("Content-Type", reqContentType)

	client := utils.ConfigureSecurityClient(s.defaultClient, request.Security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.PutRepositoriesWorkspaceRepoSlugResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		fallthrough
	case httpRes.StatusCode == 201:
		res.Headers = httpRes.Header

		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out map[string]interface{}
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.Repository = out
		}
	case httpRes.StatusCode == 400:
		fallthrough
	case httpRes.StatusCode == 401:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out map[string]interface{}
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.Error = out
		}
	}

	return res, nil
}

// PutRepositoriesWorkspaceRepoSlugCommitCommitStatusesBuildKey - Used to update the current status of a build status object on the
// specific commit.
//
// This operation can also be used to change other properties of the
// build status:
//
// * `state`
// * `name`
// * `description`
// * `url`
// * `refname`
//
// The `key` cannot be changed.
func (s *repositories) PutRepositoriesWorkspaceRepoSlugCommitCommitStatusesBuildKey(ctx context.Context, request operations.PutRepositoriesWorkspaceRepoSlugCommitCommitStatusesBuildKeyRequest) (*operations.PutRepositoriesWorkspaceRepoSlugCommitCommitStatusesBuildKeyResponse, error) {
	baseURL := s.serverURL
	url := utils.GenerateURL(ctx, baseURL, "/repositories/{workspace}/{repo_slug}/commit/{commit}/statuses/build/{key}", request.PathParams, nil)

	bodyReader, reqContentType, err := utils.SerializeRequestBody(ctx, request, "Request", "json")
	if err != nil {
		return nil, fmt.Errorf("error serializing request body: %w", err)
	}

	req, err := http.NewRequestWithContext(ctx, "PUT", url, bodyReader)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	req.Header.Set("Content-Type", reqContentType)

	client := utils.ConfigureSecurityClient(s.defaultClient, request.Security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.PutRepositoriesWorkspaceRepoSlugCommitCommitStatusesBuildKeyResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out map[string]interface{}
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.Commitstatus = out
		}
	case httpRes.StatusCode == 401:
	case httpRes.StatusCode == 404:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out map[string]interface{}
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.Error = out
		}
	}

	return res, nil
}

// PutRepositoriesWorkspaceRepoSlugHooksUID - Updates the specified webhook subscription.
//
// The following properties can be mutated:
//
// * `description`
// * `url`
// * `active`
// * `events`
func (s *repositories) PutRepositoriesWorkspaceRepoSlugHooksUID(ctx context.Context, request operations.PutRepositoriesWorkspaceRepoSlugHooksUIDRequest) (*operations.PutRepositoriesWorkspaceRepoSlugHooksUIDResponse, error) {
	baseURL := s.serverURL
	url := utils.GenerateURL(ctx, baseURL, "/repositories/{workspace}/{repo_slug}/hooks/{uid}", request.PathParams, nil)

	req, err := http.NewRequestWithContext(ctx, "PUT", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	client := utils.ConfigureSecurityClient(s.defaultClient, request.Security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.PutRepositoriesWorkspaceRepoSlugHooksUIDResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out map[string]interface{}
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.WebhookSubscription = out
		}
	case httpRes.StatusCode == 403:
		fallthrough
	case httpRes.StatusCode == 404:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out map[string]interface{}
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.Error = out
		}
	}

	return res, nil
}
