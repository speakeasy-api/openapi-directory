"""Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT."""

from __future__ import annotations
import dataclasses
import dateutil.parser
from ..shared import responseaddress as shared_responseaddress
from dataclasses_json import Undefined, dataclass_json
from datetime import datetime
from enum import Enum
from marshmallow import fields
from sdk import utils
from typing import Optional

class ActivityTypeEnum(str, Enum):
    r"""type of activity"""
    START = 'start'
    END = 'end'
    SERVICE = 'service'
    PICKUP_SHIPMENT = 'pickupShipment'
    DELIVER_SHIPMENT = 'deliverShipment'
    PICKUP = 'pickup'
    DELIVERY = 'delivery'
    BREAK = 'break'


@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class Activity:
    
    address: Optional[shared_responseaddress.ResponseAddress] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('address'), 'exclude': lambda f: f is None }})
    r"""Address of activity"""  
    arr_date_time: Optional[datetime] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('arr_date_time'), 'encoder': utils.datetimeisoformat(True), 'decoder': dateutil.parser.isoparse, 'mm_field': fields.DateTime(format='iso'), 'exclude': lambda f: f is None }})
    r"""Arrival date time with offset like this 1970-01-01T01:00+01:00. If you do not use time-dependent optimization, this is `null`."""  
    arr_time: Optional[int] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('arr_time'), 'exclude': lambda f: f is None }})
    r"""Arrival time at this activity in seconds. If type is `start`, this is not available (since it makes no sense to have `arr_time` at start). However, `end_time` is available and actually means \\\"departure time\\\" at start location. It is important to note that `arr_time` does not necessarily mean \\\"start of underlying activity\\\", it solely means arrival time at activity location. If this activity has no time windows and if there are no further preparation times, `arr_time` is equal to activity start time."""  
    distance: Optional[int] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('distance'), 'exclude': lambda f: f is None }})
    r"""cumulated distance from start to this activity in m"""  
    driving_time: Optional[int] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('driving_time'), 'exclude': lambda f: f is None }})
    r"""cumulated driving time from start to this driver activity in seconds"""  
    end_date_time: Optional[datetime] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('end_date_time'), 'encoder': utils.datetimeisoformat(True), 'decoder': dateutil.parser.isoparse, 'mm_field': fields.DateTime(format='iso'), 'exclude': lambda f: f is None }})
    r"""End date time with offset like this 1970-01-01T01:00+01:00. If you do not use time-dependent optimization, this is `null`."""  
    end_time: Optional[int] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('end_time'), 'exclude': lambda f: f is None }})
    r"""End time of and thus departure time at this activity. If type is `end`, this is not available (since it makes no sense to have an `end_time` at end) `end_time` at each activity is equal to the departure time at the activity location."""  
    id: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('id'), 'exclude': lambda f: f is None }})
    r"""Id referring to the underlying service or shipment, i.e. the shipment or service this activity belongs to"""  
    load_after: Optional[list[int]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('load_after'), 'exclude': lambda f: f is None }})
    r"""Array with size/capacity dimensions after this activity"""  
    load_before: Optional[list[int]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('load_before'), 'exclude': lambda f: f is None }})
    r"""Array with size/capacity dimensions before this activity"""  
    location_id: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('location_id'), 'exclude': lambda f: f is None }})
    r"""Id that refers to address"""  
    preparation_time: Optional[int] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('preparation_time'), 'exclude': lambda f: f is None }})
    r"""preparation time at this activity in seconds"""  
    type: Optional[ActivityTypeEnum] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('type'), 'exclude': lambda f: f is None }})
    r"""type of activity"""  
    waiting_time: Optional[int] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('waiting_time'), 'exclude': lambda f: f is None }})
    r"""Waiting time at this activity in seconds. A waiting time can occur if the activity has at least one time window. If `arr_time` < `time_window.earliest` a waiting time of `time_window_earliest` - `arr_time` occurs."""  
    