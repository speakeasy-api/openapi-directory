"""Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT."""

import requests as requests_http
from . import utils
from sdk.models import operations, shared
from typing import Any, Optional

class Users:
    _client: requests_http.Session
    _security_client: requests_http.Session
    _server_url: str
    _language: str
    _sdk_version: str
    _gen_version: str

    def __init__(self, client: requests_http.Session, security_client: requests_http.Session, server_url: str, language: str, sdk_version: str, gen_version: str) -> None:
        self._client = client
        self._security_client = security_client
        self._server_url = server_url
        self._language = language
        self._sdk_version = sdk_version
        self._gen_version = gen_version
        
    def delete_realm_users_id_(self, request: operations.DeleteRealmUsersIDRequest) -> operations.DeleteRealmUsersIDResponse:
        r"""Delete the user"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.DeleteRealmUsersIDRequest, base_url, '/{realm}/users/{id}', request)
        
        
        client = self._security_client
        
        http_res = client.request('DELETE', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DeleteRealmUsersIDResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        

        return res

    def delete_realm_users_id_consents_client_(self, request: operations.DeleteRealmUsersIDConsentsClientRequest) -> operations.DeleteRealmUsersIDConsentsClientResponse:
        r"""Revoke consent and offline tokens for particular client from user"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.DeleteRealmUsersIDConsentsClientRequest, base_url, '/{realm}/users/{id}/consents/{client}', request)
        
        
        client = self._security_client
        
        http_res = client.request('DELETE', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DeleteRealmUsersIDConsentsClientResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        

        return res

    def delete_realm_users_id_credentials_credential_id_(self, request: operations.DeleteRealmUsersIDCredentialsCredentialIDRequest) -> operations.DeleteRealmUsersIDCredentialsCredentialIDResponse:
        r"""Remove a credential for a user"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.DeleteRealmUsersIDCredentialsCredentialIDRequest, base_url, '/{realm}/users/{id}/credentials/{credentialId}', request)
        
        
        client = self._security_client
        
        http_res = client.request('DELETE', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DeleteRealmUsersIDCredentialsCredentialIDResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        

        return res

    def delete_realm_users_id_federated_identity_provider_(self, request: operations.DeleteRealmUsersIDFederatedIdentityProviderRequest) -> operations.DeleteRealmUsersIDFederatedIdentityProviderResponse:
        r"""Remove a social login provider from user"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.DeleteRealmUsersIDFederatedIdentityProviderRequest, base_url, '/{realm}/users/{id}/federated-identity/{provider}', request)
        
        
        client = self._security_client
        
        http_res = client.request('DELETE', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DeleteRealmUsersIDFederatedIdentityProviderResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        

        return res

    def delete_realm_users_id_groups_group_id_(self, request: operations.DeleteRealmUsersIDGroupsGroupIDRequest) -> operations.DeleteRealmUsersIDGroupsGroupIDResponse:
        base_url = self._server_url
        
        url = utils.generate_url(operations.DeleteRealmUsersIDGroupsGroupIDRequest, base_url, '/{realm}/users/{id}/groups/{groupId}', request)
        
        
        client = self._security_client
        
        http_res = client.request('DELETE', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DeleteRealmUsersIDGroupsGroupIDResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        

        return res

    def get_realm_users(self, request: operations.GetRealmUsersRequest) -> operations.GetRealmUsersResponse:
        r"""Get users   Returns a list of users, filtered according to query parameters"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.GetRealmUsersRequest, base_url, '/{realm}/users', request)
        
        query_params = utils.get_query_params(operations.GetRealmUsersRequest, request)
        
        client = self._security_client
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetRealmUsersResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code >= 200 and http_res.status_code < 300:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[list[shared.UserRepresentation]])
                res.user_representations = out

        return res

    def get_realm_users_count(self, request: operations.GetRealmUsersCountRequest) -> operations.GetRealmUsersCountResponse:
        r"""Returns the number of users that match the given criteria."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.GetRealmUsersCountRequest, base_url, '/{realm}/users/count', request)
        
        query_params = utils.get_query_params(operations.GetRealmUsersCountRequest, request)
        
        client = self._security_client
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetRealmUsersCountResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code >= 200 and http_res.status_code < 300:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[int])
                res.get_realm_users_count_2_xx_application_json_int32_integer = out

        return res

    def get_realm_users_id_(self, request: operations.GetRealmUsersIDRequest) -> operations.GetRealmUsersIDResponse:
        r"""Get representation of the user"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.GetRealmUsersIDRequest, base_url, '/{realm}/users/{id}', request)
        
        
        client = self._security_client
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetRealmUsersIDResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code >= 200 and http_res.status_code < 300:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.UserRepresentation])
                res.user_representation = out

        return res

    def get_realm_users_id_configured_user_storage_credential_types(self, request: operations.GetRealmUsersIDConfiguredUserStorageCredentialTypesRequest) -> operations.GetRealmUsersIDConfiguredUserStorageCredentialTypesResponse:
        r"""Return credential types, which are provided by the user storage where user is stored."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.GetRealmUsersIDConfiguredUserStorageCredentialTypesRequest, base_url, '/{realm}/users/{id}/configured-user-storage-credential-types', request)
        
        
        client = self._security_client
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetRealmUsersIDConfiguredUserStorageCredentialTypesResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code >= 200 and http_res.status_code < 300:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[list[str]])
                res.get_realm_users_id_configured_user_storage_credential_types_2_xx_application_json_strings = out

        return res

    def get_realm_users_id_consents(self, request: operations.GetRealmUsersIDConsentsRequest) -> operations.GetRealmUsersIDConsentsResponse:
        r"""Get consents granted by the user"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.GetRealmUsersIDConsentsRequest, base_url, '/{realm}/users/{id}/consents', request)
        
        
        client = self._security_client
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetRealmUsersIDConsentsResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code >= 200 and http_res.status_code < 300:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[list[dict[str, Any]]])
                res.get_realm_users_id_consents_2_xx_application_json_objects = out

        return res

    def get_realm_users_id_credentials(self, request: operations.GetRealmUsersIDCredentialsRequest) -> operations.GetRealmUsersIDCredentialsResponse:
        base_url = self._server_url
        
        url = utils.generate_url(operations.GetRealmUsersIDCredentialsRequest, base_url, '/{realm}/users/{id}/credentials', request)
        
        
        client = self._security_client
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetRealmUsersIDCredentialsResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code >= 200 and http_res.status_code < 300:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[list[shared.CredentialRepresentation]])
                res.credential_representations = out

        return res

    def get_realm_users_id_federated_identity(self, request: operations.GetRealmUsersIDFederatedIdentityRequest) -> operations.GetRealmUsersIDFederatedIdentityResponse:
        r"""Get social logins associated with the user"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.GetRealmUsersIDFederatedIdentityRequest, base_url, '/{realm}/users/{id}/federated-identity', request)
        
        
        client = self._security_client
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetRealmUsersIDFederatedIdentityResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code >= 200 and http_res.status_code < 300:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[list[shared.FederatedIdentityRepresentation]])
                res.federated_identity_representations = out

        return res

    def get_realm_users_id_groups(self, request: operations.GetRealmUsersIDGroupsRequest) -> operations.GetRealmUsersIDGroupsResponse:
        base_url = self._server_url
        
        url = utils.generate_url(operations.GetRealmUsersIDGroupsRequest, base_url, '/{realm}/users/{id}/groups', request)
        
        query_params = utils.get_query_params(operations.GetRealmUsersIDGroupsRequest, request)
        
        client = self._security_client
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetRealmUsersIDGroupsResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code >= 200 and http_res.status_code < 300:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[list[shared.GroupRepresentation]])
                res.group_representations = out

        return res

    def get_realm_users_id_groups_count(self, request: operations.GetRealmUsersIDGroupsCountRequest) -> operations.GetRealmUsersIDGroupsCountResponse:
        base_url = self._server_url
        
        url = utils.generate_url(operations.GetRealmUsersIDGroupsCountRequest, base_url, '/{realm}/users/{id}/groups/count', request)
        
        query_params = utils.get_query_params(operations.GetRealmUsersIDGroupsCountRequest, request)
        
        client = self._security_client
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetRealmUsersIDGroupsCountResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code >= 200 and http_res.status_code < 300:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[dict[str, Any]])
                res.get_realm_users_id_groups_count_2_xx_application_json_object = out

        return res

    def get_realm_users_id_offline_sessions_client_id_(self, request: operations.GetRealmUsersIDOfflineSessionsClientIDRequest) -> operations.GetRealmUsersIDOfflineSessionsClientIDResponse:
        r"""Get offline sessions associated with the user and client"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.GetRealmUsersIDOfflineSessionsClientIDRequest, base_url, '/{realm}/users/{id}/offline-sessions/{clientId}', request)
        
        
        client = self._security_client
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetRealmUsersIDOfflineSessionsClientIDResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code >= 200 and http_res.status_code < 300:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[list[shared.UserSessionRepresentation]])
                res.user_session_representations = out

        return res

    def get_realm_users_id_sessions(self, request: operations.GetRealmUsersIDSessionsRequest) -> operations.GetRealmUsersIDSessionsResponse:
        r"""Get sessions associated with the user"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.GetRealmUsersIDSessionsRequest, base_url, '/{realm}/users/{id}/sessions', request)
        
        
        client = self._security_client
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetRealmUsersIDSessionsResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code >= 200 and http_res.status_code < 300:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[list[shared.UserSessionRepresentation]])
                res.user_session_representations = out

        return res

    def post_realm_users(self, request: operations.PostRealmUsersRequest) -> operations.PostRealmUsersResponse:
        r"""Create a new user   Username must be unique."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.PostRealmUsersRequest, base_url, '/{realm}/users', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "user_representation", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = self._security_client
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.PostRealmUsersResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        

        return res

    def post_realm_users_id_credentials_credential_id_move_after_new_previous_credential_id_(self, request: operations.PostRealmUsersIDCredentialsCredentialIDMoveAfterNewPreviousCredentialIDRequest) -> operations.PostRealmUsersIDCredentialsCredentialIDMoveAfterNewPreviousCredentialIDResponse:
        r"""Move a credential to a position behind another credential"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.PostRealmUsersIDCredentialsCredentialIDMoveAfterNewPreviousCredentialIDRequest, base_url, '/{realm}/users/{id}/credentials/{credentialId}/moveAfter/{newPreviousCredentialId}', request)
        
        
        client = self._security_client
        
        http_res = client.request('POST', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.PostRealmUsersIDCredentialsCredentialIDMoveAfterNewPreviousCredentialIDResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        

        return res

    def post_realm_users_id_credentials_credential_id_move_to_first(self, request: operations.PostRealmUsersIDCredentialsCredentialIDMoveToFirstRequest) -> operations.PostRealmUsersIDCredentialsCredentialIDMoveToFirstResponse:
        r"""Move a credential to a first position in the credentials list of the user"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.PostRealmUsersIDCredentialsCredentialIDMoveToFirstRequest, base_url, '/{realm}/users/{id}/credentials/{credentialId}/moveToFirst', request)
        
        
        client = self._security_client
        
        http_res = client.request('POST', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.PostRealmUsersIDCredentialsCredentialIDMoveToFirstResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        

        return res

    def post_realm_users_id_federated_identity_provider_(self, request: operations.PostRealmUsersIDFederatedIdentityProviderRequest) -> operations.PostRealmUsersIDFederatedIdentityProviderResponse:
        r"""Add a social login provider to the user"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.PostRealmUsersIDFederatedIdentityProviderRequest, base_url, '/{realm}/users/{id}/federated-identity/{provider}', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "federated_identity_representation", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = self._security_client
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.PostRealmUsersIDFederatedIdentityProviderResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        

        return res

    def post_realm_users_id_impersonation(self, request: operations.PostRealmUsersIDImpersonationRequest) -> operations.PostRealmUsersIDImpersonationResponse:
        r"""Impersonate the user"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.PostRealmUsersIDImpersonationRequest, base_url, '/{realm}/users/{id}/impersonation', request)
        
        
        client = self._security_client
        
        http_res = client.request('POST', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.PostRealmUsersIDImpersonationResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code >= 200 and http_res.status_code < 300:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[dict[str, Any]])
                res.post_realm_users_id_impersonation_2_xx_application_json_object = out

        return res

    def post_realm_users_id_logout(self, request: operations.PostRealmUsersIDLogoutRequest) -> operations.PostRealmUsersIDLogoutResponse:
        r"""Remove all user sessions associated with the user   Also send notification to all clients that have an admin URL to invalidate the sessions for the particular user."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.PostRealmUsersIDLogoutRequest, base_url, '/{realm}/users/{id}/logout', request)
        
        
        client = self._security_client
        
        http_res = client.request('POST', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.PostRealmUsersIDLogoutResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        

        return res

    def put_realm_users_id_(self, request: operations.PutRealmUsersIDRequest) -> operations.PutRealmUsersIDResponse:
        r"""Update the user"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.PutRealmUsersIDRequest, base_url, '/{realm}/users/{id}', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "user_representation", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = self._security_client
        
        http_res = client.request('PUT', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.PutRealmUsersIDResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        

        return res

    def put_realm_users_id_credentials_credential_id_user_label(self, request: operations.PutRealmUsersIDCredentialsCredentialIDUserLabelRequest) -> operations.PutRealmUsersIDCredentialsCredentialIDUserLabelResponse:
        r"""Update a credential label for a user"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.PutRealmUsersIDCredentialsCredentialIDUserLabelRequest, base_url, '/{realm}/users/{id}/credentials/{credentialId}/userLabel', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'string')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = self._security_client
        
        http_res = client.request('PUT', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.PutRealmUsersIDCredentialsCredentialIDUserLabelResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        

        return res

    def put_realm_users_id_disable_credential_types(self, request: operations.PutRealmUsersIDDisableCredentialTypesRequest) -> operations.PutRealmUsersIDDisableCredentialTypesResponse:
        r"""Disable all credentials for a user of a specific type"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.PutRealmUsersIDDisableCredentialTypesRequest, base_url, '/{realm}/users/{id}/disable-credential-types', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = self._security_client
        
        http_res = client.request('PUT', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.PutRealmUsersIDDisableCredentialTypesResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        

        return res

    def put_realm_users_id_execute_actions_email(self, request: operations.PutRealmUsersIDExecuteActionsEmailRequest) -> operations.PutRealmUsersIDExecuteActionsEmailResponse:
        r"""Send a update account email to the user   An email contains a link the user can click to perform a set of required actions."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.PutRealmUsersIDExecuteActionsEmailRequest, base_url, '/{realm}/users/{id}/execute-actions-email', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        query_params = utils.get_query_params(operations.PutRealmUsersIDExecuteActionsEmailRequest, request)
        
        client = self._security_client
        
        http_res = client.request('PUT', url, params=query_params, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.PutRealmUsersIDExecuteActionsEmailResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        

        return res

    def put_realm_users_id_groups_group_id_(self, request: operations.PutRealmUsersIDGroupsGroupIDRequest) -> operations.PutRealmUsersIDGroupsGroupIDResponse:
        base_url = self._server_url
        
        url = utils.generate_url(operations.PutRealmUsersIDGroupsGroupIDRequest, base_url, '/{realm}/users/{id}/groups/{groupId}', request)
        
        
        client = self._security_client
        
        http_res = client.request('PUT', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.PutRealmUsersIDGroupsGroupIDResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        

        return res

    def put_realm_users_id_reset_password(self, request: operations.PutRealmUsersIDResetPasswordRequest) -> operations.PutRealmUsersIDResetPasswordResponse:
        r"""Set up a new password for the user."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.PutRealmUsersIDResetPasswordRequest, base_url, '/{realm}/users/{id}/reset-password', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "credential_representation", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = self._security_client
        
        http_res = client.request('PUT', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.PutRealmUsersIDResetPasswordResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        

        return res

    def put_realm_users_id_send_verify_email(self, request: operations.PutRealmUsersIDSendVerifyEmailRequest) -> operations.PutRealmUsersIDSendVerifyEmailResponse:
        r"""Send an email-verification email to the user   An email contains a link the user can click to verify their email address."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.PutRealmUsersIDSendVerifyEmailRequest, base_url, '/{realm}/users/{id}/send-verify-email', request)
        
        query_params = utils.get_query_params(operations.PutRealmUsersIDSendVerifyEmailRequest, request)
        
        client = self._security_client
        
        http_res = client.request('PUT', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.PutRealmUsersIDSendVerifyEmailResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        

        return res

    