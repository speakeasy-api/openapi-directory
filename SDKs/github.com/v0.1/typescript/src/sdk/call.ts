/*
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

import * as utils from "../internal/utils";
import * as operations from "./models/operations";
import * as shared from "./models/shared";
import { AxiosInstance, AxiosRequestConfig, AxiosResponse } from "axios";

/**
 * API methods responsible for spawning and manipulating individual calls
 */
export class Call {
  _defaultClient: AxiosInstance;
  _securityClient: AxiosInstance;
  _serverURL: string;
  _language: string;
  _sdkVersion: string;
  _genVersion: string;

  constructor(
    defaultClient: AxiosInstance,
    securityClient: AxiosInstance,
    serverURL: string,
    language: string,
    sdkVersion: string,
    genVersion: string
  ) {
    this._defaultClient = defaultClient;
    this._securityClient = securityClient;
    this._serverURL = serverURL;
    this._language = language;
    this._sdkVersion = sdkVersion;
    this._genVersion = genVersion;
  }

  /**
   * /v0.1/BulkCall/
   *
   * @remarks
   * Initiates multiple concurrent outbound calls
   */
  postV01BulkCall(
    req: shared.BulkCallParameters,
    security: operations.PostV01BulkCallSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.PostV01BulkCallResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new shared.BulkCallParameters(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/v0.1/BulkCall/";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "request",
        "form"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.PostV01BulkCallSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PostV01BulkCallResponse =
        new operations.PostV01BulkCallResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.bulkCallResponse = utils.objectToClass(
              httpRes?.data,
              shared.BulkCallResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * /v0.1/Call/
   *
   * @remarks
   * Initiates an outbound call
   */
  postV01Call(
    req: shared.CallParameters,
    security: operations.PostV01CallSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.PostV01CallResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new shared.CallParameters(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/v0.1/Call/";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "request",
        "form"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.PostV01CallSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PostV01CallResponse =
        new operations.PostV01CallResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.callResponse = utils.objectToClass(
              httpRes?.data,
              shared.CallResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * /v0.1/CancelScheduledHangup/
   *
   * @remarks
   * Cancels a scheduled hangup for a call
   */
  postV01CancelScheduledHangup(
    req: shared.CancelScheduledHangupParameters,
    security: operations.PostV01CancelScheduledHangupSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.PostV01CancelScheduledHangupResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new shared.CancelScheduledHangupParameters(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/v0.1/CancelScheduledHangup/";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "request",
        "form"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.PostV01CancelScheduledHangupSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PostV01CancelScheduledHangupResponse =
        new operations.PostV01CancelScheduledHangupResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.cancelScheduledHangupResponse = utils.objectToClass(
              httpRes?.data,
              shared.CancelScheduledHangupResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * /v0.1/CancelScheduledPlay/
   *
   * @remarks
   * Cancels a scheduled playback request
   */
  postV01CancelScheduledPlay(
    req: shared.CancelScheduledPlayParameters,
    security: operations.PostV01CancelScheduledPlaySecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.PostV01CancelScheduledPlayResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new shared.CancelScheduledPlayParameters(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/v0.1/CancelScheduledPlay/";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "request",
        "form"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.PostV01CancelScheduledPlaySecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PostV01CancelScheduledPlayResponse =
        new operations.PostV01CancelScheduledPlayResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.cancelScheduledPlayResponse = utils.objectToClass(
              httpRes?.data,
              shared.CancelScheduledPlayResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * /v0.1/GroupCall/
   *
   * @remarks
   * Initiate multiple racing outbound calls
   */
  postV01GroupCall(
    req: shared.GroupCallParameters,
    security: operations.PostV01GroupCallSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.PostV01GroupCallResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new shared.GroupCallParameters(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/v0.1/GroupCall/";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "request",
        "form"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.PostV01GroupCallSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PostV01GroupCallResponse =
        new operations.PostV01GroupCallResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.groupCallResponse = utils.objectToClass(
              httpRes?.data,
              shared.GroupCallResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * /v0.1/HangupAllCalls/
   *
   * @remarks
   * Hangs up all established calls
   */
  postV01HangupAllCalls(
    config?: AxiosRequestConfig
  ): Promise<operations.PostV01HangupAllCallsResponse> {
    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/v0.1/HangupAllCalls/";

    const client: AxiosInstance = this._defaultClient;

    const r = client.request({
      url: url,
      method: "post",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PostV01HangupAllCallsResponse =
        new operations.PostV01HangupAllCallsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.hangupAllCallsResponse = utils.objectToClass(
              httpRes?.data,
              shared.HangupAllCallsResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * /v0.1/HangupCall/
   *
   * @remarks
   * Hangs up a specific call
   */
  postV01HangupCall(
    req: shared.HangupCallParameters,
    security: operations.PostV01HangupCallSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.PostV01HangupCallResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new shared.HangupCallParameters(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/v0.1/HangupCall/";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "request",
        "form"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.PostV01HangupCallSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PostV01HangupCallResponse =
        new operations.PostV01HangupCallResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.hangupCallResponse = utils.objectToClass(
              httpRes?.data,
              shared.HangupCallResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * /v0.1/Play/
   *
   * @remarks
   * Plays media into a live call
   */
  postV01Play(
    req: shared.PlayParameters,
    security: operations.PostV01PlaySecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.PostV01PlayResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new shared.PlayParameters(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/v0.1/Play/";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "request",
        "form"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.PostV01PlaySecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PostV01PlayResponse =
        new operations.PostV01PlayResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.playResponse = utils.objectToClass(
              httpRes?.data,
              shared.PlayResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * /v0.1/PlayStop/
   *
   * @remarks
   * Interrupts media playback on a given call
   */
  postV01PlayStop(
    req: shared.PlayStopParameters,
    security: operations.PostV01PlayStopSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.PostV01PlayStopResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new shared.PlayStopParameters(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/v0.1/PlayStop/";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "request",
        "form"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.PostV01PlayStopSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PostV01PlayStopResponse =
        new operations.PostV01PlayStopResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.playStopResponse = utils.objectToClass(
              httpRes?.data,
              shared.PlayStopResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * /v0.1/RecordStart/
   *
   * @remarks
   * Initiates recording of a given call
   */
  postV01RecordStart(
    req: shared.RecordStartParameters,
    security: operations.PostV01RecordStartSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.PostV01RecordStartResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new shared.RecordStartParameters(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/v0.1/RecordStart/";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "request",
        "form"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.PostV01RecordStartSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PostV01RecordStartResponse =
        new operations.PostV01RecordStartResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.recordStartResponse = utils.objectToClass(
              httpRes?.data,
              shared.RecordStartResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * /v0.1/RecordStop/
   *
   * @remarks
   * Stops the recording of a given call
   */
  postV01RecordStop(
    req: shared.RecordStopParameters,
    security: operations.PostV01RecordStopSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.PostV01RecordStopResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new shared.RecordStopParameters(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/v0.1/RecordStop/";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "request",
        "form"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.PostV01RecordStopSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PostV01RecordStopResponse =
        new operations.PostV01RecordStopResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.recordStopResponse = utils.objectToClass(
              httpRes?.data,
              shared.RecordStopResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * /v0.1/ScheduleHangup/
   *
   * @remarks
   * Schedules a hangup for a specific call
   */
  postV01ScheduleHangup(
    req: shared.ScheduleHangupParameters,
    security: operations.PostV01ScheduleHangupSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.PostV01ScheduleHangupResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new shared.ScheduleHangupParameters(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/v0.1/ScheduleHangup/";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "request",
        "form"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.PostV01ScheduleHangupSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PostV01ScheduleHangupResponse =
        new operations.PostV01ScheduleHangupResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.scheduleHangupResponse = utils.objectToClass(
              httpRes?.data,
              shared.ScheduleHangupResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * /v0.1/SchedulePlay/
   *
   * @remarks
   * Schedules media playback for a specific call
   */
  postV01SchedulePlay(
    req: shared.SchedulePlayParameters,
    security: operations.PostV01SchedulePlaySecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.PostV01SchedulePlayResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new shared.SchedulePlayParameters(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/v0.1/SchedulePlay/";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "request",
        "form"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.PostV01SchedulePlaySecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PostV01SchedulePlayResponse =
        new operations.PostV01SchedulePlayResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.schedulePlayResponse = utils.objectToClass(
              httpRes?.data,
              shared.SchedulePlayResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * /v0.1/SendDigits/
   *
   * @remarks
   * Emits DMTF tones to a call
   */
  postV01SendDigits(
    req: shared.SendDigitsParameters,
    security: operations.PostV01SendDigitsSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.PostV01SendDigitsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new shared.SendDigitsParameters(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/v0.1/SendDigits/";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "request",
        "form"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.PostV01SendDigitsSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PostV01SendDigitsResponse =
        new operations.PostV01SendDigitsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.sendDigitsResponse = utils.objectToClass(
              httpRes?.data,
              shared.SendDigitsResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * /v0.1/SoundTouch/
   *
   * @remarks
   * Applies SoundTouch effects to a live call
   */
  postV01SoundTouch(
    req: shared.SoundTouchParameters,
    security: operations.PostV01SoundTouchSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.PostV01SoundTouchResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new shared.SoundTouchParameters(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/v0.1/SoundTouch/";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "request",
        "form"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.PostV01SoundTouchSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PostV01SoundTouchResponse =
        new operations.PostV01SoundTouchResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.soundTouchResponse = utils.objectToClass(
              httpRes?.data,
              shared.SoundTouchResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * /v0.1/SoundTouchStop/
   *
   * @remarks
   * Removes SoundTouch effects from a given call
   */
  postV01SoundTouchStop(
    req: shared.SoundTouchStopParameters,
    security: operations.PostV01SoundTouchStopSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.PostV01SoundTouchStopResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new shared.SoundTouchStopParameters(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/v0.1/SoundTouchStop/";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "request",
        "form"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.PostV01SoundTouchStopSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PostV01SoundTouchStopResponse =
        new operations.PostV01SoundTouchStopResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.soundTouchStopResponse = utils.objectToClass(
              httpRes?.data,
              shared.SoundTouchStopResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * /v0.1/TransferCall/
   *
   * @remarks
   * Replaces the RestXML flow of a live call
   */
  postV01TransferCall(
    req: shared.TransferCallParameters,
    security: operations.PostV01TransferCallSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.PostV01TransferCallResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new shared.TransferCallParameters(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/v0.1/TransferCall/";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "request",
        "form"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.PostV01TransferCallSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PostV01TransferCallResponse =
        new operations.PostV01TransferCallResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.transferCallResponse = utils.objectToClass(
              httpRes?.data,
              shared.TransferCallResponse
            );
          }
          break;
      }

      return res;
    });
  }
}
