<?php

/**
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

declare(strict_types=1);

namespace OpenAPI\OpenAPI;

class V1 
{

	// SDK private variables namespaced with _ to avoid conflicts with API models
	private \GuzzleHttp\ClientInterface $_defaultClient;
	private \GuzzleHttp\ClientInterface $_securityClient;
	private string $_serverUrl;
	private string $_language;
	private string $_sdkVersion;
	private string $_genVersion;	

	/**
	 * @param \GuzzleHttp\ClientInterface $defaultClient
	 * @param \GuzzleHttp\ClientInterface $securityClient
	 * @param string $serverUrl
	 * @param string $language
	 * @param string $sdkVersion
	 * @param string $genVersion
	 */
	public function __construct(\GuzzleHttp\ClientInterface $defaultClient, \GuzzleHttp\ClientInterface $securityClient, string $serverUrl, string $language, string $sdkVersion, string $genVersion)
	{
		$this->_defaultClient = $defaultClient;
		$this->_securityClient = $securityClient;
		$this->_serverUrl = $serverUrl;
		$this->_language = $language;
		$this->_sdkVersion = $sdkVersion;
		$this->_genVersion = $genVersion;
	}
	
    /**
     * Retrieve all certificate actions
     * 
     * This method is used to retrieve all stateful actions relating to a certificate lifecycle.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\CertificateActionRetrieveRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\CertificateActionRetrieveResponse
     */
	public function certificateActionRetrieve(
        \OpenAPI\OpenAPI\Models\Operations\CertificateActionRetrieveRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\CertificateActionRetrieveResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v1/certificates/{certificateId}/actions', \OpenAPI\OpenAPI\Models\Operations\CertificateActionRetrieveRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_defaultClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\CertificateActionRetrieveResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->arrayOfCertificateAction = $serializer->deserialize((string)$httpResponse->getBody(), 'array<OpenAPI\OpenAPI\Models\Shared\CertificateAction>', 'json');
            }
        }
        else if ($httpResponse->getStatusCode() === 400 or $httpResponse->getStatusCode() === 401 or $httpResponse->getStatusCode() === 403 or $httpResponse->getStatusCode() === 404 or $httpResponse->getStatusCode() === 500) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->error = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\Error', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Add alternate email address
     * 
     * This method adds an alternate email address to a certificate order and re-sends all existing request emails to that address.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\CertificateAlternateEmailAddressRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\CertificateAlternateEmailAddressResponse
     */
	public function certificateAlternateEmailAddress(
        \OpenAPI\OpenAPI\Models\Operations\CertificateAlternateEmailAddressRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\CertificateAlternateEmailAddressResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v1/certificates/{certificateId}/email/resend/{emailAddress}', \OpenAPI\OpenAPI\Models\Operations\CertificateAlternateEmailAddressRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_defaultClient->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\CertificateAlternateEmailAddressResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->certificateEmailHistory = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\CertificateEmailHistory', 'json');
            }
        }
        else if ($httpResponse->getStatusCode() === 404 or $httpResponse->getStatusCode() === 409 or $httpResponse->getStatusCode() === 500) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->error = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\Error', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Unregister system callback
     * 
     * Unregister the callback for a particular certificate.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\CertificateCallbackDeleteRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\CertificateCallbackDeleteResponse
     */
	public function certificateCallbackDelete(
        \OpenAPI\OpenAPI\Models\Operations\CertificateCallbackDeleteRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\CertificateCallbackDeleteResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v1/certificates/{certificateId}/callback', \OpenAPI\OpenAPI\Models\Operations\CertificateCallbackDeleteRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_defaultClient->request('DELETE', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\CertificateCallbackDeleteResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 204) {
        }
        else if ($httpResponse->getStatusCode() === 400 or $httpResponse->getStatusCode() === 401 or $httpResponse->getStatusCode() === 403 or $httpResponse->getStatusCode() === 404 or $httpResponse->getStatusCode() === 500) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->error = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\Error', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Retrieve system stateful action callback url
     * 
     * This method is used to retrieve the registered callback url for a certificate.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\CertificateCallbackGetRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\CertificateCallbackGetResponse
     */
	public function certificateCallbackGet(
        \OpenAPI\OpenAPI\Models\Operations\CertificateCallbackGetRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\CertificateCallbackGetResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v1/certificates/{certificateId}/callback', \OpenAPI\OpenAPI\Models\Operations\CertificateCallbackGetRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_defaultClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\CertificateCallbackGetResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->certificateCallback = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\CertificateCallback', 'json');
            }
        }
        else if ($httpResponse->getStatusCode() === 400 or $httpResponse->getStatusCode() === 401 or $httpResponse->getStatusCode() === 403 or $httpResponse->getStatusCode() === 404 or $httpResponse->getStatusCode() === 500) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->error = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\Error', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Register of certificate action callback
     * 
     * This method is used to register/replace url for callbacks for stateful actions relating to a certificate lifecycle. The callback url is a Webhook style pattern and will receive POST http requests with json body defined in the CertificateAction model definition for each certificate action.  Only one callback URL is allowed to be registered for each certificateId, so it will replace a previous registration.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\CertificateCallbackReplaceRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\CertificateCallbackReplaceResponse
     */
	public function certificateCallbackReplace(
        \OpenAPI\OpenAPI\Models\Operations\CertificateCallbackReplaceRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\CertificateCallbackReplaceResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v1/certificates/{certificateId}/callback', \OpenAPI\OpenAPI\Models\Operations\CertificateCallbackReplaceRequest::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\CertificateCallbackReplaceRequest::class, $request, null));
        
        $httpResponse = $this->_defaultClient->request('PUT', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\CertificateCallbackReplaceResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 204) {
        }
        else if ($httpResponse->getStatusCode() === 400 or $httpResponse->getStatusCode() === 401 or $httpResponse->getStatusCode() === 403 or $httpResponse->getStatusCode() === 404 or $httpResponse->getStatusCode() === 422 or $httpResponse->getStatusCode() === 500) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->error = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\Error', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Cancel a pending certificate
     * 
     * Use the cancel call to cancel a pending certificate order.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\CertificateCancelRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\CertificateCancelResponse
     */
	public function certificateCancel(
        \OpenAPI\OpenAPI\Models\Operations\CertificateCancelRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\CertificateCancelResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v1/certificates/{certificateId}/cancel', \OpenAPI\OpenAPI\Models\Operations\CertificateCancelRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_defaultClient->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\CertificateCancelResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 204) {
        }
        else if ($httpResponse->getStatusCode() === 401 or $httpResponse->getStatusCode() === 403 or $httpResponse->getStatusCode() === 404 or $httpResponse->getStatusCode() === 409 or $httpResponse->getStatusCode() === 500) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->error = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\Error', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Create a pending order for certificate
     * 
     * <p>Creating a certificate order can be a long running asynchronous operation in the PKI workflow. The PKI API supports 2 options for getting the completion stateful actions for this asynchronous operations: 1) by polling operations -- see /v1/certificates/{certificateId}/actions 2) via WebHook style callback -- see '/v1/certificates/{certificateId}/callback'.</p>
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\CertificateCreateRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\CertificateCreateResponse
     */
	public function certificateCreate(
        \OpenAPI\OpenAPI\Models\Operations\CertificateCreateRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\CertificateCreateResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v1/certificates');
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "certificateCreate", "json");
        if ($body === null) {
            throw new \Exception('Request body is required');
        }
        $options = array_merge_recursive($options, $body);
        $options = array_merge_recursive($options, Utils\Utils::getHeaders($request));
        
        $httpResponse = $this->_defaultClient->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\CertificateCreateResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 202) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->certificateIdentifier = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\CertificateIdentifier', 'json');
            }
        }
        else if ($httpResponse->getStatusCode() === 400 or $httpResponse->getStatusCode() === 401 or $httpResponse->getStatusCode() === 403 or $httpResponse->getStatusCode() === 409 or $httpResponse->getStatusCode() === 422 or $httpResponse->getStatusCode() === 500) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->error = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\Error', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Download certificate
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\CertificateDownloadRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\CertificateDownloadResponse
     */
	public function certificateDownload(
        \OpenAPI\OpenAPI\Models\Operations\CertificateDownloadRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\CertificateDownloadResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v1/certificates/{certificateId}/download', \OpenAPI\OpenAPI\Models\Operations\CertificateDownloadRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_defaultClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\CertificateDownloadResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->certificateBundle = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\CertificateBundle', 'json');
            }
        }
        else if ($httpResponse->getStatusCode() === 400 or $httpResponse->getStatusCode() === 401 or $httpResponse->getStatusCode() === 403 or $httpResponse->getStatusCode() === 404 or $httpResponse->getStatusCode() === 409 or $httpResponse->getStatusCode() === 500) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->error = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\Error', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Download certificate by entitlement
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\CertificateDownloadEntitlementRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\CertificateDownloadEntitlementResponse
     */
	public function certificateDownloadEntitlement(
        \OpenAPI\OpenAPI\Models\Operations\CertificateDownloadEntitlementRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\CertificateDownloadEntitlementResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v2/certificates/download');
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\CertificateDownloadEntitlementRequest::class, $request, null));
        
        $httpResponse = $this->_defaultClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\CertificateDownloadEntitlementResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->certificateBundle = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\CertificateBundle', 'json');
            }
        }
        else if ($httpResponse->getStatusCode() === 400 or $httpResponse->getStatusCode() === 401 or $httpResponse->getStatusCode() === 403 or $httpResponse->getStatusCode() === 404 or $httpResponse->getStatusCode() === 409 or $httpResponse->getStatusCode() === 422 or $httpResponse->getStatusCode() === 500) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->error = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\Error', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Retrieve email history
     * 
     * This method can be used to retrieve all emails sent for a certificate.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\CertificateEmailHistoryRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\CertificateEmailHistoryResponse
     */
	public function certificateEmailHistory(
        \OpenAPI\OpenAPI\Models\Operations\CertificateEmailHistoryRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\CertificateEmailHistoryResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v1/certificates/{certificateId}/email/history', \OpenAPI\OpenAPI\Models\Operations\CertificateEmailHistoryRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_defaultClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\CertificateEmailHistoryResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->certificateEmailHistory = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\CertificateEmailHistory', 'json');
            }
        }
        else if ($httpResponse->getStatusCode() === 409 or $httpResponse->getStatusCode() === 500) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->error = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\Error', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Retrieve certificate details
     * 
     * Once the certificate order has been created, this method can be used to check the status of the certificate. This method can also be used to retrieve details of the certificate.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\CertificateGetRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\CertificateGetResponse
     */
	public function certificateGet(
        \OpenAPI\OpenAPI\Models\Operations\CertificateGetRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\CertificateGetResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v1/certificates/{certificateId}', \OpenAPI\OpenAPI\Models\Operations\CertificateGetRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_defaultClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\CertificateGetResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->certificate = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\Certificate', 'json');
            }
        }
        else if ($httpResponse->getStatusCode() === 400 or $httpResponse->getStatusCode() === 401 or $httpResponse->getStatusCode() === 403 or $httpResponse->getStatusCode() === 404 or $httpResponse->getStatusCode() === 500) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->error = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\Error', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Search for certificate details by entitlement
     * 
     * Once the certificate order has been created, this method can be used to check the status of the certificate. This method can also be used to retrieve details of the certificates associated to an entitlement.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\CertificateGetEntitlementRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\CertificateGetEntitlementResponse
     */
	public function certificateGetEntitlement(
        \OpenAPI\OpenAPI\Models\Operations\CertificateGetEntitlementRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\CertificateGetEntitlementResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v2/certificates');
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\CertificateGetEntitlementRequest::class, $request, null));
        
        $httpResponse = $this->_defaultClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\CertificateGetEntitlementResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->certificates = $serializer->deserialize((string)$httpResponse->getBody(), 'array<OpenAPI\OpenAPI\Models\Shared\Certificate>', 'json');
            }
        }
        else if ($httpResponse->getStatusCode() === 400 or $httpResponse->getStatusCode() === 401 or $httpResponse->getStatusCode() === 403 or $httpResponse->getStatusCode() === 422 or $httpResponse->getStatusCode() === 500) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->error = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\Error', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Reissue active certificate
     * 
     * <p>Rekeying is the process by which the private and public key is changed for a certificate. It is a simplified reissue,where only the CSR is changed. Reissuing is the process by which domain names are added or removed from a certificate.Once a request is validated and approved, the certificate will be reissued with the new common name and sans specified. Unlimited reissues are available during the lifetime of the certificate.New names added to a certificate that do not share the base domain of the common name may take additional time to validate. If this API call is made before a previous pending reissue has been validated and issued, the previous reissue request is automatically rejected and replaced with the current request.</p>
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\CertificateReissueRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\CertificateReissueResponse
     */
	public function certificateReissue(
        \OpenAPI\OpenAPI\Models\Operations\CertificateReissueRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\CertificateReissueResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v1/certificates/{certificateId}/reissue', \OpenAPI\OpenAPI\Models\Operations\CertificateReissueRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "certificateReissue", "json");
        if ($body === null) {
            throw new \Exception('Request body is required');
        }
        $options = array_merge_recursive($options, $body);
        
        $httpResponse = $this->_defaultClient->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\CertificateReissueResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 202) {
        }
        else if ($httpResponse->getStatusCode() === 400 or $httpResponse->getStatusCode() === 401 or $httpResponse->getStatusCode() === 403 or $httpResponse->getStatusCode() === 404 or $httpResponse->getStatusCode() === 409 or $httpResponse->getStatusCode() === 422 or $httpResponse->getStatusCode() === 500) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->error = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\Error', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Renew active certificate
     * 
     * Renewal is the process by which the validity of a certificate is extended. Renewal is only available 60 days prior to expiration of the previous certificate and 30 days after the expiration of the previous certificate. The renewal supports modifying a set of the original certificate order information. Once a request is validated and approved, the certificate will be issued with extended validity. Since subject alternative names can be removed during a renewal, we require that you provide the subject alternative names you expect in the renewed certificate. New names added to a certificate that do not share the base domain of the common name may take additional time to validate. </p>
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\CertificateRenewRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\CertificateRenewResponse
     */
	public function certificateRenew(
        \OpenAPI\OpenAPI\Models\Operations\CertificateRenewRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\CertificateRenewResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v1/certificates/{certificateId}/renew', \OpenAPI\OpenAPI\Models\Operations\CertificateRenewRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "certificateRenew", "json");
        if ($body === null) {
            throw new \Exception('Request body is required');
        }
        $options = array_merge_recursive($options, $body);
        
        $httpResponse = $this->_defaultClient->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\CertificateRenewResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 202) {
        }
        else if ($httpResponse->getStatusCode() === 400 or $httpResponse->getStatusCode() === 401 or $httpResponse->getStatusCode() === 403 or $httpResponse->getStatusCode() === 404 or $httpResponse->getStatusCode() === 409 or $httpResponse->getStatusCode() === 422 or $httpResponse->getStatusCode() === 500) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->error = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\Error', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Resend an email
     * 
     * This method can be used to resend emails by providing the certificate id and the email id
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\CertificateResendEmailRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\CertificateResendEmailResponse
     */
	public function certificateResendEmail(
        \OpenAPI\OpenAPI\Models\Operations\CertificateResendEmailRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\CertificateResendEmailResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v1/certificates/{certificateId}/email/{emailId}/resend', \OpenAPI\OpenAPI\Models\Operations\CertificateResendEmailRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_defaultClient->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\CertificateResendEmailResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 204) {
        }
        else if ($httpResponse->getStatusCode() === 404 or $httpResponse->getStatusCode() === 409 or $httpResponse->getStatusCode() === 500) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->error = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\Error', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Resend email to email address
     * 
     * This method can be used to resend emails by providing the certificate id, the email id, and the recipient email address
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\CertificateResendEmailAddressRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\CertificateResendEmailAddressResponse
     */
	public function certificateResendEmailAddress(
        \OpenAPI\OpenAPI\Models\Operations\CertificateResendEmailAddressRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\CertificateResendEmailAddressResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v1/certificates/{certificateId}/email/{emailId}/resend/{emailAddress}', \OpenAPI\OpenAPI\Models\Operations\CertificateResendEmailAddressRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_defaultClient->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\CertificateResendEmailAddressResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 204) {
        }
        else if ($httpResponse->getStatusCode() === 404 or $httpResponse->getStatusCode() === 409 or $httpResponse->getStatusCode() === 500) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->error = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\Error', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Revoke active certificate
     * 
     * Use revoke call to revoke an active certificate, if the certificate has not been issued a 404 response will be returned.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\CertificateRevokeRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\CertificateRevokeResponse
     */
	public function certificateRevoke(
        \OpenAPI\OpenAPI\Models\Operations\CertificateRevokeRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\CertificateRevokeResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v1/certificates/{certificateId}/revoke', \OpenAPI\OpenAPI\Models\Operations\CertificateRevokeRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "certificateRevoke", "json");
        if ($body === null) {
            throw new \Exception('Request body is required');
        }
        $options = array_merge_recursive($options, $body);
        
        $httpResponse = $this->_defaultClient->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\CertificateRevokeResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 204) {
        }
        else if ($httpResponse->getStatusCode() === 400 or $httpResponse->getStatusCode() === 401 or $httpResponse->getStatusCode() === 403 or $httpResponse->getStatusCode() === 404 or $httpResponse->getStatusCode() === 409 or $httpResponse->getStatusCode() === 500) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->error = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\Error', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Get Site seal
     * 
     * <p>This method is used to obtain the site seal information for an issued certificate. A site seal is a graphic that the certificate purchaser can embed on their web site to show their visitors information about their SSL certificate. If a web site visitor clicks on the site seal image, a pop-up page is displayed that contains detailed information about the SSL certificate. The site seal token is used to link the site seal graphic image to the appropriate certificate details pop-up page display when a user clicks on the site seal. The site seal images are expected to be static images and hosted on the reseller's website, to minimize delays for customer page load times.</p>
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\CertificateSitesealGetRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\CertificateSitesealGetResponse
     */
	public function certificateSitesealGet(
        \OpenAPI\OpenAPI\Models\Operations\CertificateSitesealGetRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\CertificateSitesealGetResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v1/certificates/{certificateId}/siteSeal', \OpenAPI\OpenAPI\Models\Operations\CertificateSitesealGetRequest::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\CertificateSitesealGetRequest::class, $request, null));
        
        $httpResponse = $this->_defaultClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\CertificateSitesealGetResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->certificateSiteSeal = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\CertificateSiteSeal', 'json');
            }
        }
        else if ($httpResponse->getStatusCode() === 400 or $httpResponse->getStatusCode() === 401 or $httpResponse->getStatusCode() === 403 or $httpResponse->getStatusCode() === 404 or $httpResponse->getStatusCode() === 409 or $httpResponse->getStatusCode() === 422 or $httpResponse->getStatusCode() === 500) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->error = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\Error', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Validate a pending order for certificate
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\CertificateValidateRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\CertificateValidateResponse
     */
	public function certificateValidate(
        \OpenAPI\OpenAPI\Models\Operations\CertificateValidateRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\CertificateValidateResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v1/certificates/validate');
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "certificateCreate", "json");
        if ($body === null) {
            throw new \Exception('Request body is required');
        }
        $options = array_merge_recursive($options, $body);
        $options = array_merge_recursive($options, Utils\Utils::getHeaders($request));
        
        $httpResponse = $this->_defaultClient->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\CertificateValidateResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 204) {
        }
        else if ($httpResponse->getStatusCode() === 400 or $httpResponse->getStatusCode() === 401 or $httpResponse->getStatusCode() === 403 or $httpResponse->getStatusCode() === 409 or $httpResponse->getStatusCode() === 422 or $httpResponse->getStatusCode() === 500) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->error = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\Error', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Check Domain Control
     * 
     * Domain control is a means for verifying the domain included in the certificate order. This resource is useful for resellers that control the domains for their customers, and can expedite the verification process. See https://www.godaddy.com/help/verifying-your-domain-ownership-for-ssl-certificate-requests-html-or-dns-7452
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\CertificateVerifydomaincontrolRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\CertificateVerifydomaincontrolResponse
     */
	public function certificateVerifydomaincontrol(
        \OpenAPI\OpenAPI\Models\Operations\CertificateVerifydomaincontrolRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\CertificateVerifydomaincontrolResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v1/certificates/{certificateId}/verifyDomainControl', \OpenAPI\OpenAPI\Models\Operations\CertificateVerifydomaincontrolRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_defaultClient->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\CertificateVerifydomaincontrolResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 204) {
        }
        else if ($httpResponse->getStatusCode() === 400 or $httpResponse->getStatusCode() === 401 or $httpResponse->getStatusCode() === 403 or $httpResponse->getStatusCode() === 404 or $httpResponse->getStatusCode() === 409 or $httpResponse->getStatusCode() === 500) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->error = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\Error', 'json');
            }
        }

        return $response;
    }
}