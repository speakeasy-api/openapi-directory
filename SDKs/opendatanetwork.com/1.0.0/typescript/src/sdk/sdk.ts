/*
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

import * as utils from "../internal/utils";
import * as operations from "./models/operations";
import axios from "axios";
import { AxiosInstance, AxiosRequestConfig, AxiosResponse } from "axios";

/**
 * Contains the list of servers available to the SDK
 */
export const ServerList = ["http://api.opendatanetwork.com"] as const;

/**
 * The available configuration options for the SDK
 */
export type SDKProps = {
  /**
   * Allows overriding the default axios client used by the SDK
   */
  defaultClient?: AxiosInstance;
  /**
   * Allows overriding the default server URL used by the SDK
   */
  serverURL?: string;
};

/**
 * The Socrata OpenDataNetwork (ODN) REST API exposes public data, often continuosly updated and enhanced, from many thousands of public
 *
 * @remarks
 * government and non profit agencies.
 *
 * Much of this data originating from independent sources is fused together to create new, and often
 * powerful, entity level data. The API, in addition to search and autosuggest capabilities for finding datasets,
 * enables data based comparisons across geographical regions such as states, counties, metropolitan areas,
 * cities and zip codes using highly vetted data providers such as US Census, BEA, HUD and others. Comparison data
 * is preformatted for easy and efficient display on a chart, graph or interactive map.
 *
 * The API also exposes data organized by narrative style questions a human might ask. The questions can
 * be rapidly found using an autosuggest style index, and then used to directly access all data needed to
 * thoroughly and authoritatively answer the question. Retrieved data includes time series (temporally aligned),
 * tabular, map heavy (includes spatial boundaries), and auto generated unstructured descriptive text.
 *
 * The ODN API does not duplicate API endpoints or services provided by public sector agencies, but rather,
 * returns context relevant pre-populated REST URLs, when appropriate, so the caller can access data
 * directly from the source.
 *
 * The [open source](http://github.com/socrata/odn-backend) API powers [OpenDataNetwork.com](http://OpenDataNetwork.com), an [open source](http://github.com/socrata/opendatanetwork.com)
 * site; the site highlights myriad uses and provides API badges with contextually relevant API example
 * REST endpoints and documentation pointers.
 *
 * Finally, we continuously add new dat sources which appear automatically in the API, so if your favorite data
 * source is not available, check back soon. You can also join us [HERE](http://www.opendatanetwork.com/join-open-data-network)
 * and receive updates or let us know which data sources you are most interested in.
 *
 * ## App Tokens
 *
 * Registering for and including a [Socrata application token](https://dev.socrata.com/docs/app-tokens.html)
 * is _required_ for the ODN API. They can be passed either using the `app_token` parameter
 * or the `X-App-Token` HTTP header.
 */
export class SDK {
  public _defaultClient: AxiosInstance;
  public _securityClient: AxiosInstance;
  public _serverURL: string;
  private _language = "typescript";
  private _sdkVersion = "0.0.1";
  private _genVersion = "internal";
  private _globals: any;

  constructor(props?: SDKProps) {
    this._serverURL = props?.serverURL ?? ServerList[0];

    this._defaultClient =
      props?.defaultClient ?? axios.create({ baseURL: this._serverURL });
    this._securityClient = this._defaultClient;
  }

  /**
   * Create a map
   */
  createAMap(
    req: operations.CreateAMapRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.CreateAMapResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CreateAMapRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/data/v1/map/new";

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      headers: headers,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CreateAMapResponse =
        new operations.CreateAMapResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          break;
      }

      return res;
    });
  }

  /**
   * Find all available data for some entities
   */
  findAllAvailableDataForSomeEntities(
    req: operations.FindAllAvailableDataForSomeEntitiesRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.FindAllAvailableDataForSomeEntitiesResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.FindAllAvailableDataForSomeEntitiesRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/data/v1/availability/";

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      headers: headers,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.FindAllAvailableDataForSomeEntitiesResponse =
        new operations.FindAllAvailableDataForSomeEntitiesResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          break;
      }

      return res;
    });
  }

  /**
   * Find the relatives of an entity
   */
  findTheRelativesOfAnEntity(
    req: operations.FindTheRelativesOfAnEntityRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.FindTheRelativesOfAnEntityResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.FindTheRelativesOfAnEntityRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/entity/v1/{relation}",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      headers: headers,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.FindTheRelativesOfAnEntityResponse =
        new operations.FindTheRelativesOfAnEntityResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          break;
      }

      return res;
    });
  }

  /**
   * Get Entities
   */
  getEntities(
    req: operations.GetEntitiesRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetEntitiesResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetEntitiesRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/entity/v1";

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      headers: headers,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetEntitiesResponse =
        new operations.GetEntitiesResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          break;
      }

      return res;
    });
  }

  /**
   * Get constraint permutations for entities
   */
  getConstraintPermutationsForEntities(
    req: operations.GetConstraintPermutationsForEntitiesRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetConstraintPermutationsForEntitiesResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetConstraintPermutationsForEntitiesRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/data/v1/constraint/{variable}",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      headers: headers,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetConstraintPermutationsForEntitiesResponse =
        new operations.GetConstraintPermutationsForEntitiesResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          break;
      }

      return res;
    });
  }

  /**
   * Get datasets
   */
  getDatasets(
    req: operations.GetDatasetsRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetDatasetsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetDatasetsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/search/v1/dataset";

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      headers: headers,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetDatasetsResponse =
        new operations.GetDatasetsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          break;
      }

      return res;
    });
  }

  /**
   * Get questions
   */
  getQuestions(
    req: operations.GetQuestionsRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetQuestionsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetQuestionsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/search/v1/question";

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      headers: headers,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetQuestionsResponse =
        new operations.GetQuestionsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          break;
      }

      return res;
    });
  }

  /**
   * Get suggestions
   */
  getSuggestions(
    req: operations.GetSuggestionsRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetSuggestionsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetSuggestionsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(baseURL, "/suggest/v1/{type}", req);

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      headers: headers,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetSuggestionsResponse =
        new operations.GetSuggestionsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          break;
      }

      return res;
    });
  }

  /**
   * Get values for variables
   */
  getValuesForVariables(
    req: operations.GetValuesForVariablesRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetValuesForVariablesResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetValuesForVariablesRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/data/v1/values";

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      headers: headers,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetValuesForVariablesResponse =
        new operations.GetValuesForVariablesResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          break;
      }

      return res;
    });
  }
}
