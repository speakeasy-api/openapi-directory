/*
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

import * as utils from "../internal/utils";
import * as operations from "./models/operations";
import * as shared from "./models/shared";
import { AxiosInstance, AxiosRequestConfig, AxiosResponse } from "axios";

/**
 * <p>Source Accounts are where funds are drawn from for making payouts</p>
 *
 * @remarks
 *
 */
export class SourceAccounts {
  _defaultClient: AxiosInstance;
  _securityClient: AxiosInstance;
  _serverURL: string;
  _language: string;
  _sdkVersion: string;
  _genVersion: string;

  constructor(
    defaultClient: AxiosInstance,
    securityClient: AxiosInstance,
    serverURL: string,
    language: string,
    sdkVersion: string,
    genVersion: string
  ) {
    this._defaultClient = defaultClient;
    this._securityClient = securityClient;
    this._serverURL = serverURL;
    this._language = language;
    this._sdkVersion = sdkVersion;
    this._genVersion = genVersion;
  }

  /**
   * Get Source Account
   *
   * @remarks
   * Get details about given source account.
   */
  getSourceAccountV2(
    req: operations.GetSourceAccountV2Request,
    config?: AxiosRequestConfig
  ): Promise<operations.GetSourceAccountV2Response> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetSourceAccountV2Request(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v2/sourceAccounts/{sourceAccountId}",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetSourceAccountV2Response =
        new operations.GetSourceAccountV2Response({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.sourceAccountResponseV2 = utils.objectToClass(
              httpRes?.data,
              shared.SourceAccountResponseV2
            );
          }
          break;
        case httpRes?.status == 400:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.inlineResponse400 = utils.objectToClass(
              httpRes?.data,
              shared.InlineResponse400
            );
          }
          break;
        case httpRes?.status == 401:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.inlineResponse401 = utils.objectToClass(
              httpRes?.data,
              shared.InlineResponse401
            );
          }
          break;
        case httpRes?.status == 403:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.inlineResponse403 = utils.objectToClass(
              httpRes?.data,
              shared.InlineResponse403
            );
          }
          break;
        case httpRes?.status == 404:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.inlineResponse404 = utils.objectToClass(
              httpRes?.data,
              shared.InlineResponse404
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Get details about given source account.
   *
   * @remarks
   * Get details about given source account.
   */
  getSourceAccountV3(
    req: operations.GetSourceAccountV3Request,
    config?: AxiosRequestConfig
  ): Promise<operations.GetSourceAccountV3Response> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetSourceAccountV3Request(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v3/sourceAccounts/{sourceAccountId}",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetSourceAccountV3Response =
        new operations.GetSourceAccountV3Response({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.sourceAccountResponseV3 = utils.objectToClass(
              httpRes?.data,
              shared.SourceAccountResponseV3
            );
          }
          break;
        case httpRes?.status == 400:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.inlineResponse400 = utils.objectToClass(
              httpRes?.data,
              shared.InlineResponse400
            );
          }
          break;
        case httpRes?.status == 401:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.inlineResponse401 = utils.objectToClass(
              httpRes?.data,
              shared.InlineResponse401
            );
          }
          break;
        case httpRes?.status == 403:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.inlineResponse403 = utils.objectToClass(
              httpRes?.data,
              shared.InlineResponse403
            );
          }
          break;
        case httpRes?.status == 404:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.inlineResponse404 = utils.objectToClass(
              httpRes?.data,
              shared.InlineResponse404
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Get list of source accounts
   *
   * @remarks
   * List source accounts.
   */
  getSourceAccountsV2(
    req: operations.GetSourceAccountsV2Request,
    config?: AxiosRequestConfig
  ): Promise<operations.GetSourceAccountsV2Response> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetSourceAccountsV2Request(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/v2/sourceAccounts";

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetSourceAccountsV2Response =
        new operations.GetSourceAccountsV2Response({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listSourceAccountResponseV2 = utils.objectToClass(
              httpRes?.data,
              shared.ListSourceAccountResponseV2
            );
          }
          break;
        case httpRes?.status == 400:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.inlineResponse400 = utils.objectToClass(
              httpRes?.data,
              shared.InlineResponse400
            );
          }
          break;
        case httpRes?.status == 401:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.inlineResponse401 = utils.objectToClass(
              httpRes?.data,
              shared.InlineResponse401
            );
          }
          break;
        case httpRes?.status == 403:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.inlineResponse403 = utils.objectToClass(
              httpRes?.data,
              shared.InlineResponse403
            );
          }
          break;
        case httpRes?.status == 404:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.inlineResponse404 = utils.objectToClass(
              httpRes?.data,
              shared.InlineResponse404
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Get list of source accounts
   *
   * @remarks
   * List source accounts.
   */
  getSourceAccountsV3(
    req: operations.GetSourceAccountsV3Request,
    config?: AxiosRequestConfig
  ): Promise<operations.GetSourceAccountsV3Response> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetSourceAccountsV3Request(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/v3/sourceAccounts";

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetSourceAccountsV3Response =
        new operations.GetSourceAccountsV3Response({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listSourceAccountResponseV3 = utils.objectToClass(
              httpRes?.data,
              shared.ListSourceAccountResponseV3
            );
          }
          break;
        case httpRes?.status == 400:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.inlineResponse400 = utils.objectToClass(
              httpRes?.data,
              shared.InlineResponse400
            );
          }
          break;
        case httpRes?.status == 401:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.inlineResponse401 = utils.objectToClass(
              httpRes?.data,
              shared.InlineResponse401
            );
          }
          break;
        case httpRes?.status == 403:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.inlineResponse403 = utils.objectToClass(
              httpRes?.data,
              shared.InlineResponse403
            );
          }
          break;
        case httpRes?.status == 404:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.inlineResponse404 = utils.objectToClass(
              httpRes?.data,
              shared.InlineResponse404
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Set notifications
   *
   * @remarks
   * <p>Set notifications for a given source account</p>
   * <p>deprecated since 2.34 (use v3 version)</p>
   *
   */
  setNotificationsRequest(
    req: operations.SetNotificationsRequestRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.SetNotificationsRequestResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.SetNotificationsRequestRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v1/sourceAccounts/{sourceAccountId}/notifications",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "setNotificationsRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.SetNotificationsRequestResponse =
        new operations.SetNotificationsRequestResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
        case httpRes?.status == 400:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.inlineResponse400 = utils.objectToClass(
              httpRes?.data,
              shared.InlineResponse400
            );
          }
          break;
        case httpRes?.status == 401:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.inlineResponse401 = utils.objectToClass(
              httpRes?.data,
              shared.InlineResponse401
            );
          }
          break;
        case httpRes?.status == 403:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.inlineResponse403 = utils.objectToClass(
              httpRes?.data,
              shared.InlineResponse403
            );
          }
          break;
        case httpRes?.status == 404:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.inlineResponse404 = utils.objectToClass(
              httpRes?.data,
              shared.InlineResponse404
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Set notifications
   *
   * @remarks
   * <p>Set notifications for a given source account</p>
   * <p>If the balance falls below the amount set in the request an email notification will be sent to the email address registered in the payor profile</p>
   *
   */
  setNotificationsRequestV3(
    req: operations.SetNotificationsRequestV3Request,
    config?: AxiosRequestConfig
  ): Promise<operations.SetNotificationsRequestV3Response> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.SetNotificationsRequestV3Request(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v3/sourceAccounts/{sourceAccountId}/notifications",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "setNotificationsRequest2",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.SetNotificationsRequestV3Response =
        new operations.SetNotificationsRequestV3Response({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
        case httpRes?.status == 400:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.inlineResponse400 = utils.objectToClass(
              httpRes?.data,
              shared.InlineResponse400
            );
          }
          break;
        case httpRes?.status == 401:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.inlineResponse401 = utils.objectToClass(
              httpRes?.data,
              shared.InlineResponse401
            );
          }
          break;
        case httpRes?.status == 403:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.inlineResponse403 = utils.objectToClass(
              httpRes?.data,
              shared.InlineResponse403
            );
          }
          break;
        case httpRes?.status == 404:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.inlineResponse404 = utils.objectToClass(
              httpRes?.data,
              shared.InlineResponse404
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Transfer Funds between source accounts
   *
   * @remarks
   * Transfer funds between source accounts for a Payor. The 'from' source account is identified in the URL, and is the account which will be debited. The 'to' (destination) source account is in the body, and is the account which will be credited. Both source accounts must belong to the same Payor. There must be sufficient balance in the 'from' source account, otherwise the transfer attempt will fail.
   */
  transferFundsV2(
    req: operations.TransferFundsV2Request,
    config?: AxiosRequestConfig
  ): Promise<operations.TransferFundsV2Response> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.TransferFundsV2Request(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v2/sourceAccounts/{sourceAccountId}/transfers",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "transferRequestV2",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.TransferFundsV2Response =
        new operations.TransferFundsV2Response({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
        case httpRes?.status == 400:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.inlineResponse400 = utils.objectToClass(
              httpRes?.data,
              shared.InlineResponse400
            );
          }
          break;
        case httpRes?.status == 401:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.inlineResponse401 = utils.objectToClass(
              httpRes?.data,
              shared.InlineResponse401
            );
          }
          break;
        case httpRes?.status == 403:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.inlineResponse403 = utils.objectToClass(
              httpRes?.data,
              shared.InlineResponse403
            );
          }
          break;
        case httpRes?.status == 404:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.inlineResponse404 = utils.objectToClass(
              httpRes?.data,
              shared.InlineResponse404
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Transfer Funds between source accounts
   *
   * @remarks
   * Transfer funds between source accounts for a Payor. The 'from' source account is identified in the URL, and is the account which will be debited. The 'to' (destination) source account is in the body, and is the account which will be credited. Both source accounts must belong to the same Payor. There must be sufficient balance in the 'from' source account, otherwise the transfer attempt will fail.
   */
  transferFundsV3(
    req: operations.TransferFundsV3Request,
    config?: AxiosRequestConfig
  ): Promise<operations.TransferFundsV3Response> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.TransferFundsV3Request(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v3/sourceAccounts/{sourceAccountId}/transfers",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "transferRequestV3",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.TransferFundsV3Response =
        new operations.TransferFundsV3Response({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
        case httpRes?.status == 400:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.inlineResponse400 = utils.objectToClass(
              httpRes?.data,
              shared.InlineResponse400
            );
          }
          break;
        case httpRes?.status == 401:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.inlineResponse401 = utils.objectToClass(
              httpRes?.data,
              shared.InlineResponse401
            );
          }
          break;
        case httpRes?.status == 403:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.inlineResponse403 = utils.objectToClass(
              httpRes?.data,
              shared.InlineResponse403
            );
          }
          break;
        case httpRes?.status == 404:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.inlineResponse404 = utils.objectToClass(
              httpRes?.data,
              shared.InlineResponse404
            );
          }
          break;
      }

      return res;
    });
  }
}
