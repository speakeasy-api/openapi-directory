"""Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT."""

import requests as requests_http
from . import utils
from sdk.models import operations, shared
from typing import Any, Optional

class Accounts:
    _client: requests_http.Session
    _security_client: requests_http.Session
    _server_url: str
    _language: str
    _sdk_version: str
    _gen_version: str

    def __init__(self, client: requests_http.Session, security_client: requests_http.Session, server_url: str, language: str, sdk_version: str, gen_version: str) -> None:
        self._client = client
        self._security_client = security_client
        self._server_url = server_url
        self._language = language
        self._sdk_version = sdk_version
        self._gen_version = gen_version
        
    def manufacturers_accounts_languages_product_certifications_delete(self, request: operations.ManufacturersAccountsLanguagesProductCertificationsDeleteRequest, security: operations.ManufacturersAccountsLanguagesProductCertificationsDeleteSecurity) -> operations.ManufacturersAccountsLanguagesProductCertificationsDeleteResponse:
        r"""Deletes a product certification by its name. This method can only be called by certification bodies."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.ManufacturersAccountsLanguagesProductCertificationsDeleteRequest, base_url, '/v1/{name}', request)
        
        query_params = utils.get_query_params(operations.ManufacturersAccountsLanguagesProductCertificationsDeleteRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('DELETE', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ManufacturersAccountsLanguagesProductCertificationsDeleteResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[dict[str, Any]])
                res.empty = out

        return res

    def manufacturers_accounts_languages_product_certifications_get(self, request: operations.ManufacturersAccountsLanguagesProductCertificationsGetRequest, security: operations.ManufacturersAccountsLanguagesProductCertificationsGetSecurity) -> operations.ManufacturersAccountsLanguagesProductCertificationsGetResponse:
        r"""Gets a product certification by its name. This method can only be called by certification bodies."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.ManufacturersAccountsLanguagesProductCertificationsGetRequest, base_url, '/v1/{name}', request)
        
        query_params = utils.get_query_params(operations.ManufacturersAccountsLanguagesProductCertificationsGetRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ManufacturersAccountsLanguagesProductCertificationsGetResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ProductCertification])
                res.product_certification = out

        return res

    def manufacturers_accounts_languages_product_certifications_list(self, request: operations.ManufacturersAccountsLanguagesProductCertificationsListRequest, security: operations.ManufacturersAccountsLanguagesProductCertificationsListSecurity) -> operations.ManufacturersAccountsLanguagesProductCertificationsListResponse:
        r"""Lists product certifications from a specified certification body. This method can only be called by certification bodies."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.ManufacturersAccountsLanguagesProductCertificationsListRequest, base_url, '/v1/{parent}/productCertifications', request)
        
        query_params = utils.get_query_params(operations.ManufacturersAccountsLanguagesProductCertificationsListRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ManufacturersAccountsLanguagesProductCertificationsListResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ListProductCertificationsResponse])
                res.list_product_certifications_response = out

        return res

    def manufacturers_accounts_languages_product_certifications_patch(self, request: operations.ManufacturersAccountsLanguagesProductCertificationsPatchRequest, security: operations.ManufacturersAccountsLanguagesProductCertificationsPatchSecurity) -> operations.ManufacturersAccountsLanguagesProductCertificationsPatchResponse:
        r"""Updates (or creates if allow_missing = true) a product certification which links certifications with products. This method can only be called by certification bodies."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.ManufacturersAccountsLanguagesProductCertificationsPatchRequest, base_url, '/v1/{name}', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "product_certification_input", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        query_params = utils.get_query_params(operations.ManufacturersAccountsLanguagesProductCertificationsPatchRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('PATCH', url, params=query_params, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ManufacturersAccountsLanguagesProductCertificationsPatchResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ProductCertification])
                res.product_certification = out

        return res

    def manufacturers_accounts_products_delete(self, request: operations.ManufacturersAccountsProductsDeleteRequest, security: operations.ManufacturersAccountsProductsDeleteSecurity) -> operations.ManufacturersAccountsProductsDeleteResponse:
        r"""Deletes the product from a Manufacturer Center account."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.ManufacturersAccountsProductsDeleteRequest, base_url, '/v1/{parent}/products/{name}', request)
        
        query_params = utils.get_query_params(operations.ManufacturersAccountsProductsDeleteRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('DELETE', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ManufacturersAccountsProductsDeleteResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[dict[str, Any]])
                res.empty = out

        return res

    def manufacturers_accounts_products_get(self, request: operations.ManufacturersAccountsProductsGetRequest, security: operations.ManufacturersAccountsProductsGetSecurity) -> operations.ManufacturersAccountsProductsGetResponse:
        r"""Gets the product from a Manufacturer Center account, including product issues. A recently updated product takes around 15 minutes to process. Changes are only visible after it has been processed. While some issues may be available once the product has been processed, other issues may take days to appear."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.ManufacturersAccountsProductsGetRequest, base_url, '/v1/{parent}/products/{name}', request)
        
        query_params = utils.get_query_params(operations.ManufacturersAccountsProductsGetRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ManufacturersAccountsProductsGetResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Product])
                res.product = out

        return res

    def manufacturers_accounts_products_list(self, request: operations.ManufacturersAccountsProductsListRequest, security: operations.ManufacturersAccountsProductsListSecurity) -> operations.ManufacturersAccountsProductsListResponse:
        r"""Lists all the products in a Manufacturer Center account."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.ManufacturersAccountsProductsListRequest, base_url, '/v1/{parent}/products', request)
        
        query_params = utils.get_query_params(operations.ManufacturersAccountsProductsListRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ManufacturersAccountsProductsListResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ListProductsResponse])
                res.list_products_response = out

        return res

    def manufacturers_accounts_products_update(self, request: operations.ManufacturersAccountsProductsUpdateRequest, security: operations.ManufacturersAccountsProductsUpdateSecurity) -> operations.ManufacturersAccountsProductsUpdateResponse:
        r"""Inserts or updates the attributes of the product in a Manufacturer Center account. Creates a product with the provided attributes. If the product already exists, then all attributes are replaced with the new ones. The checks at upload time are minimal. All required attributes need to be present for a product to be valid. Issues may show up later after the API has accepted a new upload for a product and it is possible to overwrite an existing valid product with an invalid product. To detect this, you should retrieve the product and check it for issues once the new version is available. Uploaded attributes first need to be processed before they can be retrieved. Until then, new products will be unavailable, and retrieval of previously uploaded products will return the original state of the product."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.ManufacturersAccountsProductsUpdateRequest, base_url, '/v1/{parent}/products/{name}', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "attributes", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        query_params = utils.get_query_params(operations.ManufacturersAccountsProductsUpdateRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('PUT', url, params=query_params, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ManufacturersAccountsProductsUpdateResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[dict[str, Any]])
                res.empty = out

        return res

    