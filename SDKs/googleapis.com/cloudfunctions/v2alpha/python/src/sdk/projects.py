"""Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT."""

import requests as requests_http
from . import utils
from sdk.models import operations, shared
from typing import Optional

class Projects:
    _client: requests_http.Session
    _security_client: requests_http.Session
    _server_url: str
    _language: str
    _sdk_version: str
    _gen_version: str

    def __init__(self, client: requests_http.Session, security_client: requests_http.Session, server_url: str, language: str, sdk_version: str, gen_version: str) -> None:
        self._client = client
        self._security_client = security_client
        self._server_url = server_url
        self._language = language
        self._sdk_version = sdk_version
        self._gen_version = gen_version
        
    def cloudfunctions_projects_locations_functions_create(self, request: operations.CloudfunctionsProjectsLocationsFunctionsCreateRequest, security: operations.CloudfunctionsProjectsLocationsFunctionsCreateSecurity) -> operations.CloudfunctionsProjectsLocationsFunctionsCreateResponse:
        r"""Creates a new function. If a function with the given name already exists in the specified project, the long running operation will return `ALREADY_EXISTS` error."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.CloudfunctionsProjectsLocationsFunctionsCreateRequest, base_url, '/v2alpha/{parent}/functions', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "function_input", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        query_params = utils.get_query_params(operations.CloudfunctionsProjectsLocationsFunctionsCreateRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, params=query_params, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.CloudfunctionsProjectsLocationsFunctionsCreateResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Operation])
                res.operation = out

        return res

    def cloudfunctions_projects_locations_functions_delete(self, request: operations.CloudfunctionsProjectsLocationsFunctionsDeleteRequest, security: operations.CloudfunctionsProjectsLocationsFunctionsDeleteSecurity) -> operations.CloudfunctionsProjectsLocationsFunctionsDeleteResponse:
        r"""Deletes a function with the given name from the specified project. If the given function is used by some trigger, the trigger will be updated to remove this function."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.CloudfunctionsProjectsLocationsFunctionsDeleteRequest, base_url, '/v2alpha/{name}', request)
        
        query_params = utils.get_query_params(operations.CloudfunctionsProjectsLocationsFunctionsDeleteRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('DELETE', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.CloudfunctionsProjectsLocationsFunctionsDeleteResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Operation])
                res.operation = out

        return res

    def cloudfunctions_projects_locations_functions_generate_download_url(self, request: operations.CloudfunctionsProjectsLocationsFunctionsGenerateDownloadURLRequest, security: operations.CloudfunctionsProjectsLocationsFunctionsGenerateDownloadURLSecurity) -> operations.CloudfunctionsProjectsLocationsFunctionsGenerateDownloadURLResponse:
        r"""Returns a signed URL for downloading deployed function source code. The URL is only valid for a limited period and should be used within 30 minutes of generation. For more information about the signed URL usage see: https://cloud.google.com/storage/docs/access-control/signed-urls"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.CloudfunctionsProjectsLocationsFunctionsGenerateDownloadURLRequest, base_url, '/v2alpha/{name}:generateDownloadUrl', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        query_params = utils.get_query_params(operations.CloudfunctionsProjectsLocationsFunctionsGenerateDownloadURLRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, params=query_params, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.CloudfunctionsProjectsLocationsFunctionsGenerateDownloadURLResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.GenerateDownloadURLResponse])
                res.generate_download_url_response = out

        return res

    def cloudfunctions_projects_locations_functions_generate_upload_url(self, request: operations.CloudfunctionsProjectsLocationsFunctionsGenerateUploadURLRequest, security: operations.CloudfunctionsProjectsLocationsFunctionsGenerateUploadURLSecurity) -> operations.CloudfunctionsProjectsLocationsFunctionsGenerateUploadURLResponse:
        r"""Returns a signed URL for uploading a function source code. For more information about the signed URL usage see: https://cloud.google.com/storage/docs/access-control/signed-urls. Once the function source code upload is complete, the used signed URL should be provided in CreateFunction or UpdateFunction request as a reference to the function source code. When uploading source code to the generated signed URL, please follow these restrictions: * Source file type should be a zip file. * No credentials should be attached - the signed URLs provide access to the target bucket using internal service identity; if credentials were attached, the identity from the credentials would be used, but that identity does not have permissions to upload files to the URL. When making a HTTP PUT request, these two headers need to be specified: * `content-type: application/zip` And this header SHOULD NOT be specified: * `Authorization: Bearer YOUR_TOKEN`"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.CloudfunctionsProjectsLocationsFunctionsGenerateUploadURLRequest, base_url, '/v2alpha/{parent}/functions:generateUploadUrl', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "generate_upload_url_request", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        query_params = utils.get_query_params(operations.CloudfunctionsProjectsLocationsFunctionsGenerateUploadURLRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, params=query_params, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.CloudfunctionsProjectsLocationsFunctionsGenerateUploadURLResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.GenerateUploadURLResponse])
                res.generate_upload_url_response = out

        return res

    def cloudfunctions_projects_locations_functions_get_iam_policy(self, request: operations.CloudfunctionsProjectsLocationsFunctionsGetIamPolicyRequest, security: operations.CloudfunctionsProjectsLocationsFunctionsGetIamPolicySecurity) -> operations.CloudfunctionsProjectsLocationsFunctionsGetIamPolicyResponse:
        r"""Gets the access control policy for a resource. Returns an empty policy if the resource exists and does not have a policy set."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.CloudfunctionsProjectsLocationsFunctionsGetIamPolicyRequest, base_url, '/v2alpha/{resource}:getIamPolicy', request)
        
        query_params = utils.get_query_params(operations.CloudfunctionsProjectsLocationsFunctionsGetIamPolicyRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.CloudfunctionsProjectsLocationsFunctionsGetIamPolicyResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Policy])
                res.policy = out

        return res

    def cloudfunctions_projects_locations_functions_list(self, request: operations.CloudfunctionsProjectsLocationsFunctionsListRequest, security: operations.CloudfunctionsProjectsLocationsFunctionsListSecurity) -> operations.CloudfunctionsProjectsLocationsFunctionsListResponse:
        r"""Returns a list of functions that belong to the requested project."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.CloudfunctionsProjectsLocationsFunctionsListRequest, base_url, '/v2alpha/{parent}/functions', request)
        
        query_params = utils.get_query_params(operations.CloudfunctionsProjectsLocationsFunctionsListRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.CloudfunctionsProjectsLocationsFunctionsListResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ListFunctionsResponse])
                res.list_functions_response = out

        return res

    def cloudfunctions_projects_locations_functions_patch(self, request: operations.CloudfunctionsProjectsLocationsFunctionsPatchRequest, security: operations.CloudfunctionsProjectsLocationsFunctionsPatchSecurity) -> operations.CloudfunctionsProjectsLocationsFunctionsPatchResponse:
        r"""Updates existing function."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.CloudfunctionsProjectsLocationsFunctionsPatchRequest, base_url, '/v2alpha/{name}', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "function_input", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        query_params = utils.get_query_params(operations.CloudfunctionsProjectsLocationsFunctionsPatchRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('PATCH', url, params=query_params, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.CloudfunctionsProjectsLocationsFunctionsPatchResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Operation])
                res.operation = out

        return res

    def cloudfunctions_projects_locations_functions_set_iam_policy(self, request: operations.CloudfunctionsProjectsLocationsFunctionsSetIamPolicyRequest, security: operations.CloudfunctionsProjectsLocationsFunctionsSetIamPolicySecurity) -> operations.CloudfunctionsProjectsLocationsFunctionsSetIamPolicyResponse:
        r"""Sets the access control policy on the specified resource. Replaces any existing policy. Can return `NOT_FOUND`, `INVALID_ARGUMENT`, and `PERMISSION_DENIED` errors."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.CloudfunctionsProjectsLocationsFunctionsSetIamPolicyRequest, base_url, '/v2alpha/{resource}:setIamPolicy', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "set_iam_policy_request", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        query_params = utils.get_query_params(operations.CloudfunctionsProjectsLocationsFunctionsSetIamPolicyRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, params=query_params, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.CloudfunctionsProjectsLocationsFunctionsSetIamPolicyResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Policy])
                res.policy = out

        return res

    def cloudfunctions_projects_locations_functions_test_iam_permissions(self, request: operations.CloudfunctionsProjectsLocationsFunctionsTestIamPermissionsRequest, security: operations.CloudfunctionsProjectsLocationsFunctionsTestIamPermissionsSecurity) -> operations.CloudfunctionsProjectsLocationsFunctionsTestIamPermissionsResponse:
        r"""Returns permissions that a caller has on the specified resource. If the resource does not exist, this will return an empty set of permissions, not a `NOT_FOUND` error. Note: This operation is designed to be used for building permission-aware UIs and command-line tools, not for authorization checking. This operation may \\"fail open\\" without warning."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.CloudfunctionsProjectsLocationsFunctionsTestIamPermissionsRequest, base_url, '/v2alpha/{resource}:testIamPermissions', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "test_iam_permissions_request", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        query_params = utils.get_query_params(operations.CloudfunctionsProjectsLocationsFunctionsTestIamPermissionsRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, params=query_params, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.CloudfunctionsProjectsLocationsFunctionsTestIamPermissionsResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.TestIamPermissionsResponse])
                res.test_iam_permissions_response = out

        return res

    def cloudfunctions_projects_locations_list(self, request: operations.CloudfunctionsProjectsLocationsListRequest, security: operations.CloudfunctionsProjectsLocationsListSecurity) -> operations.CloudfunctionsProjectsLocationsListResponse:
        r"""Lists information about the supported locations for this service."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.CloudfunctionsProjectsLocationsListRequest, base_url, '/v2alpha/{name}/locations', request)
        
        query_params = utils.get_query_params(operations.CloudfunctionsProjectsLocationsListRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.CloudfunctionsProjectsLocationsListResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ListLocationsResponse])
                res.list_locations_response = out

        return res

    def cloudfunctions_projects_locations_operations_get(self, request: operations.CloudfunctionsProjectsLocationsOperationsGetRequest, security: operations.CloudfunctionsProjectsLocationsOperationsGetSecurity) -> operations.CloudfunctionsProjectsLocationsOperationsGetResponse:
        r"""Gets the latest state of a long-running operation. Clients can use this method to poll the operation result at intervals as recommended by the API service."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.CloudfunctionsProjectsLocationsOperationsGetRequest, base_url, '/v2alpha/{name}', request)
        
        query_params = utils.get_query_params(operations.CloudfunctionsProjectsLocationsOperationsGetRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.CloudfunctionsProjectsLocationsOperationsGetResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Operation])
                res.operation = out

        return res

    def cloudfunctions_projects_locations_operations_list(self, request: operations.CloudfunctionsProjectsLocationsOperationsListRequest, security: operations.CloudfunctionsProjectsLocationsOperationsListSecurity) -> operations.CloudfunctionsProjectsLocationsOperationsListResponse:
        r"""Lists operations that match the specified filter in the request. If the server doesn't support this method, it returns `UNIMPLEMENTED`."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.CloudfunctionsProjectsLocationsOperationsListRequest, base_url, '/v2alpha/{name}/operations', request)
        
        query_params = utils.get_query_params(operations.CloudfunctionsProjectsLocationsOperationsListRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.CloudfunctionsProjectsLocationsOperationsListResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ListOperationsResponse])
                res.list_operations_response = out

        return res

    def cloudfunctions_projects_locations_runtimes_list(self, request: operations.CloudfunctionsProjectsLocationsRuntimesListRequest, security: operations.CloudfunctionsProjectsLocationsRuntimesListSecurity) -> operations.CloudfunctionsProjectsLocationsRuntimesListResponse:
        r"""Returns a list of runtimes that are supported for the requested project."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.CloudfunctionsProjectsLocationsRuntimesListRequest, base_url, '/v2alpha/{parent}/runtimes', request)
        
        query_params = utils.get_query_params(operations.CloudfunctionsProjectsLocationsRuntimesListRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.CloudfunctionsProjectsLocationsRuntimesListResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ListRuntimesResponse])
                res.list_runtimes_response = out

        return res

    