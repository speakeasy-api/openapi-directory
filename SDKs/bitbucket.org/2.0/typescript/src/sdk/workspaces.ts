/*
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

import * as utils from "../internal/utils";
import * as operations from "./models/operations";
import * as shared from "./models/shared";
import { AxiosInstance, AxiosRequestConfig, AxiosResponse } from "axios";

/**
 * A workspace is where you create repositories, collaborate on
 *
 * @remarks
 * your code, and organize different streams of work in your Bitbucket
 * Cloud account. Workspaces replace the use of teams and users in API
 * calls.
 *
 */
export class Workspaces {
  _defaultClient: AxiosInstance;
  _securityClient: AxiosInstance;
  _serverURL: string;
  _language: string;
  _sdkVersion: string;
  _genVersion: string;

  constructor(
    defaultClient: AxiosInstance,
    securityClient: AxiosInstance,
    serverURL: string,
    language: string,
    sdkVersion: string,
    genVersion: string
  ) {
    this._defaultClient = defaultClient;
    this._securityClient = securityClient;
    this._serverURL = serverURL;
    this._language = language;
    this._sdkVersion = sdkVersion;
    this._genVersion = genVersion;
  }

  /**
   * Delete a webhook for a workspace
   *
   * @remarks
   * Deletes the specified webhook subscription from the given workspace.
   */
  deleteWorkspacesWorkspaceHooksUid(
    req: operations.DeleteWorkspacesWorkspaceHooksUidRequest,
    security: operations.DeleteWorkspacesWorkspaceHooksUidSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.DeleteWorkspacesWorkspaceHooksUidResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DeleteWorkspacesWorkspaceHooksUidRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/workspaces/{workspace}/hooks/{uid}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.DeleteWorkspacesWorkspaceHooksUidSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DeleteWorkspacesWorkspaceHooksUidResponse =
        new operations.DeleteWorkspacesWorkspaceHooksUidResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
        case [403, 404].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.error = utils.objectToClass(httpRes?.data);
          }
          break;
      }

      return res;
    });
  }

  /**
   * List workspaces for the current user
   *
   * @remarks
   * Returns an object for each workspace the caller is a member of, and
   * their effective role - the highest level of privilege the caller has.
   * If a user is a member of multiple groups with distinct roles, only the
   * highest level is returned.
   *
   * Permissions can be:
   *
   * * `owner`
   * * `collaborator`
   * * `member`
   *
   * **The `collaborator` role is being removed from the Bitbucket Cloud API. For more information,
   * see the [deprecation announcement](/cloud/bitbucket/deprecation-notice-collaborator-role/).**
   *
   * Example:
   *
   * ```
   * $ curl https://api.bitbucket.org/2.0/user/permissions/workspaces
   *
   * {
   *   "pagelen": 10,
   *   "page": 1,
   *   "size": 1,
   *   "values": [
   *     {
   *       "type": "workspace_membership",
   *       "permission": "owner",
   *       "last_accessed": "2019-03-07T12:35:02.900024+00:00",
   *       "added_on": "2018-10-11T17:42:02.961424+00:00",
   *       "user": {
   *         "type": "user",
   *         "uuid": "{470c176d-3574-44ea-bb41-89e8638bcca4}",
   *         "nickname": "evzijst",
   *         "display_name": "Erik van Zijst",
   *       },
   *       "workspace": {
   *         "type": "workspace",
   *         "uuid": "{a15fb181-db1f-48f7-b41f-e1eff06929d6}",
   *         "slug": "bbworkspace1",
   *         "name": "Atlassian Bitbucket",
   *       }
   *     }
   *   ]
   * }
   * ```
   *
   * Results may be further [filtered or sorted](/cloud/bitbucket/rest/intro/#filtering) by
   * workspace or permission by adding the following query string parameters:
   *
   * * `q=workspace.slug="bbworkspace1"` or `q=permission="owner"`
   * * `sort=workspace.slug`
   *
   * Note that the query parameter values need to be URL escaped so that `=`
   * would become `%3D`.
   */
  getUserPermissionsWorkspaces(
    req: operations.GetUserPermissionsWorkspacesRequest,
    security: operations.GetUserPermissionsWorkspacesSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.GetUserPermissionsWorkspacesResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetUserPermissionsWorkspacesRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/user/permissions/workspaces";
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.GetUserPermissionsWorkspacesSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetUserPermissionsWorkspacesResponse =
        new operations.GetUserPermissionsWorkspacesResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.paginatedWorkspaceMemberships = utils.objectToClass(
              httpRes?.data,
              shared.PaginatedWorkspaceMemberships
            );
          }
          break;
        case httpRes?.status == 401:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.error = utils.objectToClass(httpRes?.data);
          }
          break;
      }

      return res;
    });
  }

  /**
   * List workspaces for user
   *
   * @remarks
   * Returns a list of workspaces accessible by the authenticated user.
   *
   * Example:
   *
   * ```
   * $ curl https://api.bitbucket.org/2.0/workspaces
   *
   * {
   *   "pagelen": 10,
   *   "page": 1,
   *   "size": 1,
   *   "values": [
   *     {
   *         "uuid": "{a15fb181-db1f-48f7-b41f-e1eff06929d6}",
   *         "links": {
   *             "owners": {
   *                 "href": "https://api.bitbucket.org/2.0/workspaces/bbworkspace1/members?q=permission%3D%22owner%22"
   *             },
   *             "self": {
   *                 "href": "https://api.bitbucket.org/2.0/workspaces/bbworkspace1"
   *             },
   *             "repositories": {
   *                 "href": "https://api.bitbucket.org/2.0/repositories/bbworkspace1"
   *             },
   *             "snippets": {
   *                 "href": "https://api.bitbucket.org/2.0/snippets/bbworkspace1"
   *             },
   *             "html": {
   *                 "href": "https://bitbucket.org/bbworkspace1/"
   *             },
   *             "avatar": {
   *                 "href": "https://bitbucket.org/workspaces/bbworkspace1/avatar/?ts=1543465801"
   *             },
   *             "members": {
   *                 "href": "https://api.bitbucket.org/2.0/workspaces/bbworkspace1/members"
   *             },
   *             "projects": {
   *                 "href": "https://api.bitbucket.org/2.0/workspaces/bbworkspace1/projects"
   *             }
   *         },
   *         "created_on": "2018-11-14T19:15:05.058566+00:00",
   *         "type": "workspace",
   *         "slug": "bbworkspace1",
   *         "is_private": true,
   *         "name": "Atlassian Bitbucket"
   *     }
   *   ]
   * }
   * ```
   *
   * Results may be further [filtered or sorted](/cloud/bitbucket/rest/intro/#filtering) by
   * workspace or permission by adding the following query string parameters:
   *
   * * `q=slug="bbworkspace1"` or `q=is_private=true`
   * * `sort=created_on`
   *
   * Note that the query parameter values need to be URL escaped so that `=`
   * would become `%3D`.
   *
   * **The `collaborator` role is being removed from the Bitbucket Cloud API. For more information,
   * see the [deprecation announcement](/cloud/bitbucket/deprecation-notice-collaborator-role/).**
   */
  getWorkspaces(
    req: operations.GetWorkspacesRequest,
    security: operations.GetWorkspacesSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.GetWorkspacesResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetWorkspacesRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/workspaces";
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.GetWorkspacesSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetWorkspacesResponse =
        new operations.GetWorkspacesResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.paginatedWorkspaces = utils.objectToClass(
              httpRes?.data,
              shared.PaginatedWorkspaces
            );
          }
          break;
        case httpRes?.status == 401:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.error = utils.objectToClass(httpRes?.data);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Get a workspace
   *
   * @remarks
   * Returns the requested workspace.
   */
  getWorkspacesWorkspace(
    req: operations.GetWorkspacesWorkspaceRequest,
    security: operations.GetWorkspacesWorkspaceSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.GetWorkspacesWorkspaceResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetWorkspacesWorkspaceRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/workspaces/{workspace}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.GetWorkspacesWorkspaceSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetWorkspacesWorkspaceResponse =
        new operations.GetWorkspacesWorkspaceResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.workspace = utils.objectToClass(httpRes?.data);
          }
          break;
        case httpRes?.status == 404:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.error = utils.objectToClass(httpRes?.data);
          }
          break;
      }

      return res;
    });
  }

  /**
   * List webhooks for a workspace
   *
   * @remarks
   * Returns a paginated list of webhooks installed on this workspace.
   */
  getWorkspacesWorkspaceHooks(
    req: operations.GetWorkspacesWorkspaceHooksRequest,
    security: operations.GetWorkspacesWorkspaceHooksSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.GetWorkspacesWorkspaceHooksResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetWorkspacesWorkspaceHooksRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/workspaces/{workspace}/hooks",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.GetWorkspacesWorkspaceHooksSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetWorkspacesWorkspaceHooksResponse =
        new operations.GetWorkspacesWorkspaceHooksResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.paginatedWebhookSubscriptions = utils.objectToClass(
              httpRes?.data,
              shared.PaginatedWebhookSubscriptions
            );
          }
          break;
        case [403, 404].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.error = utils.objectToClass(httpRes?.data);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Get a webhook for a workspace
   *
   * @remarks
   * Returns the webhook with the specified id installed on the given
   * workspace.
   */
  getWorkspacesWorkspaceHooksUid(
    req: operations.GetWorkspacesWorkspaceHooksUidRequest,
    security: operations.GetWorkspacesWorkspaceHooksUidSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.GetWorkspacesWorkspaceHooksUidResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetWorkspacesWorkspaceHooksUidRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/workspaces/{workspace}/hooks/{uid}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.GetWorkspacesWorkspaceHooksUidSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetWorkspacesWorkspaceHooksUidResponse =
        new operations.GetWorkspacesWorkspaceHooksUidResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.webhookSubscription = utils.objectToClass(httpRes?.data);
          }
          break;
        case httpRes?.status == 404:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.error = utils.objectToClass(httpRes?.data);
          }
          break;
      }

      return res;
    });
  }

  /**
   * List users in a workspace
   *
   * @remarks
   * Returns all members of the requested workspace.
   */
  getWorkspacesWorkspaceMembers(
    req: operations.GetWorkspacesWorkspaceMembersRequest,
    security: operations.GetWorkspacesWorkspaceMembersSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.GetWorkspacesWorkspaceMembersResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetWorkspacesWorkspaceMembersRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/workspaces/{workspace}/members",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.GetWorkspacesWorkspaceMembersSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetWorkspacesWorkspaceMembersResponse =
        new operations.GetWorkspacesWorkspaceMembersResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.paginatedWorkspaceMemberships = utils.objectToClass(
              httpRes?.data,
              shared.PaginatedWorkspaceMemberships
            );
          }
          break;
        case httpRes?.status == 401:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.error = utils.objectToClass(httpRes?.data);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Get user membership for a workspace
   *
   * @remarks
   * Returns the workspace membership, which includes
   * a `User` object for the member and a `Workspace` object
   * for the requested workspace.
   */
  getWorkspacesWorkspaceMembersMember(
    req: operations.GetWorkspacesWorkspaceMembersMemberRequest,
    security: operations.GetWorkspacesWorkspaceMembersMemberSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.GetWorkspacesWorkspaceMembersMemberResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetWorkspacesWorkspaceMembersMemberRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/workspaces/{workspace}/members/{member}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.GetWorkspacesWorkspaceMembersMemberSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetWorkspacesWorkspaceMembersMemberResponse =
        new operations.GetWorkspacesWorkspaceMembersMemberResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.workspaceMembership = utils.objectToClass(httpRes?.data);
          }
          break;
        case [401, 404].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.error = utils.objectToClass(httpRes?.data);
          }
          break;
      }

      return res;
    });
  }

  /**
   * List user permissions in a workspace
   *
   * @remarks
   * Returns the list of members in a workspace
   * and their permission levels.
   * Permission can be:
   * * `owner`
   * * `collaborator`
   * * `member`
   *
   * **The `collaborator` role is being removed from the Bitbucket Cloud API. For more information,
   * see the [deprecation announcement](/cloud/bitbucket/deprecation-notice-collaborator-role/).**
   *
   * Example:
   *
   * ```
   * $ curl -X https://api.bitbucket.org/2.0/workspaces/bbworkspace1/permissions
   *
   * {
   *     "pagelen": 10,
   *     "values": [
   *         {
   *             "permission": "owner",
   *             "type": "workspace_membership",
   *             "user": {
   *                 "type": "user",
   *                 "uuid": "{470c176d-3574-44ea-bb41-89e8638bcca4}",
   *                 "display_name": "Erik van Zijst",
   *             },
   *             "workspace": {
   *                 "type": "workspace",
   *                 "uuid": "{a15fb181-db1f-48f7-b41f-e1eff06929d6}",
   *                 "slug": "bbworkspace1",
   *                 "name": "Atlassian Bitbucket",
   *             }
   *         },
   *         {
   *             "permission": "member",
   *             "type": "workspace_membership",
   *             "user": {
   *                 "type": "user",
   *                 "nickname": "seanaty",
   *                 "display_name": "Sean Conaty",
   *                 "uuid": "{504c3b62-8120-4f0c-a7bc-87800b9d6f70}"
   *             },
   *             "workspace": {
   *                 "type": "workspace",
   *                 "uuid": "{a15fb181-db1f-48f7-b41f-e1eff06929d6}",
   *                 "slug": "bbworkspace1",
   *                 "name": "Atlassian Bitbucket",
   *             }
   *         }
   *     ],
   *     "page": 1,
   *     "size": 2
   * }
   * ```
   *
   * Results may be further [filtered](/cloud/bitbucket/rest/intro/#filtering) by
   * permission by adding the following query string parameters:
   *
   * * `q=permission="owner"`
   */
  getWorkspacesWorkspacePermissions(
    req: operations.GetWorkspacesWorkspacePermissionsRequest,
    security: operations.GetWorkspacesWorkspacePermissionsSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.GetWorkspacesWorkspacePermissionsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetWorkspacesWorkspacePermissionsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/workspaces/{workspace}/permissions",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.GetWorkspacesWorkspacePermissionsSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetWorkspacesWorkspacePermissionsResponse =
        new operations.GetWorkspacesWorkspacePermissionsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.paginatedWorkspaceMemberships = utils.objectToClass(
              httpRes?.data,
              shared.PaginatedWorkspaceMemberships
            );
          }
          break;
        case httpRes?.status == 401:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.error = utils.objectToClass(httpRes?.data);
          }
          break;
      }

      return res;
    });
  }

  /**
   * List all repository permissions for a workspace
   *
   * @remarks
   * Returns an object for each repository permission for all of a
   * workspace's repositories.
   *
   * Permissions returned are effective permissions: the highest level of
   * permission the user has. This does not distinguish between direct and
   * indirect (group) privileges.
   *
   * Only users with admin permission for the team may access this resource.
   *
   * Permissions can be:
   *
   * * `admin`
   * * `write`
   * * `read`
   *
   * Example:
   *
   * ```
   * $ curl https://api.bitbucket.org/2.0/workspaces/atlassian_tutorial/permissions/repositories
   *
   * {
   *   "pagelen": 10,
   *   "values": [
   *     {
   *       "type": "repository_permission",
   *       "user": {
   *         "type": "user",
   *         "display_name": "Erik van Zijst",
   *         "uuid": "{d301aafa-d676-4ee0-88be-962be7417567}"
   *       },
   *       "repository": {
   *         "type": "repository",
   *         "name": "geordi",
   *         "full_name": "atlassian_tutorial/geordi",
   *         "uuid": "{85d08b4e-571d-44e9-a507-fa476535aa98}"
   *       },
   *       "permission": "admin"
   *     },
   *     {
   *       "type": "repository_permission",
   *       "user": {
   *         "type": "user",
   *         "display_name": "Sean Conaty",
   *         "uuid": "{504c3b62-8120-4f0c-a7bc-87800b9d6f70}"
   *       },
   *       "repository": {
   *         "type": "repository",
   *         "name": "geordi",
   *         "full_name": "atlassian_tutorial/geordi",
   *         "uuid": "{85d08b4e-571d-44e9-a507-fa476535aa98}"
   *       },
   *       "permission": "write"
   *     },
   *     {
   *       "type": "repository_permission",
   *       "user": {
   *         "type": "user",
   *         "display_name": "Jeff Zeng",
   *         "uuid": "{47f92a9a-c3a3-4d0b-bc4e-782a969c5c72}"
   *       },
   *       "repository": {
   *         "type": "repository",
   *         "name": "whee",
   *         "full_name": "atlassian_tutorial/whee",
   *         "uuid": "{30ba25e9-51ff-4555-8dd0-fc7ee2fa0895}"
   *       },
   *       "permission": "admin"
   *     }
   *   ],
   *   "page": 1,
   *   "size": 3
   * }
   * ```
   *
   * Results may be further [filtered or sorted](/cloud/bitbucket/rest/intro/#filtering)
   * by repository, user, or permission by adding the following query string
   * parameters:
   *
   * * `q=repository.name="geordi"` or `q=permission>"read"`
   * * `sort=user.display_name`
   *
   * Note that the query parameter values need to be URL escaped so that `=`
   * would become `%3D`.
   */
  getWorkspacesWorkspacePermissionsRepositories(
    req: operations.GetWorkspacesWorkspacePermissionsRepositoriesRequest,
    security: operations.GetWorkspacesWorkspacePermissionsRepositoriesSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.GetWorkspacesWorkspacePermissionsRepositoriesResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetWorkspacesWorkspacePermissionsRepositoriesRequest(
        req
      );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/workspaces/{workspace}/permissions/repositories",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.GetWorkspacesWorkspacePermissionsRepositoriesSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetWorkspacesWorkspacePermissionsRepositoriesResponse =
        new operations.GetWorkspacesWorkspacePermissionsRepositoriesResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.paginatedRepositoryPermissions = utils.objectToClass(
              httpRes?.data,
              shared.PaginatedRepositoryPermissions
            );
          }
          break;
        case httpRes?.status == 403:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.error = utils.objectToClass(httpRes?.data);
          }
          break;
      }

      return res;
    });
  }

  /**
   * List a repository permissions for a workspace
   *
   * @remarks
   * Returns an object for the repository permission of each user in the
   * requested repository.
   *
   * Permissions returned are effective permissions: the highest level of
   * permission the user has. This does not distinguish between direct and
   * indirect (group) privileges.
   *
   * Only users with admin permission for the repository may access this resource.
   *
   * Permissions can be:
   *
   * * `admin`
   * * `write`
   * * `read`
   *
   * Example:
   *
   * ```
   * $ curl https://api.bitbucket.org/2.0/workspaces/atlassian_tutorial/permissions/repositories/geordi
   *
   * {
   *   "pagelen": 10,
   *   "values": [
   *     {
   *       "type": "repository_permission",
   *       "user": {
   *         "type": "user",
   *         "display_name": "Erik van Zijst",
   *         "uuid": "{d301aafa-d676-4ee0-88be-962be7417567}"
   *       },
   *       "repository": {
   *         "type": "repository",
   *         "name": "geordi",
   *         "full_name": "atlassian_tutorial/geordi",
   *         "uuid": "{85d08b4e-571d-44e9-a507-fa476535aa98}"
   *       },
   *       "permission": "admin"
   *     },
   *     {
   *       "type": "repository_permission",
   *       "user": {
   *         "type": "user",
   *         "display_name": "Sean Conaty",
   *         "uuid": "{504c3b62-8120-4f0c-a7bc-87800b9d6f70}"
   *       },
   *       "repository": {
   *         "type": "repository",
   *         "name": "geordi",
   *         "full_name": "atlassian_tutorial/geordi",
   *         "uuid": "{85d08b4e-571d-44e9-a507-fa476535aa98}"
   *       },
   *       "permission": "write"
   *     }
   *   ],
   *   "page": 1,
   *   "size": 2
   * }
   * ```
   *
   * Results may be further [filtered or sorted](/cloud/bitbucket/rest/intro/#filtering)
   * by user, or permission by adding the following query string parameters:
   *
   * * `q=permission>"read"`
   * * `sort=user.display_name`
   *
   * Note that the query parameter values need to be URL escaped so that `=`
   * would become `%3D`.
   */
  getWorkspacesWorkspacePermissionsRepositoriesRepoSlug(
    req: operations.GetWorkspacesWorkspacePermissionsRepositoriesRepoSlugRequest,
    security: operations.GetWorkspacesWorkspacePermissionsRepositoriesRepoSlugSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.GetWorkspacesWorkspacePermissionsRepositoriesRepoSlugResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.GetWorkspacesWorkspacePermissionsRepositoriesRepoSlugRequest(
          req
        );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/workspaces/{workspace}/permissions/repositories/{repo_slug}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.GetWorkspacesWorkspacePermissionsRepositoriesRepoSlugSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetWorkspacesWorkspacePermissionsRepositoriesRepoSlugResponse =
        new operations.GetWorkspacesWorkspacePermissionsRepositoriesRepoSlugResponse(
          {
            statusCode: httpRes.status,
            contentType: contentType,
            rawResponse: httpRes,
          }
        );
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.paginatedRepositoryPermissions = utils.objectToClass(
              httpRes?.data,
              shared.PaginatedRepositoryPermissions
            );
          }
          break;
        case httpRes?.status == 403:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.error = utils.objectToClass(httpRes?.data);
          }
          break;
      }

      return res;
    });
  }

  /**
   * List projects in a workspace
   *
   * @remarks
   * Returns the list of projects in this workspace.
   */
  getWorkspacesWorkspaceProjects(
    req: operations.GetWorkspacesWorkspaceProjectsRequest,
    security: operations.GetWorkspacesWorkspaceProjectsSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.GetWorkspacesWorkspaceProjectsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetWorkspacesWorkspaceProjectsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/workspaces/{workspace}/projects",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.GetWorkspacesWorkspaceProjectsSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetWorkspacesWorkspaceProjectsResponse =
        new operations.GetWorkspacesWorkspaceProjectsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.paginatedProjects = utils.objectToClass(
              httpRes?.data,
              shared.PaginatedProjects
            );
          }
          break;
        case httpRes?.status == 404:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.error = utils.objectToClass(httpRes?.data);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Get a project for a workspace
   *
   * @remarks
   * Returns the requested project.
   */
  getWorkspacesWorkspaceProjectsProjectKey(
    req: operations.GetWorkspacesWorkspaceProjectsProjectKeyRequest,
    security: operations.GetWorkspacesWorkspaceProjectsProjectKeySecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.GetWorkspacesWorkspaceProjectsProjectKeyResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetWorkspacesWorkspaceProjectsProjectKeyRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/workspaces/{workspace}/projects/{project_key}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.GetWorkspacesWorkspaceProjectsProjectKeySecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetWorkspacesWorkspaceProjectsProjectKeyResponse =
        new operations.GetWorkspacesWorkspaceProjectsProjectKeyResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.project = utils.objectToClass(httpRes?.data);
          }
          break;
        case [401, 403, 404].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.error = utils.objectToClass(httpRes?.data);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Create a webhook for a workspace
   *
   * @remarks
   * Creates a new webhook on the specified workspace.
   *
   * Workspace webhooks are fired for events from all repositories contained
   * by that workspace.
   *
   * Example:
   *
   * ```
   * $ curl -X POST -u credentials -H 'Content-Type: application/json'
   *   https://api.bitbucket.org/2.0/workspaces/my-workspace/hooks
   *   -d '
   *     {
   *       "description": "Webhook Description",
   *       "url": "https://example.com/",
   *       "active": true,
   *       "events": [
   *         "repo:push",
   *         "issue:created",
   *         "issue:updated"
   *       ]
   *     }'
   * ```
   *
   * This call requires the webhook scope, as well as any scope
   * that applies to the events that the webhook subscribes to. In the
   * example above that means: `webhook`, `repository` and `issue`.
   *
   * The `url` must properly resolve and cannot be an internal, non-routed address.
   *
   * Only workspace owners can install webhooks on workspaces.
   */
  postWorkspacesWorkspaceHooks(
    req: operations.PostWorkspacesWorkspaceHooksRequest,
    security: operations.PostWorkspacesWorkspaceHooksSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.PostWorkspacesWorkspaceHooksResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PostWorkspacesWorkspaceHooksRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/workspaces/{workspace}/hooks",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.PostWorkspacesWorkspaceHooksSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "post",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PostWorkspacesWorkspaceHooksResponse =
        new operations.PostWorkspacesWorkspaceHooksResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
          headers: utils.getHeadersFromResponse(httpRes.headers),
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.webhookSubscription = utils.objectToClass(httpRes?.data);
          }
          break;
        case [403, 404].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.error = utils.objectToClass(httpRes?.data);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Update a webhook for a workspace
   *
   * @remarks
   * Updates the specified webhook subscription.
   *
   * The following properties can be mutated:
   *
   * * `description`
   * * `url`
   * * `active`
   * * `events`
   */
  putWorkspacesWorkspaceHooksUid(
    req: operations.PutWorkspacesWorkspaceHooksUidRequest,
    security: operations.PutWorkspacesWorkspaceHooksUidSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.PutWorkspacesWorkspaceHooksUidResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PutWorkspacesWorkspaceHooksUidRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/workspaces/{workspace}/hooks/{uid}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.PutWorkspacesWorkspaceHooksUidSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "put",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PutWorkspacesWorkspaceHooksUidResponse =
        new operations.PutWorkspacesWorkspaceHooksUidResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.webhookSubscription = utils.objectToClass(httpRes?.data);
          }
          break;
        case [403, 404].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.error = utils.objectToClass(httpRes?.data);
          }
          break;
      }

      return res;
    });
  }
}
