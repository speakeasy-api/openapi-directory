// Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.

package sdk

import (
	"context"
	"fmt"
	"net/http"
	"openapi/pkg/models/operations"
	"openapi/pkg/models/shared"
	"openapi/pkg/utils"
	"strings"
)

// airspace - #### Information is available for the following types of airspace:
// * **Controlled Airspace (CAS):** Class B, C, D, E2 airspace names, boundaries, altitude information, and LAANC availability
// * **Special Use Airspace (SUA):** Names, boundaries, and altitude information for the following types of Special Use Airspace:
//   - Alert Areas (AA)
//   - Military Operations Areas (MOA)
//   - National Security Areas (NSA)
//   - Prohibited Areas (PA)
//   - Restricted Areas (RA)
//   - Warning Areas (WA)
//
// * **Miscellaneous Activity Areas (MAA):** Names and boundary information for the following types of Miscellaneous Activity Areas:
//   - Aerobatic Practice Areas (AEROBATIC PRACTICE)
//   - Glider Operations Areas (GLIDER)
//   - Hang Glider Operations Areas (HANG GLIDER)
//   - Parachute Jump Areas (PARACHUTE JUMP AREA)
//   - Space Launch Activity Areas (SPACE LAUNCH ACTIVITY)
//
// * **Military Training Routes (MTR):** Names, route geometry, usage times, and corridor width information for both VFR and IFR Military Training Routes
type airspace struct {
	defaultClient  HTTPClient
	securityClient HTTPClient
	serverURL      string
	language       string
	sdkVersion     string
	genVersion     string
}

func newAirspace(defaultClient, securityClient HTTPClient, serverURL, language, sdkVersion, genVersion string) *airspace {
	return &airspace{
		defaultClient:  defaultClient,
		securityClient: securityClient,
		serverURL:      serverURL,
		language:       language,
		sdkVersion:     sdkVersion,
		genVersion:     genVersion,
	}
}

// AspByDistanceUsV1AirspaceDistanceQueryPost - Retrieve all requested types of airspace located within given distance of location.
// Retrieve selected types of airspace existing within given distance from a point. Request body parameters are:
// * latitude:  WGS84 latitude coordinate of your selected point, in decimal degrees
// * longitude:  WGS84 longitude coordinate of your selected point, in decimal degrees
// * distance:  distance in meters (max allowed value is 25000)
// * asptypes:  list of one or more airspace types you wish to retrieve. Allowed values are 'CAS', 'SUA', 'MAA', and 'MTR'.
//
// Successful requests return a list of GeoJSON FeatureCollections, one for each Airspace type indicated in the request. Within each feature collection, there will be a separate Feature for each Airspace instance found. All Features will include a property indicating the *airspace_type*. Additional properties for each *airspace_type* are as follows:
// * CAS (Controlled Airspace)
//   - *name*
//   - *cas_class*: B, C, D, or E2
//   - *floor*: integer value in ft MSL
//   - *ceiling*: integer value in ft MSL
//   - *lannc*: true/false indicating whether or not authorization for this airspace may be obtained via LAANC
//
// * SUA (Special Use Airspace)
//   - *name*
//   - *sua_type*: AA = Alert Area, MOA = Military Operations Area, NSA = National Security Area, PA = Prohibited Area, RA = Restricted Area, WA = Warning Area
//   - *floor*: lower limit of the airspace
//   - *floor_uom*: unit of measure used for the numeric floor value: FT (feet) or FL (flight level)
//   - *floor_ref*: reference level used for the numeric floor value: AGL, MSL, or STD (standard atmosphere, used for flight level values)
//   - *ceiling*: upper limit of the airspace
//   - *ceiling_uom*: unit of measure used for the numeric floor value: FT (feet) or FL (flight level)
//   - *ceiling_ref*: reference level used for the numeric ceiling value: AGL, MSL, or STD (standard atmosphere, used for flight level values)
//
// * MAA (Miscellaneous Activity Area)
//   - *name*
//   - *maa_type*: one of the following - ULTRALIGHT, PARACHUTE JUMP AREA, AEROBATIC PRACTICE, GLIDER, HANG GLIDER, SPACE LAUNCH ACTIVITY
//   - *use_times*: textual description of days/times when activity in the area should be expected
//
// * MTR (Military Training Route)
//   - *name*
//   - *use_times*: textual description of days/times when MTR is active/hot
//   - *terrain_following*: boolean value indicating whether terrain following activity occurs on the route
//   - *max_extent_nm*: maximum distance that aircraft can deviate from route centerline
func (s *airspace) AspByDistanceUsV1AirspaceDistanceQueryPost(ctx context.Context, request operations.AspByDistanceUsV1AirspaceDistanceQueryPostRequest) (*operations.AspByDistanceUsV1AirspaceDistanceQueryPostResponse, error) {
	baseURL := s.serverURL
	url := strings.TrimSuffix(baseURL, "/") + "/us/v1/airspace/distance-query"

	bodyReader, reqContentType, err := utils.SerializeRequestBody(ctx, request, "AirspaceByDistance", "json")
	if err != nil {
		return nil, fmt.Errorf("error serializing request body: %w", err)
	}
	if bodyReader == nil {
		return nil, fmt.Errorf("request body is required")
	}

	req, err := http.NewRequestWithContext(ctx, "POST", url, bodyReader)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	req.Header.Set("Content-Type", reqContentType)

	utils.PopulateHeaders(ctx, req, request)

	client := s.defaultClient

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.AspByDistanceUsV1AirspaceDistanceQueryPostResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *shared.AirspaceDistanceResponse
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.AirspaceDistanceResponse = out
		}
	case httpRes.StatusCode == 422:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *shared.HTTPValidationError
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.HTTPValidationError = out
		}
	}

	return res, nil
}

// AspByPolyUsV1AirspacePolygonQueryPost - Retrieve all requested types of airspace located within given GeoJSON Polygon.
// Retrieve selected types of airspace located within given area. Request body parameters are:
// * poly:  [GeoJSON Polygon](https://www.rfc-editor.org/rfc/rfc7946.html#appendix-A) defining the area. Max allowed area is 1000 km^2.
// * asptypes:  list of one or more airspace types you wish to retrieve. Allowed values are 'CAS', 'SUA', 'MAA', and 'MTR'.
//
// Successful requests return a list of GeoJSON FeatureCollections, one for each Airspace type indicated in the request. Within each feature collection, there will be a separate Feature for each Airspace instance found. All Features will include a property indicating the *airspace_type*. Additional properties for each *airspace_type* are as follows:
// * CAS (Controlled Airspace)
//   - *name*
//   - *cas_class*: B, C, D, or E2
//   - *floor*: integer value in ft MSL
//   - *ceiling*: integer value in ft MSL
//   - *lannc*: true/false indicating whether or not authorization for this airspace may be obtained via LAANC
//
// * SUA (Special Use Airspace)
//   - *name*
//   - *sua_type*: AA = Alert Area, MOA = Military Operations Area, NSA = National Security Area, PA = Prohibited Area, RA = Restricted Area, WA = Warning Area
//   - *floor*: lower limit of the airspace
//   - *floor_uom*: unit of measure used for the numeric floor value: FT (feet) or FL (flight level)
//   - *floor_ref*: reference level used for the numeric floor value: AGL, MSL, or STD (standard atmosphere, used for flight level values)
//   - *ceiling*: upper limit of the airspace
//   - *ceiling_uom*: unit of measure used for the numeric floor value: FT (feet) or FL (flight level)
//   - *ceiling_ref*: reference level used for the numeric ceiling value: AGL, MSL, or STD (standard atmosphere, used for flight level values)
//
// * MAA (Miscellaneous Activity Area)
//   - *name*
//   - *maa_type*: one of the following - ULTRALIGHT, PARACHUTE JUMP AREA, AEROBATIC PRACTICE, GLIDER, HANG GLIDER, SPACE LAUNCH ACTIVITY
//   - *use_times*: textual description of days/times when activity in the area should be expected
//
// * MTR (Military Training Route)
//   - *name*
//   - *use_times*: textual description of days/times when MTR is active/hot
//   - *terrain_following*: boolean value indicating whether terrain following activity occurs on the route
//   - *max_extent_nm*: maximum distance that aircraft can deviate from route centerline
func (s *airspace) AspByPolyUsV1AirspacePolygonQueryPost(ctx context.Context, request operations.AspByPolyUsV1AirspacePolygonQueryPostRequest) (*operations.AspByPolyUsV1AirspacePolygonQueryPostResponse, error) {
	baseURL := s.serverURL
	url := strings.TrimSuffix(baseURL, "/") + "/us/v1/airspace/polygon-query"

	bodyReader, reqContentType, err := utils.SerializeRequestBody(ctx, request, "AirspaceByPolygon", "json")
	if err != nil {
		return nil, fmt.Errorf("error serializing request body: %w", err)
	}
	if bodyReader == nil {
		return nil, fmt.Errorf("request body is required")
	}

	req, err := http.NewRequestWithContext(ctx, "POST", url, bodyReader)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	req.Header.Set("Content-Type", reqContentType)

	utils.PopulateHeaders(ctx, req, request)

	client := s.defaultClient

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.AspByPolyUsV1AirspacePolygonQueryPostResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *shared.AirspacePolyResponse
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.AirspacePolyResponse = out
		}
	case httpRes.StatusCode == 422:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *shared.HTTPValidationError
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.HTTPValidationError = out
		}
	}

	return res, nil
}

// AspByRouteUsV1AirspaceRouteQueryPost - Retrieve all requested types of airspace traversed by route.
// Retrieve selected types of airspace traversed by route. Request body parameters are:
// * route:  [GeoJSON Linestring](https://www.rfc-editor.org/rfc/rfc7946.html#appendix-A) defining the route. Max allowed length is 50 km.
// * asptypes:  list of one or more airspace types you wish to retrieve. Allowed values are 'CAS', 'SUA', 'MAA', and 'MTR'.
//
// Successful requests return a list of GeoJSON FeatureCollections, one for each Airspace type indicated in the request. Within each feature collection, there will be a separate Feature for each Airspace instance found. All Features will include a property indicating the *airspace_type*. Additional properties for each *airspace_type* are as follows:
// * CAS (Controlled Airspace)
//   - *name*
//   - *cas_class*: B, C, D, or E2
//   - *floor*: integer value in ft MSL
//   - *ceiling*: integer value in ft MSL
//   - *lannc*: true/false indicating whether or not authorization for this airspace may be obtained via LAANC
//
// * SUA (Special Use Airspace)
//   - *name*
//   - *sua_type*: AA = Alert Area, MOA = Military Operations Area, NSA = National Security Area, PA = Prohibited Area, RA = Restricted Area, WA = Warning Area
//   - *floor*: lower limit of the airspace
//   - *floor_uom*: unit of measure used for the numeric floor value: FT (feet) or FL (flight level)
//   - *floor_ref*: reference level used for the numeric floor value: AGL, MSL, or STD (standard atmosphere, used for flight level values)
//   - *ceiling*: upper limit of the airspace
//   - *ceiling_uom*: unit of measure used for the numeric floor value: FT (feet) or FL (flight level)
//   - *ceiling_ref*: reference level used for the numeric ceiling value: AGL, MSL, or STD (standard atmosphere, used for flight level values)
//
// * MAA (Miscellaneous Activity Area)
//   - *name*
//   - *maa_type*: one of the following - ULTRALIGHT, PARACHUTE JUMP AREA, AEROBATIC PRACTICE, GLIDER, HANG GLIDER, SPACE LAUNCH ACTIVITY
//   - *use_times*: textual description of days/times when activity in the area should be expected
//
// * MTR (Military Training Route)
//   - *name*
//   - *use_times*: textual description of days/times when MTR is active/hot
//   - *terrain_following*: boolean value indicating whether terrain following activity occurs on the route
//   - *max_extent_nm*: maximum distance that aircraft can deviate from route centerline
func (s *airspace) AspByRouteUsV1AirspaceRouteQueryPost(ctx context.Context, request operations.AspByRouteUsV1AirspaceRouteQueryPostRequest) (*operations.AspByRouteUsV1AirspaceRouteQueryPostResponse, error) {
	baseURL := s.serverURL
	url := strings.TrimSuffix(baseURL, "/") + "/us/v1/airspace/route-query"

	bodyReader, reqContentType, err := utils.SerializeRequestBody(ctx, request, "AirspaceByRoute", "json")
	if err != nil {
		return nil, fmt.Errorf("error serializing request body: %w", err)
	}
	if bodyReader == nil {
		return nil, fmt.Errorf("request body is required")
	}

	req, err := http.NewRequestWithContext(ctx, "POST", url, bodyReader)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	req.Header.Set("Content-Type", reqContentType)

	utils.PopulateHeaders(ctx, req, request)

	client := s.defaultClient

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.AspByRouteUsV1AirspaceRouteQueryPostResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *shared.AirspaceRouteResponse
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.AirspaceRouteResponse = out
		}
	case httpRes.StatusCode == 422:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *shared.HTTPValidationError
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.HTTPValidationError = out
		}
	}

	return res, nil
}
