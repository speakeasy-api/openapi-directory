// Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.

package shared

import (
	"encoding/json"
	"fmt"
)

// PartOfSpeechAspectEnum - The grammatical aspect.
type PartOfSpeechAspectEnum string

const (
	PartOfSpeechAspectEnumAspectUnknown PartOfSpeechAspectEnum = "ASPECT_UNKNOWN"
	PartOfSpeechAspectEnumPerfective    PartOfSpeechAspectEnum = "PERFECTIVE"
	PartOfSpeechAspectEnumImperfective  PartOfSpeechAspectEnum = "IMPERFECTIVE"
	PartOfSpeechAspectEnumProgressive   PartOfSpeechAspectEnum = "PROGRESSIVE"
)

func (e *PartOfSpeechAspectEnum) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return err
	}
	switch s {
	case "ASPECT_UNKNOWN":
		fallthrough
	case "PERFECTIVE":
		fallthrough
	case "IMPERFECTIVE":
		fallthrough
	case "PROGRESSIVE":
		*e = PartOfSpeechAspectEnum(s)
		return nil
	default:
		return fmt.Errorf("invalid value for PartOfSpeechAspectEnum: %s", s)
	}
}

// PartOfSpeechCaseEnum - The grammatical case.
type PartOfSpeechCaseEnum string

const (
	PartOfSpeechCaseEnumCaseUnknown   PartOfSpeechCaseEnum = "CASE_UNKNOWN"
	PartOfSpeechCaseEnumAccusative    PartOfSpeechCaseEnum = "ACCUSATIVE"
	PartOfSpeechCaseEnumAdverbial     PartOfSpeechCaseEnum = "ADVERBIAL"
	PartOfSpeechCaseEnumComplementive PartOfSpeechCaseEnum = "COMPLEMENTIVE"
	PartOfSpeechCaseEnumDative        PartOfSpeechCaseEnum = "DATIVE"
	PartOfSpeechCaseEnumGenitive      PartOfSpeechCaseEnum = "GENITIVE"
	PartOfSpeechCaseEnumInstrumental  PartOfSpeechCaseEnum = "INSTRUMENTAL"
	PartOfSpeechCaseEnumLocative      PartOfSpeechCaseEnum = "LOCATIVE"
	PartOfSpeechCaseEnumNominative    PartOfSpeechCaseEnum = "NOMINATIVE"
	PartOfSpeechCaseEnumOblique       PartOfSpeechCaseEnum = "OBLIQUE"
	PartOfSpeechCaseEnumPartitive     PartOfSpeechCaseEnum = "PARTITIVE"
	PartOfSpeechCaseEnumPrepositional PartOfSpeechCaseEnum = "PREPOSITIONAL"
	PartOfSpeechCaseEnumReflexiveCase PartOfSpeechCaseEnum = "REFLEXIVE_CASE"
	PartOfSpeechCaseEnumRelativeCase  PartOfSpeechCaseEnum = "RELATIVE_CASE"
	PartOfSpeechCaseEnumVocative      PartOfSpeechCaseEnum = "VOCATIVE"
)

func (e *PartOfSpeechCaseEnum) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return err
	}
	switch s {
	case "CASE_UNKNOWN":
		fallthrough
	case "ACCUSATIVE":
		fallthrough
	case "ADVERBIAL":
		fallthrough
	case "COMPLEMENTIVE":
		fallthrough
	case "DATIVE":
		fallthrough
	case "GENITIVE":
		fallthrough
	case "INSTRUMENTAL":
		fallthrough
	case "LOCATIVE":
		fallthrough
	case "NOMINATIVE":
		fallthrough
	case "OBLIQUE":
		fallthrough
	case "PARTITIVE":
		fallthrough
	case "PREPOSITIONAL":
		fallthrough
	case "REFLEXIVE_CASE":
		fallthrough
	case "RELATIVE_CASE":
		fallthrough
	case "VOCATIVE":
		*e = PartOfSpeechCaseEnum(s)
		return nil
	default:
		return fmt.Errorf("invalid value for PartOfSpeechCaseEnum: %s", s)
	}
}

// PartOfSpeechFormEnum - The grammatical form.
type PartOfSpeechFormEnum string

const (
	PartOfSpeechFormEnumFormUnknown    PartOfSpeechFormEnum = "FORM_UNKNOWN"
	PartOfSpeechFormEnumAdnomial       PartOfSpeechFormEnum = "ADNOMIAL"
	PartOfSpeechFormEnumAuxiliary      PartOfSpeechFormEnum = "AUXILIARY"
	PartOfSpeechFormEnumComplementizer PartOfSpeechFormEnum = "COMPLEMENTIZER"
	PartOfSpeechFormEnumFinalEnding    PartOfSpeechFormEnum = "FINAL_ENDING"
	PartOfSpeechFormEnumGerund         PartOfSpeechFormEnum = "GERUND"
	PartOfSpeechFormEnumRealis         PartOfSpeechFormEnum = "REALIS"
	PartOfSpeechFormEnumIrrealis       PartOfSpeechFormEnum = "IRREALIS"
	PartOfSpeechFormEnumShort          PartOfSpeechFormEnum = "SHORT"
	PartOfSpeechFormEnumLong           PartOfSpeechFormEnum = "LONG"
	PartOfSpeechFormEnumOrder          PartOfSpeechFormEnum = "ORDER"
	PartOfSpeechFormEnumSpecific       PartOfSpeechFormEnum = "SPECIFIC"
)

func (e *PartOfSpeechFormEnum) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return err
	}
	switch s {
	case "FORM_UNKNOWN":
		fallthrough
	case "ADNOMIAL":
		fallthrough
	case "AUXILIARY":
		fallthrough
	case "COMPLEMENTIZER":
		fallthrough
	case "FINAL_ENDING":
		fallthrough
	case "GERUND":
		fallthrough
	case "REALIS":
		fallthrough
	case "IRREALIS":
		fallthrough
	case "SHORT":
		fallthrough
	case "LONG":
		fallthrough
	case "ORDER":
		fallthrough
	case "SPECIFIC":
		*e = PartOfSpeechFormEnum(s)
		return nil
	default:
		return fmt.Errorf("invalid value for PartOfSpeechFormEnum: %s", s)
	}
}

// PartOfSpeechGenderEnum - The grammatical gender.
type PartOfSpeechGenderEnum string

const (
	PartOfSpeechGenderEnumGenderUnknown PartOfSpeechGenderEnum = "GENDER_UNKNOWN"
	PartOfSpeechGenderEnumFeminine      PartOfSpeechGenderEnum = "FEMININE"
	PartOfSpeechGenderEnumMasculine     PartOfSpeechGenderEnum = "MASCULINE"
	PartOfSpeechGenderEnumNeuter        PartOfSpeechGenderEnum = "NEUTER"
)

func (e *PartOfSpeechGenderEnum) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return err
	}
	switch s {
	case "GENDER_UNKNOWN":
		fallthrough
	case "FEMININE":
		fallthrough
	case "MASCULINE":
		fallthrough
	case "NEUTER":
		*e = PartOfSpeechGenderEnum(s)
		return nil
	default:
		return fmt.Errorf("invalid value for PartOfSpeechGenderEnum: %s", s)
	}
}

// PartOfSpeechMoodEnum - The grammatical mood.
type PartOfSpeechMoodEnum string

const (
	PartOfSpeechMoodEnumMoodUnknown     PartOfSpeechMoodEnum = "MOOD_UNKNOWN"
	PartOfSpeechMoodEnumConditionalMood PartOfSpeechMoodEnum = "CONDITIONAL_MOOD"
	PartOfSpeechMoodEnumImperative      PartOfSpeechMoodEnum = "IMPERATIVE"
	PartOfSpeechMoodEnumIndicative      PartOfSpeechMoodEnum = "INDICATIVE"
	PartOfSpeechMoodEnumInterrogative   PartOfSpeechMoodEnum = "INTERROGATIVE"
	PartOfSpeechMoodEnumJussive         PartOfSpeechMoodEnum = "JUSSIVE"
	PartOfSpeechMoodEnumSubjunctive     PartOfSpeechMoodEnum = "SUBJUNCTIVE"
)

func (e *PartOfSpeechMoodEnum) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return err
	}
	switch s {
	case "MOOD_UNKNOWN":
		fallthrough
	case "CONDITIONAL_MOOD":
		fallthrough
	case "IMPERATIVE":
		fallthrough
	case "INDICATIVE":
		fallthrough
	case "INTERROGATIVE":
		fallthrough
	case "JUSSIVE":
		fallthrough
	case "SUBJUNCTIVE":
		*e = PartOfSpeechMoodEnum(s)
		return nil
	default:
		return fmt.Errorf("invalid value for PartOfSpeechMoodEnum: %s", s)
	}
}

// PartOfSpeechNumberEnum - The grammatical number.
type PartOfSpeechNumberEnum string

const (
	PartOfSpeechNumberEnumNumberUnknown PartOfSpeechNumberEnum = "NUMBER_UNKNOWN"
	PartOfSpeechNumberEnumSingular      PartOfSpeechNumberEnum = "SINGULAR"
	PartOfSpeechNumberEnumPlural        PartOfSpeechNumberEnum = "PLURAL"
	PartOfSpeechNumberEnumDual          PartOfSpeechNumberEnum = "DUAL"
)

func (e *PartOfSpeechNumberEnum) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return err
	}
	switch s {
	case "NUMBER_UNKNOWN":
		fallthrough
	case "SINGULAR":
		fallthrough
	case "PLURAL":
		fallthrough
	case "DUAL":
		*e = PartOfSpeechNumberEnum(s)
		return nil
	default:
		return fmt.Errorf("invalid value for PartOfSpeechNumberEnum: %s", s)
	}
}

// PartOfSpeechPersonEnum - The grammatical person.
type PartOfSpeechPersonEnum string

const (
	PartOfSpeechPersonEnumPersonUnknown   PartOfSpeechPersonEnum = "PERSON_UNKNOWN"
	PartOfSpeechPersonEnumFirst           PartOfSpeechPersonEnum = "FIRST"
	PartOfSpeechPersonEnumSecond          PartOfSpeechPersonEnum = "SECOND"
	PartOfSpeechPersonEnumThird           PartOfSpeechPersonEnum = "THIRD"
	PartOfSpeechPersonEnumReflexivePerson PartOfSpeechPersonEnum = "REFLEXIVE_PERSON"
)

func (e *PartOfSpeechPersonEnum) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return err
	}
	switch s {
	case "PERSON_UNKNOWN":
		fallthrough
	case "FIRST":
		fallthrough
	case "SECOND":
		fallthrough
	case "THIRD":
		fallthrough
	case "REFLEXIVE_PERSON":
		*e = PartOfSpeechPersonEnum(s)
		return nil
	default:
		return fmt.Errorf("invalid value for PartOfSpeechPersonEnum: %s", s)
	}
}

// PartOfSpeechProperEnum - The grammatical properness.
type PartOfSpeechProperEnum string

const (
	PartOfSpeechProperEnumProperUnknown PartOfSpeechProperEnum = "PROPER_UNKNOWN"
	PartOfSpeechProperEnumProper        PartOfSpeechProperEnum = "PROPER"
	PartOfSpeechProperEnumNotProper     PartOfSpeechProperEnum = "NOT_PROPER"
)

func (e *PartOfSpeechProperEnum) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return err
	}
	switch s {
	case "PROPER_UNKNOWN":
		fallthrough
	case "PROPER":
		fallthrough
	case "NOT_PROPER":
		*e = PartOfSpeechProperEnum(s)
		return nil
	default:
		return fmt.Errorf("invalid value for PartOfSpeechProperEnum: %s", s)
	}
}

// PartOfSpeechReciprocityEnum - The grammatical reciprocity.
type PartOfSpeechReciprocityEnum string

const (
	PartOfSpeechReciprocityEnumReciprocityUnknown PartOfSpeechReciprocityEnum = "RECIPROCITY_UNKNOWN"
	PartOfSpeechReciprocityEnumReciprocal         PartOfSpeechReciprocityEnum = "RECIPROCAL"
	PartOfSpeechReciprocityEnumNonReciprocal      PartOfSpeechReciprocityEnum = "NON_RECIPROCAL"
)

func (e *PartOfSpeechReciprocityEnum) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return err
	}
	switch s {
	case "RECIPROCITY_UNKNOWN":
		fallthrough
	case "RECIPROCAL":
		fallthrough
	case "NON_RECIPROCAL":
		*e = PartOfSpeechReciprocityEnum(s)
		return nil
	default:
		return fmt.Errorf("invalid value for PartOfSpeechReciprocityEnum: %s", s)
	}
}

// PartOfSpeechTagEnum - The part of speech tag.
type PartOfSpeechTagEnum string

const (
	PartOfSpeechTagEnumUnknown PartOfSpeechTagEnum = "UNKNOWN"
	PartOfSpeechTagEnumAdj     PartOfSpeechTagEnum = "ADJ"
	PartOfSpeechTagEnumAdp     PartOfSpeechTagEnum = "ADP"
	PartOfSpeechTagEnumAdv     PartOfSpeechTagEnum = "ADV"
	PartOfSpeechTagEnumConj    PartOfSpeechTagEnum = "CONJ"
	PartOfSpeechTagEnumDet     PartOfSpeechTagEnum = "DET"
	PartOfSpeechTagEnumNoun    PartOfSpeechTagEnum = "NOUN"
	PartOfSpeechTagEnumNum     PartOfSpeechTagEnum = "NUM"
	PartOfSpeechTagEnumPron    PartOfSpeechTagEnum = "PRON"
	PartOfSpeechTagEnumPrt     PartOfSpeechTagEnum = "PRT"
	PartOfSpeechTagEnumPunct   PartOfSpeechTagEnum = "PUNCT"
	PartOfSpeechTagEnumVerb    PartOfSpeechTagEnum = "VERB"
	PartOfSpeechTagEnumX       PartOfSpeechTagEnum = "X"
	PartOfSpeechTagEnumAffix   PartOfSpeechTagEnum = "AFFIX"
)

func (e *PartOfSpeechTagEnum) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return err
	}
	switch s {
	case "UNKNOWN":
		fallthrough
	case "ADJ":
		fallthrough
	case "ADP":
		fallthrough
	case "ADV":
		fallthrough
	case "CONJ":
		fallthrough
	case "DET":
		fallthrough
	case "NOUN":
		fallthrough
	case "NUM":
		fallthrough
	case "PRON":
		fallthrough
	case "PRT":
		fallthrough
	case "PUNCT":
		fallthrough
	case "VERB":
		fallthrough
	case "X":
		fallthrough
	case "AFFIX":
		*e = PartOfSpeechTagEnum(s)
		return nil
	default:
		return fmt.Errorf("invalid value for PartOfSpeechTagEnum: %s", s)
	}
}

// PartOfSpeechTenseEnum - The grammatical tense.
type PartOfSpeechTenseEnum string

const (
	PartOfSpeechTenseEnumTenseUnknown     PartOfSpeechTenseEnum = "TENSE_UNKNOWN"
	PartOfSpeechTenseEnumConditionalTense PartOfSpeechTenseEnum = "CONDITIONAL_TENSE"
	PartOfSpeechTenseEnumFuture           PartOfSpeechTenseEnum = "FUTURE"
	PartOfSpeechTenseEnumPast             PartOfSpeechTenseEnum = "PAST"
	PartOfSpeechTenseEnumPresent          PartOfSpeechTenseEnum = "PRESENT"
	PartOfSpeechTenseEnumImperfect        PartOfSpeechTenseEnum = "IMPERFECT"
	PartOfSpeechTenseEnumPluperfect       PartOfSpeechTenseEnum = "PLUPERFECT"
)

func (e *PartOfSpeechTenseEnum) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return err
	}
	switch s {
	case "TENSE_UNKNOWN":
		fallthrough
	case "CONDITIONAL_TENSE":
		fallthrough
	case "FUTURE":
		fallthrough
	case "PAST":
		fallthrough
	case "PRESENT":
		fallthrough
	case "IMPERFECT":
		fallthrough
	case "PLUPERFECT":
		*e = PartOfSpeechTenseEnum(s)
		return nil
	default:
		return fmt.Errorf("invalid value for PartOfSpeechTenseEnum: %s", s)
	}
}

// PartOfSpeechVoiceEnum - The grammatical voice.
type PartOfSpeechVoiceEnum string

const (
	PartOfSpeechVoiceEnumVoiceUnknown PartOfSpeechVoiceEnum = "VOICE_UNKNOWN"
	PartOfSpeechVoiceEnumActive       PartOfSpeechVoiceEnum = "ACTIVE"
	PartOfSpeechVoiceEnumCausative    PartOfSpeechVoiceEnum = "CAUSATIVE"
	PartOfSpeechVoiceEnumPassive      PartOfSpeechVoiceEnum = "PASSIVE"
)

func (e *PartOfSpeechVoiceEnum) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return err
	}
	switch s {
	case "VOICE_UNKNOWN":
		fallthrough
	case "ACTIVE":
		fallthrough
	case "CAUSATIVE":
		fallthrough
	case "PASSIVE":
		*e = PartOfSpeechVoiceEnum(s)
		return nil
	default:
		return fmt.Errorf("invalid value for PartOfSpeechVoiceEnum: %s", s)
	}
}

// PartOfSpeech - Represents part of speech information for a token. Parts of speech are as defined in http://www.lrec-conf.org/proceedings/lrec2012/pdf/274_Paper.pdf
type PartOfSpeech struct {
	// The grammatical aspect.
	Aspect *PartOfSpeechAspectEnum `json:"aspect,omitempty"`
	// The grammatical case.
	Case *PartOfSpeechCaseEnum `json:"case,omitempty"`
	// The grammatical form.
	Form *PartOfSpeechFormEnum `json:"form,omitempty"`
	// The grammatical gender.
	Gender *PartOfSpeechGenderEnum `json:"gender,omitempty"`
	// The grammatical mood.
	Mood *PartOfSpeechMoodEnum `json:"mood,omitempty"`
	// The grammatical number.
	Number *PartOfSpeechNumberEnum `json:"number,omitempty"`
	// The grammatical person.
	Person *PartOfSpeechPersonEnum `json:"person,omitempty"`
	// The grammatical properness.
	Proper *PartOfSpeechProperEnum `json:"proper,omitempty"`
	// The grammatical reciprocity.
	Reciprocity *PartOfSpeechReciprocityEnum `json:"reciprocity,omitempty"`
	// The part of speech tag.
	Tag *PartOfSpeechTagEnum `json:"tag,omitempty"`
	// The grammatical tense.
	Tense *PartOfSpeechTenseEnum `json:"tense,omitempty"`
	// The grammatical voice.
	Voice *PartOfSpeechVoiceEnum `json:"voice,omitempty"`
}
