/*
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

import { SpeakeasyBase, SpeakeasyMetadata } from "../../../internal/utils";
import { Expose, Transform } from "class-transformer";

/**
 * The direction used to render the individual's name.
 */
export enum IndividualNameDirectionEnum {
  LeftToRight = "left-to-right",
  RightToLeft = "right-to-left",
}

/**
 * The individual's name prefix.
 */
export enum IndividualNameNamePrefixEnum {
  Mr = "Mr",
  Ms = "Ms",
}

/**
 * The name type.
 */
export enum IndividualNameNameTypeEnum {
  Alias = "Alias",
  PrincipalName = "Principal Name",
}

/**
 * The Individual Name resource.
 */
export class IndividualNameInput extends SpeakeasyBase {
  /**
   * The direction used to render the individual's name.
   */
  @SpeakeasyMetadata()
  @Expose({ name: "direction" })
  direction?: IndividualNameDirectionEnum;

  /**
   * The individual's family name.
   */
  @SpeakeasyMetadata()
  @Expose({ name: "familyName" })
  familyName?: string;

  /**
   * The individual's formal salutation, for example, "Mr William Smith".
   */
  @SpeakeasyMetadata()
  @Expose({ name: "formalSalutation" })
  formalSalutation?: string;

  /**
   * The individual's given name.
   */
  @SpeakeasyMetadata()
  @Expose({ name: "givenName" })
  givenName?: string;

  /**
   * The individual's informal salutation, for example, "Bill".
   */
  @SpeakeasyMetadata()
  @Expose({ name: "informalSalutation" })
  informalSalutation?: string;

  /**
   * The individual's middle name.
   */
  @SpeakeasyMetadata()
  @Expose({ name: "middleName" })
  middleName?: string;

  /**
   * The individual's name prefix.
   */
  @SpeakeasyMetadata()
  @Expose({ name: "namePrefix" })
  namePrefix?: IndividualNameNamePrefixEnum;

  /**
   * The individual's name suffix, for example, "Jr" or "Sr".
   */
  @SpeakeasyMetadata()
  @Expose({ name: "nameSuffix" })
  nameSuffix?: string;

  /**
   * The name type.
   */
  @SpeakeasyMetadata()
  @Expose({ name: "nameType" })
  nameType?: IndividualNameNameTypeEnum;
}

/**
 * The Individual Name resource.
 */
export class IndividualName extends SpeakeasyBase {
  /**
   * The direction used to render the individual's name.
   */
  @SpeakeasyMetadata()
  @Expose({ name: "direction" })
  direction?: IndividualNameDirectionEnum;

  /**
   * The individual's family name.
   */
  @SpeakeasyMetadata()
  @Expose({ name: "familyName" })
  familyName?: string;

  /**
   * The individual's formal salutation, for example, "Mr William Smith".
   */
  @SpeakeasyMetadata()
  @Expose({ name: "formalSalutation" })
  formalSalutation?: string;

  /**
   * The date and time the resource became active in the format defined by [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601).
   */
  @SpeakeasyMetadata()
  @Expose({ name: "fromDate" })
  @Transform(({ value }) => new Date(value), { toClassOnly: true })
  fromDate?: Date;

  /**
   * The individual's given name.
   */
  @SpeakeasyMetadata()
  @Expose({ name: "givenName" })
  givenName?: string;

  /**
   * The resource's unique identifier.
   */
  @SpeakeasyMetadata()
  @Expose({ name: "id" })
  id?: string;

  /**
   * The individual's informal salutation, for example, "Bill".
   */
  @SpeakeasyMetadata()
  @Expose({ name: "informalSalutation" })
  informalSalutation?: string;

  /**
   * The individual's middle name.
   */
  @SpeakeasyMetadata()
  @Expose({ name: "middleName" })
  middleName?: string;

  /**
   * The individual's name prefix.
   */
  @SpeakeasyMetadata()
  @Expose({ name: "namePrefix" })
  namePrefix?: IndividualNameNamePrefixEnum;

  /**
   * The individual's name suffix, for example, "Jr" or "Sr".
   */
  @SpeakeasyMetadata()
  @Expose({ name: "nameSuffix" })
  nameSuffix?: string;

  /**
   * The name type.
   */
  @SpeakeasyMetadata()
  @Expose({ name: "nameType" })
  nameType?: IndividualNameNameTypeEnum;

  /**
   * The date and time the resource became inactive in the format defined by [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601).
   */
  @SpeakeasyMetadata()
  @Expose({ name: "toDate" })
  @Transform(({ value }) => new Date(value), { toClassOnly: true })
  toDate?: Date;
}
