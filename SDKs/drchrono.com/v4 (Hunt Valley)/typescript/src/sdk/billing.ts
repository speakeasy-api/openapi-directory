/*
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

import * as utils from "../internal/utils";
import * as operations from "./models/operations";
import * as shared from "./models/shared";
import { AxiosInstance, AxiosRequestConfig, AxiosResponse } from "axios";

/**
 * Create and manage billing resources
 */
export class Billing {
  _defaultClient: AxiosInstance;
  _securityClient: AxiosInstance;
  _serverURL: string;
  _language: string;
  _sdkVersion: string;
  _genVersion: string;

  constructor(
    defaultClient: AxiosInstance,
    securityClient: AxiosInstance,
    serverURL: string,
    language: string,
    sdkVersion: string,
    genVersion: string
  ) {
    this._defaultClient = defaultClient;
    this._securityClient = securityClient;
    this._serverURL = serverURL;
    this._language = language;
    this._sdkVersion = sdkVersion;
    this._genVersion = genVersion;
  }

  /**
   * Retrieve or search billing profiles
   */
  billingProfilesList(
    req: operations.BillingProfilesListRequest,
    security: operations.BillingProfilesListSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.BillingProfilesListResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.BillingProfilesListRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/api/billing_profiles";
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.BillingProfilesListSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.BillingProfilesListResponse =
        new operations.BillingProfilesListResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.billingProfilesList200ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.BillingProfilesList200ApplicationJSON
              );
          }
          break;
        case [400, 401, 403, 404, 405, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Retrieve an existing billing profiles
   */
  billingProfilesRead(
    req: operations.BillingProfilesReadRequest,
    security: operations.BillingProfilesReadSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.BillingProfilesReadResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.BillingProfilesReadRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/api/billing_profiles/{id}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.BillingProfilesReadSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.BillingProfilesReadResponse =
        new operations.BillingProfilesReadResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.billingProfile = utils.objectToClass(
              httpRes?.data,
              shared.BillingProfile
            );
          }
          break;
        case [400, 401, 403, 404, 405, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Create communication (phone call) logs
   */
  commLogsCreate(
    req: operations.CommLogsCreateRequest,
    security: operations.CommLogsCreateSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.CommLogsCreateResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CommLogsCreateRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/api/comm_logs";
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.CommLogsCreateSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "post",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CommLogsCreateResponse =
        new operations.CommLogsCreateResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.phoneCallLog = utils.objectToClass(
              httpRes?.data,
              shared.PhoneCallLog
            );
          }
          break;
        case [400, 401, 403, 404, 405, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Retrieve or search communicatioin (phone call) logs
   */
  commLogsList(
    req: operations.CommLogsListRequest,
    security: operations.CommLogsListSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.CommLogsListResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CommLogsListRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/api/comm_logs";
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.CommLogsListSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CommLogsListResponse =
        new operations.CommLogsListResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.commLogsList200ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.CommLogsList200ApplicationJSON
            );
          }
          break;
        case [400, 401, 403, 404, 405, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Update an existing communication (phone call) logs
   */
  commLogsPartialUpdate(
    req: operations.CommLogsPartialUpdateRequest,
    security: operations.CommLogsPartialUpdateSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.CommLogsPartialUpdateResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CommLogsPartialUpdateRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(baseURL, "/api/comm_logs/{id}", req);
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.CommLogsPartialUpdateSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "patch",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CommLogsPartialUpdateResponse =
        new operations.CommLogsPartialUpdateResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case [204, 400, 401, 403, 404, 405, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Retrieve an existing communication (phone call) logs
   */
  commLogsRead(
    req: operations.CommLogsReadRequest,
    security: operations.CommLogsReadSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.CommLogsReadResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CommLogsReadRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(baseURL, "/api/comm_logs/{id}", req);
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.CommLogsReadSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CommLogsReadResponse =
        new operations.CommLogsReadResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.phoneCallLog = utils.objectToClass(
              httpRes?.data,
              shared.PhoneCallLog
            );
          }
          break;
        case [400, 401, 403, 404, 405, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Update an existing communication (phone call) logs
   */
  commLogsUpdate(
    req: operations.CommLogsUpdateRequest,
    security: operations.CommLogsUpdateSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.CommLogsUpdateResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CommLogsUpdateRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(baseURL, "/api/comm_logs/{id}", req);
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.CommLogsUpdateSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "put",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CommLogsUpdateResponse =
        new operations.CommLogsUpdateResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case [204, 400, 401, 403, 404, 405, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Retrieve or search custom insurance plan names
   */
  customInsurancePlanNamesList(
    req: operations.CustomInsurancePlanNamesListRequest,
    security: operations.CustomInsurancePlanNamesListSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.CustomInsurancePlanNamesListResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CustomInsurancePlanNamesListRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/api/custom_insurance_plan_names";
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.CustomInsurancePlanNamesListSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CustomInsurancePlanNamesListResponse =
        new operations.CustomInsurancePlanNamesListResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.customInsurancePlanNamesList200ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.CustomInsurancePlanNamesList200ApplicationJSON
              );
          }
          break;
        case [400, 401, 403, 404, 405, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Retrieve an existing custom insurance plan name
   */
  customInsurancePlanNamesRead(
    req: operations.CustomInsurancePlanNamesReadRequest,
    security: operations.CustomInsurancePlanNamesReadSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.CustomInsurancePlanNamesReadResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CustomInsurancePlanNamesReadRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/api/custom_insurance_plan_names/{id}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.CustomInsurancePlanNamesReadSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CustomInsurancePlanNamesReadResponse =
        new operations.CustomInsurancePlanNamesReadResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.customInsurancePlanName = utils.objectToClass(
              httpRes?.data,
              shared.CustomInsurancePlanName
            );
          }
          break;
        case [400, 401, 403, 404, 405, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Retrieve or search past eligibility checks for patient
   */
  eligibilityChecksList(
    req: operations.EligibilityChecksListRequest,
    security: operations.EligibilityChecksListSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.EligibilityChecksListResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.EligibilityChecksListRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/api/eligibility_checks";
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.EligibilityChecksListSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.EligibilityChecksListResponse =
        new operations.EligibilityChecksListResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.eligibilityChecksList200ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.EligibilityChecksList200ApplicationJSON
              );
          }
          break;
        case [400, 401, 403, 404, 405, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Retrieve an existing past eligibility check
   */
  eligibilityChecksRead(
    req: operations.EligibilityChecksReadRequest,
    security: operations.EligibilityChecksReadSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.EligibilityChecksReadResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.EligibilityChecksReadRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/api/eligibility_checks/{id}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.EligibilityChecksReadSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.EligibilityChecksReadResponse =
        new operations.EligibilityChecksReadResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.coverage = utils.objectToClass(httpRes?.data, shared.Coverage);
          }
          break;
        case [400, 401, 403, 404, 405, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Create billing line item for appointments
   */
  lineItemsCreate(
    req: operations.LineItemsCreateRequest,
    security: operations.LineItemsCreateSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.LineItemsCreateResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.LineItemsCreateRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/api/line_items";
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.LineItemsCreateSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "post",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.LineItemsCreateResponse =
        new operations.LineItemsCreateResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.billingLineItem = utils.objectToClass(
              httpRes?.data,
              shared.BillingLineItem
            );
          }
          break;
        case [400, 401, 403, 404, 405, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  lineItemsDelete(
    req: operations.LineItemsDeleteRequest,
    security: operations.LineItemsDeleteSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.LineItemsDeleteResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.LineItemsDeleteRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(baseURL, "/api/line_items/{id}", req);
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.LineItemsDeleteSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.LineItemsDeleteResponse =
        new operations.LineItemsDeleteResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case [204, 400, 401, 403, 404, 405, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Retrieve or search billing line items
   */
  lineItemsList(
    req: operations.LineItemsListRequest,
    security: operations.LineItemsListSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.LineItemsListResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.LineItemsListRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/api/line_items";
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.LineItemsListSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.LineItemsListResponse =
        new operations.LineItemsListResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.lineItemsList200ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.LineItemsList200ApplicationJSON
            );
          }
          break;
        case [400, 401, 403, 404, 405, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  lineItemsPartialUpdate(
    req: operations.LineItemsPartialUpdateRequest,
    security: operations.LineItemsPartialUpdateSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.LineItemsPartialUpdateResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.LineItemsPartialUpdateRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(baseURL, "/api/line_items/{id}", req);
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.LineItemsPartialUpdateSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "patch",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.LineItemsPartialUpdateResponse =
        new operations.LineItemsPartialUpdateResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case [204, 400, 401, 403, 404, 405, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Retrieve an existing billing line item
   */
  lineItemsRead(
    req: operations.LineItemsReadRequest,
    security: operations.LineItemsReadSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.LineItemsReadResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.LineItemsReadRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(baseURL, "/api/line_items/{id}", req);
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.LineItemsReadSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.LineItemsReadResponse =
        new operations.LineItemsReadResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.billingLineItem = utils.objectToClass(
              httpRes?.data,
              shared.BillingLineItem
            );
          }
          break;
        case [400, 401, 403, 404, 405, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  lineItemsUpdate(
    req: operations.LineItemsUpdateRequest,
    security: operations.LineItemsUpdateSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.LineItemsUpdateResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.LineItemsUpdateRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(baseURL, "/api/line_items/{id}", req);
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.LineItemsUpdateSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "put",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.LineItemsUpdateResponse =
        new operations.LineItemsUpdateResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case [204, 400, 401, 403, 404, 405, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Retrieve or search patient payment logs
   */
  patientPaymentLogList(
    req: operations.PatientPaymentLogListRequest,
    security: operations.PatientPaymentLogListSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.PatientPaymentLogListResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PatientPaymentLogListRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/api/patient_payment_log";
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.PatientPaymentLogListSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PatientPaymentLogListResponse =
        new operations.PatientPaymentLogListResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.patientPaymentLogList200ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.PatientPaymentLogList200ApplicationJSON
              );
          }
          break;
        case [400, 401, 403, 404, 405, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Retrieve an existing patient payment log
   */
  patientPaymentLogRead(
    req: operations.PatientPaymentLogReadRequest,
    security: operations.PatientPaymentLogReadSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.PatientPaymentLogReadResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PatientPaymentLogReadRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/api/patient_payment_log/{id}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.PatientPaymentLogReadSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PatientPaymentLogReadResponse =
        new operations.PatientPaymentLogReadResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.cashPaymentLog = utils.objectToClass(
              httpRes?.data,
              shared.CashPaymentLog
            );
          }
          break;
        case [400, 401, 403, 404, 405, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Create patient payment
   */
  patientPaymentsCreate(
    req: operations.PatientPaymentsCreateRequest,
    security: operations.PatientPaymentsCreateSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.PatientPaymentsCreateResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PatientPaymentsCreateRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/api/patient_payments";
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.PatientPaymentsCreateSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "post",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PatientPaymentsCreateResponse =
        new operations.PatientPaymentsCreateResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.cashPayment = utils.objectToClass(
              httpRes?.data,
              shared.CashPayment
            );
          }
          break;
        case [400, 401, 403, 404, 405, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Retrieve or search patient payments
   */
  patientPaymentsList(
    req: operations.PatientPaymentsListRequest,
    security: operations.PatientPaymentsListSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.PatientPaymentsListResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PatientPaymentsListRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/api/patient_payments";
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.PatientPaymentsListSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PatientPaymentsListResponse =
        new operations.PatientPaymentsListResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.patientPaymentsList200ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.PatientPaymentsList200ApplicationJSON
              );
          }
          break;
        case [400, 401, 403, 404, 405, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Retrieve an existing patient payment
   */
  patientPaymentsRead(
    req: operations.PatientPaymentsReadRequest,
    security: operations.PatientPaymentsReadSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.PatientPaymentsReadResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PatientPaymentsReadRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/api/patient_payments/{id}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.PatientPaymentsReadSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PatientPaymentsReadResponse =
        new operations.PatientPaymentsReadResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.cashPayment = utils.objectToClass(
              httpRes?.data,
              shared.CashPayment
            );
          }
          break;
        case [400, 401, 403, 404, 405, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  proceduresList(
    req: operations.ProceduresListRequest,
    security: operations.ProceduresListSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.ProceduresListResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ProceduresListRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/api/procedures";
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ProceduresListSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ProceduresListResponse =
        new operations.ProceduresListResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.proceduresList200ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.ProceduresList200ApplicationJSON
            );
          }
          break;
        case [400, 401, 403, 404, 405, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  proceduresRead(
    req: operations.ProceduresReadRequest,
    security: operations.ProceduresReadSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.ProceduresReadResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ProceduresReadRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(baseURL, "/api/procedures/{id}", req);
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ProceduresReadSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ProceduresReadResponse =
        new operations.ProceduresReadResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.billingLineItem = utils.objectToClass(
              httpRes?.data,
              shared.BillingLineItem
            );
          }
          break;
        case [400, 401, 403, 404, 405, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Retrieve or search insurance transactions associated with billing line items
   */
  transactionsList(
    req: operations.TransactionsListRequest,
    security: operations.TransactionsListSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.TransactionsListResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.TransactionsListRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/api/transactions";
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.TransactionsListSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.TransactionsListResponse =
        new operations.TransactionsListResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.transactionsList200ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.TransactionsList200ApplicationJSON
            );
          }
          break;
        case [400, 401, 403, 404, 405, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Retrieve an existing insurance transaction
   */
  transactionsRead(
    req: operations.TransactionsReadRequest,
    security: operations.TransactionsReadSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.TransactionsReadResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.TransactionsReadRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/api/transactions/{id}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.TransactionsReadSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.TransactionsReadResponse =
        new operations.TransactionsReadResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.lineItemTransaction = utils.objectToClass(
              httpRes?.data,
              shared.LineItemTransaction
            );
          }
          break;
        case [400, 401, 403, 404, 405, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }
}
