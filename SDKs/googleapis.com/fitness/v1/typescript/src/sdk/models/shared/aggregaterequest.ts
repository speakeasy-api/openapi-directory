/*
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

import { SpeakeasyBase, SpeakeasyMetadata } from "../../../internal/utils";
import { AggregateBy } from "./aggregateby";
import { BucketByActivity } from "./bucketbyactivity";
import { BucketBySession } from "./bucketbysession";
import { BucketByTime } from "./bucketbytime";
import { Expose, Type } from "class-transformer";

export enum AggregateRequestFilteredDataQualityStandardEnum {
  DataQualityUnknown = "dataQualityUnknown",
  DataQualityBloodPressureEsh2002 = "dataQualityBloodPressureEsh2002",
  DataQualityBloodPressureEsh2010 = "dataQualityBloodPressureEsh2010",
  DataQualityBloodPressureAami = "dataQualityBloodPressureAami",
  DataQualityBloodPressureBhsAA = "dataQualityBloodPressureBhsAA",
  DataQualityBloodPressureBhsAB = "dataQualityBloodPressureBhsAB",
  DataQualityBloodPressureBhsBA = "dataQualityBloodPressureBhsBA",
  DataQualityBloodPressureBhsBB = "dataQualityBloodPressureBhsBB",
  DataQualityBloodGlucoseIso151972003 = "dataQualityBloodGlucoseIso151972003",
  DataQualityBloodGlucoseIso151972013 = "dataQualityBloodGlucoseIso151972013",
}

/**
 * Next id: 10
 */
export class AggregateRequest extends SpeakeasyBase {
  /**
   * The specification of data to be aggregated. At least one aggregateBy spec must be provided. All data that is specified will be aggregated using the same bucketing criteria. There will be one dataset in the response for every aggregateBy spec.
   */
  @SpeakeasyMetadata({ elemType: AggregateBy })
  @Expose({ name: "aggregateBy" })
  @Type(() => AggregateBy)
  aggregateBy?: AggregateBy[];

  @SpeakeasyMetadata()
  @Expose({ name: "bucketByActivitySegment" })
  @Type(() => BucketByActivity)
  bucketByActivitySegment?: BucketByActivity;

  @SpeakeasyMetadata()
  @Expose({ name: "bucketByActivityType" })
  @Type(() => BucketByActivity)
  bucketByActivityType?: BucketByActivity;

  @SpeakeasyMetadata()
  @Expose({ name: "bucketBySession" })
  @Type(() => BucketBySession)
  bucketBySession?: BucketBySession;

  @SpeakeasyMetadata()
  @Expose({ name: "bucketByTime" })
  @Type(() => BucketByTime)
  bucketByTime?: BucketByTime;

  /**
   * The end of a window of time. Data that intersects with this time window will be aggregated. The time is in milliseconds since epoch, inclusive. The maximum allowed difference between start_time_millis // and end_time_millis is 7776000000 (roughly 90 days).
   */
  @SpeakeasyMetadata()
  @Expose({ name: "endTimeMillis" })
  endTimeMillis?: string;

  /**
   * DO NOT POPULATE THIS FIELD. It is ignored.
   */
  @SpeakeasyMetadata()
  @Expose({ name: "filteredDataQualityStandard" })
  filteredDataQualityStandard?: AggregateRequestFilteredDataQualityStandardEnum[];

  /**
   * The start of a window of time. Data that intersects with this time window will be aggregated. The time is in milliseconds since epoch, inclusive.
   */
  @SpeakeasyMetadata()
  @Expose({ name: "startTimeMillis" })
  startTimeMillis?: string;
}
