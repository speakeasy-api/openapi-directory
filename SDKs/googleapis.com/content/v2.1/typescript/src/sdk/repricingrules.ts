/*
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

import * as utils from "../internal/utils";
import * as operations from "./models/operations";
import * as shared from "./models/shared";
import { AxiosInstance, AxiosRequestConfig, AxiosResponse } from "axios";

export class Repricingrules {
  _defaultClient: AxiosInstance;
  _securityClient: AxiosInstance;
  _serverURL: string;
  _language: string;
  _sdkVersion: string;
  _genVersion: string;

  constructor(
    defaultClient: AxiosInstance,
    securityClient: AxiosInstance,
    serverURL: string,
    language: string,
    sdkVersion: string,
    genVersion: string
  ) {
    this._defaultClient = defaultClient;
    this._securityClient = securityClient;
    this._serverURL = serverURL;
    this._language = language;
    this._sdkVersion = sdkVersion;
    this._genVersion = genVersion;
  }

  /**
   * Creates a repricing rule for your Merchant Center account.
   */
  contentRepricingrulesCreate(
    req: operations.ContentRepricingrulesCreateRequest,
    security: operations.ContentRepricingrulesCreateSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.ContentRepricingrulesCreateResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ContentRepricingrulesCreateRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/{merchantId}/repricingrules",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "repricingRuleInput",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ContentRepricingrulesCreateSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ContentRepricingrulesCreateResponse =
        new operations.ContentRepricingrulesCreateResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.repricingRule = utils.objectToClass(
              httpRes?.data,
              shared.RepricingRule
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Deletes a repricing rule in your Merchant Center account.
   */
  contentRepricingrulesDelete(
    req: operations.ContentRepricingrulesDeleteRequest,
    security: operations.ContentRepricingrulesDeleteSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.ContentRepricingrulesDeleteResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ContentRepricingrulesDeleteRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/{merchantId}/repricingrules/{ruleId}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ContentRepricingrulesDeleteSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ContentRepricingrulesDeleteResponse =
        new operations.ContentRepricingrulesDeleteResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          break;
      }

      return res;
    });
  }

  /**
   * Retrieves a repricing rule from your Merchant Center account.
   */
  contentRepricingrulesGet(
    req: operations.ContentRepricingrulesGetRequest,
    security: operations.ContentRepricingrulesGetSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.ContentRepricingrulesGetResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ContentRepricingrulesGetRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/{merchantId}/repricingrules/{ruleId}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ContentRepricingrulesGetSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ContentRepricingrulesGetResponse =
        new operations.ContentRepricingrulesGetResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.repricingRule = utils.objectToClass(
              httpRes?.data,
              shared.RepricingRule
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Lists the repricing rules in your Merchant Center account.
   */
  contentRepricingrulesList(
    req: operations.ContentRepricingrulesListRequest,
    security: operations.ContentRepricingrulesListSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.ContentRepricingrulesListResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ContentRepricingrulesListRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/{merchantId}/repricingrules",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ContentRepricingrulesListSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ContentRepricingrulesListResponse =
        new operations.ContentRepricingrulesListResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listRepricingRulesResponse = utils.objectToClass(
              httpRes?.data,
              shared.ListRepricingRulesResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Updates a repricing rule in your Merchant Center account. All mutable fields will be overwritten in each update request. In each update, you must provide all required mutable fields, or an error will be thrown. If you do not provide an optional field in the update request, if that field currently exists, it will be deleted from the rule.
   */
  contentRepricingrulesPatch(
    req: operations.ContentRepricingrulesPatchRequest,
    security: operations.ContentRepricingrulesPatchSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.ContentRepricingrulesPatchResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ContentRepricingrulesPatchRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/{merchantId}/repricingrules/{ruleId}",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "repricingRuleInput",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ContentRepricingrulesPatchSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "patch",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ContentRepricingrulesPatchResponse =
        new operations.ContentRepricingrulesPatchResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.repricingRule = utils.objectToClass(
              httpRes?.data,
              shared.RepricingRule
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Lists the metrics report for a given Repricing rule.
   */
  contentRepricingrulesRepricingreportsList(
    req: operations.ContentRepricingrulesRepricingreportsListRequest,
    security: operations.ContentRepricingrulesRepricingreportsListSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.ContentRepricingrulesRepricingreportsListResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ContentRepricingrulesRepricingreportsListRequest(
        req
      );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/{merchantId}/repricingrules/{ruleId}/repricingreports",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.ContentRepricingrulesRepricingreportsListSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ContentRepricingrulesRepricingreportsListResponse =
        new operations.ContentRepricingrulesRepricingreportsListResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listRepricingRuleReportsResponse = utils.objectToClass(
              httpRes?.data,
              shared.ListRepricingRuleReportsResponse
            );
          }
          break;
      }

      return res;
    });
  }
}
