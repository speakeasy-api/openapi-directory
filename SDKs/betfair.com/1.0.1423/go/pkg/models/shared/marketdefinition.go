// Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.

package shared

import (
	"encoding/json"
	"fmt"
	"time"
)

type MarketDefinitionBettingTypeEnum string

const (
	MarketDefinitionBettingTypeEnumOdds                    MarketDefinitionBettingTypeEnum = "ODDS"
	MarketDefinitionBettingTypeEnumLine                    MarketDefinitionBettingTypeEnum = "LINE"
	MarketDefinitionBettingTypeEnumRange                   MarketDefinitionBettingTypeEnum = "RANGE"
	MarketDefinitionBettingTypeEnumAsianHandicapDoubleLine MarketDefinitionBettingTypeEnum = "ASIAN_HANDICAP_DOUBLE_LINE"
	MarketDefinitionBettingTypeEnumAsianHandicapSingleLine MarketDefinitionBettingTypeEnum = "ASIAN_HANDICAP_SINGLE_LINE"
)

func (e MarketDefinitionBettingTypeEnum) ToPointer() *MarketDefinitionBettingTypeEnum {
	return &e
}

func (e *MarketDefinitionBettingTypeEnum) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "ODDS":
		fallthrough
	case "LINE":
		fallthrough
	case "RANGE":
		fallthrough
	case "ASIAN_HANDICAP_DOUBLE_LINE":
		fallthrough
	case "ASIAN_HANDICAP_SINGLE_LINE":
		*e = MarketDefinitionBettingTypeEnum(v)
		return nil
	default:
		return fmt.Errorf("invalid value for MarketDefinitionBettingTypeEnum: %v", v)
	}
}

type MarketDefinitionStatusEnum string

const (
	MarketDefinitionStatusEnumInactive  MarketDefinitionStatusEnum = "INACTIVE"
	MarketDefinitionStatusEnumOpen      MarketDefinitionStatusEnum = "OPEN"
	MarketDefinitionStatusEnumSuspended MarketDefinitionStatusEnum = "SUSPENDED"
	MarketDefinitionStatusEnumClosed    MarketDefinitionStatusEnum = "CLOSED"
)

func (e MarketDefinitionStatusEnum) ToPointer() *MarketDefinitionStatusEnum {
	return &e
}

func (e *MarketDefinitionStatusEnum) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "INACTIVE":
		fallthrough
	case "OPEN":
		fallthrough
	case "SUSPENDED":
		fallthrough
	case "CLOSED":
		*e = MarketDefinitionStatusEnum(v)
		return nil
	default:
		return fmt.Errorf("invalid value for MarketDefinitionStatusEnum: %v", v)
	}
}

type MarketDefinition struct {
	BetDelay        *int                             `json:"betDelay,omitempty"`
	BettingType     *MarketDefinitionBettingTypeEnum `json:"bettingType,omitempty"`
	BspMarket       *bool                            `json:"bspMarket,omitempty"`
	BspReconciled   *bool                            `json:"bspReconciled,omitempty"`
	Complete        *bool                            `json:"complete,omitempty"`
	CountryCode     *string                          `json:"countryCode,omitempty"`
	CrossMatching   *bool                            `json:"crossMatching,omitempty"`
	DiscountAllowed *bool                            `json:"discountAllowed,omitempty"`
	EachWayDivisor  *float64                         `json:"eachWayDivisor,omitempty"`
	EventID         *string                          `json:"eventId,omitempty"`
	// The Event Type the market is contained within.
	EventTypeID       *string            `json:"eventTypeId,omitempty"`
	InPlay            *bool              `json:"inPlay,omitempty"`
	KeyLineDefinition *KeyLineDefinition `json:"keyLineDefinition,omitempty"`
	// For Handicap and Line markets, the lines available on this market will be between the range of lineMinUnit and lineMaxUnit, in increments of the lineInterval value. e.g. If unit is runs, lineMinUnit=10, lineMaxUnit=20 and lineInterval=0.5, then valid lines include 10, 10.5, 11, 11.5 up to 20 runs.
	LineInterval *float64 `json:"lineInterval,omitempty"`
	// For Handicap and Line markets, the maximum value for the outcome, in market units for this market (eg 100 runs).
	LineMaxUnit *float64 `json:"lineMaxUnit,omitempty"`
	// For Handicap and Line markets, the minimum value for the outcome, in market units for this market (eg 0 runs).
	LineMinUnit           *float64               `json:"lineMinUnit,omitempty"`
	MarketBaseRate        *float64               `json:"marketBaseRate,omitempty"`
	MarketTime            *time.Time             `json:"marketTime,omitempty"`
	MarketType            *string                `json:"marketType,omitempty"`
	NumberOfActiveRunners *int                   `json:"numberOfActiveRunners,omitempty"`
	NumberOfWinners       *int                   `json:"numberOfWinners,omitempty"`
	OpenDate              *time.Time             `json:"openDate,omitempty"`
	PersistenceEnabled    *bool                  `json:"persistenceEnabled,omitempty"`
	PriceLadderDefinition *PriceLadderDefinition `json:"priceLadderDefinition,omitempty"`
	RaceType              *string                `json:"raceType,omitempty"`
	// The market regulators.
	Regulators        []string                    `json:"regulators,omitempty"`
	Runners           []RunnerDefinition          `json:"runners,omitempty"`
	RunnersVoidable   *bool                       `json:"runnersVoidable,omitempty"`
	SettledTime       *time.Time                  `json:"settledTime,omitempty"`
	Status            *MarketDefinitionStatusEnum `json:"status,omitempty"`
	SuspendTime       *time.Time                  `json:"suspendTime,omitempty"`
	Timezone          *string                     `json:"timezone,omitempty"`
	TurnInPlayEnabled *bool                       `json:"turnInPlayEnabled,omitempty"`
	Venue             *string                     `json:"venue,omitempty"`
	Version           *int64                      `json:"version,omitempty"`
}
