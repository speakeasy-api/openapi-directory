// Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.

package operations

import (
	"encoding/json"
	"fmt"
	"net/http"
	"openapi/pkg/models/shared"
)

type CreateVodPathParams struct {
	// The ID of the user.
	UserID float64 `pathParam:"style=simple,explode=false,name=user_id"`
}

// CreateVodRequestBodyAcceptedCurrenciesEnum - An array of accepted currencies.
//
// Option descriptions:
//   - `AUD` - Australian Dollar
//   - `CAD` - Canadian Dollar
//   - `CHF` - Swiss Franc
//   - `DKK` - Danish Krone
//   - `EUR` - Euro
//   - `GBP` - British Pound
//   - `JPY` - Japanese Yen
//   - `KRW` - South Korean Won
//   - `NOK` - Norwegian Krone
//   - `PLN` - Polish Zloty
//   - `SEK` - Swedish Krona
//   - `USD` - US Dollar
type CreateVodRequestBodyAcceptedCurrenciesEnum string

const (
	CreateVodRequestBodyAcceptedCurrenciesEnumAud CreateVodRequestBodyAcceptedCurrenciesEnum = "AUD"
	CreateVodRequestBodyAcceptedCurrenciesEnumCad CreateVodRequestBodyAcceptedCurrenciesEnum = "CAD"
	CreateVodRequestBodyAcceptedCurrenciesEnumChf CreateVodRequestBodyAcceptedCurrenciesEnum = "CHF"
	CreateVodRequestBodyAcceptedCurrenciesEnumDkk CreateVodRequestBodyAcceptedCurrenciesEnum = "DKK"
	CreateVodRequestBodyAcceptedCurrenciesEnumEur CreateVodRequestBodyAcceptedCurrenciesEnum = "EUR"
	CreateVodRequestBodyAcceptedCurrenciesEnumGbp CreateVodRequestBodyAcceptedCurrenciesEnum = "GBP"
	CreateVodRequestBodyAcceptedCurrenciesEnumJpy CreateVodRequestBodyAcceptedCurrenciesEnum = "JPY"
	CreateVodRequestBodyAcceptedCurrenciesEnumKrw CreateVodRequestBodyAcceptedCurrenciesEnum = "KRW"
	CreateVodRequestBodyAcceptedCurrenciesEnumNok CreateVodRequestBodyAcceptedCurrenciesEnum = "NOK"
	CreateVodRequestBodyAcceptedCurrenciesEnumPln CreateVodRequestBodyAcceptedCurrenciesEnum = "PLN"
	CreateVodRequestBodyAcceptedCurrenciesEnumSek CreateVodRequestBodyAcceptedCurrenciesEnum = "SEK"
	CreateVodRequestBodyAcceptedCurrenciesEnumUsd CreateVodRequestBodyAcceptedCurrenciesEnum = "USD"
)

func (e *CreateVodRequestBodyAcceptedCurrenciesEnum) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return err
	}
	switch s {
	case "AUD":
		fallthrough
	case "CAD":
		fallthrough
	case "CHF":
		fallthrough
	case "DKK":
		fallthrough
	case "EUR":
		fallthrough
	case "GBP":
		fallthrough
	case "JPY":
		fallthrough
	case "KRW":
		fallthrough
	case "NOK":
		fallthrough
	case "PLN":
		fallthrough
	case "SEK":
		fallthrough
	case "USD":
		*e = CreateVodRequestBodyAcceptedCurrenciesEnum(s)
		return nil
	default:
		return fmt.Errorf("invalid value for CreateVodRequestBodyAcceptedCurrenciesEnum: %s", s)
	}
}

type CreateVodRequestBodyBuyPrice struct {
	// The purchase price of this video in AUD.
	Aud *float64 `json:"AUD,omitempty"`
	// The purchase price of this video in CAD.
	Cad *float64 `json:"CAD,omitempty"`
	// The purchase price of this video in CHF.
	Chf *float64 `json:"CHF,omitempty"`
	// The purchase price of this video in DKK.
	Dkk *float64 `json:"DKK,omitempty"`
	// The purchase price of this video in EUR.
	Eur *float64 `json:"EUR,omitempty"`
	// The purchase price of this video in GBP.
	Gbp *float64 `json:"GBP,omitempty"`
	// The purchase price of this video in JPY.
	Jpy *float64 `json:"JPY,omitempty"`
	// The purchase price of this video in KRW.
	Krw *float64 `json:"KRW,omitempty"`
	// The purchase price of this video in NOK.
	Nok *float64 `json:"NOK,omitempty"`
	// The purchase price of this video in PLN.
	Pln *float64 `json:"PLN,omitempty"`
	// The purchase price of this video in SEK.
	Sek *float64 `json:"SEK,omitempty"`
	// The purchase price of this video in USD when `type` is `film`, or the purchase price of the entire collection in USD when `type` is `series`.
	Usd *float64 `json:"USD,omitempty"`
}

type CreateVodRequestBodyBuy struct {
	// Whether the Buy action is active. *Required if `rent.active` is false.
	Active *bool `json:"active,omitempty"`
	// Whether people who buy the video can download it. To use this field, `type` must be `film`.
	Download *bool                         `json:"download,omitempty"`
	Price    *CreateVodRequestBodyBuyPrice `json:"price,omitempty"`
}

// CreateVodRequestBodyContentRatingEnum - One or more ratings, either as a comma-separated list or as a JSON array depending on the request format.
type CreateVodRequestBodyContentRatingEnum string

const (
	CreateVodRequestBodyContentRatingEnumDrugs    CreateVodRequestBodyContentRatingEnum = "drugs"
	CreateVodRequestBodyContentRatingEnumLanguage CreateVodRequestBodyContentRatingEnum = "language"
	CreateVodRequestBodyContentRatingEnumNudity   CreateVodRequestBodyContentRatingEnum = "nudity"
	CreateVodRequestBodyContentRatingEnumSafe     CreateVodRequestBodyContentRatingEnum = "safe"
	CreateVodRequestBodyContentRatingEnumUnrated  CreateVodRequestBodyContentRatingEnum = "unrated"
	CreateVodRequestBodyContentRatingEnumViolence CreateVodRequestBodyContentRatingEnum = "violence"
)

func (e *CreateVodRequestBodyContentRatingEnum) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return err
	}
	switch s {
	case "drugs":
		fallthrough
	case "language":
		fallthrough
	case "nudity":
		fallthrough
	case "safe":
		fallthrough
	case "unrated":
		fallthrough
	case "violence":
		*e = CreateVodRequestBodyContentRatingEnum(s)
		return nil
	default:
		return fmt.Errorf("invalid value for CreateVodRequestBodyContentRatingEnum: %s", s)
	}
}

type CreateVodRequestBodyEpisodesBuyPrice struct {
	// The purchase price per episode. *Required if `episodes.buy.active` is true.
	Usd *float64 `json:"USD,omitempty"`
}

type CreateVodRequestBodyEpisodesBuy struct {
	// Whether episodes can be bought.
	Active *bool `json:"active,omitempty"`
	// Whether people who buy the episode can download it. To use this field, `type` must be `series`.
	Download *bool                                 `json:"download,omitempty"`
	Price    *CreateVodRequestBodyEpisodesBuyPrice `json:"price,omitempty"`
}

// CreateVodRequestBodyEpisodesRentPeriodEnum - The period in which this episode can be rented for.
type CreateVodRequestBodyEpisodesRentPeriodEnum string

const (
	CreateVodRequestBodyEpisodesRentPeriodEnumOneWeek        CreateVodRequestBodyEpisodesRentPeriodEnum = "1 week"
	CreateVodRequestBodyEpisodesRentPeriodEnumOneYear        CreateVodRequestBodyEpisodesRentPeriodEnum = "1 year"
	CreateVodRequestBodyEpisodesRentPeriodEnumTwentyFourHour CreateVodRequestBodyEpisodesRentPeriodEnum = "24 hour"
	CreateVodRequestBodyEpisodesRentPeriodEnumThreeMonth     CreateVodRequestBodyEpisodesRentPeriodEnum = "3 month"
	CreateVodRequestBodyEpisodesRentPeriodEnumThirtyDay      CreateVodRequestBodyEpisodesRentPeriodEnum = "30 day"
	CreateVodRequestBodyEpisodesRentPeriodEnumFortyEightHour CreateVodRequestBodyEpisodesRentPeriodEnum = "48 hour"
	CreateVodRequestBodyEpisodesRentPeriodEnumSixMonth       CreateVodRequestBodyEpisodesRentPeriodEnum = "6 month"
	CreateVodRequestBodyEpisodesRentPeriodEnumSeventyTwoHour CreateVodRequestBodyEpisodesRentPeriodEnum = "72 hour"
)

func (e *CreateVodRequestBodyEpisodesRentPeriodEnum) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return err
	}
	switch s {
	case "1 week":
		fallthrough
	case "1 year":
		fallthrough
	case "24 hour":
		fallthrough
	case "3 month":
		fallthrough
	case "30 day":
		fallthrough
	case "48 hour":
		fallthrough
	case "6 month":
		fallthrough
	case "72 hour":
		*e = CreateVodRequestBodyEpisodesRentPeriodEnum(s)
		return nil
	default:
		return fmt.Errorf("invalid value for CreateVodRequestBodyEpisodesRentPeriodEnum: %s", s)
	}
}

type CreateVodRequestBodyEpisodesRentPrice struct {
	// The default price to rent an episode. This field is applicable only when `type` is `series`. *Required if `episodes.rent.active` is true.
	Usd *float64 `json:"USD,omitempty"`
}

type CreateVodRequestBodyEpisodesRent struct {
	// Whether episodes can be rented
	Active *bool `json:"active,omitempty"`
	// The period in which this episode can be rented for.
	Period *CreateVodRequestBodyEpisodesRentPeriodEnum `json:"period,omitempty"`
	Price  *CreateVodRequestBodyEpisodesRentPrice      `json:"price,omitempty"`
}

type CreateVodRequestBodyEpisodes struct {
	Buy  *CreateVodRequestBodyEpisodesBuy  `json:"buy,omitempty"`
	Rent *CreateVodRequestBodyEpisodesRent `json:"rent,omitempty"`
}

// CreateVodRequestBodyRentPeriodEnum - The period in which this can be rented for.
type CreateVodRequestBodyRentPeriodEnum string

const (
	CreateVodRequestBodyRentPeriodEnumOneWeek        CreateVodRequestBodyRentPeriodEnum = "1 week"
	CreateVodRequestBodyRentPeriodEnumOneYear        CreateVodRequestBodyRentPeriodEnum = "1 year"
	CreateVodRequestBodyRentPeriodEnumTwentyFourHour CreateVodRequestBodyRentPeriodEnum = "24 hour"
	CreateVodRequestBodyRentPeriodEnumThreeMonth     CreateVodRequestBodyRentPeriodEnum = "3 month"
	CreateVodRequestBodyRentPeriodEnumThirtyDay      CreateVodRequestBodyRentPeriodEnum = "30 day"
	CreateVodRequestBodyRentPeriodEnumFortyEightHour CreateVodRequestBodyRentPeriodEnum = "48 hour"
	CreateVodRequestBodyRentPeriodEnumSixMonth       CreateVodRequestBodyRentPeriodEnum = "6 month"
	CreateVodRequestBodyRentPeriodEnumSeventyTwoHour CreateVodRequestBodyRentPeriodEnum = "72 hour"
)

func (e *CreateVodRequestBodyRentPeriodEnum) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return err
	}
	switch s {
	case "1 week":
		fallthrough
	case "1 year":
		fallthrough
	case "24 hour":
		fallthrough
	case "3 month":
		fallthrough
	case "30 day":
		fallthrough
	case "48 hour":
		fallthrough
	case "6 month":
		fallthrough
	case "72 hour":
		*e = CreateVodRequestBodyRentPeriodEnum(s)
		return nil
	default:
		return fmt.Errorf("invalid value for CreateVodRequestBodyRentPeriodEnum: %s", s)
	}
}

type CreateVodRequestBodyRentPrice struct {
	// The rental price of this video in AUD.
	Aud *float64 `json:"AUD,omitempty"`
	// The rental price of this video in CAD.
	Cad *float64 `json:"CAD,omitempty"`
	// The rental price of this video in CHF.
	Chf *float64 `json:"CHF,omitempty"`
	// The rental price of this video in DKK.
	Dkk *float64 `json:"DKK,omitempty"`
	// The rental price of this video in EUR.
	Eur *float64 `json:"EUR,omitempty"`
	// The rental price of this video in GBP.
	Gbp *float64 `json:"GBP,omitempty"`
	// The rental price of this video in JPY.
	Jpy *float64 `json:"JPY,omitempty"`
	// The rental price of this video in KRW.
	Krw *float64 `json:"KRW,omitempty"`
	// The rental price of this video in NOK.
	Nok *float64 `json:"NOK,omitempty"`
	// The rental price of this video in PLN.
	Pln *float64 `json:"PLN,omitempty"`
	// The rental price of this video in SEK.
	Sek *float64 `json:"SEK,omitempty"`
	// The rental price of this video in USD when `type` is `film`, or the rental price of the entire collection in USD when `type` is `series`.
	Usd *float64 `json:"USD,omitempty"`
}

type CreateVodRequestBodyRent struct {
	// Whether the video can be rented. *Required if `buy.active` is false.
	Active *bool `json:"active,omitempty"`
	// The period in which this can be rented for.
	Period *CreateVodRequestBodyRentPeriodEnum `json:"period,omitempty"`
	Price  *CreateVodRequestBodyRentPrice      `json:"price,omitempty"`
}

type CreateVodRequestBodySubscriptionMonthlyPrice struct {
	// The monthly subscription price in USD. *Required if `subscription.active` is true.
	Usd *float64 `json:"USD,omitempty"`
}

type CreateVodRequestBodySubscriptionMonthly struct {
	// Whether monthly subscription is active. *Required if `rent.active` and `buy.active` are false.
	Active *bool                                         `json:"active,omitempty"`
	Price  *CreateVodRequestBodySubscriptionMonthlyPrice `json:"price,omitempty"`
}

type CreateVodRequestBodySubscription struct {
	Monthly *CreateVodRequestBodySubscriptionMonthly `json:"monthly,omitempty"`
}

// CreateVodRequestBodyTypeEnum - The type of On Demand page.
type CreateVodRequestBodyTypeEnum string

const (
	CreateVodRequestBodyTypeEnumFilm   CreateVodRequestBodyTypeEnum = "film"
	CreateVodRequestBodyTypeEnumSeries CreateVodRequestBodyTypeEnum = "series"
)

func (e *CreateVodRequestBodyTypeEnum) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return err
	}
	switch s {
	case "film":
		fallthrough
	case "series":
		*e = CreateVodRequestBodyTypeEnum(s)
		return nil
	default:
		return fmt.Errorf("invalid value for CreateVodRequestBodyTypeEnum: %s", s)
	}
}

type CreateVodRequestBody struct {
	// An array of accepted currencies.
	//
	// Option descriptions:
	//  * `AUD` - Australian Dollar
	//  * `CAD` - Canadian Dollar
	//  * `CHF` - Swiss Franc
	//  * `DKK` - Danish Krone
	//  * `EUR` - Euro
	//  * `GBP` - British Pound
	//  * `JPY` - Japanese Yen
	//  * `KRW` - South Korean Won
	//  * `NOK` - Norwegian Krone
	//  * `PLN` - Polish Zloty
	//  * `SEK` - Swedish Krona
	//  * `USD` - US Dollar
	//
	AcceptedCurrencies *CreateVodRequestBodyAcceptedCurrenciesEnum `json:"accepted_currencies,omitempty"`
	Buy                *CreateVodRequestBodyBuy                    `json:"buy,omitempty"`
	// One or more ratings, either as a comma-separated list or as a JSON array depending on the request format.
	ContentRating CreateVodRequestBodyContentRatingEnum `json:"content_rating"`
	// The description of the On Demand page.
	Description string `json:"description"`
	// The custom domain of the On Demand page.
	DomainLink *string                       `json:"domain_link,omitempty"`
	Episodes   *CreateVodRequestBodyEpisodes `json:"episodes,omitempty"`
	// The custom string to use in this On Demand page's Vimeo URL.
	Link *string `json:"link,omitempty"`
	// The name of the On Demand page.
	Name         string                            `json:"name"`
	Rent         *CreateVodRequestBodyRent         `json:"rent,omitempty"`
	Subscription *CreateVodRequestBodySubscription `json:"subscription,omitempty"`
	// The type of On Demand page.
	Type CreateVodRequestBodyTypeEnum `json:"type"`
}

type CreateVodRequest struct {
	PathParams CreateVodPathParams
	Request    CreateVodRequestBody `request:"mediaType=application/json"`
}

type CreateVodResponse struct {
	ContentType string
	StatusCode  int
	RawResponse *http.Response
	// The On Demand page was created.
	OnDemandPage *shared.OnDemandPage
}
