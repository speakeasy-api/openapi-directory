/*
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

import * as utils from "../internal/utils";
import * as operations from "./models/operations";
import * as shared from "./models/shared";
import { AxiosInstance, AxiosRequestConfig, AxiosResponse } from "axios";

export class Crash {
  _defaultClient: AxiosInstance;
  _securityClient: AxiosInstance;
  _serverURL: string;
  _language: string;
  _sdkVersion: string;
  _genVersion: string;

  constructor(
    defaultClient: AxiosInstance,
    securityClient: AxiosInstance,
    serverURL: string,
    language: string,
    sdkVersion: string,
    genVersion: string
  ) {
    this._defaultClient = defaultClient;
    this._securityClient = securityClient;
    this._serverURL = serverURL;
    this._language = language;
    this._sdkVersion = sdkVersion;
    this._genVersion = genVersion;
  }

  /**
   * Gets a specific group.
   */
  crashGroupsGet(
    req: operations.CrashGroupsGetRequest,
    security: operations.CrashGroupsGetSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.CrashGroupsGetResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CrashGroupsGetRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v0.1/apps/{owner_name}/{app_name}/crash_groups/{crash_group_id}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.CrashGroupsGetSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CrashGroupsGetResponse =
        new operations.CrashGroupsGetResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.crashGroupsGet200ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.CrashGroupsGet200ApplicationJSON
            );
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.crashGroupsGetDefaultApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.CrashGroupsGetDefaultApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Gets a stacktrace for a specific crash.
   */
  crashGroupsGetStacktrace(
    req: operations.CrashGroupsGetStacktraceRequest,
    security: operations.CrashGroupsGetStacktraceSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.CrashGroupsGetStacktraceResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CrashGroupsGetStacktraceRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v0.1/apps/{owner_name}/{app_name}/crash_groups/{crash_group_id}/stacktrace",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.CrashGroupsGetStacktraceSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CrashGroupsGetStacktraceResponse =
        new operations.CrashGroupsGetStacktraceResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.stacktrace = utils.objectToClass(
              httpRes?.data,
              shared.Stacktrace
            );
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.crashGroupsGetStacktraceDefaultApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.CrashGroupsGetStacktraceDefaultApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Gets a list of crash groups and whether the list contains all available groups.
   */
  crashGroupsList(
    req: operations.CrashGroupsListRequest,
    security: operations.CrashGroupsListSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.CrashGroupsListResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CrashGroupsListRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v0.1/apps/{owner_name}/{app_name}/crash_groups",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.CrashGroupsListSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CrashGroupsListResponse =
        new operations.CrashGroupsListResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.crashGroupsList200ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.CrashGroupsList200ApplicationJSON
            );
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.crashGroupsListDefaultApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.CrashGroupsListDefaultApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Updates a group.
   */
  crashGroupsUpdate(
    req: operations.CrashGroupsUpdateRequest,
    security: operations.CrashGroupsUpdateSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.CrashGroupsUpdateResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CrashGroupsUpdateRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v0.1/apps/{owner_name}/{app_name}/crash_groups/{crash_group_id}",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.CrashGroupsUpdateSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "patch",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CrashGroupsUpdateResponse =
        new operations.CrashGroupsUpdateResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.crashGroupsUpdate200ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.CrashGroupsUpdate200ApplicationJSON
            );
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.crashGroupsUpdateDefaultApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.CrashGroupsUpdateDefaultApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Delete a specific crash and related attachments and blobs for an app.
   */
  crashesDelete(
    req: operations.CrashesDeleteRequest,
    security: operations.CrashesDeleteSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.CrashesDeleteResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CrashesDeleteRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v0.1/apps/{owner_name}/{app_name}/crash_groups/{crash_group_id}/crashes/{crash_id}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.CrashesDeleteSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CrashesDeleteResponse =
        new operations.CrashesDeleteResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.crashesDelete200ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.CrashesDelete200ApplicationJSON
            );
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.crashesDeleteDefaultApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.CrashesDeleteDefaultApplicationJSON
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Gets a specific crash for an app.
   */
  crashesGet(
    req: operations.CrashesGetRequest,
    security: operations.CrashesGetSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.CrashesGetResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CrashesGetRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v0.1/apps/{owner_name}/{app_name}/crash_groups/{crash_group_id}/crashes/{crash_id}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.CrashesGetSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CrashesGetResponse =
        new operations.CrashesGetResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.crash = utils.objectToClass(httpRes?.data, shared.Crash);
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.crashesGetDefaultApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.CrashesGetDefaultApplicationJSON
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Gets whether the application has any crashes.
   */
  crashesGetAppCrashesInfo(
    req: operations.CrashesGetAppCrashesInfoRequest,
    security: operations.CrashesGetAppCrashesInfoSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.CrashesGetAppCrashesInfoResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CrashesGetAppCrashesInfoRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v0.1/apps/{owner_name}/{app_name}/crashes_info",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.CrashesGetAppCrashesInfoSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CrashesGetAppCrashesInfoResponse =
        new operations.CrashesGetAppCrashesInfoResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.crashesGetAppCrashesInfo200ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.CrashesGetAppCrashesInfo200ApplicationJSON
              );
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.crashesGetAppCrashesInfoDefaultApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.CrashesGetAppCrashesInfoDefaultApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Gets a list of application versions.
   */
  crashesGetAppVersions(
    req: operations.CrashesGetAppVersionsRequest,
    security: operations.CrashesGetAppVersionsSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.CrashesGetAppVersionsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CrashesGetAppVersionsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v0.1/apps/{owner_name}/{app_name}/versions",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.CrashesGetAppVersionsSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CrashesGetAppVersionsResponse =
        new operations.CrashesGetAppVersionsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.crashesGetAppVersions200ApplicationJSONObjects = [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.crashesGetAppVersions200ApplicationJSONObjects =
              utils.objectToClass(
                httpRes?.data,
                operations.CrashesGetAppVersions200ApplicationJSON,
                resFieldDepth
              );
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.crashesGetAppVersionsDefaultApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.CrashesGetAppVersionsDefaultApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Gets the URI location to download crash attachment.
   */
  crashesGetCrashAttachmentLocation(
    req: operations.CrashesGetCrashAttachmentLocationRequest,
    security: operations.CrashesGetCrashAttachmentLocationSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.CrashesGetCrashAttachmentLocationResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CrashesGetCrashAttachmentLocationRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v0.1/apps/{owner_name}/{app_name}/crashes/{crash_id}/attachments/{attachment_id}/location",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.CrashesGetCrashAttachmentLocationSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CrashesGetCrashAttachmentLocationResponse =
        new operations.CrashesGetCrashAttachmentLocationResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.crashesGetCrashAttachmentLocation200ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.CrashesGetCrashAttachmentLocation200ApplicationJSON
              );
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.crashesGetCrashAttachmentLocationDefaultApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.CrashesGetCrashAttachmentLocationDefaultApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Gets content of the text attachment.
   */
  crashesGetCrashTextAttachmentContent(
    req: operations.CrashesGetCrashTextAttachmentContentRequest,
    security: operations.CrashesGetCrashTextAttachmentContentSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.CrashesGetCrashTextAttachmentContentResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CrashesGetCrashTextAttachmentContentRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v0.1/apps/{owner_name}/{app_name}/crashes/{crash_id}/attachments/{attachment_id}/text",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.CrashesGetCrashTextAttachmentContentSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CrashesGetCrashTextAttachmentContentResponse =
        new operations.CrashesGetCrashTextAttachmentContentResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.crashesGetCrashTextAttachmentContent200ApplicationJSONString =
              JSON.stringify(httpRes?.data);
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.crashesGetCrashTextAttachmentContentDefaultApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.CrashesGetCrashTextAttachmentContentDefaultApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Gets the native log of a specific crash.
   */
  crashesGetNativeCrash(
    req: operations.CrashesGetNativeCrashRequest,
    security: operations.CrashesGetNativeCrashSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.CrashesGetNativeCrashResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CrashesGetNativeCrashRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v0.1/apps/{owner_name}/{app_name}/crash_groups/{crash_group_id}/crashes/{crash_id}/native",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.CrashesGetNativeCrashSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CrashesGetNativeCrashResponse =
        new operations.CrashesGetNativeCrashResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.crashesGetNativeCrash200ApplicationJSONString = JSON.stringify(
              httpRes?.data
            );
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.crashesGetNativeCrashDefaultApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.CrashesGetNativeCrashDefaultApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Gets the native log of a specific crash as a text attachment.
   */
  crashesGetNativeCrashDownload(
    req: operations.CrashesGetNativeCrashDownloadRequest,
    security: operations.CrashesGetNativeCrashDownloadSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.CrashesGetNativeCrashDownloadResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CrashesGetNativeCrashDownloadRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v0.1/apps/{owner_name}/{app_name}/crash_groups/{crash_group_id}/crashes/{crash_id}/native/download",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.CrashesGetNativeCrashDownloadSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CrashesGetNativeCrashDownloadResponse =
        new operations.CrashesGetNativeCrashDownloadResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.crashesGetNativeCrashDownload200ApplicationJSONString =
              JSON.stringify(httpRes?.data);
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.crashesGetNativeCrashDownloadDefaultApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.CrashesGetNativeCrashDownloadDefaultApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Gets the URI location to download json of a specific crash.
   */
  crashesGetRawCrashLocation(
    req: operations.CrashesGetRawCrashLocationRequest,
    security: operations.CrashesGetRawCrashLocationSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.CrashesGetRawCrashLocationResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CrashesGetRawCrashLocationRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v0.1/apps/{owner_name}/{app_name}/crash_groups/{crash_group_id}/crashes/{crash_id}/raw/location",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.CrashesGetRawCrashLocationSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CrashesGetRawCrashLocationResponse =
        new operations.CrashesGetRawCrashLocationResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.crashesGetRawCrashLocation200ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.CrashesGetRawCrashLocation200ApplicationJSON
              );
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.crashesGetRawCrashLocationDefaultApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.CrashesGetRawCrashLocationDefaultApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Gets a stacktrace for a specific crash.
   */
  crashesGetStacktrace(
    req: operations.CrashesGetStacktraceRequest,
    security: operations.CrashesGetStacktraceSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.CrashesGetStacktraceResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CrashesGetStacktraceRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v0.1/apps/{owner_name}/{app_name}/crash_groups/{crash_group_id}/crashes/{crash_id}/stacktrace",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.CrashesGetStacktraceSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CrashesGetStacktraceResponse =
        new operations.CrashesGetStacktraceResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.stacktrace = utils.objectToClass(
              httpRes?.data,
              shared.Stacktrace
            );
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.crashesGetStacktraceDefaultApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.CrashesGetStacktraceDefaultApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Gets all crashes of a group.
   */
  crashesList(
    req: operations.CrashesListRequest,
    security: operations.CrashesListSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.CrashesListResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CrashesListRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v0.1/apps/{owner_name}/{app_name}/crash_groups/{crash_group_id}/crashes",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.CrashesListSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CrashesListResponse =
        new operations.CrashesListResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.crashes = [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.crashes = utils.objectToClass(
              httpRes?.data,
              shared.Crash,
              resFieldDepth
            );
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.crashesListDefaultApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.CrashesListDefaultApplicationJSON
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Gets all attachments for a specific crash.
   */
  crashesListAttachments(
    req: operations.CrashesListAttachmentsRequest,
    security: operations.CrashesListAttachmentsSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.CrashesListAttachmentsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CrashesListAttachmentsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v0.1/apps/{owner_name}/{app_name}/crashes/{crash_id}/attachments",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.CrashesListAttachmentsSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CrashesListAttachmentsResponse =
        new operations.CrashesListAttachmentsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.crashesListAttachments200ApplicationJSONObjects = [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.crashesListAttachments200ApplicationJSONObjects =
              utils.objectToClass(
                httpRes?.data,
                operations.CrashesListAttachments200ApplicationJSON,
                resFieldDepth
              );
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.crashesListAttachmentsDefaultApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.CrashesListAttachmentsDefaultApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Gets missing symbol crash group by its id
   *
   * @remarks
   * Gets missing symbol crash group by its id
   */
  missingSymbolGroupsGet(
    req: operations.MissingSymbolGroupsGetRequest,
    security: operations.MissingSymbolGroupsGetSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.MissingSymbolGroupsGetResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.MissingSymbolGroupsGetRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v0.1/apps/{owner_name}/{app_name}/diagnostics/symbol_groups/{symbol_group_id}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.MissingSymbolGroupsGetSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.MissingSymbolGroupsGetResponse =
        new operations.MissingSymbolGroupsGetResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.missingSymbolGroupsGet200ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.MissingSymbolGroupsGet200ApplicationJSON
              );
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.missingSymbolGroupsGetDefaultApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.MissingSymbolGroupsGetDefaultApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Gets application level statistics for all missing symbol groups
   *
   * @remarks
   * Gets application level statistics for all missing symbol groups
   */
  missingSymbolGroupsInfo(
    req: operations.MissingSymbolGroupsInfoRequest,
    security: operations.MissingSymbolGroupsInfoSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.MissingSymbolGroupsInfoResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.MissingSymbolGroupsInfoRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v0.1/apps/{owner_name}/{app_name}/diagnostics/symbol_groups_info",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.MissingSymbolGroupsInfoSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.MissingSymbolGroupsInfoResponse =
        new operations.MissingSymbolGroupsInfoResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.missingSymbolGroupsInfo200ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.MissingSymbolGroupsInfo200ApplicationJSON
              );
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.missingSymbolGroupsInfoDefaultApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.MissingSymbolGroupsInfoDefaultApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Gets top N (ordered by crash count) of crash groups by missing symbol
   *
   * @remarks
   * Gets top N (ordered by crash count) of crash groups by missing symbol
   */
  missingSymbolGroupsList(
    req: operations.MissingSymbolGroupsListRequest,
    security: operations.MissingSymbolGroupsListSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.MissingSymbolGroupsListResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.MissingSymbolGroupsListRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v0.1/apps/{owner_name}/{app_name}/diagnostics/symbol_groups",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.MissingSymbolGroupsListSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.MissingSymbolGroupsListResponse =
        new operations.MissingSymbolGroupsListResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.missingSymbolGroupsList200ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.MissingSymbolGroupsList200ApplicationJSON
              );
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.missingSymbolGroupsListDefaultApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.MissingSymbolGroupsListDefaultApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Commits or aborts the symbol upload process for a new set of symbols for the specified application
   */
  symbolUploadsComplete(
    req: operations.SymbolUploadsCompleteRequest,
    security: operations.SymbolUploadsCompleteSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.SymbolUploadsCompleteResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.SymbolUploadsCompleteRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v0.1/apps/{owner_name}/{app_name}/symbol_uploads/{symbol_upload_id}",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.SymbolUploadsCompleteSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "patch",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.SymbolUploadsCompleteResponse =
        new operations.SymbolUploadsCompleteResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.symbolUploadsComplete200ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.SymbolUploadsComplete200ApplicationJSON
              );
          }
          break;
        case httpRes?.status == 400:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.symbolUploadsComplete400ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.SymbolUploadsComplete400ApplicationJSON
              );
          }
          break;
        case httpRes?.status == 403:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.symbolUploadsComplete403ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.SymbolUploadsComplete403ApplicationJSON
              );
          }
          break;
        case httpRes?.status == 500:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.symbolUploadsComplete500ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.SymbolUploadsComplete500ApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Begins the symbol upload process for a new set of symbols for the specified application
   */
  symbolUploadsCreate(
    req: operations.SymbolUploadsCreateRequest,
    security: operations.SymbolUploadsCreateSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.SymbolUploadsCreateResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.SymbolUploadsCreateRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v0.1/apps/{owner_name}/{app_name}/symbol_uploads",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.SymbolUploadsCreateSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.SymbolUploadsCreateResponse =
        new operations.SymbolUploadsCreateResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.symbolUploadsCreate200ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.SymbolUploadsCreate200ApplicationJSON
              );
          }
          break;
        case httpRes?.status == 400:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.symbolUploadsCreate400ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.SymbolUploadsCreate400ApplicationJSON
              );
          }
          break;
        case httpRes?.status == 403:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.symbolUploadsCreate403ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.SymbolUploadsCreate403ApplicationJSON
              );
          }
          break;
        case httpRes?.status == 500:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.symbolUploadsCreate500ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.SymbolUploadsCreate500ApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Deletes a symbol upload by id for the specified application
   */
  symbolUploadsDelete(
    req: operations.SymbolUploadsDeleteRequest,
    security: operations.SymbolUploadsDeleteSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.SymbolUploadsDeleteResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.SymbolUploadsDeleteRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v0.1/apps/{owner_name}/{app_name}/symbol_uploads/{symbol_upload_id}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.SymbolUploadsDeleteSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.SymbolUploadsDeleteResponse =
        new operations.SymbolUploadsDeleteResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.symbolUploadsDelete200ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.SymbolUploadsDelete200ApplicationJSON
              );
          }
          break;
        case httpRes?.status == 403:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.symbolUploadsDelete403ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.SymbolUploadsDelete403ApplicationJSON
              );
          }
          break;
        case httpRes?.status == 404:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.symbolUploadsDelete404ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.SymbolUploadsDelete404ApplicationJSON
              );
          }
          break;
        case httpRes?.status == 500:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.symbolUploadsDelete500ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.SymbolUploadsDelete500ApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Gets a symbol upload by id for the specified application
   */
  symbolUploadsGet(
    req: operations.SymbolUploadsGetRequest,
    security: operations.SymbolUploadsGetSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.SymbolUploadsGetResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.SymbolUploadsGetRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v0.1/apps/{owner_name}/{app_name}/symbol_uploads/{symbol_upload_id}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.SymbolUploadsGetSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.SymbolUploadsGetResponse =
        new operations.SymbolUploadsGetResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.symbolUploadsGet200ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.SymbolUploadsGet200ApplicationJSON
            );
          }
          break;
        case httpRes?.status == 403:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.symbolUploadsGet403ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.SymbolUploadsGet403ApplicationJSON
            );
          }
          break;
        case httpRes?.status == 404:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.symbolUploadsGet404ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.SymbolUploadsGet404ApplicationJSON
            );
          }
          break;
        case httpRes?.status == 500:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.symbolUploadsGet500ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.SymbolUploadsGet500ApplicationJSON
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Gets the URL to download the symbol upload
   */
  symbolUploadsGetLocation(
    req: operations.SymbolUploadsGetLocationRequest,
    security: operations.SymbolUploadsGetLocationSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.SymbolUploadsGetLocationResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.SymbolUploadsGetLocationRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v0.1/apps/{owner_name}/{app_name}/symbol_uploads/{symbol_upload_id}/location",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.SymbolUploadsGetLocationSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.SymbolUploadsGetLocationResponse =
        new operations.SymbolUploadsGetLocationResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.symbolUploadsGetLocation200ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.SymbolUploadsGetLocation200ApplicationJSON
              );
          }
          break;
        case httpRes?.status == 403:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.symbolUploadsGetLocation403ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.SymbolUploadsGetLocation403ApplicationJSON
              );
          }
          break;
        case httpRes?.status == 404:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.symbolUploadsGetLocation404ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.SymbolUploadsGetLocation404ApplicationJSON
              );
          }
          break;
        case httpRes?.status == 500:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.symbolUploadsGetLocation500ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.SymbolUploadsGetLocation500ApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Gets a list of all uploads for the specified application
   */
  symbolUploadsList(
    req: operations.SymbolUploadsListRequest,
    security: operations.SymbolUploadsListSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.SymbolUploadsListResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.SymbolUploadsListRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v0.1/apps/{owner_name}/{app_name}/symbol_uploads",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.SymbolUploadsListSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.SymbolUploadsListResponse =
        new operations.SymbolUploadsListResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.symbolUploadsList200ApplicationJSONObjects = [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.symbolUploadsList200ApplicationJSONObjects =
              utils.objectToClass(
                httpRes?.data,
                operations.SymbolUploadsList200ApplicationJSON,
                resFieldDepth
              );
          }
          break;
        case httpRes?.status == 403:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.symbolUploadsList403ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.SymbolUploadsList403ApplicationJSON
            );
          }
          break;
        case httpRes?.status == 500:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.symbolUploadsList500ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.SymbolUploadsList500ApplicationJSON
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Returns a particular symbol by id (uuid) for the provided application
   */
  symbolsGet(
    req: operations.SymbolsGetRequest,
    security: operations.SymbolsGetSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.SymbolsGetResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.SymbolsGetRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v0.1/apps/{owner_name}/{app_name}/symbols/{symbol_id}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.SymbolsGetSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.SymbolsGetResponse =
        new operations.SymbolsGetResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.symbolsGet200ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.SymbolsGet200ApplicationJSON
            );
          }
          break;
        case httpRes?.status == 403:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.symbolsGet403ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.SymbolsGet403ApplicationJSON
            );
          }
          break;
        case httpRes?.status == 404:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.symbolsGet404ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.SymbolsGet404ApplicationJSON
            );
          }
          break;
        case httpRes?.status == 500:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.symbolsGet500ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.SymbolsGet500ApplicationJSON
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Gets the URL to download the symbol
   */
  symbolsGetLocation(
    req: operations.SymbolsGetLocationRequest,
    security: operations.SymbolsGetLocationSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.SymbolsGetLocationResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.SymbolsGetLocationRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v0.1/apps/{owner_name}/{app_name}/symbols/{symbol_id}/location",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.SymbolsGetLocationSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.SymbolsGetLocationResponse =
        new operations.SymbolsGetLocationResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.symbolsGetLocation200ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.SymbolsGetLocation200ApplicationJSON
              );
          }
          break;
        case httpRes?.status == 403:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.symbolsGetLocation403ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.SymbolsGetLocation403ApplicationJSON
              );
          }
          break;
        case httpRes?.status == 404:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.symbolsGetLocation404ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.SymbolsGetLocation404ApplicationJSON
              );
          }
          break;
        case httpRes?.status == 500:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.symbolsGetLocation500ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.SymbolsGetLocation500ApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Returns a particular symbol by id (uuid) for the provided application
   */
  symbolsGetStatus(
    req: operations.SymbolsGetStatusRequest,
    security: operations.SymbolsGetStatusSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.SymbolsGetStatusResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.SymbolsGetStatusRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v0.1/apps/{owner_name}/{app_name}/symbols/{symbol_id}/status",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.SymbolsGetStatusSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.SymbolsGetStatusResponse =
        new operations.SymbolsGetStatusResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.symbolsGetStatus200ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.SymbolsGetStatus200ApplicationJSON
            );
          }
          break;
        case httpRes?.status == 403:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.symbolsGetStatus403ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.SymbolsGetStatus403ApplicationJSON
            );
          }
          break;
        case httpRes?.status == 404:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.symbolsGetStatus404ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.SymbolsGetStatus404ApplicationJSON
            );
          }
          break;
        case httpRes?.status == 500:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.symbolsGetStatus500ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.SymbolsGetStatus500ApplicationJSON
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Marks a symbol by id (uuid) as ignored
   */
  symbolsIgnore(
    req: operations.SymbolsIgnoreRequest,
    security: operations.SymbolsIgnoreSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.SymbolsIgnoreResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.SymbolsIgnoreRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v0.1/apps/{owner_name}/{app_name}/symbols/{symbol_id}/ignore",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.SymbolsIgnoreSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "post",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.SymbolsIgnoreResponse =
        new operations.SymbolsIgnoreResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.symbolsIgnore200ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.SymbolsIgnore200ApplicationJSON
            );
          }
          break;
        case httpRes?.status == 403:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.symbolsIgnore403ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.SymbolsIgnore403ApplicationJSON
            );
          }
          break;
        case httpRes?.status == 404:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.symbolsIgnore404ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.SymbolsIgnore404ApplicationJSON
            );
          }
          break;
        case httpRes?.status == 500:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.symbolsIgnore500ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.SymbolsIgnore500ApplicationJSON
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Returns the list of all symbols for the provided application
   */
  symbolsList(
    req: operations.SymbolsListRequest,
    security: operations.SymbolsListSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.SymbolsListResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.SymbolsListRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v0.1/apps/{owner_name}/{app_name}/symbols",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.SymbolsListSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.SymbolsListResponse =
        new operations.SymbolsListResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.symbolsList200ApplicationJSONObjects = [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.symbolsList200ApplicationJSONObjects = utils.objectToClass(
              httpRes?.data,
              operations.SymbolsList200ApplicationJSON,
              resFieldDepth
            );
          }
          break;
        case httpRes?.status == 403:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.symbolsList403ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.SymbolsList403ApplicationJSON
            );
          }
          break;
        case httpRes?.status == 500:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.symbolsList500ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.SymbolsList500ApplicationJSON
            );
          }
          break;
      }

      return res;
    });
  }
}
