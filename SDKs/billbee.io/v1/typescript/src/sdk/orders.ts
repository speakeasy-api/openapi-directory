/*
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

import * as utils from "../internal/utils";
import * as operations from "./models/operations";
import * as shared from "./models/shared";
import { AxiosInstance, AxiosRequestConfig, AxiosResponse } from "axios";

export class Orders {
  _defaultClient: AxiosInstance;
  _securityClient: AxiosInstance;
  _serverURL: string;
  _language: string;
  _sdkVersion: string;
  _genVersion: string;

  constructor(
    defaultClient: AxiosInstance,
    securityClient: AxiosInstance,
    serverURL: string,
    language: string,
    sdkVersion: string,
    genVersion: string
  ) {
    this._defaultClient = defaultClient;
    this._securityClient = securityClient;
    this._serverURL = serverURL;
    this._language = language;
    this._sdkVersion = sdkVersion;
    this._genVersion = genVersion;
  }

  layoutApiGetList(
    config?: AxiosRequestConfig
  ): Promise<operations.LayoutApiGetListResponse> {
    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/api/v1/layouts";

    const client: AxiosInstance = this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.LayoutApiGetListResponse =
        new operations.LayoutApiGetListResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.rechnungsdruckWebAppControllersAPIAPIResultSystemCollectionsGenericListBillbeeInterfacesBillbeeAPIModelsLayoutTemplate =
              utils.objectToClass(
                httpRes?.data,
                shared.RechnungsdruckWebAppControllersAPIAPIResultSystemCollectionsGenericListBillbeeInterfacesBillbeeAPIModelsLayoutTemplate
              );
          }
          if (utils.matchContentType(contentType, `text/json`)) {
            res.rechnungsdruckWebAppControllersAPIAPIResultSystemCollectionsGenericListBillbeeInterfacesBillbeeAPIModelsLayoutTemplate =
              utils.objectToClass(
                httpRes?.data,
                shared.RechnungsdruckWebAppControllersAPIAPIResultSystemCollectionsGenericListBillbeeInterfacesBillbeeAPIModelsLayoutTemplate
              );
          }
          if (utils.matchContentType(contentType, `application/xml`)) {
            const resBody: string = JSON.stringify(httpRes?.data, null, 0);
            const out: Uint8Array = new Uint8Array(resBody.length);
            for (let i = 0; i < resBody.length; i++)
              out[i] = resBody.charCodeAt(i);
            res.body = out;
          }
          if (utils.matchContentType(contentType, `text/xml`)) {
            const resBody: string = JSON.stringify(httpRes?.data, null, 0);
            const out: Uint8Array = new Uint8Array(resBody.length);
            for (let i = 0; i < resBody.length; i++)
              out[i] = resBody.charCodeAt(i);
            res.body = out;
          }
          break;
      }

      return res;
    });
  }

  /**
   * Add a shipment to a given order
   */
  orderApiAddShipmentForm(
    req: operations.OrderApiAddShipmentFormRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.OrderApiAddShipmentFormResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.OrderApiAddShipmentFormRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/api/v1/orders/{id}/shipment",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "rechnungsdruckWebAppControllersApiApiAddShipmentToOrderModel",
        "form"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.OrderApiAddShipmentFormResponse =
        new operations.OrderApiAddShipmentFormResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.orderApiAddShipmentForm200ApplicationJSONObject =
              utils.objectToClass(httpRes?.data);
          }
          if (utils.matchContentType(contentType, `text/json`)) {
            res.orderApiAddShipmentForm200TextJSONObject = utils.objectToClass(
              httpRes?.data
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Add a shipment to a given order
   */
  orderApiAddShipmentJson(
    req: operations.OrderApiAddShipmentJsonRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.OrderApiAddShipmentJsonResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.OrderApiAddShipmentJsonRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/api/v1/orders/{id}/shipment",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "rechnungsdruckWebAppControllersApiApiAddShipmentToOrderModel",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.OrderApiAddShipmentJsonResponse =
        new operations.OrderApiAddShipmentJsonResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.orderApiAddShipmentJSON200ApplicationJSONObject =
              utils.objectToClass(httpRes?.data);
          }
          if (utils.matchContentType(contentType, `text/json`)) {
            res.orderApiAddShipmentJSON200TextJSONObject = utils.objectToClass(
              httpRes?.data
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Add a shipment to a given order
   */
  orderApiAddShipmentRaw(
    req: operations.OrderApiAddShipmentRawRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.OrderApiAddShipmentRawResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.OrderApiAddShipmentRawRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/api/v1/orders/{id}/shipment",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "raw"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.OrderApiAddShipmentRawResponse =
        new operations.OrderApiAddShipmentRawResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.orderApiAddShipmentRaw200ApplicationJSONObject =
              utils.objectToClass(httpRes?.data);
          }
          if (utils.matchContentType(contentType, `text/json`)) {
            res.orderApiAddShipmentRaw200TextJSONObject = utils.objectToClass(
              httpRes?.data
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Create an delivery note for an existing order. This request is extra throttled by order and api key to a maximum of 1 per 5 minutes.
   */
  orderApiCreateDeliveryNote(
    req: operations.OrderApiCreateDeliveryNoteRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.OrderApiCreateDeliveryNoteResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.OrderApiCreateDeliveryNoteRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/api/v1/orders/CreateDeliveryNote/{id}",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "post",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.OrderApiCreateDeliveryNoteResponse =
        new operations.OrderApiCreateDeliveryNoteResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.orderApiCreateDeliveryNote200ApplicationJSONObject =
              utils.objectToClass(httpRes?.data);
          }
          if (utils.matchContentType(contentType, `text/json`)) {
            res.orderApiCreateDeliveryNote200TextJSONObject =
              utils.objectToClass(httpRes?.data);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Create an invoice for an existing order. This request is extra throttled by order and api key to a maximum of 1 per 5 minutes.
   */
  orderApiCreateInvoice(
    req: operations.OrderApiCreateInvoiceRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.OrderApiCreateInvoiceResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.OrderApiCreateInvoiceRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/api/v1/orders/CreateInvoice/{id}",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "post",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.OrderApiCreateInvoiceResponse =
        new operations.OrderApiCreateInvoiceResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.orderApiCreateInvoice200ApplicationJSONObject =
              utils.objectToClass(httpRes?.data);
          }
          if (utils.matchContentType(contentType, `text/json`)) {
            res.orderApiCreateInvoice200TextJSONObject = utils.objectToClass(
              httpRes?.data
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Find a single order by its external id (order number)
   */
  orderApiFind(
    req: operations.OrderApiFindRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.OrderApiFindResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.OrderApiFindRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/api/v1/orders/find/{id}/{partner}",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.OrderApiFindResponse =
        new operations.OrderApiFindResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.orderApiFind200ApplicationJSONObject = utils.objectToClass(
              httpRes?.data
            );
          }
          if (utils.matchContentType(contentType, `text/json`)) {
            res.orderApiFind200TextJSONObject = utils.objectToClass(
              httpRes?.data
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Get a single order by its internal billbee id. This request is throttled to 6 calls per order in one minute
   */
  orderApiGet(
    req: operations.OrderApiGetRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.OrderApiGetResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.OrderApiGetRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(baseURL, "/api/v1/orders/{id}", req);

    const client: AxiosInstance = this._defaultClient;

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.OrderApiGetResponse =
        new operations.OrderApiGetResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.rechnungsdruckWebAppControllersAPIAPIResultBillbeeInterfacesBillbeeAPIModelOrder =
              utils.objectToClass(
                httpRes?.data,
                shared.RechnungsdruckWebAppControllersAPIAPIResultBillbeeInterfacesBillbeeAPIModelOrder
              );
          }
          if (utils.matchContentType(contentType, `text/json`)) {
            res.rechnungsdruckWebAppControllersAPIAPIResultBillbeeInterfacesBillbeeAPIModelOrder =
              utils.objectToClass(
                httpRes?.data,
                shared.RechnungsdruckWebAppControllersAPIAPIResultBillbeeInterfacesBillbeeAPIModelOrder
              );
          }
          if (utils.matchContentType(contentType, `application/xml`)) {
            const resBody: string = JSON.stringify(httpRes?.data, null, 0);
            const out: Uint8Array = new Uint8Array(resBody.length);
            for (let i = 0; i < resBody.length; i++)
              out[i] = resBody.charCodeAt(i);
            res.body = out;
          }
          if (utils.matchContentType(contentType, `text/xml`)) {
            const resBody: string = JSON.stringify(httpRes?.data, null, 0);
            const out: Uint8Array = new Uint8Array(resBody.length);
            for (let i = 0; i < resBody.length; i++)
              out[i] = resBody.charCodeAt(i);
            res.body = out;
          }
          break;
      }

      return res;
    });
  }

  /**
   * Get a single order by its external order number
   */
  orderApiGetByExtRef(
    req: operations.OrderApiGetByExtRefRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.OrderApiGetByExtRefResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.OrderApiGetByExtRefRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/api/v1/orders/findbyextref/{extRef}",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.OrderApiGetByExtRefResponse =
        new operations.OrderApiGetByExtRefResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.rechnungsdruckWebAppControllersAPIAPIResultBillbeeInterfacesBillbeeAPIModelOrder =
              utils.objectToClass(
                httpRes?.data,
                shared.RechnungsdruckWebAppControllersAPIAPIResultBillbeeInterfacesBillbeeAPIModelOrder
              );
          }
          if (utils.matchContentType(contentType, `text/json`)) {
            res.rechnungsdruckWebAppControllersAPIAPIResultBillbeeInterfacesBillbeeAPIModelOrder =
              utils.objectToClass(
                httpRes?.data,
                shared.RechnungsdruckWebAppControllersAPIAPIResultBillbeeInterfacesBillbeeAPIModelOrder
              );
          }
          if (utils.matchContentType(contentType, `application/xml`)) {
            const resBody: string = JSON.stringify(httpRes?.data, null, 0);
            const out: Uint8Array = new Uint8Array(resBody.length);
            for (let i = 0; i < resBody.length; i++)
              out[i] = resBody.charCodeAt(i);
            res.body = out;
          }
          if (utils.matchContentType(contentType, `text/xml`)) {
            const resBody: string = JSON.stringify(httpRes?.data, null, 0);
            const out: Uint8Array = new Uint8Array(resBody.length);
            for (let i = 0; i < resBody.length; i++)
              out[i] = resBody.charCodeAt(i);
            res.body = out;
          }
          break;
      }

      return res;
    });
  }

  /**
   * Get a list of all invoices optionally filtered by date. This request ist throttled to 1 per 1 minute for same page and minInvoiceDate
   */
  orderApiGetInvoiceList(
    req: operations.OrderApiGetInvoiceListRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.OrderApiGetInvoiceListResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.OrderApiGetInvoiceListRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/api/v1/orders/invoices";

    const client: AxiosInstance = this._defaultClient;

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.OrderApiGetInvoiceListResponse =
        new operations.OrderApiGetInvoiceListResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.orderApiGetInvoiceList200ApplicationJSONObject =
              utils.objectToClass(httpRes?.data);
          }
          if (utils.matchContentType(contentType, `text/json`)) {
            res.orderApiGetInvoiceList200TextJSONObject = utils.objectToClass(
              httpRes?.data
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Get a list of all orders optionally filtered by date
   */
  orderApiGetList(
    req: operations.OrderApiGetListRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.OrderApiGetListResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.OrderApiGetListRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/api/v1/orders";

    const client: AxiosInstance = this._defaultClient;

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.OrderApiGetListResponse =
        new operations.OrderApiGetListResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.rechnungsdruckWebAppControllersAPIAPIPagedResultSystemCollectionsGenericListBillbeeInterfacesBillbeeAPIModelOrder =
              utils.objectToClass(
                httpRes?.data,
                shared.RechnungsdruckWebAppControllersAPIAPIPagedResultSystemCollectionsGenericListBillbeeInterfacesBillbeeAPIModelOrder
              );
          }
          if (utils.matchContentType(contentType, `text/json`)) {
            res.rechnungsdruckWebAppControllersAPIAPIPagedResultSystemCollectionsGenericListBillbeeInterfacesBillbeeAPIModelOrder =
              utils.objectToClass(
                httpRes?.data,
                shared.RechnungsdruckWebAppControllersAPIAPIPagedResultSystemCollectionsGenericListBillbeeInterfacesBillbeeAPIModelOrder
              );
          }
          if (utils.matchContentType(contentType, `application/xml`)) {
            const resBody: string = JSON.stringify(httpRes?.data, null, 0);
            const out: Uint8Array = new Uint8Array(resBody.length);
            for (let i = 0; i < resBody.length; i++)
              out[i] = resBody.charCodeAt(i);
            res.body = out;
          }
          if (utils.matchContentType(contentType, `text/xml`)) {
            const resBody: string = JSON.stringify(httpRes?.data, null, 0);
            const out: Uint8Array = new Uint8Array(resBody.length);
            for (let i = 0; i < resBody.length; i++)
              out[i] = resBody.charCodeAt(i);
            res.body = out;
          }
          break;
      }

      return res;
    });
  }

  /**
   * Returns a list of fields which can be updated with the orders/{id} patch call
   */
  orderApiGetPatchableFields(
    config?: AxiosRequestConfig
  ): Promise<operations.OrderApiGetPatchableFieldsResponse> {
    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/api/v1/orders/PatchableFields";

    const client: AxiosInstance = this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.OrderApiGetPatchableFieldsResponse =
        new operations.OrderApiGetPatchableFieldsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.orderApiGetPatchableFields200ApplicationJSONObject =
              utils.objectToClass(httpRes?.data);
          }
          if (utils.matchContentType(contentType, `text/json`)) {
            res.orderApiGetPatchableFields200TextJSONObject =
              utils.objectToClass(httpRes?.data);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Parses a text and replaces all placeholders
   */
  orderApiParsePlaceholdersForm(
    req: operations.OrderApiParsePlaceholdersFormRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.OrderApiParsePlaceholdersFormResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.OrderApiParsePlaceholdersFormRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/api/v1/orders/{id}/parse-placeholders",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "rechnungsdruckWebAppControllersApiOrderApiControllerParseTextContainer",
        "form"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.OrderApiParsePlaceholdersFormResponse =
        new operations.OrderApiParsePlaceholdersFormResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.orderApiParsePlaceholdersForm200ApplicationJSONObject =
              utils.objectToClass(httpRes?.data);
          }
          if (utils.matchContentType(contentType, `text/json`)) {
            res.orderApiParsePlaceholdersForm200TextJSONObject =
              utils.objectToClass(httpRes?.data);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Parses a text and replaces all placeholders
   */
  orderApiParsePlaceholdersJson(
    req: operations.OrderApiParsePlaceholdersJsonRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.OrderApiParsePlaceholdersJsonResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.OrderApiParsePlaceholdersJsonRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/api/v1/orders/{id}/parse-placeholders",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "rechnungsdruckWebAppControllersApiOrderApiControllerParseTextContainer",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.OrderApiParsePlaceholdersJsonResponse =
        new operations.OrderApiParsePlaceholdersJsonResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.orderApiParsePlaceholdersJSON200ApplicationJSONObject =
              utils.objectToClass(httpRes?.data);
          }
          if (utils.matchContentType(contentType, `text/json`)) {
            res.orderApiParsePlaceholdersJSON200TextJSONObject =
              utils.objectToClass(httpRes?.data);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Parses a text and replaces all placeholders
   */
  orderApiParsePlaceholdersRaw(
    req: operations.OrderApiParsePlaceholdersRawRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.OrderApiParsePlaceholdersRawResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.OrderApiParsePlaceholdersRawRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/api/v1/orders/{id}/parse-placeholders",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "raw"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.OrderApiParsePlaceholdersRawResponse =
        new operations.OrderApiParsePlaceholdersRawResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.orderApiParsePlaceholdersRaw200ApplicationJSONObject =
              utils.objectToClass(httpRes?.data);
          }
          if (utils.matchContentType(contentType, `text/json`)) {
            res.orderApiParsePlaceholdersRaw200TextJSONObject =
              utils.objectToClass(httpRes?.data);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Updates one or more fields of an order
   */
  orderApiPatchOrder(
    req: operations.OrderApiPatchOrderRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.OrderApiPatchOrderResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.OrderApiPatchOrderRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(baseURL, "/api/v1/orders/{id}", req);

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "patch",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.OrderApiPatchOrderResponse =
        new operations.OrderApiPatchOrderResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.rechnungsdruckWebAppControllersAPIAPIResultBillbeeInterfacesBillbeeAPIModelOrder =
              utils.objectToClass(
                httpRes?.data,
                shared.RechnungsdruckWebAppControllersAPIAPIResultBillbeeInterfacesBillbeeAPIModelOrder
              );
          }
          if (utils.matchContentType(contentType, `text/json`)) {
            res.rechnungsdruckWebAppControllersAPIAPIResultBillbeeInterfacesBillbeeAPIModelOrder =
              utils.objectToClass(
                httpRes?.data,
                shared.RechnungsdruckWebAppControllersAPIAPIResultBillbeeInterfacesBillbeeAPIModelOrder
              );
          }
          if (utils.matchContentType(contentType, `application/xml`)) {
            const resBody: string = JSON.stringify(httpRes?.data, null, 0);
            const out: Uint8Array = new Uint8Array(resBody.length);
            for (let i = 0; i < resBody.length; i++)
              out[i] = resBody.charCodeAt(i);
            res.body = out;
          }
          if (utils.matchContentType(contentType, `text/xml`)) {
            const resBody: string = JSON.stringify(httpRes?.data, null, 0);
            const out: Uint8Array = new Uint8Array(resBody.length);
            for (let i = 0; i < resBody.length; i++)
              out[i] = resBody.charCodeAt(i);
            res.body = out;
          }
          break;
      }

      return res;
    });
  }

  /**
   * Creates a new order in the Billbee account
   *
   * @remarks
   * To create an order POST an JSON object to the orders endpoint with the shown properties.
   * Not all properties are required.
   */
  orderApiPostNewOrderForm(
    req: operations.OrderApiPostNewOrderFormRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.OrderApiPostNewOrderFormResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.OrderApiPostNewOrderFormRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/api/v1/orders";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "billbeeInterfacesBillbeeAPIModelOrderInput",
        "form"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url + queryParams,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.OrderApiPostNewOrderFormResponse =
        new operations.OrderApiPostNewOrderFormResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.rechnungsdruckWebAppControllersAPIAPIResultBillbeeInterfacesBillbeeAPIModelOrder =
              utils.objectToClass(
                httpRes?.data,
                shared.RechnungsdruckWebAppControllersAPIAPIResultBillbeeInterfacesBillbeeAPIModelOrder
              );
          }
          if (utils.matchContentType(contentType, `text/json`)) {
            res.rechnungsdruckWebAppControllersAPIAPIResultBillbeeInterfacesBillbeeAPIModelOrder =
              utils.objectToClass(
                httpRes?.data,
                shared.RechnungsdruckWebAppControllersAPIAPIResultBillbeeInterfacesBillbeeAPIModelOrder
              );
          }
          if (utils.matchContentType(contentType, `application/xml`)) {
            const resBody: string = JSON.stringify(httpRes?.data, null, 0);
            const out: Uint8Array = new Uint8Array(resBody.length);
            for (let i = 0; i < resBody.length; i++)
              out[i] = resBody.charCodeAt(i);
            res.body = out;
          }
          if (utils.matchContentType(contentType, `text/xml`)) {
            const resBody: string = JSON.stringify(httpRes?.data, null, 0);
            const out: Uint8Array = new Uint8Array(resBody.length);
            for (let i = 0; i < resBody.length; i++)
              out[i] = resBody.charCodeAt(i);
            res.body = out;
          }
          break;
        case [400, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Creates a new order in the Billbee account
   *
   * @remarks
   * To create an order POST an JSON object to the orders endpoint with the shown properties.
   * Not all properties are required.
   */
  orderApiPostNewOrderJson(
    req: operations.OrderApiPostNewOrderJsonRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.OrderApiPostNewOrderJsonResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.OrderApiPostNewOrderJsonRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/api/v1/orders";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "billbeeInterfacesBillbeeAPIModelOrderInput",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url + queryParams,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.OrderApiPostNewOrderJsonResponse =
        new operations.OrderApiPostNewOrderJsonResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.rechnungsdruckWebAppControllersAPIAPIResultBillbeeInterfacesBillbeeAPIModelOrder =
              utils.objectToClass(
                httpRes?.data,
                shared.RechnungsdruckWebAppControllersAPIAPIResultBillbeeInterfacesBillbeeAPIModelOrder
              );
          }
          if (utils.matchContentType(contentType, `text/json`)) {
            res.rechnungsdruckWebAppControllersAPIAPIResultBillbeeInterfacesBillbeeAPIModelOrder =
              utils.objectToClass(
                httpRes?.data,
                shared.RechnungsdruckWebAppControllersAPIAPIResultBillbeeInterfacesBillbeeAPIModelOrder
              );
          }
          if (utils.matchContentType(contentType, `application/xml`)) {
            const resBody: string = JSON.stringify(httpRes?.data, null, 0);
            const out: Uint8Array = new Uint8Array(resBody.length);
            for (let i = 0; i < resBody.length; i++)
              out[i] = resBody.charCodeAt(i);
            res.body = out;
          }
          if (utils.matchContentType(contentType, `text/xml`)) {
            const resBody: string = JSON.stringify(httpRes?.data, null, 0);
            const out: Uint8Array = new Uint8Array(resBody.length);
            for (let i = 0; i < resBody.length; i++)
              out[i] = resBody.charCodeAt(i);
            res.body = out;
          }
          break;
        case [400, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Creates a new order in the Billbee account
   *
   * @remarks
   * To create an order POST an JSON object to the orders endpoint with the shown properties.
   * Not all properties are required.
   */
  orderApiPostNewOrderRaw(
    req: operations.OrderApiPostNewOrderRawRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.OrderApiPostNewOrderRawResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.OrderApiPostNewOrderRawRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/api/v1/orders";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "raw"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url + queryParams,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.OrderApiPostNewOrderRawResponse =
        new operations.OrderApiPostNewOrderRawResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.rechnungsdruckWebAppControllersAPIAPIResultBillbeeInterfacesBillbeeAPIModelOrder =
              utils.objectToClass(
                httpRes?.data,
                shared.RechnungsdruckWebAppControllersAPIAPIResultBillbeeInterfacesBillbeeAPIModelOrder
              );
          }
          if (utils.matchContentType(contentType, `text/json`)) {
            res.rechnungsdruckWebAppControllersAPIAPIResultBillbeeInterfacesBillbeeAPIModelOrder =
              utils.objectToClass(
                httpRes?.data,
                shared.RechnungsdruckWebAppControllersAPIAPIResultBillbeeInterfacesBillbeeAPIModelOrder
              );
          }
          if (utils.matchContentType(contentType, `application/xml`)) {
            const resBody: string = JSON.stringify(httpRes?.data, null, 0);
            const out: Uint8Array = new Uint8Array(resBody.length);
            for (let i = 0; i < resBody.length; i++)
              out[i] = resBody.charCodeAt(i);
            res.body = out;
          }
          if (utils.matchContentType(contentType, `text/xml`)) {
            const resBody: string = JSON.stringify(httpRes?.data, null, 0);
            const out: Uint8Array = new Uint8Array(resBody.length);
            for (let i = 0; i < resBody.length; i++)
              out[i] = resBody.charCodeAt(i);
            res.body = out;
          }
          break;
        case [400, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Sends a message to the buyer
   */
  orderApiSendMessageForm(
    req: operations.OrderApiSendMessageFormRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.OrderApiSendMessageFormResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.OrderApiSendMessageFormRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/api/v1/orders/{id}/send-message",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "rechnungsdruckWebAppControllersApiOrderApiControllerSendMessageModel",
        "form"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.OrderApiSendMessageFormResponse =
        new operations.OrderApiSendMessageFormResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.orderApiSendMessageForm200ApplicationJSONObject =
              utils.objectToClass(httpRes?.data);
          }
          if (utils.matchContentType(contentType, `text/json`)) {
            res.orderApiSendMessageForm200TextJSONObject = utils.objectToClass(
              httpRes?.data
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Sends a message to the buyer
   */
  orderApiSendMessageJson(
    req: operations.OrderApiSendMessageJsonRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.OrderApiSendMessageJsonResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.OrderApiSendMessageJsonRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/api/v1/orders/{id}/send-message",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "rechnungsdruckWebAppControllersApiOrderApiControllerSendMessageModel",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.OrderApiSendMessageJsonResponse =
        new operations.OrderApiSendMessageJsonResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.orderApiSendMessageJSON200ApplicationJSONObject =
              utils.objectToClass(httpRes?.data);
          }
          if (utils.matchContentType(contentType, `text/json`)) {
            res.orderApiSendMessageJSON200TextJSONObject = utils.objectToClass(
              httpRes?.data
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Sends a message to the buyer
   */
  orderApiSendMessageRaw(
    req: operations.OrderApiSendMessageRawRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.OrderApiSendMessageRawResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.OrderApiSendMessageRawRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/api/v1/orders/{id}/send-message",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "raw"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.OrderApiSendMessageRawResponse =
        new operations.OrderApiSendMessageRawResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.orderApiSendMessageRaw200ApplicationJSONObject =
              utils.objectToClass(httpRes?.data);
          }
          if (utils.matchContentType(contentType, `text/json`)) {
            res.orderApiSendMessageRaw200TextJSONObject = utils.objectToClass(
              httpRes?.data
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Attach one or more tags to an order
   *
   * @remarks
   * When a tag is already attached, it is ignored. Tags are not case sensitive. All given tags are added to the existing tags.
   */
  orderApiTagsCreateForm(
    req: operations.OrderApiTagsCreateFormRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.OrderApiTagsCreateFormResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.OrderApiTagsCreateFormRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/api/v1/orders/{id}/tags",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "rechnungsdruckWebAppControllersApiOrderTagCreate",
        "form"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.OrderApiTagsCreateFormResponse =
        new operations.OrderApiTagsCreateFormResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.orderApiTagsCreateForm200ApplicationJSONObject =
              utils.objectToClass(httpRes?.data);
          }
          if (utils.matchContentType(contentType, `text/json`)) {
            res.orderApiTagsCreateForm200TextJSONObject = utils.objectToClass(
              httpRes?.data
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Attach one or more tags to an order
   *
   * @remarks
   * When a tag is already attached, it is ignored. Tags are not case sensitive. All given tags are added to the existing tags.
   */
  orderApiTagsCreateJson(
    req: operations.OrderApiTagsCreateJsonRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.OrderApiTagsCreateJsonResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.OrderApiTagsCreateJsonRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/api/v1/orders/{id}/tags",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "rechnungsdruckWebAppControllersApiOrderTagCreate",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.OrderApiTagsCreateJsonResponse =
        new operations.OrderApiTagsCreateJsonResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.orderApiTagsCreateJSON200ApplicationJSONObject =
              utils.objectToClass(httpRes?.data);
          }
          if (utils.matchContentType(contentType, `text/json`)) {
            res.orderApiTagsCreateJSON200TextJSONObject = utils.objectToClass(
              httpRes?.data
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Attach one or more tags to an order
   *
   * @remarks
   * When a tag is already attached, it is ignored. Tags are not case sensitive. All given tags are added to the existing tags.
   */
  orderApiTagsCreateRaw(
    req: operations.OrderApiTagsCreateRawRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.OrderApiTagsCreateRawResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.OrderApiTagsCreateRawRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/api/v1/orders/{id}/tags",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "raw"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.OrderApiTagsCreateRawResponse =
        new operations.OrderApiTagsCreateRawResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.orderApiTagsCreateRaw200ApplicationJSONObject =
              utils.objectToClass(httpRes?.data);
          }
          if (utils.matchContentType(contentType, `text/json`)) {
            res.orderApiTagsCreateRaw200TextJSONObject = utils.objectToClass(
              httpRes?.data
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Sets the tags attached to an order
   *
   * @remarks
   * All existing tags will be replaced by the given list of new tags. To just add tags, use POST method.
   */
  orderApiTagsUpdateForm(
    req: operations.OrderApiTagsUpdateFormRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.OrderApiTagsUpdateFormResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.OrderApiTagsUpdateFormRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/api/v1/orders/{id}/tags",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "rechnungsdruckWebAppControllersApiOrderTagCreate",
        "form"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "put",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.OrderApiTagsUpdateFormResponse =
        new operations.OrderApiTagsUpdateFormResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.orderApiTagsUpdateForm200ApplicationJSONObject =
              utils.objectToClass(httpRes?.data);
          }
          if (utils.matchContentType(contentType, `text/json`)) {
            res.orderApiTagsUpdateForm200TextJSONObject = utils.objectToClass(
              httpRes?.data
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Sets the tags attached to an order
   *
   * @remarks
   * All existing tags will be replaced by the given list of new tags. To just add tags, use POST method.
   */
  orderApiTagsUpdateJson(
    req: operations.OrderApiTagsUpdateJsonRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.OrderApiTagsUpdateJsonResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.OrderApiTagsUpdateJsonRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/api/v1/orders/{id}/tags",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "rechnungsdruckWebAppControllersApiOrderTagCreate",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "put",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.OrderApiTagsUpdateJsonResponse =
        new operations.OrderApiTagsUpdateJsonResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.orderApiTagsUpdateJSON200ApplicationJSONObject =
              utils.objectToClass(httpRes?.data);
          }
          if (utils.matchContentType(contentType, `text/json`)) {
            res.orderApiTagsUpdateJSON200TextJSONObject = utils.objectToClass(
              httpRes?.data
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Sets the tags attached to an order
   *
   * @remarks
   * All existing tags will be replaced by the given list of new tags. To just add tags, use POST method.
   */
  orderApiTagsUpdateRaw(
    req: operations.OrderApiTagsUpdateRawRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.OrderApiTagsUpdateRawResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.OrderApiTagsUpdateRawRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/api/v1/orders/{id}/tags",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "raw"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "put",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.OrderApiTagsUpdateRawResponse =
        new operations.OrderApiTagsUpdateRawResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.orderApiTagsUpdateRaw200ApplicationJSONObject =
              utils.objectToClass(httpRes?.data);
          }
          if (utils.matchContentType(contentType, `text/json`)) {
            res.orderApiTagsUpdateRaw200TextJSONObject = utils.objectToClass(
              httpRes?.data
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Triggers a rule event
   */
  orderApiTriggerEventForm(
    req: operations.OrderApiTriggerEventFormRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.OrderApiTriggerEventFormResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.OrderApiTriggerEventFormRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/api/v1/orders/{id}/trigger-event",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "rechnungsdruckWebAppControllersApiOrderApiControllerTriggerEventContainer",
        "form"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.OrderApiTriggerEventFormResponse =
        new operations.OrderApiTriggerEventFormResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.orderApiTriggerEventForm200ApplicationJSONObject =
              utils.objectToClass(httpRes?.data);
          }
          if (utils.matchContentType(contentType, `text/json`)) {
            res.orderApiTriggerEventForm200TextJSONObject = utils.objectToClass(
              httpRes?.data
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Triggers a rule event
   */
  orderApiTriggerEventJson(
    req: operations.OrderApiTriggerEventJsonRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.OrderApiTriggerEventJsonResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.OrderApiTriggerEventJsonRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/api/v1/orders/{id}/trigger-event",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "rechnungsdruckWebAppControllersApiOrderApiControllerTriggerEventContainer",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.OrderApiTriggerEventJsonResponse =
        new operations.OrderApiTriggerEventJsonResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.orderApiTriggerEventJSON200ApplicationJSONObject =
              utils.objectToClass(httpRes?.data);
          }
          if (utils.matchContentType(contentType, `text/json`)) {
            res.orderApiTriggerEventJSON200TextJSONObject = utils.objectToClass(
              httpRes?.data
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Triggers a rule event
   */
  orderApiTriggerEventRaw(
    req: operations.OrderApiTriggerEventRawRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.OrderApiTriggerEventRawResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.OrderApiTriggerEventRawRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/api/v1/orders/{id}/trigger-event",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "raw"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.OrderApiTriggerEventRawResponse =
        new operations.OrderApiTriggerEventRawResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.orderApiTriggerEventRaw200ApplicationJSONObject =
              utils.objectToClass(httpRes?.data);
          }
          if (utils.matchContentType(contentType, `text/json`)) {
            res.orderApiTriggerEventRaw200TextJSONObject = utils.objectToClass(
              httpRes?.data
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Changes the main state of a single order
   *
   * @remarks
   * ### REMARKS ###
   * Use this call to change the state of an order to i.e. paid or sent.
   *
   * The state is transfered to the external shop/marketplace if configured.
   * This is the list of known states:
   * - 1: ordered
   * - 2: confirmed
   * - 3: paid
   * - 4: shipped
   * - 5: reclamation
   * - 6: deleted
   * - 7: closed
   * - 8: canceled
   * - 9: archived
   * - 10: not used
   * - 11: demand note 1
   * - 12: demand note 2
   * - 13: packed
   * - 14: offered
   * - 15: payment reminder
   * - 16: fulfilling
   */
  orderApiUpdateStateForm(
    req: operations.OrderApiUpdateStateFormRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.OrderApiUpdateStateFormResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.OrderApiUpdateStateFormRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/api/v1/orders/{id}/orderstate",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "rechnungsdruckWebAppControllersApiOrderStateUpdate",
        "form"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "put",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.OrderApiUpdateStateFormResponse =
        new operations.OrderApiUpdateStateFormResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.orderApiUpdateStateForm200ApplicationJSONObject =
              utils.objectToClass(httpRes?.data);
          }
          if (utils.matchContentType(contentType, `text/json`)) {
            res.orderApiUpdateStateForm200TextJSONObject = utils.objectToClass(
              httpRes?.data
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Changes the main state of a single order
   *
   * @remarks
   * ### REMARKS ###
   * Use this call to change the state of an order to i.e. paid or sent.
   *
   * The state is transfered to the external shop/marketplace if configured.
   * This is the list of known states:
   * - 1: ordered
   * - 2: confirmed
   * - 3: paid
   * - 4: shipped
   * - 5: reclamation
   * - 6: deleted
   * - 7: closed
   * - 8: canceled
   * - 9: archived
   * - 10: not used
   * - 11: demand note 1
   * - 12: demand note 2
   * - 13: packed
   * - 14: offered
   * - 15: payment reminder
   * - 16: fulfilling
   */
  orderApiUpdateStateJson(
    req: operations.OrderApiUpdateStateJsonRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.OrderApiUpdateStateJsonResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.OrderApiUpdateStateJsonRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/api/v1/orders/{id}/orderstate",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "rechnungsdruckWebAppControllersApiOrderStateUpdate",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "put",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.OrderApiUpdateStateJsonResponse =
        new operations.OrderApiUpdateStateJsonResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.orderApiUpdateStateJSON200ApplicationJSONObject =
              utils.objectToClass(httpRes?.data);
          }
          if (utils.matchContentType(contentType, `text/json`)) {
            res.orderApiUpdateStateJSON200TextJSONObject = utils.objectToClass(
              httpRes?.data
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Changes the main state of a single order
   *
   * @remarks
   * ### REMARKS ###
   * Use this call to change the state of an order to i.e. paid or sent.
   *
   * The state is transfered to the external shop/marketplace if configured.
   * This is the list of known states:
   * - 1: ordered
   * - 2: confirmed
   * - 3: paid
   * - 4: shipped
   * - 5: reclamation
   * - 6: deleted
   * - 7: closed
   * - 8: canceled
   * - 9: archived
   * - 10: not used
   * - 11: demand note 1
   * - 12: demand note 2
   * - 13: packed
   * - 14: offered
   * - 15: payment reminder
   * - 16: fulfilling
   */
  orderApiUpdateStateRaw(
    req: operations.OrderApiUpdateStateRawRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.OrderApiUpdateStateRawResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.OrderApiUpdateStateRawRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/api/v1/orders/{id}/orderstate",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "raw"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "put",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.OrderApiUpdateStateRawResponse =
        new operations.OrderApiUpdateStateRawResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.orderApiUpdateStateRaw200ApplicationJSONObject =
              utils.objectToClass(httpRes?.data);
          }
          if (utils.matchContentType(contentType, `text/json`)) {
            res.orderApiUpdateStateRaw200TextJSONObject = utils.objectToClass(
              httpRes?.data
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Search for products, customers and orders.
   * Type can be "order", "product" and / or "customer"
   * Term can contains lucene query syntax
   */
  searchSearchForm(
    req: shared.RechnungsdruckWebAppControllersApiSearchControllerSearchModel,
    config?: AxiosRequestConfig
  ): Promise<operations.SearchSearchFormResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new shared.RechnungsdruckWebAppControllersApiSearchControllerSearchModel(
          req
        );
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/api/v1/search";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "request",
        "form"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.SearchSearchFormResponse =
        new operations.SearchSearchFormResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.rechnungsdruckWebAppControllersApiApiResultRechnungsdruckWebAppControllersApiSearchControllerSearchResultsModel =
              utils.objectToClass(
                httpRes?.data,
                shared.RechnungsdruckWebAppControllersApiApiResultRechnungsdruckWebAppControllersApiSearchControllerSearchResultsModel
              );
          }
          if (utils.matchContentType(contentType, `text/json`)) {
            res.rechnungsdruckWebAppControllersApiApiResultRechnungsdruckWebAppControllersApiSearchControllerSearchResultsModel =
              utils.objectToClass(
                httpRes?.data,
                shared.RechnungsdruckWebAppControllersApiApiResultRechnungsdruckWebAppControllersApiSearchControllerSearchResultsModel
              );
          }
          if (utils.matchContentType(contentType, `application/xml`)) {
            const resBody: string = JSON.stringify(httpRes?.data, null, 0);
            const out: Uint8Array = new Uint8Array(resBody.length);
            for (let i = 0; i < resBody.length; i++)
              out[i] = resBody.charCodeAt(i);
            res.body = out;
          }
          if (utils.matchContentType(contentType, `text/xml`)) {
            const resBody: string = JSON.stringify(httpRes?.data, null, 0);
            const out: Uint8Array = new Uint8Array(resBody.length);
            for (let i = 0; i < resBody.length; i++)
              out[i] = resBody.charCodeAt(i);
            res.body = out;
          }
          break;
      }

      return res;
    });
  }

  /**
   * Search for products, customers and orders.
   * Type can be "order", "product" and / or "customer"
   * Term can contains lucene query syntax
   */
  searchSearchJson(
    req: shared.RechnungsdruckWebAppControllersApiSearchControllerSearchModel,
    config?: AxiosRequestConfig
  ): Promise<operations.SearchSearchJsonResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new shared.RechnungsdruckWebAppControllersApiSearchControllerSearchModel(
          req
        );
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/api/v1/search";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "request",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.SearchSearchJsonResponse =
        new operations.SearchSearchJsonResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.rechnungsdruckWebAppControllersApiApiResultRechnungsdruckWebAppControllersApiSearchControllerSearchResultsModel =
              utils.objectToClass(
                httpRes?.data,
                shared.RechnungsdruckWebAppControllersApiApiResultRechnungsdruckWebAppControllersApiSearchControllerSearchResultsModel
              );
          }
          if (utils.matchContentType(contentType, `text/json`)) {
            res.rechnungsdruckWebAppControllersApiApiResultRechnungsdruckWebAppControllersApiSearchControllerSearchResultsModel =
              utils.objectToClass(
                httpRes?.data,
                shared.RechnungsdruckWebAppControllersApiApiResultRechnungsdruckWebAppControllersApiSearchControllerSearchResultsModel
              );
          }
          if (utils.matchContentType(contentType, `application/xml`)) {
            const resBody: string = JSON.stringify(httpRes?.data, null, 0);
            const out: Uint8Array = new Uint8Array(resBody.length);
            for (let i = 0; i < resBody.length; i++)
              out[i] = resBody.charCodeAt(i);
            res.body = out;
          }
          if (utils.matchContentType(contentType, `text/xml`)) {
            const resBody: string = JSON.stringify(httpRes?.data, null, 0);
            const out: Uint8Array = new Uint8Array(resBody.length);
            for (let i = 0; i < resBody.length; i++)
              out[i] = resBody.charCodeAt(i);
            res.body = out;
          }
          break;
      }

      return res;
    });
  }

  /**
   * Search for products, customers and orders.
   * Type can be "order", "product" and / or "customer"
   * Term can contains lucene query syntax
   */
  searchSearchRaw(
    req: Uint8Array,
    config?: AxiosRequestConfig
  ): Promise<operations.SearchSearchRawResponse> {
    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/api/v1/search";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "request",
        "raw"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.SearchSearchRawResponse =
        new operations.SearchSearchRawResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.rechnungsdruckWebAppControllersApiApiResultRechnungsdruckWebAppControllersApiSearchControllerSearchResultsModel =
              utils.objectToClass(
                httpRes?.data,
                shared.RechnungsdruckWebAppControllersApiApiResultRechnungsdruckWebAppControllersApiSearchControllerSearchResultsModel
              );
          }
          if (utils.matchContentType(contentType, `text/json`)) {
            res.rechnungsdruckWebAppControllersApiApiResultRechnungsdruckWebAppControllersApiSearchControllerSearchResultsModel =
              utils.objectToClass(
                httpRes?.data,
                shared.RechnungsdruckWebAppControllersApiApiResultRechnungsdruckWebAppControllersApiSearchControllerSearchResultsModel
              );
          }
          if (utils.matchContentType(contentType, `application/xml`)) {
            const resBody: string = JSON.stringify(httpRes?.data, null, 0);
            const out: Uint8Array = new Uint8Array(resBody.length);
            for (let i = 0; i < resBody.length; i++)
              out[i] = resBody.charCodeAt(i);
            res.body = out;
          }
          if (utils.matchContentType(contentType, `text/xml`)) {
            const resBody: string = JSON.stringify(httpRes?.data, null, 0);
            const out: Uint8Array = new Uint8Array(resBody.length);
            for (let i = 0; i < resBody.length; i++)
              out[i] = resBody.charCodeAt(i);
            res.body = out;
          }
          break;
      }

      return res;
    });
  }
}
