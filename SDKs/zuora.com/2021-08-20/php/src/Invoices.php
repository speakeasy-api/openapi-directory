<?php

/**
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

declare(strict_types=1);

namespace OpenAPI\OpenAPI;

class Invoices 
{

	// SDK private variables namespaced with _ to avoid conflicts with API models
	private \GuzzleHttp\ClientInterface $_defaultClient;
	private \GuzzleHttp\ClientInterface $_securityClient;
	private string $_serverUrl;
	private string $_language;
	private string $_sdkVersion;
	private string $_genVersion;	

	/**
	 * @param \GuzzleHttp\ClientInterface $defaultClient
	 * @param \GuzzleHttp\ClientInterface $securityClient
	 * @param string $serverUrl
	 * @param string $language
	 * @param string $sdkVersion
	 * @param string $genVersion
	 */
	public function __construct(\GuzzleHttp\ClientInterface $defaultClient, \GuzzleHttp\ClientInterface $securityClient, string $serverUrl, string $language, string $sdkVersion, string $genVersion)
	{
		$this->_defaultClient = $defaultClient;
		$this->_securityClient = $securityClient;
		$this->_serverUrl = $serverUrl;
		$this->_language = $language;
		$this->_sdkVersion = $sdkVersion;
		$this->_genVersion = $genVersion;
	}
	
    /**
     * List all application parts of an invoice
     * 
     * **Note:** This operation is only available if you have [Invoice Settlement](https://knowledgecenter.zuora.com/Billing/Billing_and_Payments/Invoice_Settlement) enabled. The Invoice Settlement feature is generally available as of Zuora Billing Release 296 (March 2021). This feature includes Unapplied Payments, Credit and Debit Memo, and Invoice Item Settlement. If you want to enable Invoice Settlement, see [Invoice Settlement Enablement and Checklist Guide](https://knowledgecenter.zuora.com/Billing/Billing_and_Payments/Invoice_Settlement/Invoice_Settlement_Migration_Checklist_and_Guide) for more information.
     * 
     * Retrieves information about the payments or credit memos that are applied to a specified invoice.
     * 
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GETInvoiceApplicationPartsRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\GETInvoiceApplicationPartsResponse
     */
	public function getInvoiceApplicationParts(
        \OpenAPI\OpenAPI\Models\Operations\GETInvoiceApplicationPartsRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\GETInvoiceApplicationPartsResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v1/invoices/{invoiceId}/application-parts', \OpenAPI\OpenAPI\Models\Operations\GETInvoiceApplicationPartsRequest::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getHeaders($request));
        
        $httpResponse = $this->_defaultClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GETInvoiceApplicationPartsResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            $response->headers = $httpResponse->getHeaders();
            
            if (Utils\Utils::matchContentType($contentType, 'application/json; charset=utf-8')) {
                $serializer = Utils\JSON::createSerializer();
                $response->getInvoiceApplicationPartCollectionType = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\GetInvoiceApplicationPartCollectionType', 'json');
            }
        }

        return $response;
    }
	
    /**
     * List all files of an invoice
     * 
     * Retrieves the information about all PDF files of a specified invoice. 
     * 
     * Invoice PDF files are returned in reverse chronological order by the value of the `versionNumber` field.
     * 
     * **Note**: This API only retrieves the PDF files that have been generated. If the latest PDF file is being generated, it will not be included in the response.
     * 
     * You can use the [Query](https://www.zuora.com/developer/api-reference/#operation/Action_POSTquery) action to get the latest PDF file, for example: `"select Body from Invoice where Id = '2c93808457d787030157e0324aea5158'"`.
     * 
     * See [Query an Invoice Body](https://knowledgecenter.zuora.com/Central_Platform/API/G_SOAP_API/E1_SOAP_API_Object_Reference/Invoice/Query_an_Invoice_Body_Field) for more information.
     * 
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GETInvoiceFilesRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\GETInvoiceFilesResponse
     */
	public function getInvoiceFiles(
        \OpenAPI\OpenAPI\Models\Operations\GETInvoiceFilesRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\GETInvoiceFilesResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v1/invoices/{invoiceId}/files', \OpenAPI\OpenAPI\Models\Operations\GETInvoiceFilesRequest::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\GETInvoiceFilesRequest::class, $request, null));
        $options = array_merge_recursive($options, Utils\Utils::getHeaders($request));
        
        $httpResponse = $this->_defaultClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GETInvoiceFilesResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            $response->headers = $httpResponse->getHeaders();
            
            if (Utils\Utils::matchContentType($contentType, 'application/json; charset=utf-8')) {
                $serializer = Utils\JSON::createSerializer();
                $response->getInvoiceFilesResponse = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\GETInvoiceFilesResponse', 'json');
            }
        }

        return $response;
    }
	
    /**
     * List all items of an invoice
     * 
     * Retrieves the information about all items of a specified invoice. 
     * 
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GETInvoiceItemsRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\GETInvoiceItemsResponse
     */
	public function getInvoiceItems(
        \OpenAPI\OpenAPI\Models\Operations\GETInvoiceItemsRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\GETInvoiceItemsResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v1/invoices/{invoiceId}/items', \OpenAPI\OpenAPI\Models\Operations\GETInvoiceItemsRequest::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\GETInvoiceItemsRequest::class, $request, null));
        $options = array_merge_recursive($options, Utils\Utils::getHeaders($request));
        
        $httpResponse = $this->_defaultClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GETInvoiceItemsResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            $response->headers = $httpResponse->getHeaders();
            
            if (Utils\Utils::matchContentType($contentType, 'application/json; charset=utf-8')) {
                $serializer = Utils\JSON::createSerializer();
                $response->getInvoiceItemsResponse = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\GETInvoiceItemsResponse', 'json');
            }
        }

        return $response;
    }
	
    /**
     * List all taxation items of an invoice item
     * 
     * Retrieves information about the taxation items of a specific invoice item. 
     * 
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GETTaxationItemsOfInvoiceItemRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\GETTaxationItemsOfInvoiceItemResponse
     */
	public function getTaxationItemsOfInvoiceItem(
        \OpenAPI\OpenAPI\Models\Operations\GETTaxationItemsOfInvoiceItemRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\GETTaxationItemsOfInvoiceItemResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v1/invoices/{invoiceId}/items/{itemId}/taxation-items', \OpenAPI\OpenAPI\Models\Operations\GETTaxationItemsOfInvoiceItemRequest::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\GETTaxationItemsOfInvoiceItemRequest::class, $request, null));
        $options = array_merge_recursive($options, Utils\Utils::getHeaders($request));
        
        $httpResponse = $this->_defaultClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GETTaxationItemsOfInvoiceItemResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            $response->headers = $httpResponse->getHeaders();
            
            if (Utils\Utils::matchContentType($contentType, 'application/json; charset=utf-8')) {
                $serializer = Utils\JSON::createSerializer();
                $response->getInvoiceTaxationItemsResponse = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\GETInvoiceTaxationItemsResponse', 'json');
            }
        }

        return $response;
    }
	
    /**
     * CRUD: Delete an invoice
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\ObjectDELETEInvoiceRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\ObjectDELETEInvoiceResponse
     */
	public function objectDELETEInvoice(
        \OpenAPI\OpenAPI\Models\Operations\ObjectDELETEInvoiceRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\ObjectDELETEInvoiceResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v1/object/invoice/{id}', \OpenAPI\OpenAPI\Models\Operations\ObjectDELETEInvoiceRequest::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getHeaders($request));
        
        $httpResponse = $this->_defaultClient->request('DELETE', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\ObjectDELETEInvoiceResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            $response->headers = $httpResponse->getHeaders();
            
            if (Utils\Utils::matchContentType($contentType, 'application/json; charset=utf-8')) {
                $serializer = Utils\JSON::createSerializer();
                $response->proxyDeleteResponse = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\ProxyDeleteResponse', 'json');
            }
        }
        else if ($httpResponse->getStatusCode() === 401) {
            $response->headers = $httpResponse->getHeaders();
            
            if (Utils\Utils::matchContentType($contentType, 'application/json; charset=utf-8')) {
                $serializer = Utils\JSON::createSerializer();
                $response->proxyUnauthorizedResponse = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\ProxyUnauthorizedResponse', 'json');
            }
        }

        return $response;
    }
	
    /**
     * CRUD: Retrieve an invoice
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\ObjectGETInvoiceRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\ObjectGETInvoiceResponse
     */
	public function objectGETInvoice(
        \OpenAPI\OpenAPI\Models\Operations\ObjectGETInvoiceRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\ObjectGETInvoiceResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v1/object/invoice/{id}', \OpenAPI\OpenAPI\Models\Operations\ObjectGETInvoiceRequest::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\ObjectGETInvoiceRequest::class, $request, null));
        $options = array_merge_recursive($options, Utils\Utils::getHeaders($request));
        
        $httpResponse = $this->_defaultClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\ObjectGETInvoiceResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            $response->headers = $httpResponse->getHeaders();
            
            if (Utils\Utils::matchContentType($contentType, 'application/json; charset=utf-8')) {
                $serializer = Utils\JSON::createSerializer();
                $response->proxyGetInvoice = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\ProxyGetInvoice', 'json');
            }
        }
        else if ($httpResponse->getStatusCode() === 401) {
            $response->headers = $httpResponse->getHeaders();
            
            if (Utils\Utils::matchContentType($contentType, 'application/json; charset=utf-8')) {
                $serializer = Utils\JSON::createSerializer();
                $response->proxyUnauthorizedResponse = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\ProxyUnauthorizedResponse', 'json');
            }
        }
        else if ($httpResponse->getStatusCode() === 404) {
            $response->headers = $httpResponse->getHeaders();
            
            if (Utils\Utils::matchContentType($contentType, 'application/json; charset=utf-8')) {
                $serializer = Utils\JSON::createSerializer();
                $response->proxyNoDataResponse = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\ProxyNoDataResponse', 'json');
            }
        }

        return $response;
    }
	
    /**
     * CRUD: Update an invoice
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\ObjectPUTInvoiceRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\ObjectPUTInvoiceResponse
     */
	public function objectPUTInvoice(
        \OpenAPI\OpenAPI\Models\Operations\ObjectPUTInvoiceRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\ObjectPUTInvoiceResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v1/object/invoice/{id}', \OpenAPI\OpenAPI\Models\Operations\ObjectPUTInvoiceRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "proxyModifyInvoice", "json");
        if ($body === null) {
            throw new \Exception('Request body is required');
        }
        $options = array_merge_recursive($options, $body);
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\ObjectPUTInvoiceRequest::class, $request, null));
        $options = array_merge_recursive($options, Utils\Utils::getHeaders($request));
        
        $httpResponse = $this->_defaultClient->request('PUT', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\ObjectPUTInvoiceResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            $response->headers = $httpResponse->getHeaders();
            
            if (Utils\Utils::matchContentType($contentType, 'application/json; charset=utf-8')) {
                $serializer = Utils\JSON::createSerializer();
                $response->proxyCreateOrModifyResponse = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\ProxyCreateOrModifyResponse', 'json');
            }
        }
        else if ($httpResponse->getStatusCode() === 401) {
            $response->headers = $httpResponse->getHeaders();
            
            if (Utils\Utils::matchContentType($contentType, 'application/json; charset=utf-8')) {
                $serializer = Utils\JSON::createSerializer();
                $response->proxyUnauthorizedResponse = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\ProxyUnauthorizedResponse', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Create a credit memo from an invoice
     * 
     * **Note:** This operation is only available if you have [Invoice Settlement](https://knowledgecenter.zuora.com/Billing/Billing_and_Payments/Invoice_Settlement) enabled. The Invoice Settlement feature is generally available as of Zuora Billing Release 296 (March 2021). This feature includes Unapplied Payments, Credit and Debit Memo, and Invoice Item Settlement. If you want to enable Invoice Settlement, see [Invoice Settlement Enablement and Checklist Guide](https://knowledgecenter.zuora.com/Billing/Billing_and_Payments/Invoice_Settlement/Invoice_Settlement_Migration_Checklist_and_Guide) for more information. 
     * 
     * Creates an ad-hoc credit memo from an invoice.
     * 
     * You can create a credit memo from an invoice only if you have the user permission. See [Billing Roles](https://knowledgecenter.zuora.com/CF_Users_and_Administrators/A_Administrator_Settings/User_Roles/d_Billing_Roles) for more information.
     * 
     * For a use case of this operation, see [Create credit memo](https://www.zuora.com/developer/api-guides/#Create-credit-memo).
     * 
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\POSTCreditMemoFromInvoiceRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\POSTCreditMemoFromInvoiceResponse
     */
	public function postCreditMemoFromInvoice(
        \OpenAPI\OpenAPI\Models\Operations\POSTCreditMemoFromInvoiceRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\POSTCreditMemoFromInvoiceResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v1/invoices/{invoiceId}/creditmemos', \OpenAPI\OpenAPI\Models\Operations\POSTCreditMemoFromInvoiceRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "creditMemoFromInvoiceType", "json");
        if ($body === null) {
            throw new \Exception('Request body is required');
        }
        $options = array_merge_recursive($options, $body);
        $options = array_merge_recursive($options, Utils\Utils::getHeaders($request));
        
        $httpResponse = $this->_defaultClient->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\POSTCreditMemoFromInvoiceResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            $response->headers = $httpResponse->getHeaders();
            
            if (Utils\Utils::matchContentType($contentType, 'application/json; charset=utf-8')) {
                $serializer = Utils\JSON::createSerializer();
                $response->getCreditMemoType = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\GETCreditMemoType', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Create a debit memo from an invoice
     * 
     * **Note:** This operation is only available if you have [Invoice Settlement](https://knowledgecenter.zuora.com/Billing/Billing_and_Payments/Invoice_Settlement) enabled. The Invoice Settlement feature is generally available as of Zuora Billing Release 296 (March 2021). This feature includes Unapplied Payments, Credit and Debit Memo, and Invoice Item Settlement. If you want to enable Invoice Settlement, see [Invoice Settlement Enablement and Checklist Guide](https://knowledgecenter.zuora.com/Billing/Billing_and_Payments/Invoice_Settlement/Invoice_Settlement_Migration_Checklist_and_Guide) for more information. 
     * 
     * Creates an ad-hoc debit memo from an invoice.
     * 
     * You can create a debit memo from an invoice only if you have the user permission. See [Billing Roles](https://knowledgecenter.zuora.com/CF_Users_and_Administrators/A_Administrator_Settings/User_Roles/d_Billing_Roles) for more information.
     * 
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\POSTDebitMemoFromInvoiceRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\POSTDebitMemoFromInvoiceResponse
     */
	public function postDebitMemoFromInvoice(
        \OpenAPI\OpenAPI\Models\Operations\POSTDebitMemoFromInvoiceRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\POSTDebitMemoFromInvoiceResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v1/invoices/{invoiceId}/debitmemos', \OpenAPI\OpenAPI\Models\Operations\POSTDebitMemoFromInvoiceRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "debitMemoFromInvoiceType", "json");
        if ($body === null) {
            throw new \Exception('Request body is required');
        }
        $options = array_merge_recursive($options, $body);
        $options = array_merge_recursive($options, Utils\Utils::getHeaders($request));
        
        $httpResponse = $this->_defaultClient->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\POSTDebitMemoFromInvoiceResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            $response->headers = $httpResponse->getHeaders();
            
            if (Utils\Utils::matchContentType($contentType, 'application/json; charset=utf-8')) {
                $serializer = Utils\JSON::createSerializer();
                $response->getDebitMemoType = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\GETDebitMemoType', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Email an invoice
     * 
     * Sends a posted invoice to the specified email addresses manually.
     * 
     * 
     * 
     * ## Notes
     *   - You must activate the **Manual Email For Invoice | Manual Email For Invoice** notification before emailing invoices. To include the invoice PDF in the email, select the **Include Invoice PDF** check box in the **Edit notification** dialog from the Zuora UI. See [Create and Edit Notifications](https://knowledgecenter.zuora.com/CF_Users_and_Administrators/Notifications/C_Create_Notifications#section_2) for more information.
     * 
     * 
     *   - Zuora sends the email messages based on the email template you set. You can set the email template to use in the **Delivery Options** panel of the **Edit notification** dialog from the Zuora UI. By default, the **Invoice Posted Default Email Template** template is used. See [Create and Edit Email Templates](https://knowledgecenter.zuora.com/CF_Users_and_Administrators/Notifications/Create_Email_Templates) for more information.
     * 
     * 
     *   - The invoices are sent only to the work email addresses or personal email addresses of the Bill To contact if the following conditions are all met:
     * 
     *     * The `useEmailTemplateSetting` field is set to `false`.
     *     * The email addresses are not specified in the `emailAddresses` field.
     * 
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\POSTEmailInvoiceRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\POSTEmailInvoiceResponse
     */
	public function postEmailInvoice(
        \OpenAPI\OpenAPI\Models\Operations\POSTEmailInvoiceRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\POSTEmailInvoiceResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v1/invoices/{invoiceId}/emails', \OpenAPI\OpenAPI\Models\Operations\POSTEmailInvoiceRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "postInvoiceEmailRequestType", "json");
        if ($body === null) {
            throw new \Exception('Request body is required');
        }
        $options = array_merge_recursive($options, $body);
        $options = array_merge_recursive($options, Utils\Utils::getHeaders($request));
        
        $httpResponse = $this->_defaultClient->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\POSTEmailInvoiceResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            $response->headers = $httpResponse->getHeaders();
            
            if (Utils\Utils::matchContentType($contentType, 'application/json; charset=utf-8')) {
                $serializer = Utils\JSON::createSerializer();
                $response->commonResponseType = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\CommonResponseType', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Create a standalone invoice
     * 
     * **Note:** This operation is only available if you have Unified Invoicing enabled. The Unified Invoicing feature is in the Early Adopter phase. We are actively soliciting feedback from a small set of early adopters before releasing it as generally available. If you want to join this early adopter program, submit a request at [Zuora Global Support](http://support.zuora.com/).
     * 
     * Creates a standalone invoice for selling physical goods, services or other items on a non-recurring basis to your subscription customers.
     * 
     * To use this operation, you must have the Create Standalone Invoice and Modify Invoice user permissions. See [Billing Roles](https://knowledgecenter.zuora.com/CF_Users_and_Administrators/A_Administrator_Settings/User_Roles/d_Billing_Roles) for more information.
     * 
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\POSTStandaloneInvoiceRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\POSTStandaloneInvoiceResponse
     */
	public function postStandaloneInvoice(
        \OpenAPI\OpenAPI\Models\Operations\POSTStandaloneInvoiceRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\POSTStandaloneInvoiceResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v1/invoices');
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "postInvoiceType", "json");
        if ($body === null) {
            throw new \Exception('Request body is required');
        }
        $options = array_merge_recursive($options, $body);
        $options = array_merge_recursive($options, Utils\Utils::getHeaders($request));
        
        $httpResponse = $this->_defaultClient->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\POSTStandaloneInvoiceResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            $response->headers = $httpResponse->getHeaders();
            
            if (Utils\Utils::matchContentType($contentType, 'application/json; charset=utf-8')) {
                $serializer = Utils\JSON::createSerializer();
                $response->postInvoiceResponse = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\PostInvoiceResponse', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Upload a file for an invoice
     * 
     * Uploads an externally generated invoice PDF file for an invoice that is in Draft or Posted status.
     * 
     * To use this operation, you must enable the Modify Invoice permission. See [Billing Permissions](https://knowledgecenter.zuora.com/Billing/Tenant_Management/A_Administrator_Settings/User_Roles/d_Billing_Roles) for more information.
     * 
     * This operation has the following restrictions:
     * - Only the PDF file format is supported.
     * - The maximum size of the PDF file to upload is 4 MB.
     * - A maximum of 50 PDF files can be uploaded for one invoice.
     * 
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\POSTUploadFileForInvoiceRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\POSTUploadFileForInvoiceResponse
     */
	public function postUploadFileForInvoice(
        \OpenAPI\OpenAPI\Models\Operations\POSTUploadFileForInvoiceRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\POSTUploadFileForInvoiceResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v1/invoices/{invoiceId}/files', \OpenAPI\OpenAPI\Models\Operations\POSTUploadFileForInvoiceRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "requestBody", "multipart");
        $options = array_merge_recursive($options, $body);
        $options = array_merge_recursive($options, Utils\Utils::getHeaders($request));
        
        $httpResponse = $this->_defaultClient->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\POSTUploadFileForInvoiceResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            $response->headers = $httpResponse->getHeaders();
            
            if (Utils\Utils::matchContentType($contentType, 'application/json; charset=utf-8')) {
                $serializer = Utils\JSON::createSerializer();
                $response->postUploadFileResponse = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\POSTUploadFileResponse', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Update invoices
     * 
     * Updates multiple invoices in batches with one call. 
     * 
     * ## Limitations 
     * 
     * This operation has the following limitations:
     * 
     * * You can update a maximum of 50 invoices by one call.
     * 
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\PUTBatchUpdateInvoicesRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\PUTBatchUpdateInvoicesResponse
     */
	public function putBatchUpdateInvoices(
        \OpenAPI\OpenAPI\Models\Operations\PUTBatchUpdateInvoicesRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\PUTBatchUpdateInvoicesResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v1/invoices');
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "putBatchInvoiceType", "json");
        if ($body === null) {
            throw new \Exception('Request body is required');
        }
        $options = array_merge_recursive($options, $body);
        $options = array_merge_recursive($options, Utils\Utils::getHeaders($request));
        
        $httpResponse = $this->_defaultClient->request('PUT', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\PUTBatchUpdateInvoicesResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            $response->headers = $httpResponse->getHeaders();
            
            if (Utils\Utils::matchContentType($contentType, 'application/json; charset=utf-8')) {
                $serializer = Utils\JSON::createSerializer();
                $response->commonResponseType = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\CommonResponseType', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Reverse an invoice
     * 
     * **Note:** This operation is only available if you have [Invoice Settlement](https://knowledgecenter.zuora.com/Billing/Billing_and_Payments/Invoice_Settlement) enabled. The Invoice Settlement feature is generally available as of Zuora Billing Release 296 (March 2021). This feature includes Unapplied Payments, Credit and Debit Memo, and Invoice Item Settlement. If you want to enable Invoice Settlement, see [Invoice Settlement Enablement and Checklist Guide](https://knowledgecenter.zuora.com/Billing/Billing_and_Payments/Invoice_Settlement/Invoice_Settlement_Migration_Checklist_and_Guide) for more information.
     * 
     * Reverses a posted invoice. 
     * 
     * **Restrictions**
     * 
     * You are not allowed to reverse an invoice if any of the following restrictions is met:
     * 
     * * Payments and credit memos are applied to the invoice.
     * * The invoice is split.
     * * The invoice is not in Posted status.
     * * The total amount of the invoice is less than 0 (a negative invoice).
     * * Using Tax Connector for Extension Platform to calculate taxes.
     * * An invoice contains more than 2,000 items in total, including invoice items, discount items, and taxation items.
     * 
     * See [Invoice Reversal](https://knowledgecenter.zuora.com/CB_Billing/IA_Invoices/Reverse_Posted_Invoices) for more information.
     * 
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\PUTReverseInvoiceRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\PUTReverseInvoiceResponse
     */
	public function putReverseInvoice(
        \OpenAPI\OpenAPI\Models\Operations\PUTReverseInvoiceRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\PUTReverseInvoiceResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v1/invoices/{invoiceId}/reverse', \OpenAPI\OpenAPI\Models\Operations\PUTReverseInvoiceRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "putReverseInvoiceType", "json");
        if ($body === null) {
            throw new \Exception('Request body is required');
        }
        $options = array_merge_recursive($options, $body);
        $options = array_merge_recursive($options, Utils\Utils::getHeaders($request));
        
        $httpResponse = $this->_defaultClient->request('PUT', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\PUTReverseInvoiceResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            $response->headers = $httpResponse->getHeaders();
            
            if (Utils\Utils::matchContentType($contentType, 'application/json; charset=utf-8')) {
                $serializer = Utils\JSON::createSerializer();
                $response->putReverseInvoiceResponseType = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\PutReverseInvoiceResponseType', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Update an invoice
     * 
     * Updates a specific invoice. 
     * 
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\PUTUpdateInvoiceRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\PUTUpdateInvoiceResponse
     */
	public function putUpdateInvoice(
        \OpenAPI\OpenAPI\Models\Operations\PUTUpdateInvoiceRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\PUTUpdateInvoiceResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v1/invoices/{invoiceId}', \OpenAPI\OpenAPI\Models\Operations\PUTUpdateInvoiceRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "putInvoiceType", "json");
        if ($body === null) {
            throw new \Exception('Request body is required');
        }
        $options = array_merge_recursive($options, $body);
        $options = array_merge_recursive($options, Utils\Utils::getHeaders($request));
        
        $httpResponse = $this->_defaultClient->request('PUT', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\PUTUpdateInvoiceResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            $response->headers = $httpResponse->getHeaders();
            
            if (Utils\Utils::matchContentType($contentType, 'application/json; charset=utf-8')) {
                $serializer = Utils\JSON::createSerializer();
                $response->putInvoiceResponseType = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\PutInvoiceResponseType', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Write off an invoice
     * 
     * **Note:** This operation is only available if you have [Invoice Settlement](https://knowledgecenter.zuora.com/Billing/Billing_and_Payments/Invoice_Settlement) enabled. The Invoice Settlement feature is generally available as of Zuora Billing Release 296 (March 2021). This feature includes Unapplied Payments, Credit and Debit Memo, and Invoice Item Settlement. If you want to enable Invoice Settlement, see [Invoice Settlement Enablement and Checklist Guide](https://knowledgecenter.zuora.com/Billing/Billing_and_Payments/Invoice_Settlement/Invoice_Settlement_Migration_Checklist_and_Guide) for more information.
     * 
     * Writes off a posted invoice. 
     * 
     * By writing off an invoice, a credit memo is created and applied to the invoice. The generated credit memo items and credit memo taxation items are applied to invoice items and invoice taxation items based on the configured default application rule. If an invoice is written off, the balance of each invoice item and invoice taxation item must be zero.
     * 
     * If you set the **Create credit memos mirroring invoice items billing rule** to **Yes**, you can write off an invoice even if all its items have zero balance.
     * 
     * **Restrictions**
     * 
     * You cannot write off an invoice if any of the following restrictions is met:
     * 
     * * The balance of an invoice has been changed before Invoice Settlement is enabled.
     * 
     *   For example, before Invoice Settlement is enabled, any credit balance adjustments, invoice item adjustments, or invoice adjustments have been applied to an invoice.
     * 
     * * An invoice contains more than 2,000 items in total, including invoice items, discount items, and taxation items.
     * 
     * See [Invoice Write-off](https://knowledgecenter.zuora.com/Billing/Billing_and_Payments/IA_Invoices/Invoice_Write-Off) for more information.        
     * 
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\PUTWriteOffInvoiceRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\PUTWriteOffInvoiceResponse
     */
	public function putWriteOffInvoice(
        \OpenAPI\OpenAPI\Models\Operations\PUTWriteOffInvoiceRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\PUTWriteOffInvoiceResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v1/invoices/{invoiceId}/write-off', \OpenAPI\OpenAPI\Models\Operations\PUTWriteOffInvoiceRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "putWriteOffInvoiceRequest", "json");
        if ($body === null) {
            throw new \Exception('Request body is required');
        }
        $options = array_merge_recursive($options, $body);
        $options = array_merge_recursive($options, Utils\Utils::getHeaders($request));
        
        $httpResponse = $this->_defaultClient->request('PUT', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\PUTWriteOffInvoiceResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            $response->headers = $httpResponse->getHeaders();
            
            if (Utils\Utils::matchContentType($contentType, 'application/json; charset=utf-8')) {
                $serializer = Utils\JSON::createSerializer();
                $response->putWriteOffInvoiceResponse = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\PUTWriteOffInvoiceResponse', 'json');
            }
        }

        return $response;
    }
}