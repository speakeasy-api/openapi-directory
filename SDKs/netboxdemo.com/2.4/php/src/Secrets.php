<?php

/**
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

declare(strict_types=1);

namespace OpenAPI\OpenAPI;

class Secrets 
{

	// SDK private variables namespaced with _ to avoid conflicts with API models
	private \GuzzleHttp\ClientInterface $_defaultClient;
	private \GuzzleHttp\ClientInterface $_securityClient;
	private string $_serverUrl;
	private string $_language;
	private string $_sdkVersion;
	private string $_genVersion;	

	/**
	 * @param \GuzzleHttp\ClientInterface $defaultClient
	 * @param \GuzzleHttp\ClientInterface $securityClient
	 * @param string $serverUrl
	 * @param string $language
	 * @param string $sdkVersion
	 * @param string $genVersion
	 */
	public function __construct(\GuzzleHttp\ClientInterface $defaultClient, \GuzzleHttp\ClientInterface $securityClient, string $serverUrl, string $language, string $sdkVersion, string $genVersion)
	{
		$this->_defaultClient = $defaultClient;
		$this->_securityClient = $securityClient;
		$this->_serverUrl = $serverUrl;
		$this->_language = $language;
		$this->_sdkVersion = $sdkVersion;
		$this->_genVersion = $genVersion;
	}
	
    /**
     * secretsChoicesList
     * 
     * @return \OpenAPI\OpenAPI\Models\Operations\SecretsChoicesListResponse
     */
	public function secretsChoicesList(
    ): \OpenAPI\OpenAPI\Models\Operations\SecretsChoicesListResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/secrets/_choices/');
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\SecretsChoicesListResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
        }

        return $response;
    }
	
    /**
     * secretsChoicesRead
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\SecretsChoicesReadRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\SecretsChoicesReadResponse
     */
	public function secretsChoicesRead(
        \OpenAPI\OpenAPI\Models\Operations\SecretsChoicesReadRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\SecretsChoicesReadResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/secrets/_choices/{id}/', \OpenAPI\OpenAPI\Models\Operations\SecretsChoicesReadRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\SecretsChoicesReadResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
        }

        return $response;
    }
	
    /**
     * This endpoint can be used to generate a new RSA key pair. The keys are returned in PEM format.
     * 
     *     {
     *         "public_key": "<public key>",
     *         "private_key": "<private key>"
     *     }
     * 
     * @return \OpenAPI\OpenAPI\Models\Operations\SecretsGenerateRsaKeyPairListResponse
     */
	public function secretsGenerateRsaKeyPairList(
    ): \OpenAPI\OpenAPI\Models\Operations\SecretsGenerateRsaKeyPairListResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/secrets/generate-rsa-key-pair/');
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\SecretsGenerateRsaKeyPairListResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
        }

        return $response;
    }
	
    /**
     * Retrieve a temporary session key to use for encrypting and decrypting secrets via the API. The user's private RSA
     * key is POSTed with the name `private_key`. An example:
     * 
     *     curl -v -X POST -H "Authorization: Token <token>" -H "Accept: application/json; indent=4" \
     *     --data-urlencode "private_key@<filename>" https://netbox/api/secrets/get-session-key/
     * 
     * This request will yield a base64-encoded session key to be included in an `X-Session-Key` header in future requests:
     * 
     *     {
     *         "session_key": "+8t4SI6XikgVmB5+/urhozx9O5qCQANyOk1MNe6taRf="
     *     }
     * 
     * This endpoint accepts one optional parameter: `preserve_key`. If True and a session key exists, the existing session
     * key will be returned instead of a new one.
     * 
     * @return \OpenAPI\OpenAPI\Models\Operations\SecretsGetSessionKeyCreateResponse
     */
	public function secretsGetSessionKeyCreate(
    ): \OpenAPI\OpenAPI\Models\Operations\SecretsGetSessionKeyCreateResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/secrets/get-session-key/');
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_securityClient->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\SecretsGetSessionKeyCreateResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 201) {
        }

        return $response;
    }
	
    /**
     * secretsSecretRolesCreate
     * 
     * @param \OpenAPI\OpenAPI\Models\Shared\SecretRoleInput $request
     * @return \OpenAPI\OpenAPI\Models\Operations\SecretsSecretRolesCreateResponse
     */
	public function secretsSecretRolesCreate(
        \OpenAPI\OpenAPI\Models\Shared\SecretRoleInput $request,
    ): \OpenAPI\OpenAPI\Models\Operations\SecretsSecretRolesCreateResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/secrets/secret-roles/');
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "request", "json");
        if ($body === null) {
            throw new \Exception('Request body is required');
        }
        $options = array_merge_recursive($options, $body);
        
        $httpResponse = $this->_securityClient->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\SecretsSecretRolesCreateResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 201) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->secretRole = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\SecretRole', 'json');
            }
        }

        return $response;
    }
	
    /**
     * secretsSecretRolesDelete
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\SecretsSecretRolesDeleteRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\SecretsSecretRolesDeleteResponse
     */
	public function secretsSecretRolesDelete(
        \OpenAPI\OpenAPI\Models\Operations\SecretsSecretRolesDeleteRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\SecretsSecretRolesDeleteResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/secrets/secret-roles/{id}/', \OpenAPI\OpenAPI\Models\Operations\SecretsSecretRolesDeleteRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_securityClient->request('DELETE', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\SecretsSecretRolesDeleteResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 204) {
        }

        return $response;
    }
	
    /**
     * secretsSecretRolesList
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\SecretsSecretRolesListRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\SecretsSecretRolesListResponse
     */
	public function secretsSecretRolesList(
        \OpenAPI\OpenAPI\Models\Operations\SecretsSecretRolesListRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\SecretsSecretRolesListResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/secrets/secret-roles/');
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\SecretsSecretRolesListRequest::class, $request, null));
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\SecretsSecretRolesListResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->secretsSecretRolesList200ApplicationJSONObject = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Operations\SecretsSecretRolesList200ApplicationJSON', 'json');
            }
        }

        return $response;
    }
	
    /**
     * secretsSecretRolesPartialUpdate
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\SecretsSecretRolesPartialUpdateRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\SecretsSecretRolesPartialUpdateResponse
     */
	public function secretsSecretRolesPartialUpdate(
        \OpenAPI\OpenAPI\Models\Operations\SecretsSecretRolesPartialUpdateRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\SecretsSecretRolesPartialUpdateResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/secrets/secret-roles/{id}/', \OpenAPI\OpenAPI\Models\Operations\SecretsSecretRolesPartialUpdateRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "secretRoleInput", "json");
        if ($body === null) {
            throw new \Exception('Request body is required');
        }
        $options = array_merge_recursive($options, $body);
        
        $httpResponse = $this->_securityClient->request('PATCH', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\SecretsSecretRolesPartialUpdateResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->secretRole = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\SecretRole', 'json');
            }
        }

        return $response;
    }
	
    /**
     * secretsSecretRolesRead
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\SecretsSecretRolesReadRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\SecretsSecretRolesReadResponse
     */
	public function secretsSecretRolesRead(
        \OpenAPI\OpenAPI\Models\Operations\SecretsSecretRolesReadRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\SecretsSecretRolesReadResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/secrets/secret-roles/{id}/', \OpenAPI\OpenAPI\Models\Operations\SecretsSecretRolesReadRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\SecretsSecretRolesReadResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->secretRole = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\SecretRole', 'json');
            }
        }

        return $response;
    }
	
    /**
     * secretsSecretRolesUpdate
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\SecretsSecretRolesUpdateRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\SecretsSecretRolesUpdateResponse
     */
	public function secretsSecretRolesUpdate(
        \OpenAPI\OpenAPI\Models\Operations\SecretsSecretRolesUpdateRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\SecretsSecretRolesUpdateResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/secrets/secret-roles/{id}/', \OpenAPI\OpenAPI\Models\Operations\SecretsSecretRolesUpdateRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "secretRoleInput", "json");
        if ($body === null) {
            throw new \Exception('Request body is required');
        }
        $options = array_merge_recursive($options, $body);
        
        $httpResponse = $this->_securityClient->request('PUT', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\SecretsSecretRolesUpdateResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->secretRole = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\SecretRole', 'json');
            }
        }

        return $response;
    }
	
    /**
     * secretsSecretsCreate
     * 
     * @param \OpenAPI\OpenAPI\Models\Shared\WritableSecretInput $request
     * @return \OpenAPI\OpenAPI\Models\Operations\SecretsSecretsCreateResponse
     */
	public function secretsSecretsCreate(
        \OpenAPI\OpenAPI\Models\Shared\WritableSecretInput $request,
    ): \OpenAPI\OpenAPI\Models\Operations\SecretsSecretsCreateResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/secrets/secrets/');
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "request", "json");
        if ($body === null) {
            throw new \Exception('Request body is required');
        }
        $options = array_merge_recursive($options, $body);
        
        $httpResponse = $this->_securityClient->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\SecretsSecretsCreateResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 201) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->secret = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\Secret', 'json');
            }
        }

        return $response;
    }
	
    /**
     * secretsSecretsDelete
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\SecretsSecretsDeleteRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\SecretsSecretsDeleteResponse
     */
	public function secretsSecretsDelete(
        \OpenAPI\OpenAPI\Models\Operations\SecretsSecretsDeleteRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\SecretsSecretsDeleteResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/secrets/secrets/{id}/', \OpenAPI\OpenAPI\Models\Operations\SecretsSecretsDeleteRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_securityClient->request('DELETE', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\SecretsSecretsDeleteResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 204) {
        }

        return $response;
    }
	
    /**
     * secretsSecretsList
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\SecretsSecretsListRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\SecretsSecretsListResponse
     */
	public function secretsSecretsList(
        \OpenAPI\OpenAPI\Models\Operations\SecretsSecretsListRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\SecretsSecretsListResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/secrets/secrets/');
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\SecretsSecretsListRequest::class, $request, null));
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\SecretsSecretsListResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->secretsSecretsList200ApplicationJSONObject = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Operations\SecretsSecretsList200ApplicationJSON', 'json');
            }
        }

        return $response;
    }
	
    /**
     * secretsSecretsPartialUpdate
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\SecretsSecretsPartialUpdateRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\SecretsSecretsPartialUpdateResponse
     */
	public function secretsSecretsPartialUpdate(
        \OpenAPI\OpenAPI\Models\Operations\SecretsSecretsPartialUpdateRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\SecretsSecretsPartialUpdateResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/secrets/secrets/{id}/', \OpenAPI\OpenAPI\Models\Operations\SecretsSecretsPartialUpdateRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "writableSecretInput", "json");
        if ($body === null) {
            throw new \Exception('Request body is required');
        }
        $options = array_merge_recursive($options, $body);
        
        $httpResponse = $this->_securityClient->request('PATCH', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\SecretsSecretsPartialUpdateResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->secret = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\Secret', 'json');
            }
        }

        return $response;
    }
	
    /**
     * secretsSecretsRead
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\SecretsSecretsReadRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\SecretsSecretsReadResponse
     */
	public function secretsSecretsRead(
        \OpenAPI\OpenAPI\Models\Operations\SecretsSecretsReadRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\SecretsSecretsReadResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/secrets/secrets/{id}/', \OpenAPI\OpenAPI\Models\Operations\SecretsSecretsReadRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\SecretsSecretsReadResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->secret = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\Secret', 'json');
            }
        }

        return $response;
    }
	
    /**
     * secretsSecretsUpdate
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\SecretsSecretsUpdateRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\SecretsSecretsUpdateResponse
     */
	public function secretsSecretsUpdate(
        \OpenAPI\OpenAPI\Models\Operations\SecretsSecretsUpdateRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\SecretsSecretsUpdateResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/secrets/secrets/{id}/', \OpenAPI\OpenAPI\Models\Operations\SecretsSecretsUpdateRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "writableSecretInput", "json");
        if ($body === null) {
            throw new \Exception('Request body is required');
        }
        $options = array_merge_recursive($options, $body);
        
        $httpResponse = $this->_securityClient->request('PUT', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\SecretsSecretsUpdateResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->secret = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\Secret', 'json');
            }
        }

        return $response;
    }
}