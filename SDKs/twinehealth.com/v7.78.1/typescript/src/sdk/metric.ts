/*
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

import * as utils from "../internal/utils";
import * as operations from "./models/operations";
import * as shared from "./models/shared";
import { AxiosInstance, AxiosRequestConfig, AxiosResponse } from "axios";

/**
 * A metric is a quantitative result for a patient. For example, vital signs, lab results, etc. are all metrics.
 */
export class Metric {
  _defaultClient: AxiosInstance;
  _securityClient: AxiosInstance;
  _serverURL: string;
  _language: string;
  _sdkVersion: string;
  _genVersion: string;

  constructor(
    defaultClient: AxiosInstance,
    securityClient: AxiosInstance,
    serverURL: string,
    language: string,
    sdkVersion: string,
    genVersion: string
  ) {
    this._defaultClient = defaultClient;
    this._securityClient = securityClient;
    this._serverURL = serverURL;
    this._language = language;
    this._sdkVersion = sdkVersion;
    this._genVersion = genVersion;
  }

  /**
   * Create patient health metrics
   *
   * @remarks
   * Create one or more patient health metrics.
   *
   * Example for creating a patient health result with a patient specified using `meta.query` instead of `id`:
   *
   * ```JSON
   *   {
   *     "data": {
   *       "type": "patient_health_metric",
   *        "attributes": {
   *          "code": {
   *            "system": "LOINC",
   *            "value": "13457-7"
   *          },
   *          "type": "ldl_cholesterol",
   *          "occurred_at": "2017-03-14T11:00:57.000Z",
   *          "value": 121,
   *          "unit": "mg/dl"
   *       },
   *       "relationships": {
   *         "patient": {
   *           "data": {
   *             "type": "patient",
   *             "meta": {
   *               "query": {
   *                 "identifier": {
   *                   "system": "medical-record-number",
   *                   "value": "121212"
   *                 },
   *                 "organization": "58c4554710123c5c40dbab81"
   *               }
   *             }
   *           }
   *         }
   *       }
   *     }
   *   }
   * ```
   *
   */
  createPatientHealthMetric(
    req: shared.CreatePatientHealthMetricRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.CreatePatientHealthMetricResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new shared.CreatePatientHealthMetricRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/patient_health_metric";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "request",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CreatePatientHealthMetricResponse =
        new operations.CreatePatientHealthMetricResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/vnd.api+json`)) {
            res.createPatientHealthMetricResponse = utils.objectToClass(
              httpRes?.data,
              shared.CreatePatientHealthMetricResponse
            );
          }
          break;
        case [401, 403, 409].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/vnd.api+json`)) {
            res.createOrUpdateErrorResponse = utils.objectToClass(
              httpRes?.data,
              shared.CreateOrUpdateErrorResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Get a patient health metric
   *
   * @remarks
   * Get the plan summary for a patient.
   */
  fetchPatientHealthMetric(
    req: operations.FetchPatientHealthMetricRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.FetchPatientHealthMetricResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.FetchPatientHealthMetricRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/patient_health_metric/{id}",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.FetchPatientHealthMetricResponse =
        new operations.FetchPatientHealthMetricResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/vnd.api+json`)) {
            res.fetchPatientHealthMetricResponse = utils.objectToClass(
              httpRes?.data,
              shared.FetchPatientHealthMetricResponse
            );
          }
          break;
        case [401, 403].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/vnd.api+json`)) {
            res.fetchErrorResponse = utils.objectToClass(
              httpRes?.data,
              shared.FetchErrorResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * List patient health metrics
   *
   * @remarks
   * Get a list of patient health metrics.
   */
  fetchPatientHealthMetrics(
    req: operations.FetchPatientHealthMetricsRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.FetchPatientHealthMetricsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.FetchPatientHealthMetricsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/patient_health_metric";

    const client: AxiosInstance = this._defaultClient;

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.FetchPatientHealthMetricsResponse =
        new operations.FetchPatientHealthMetricsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/vnd.api+json`)) {
            res.fetchPatientHealthMetricResponse = utils.objectToClass(
              httpRes?.data,
              shared.FetchPatientHealthMetricResponse
            );
          }
          break;
        case [401, 403, 409].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/vnd.api+json`)) {
            res.fetchErrorResponse = utils.objectToClass(
              httpRes?.data,
              shared.FetchErrorResponse
            );
          }
          break;
      }

      return res;
    });
  }
}
