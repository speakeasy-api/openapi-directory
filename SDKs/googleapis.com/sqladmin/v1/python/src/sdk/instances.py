"""Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT."""

import requests as requests_http
from . import utils
from sdk.models import operations, shared
from typing import Optional

class Instances:
    _client: requests_http.Session
    _security_client: requests_http.Session
    _server_url: str
    _language: str
    _sdk_version: str
    _gen_version: str

    def __init__(self, client: requests_http.Session, security_client: requests_http.Session, server_url: str, language: str, sdk_version: str, gen_version: str) -> None:
        self._client = client
        self._security_client = security_client
        self._server_url = server_url
        self._language = language
        self._sdk_version = sdk_version
        self._gen_version = gen_version
        
    def sql_instances_add_server_ca(self, request: operations.SQLInstancesAddServerCaRequest, security: operations.SQLInstancesAddServerCaSecurity) -> operations.SQLInstancesAddServerCaResponse:
        r"""Adds a new trusted Certificate Authority (CA) version for the specified instance. Required to prepare for a certificate rotation. If a CA version was previously added but never used in a certificate rotation, this operation replaces that version. There cannot be more than one CA version waiting to be rotated in."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.SQLInstancesAddServerCaRequest, base_url, '/v1/projects/{project}/instances/{instance}/addServerCa', request)
        
        query_params = utils.get_query_params(operations.SQLInstancesAddServerCaRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.SQLInstancesAddServerCaResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Operation])
                res.operation = out

        return res

    def sql_instances_clone(self, request: operations.SQLInstancesCloneRequest, security: operations.SQLInstancesCloneSecurity) -> operations.SQLInstancesCloneResponse:
        r"""Creates a Cloud SQL instance as a clone of the source instance. Using this operation might cause your instance to restart."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.SQLInstancesCloneRequest, base_url, '/v1/projects/{project}/instances/{instance}/clone', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "instances_clone_request", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        query_params = utils.get_query_params(operations.SQLInstancesCloneRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, params=query_params, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.SQLInstancesCloneResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Operation])
                res.operation = out

        return res

    def sql_instances_delete(self, request: operations.SQLInstancesDeleteRequest, security: operations.SQLInstancesDeleteSecurity) -> operations.SQLInstancesDeleteResponse:
        r"""Deletes a Cloud SQL instance."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.SQLInstancesDeleteRequest, base_url, '/v1/projects/{project}/instances/{instance}', request)
        
        query_params = utils.get_query_params(operations.SQLInstancesDeleteRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('DELETE', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.SQLInstancesDeleteResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Operation])
                res.operation = out

        return res

    def sql_instances_demote_master(self, request: operations.SQLInstancesDemoteMasterRequest, security: operations.SQLInstancesDemoteMasterSecurity) -> operations.SQLInstancesDemoteMasterResponse:
        r"""Demotes the stand-alone instance to be a Cloud SQL read replica for an external database server."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.SQLInstancesDemoteMasterRequest, base_url, '/v1/projects/{project}/instances/{instance}/demoteMaster', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "instances_demote_master_request", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        query_params = utils.get_query_params(operations.SQLInstancesDemoteMasterRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, params=query_params, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.SQLInstancesDemoteMasterResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Operation])
                res.operation = out

        return res

    def sql_instances_export(self, request: operations.SQLInstancesExportRequest, security: operations.SQLInstancesExportSecurity) -> operations.SQLInstancesExportResponse:
        r"""Exports data from a Cloud SQL instance to a Cloud Storage bucket as a SQL dump or CSV file."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.SQLInstancesExportRequest, base_url, '/v1/projects/{project}/instances/{instance}/export', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "instances_export_request", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        query_params = utils.get_query_params(operations.SQLInstancesExportRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, params=query_params, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.SQLInstancesExportResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Operation])
                res.operation = out

        return res

    def sql_instances_failover(self, request: operations.SQLInstancesFailoverRequest, security: operations.SQLInstancesFailoverSecurity) -> operations.SQLInstancesFailoverResponse:
        r"""Initiates a manual failover of a high availability (HA) primary instance to a standby instance, which becomes the primary instance. Users are then rerouted to the new primary. For more information, see the [Overview of high availability](https://cloud.google.com/sql/docs/mysql/high-availability) page in the Cloud SQL documentation. If using Legacy HA (MySQL only), this causes the instance to failover to its failover replica instance."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.SQLInstancesFailoverRequest, base_url, '/v1/projects/{project}/instances/{instance}/failover', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "instances_failover_request", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        query_params = utils.get_query_params(operations.SQLInstancesFailoverRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, params=query_params, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.SQLInstancesFailoverResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Operation])
                res.operation = out

        return res

    def sql_instances_get(self, request: operations.SQLInstancesGetRequest, security: operations.SQLInstancesGetSecurity) -> operations.SQLInstancesGetResponse:
        r"""Retrieves a resource containing information about a Cloud SQL instance."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.SQLInstancesGetRequest, base_url, '/v1/projects/{project}/instances/{instance}', request)
        
        query_params = utils.get_query_params(operations.SQLInstancesGetRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.SQLInstancesGetResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.DatabaseInstance])
                res.database_instance = out

        return res

    def sql_instances_import(self, request: operations.SQLInstancesImportRequest, security: operations.SQLInstancesImportSecurity) -> operations.SQLInstancesImportResponse:
        r"""Imports data into a Cloud SQL instance from a SQL dump or CSV file in Cloud Storage."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.SQLInstancesImportRequest, base_url, '/v1/projects/{project}/instances/{instance}/import', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "instances_import_request", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        query_params = utils.get_query_params(operations.SQLInstancesImportRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, params=query_params, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.SQLInstancesImportResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Operation])
                res.operation = out

        return res

    def sql_instances_insert(self, request: operations.SQLInstancesInsertRequest, security: operations.SQLInstancesInsertSecurity) -> operations.SQLInstancesInsertResponse:
        r"""Creates a new Cloud SQL instance."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.SQLInstancesInsertRequest, base_url, '/v1/projects/{project}/instances', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "database_instance_input", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        query_params = utils.get_query_params(operations.SQLInstancesInsertRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, params=query_params, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.SQLInstancesInsertResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Operation])
                res.operation = out

        return res

    def sql_instances_list(self, request: operations.SQLInstancesListRequest, security: operations.SQLInstancesListSecurity) -> operations.SQLInstancesListResponse:
        r"""Lists instances under a given project."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.SQLInstancesListRequest, base_url, '/v1/projects/{project}/instances', request)
        
        query_params = utils.get_query_params(operations.SQLInstancesListRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.SQLInstancesListResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.InstancesListResponse])
                res.instances_list_response = out

        return res

    def sql_instances_list_server_cas(self, request: operations.SQLInstancesListServerCasRequest, security: operations.SQLInstancesListServerCasSecurity) -> operations.SQLInstancesListServerCasResponse:
        r"""Lists all of the trusted Certificate Authorities (CAs) for the specified instance. There can be up to three CAs listed: the CA that was used to sign the certificate that is currently in use, a CA that has been added but not yet used to sign a certificate, and a CA used to sign a certificate that has previously rotated out."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.SQLInstancesListServerCasRequest, base_url, '/v1/projects/{project}/instances/{instance}/listServerCas', request)
        
        query_params = utils.get_query_params(operations.SQLInstancesListServerCasRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.SQLInstancesListServerCasResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.InstancesListServerCasResponse])
                res.instances_list_server_cas_response = out

        return res

    def sql_instances_patch(self, request: operations.SQLInstancesPatchRequest, security: operations.SQLInstancesPatchSecurity) -> operations.SQLInstancesPatchResponse:
        r"""Partially updates settings of a Cloud SQL instance by merging the request with the current configuration. This method supports patch semantics."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.SQLInstancesPatchRequest, base_url, '/v1/projects/{project}/instances/{instance}', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "database_instance_input", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        query_params = utils.get_query_params(operations.SQLInstancesPatchRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('PATCH', url, params=query_params, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.SQLInstancesPatchResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Operation])
                res.operation = out

        return res

    def sql_instances_promote_replica(self, request: operations.SQLInstancesPromoteReplicaRequest, security: operations.SQLInstancesPromoteReplicaSecurity) -> operations.SQLInstancesPromoteReplicaResponse:
        r"""Promotes the read replica instance to be a stand-alone Cloud SQL instance. Using this operation might cause your instance to restart."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.SQLInstancesPromoteReplicaRequest, base_url, '/v1/projects/{project}/instances/{instance}/promoteReplica', request)
        
        query_params = utils.get_query_params(operations.SQLInstancesPromoteReplicaRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.SQLInstancesPromoteReplicaResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Operation])
                res.operation = out

        return res

    def sql_instances_reset_ssl_config(self, request: operations.SQLInstancesResetSslConfigRequest, security: operations.SQLInstancesResetSslConfigSecurity) -> operations.SQLInstancesResetSslConfigResponse:
        r"""Deletes all client certificates and generates a new server SSL certificate for the instance."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.SQLInstancesResetSslConfigRequest, base_url, '/v1/projects/{project}/instances/{instance}/resetSslConfig', request)
        
        query_params = utils.get_query_params(operations.SQLInstancesResetSslConfigRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.SQLInstancesResetSslConfigResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Operation])
                res.operation = out

        return res

    def sql_instances_restart(self, request: operations.SQLInstancesRestartRequest, security: operations.SQLInstancesRestartSecurity) -> operations.SQLInstancesRestartResponse:
        r"""Restarts a Cloud SQL instance."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.SQLInstancesRestartRequest, base_url, '/v1/projects/{project}/instances/{instance}/restart', request)
        
        query_params = utils.get_query_params(operations.SQLInstancesRestartRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.SQLInstancesRestartResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Operation])
                res.operation = out

        return res

    def sql_instances_restore_backup(self, request: operations.SQLInstancesRestoreBackupRequest, security: operations.SQLInstancesRestoreBackupSecurity) -> operations.SQLInstancesRestoreBackupResponse:
        r"""Restores a backup of a Cloud SQL instance. Using this operation might cause your instance to restart."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.SQLInstancesRestoreBackupRequest, base_url, '/v1/projects/{project}/instances/{instance}/restoreBackup', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "instances_restore_backup_request", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        query_params = utils.get_query_params(operations.SQLInstancesRestoreBackupRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, params=query_params, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.SQLInstancesRestoreBackupResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Operation])
                res.operation = out

        return res

    def sql_instances_rotate_server_ca(self, request: operations.SQLInstancesRotateServerCaRequest, security: operations.SQLInstancesRotateServerCaSecurity) -> operations.SQLInstancesRotateServerCaResponse:
        r"""Rotates the server certificate to one signed by the Certificate Authority (CA) version previously added with the addServerCA method."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.SQLInstancesRotateServerCaRequest, base_url, '/v1/projects/{project}/instances/{instance}/rotateServerCa', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "instances_rotate_server_ca_request", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        query_params = utils.get_query_params(operations.SQLInstancesRotateServerCaRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, params=query_params, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.SQLInstancesRotateServerCaResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Operation])
                res.operation = out

        return res

    def sql_instances_start_replica(self, request: operations.SQLInstancesStartReplicaRequest, security: operations.SQLInstancesStartReplicaSecurity) -> operations.SQLInstancesStartReplicaResponse:
        r"""Starts the replication in the read replica instance."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.SQLInstancesStartReplicaRequest, base_url, '/v1/projects/{project}/instances/{instance}/startReplica', request)
        
        query_params = utils.get_query_params(operations.SQLInstancesStartReplicaRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.SQLInstancesStartReplicaResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Operation])
                res.operation = out

        return res

    def sql_instances_stop_replica(self, request: operations.SQLInstancesStopReplicaRequest, security: operations.SQLInstancesStopReplicaSecurity) -> operations.SQLInstancesStopReplicaResponse:
        r"""Stops the replication in the read replica instance."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.SQLInstancesStopReplicaRequest, base_url, '/v1/projects/{project}/instances/{instance}/stopReplica', request)
        
        query_params = utils.get_query_params(operations.SQLInstancesStopReplicaRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.SQLInstancesStopReplicaResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Operation])
                res.operation = out

        return res

    def sql_instances_truncate_log(self, request: operations.SQLInstancesTruncateLogRequest, security: operations.SQLInstancesTruncateLogSecurity) -> operations.SQLInstancesTruncateLogResponse:
        r"""Truncate MySQL general and slow query log tables MySQL only."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.SQLInstancesTruncateLogRequest, base_url, '/v1/projects/{project}/instances/{instance}/truncateLog', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "instances_truncate_log_request", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        query_params = utils.get_query_params(operations.SQLInstancesTruncateLogRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, params=query_params, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.SQLInstancesTruncateLogResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Operation])
                res.operation = out

        return res

    def sql_instances_update(self, request: operations.SQLInstancesUpdateRequest, security: operations.SQLInstancesUpdateSecurity) -> operations.SQLInstancesUpdateResponse:
        r"""Updates settings of a Cloud SQL instance. Using this operation might cause your instance to restart."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.SQLInstancesUpdateRequest, base_url, '/v1/projects/{project}/instances/{instance}', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "database_instance_input", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        query_params = utils.get_query_params(operations.SQLInstancesUpdateRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('PUT', url, params=query_params, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.SQLInstancesUpdateResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Operation])
                res.operation = out

        return res

    