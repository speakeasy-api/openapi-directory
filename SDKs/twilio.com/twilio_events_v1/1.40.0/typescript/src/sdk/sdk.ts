/*
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

import * as utils from "../internal/utils";
import * as operations from "./models/operations";
import * as shared from "./models/shared";
import axios from "axios";
import { AxiosInstance, AxiosRequestConfig, AxiosResponse } from "axios";

/**
 * Contains the list of servers available to the SDK
 */
export const ServerList = ["https://events.twilio.com"] as const;

/**
 * The available configuration options for the SDK
 */
export type SDKProps = {
  /**
   * Allows overriding the default axios client used by the SDK
   */
  defaultClient?: AxiosInstance;
  /**
   * Allows overriding the default server URL used by the SDK
   */
  serverURL?: string;
};

/**
 * This is the public Twilio REST API.
 */
export class SDK {
  public _defaultClient: AxiosInstance;
  public _securityClient: AxiosInstance;
  public _serverURL: string;
  private _language = "typescript";
  private _sdkVersion = "0.0.1";
  private _genVersion = "internal";
  private _globals: any;

  constructor(props?: SDKProps) {
    this._serverURL = props?.serverURL ?? ServerList[0];

    this._defaultClient =
      props?.defaultClient ?? axios.create({ baseURL: this._serverURL });
    this._securityClient = this._defaultClient;
  }

  /**
   * Create a new Sink
   */
  createSink(
    req: operations.CreateSinkCreateSinkRequest,
    security: operations.CreateSinkSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.CreateSinkResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CreateSinkCreateSinkRequest(req);
    }

    let baseURL: string = operations.CreateSinkServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = baseURL.replace(/\/$/, "") + "/v1/Sinks";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "request",
        "form"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.CreateSinkSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CreateSinkResponse =
        new operations.CreateSinkResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.eventsV1Sink = utils.objectToClass(
              httpRes?.data,
              shared.EventsV1Sink
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Create a new Sink Test Event for the given Sink.
   */
  createSinkTest(
    req: operations.CreateSinkTestRequest,
    security: operations.CreateSinkTestSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.CreateSinkTestResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CreateSinkTestRequest(req);
    }

    let baseURL: string = operations.CreateSinkTestServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(baseURL, "/v1/Sinks/{Sid}/Test", req);
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.CreateSinkTestSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "post",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CreateSinkTestResponse =
        new operations.CreateSinkTestResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.eventsV1SinkSinkTest = utils.objectToClass(
              httpRes?.data,
              shared.EventsV1SinkSinkTest
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Validate that a test event for a Sink was received.
   */
  createSinkValidate(
    req: operations.CreateSinkValidateRequest,
    security: operations.CreateSinkValidateSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.CreateSinkValidateResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CreateSinkValidateRequest(req);
    }

    let baseURL: string = operations.CreateSinkValidateServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v1/Sinks/{Sid}/Validate",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "form"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.CreateSinkValidateSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CreateSinkValidateResponse =
        new operations.CreateSinkValidateResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.eventsV1SinkSinkValidate = utils.objectToClass(
              httpRes?.data,
              shared.EventsV1SinkSinkValidate
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Create a new Subscribed Event type for the subscription
   */
  createSubscribedEvent(
    req: operations.CreateSubscribedEventRequest,
    security: operations.CreateSubscribedEventSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.CreateSubscribedEventResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CreateSubscribedEventRequest(req);
    }

    let baseURL: string = operations.CreateSubscribedEventServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v1/Subscriptions/{SubscriptionSid}/SubscribedEvents",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "form"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.CreateSubscribedEventSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CreateSubscribedEventResponse =
        new operations.CreateSubscribedEventResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.eventsV1SubscriptionSubscribedEvent = utils.objectToClass(
              httpRes?.data,
              shared.EventsV1SubscriptionSubscribedEvent
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Create a new Subscription.
   */
  createSubscription(
    req: operations.CreateSubscriptionCreateSubscriptionRequest,
    security: operations.CreateSubscriptionSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.CreateSubscriptionResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CreateSubscriptionCreateSubscriptionRequest(req);
    }

    let baseURL: string = operations.CreateSubscriptionServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = baseURL.replace(/\/$/, "") + "/v1/Subscriptions";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "request",
        "form"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.CreateSubscriptionSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CreateSubscriptionResponse =
        new operations.CreateSubscriptionResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.eventsV1Subscription = utils.objectToClass(
              httpRes?.data,
              shared.EventsV1Subscription
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Delete a specific Sink.
   */
  deleteSink(
    req: operations.DeleteSinkRequest,
    security: operations.DeleteSinkSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.DeleteSinkResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DeleteSinkRequest(req);
    }

    let baseURL: string = operations.DeleteSinkServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(baseURL, "/v1/Sinks/{Sid}", req);
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.DeleteSinkSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DeleteSinkResponse =
        new operations.DeleteSinkResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
      }

      return res;
    });
  }

  /**
   * Remove an event type from a subscription.
   */
  deleteSubscribedEvent(
    req: operations.DeleteSubscribedEventRequest,
    security: operations.DeleteSubscribedEventSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.DeleteSubscribedEventResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DeleteSubscribedEventRequest(req);
    }

    let baseURL: string = operations.DeleteSubscribedEventServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v1/Subscriptions/{SubscriptionSid}/SubscribedEvents/{Type}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.DeleteSubscribedEventSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DeleteSubscribedEventResponse =
        new operations.DeleteSubscribedEventResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
      }

      return res;
    });
  }

  /**
   * Delete a specific Subscription.
   */
  deleteSubscription(
    req: operations.DeleteSubscriptionRequest,
    security: operations.DeleteSubscriptionSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.DeleteSubscriptionResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DeleteSubscriptionRequest(req);
    }

    let baseURL: string = operations.DeleteSubscriptionServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v1/Subscriptions/{Sid}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.DeleteSubscriptionSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DeleteSubscriptionResponse =
        new operations.DeleteSubscriptionResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
      }

      return res;
    });
  }

  /**
   * Fetch a specific Event Type.
   */
  fetchEventType(
    req: operations.FetchEventTypeRequest,
    security: operations.FetchEventTypeSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.FetchEventTypeResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.FetchEventTypeRequest(req);
    }

    let baseURL: string = operations.FetchEventTypeServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(baseURL, "/v1/Types/{Type}", req);
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.FetchEventTypeSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.FetchEventTypeResponse =
        new operations.FetchEventTypeResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.eventsV1EventType = utils.objectToClass(
              httpRes?.data,
              shared.EventsV1EventType
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Fetch a specific schema with its nested versions.
   */
  fetchSchema(
    req: operations.FetchSchemaRequest,
    security: operations.FetchSchemaSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.FetchSchemaResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.FetchSchemaRequest(req);
    }

    let baseURL: string = operations.FetchSchemaServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(baseURL, "/v1/Schemas/{Id}", req);
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.FetchSchemaSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.FetchSchemaResponse =
        new operations.FetchSchemaResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.eventsV1Schema = utils.objectToClass(
              httpRes?.data,
              shared.EventsV1Schema
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Fetch a specific schema and version.
   */
  fetchSchemaVersion(
    req: operations.FetchSchemaVersionRequest,
    security: operations.FetchSchemaVersionSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.FetchSchemaVersionResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.FetchSchemaVersionRequest(req);
    }

    let baseURL: string = operations.FetchSchemaVersionServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v1/Schemas/{Id}/Versions/{SchemaVersion}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.FetchSchemaVersionSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.FetchSchemaVersionResponse =
        new operations.FetchSchemaVersionResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.eventsV1SchemaSchemaVersion = utils.objectToClass(
              httpRes?.data,
              shared.EventsV1SchemaSchemaVersion
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Fetch a specific Sink.
   */
  fetchSink(
    req: operations.FetchSinkRequest,
    security: operations.FetchSinkSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.FetchSinkResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.FetchSinkRequest(req);
    }

    let baseURL: string = operations.FetchSinkServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(baseURL, "/v1/Sinks/{Sid}", req);
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.FetchSinkSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.FetchSinkResponse =
        new operations.FetchSinkResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.eventsV1Sink = utils.objectToClass(
              httpRes?.data,
              shared.EventsV1Sink
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Read an Event for a Subscription.
   */
  fetchSubscribedEvent(
    req: operations.FetchSubscribedEventRequest,
    security: operations.FetchSubscribedEventSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.FetchSubscribedEventResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.FetchSubscribedEventRequest(req);
    }

    let baseURL: string = operations.FetchSubscribedEventServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v1/Subscriptions/{SubscriptionSid}/SubscribedEvents/{Type}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.FetchSubscribedEventSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.FetchSubscribedEventResponse =
        new operations.FetchSubscribedEventResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.eventsV1SubscriptionSubscribedEvent = utils.objectToClass(
              httpRes?.data,
              shared.EventsV1SubscriptionSubscribedEvent
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Fetch a specific Subscription.
   */
  fetchSubscription(
    req: operations.FetchSubscriptionRequest,
    security: operations.FetchSubscriptionSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.FetchSubscriptionResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.FetchSubscriptionRequest(req);
    }

    let baseURL: string = operations.FetchSubscriptionServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v1/Subscriptions/{Sid}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.FetchSubscriptionSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.FetchSubscriptionResponse =
        new operations.FetchSubscriptionResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.eventsV1Subscription = utils.objectToClass(
              httpRes?.data,
              shared.EventsV1Subscription
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Retrieve a paginated list of all the available Event Types.
   */
  listEventType(
    req: operations.ListEventTypeRequest,
    security: operations.ListEventTypeSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.ListEventTypeResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ListEventTypeRequest(req);
    }

    let baseURL: string = operations.ListEventTypeServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = baseURL.replace(/\/$/, "") + "/v1/Types";
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ListEventTypeSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ListEventTypeResponse =
        new operations.ListEventTypeResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listEventTypeResponse = utils.objectToClass(
              httpRes?.data,
              operations.ListEventTypeListEventTypeResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Retrieve a paginated list of versions of the schema.
   */
  listSchemaVersion(
    req: operations.ListSchemaVersionRequest,
    security: operations.ListSchemaVersionSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.ListSchemaVersionResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ListSchemaVersionRequest(req);
    }

    let baseURL: string = operations.ListSchemaVersionServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v1/Schemas/{Id}/Versions",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ListSchemaVersionSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ListSchemaVersionResponse =
        new operations.ListSchemaVersionResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listSchemaVersionResponse = utils.objectToClass(
              httpRes?.data,
              operations.ListSchemaVersionListSchemaVersionResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Retrieve a paginated list of Sinks belonging to the account used to make the request.
   */
  listSink(
    req: operations.ListSinkRequest,
    security: operations.ListSinkSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.ListSinkResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ListSinkRequest(req);
    }

    let baseURL: string = operations.ListSinkServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = baseURL.replace(/\/$/, "") + "/v1/Sinks";
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ListSinkSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ListSinkResponse = new operations.ListSinkResponse({
        statusCode: httpRes.status,
        contentType: contentType,
        rawResponse: httpRes,
      });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listSinkResponse = utils.objectToClass(
              httpRes?.data,
              operations.ListSinkListSinkResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Retrieve a list of all Subscribed Event types for a Subscription.
   */
  listSubscribedEvent(
    req: operations.ListSubscribedEventRequest,
    security: operations.ListSubscribedEventSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.ListSubscribedEventResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ListSubscribedEventRequest(req);
    }

    let baseURL: string = operations.ListSubscribedEventServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v1/Subscriptions/{SubscriptionSid}/SubscribedEvents",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ListSubscribedEventSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ListSubscribedEventResponse =
        new operations.ListSubscribedEventResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listSubscribedEventResponse = utils.objectToClass(
              httpRes?.data,
              operations.ListSubscribedEventListSubscribedEventResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Retrieve a paginated list of Subscriptions belonging to the account used to make the request.
   */
  listSubscription(
    req: operations.ListSubscriptionRequest,
    security: operations.ListSubscriptionSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.ListSubscriptionResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ListSubscriptionRequest(req);
    }

    let baseURL: string = operations.ListSubscriptionServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = baseURL.replace(/\/$/, "") + "/v1/Subscriptions";
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ListSubscriptionSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ListSubscriptionResponse =
        new operations.ListSubscriptionResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listSubscriptionResponse = utils.objectToClass(
              httpRes?.data,
              operations.ListSubscriptionListSubscriptionResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Update a specific Sink
   */
  updateSink(
    req: operations.UpdateSinkRequest,
    security: operations.UpdateSinkSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.UpdateSinkResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.UpdateSinkRequest(req);
    }

    let baseURL: string = operations.UpdateSinkServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(baseURL, "/v1/Sinks/{Sid}", req);

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "form"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.UpdateSinkSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UpdateSinkResponse =
        new operations.UpdateSinkResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.eventsV1Sink = utils.objectToClass(
              httpRes?.data,
              shared.EventsV1Sink
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Update an Event for a Subscription.
   */
  updateSubscribedEvent(
    req: operations.UpdateSubscribedEventRequest,
    security: operations.UpdateSubscribedEventSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.UpdateSubscribedEventResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.UpdateSubscribedEventRequest(req);
    }

    let baseURL: string = operations.UpdateSubscribedEventServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v1/Subscriptions/{SubscriptionSid}/SubscribedEvents/{Type}",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "form"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.UpdateSubscribedEventSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UpdateSubscribedEventResponse =
        new operations.UpdateSubscribedEventResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.eventsV1SubscriptionSubscribedEvent = utils.objectToClass(
              httpRes?.data,
              shared.EventsV1SubscriptionSubscribedEvent
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Update a Subscription.
   */
  updateSubscription(
    req: operations.UpdateSubscriptionRequest,
    security: operations.UpdateSubscriptionSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.UpdateSubscriptionResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.UpdateSubscriptionRequest(req);
    }

    let baseURL: string = operations.UpdateSubscriptionServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v1/Subscriptions/{Sid}",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "form"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.UpdateSubscriptionSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UpdateSubscriptionResponse =
        new operations.UpdateSubscriptionResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.eventsV1Subscription = utils.objectToClass(
              httpRes?.data,
              shared.EventsV1Subscription
            );
          }
          break;
      }

      return res;
    });
  }
}
