/*
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

import * as utils from "../internal/utils";
import * as operations from "./models/operations";
import * as shared from "./models/shared";
import { AxiosInstance, AxiosRequestConfig, AxiosResponse } from "axios";

export class NetworkEndpointGroups {
  _defaultClient: AxiosInstance;
  _securityClient: AxiosInstance;
  _serverURL: string;
  _language: string;
  _sdkVersion: string;
  _genVersion: string;

  constructor(
    defaultClient: AxiosInstance,
    securityClient: AxiosInstance,
    serverURL: string,
    language: string,
    sdkVersion: string,
    genVersion: string
  ) {
    this._defaultClient = defaultClient;
    this._securityClient = securityClient;
    this._serverURL = serverURL;
    this._language = language;
    this._sdkVersion = sdkVersion;
    this._genVersion = genVersion;
  }

  /**
   * Retrieves the list of network endpoint groups and sorts them by zone.
   */
  computeNetworkEndpointGroupsAggregatedList(
    req: operations.ComputeNetworkEndpointGroupsAggregatedListRequest,
    security: operations.ComputeNetworkEndpointGroupsAggregatedListSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.ComputeNetworkEndpointGroupsAggregatedListResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ComputeNetworkEndpointGroupsAggregatedListRequest(
        req
      );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/projects/{project}/aggregated/networkEndpointGroups",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.ComputeNetworkEndpointGroupsAggregatedListSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ComputeNetworkEndpointGroupsAggregatedListResponse =
        new operations.ComputeNetworkEndpointGroupsAggregatedListResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.networkEndpointGroupAggregatedList = utils.objectToClass(
              httpRes?.data,
              shared.NetworkEndpointGroupAggregatedList
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Attach a list of network endpoints to the specified network endpoint group.
   */
  computeNetworkEndpointGroupsAttachNetworkEndpoints(
    req: operations.ComputeNetworkEndpointGroupsAttachNetworkEndpointsRequest,
    security: operations.ComputeNetworkEndpointGroupsAttachNetworkEndpointsSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.ComputeNetworkEndpointGroupsAttachNetworkEndpointsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.ComputeNetworkEndpointGroupsAttachNetworkEndpointsRequest(
          req
        );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/projects/{project}/zones/{zone}/networkEndpointGroups/{networkEndpointGroup}/attachNetworkEndpoints",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "networkEndpointGroupsAttachEndpointsRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.ComputeNetworkEndpointGroupsAttachNetworkEndpointsSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ComputeNetworkEndpointGroupsAttachNetworkEndpointsResponse =
        new operations.ComputeNetworkEndpointGroupsAttachNetworkEndpointsResponse(
          {
            statusCode: httpRes.status,
            contentType: contentType,
            rawResponse: httpRes,
          }
        );
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.operation = utils.objectToClass(
              httpRes?.data,
              shared.Operation
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Deletes the specified network endpoint group. The network endpoints in the NEG and the VM instances they belong to are not terminated when the NEG is deleted. Note that the NEG cannot be deleted if there are backend services referencing it.
   */
  computeNetworkEndpointGroupsDelete(
    req: operations.ComputeNetworkEndpointGroupsDeleteRequest,
    security: operations.ComputeNetworkEndpointGroupsDeleteSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.ComputeNetworkEndpointGroupsDeleteResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ComputeNetworkEndpointGroupsDeleteRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/projects/{project}/zones/{zone}/networkEndpointGroups/{networkEndpointGroup}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ComputeNetworkEndpointGroupsDeleteSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ComputeNetworkEndpointGroupsDeleteResponse =
        new operations.ComputeNetworkEndpointGroupsDeleteResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.operation = utils.objectToClass(
              httpRes?.data,
              shared.Operation
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Detach a list of network endpoints from the specified network endpoint group.
   */
  computeNetworkEndpointGroupsDetachNetworkEndpoints(
    req: operations.ComputeNetworkEndpointGroupsDetachNetworkEndpointsRequest,
    security: operations.ComputeNetworkEndpointGroupsDetachNetworkEndpointsSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.ComputeNetworkEndpointGroupsDetachNetworkEndpointsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.ComputeNetworkEndpointGroupsDetachNetworkEndpointsRequest(
          req
        );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/projects/{project}/zones/{zone}/networkEndpointGroups/{networkEndpointGroup}/detachNetworkEndpoints",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "networkEndpointGroupsDetachEndpointsRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.ComputeNetworkEndpointGroupsDetachNetworkEndpointsSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ComputeNetworkEndpointGroupsDetachNetworkEndpointsResponse =
        new operations.ComputeNetworkEndpointGroupsDetachNetworkEndpointsResponse(
          {
            statusCode: httpRes.status,
            contentType: contentType,
            rawResponse: httpRes,
          }
        );
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.operation = utils.objectToClass(
              httpRes?.data,
              shared.Operation
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Returns the specified network endpoint group.
   */
  computeNetworkEndpointGroupsGet(
    req: operations.ComputeNetworkEndpointGroupsGetRequest,
    security: operations.ComputeNetworkEndpointGroupsGetSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.ComputeNetworkEndpointGroupsGetResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ComputeNetworkEndpointGroupsGetRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/projects/{project}/zones/{zone}/networkEndpointGroups/{networkEndpointGroup}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ComputeNetworkEndpointGroupsGetSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ComputeNetworkEndpointGroupsGetResponse =
        new operations.ComputeNetworkEndpointGroupsGetResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.networkEndpointGroup = utils.objectToClass(
              httpRes?.data,
              shared.NetworkEndpointGroup
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Creates a network endpoint group in the specified project using the parameters that are included in the request.
   */
  computeNetworkEndpointGroupsInsert(
    req: operations.ComputeNetworkEndpointGroupsInsertRequest,
    security: operations.ComputeNetworkEndpointGroupsInsertSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.ComputeNetworkEndpointGroupsInsertResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ComputeNetworkEndpointGroupsInsertRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/projects/{project}/zones/{zone}/networkEndpointGroups",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "networkEndpointGroup",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ComputeNetworkEndpointGroupsInsertSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ComputeNetworkEndpointGroupsInsertResponse =
        new operations.ComputeNetworkEndpointGroupsInsertResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.operation = utils.objectToClass(
              httpRes?.data,
              shared.Operation
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Retrieves the list of network endpoint groups that are located in the specified project and zone.
   */
  computeNetworkEndpointGroupsList(
    req: operations.ComputeNetworkEndpointGroupsListRequest,
    security: operations.ComputeNetworkEndpointGroupsListSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.ComputeNetworkEndpointGroupsListResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ComputeNetworkEndpointGroupsListRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/projects/{project}/zones/{zone}/networkEndpointGroups",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ComputeNetworkEndpointGroupsListSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ComputeNetworkEndpointGroupsListResponse =
        new operations.ComputeNetworkEndpointGroupsListResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.networkEndpointGroupList = utils.objectToClass(
              httpRes?.data,
              shared.NetworkEndpointGroupList
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Lists the network endpoints in the specified network endpoint group.
   */
  computeNetworkEndpointGroupsListNetworkEndpoints(
    req: operations.ComputeNetworkEndpointGroupsListNetworkEndpointsRequest,
    security: operations.ComputeNetworkEndpointGroupsListNetworkEndpointsSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.ComputeNetworkEndpointGroupsListNetworkEndpointsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.ComputeNetworkEndpointGroupsListNetworkEndpointsRequest(
          req
        );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/projects/{project}/zones/{zone}/networkEndpointGroups/{networkEndpointGroup}/listNetworkEndpoints",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "networkEndpointGroupsListEndpointsRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.ComputeNetworkEndpointGroupsListNetworkEndpointsSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ComputeNetworkEndpointGroupsListNetworkEndpointsResponse =
        new operations.ComputeNetworkEndpointGroupsListNetworkEndpointsResponse(
          {
            statusCode: httpRes.status,
            contentType: contentType,
            rawResponse: httpRes,
          }
        );
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.networkEndpointGroupsListNetworkEndpoints = utils.objectToClass(
              httpRes?.data,
              shared.NetworkEndpointGroupsListNetworkEndpoints
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Returns permissions that a caller has on the specified resource.
   */
  computeNetworkEndpointGroupsTestIamPermissions(
    req: operations.ComputeNetworkEndpointGroupsTestIamPermissionsRequest,
    security: operations.ComputeNetworkEndpointGroupsTestIamPermissionsSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.ComputeNetworkEndpointGroupsTestIamPermissionsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.ComputeNetworkEndpointGroupsTestIamPermissionsRequest(
          req
        );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/projects/{project}/zones/{zone}/networkEndpointGroups/{resource}/testIamPermissions",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "testPermissionsRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.ComputeNetworkEndpointGroupsTestIamPermissionsSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ComputeNetworkEndpointGroupsTestIamPermissionsResponse =
        new operations.ComputeNetworkEndpointGroupsTestIamPermissionsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.testPermissionsResponse = utils.objectToClass(
              httpRes?.data,
              shared.TestPermissionsResponse
            );
          }
          break;
      }

      return res;
    });
  }
}
