// Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.

package shared

import (
	"encoding/json"
	"fmt"
)

// BreakpointActionEnum - Action that the agent should perform when the code at the breakpoint location is hit.
type BreakpointActionEnum string

const (
	BreakpointActionEnumCapture BreakpointActionEnum = "CAPTURE"
	BreakpointActionEnumLog     BreakpointActionEnum = "LOG"
)

func (e *BreakpointActionEnum) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return err
	}
	switch s {
	case "CAPTURE":
		fallthrough
	case "LOG":
		*e = BreakpointActionEnum(s)
		return nil
	default:
		return fmt.Errorf("invalid value for BreakpointActionEnum: %s", s)
	}
}

// BreakpointLogLevelEnum - Indicates the severity of the log. Only relevant when action is `LOG`.
type BreakpointLogLevelEnum string

const (
	BreakpointLogLevelEnumInfo    BreakpointLogLevelEnum = "INFO"
	BreakpointLogLevelEnumWarning BreakpointLogLevelEnum = "WARNING"
	BreakpointLogLevelEnumError   BreakpointLogLevelEnum = "ERROR"
)

func (e *BreakpointLogLevelEnum) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return err
	}
	switch s {
	case "INFO":
		fallthrough
	case "WARNING":
		fallthrough
	case "ERROR":
		*e = BreakpointLogLevelEnum(s)
		return nil
	default:
		return fmt.Errorf("invalid value for BreakpointLogLevelEnum: %s", s)
	}
}

// BreakpointStateEnum - The current state of the breakpoint.
type BreakpointStateEnum string

const (
	BreakpointStateEnumStateUnspecified         BreakpointStateEnum = "STATE_UNSPECIFIED"
	BreakpointStateEnumStateCanaryPendingAgents BreakpointStateEnum = "STATE_CANARY_PENDING_AGENTS"
	BreakpointStateEnumStateCanaryActive        BreakpointStateEnum = "STATE_CANARY_ACTIVE"
	BreakpointStateEnumStateRollingToAll        BreakpointStateEnum = "STATE_ROLLING_TO_ALL"
	BreakpointStateEnumStateIsFinal             BreakpointStateEnum = "STATE_IS_FINAL"
)

func (e *BreakpointStateEnum) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return err
	}
	switch s {
	case "STATE_UNSPECIFIED":
		fallthrough
	case "STATE_CANARY_PENDING_AGENTS":
		fallthrough
	case "STATE_CANARY_ACTIVE":
		fallthrough
	case "STATE_ROLLING_TO_ALL":
		fallthrough
	case "STATE_IS_FINAL":
		*e = BreakpointStateEnum(s)
		return nil
	default:
		return fmt.Errorf("invalid value for BreakpointStateEnum: %s", s)
	}
}

// Breakpoint - ------------------------------------------------------------------------------ ## Breakpoint (the resource) Represents the breakpoint specification, status and results.
type Breakpoint struct {
	// Action that the agent should perform when the code at the breakpoint location is hit.
	Action *BreakpointActionEnum `json:"action,omitempty"`
	// The deadline for the breakpoint to stay in CANARY_ACTIVE state. The value is meaningless when the breakpoint is not in CANARY_ACTIVE state.
	CanaryExpireTime *string `json:"canaryExpireTime,omitempty"`
	// Condition that triggers the breakpoint. The condition is a compound boolean expression composed using expressions in a programming language at the source location.
	Condition *string `json:"condition,omitempty"`
	// Time this breakpoint was created by the server in seconds resolution.
	CreateTime *string `json:"createTime,omitempty"`
	// Values of evaluated expressions at breakpoint time. The evaluated expressions appear in exactly the same order they are listed in the `expressions` field. The `name` field holds the original expression text, the `value` or `members` field holds the result of the evaluated expression. If the expression cannot be evaluated, the `status` inside the `Variable` will indicate an error and contain the error text.
	EvaluatedExpressions []Variable `json:"evaluatedExpressions,omitempty"`
	// List of read-only expressions to evaluate at the breakpoint location. The expressions are composed using expressions in the programming language at the source location. If the breakpoint action is `LOG`, the evaluated expressions are included in log statements.
	Expressions []string `json:"expressions,omitempty"`
	// Time this breakpoint was finalized as seen by the server in seconds resolution.
	FinalTime *string `json:"finalTime,omitempty"`
	// Breakpoint identifier, unique in the scope of the debuggee.
	ID *string `json:"id,omitempty"`
	// When true, indicates that this is a final result and the breakpoint state will not change from here on.
	IsFinalState *bool `json:"isFinalState,omitempty"`
	// A set of custom breakpoint properties, populated by the agent, to be displayed to the user.
	Labels map[string]string `json:"labels,omitempty"`
	// Represents a location in the source code.
	Location *SourceLocation `json:"location,omitempty"`
	// Indicates the severity of the log. Only relevant when action is `LOG`.
	LogLevel *BreakpointLogLevelEnum `json:"logLevel,omitempty"`
	// Only relevant when action is `LOG`. Defines the message to log when the breakpoint hits. The message may include parameter placeholders `$0`, `$1`, etc. These placeholders are replaced with the evaluated value of the appropriate expression. Expressions not referenced in `log_message_format` are not logged. Example: `Message received, id = $0, count = $1` with `expressions` = `[ message.id, message.count ]`.
	LogMessageFormat *string `json:"logMessageFormat,omitempty"`
	// The stack at breakpoint time, where stack_frames[0] represents the most recently entered function.
	StackFrames []StackFrame `json:"stackFrames,omitempty"`
	// The current state of the breakpoint.
	State *BreakpointStateEnum `json:"state,omitempty"`
	// Represents a contextual status message. The message can indicate an error or informational status, and refer to specific parts of the containing object. For example, the `Breakpoint.status` field can indicate an error referring to the `BREAKPOINT_SOURCE_LOCATION` with the message `Location not found`.
	Status *StatusMessage `json:"status,omitempty"`
	// E-mail address of the user that created this breakpoint
	UserEmail *string `json:"userEmail,omitempty"`
	// The `variable_table` exists to aid with computation, memory and network traffic optimization. It enables storing a variable once and reference it from multiple variables, including variables stored in the `variable_table` itself. For example, the same `this` object, which may appear at many levels of the stack, can have all of its data stored once in this table. The stack frame variables then would hold only a reference to it. The variable `var_table_index` field is an index into this repeated field. The stored objects are nameless and get their name from the referencing variable. The effective variable is a merge of the referencing variable and the referenced variable.
	VariableTable []Variable `json:"variableTable,omitempty"`
}
