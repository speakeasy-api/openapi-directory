<?php

/**
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

declare(strict_types=1);

namespace OpenAPI\OpenAPI\Models\Operations;


class CreateAuthorizerRequestBody
{
    /**
     * The ARN of the authorizer's Lambda function.
     * 
     * @var string $authorizerFunctionArn
     */
	#[\JMS\Serializer\Annotation\SerializedName('authorizerFunctionArn')]
    #[\JMS\Serializer\Annotation\Type('string')]
    public string $authorizerFunctionArn;
    
    /**
     * <p>When <code>true</code>, the result from the authorizerâ€™s Lambda function is cached for clients that use persistent HTTP connections. The results are cached for the time specified by the Lambda function in <code>refreshAfterInSeconds</code>. This value does not affect authorization of clients that use MQTT connections.</p> <p>The default value is <code>false</code>.</p>
     * 
     * @var ?bool $enableCachingForHttp
     */
	#[\JMS\Serializer\Annotation\SerializedName('enableCachingForHttp')]
    #[\JMS\Serializer\Annotation\Type('bool')]
    #[\JMS\Serializer\Annotation\SkipWhenEmpty]
    public ?bool $enableCachingForHttp = null;
    
    /**
     * Specifies whether IoT validates the token signature in an authorization request.
     * 
     * @var ?bool $signingDisabled
     */
	#[\JMS\Serializer\Annotation\SerializedName('signingDisabled')]
    #[\JMS\Serializer\Annotation\Type('bool')]
    #[\JMS\Serializer\Annotation\SkipWhenEmpty]
    public ?bool $signingDisabled = null;
    
    /**
     * The status of the create authorizer request.
     * 
     * @var ?\OpenAPI\OpenAPI\Models\Operations\CreateAuthorizerRequestBodyStatusEnum $status
     */
	#[\JMS\Serializer\Annotation\SerializedName('status')]
    #[\JMS\Serializer\Annotation\Type('enum<OpenAPI\OpenAPI\Models\Operations\CreateAuthorizerRequestBodyStatusEnum>')]
    #[\JMS\Serializer\Annotation\SkipWhenEmpty]
    public ?CreateAuthorizerRequestBodyStatusEnum $status = null;
    
    /**
     * <p>Metadata which can be used to manage the custom authorizer.</p> <note> <p>For URI Request parameters use format: ...key1=value1&amp;key2=value2...</p> <p>For the CLI command-line parameter use format: &amp;&amp;tags "key1=value1&amp;key2=value2..."</p> <p>For the cli-input-json file use format: "tags": "key1=value1&amp;key2=value2..."</p> </note>
     * 
     * @var ?array<\OpenAPI\OpenAPI\Models\Shared\Tag> $tags
     */
	#[\JMS\Serializer\Annotation\SerializedName('tags')]
    #[\JMS\Serializer\Annotation\Type('array<OpenAPI\OpenAPI\Models\Shared\Tag>')]
    #[\JMS\Serializer\Annotation\SkipWhenEmpty]
    public ?array $tags = null;
    
    /**
     * The name of the token key used to extract the token from the HTTP headers.
     * 
     * @var ?string $tokenKeyName
     */
	#[\JMS\Serializer\Annotation\SerializedName('tokenKeyName')]
    #[\JMS\Serializer\Annotation\Type('string')]
    #[\JMS\Serializer\Annotation\SkipWhenEmpty]
    public ?string $tokenKeyName = null;
    
    /**
     * The public keys used to verify the digital signature returned by your custom authentication service.
     * 
     * @var ?array<string, string> $tokenSigningPublicKeys
     */
	#[\JMS\Serializer\Annotation\SerializedName('tokenSigningPublicKeys')]
    #[\JMS\Serializer\Annotation\Type('array<string, string>')]
    #[\JMS\Serializer\Annotation\SkipWhenEmpty]
    public ?array $tokenSigningPublicKeys = null;
    
	public function __construct()
	{
		$this->authorizerFunctionArn = "";
		$this->enableCachingForHttp = null;
		$this->signingDisabled = null;
		$this->status = null;
		$this->tags = null;
		$this->tokenKeyName = null;
		$this->tokenSigningPublicKeys = null;
	}
}
