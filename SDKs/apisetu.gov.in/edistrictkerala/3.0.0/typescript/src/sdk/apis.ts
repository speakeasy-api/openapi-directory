/*
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

import * as utils from "../internal/utils";
import * as operations from "./models/operations";
import { AxiosInstance, AxiosRequestConfig, AxiosResponse } from "axios";

export class APIs {
  _defaultClient: AxiosInstance;
  _securityClient: AxiosInstance;
  _serverURL: string;
  _language: string;
  _sdkVersion: string;
  _genVersion: string;

  constructor(
    defaultClient: AxiosInstance,
    securityClient: AxiosInstance,
    serverURL: string,
    language: string,
    sdkVersion: string,
    genVersion: string
  ) {
    this._defaultClient = defaultClient;
    this._securityClient = securityClient;
    this._serverURL = serverURL;
    this._language = language;
    this._sdkVersion = sdkVersion;
    this._genVersion = genVersion;
  }

  /**
   * Community Certificate
   *
   * @remarks
   * API to verify Community Certificate.
   */
  cmcer(
    req: operations.CmcerRequestBody,
    security: operations.CmcerSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.CmcerResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CmcerRequestBody(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/cmcer/certificate";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "request",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.CmcerSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CmcerResponse = new operations.CmcerResponse({
        statusCode: httpRes.status,
        contentType: contentType,
        rawResponse: httpRes,
      });
      switch (true) {
        case httpRes?.status == 200:
          break;
        case httpRes?.status == 400:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.cmcer400ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.Cmcer400ApplicationJSON
            );
          }
          break;
        case httpRes?.status == 401:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.cmcer401ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.Cmcer401ApplicationJSON
            );
          }
          break;
        case httpRes?.status == 404:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.cmcer404ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.Cmcer404ApplicationJSON
            );
          }
          break;
        case httpRes?.status == 500:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.cmcer500ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.Cmcer500ApplicationJSON
            );
          }
          break;
        case httpRes?.status == 502:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.cmcer502ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.Cmcer502ApplicationJSON
            );
          }
          break;
        case httpRes?.status == 503:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.cmcer503ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.Cmcer503ApplicationJSON
            );
          }
          break;
        case httpRes?.status == 504:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.cmcer504ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.Cmcer504ApplicationJSON
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Conversion Certificate
   *
   * @remarks
   * API to verify Conversion Certificate.
   */
  cncer(
    req: operations.CncerRequestBody,
    security: operations.CncerSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.CncerResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CncerRequestBody(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/cncer/certificate";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "request",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.CncerSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CncerResponse = new operations.CncerResponse({
        statusCode: httpRes.status,
        contentType: contentType,
        rawResponse: httpRes,
      });
      switch (true) {
        case httpRes?.status == 200:
          break;
        case httpRes?.status == 400:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.cncer400ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.Cncer400ApplicationJSON
            );
          }
          break;
        case httpRes?.status == 401:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.cncer401ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.Cncer401ApplicationJSON
            );
          }
          break;
        case httpRes?.status == 404:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.cncer404ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.Cncer404ApplicationJSON
            );
          }
          break;
        case httpRes?.status == 500:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.cncer500ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.Cncer500ApplicationJSON
            );
          }
          break;
        case httpRes?.status == 502:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.cncer502ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.Cncer502ApplicationJSON
            );
          }
          break;
        case httpRes?.status == 503:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.cncer503ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.Cncer503ApplicationJSON
            );
          }
          break;
        case httpRes?.status == 504:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.cncer504ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.Cncer504ApplicationJSON
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Caste Certificate
   *
   * @remarks
   * API to verify Caste Certificate.
   */
  ctcer(
    req: operations.CtcerRequestBody,
    security: operations.CtcerSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.CtcerResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CtcerRequestBody(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/ctcer/certificate";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "request",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.CtcerSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CtcerResponse = new operations.CtcerResponse({
        statusCode: httpRes.status,
        contentType: contentType,
        rawResponse: httpRes,
      });
      switch (true) {
        case httpRes?.status == 200:
          break;
        case httpRes?.status == 400:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.ctcer400ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.Ctcer400ApplicationJSON
            );
          }
          break;
        case httpRes?.status == 401:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.ctcer401ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.Ctcer401ApplicationJSON
            );
          }
          break;
        case httpRes?.status == 404:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.ctcer404ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.Ctcer404ApplicationJSON
            );
          }
          break;
        case httpRes?.status == 500:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.ctcer500ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.Ctcer500ApplicationJSON
            );
          }
          break;
        case httpRes?.status == 502:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.ctcer502ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.Ctcer502ApplicationJSON
            );
          }
          break;
        case httpRes?.status == 503:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.ctcer503ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.Ctcer503ApplicationJSON
            );
          }
          break;
        case httpRes?.status == 504:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.ctcer504ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.Ctcer504ApplicationJSON
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Domicile Certificate
   *
   * @remarks
   * API to verify Domicile Certificate.
   */
  dmcer(
    req: operations.DmcerRequestBody,
    security: operations.DmcerSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.DmcerResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DmcerRequestBody(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/dmcer/certificate";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "request",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.DmcerSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DmcerResponse = new operations.DmcerResponse({
        statusCode: httpRes.status,
        contentType: contentType,
        rawResponse: httpRes,
      });
      switch (true) {
        case httpRes?.status == 200:
          break;
        case httpRes?.status == 400:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.dmcer400ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.Dmcer400ApplicationJSON
            );
          }
          break;
        case httpRes?.status == 401:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.dmcer401ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.Dmcer401ApplicationJSON
            );
          }
          break;
        case httpRes?.status == 404:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.dmcer404ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.Dmcer404ApplicationJSON
            );
          }
          break;
        case httpRes?.status == 500:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.dmcer500ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.Dmcer500ApplicationJSON
            );
          }
          break;
        case httpRes?.status == 502:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.dmcer502ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.Dmcer502ApplicationJSON
            );
          }
          break;
        case httpRes?.status == 503:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.dmcer503ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.Dmcer503ApplicationJSON
            );
          }
          break;
        case httpRes?.status == 504:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.dmcer504ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.Dmcer504ApplicationJSON
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Dependency Certificate
   *
   * @remarks
   * API to verify Dependency Certificate.
   */
  dpcer(
    req: operations.DpcerRequestBody,
    security: operations.DpcerSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.DpcerResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DpcerRequestBody(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/dpcer/certificate";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "request",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.DpcerSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DpcerResponse = new operations.DpcerResponse({
        statusCode: httpRes.status,
        contentType: contentType,
        rawResponse: httpRes,
      });
      switch (true) {
        case httpRes?.status == 200:
          break;
        case httpRes?.status == 400:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.dpcer400ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.Dpcer400ApplicationJSON
            );
          }
          break;
        case httpRes?.status == 401:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.dpcer401ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.Dpcer401ApplicationJSON
            );
          }
          break;
        case httpRes?.status == 404:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.dpcer404ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.Dpcer404ApplicationJSON
            );
          }
          break;
        case httpRes?.status == 500:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.dpcer500ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.Dpcer500ApplicationJSON
            );
          }
          break;
        case httpRes?.status == 502:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.dpcer502ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.Dpcer502ApplicationJSON
            );
          }
          break;
        case httpRes?.status == 503:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.dpcer503ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.Dpcer503ApplicationJSON
            );
          }
          break;
        case httpRes?.status == 504:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.dpcer504ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.Dpcer504ApplicationJSON
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Destitute Certificate
   *
   * @remarks
   * API to verify Destitute Certificate.
   */
  dscer(
    req: operations.DscerRequestBody,
    security: operations.DscerSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.DscerResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DscerRequestBody(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/dscer/certificate";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "request",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.DscerSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DscerResponse = new operations.DscerResponse({
        statusCode: httpRes.status,
        contentType: contentType,
        rawResponse: httpRes,
      });
      switch (true) {
        case httpRes?.status == 200:
          break;
        case httpRes?.status == 400:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.dscer400ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.Dscer400ApplicationJSON
            );
          }
          break;
        case httpRes?.status == 401:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.dscer401ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.Dscer401ApplicationJSON
            );
          }
          break;
        case httpRes?.status == 404:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.dscer404ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.Dscer404ApplicationJSON
            );
          }
          break;
        case httpRes?.status == 500:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.dscer500ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.Dscer500ApplicationJSON
            );
          }
          break;
        case httpRes?.status == 502:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.dscer502ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.Dscer502ApplicationJSON
            );
          }
          break;
        case httpRes?.status == 503:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.dscer503ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.Dscer503ApplicationJSON
            );
          }
          break;
        case httpRes?.status == 504:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.dscer504ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.Dscer504ApplicationJSON
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Family Membership Certificate
   *
   * @remarks
   * API to verify Family Membership Certificate.
   */
  fmcer(
    req: operations.FmcerRequestBody,
    security: operations.FmcerSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.FmcerResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.FmcerRequestBody(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/fmcer/certificate";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "request",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.FmcerSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.FmcerResponse = new operations.FmcerResponse({
        statusCode: httpRes.status,
        contentType: contentType,
        rawResponse: httpRes,
      });
      switch (true) {
        case httpRes?.status == 200:
          break;
        case httpRes?.status == 400:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.fmcer400ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.Fmcer400ApplicationJSON
            );
          }
          break;
        case httpRes?.status == 401:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.fmcer401ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.Fmcer401ApplicationJSON
            );
          }
          break;
        case httpRes?.status == 404:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.fmcer404ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.Fmcer404ApplicationJSON
            );
          }
          break;
        case httpRes?.status == 500:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.fmcer500ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.Fmcer500ApplicationJSON
            );
          }
          break;
        case httpRes?.status == 502:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.fmcer502ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.Fmcer502ApplicationJSON
            );
          }
          break;
        case httpRes?.status == 503:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.fmcer503ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.Fmcer503ApplicationJSON
            );
          }
          break;
        case httpRes?.status == 504:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.fmcer504ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.Fmcer504ApplicationJSON
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Identification Certificate
   *
   * @remarks
   * API to verify Identification Certificate.
   */
  idcer(
    req: operations.IdcerRequestBody,
    security: operations.IdcerSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.IdcerResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.IdcerRequestBody(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/idcer/certificate";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "request",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.IdcerSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.IdcerResponse = new operations.IdcerResponse({
        statusCode: httpRes.status,
        contentType: contentType,
        rawResponse: httpRes,
      });
      switch (true) {
        case httpRes?.status == 200:
          break;
        case httpRes?.status == 400:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.idcer400ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.Idcer400ApplicationJSON
            );
          }
          break;
        case httpRes?.status == 401:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.idcer401ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.Idcer401ApplicationJSON
            );
          }
          break;
        case httpRes?.status == 404:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.idcer404ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.Idcer404ApplicationJSON
            );
          }
          break;
        case httpRes?.status == 500:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.idcer500ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.Idcer500ApplicationJSON
            );
          }
          break;
        case httpRes?.status == 502:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.idcer502ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.Idcer502ApplicationJSON
            );
          }
          break;
        case httpRes?.status == 503:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.idcer503ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.Idcer503ApplicationJSON
            );
          }
          break;
        case httpRes?.status == 504:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.idcer504ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.Idcer504ApplicationJSON
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Inter-Caste Marriage Certificate
   *
   * @remarks
   * API to verify Inter-Caste Marriage Certificate.
   */
  imcer(
    req: operations.ImcerRequestBody,
    security: operations.ImcerSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.ImcerResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ImcerRequestBody(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/imcer/certificate";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "request",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ImcerSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ImcerResponse = new operations.ImcerResponse({
        statusCode: httpRes.status,
        contentType: contentType,
        rawResponse: httpRes,
      });
      switch (true) {
        case httpRes?.status == 200:
          break;
        case httpRes?.status == 400:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.imcer400ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.Imcer400ApplicationJSON
            );
          }
          break;
        case httpRes?.status == 401:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.imcer401ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.Imcer401ApplicationJSON
            );
          }
          break;
        case httpRes?.status == 404:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.imcer404ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.Imcer404ApplicationJSON
            );
          }
          break;
        case httpRes?.status == 500:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.imcer500ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.Imcer500ApplicationJSON
            );
          }
          break;
        case httpRes?.status == 502:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.imcer502ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.Imcer502ApplicationJSON
            );
          }
          break;
        case httpRes?.status == 503:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.imcer503ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.Imcer503ApplicationJSON
            );
          }
          break;
        case httpRes?.status == 504:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.imcer504ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.Imcer504ApplicationJSON
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Income Certificate
   *
   * @remarks
   * API to verify Income Certificate.
   */
  incer(
    req: operations.IncerRequestBody,
    security: operations.IncerSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.IncerResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.IncerRequestBody(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/incer/certificate";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "request",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.IncerSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.IncerResponse = new operations.IncerResponse({
        statusCode: httpRes.status,
        contentType: contentType,
        rawResponse: httpRes,
      });
      switch (true) {
        case httpRes?.status == 200:
          break;
        case httpRes?.status == 400:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.incer400ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.Incer400ApplicationJSON
            );
          }
          break;
        case httpRes?.status == 401:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.incer401ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.Incer401ApplicationJSON
            );
          }
          break;
        case httpRes?.status == 404:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.incer404ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.Incer404ApplicationJSON
            );
          }
          break;
        case httpRes?.status == 500:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.incer500ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.Incer500ApplicationJSON
            );
          }
          break;
        case httpRes?.status == 502:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.incer502ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.Incer502ApplicationJSON
            );
          }
          break;
        case httpRes?.status == 503:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.incer503ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.Incer503ApplicationJSON
            );
          }
          break;
        case httpRes?.status == 504:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.incer504ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.Incer504ApplicationJSON
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Life Certificate
   *
   * @remarks
   * API to verify Life Certificate.
   */
  lfcer(
    req: operations.LfcerRequestBody,
    security: operations.LfcerSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.LfcerResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.LfcerRequestBody(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/lfcer/certificate";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "request",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.LfcerSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.LfcerResponse = new operations.LfcerResponse({
        statusCode: httpRes.status,
        contentType: contentType,
        rawResponse: httpRes,
      });
      switch (true) {
        case httpRes?.status == 200:
          break;
        case httpRes?.status == 400:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.lfcer400ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.Lfcer400ApplicationJSON
            );
          }
          break;
        case httpRes?.status == 401:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.lfcer401ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.Lfcer401ApplicationJSON
            );
          }
          break;
        case httpRes?.status == 404:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.lfcer404ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.Lfcer404ApplicationJSON
            );
          }
          break;
        case httpRes?.status == 500:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.lfcer500ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.Lfcer500ApplicationJSON
            );
          }
          break;
        case httpRes?.status == 502:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.lfcer502ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.Lfcer502ApplicationJSON
            );
          }
          break;
        case httpRes?.status == 503:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.lfcer503ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.Lfcer503ApplicationJSON
            );
          }
          break;
        case httpRes?.status == 504:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.lfcer504ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.Lfcer504ApplicationJSON
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Legal Heir Certificate
   *
   * @remarks
   * API to verify Legal Heir Certificate.
   */
  lhcer(
    req: operations.LhcerRequestBody,
    security: operations.LhcerSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.LhcerResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.LhcerRequestBody(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/lhcer/certificate";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "request",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.LhcerSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.LhcerResponse = new operations.LhcerResponse({
        statusCode: httpRes.status,
        contentType: contentType,
        rawResponse: httpRes,
      });
      switch (true) {
        case httpRes?.status == 200:
          break;
        case httpRes?.status == 400:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.lhcer400ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.Lhcer400ApplicationJSON
            );
          }
          break;
        case httpRes?.status == 401:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.lhcer401ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.Lhcer401ApplicationJSON
            );
          }
          break;
        case httpRes?.status == 404:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.lhcer404ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.Lhcer404ApplicationJSON
            );
          }
          break;
        case httpRes?.status == 500:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.lhcer500ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.Lhcer500ApplicationJSON
            );
          }
          break;
        case httpRes?.status == 502:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.lhcer502ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.Lhcer502ApplicationJSON
            );
          }
          break;
        case httpRes?.status == 503:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.lhcer503ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.Lhcer503ApplicationJSON
            );
          }
          break;
        case httpRes?.status == 504:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.lhcer504ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.Lhcer504ApplicationJSON
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Location Certificate
   *
   * @remarks
   * API to verify Location Certificate.
   */
  locer(
    req: operations.LocerRequestBody,
    security: operations.LocerSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.LocerResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.LocerRequestBody(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/locer/certificate";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "request",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.LocerSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.LocerResponse = new operations.LocerResponse({
        statusCode: httpRes.status,
        contentType: contentType,
        rawResponse: httpRes,
      });
      switch (true) {
        case httpRes?.status == 200:
          break;
        case httpRes?.status == 400:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.locer400ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.Locer400ApplicationJSON
            );
          }
          break;
        case httpRes?.status == 401:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.locer401ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.Locer401ApplicationJSON
            );
          }
          break;
        case httpRes?.status == 404:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.locer404ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.Locer404ApplicationJSON
            );
          }
          break;
        case httpRes?.status == 500:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.locer500ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.Locer500ApplicationJSON
            );
          }
          break;
        case httpRes?.status == 502:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.locer502ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.Locer502ApplicationJSON
            );
          }
          break;
        case httpRes?.status == 503:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.locer503ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.Locer503ApplicationJSON
            );
          }
          break;
        case httpRes?.status == 504:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.locer504ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.Locer504ApplicationJSON
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Minority Certificate
   *
   * @remarks
   * API to verify Minority Certificate.
   */
  mncer(
    req: operations.MncerRequestBody,
    security: operations.MncerSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.MncerResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.MncerRequestBody(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/mncer/certificate";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "request",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.MncerSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.MncerResponse = new operations.MncerResponse({
        statusCode: httpRes.status,
        contentType: contentType,
        rawResponse: httpRes,
      });
      switch (true) {
        case httpRes?.status == 200:
          break;
        case httpRes?.status == 400:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.mncer400ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.Mncer400ApplicationJSON
            );
          }
          break;
        case httpRes?.status == 401:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.mncer401ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.Mncer401ApplicationJSON
            );
          }
          break;
        case httpRes?.status == 404:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.mncer404ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.Mncer404ApplicationJSON
            );
          }
          break;
        case httpRes?.status == 500:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.mncer500ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.Mncer500ApplicationJSON
            );
          }
          break;
        case httpRes?.status == 502:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.mncer502ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.Mncer502ApplicationJSON
            );
          }
          break;
        case httpRes?.status == 503:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.mncer503ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.Mncer503ApplicationJSON
            );
          }
          break;
        case httpRes?.status == 504:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.mncer504ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.Mncer504ApplicationJSON
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Non-Remarriage Certificate
   *
   * @remarks
   * API to verify Non-Remarriage Certificate.
   */
  nrcer(
    req: operations.NrcerRequestBody,
    security: operations.NrcerSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.NrcerResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.NrcerRequestBody(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/nrcer/certificate";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "request",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.NrcerSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.NrcerResponse = new operations.NrcerResponse({
        statusCode: httpRes.status,
        contentType: contentType,
        rawResponse: httpRes,
      });
      switch (true) {
        case httpRes?.status == 200:
          break;
        case httpRes?.status == 400:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.nrcer400ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.Nrcer400ApplicationJSON
            );
          }
          break;
        case httpRes?.status == 401:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.nrcer401ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.Nrcer401ApplicationJSON
            );
          }
          break;
        case httpRes?.status == 404:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.nrcer404ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.Nrcer404ApplicationJSON
            );
          }
          break;
        case httpRes?.status == 500:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.nrcer500ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.Nrcer500ApplicationJSON
            );
          }
          break;
        case httpRes?.status == 502:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.nrcer502ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.Nrcer502ApplicationJSON
            );
          }
          break;
        case httpRes?.status == 503:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.nrcer503ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.Nrcer503ApplicationJSON
            );
          }
          break;
        case httpRes?.status == 504:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.nrcer504ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.Nrcer504ApplicationJSON
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Nativity Certificate
   *
   * @remarks
   * API to verify Nativity Certificate.
   */
  ntcer(
    req: operations.NtcerRequestBody,
    security: operations.NtcerSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.NtcerResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.NtcerRequestBody(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/ntcer/certificate";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "request",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.NtcerSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.NtcerResponse = new operations.NtcerResponse({
        statusCode: httpRes.status,
        contentType: contentType,
        rawResponse: httpRes,
      });
      switch (true) {
        case httpRes?.status == 200:
          break;
        case httpRes?.status == 400:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.ntcer400ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.Ntcer400ApplicationJSON
            );
          }
          break;
        case httpRes?.status == 401:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.ntcer401ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.Ntcer401ApplicationJSON
            );
          }
          break;
        case httpRes?.status == 404:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.ntcer404ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.Ntcer404ApplicationJSON
            );
          }
          break;
        case httpRes?.status == 500:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.ntcer500ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.Ntcer500ApplicationJSON
            );
          }
          break;
        case httpRes?.status == 502:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.ntcer502ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.Ntcer502ApplicationJSON
            );
          }
          break;
        case httpRes?.status == 503:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.ntcer503ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.Ntcer503ApplicationJSON
            );
          }
          break;
        case httpRes?.status == 504:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.ntcer504ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.Ntcer504ApplicationJSON
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * One and the Same Certificate
   *
   * @remarks
   * API to verify One and the Same Certificate.
   */
  oscer(
    req: operations.OscerRequestBody,
    security: operations.OscerSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.OscerResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.OscerRequestBody(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/oscer/certificate";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "request",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.OscerSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.OscerResponse = new operations.OscerResponse({
        statusCode: httpRes.status,
        contentType: contentType,
        rawResponse: httpRes,
      });
      switch (true) {
        case httpRes?.status == 200:
          break;
        case httpRes?.status == 400:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.oscer400ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.Oscer400ApplicationJSON
            );
          }
          break;
        case httpRes?.status == 401:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.oscer401ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.Oscer401ApplicationJSON
            );
          }
          break;
        case httpRes?.status == 404:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.oscer404ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.Oscer404ApplicationJSON
            );
          }
          break;
        case httpRes?.status == 500:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.oscer500ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.Oscer500ApplicationJSON
            );
          }
          break;
        case httpRes?.status == 502:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.oscer502ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.Oscer502ApplicationJSON
            );
          }
          break;
        case httpRes?.status == 503:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.oscer503ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.Oscer503ApplicationJSON
            );
          }
          break;
        case httpRes?.status == 504:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.oscer504ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.Oscer504ApplicationJSON
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Possession and Non-Attachment Certificate
   *
   * @remarks
   * API to verify Possession and Non-Attachment Certificate.
   */
  pncer(
    req: operations.PncerRequestBody,
    security: operations.PncerSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.PncerResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PncerRequestBody(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/pncer/certificate";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "request",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.PncerSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PncerResponse = new operations.PncerResponse({
        statusCode: httpRes.status,
        contentType: contentType,
        rawResponse: httpRes,
      });
      switch (true) {
        case httpRes?.status == 200:
          break;
        case httpRes?.status == 400:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.pncer400ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.Pncer400ApplicationJSON
            );
          }
          break;
        case httpRes?.status == 401:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.pncer401ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.Pncer401ApplicationJSON
            );
          }
          break;
        case httpRes?.status == 404:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.pncer404ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.Pncer404ApplicationJSON
            );
          }
          break;
        case httpRes?.status == 500:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.pncer500ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.Pncer500ApplicationJSON
            );
          }
          break;
        case httpRes?.status == 502:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.pncer502ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.Pncer502ApplicationJSON
            );
          }
          break;
        case httpRes?.status == 503:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.pncer503ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.Pncer503ApplicationJSON
            );
          }
          break;
        case httpRes?.status == 504:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.pncer504ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.Pncer504ApplicationJSON
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Possession Certificate
   *
   * @remarks
   * API to verify Possession Certificate.
   */
  pscer(
    req: operations.PscerRequestBody,
    security: operations.PscerSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.PscerResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PscerRequestBody(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/pscer/certificate";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "request",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.PscerSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PscerResponse = new operations.PscerResponse({
        statusCode: httpRes.status,
        contentType: contentType,
        rawResponse: httpRes,
      });
      switch (true) {
        case httpRes?.status == 200:
          break;
        case httpRes?.status == 400:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.pscer400ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.Pscer400ApplicationJSON
            );
          }
          break;
        case httpRes?.status == 401:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.pscer401ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.Pscer401ApplicationJSON
            );
          }
          break;
        case httpRes?.status == 404:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.pscer404ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.Pscer404ApplicationJSON
            );
          }
          break;
        case httpRes?.status == 500:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.pscer500ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.Pscer500ApplicationJSON
            );
          }
          break;
        case httpRes?.status == 502:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.pscer502ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.Pscer502ApplicationJSON
            );
          }
          break;
        case httpRes?.status == 503:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.pscer503ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.Pscer503ApplicationJSON
            );
          }
          break;
        case httpRes?.status == 504:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.pscer504ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.Pscer504ApplicationJSON
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Relationship Certificate
   *
   * @remarks
   * API to verify Relationship Certificate.
   */
  rlcer(
    req: operations.RlcerRequestBody,
    security: operations.RlcerSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.RlcerResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.RlcerRequestBody(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/rlcer/certificate";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "request",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.RlcerSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.RlcerResponse = new operations.RlcerResponse({
        statusCode: httpRes.status,
        contentType: contentType,
        rawResponse: httpRes,
      });
      switch (true) {
        case httpRes?.status == 200:
          break;
        case httpRes?.status == 400:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.rlcer400ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.Rlcer400ApplicationJSON
            );
          }
          break;
        case httpRes?.status == 401:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.rlcer401ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.Rlcer401ApplicationJSON
            );
          }
          break;
        case httpRes?.status == 404:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.rlcer404ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.Rlcer404ApplicationJSON
            );
          }
          break;
        case httpRes?.status == 500:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.rlcer500ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.Rlcer500ApplicationJSON
            );
          }
          break;
        case httpRes?.status == 502:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.rlcer502ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.Rlcer502ApplicationJSON
            );
          }
          break;
        case httpRes?.status == 503:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.rlcer503ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.Rlcer503ApplicationJSON
            );
          }
          break;
        case httpRes?.status == 504:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.rlcer504ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.Rlcer504ApplicationJSON
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Residence Certificate
   *
   * @remarks
   * API to verify Residence Certificate.
   */
  rscer(
    req: operations.RscerRequestBody,
    security: operations.RscerSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.RscerResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.RscerRequestBody(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/rscer/certificate";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "request",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.RscerSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.RscerResponse = new operations.RscerResponse({
        statusCode: httpRes.status,
        contentType: contentType,
        rawResponse: httpRes,
      });
      switch (true) {
        case httpRes?.status == 200:
          break;
        case httpRes?.status == 400:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.rscer400ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.Rscer400ApplicationJSON
            );
          }
          break;
        case httpRes?.status == 401:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.rscer401ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.Rscer401ApplicationJSON
            );
          }
          break;
        case httpRes?.status == 404:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.rscer404ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.Rscer404ApplicationJSON
            );
          }
          break;
        case httpRes?.status == 500:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.rscer500ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.Rscer500ApplicationJSON
            );
          }
          break;
        case httpRes?.status == 502:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.rscer502ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.Rscer502ApplicationJSON
            );
          }
          break;
        case httpRes?.status == 503:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.rscer503ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.Rscer503ApplicationJSON
            );
          }
          break;
        case httpRes?.status == 504:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.rscer504ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.Rscer504ApplicationJSON
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Solvency Certificate
   *
   * @remarks
   * API to verify Solvency Certificate.
   */
  slcer(
    req: operations.SlcerRequestBody,
    security: operations.SlcerSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.SlcerResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.SlcerRequestBody(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/slcer/certificate";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "request",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.SlcerSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.SlcerResponse = new operations.SlcerResponse({
        statusCode: httpRes.status,
        contentType: contentType,
        rawResponse: httpRes,
      });
      switch (true) {
        case httpRes?.status == 200:
          break;
        case httpRes?.status == 400:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.slcer400ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.Slcer400ApplicationJSON
            );
          }
          break;
        case httpRes?.status == 401:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.slcer401ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.Slcer401ApplicationJSON
            );
          }
          break;
        case httpRes?.status == 404:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.slcer404ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.Slcer404ApplicationJSON
            );
          }
          break;
        case httpRes?.status == 500:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.slcer500ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.Slcer500ApplicationJSON
            );
          }
          break;
        case httpRes?.status == 502:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.slcer502ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.Slcer502ApplicationJSON
            );
          }
          break;
        case httpRes?.status == 503:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.slcer503ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.Slcer503ApplicationJSON
            );
          }
          break;
        case httpRes?.status == 504:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.slcer504ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.Slcer504ApplicationJSON
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Valuation Certificate
   *
   * @remarks
   * API to verify Valuation Certificate.
   */
  vlcer(
    req: operations.VlcerRequestBody,
    security: operations.VlcerSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.VlcerResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.VlcerRequestBody(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/vlcer/certificate";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "request",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.VlcerSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.VlcerResponse = new operations.VlcerResponse({
        statusCode: httpRes.status,
        contentType: contentType,
        rawResponse: httpRes,
      });
      switch (true) {
        case httpRes?.status == 200:
          break;
        case httpRes?.status == 400:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.vlcer400ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.Vlcer400ApplicationJSON
            );
          }
          break;
        case httpRes?.status == 401:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.vlcer401ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.Vlcer401ApplicationJSON
            );
          }
          break;
        case httpRes?.status == 404:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.vlcer404ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.Vlcer404ApplicationJSON
            );
          }
          break;
        case httpRes?.status == 500:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.vlcer500ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.Vlcer500ApplicationJSON
            );
          }
          break;
        case httpRes?.status == 502:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.vlcer502ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.Vlcer502ApplicationJSON
            );
          }
          break;
        case httpRes?.status == 503:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.vlcer503ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.Vlcer503ApplicationJSON
            );
          }
          break;
        case httpRes?.status == 504:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.vlcer504ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.Vlcer504ApplicationJSON
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Widow-Widower Certificate
   *
   * @remarks
   * API to verify Widow-Widower Certificate.
   */
  wwcer(
    req: operations.WwcerRequestBody,
    security: operations.WwcerSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.WwcerResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.WwcerRequestBody(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/wwcer/certificate";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "request",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.WwcerSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.WwcerResponse = new operations.WwcerResponse({
        statusCode: httpRes.status,
        contentType: contentType,
        rawResponse: httpRes,
      });
      switch (true) {
        case httpRes?.status == 200:
          break;
        case httpRes?.status == 400:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.wwcer400ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.Wwcer400ApplicationJSON
            );
          }
          break;
        case httpRes?.status == 401:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.wwcer401ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.Wwcer401ApplicationJSON
            );
          }
          break;
        case httpRes?.status == 404:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.wwcer404ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.Wwcer404ApplicationJSON
            );
          }
          break;
        case httpRes?.status == 500:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.wwcer500ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.Wwcer500ApplicationJSON
            );
          }
          break;
        case httpRes?.status == 502:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.wwcer502ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.Wwcer502ApplicationJSON
            );
          }
          break;
        case httpRes?.status == 503:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.wwcer503ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.Wwcer503ApplicationJSON
            );
          }
          break;
        case httpRes?.status == 504:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.wwcer504ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.Wwcer504ApplicationJSON
            );
          }
          break;
      }

      return res;
    });
  }
}
