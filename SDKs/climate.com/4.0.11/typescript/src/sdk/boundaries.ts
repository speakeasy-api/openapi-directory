/*
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

import * as utils from "../internal/utils";
import * as operations from "./models/operations";
import * as shared from "./models/shared";
import { AxiosInstance, AxiosRequestConfig, AxiosResponse } from "axios";

/**
 * Field Boundary data endpoints.
 */
export class Boundaries {
  _defaultClient: AxiosInstance;
  _securityClient: AxiosInstance;
  _serverURL: string;
  _language: string;
  _sdkVersion: string;
  _genVersion: string;

  constructor(
    defaultClient: AxiosInstance,
    securityClient: AxiosInstance,
    serverURL: string,
    language: string,
    sdkVersion: string,
    genVersion: string
  ) {
    this._defaultClient = defaultClient;
    this._securityClient = securityClient;
    this._serverURL = serverURL;
    this._language = language;
    this._sdkVersion = sdkVersion;
    this._genVersion = genVersion;
  }

  /**
   * Retrieve Boundaries in batch
   *
   * @remarks
   * Retrieve multiple **Boundaries** (up to 10 per request).
   */
  fetchBoundaries(
    req: shared.BoundariesQuery,
    security: operations.FetchBoundariesSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.FetchBoundariesResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new shared.BoundariesQuery(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/v4/boundaries/query";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "request",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.FetchBoundariesSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.FetchBoundariesResponse =
        new operations.FetchBoundariesResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
          headers: utils.getHeadersFromResponse(httpRes.headers),
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.boundaries = utils.objectToClass(
              httpRes?.data,
              shared.Boundaries
            );
          }
          break;
        case [400, 401, 403, 404, 429, 500, 503].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.error = utils.objectToClass(httpRes?.data, shared.ErrorT);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Retrieve a Boundary by ID
   *
   * @remarks
   * Retrieve a **Boundary** by ID.
   */
  fetchBoundaryById(
    req: operations.FetchBoundaryByIdRequest,
    security: operations.FetchBoundaryByIdSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.FetchBoundaryByIdResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.FetchBoundaryByIdRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v4/boundaries/{boundaryId}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.FetchBoundaryByIdSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.FetchBoundaryByIdResponse =
        new operations.FetchBoundaryByIdResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
          headers: utils.getHeadersFromResponse(httpRes.headers),
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.boundary = utils.objectToClass(httpRes?.data, shared.Boundary);
          }
          break;
        case [400, 401, 403, 404, 429, 500, 503].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.error = utils.objectToClass(httpRes?.data, shared.ErrorT);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Upload a boundary
   *
   * @remarks
   * Upload a **Boundary** entry by passing the geometry of the boundary. This will store the boundary but will not create field in Climate FieldView and will not link to an existing field in Climate FieldView.
   * This is restricted to callers with **boundaries:write** scope.
   * To upload a field boundary for field creation in Climate FieldView, please use **POST /v4/uploads**.
   */
  uploadBoundary(
    req: shared.BoundaryUpload,
    security: operations.UploadBoundarySecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.UploadBoundaryResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new shared.BoundaryUpload(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/v4/boundaries";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "request",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.UploadBoundarySecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UploadBoundaryResponse =
        new operations.UploadBoundaryResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
          headers: utils.getHeadersFromResponse(httpRes.headers),
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.uploadedBoundaryId = utils.objectToClass(
              httpRes?.data,
              shared.UploadedBoundaryId
            );
          }
          break;
        case [400, 401, 403, 404, 429, 500, 503].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.error = utils.objectToClass(httpRes?.data, shared.ErrorT);
          }
          break;
      }

      return res;
    });
  }
}
