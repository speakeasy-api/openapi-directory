// Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.

package shared

import (
	"bytes"
	"encoding/json"
	"errors"
	"fmt"
)

// CreateWorkflowTemplateEnum - The template that the Dispatch API will execute. For the initial version of the API the only available value will be failover
type CreateWorkflowTemplateEnum string

const (
	CreateWorkflowTemplateEnumFailover CreateWorkflowTemplateEnum = "failover"
)

func (e CreateWorkflowTemplateEnum) ToPointer() *CreateWorkflowTemplateEnum {
	return &e
}

func (e *CreateWorkflowTemplateEnum) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "failover":
		*e = CreateWorkflowTemplateEnum(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CreateWorkflowTemplateEnum: %v", v)
	}
}

type CreateWorkflowWorkflowType string

const (
	CreateWorkflowWorkflowTypeSendWithFailoverMessage CreateWorkflowWorkflowType = "sendWithFailoverMessage"
	CreateWorkflowWorkflowTypeSendMessage             CreateWorkflowWorkflowType = "sendMessage"
)

type CreateWorkflowWorkflow struct {
	SendWithFailoverMessage *SendWithFailoverMessage
	SendMessage             *SendMessage

	Type CreateWorkflowWorkflowType
}

func CreateCreateWorkflowWorkflowSendWithFailoverMessage(sendWithFailoverMessage SendWithFailoverMessage) CreateWorkflowWorkflow {
	typ := CreateWorkflowWorkflowTypeSendWithFailoverMessage

	return CreateWorkflowWorkflow{
		SendWithFailoverMessage: &sendWithFailoverMessage,
		Type:                    typ,
	}
}

func CreateCreateWorkflowWorkflowSendMessage(sendMessage SendMessage) CreateWorkflowWorkflow {
	typ := CreateWorkflowWorkflowTypeSendMessage

	return CreateWorkflowWorkflow{
		SendMessage: &sendMessage,
		Type:        typ,
	}
}

func (u *CreateWorkflowWorkflow) UnmarshalJSON(data []byte) error {
	var d *json.Decoder

	sendWithFailoverMessage := new(SendWithFailoverMessage)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&sendWithFailoverMessage); err == nil {
		u.SendWithFailoverMessage = sendWithFailoverMessage
		u.Type = CreateWorkflowWorkflowTypeSendWithFailoverMessage
		return nil
	}

	sendMessage := new(SendMessage)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&sendMessage); err == nil {
		u.SendMessage = sendMessage
		u.Type = CreateWorkflowWorkflowTypeSendMessage
		return nil
	}

	return errors.New("could not unmarshal into supported union types")
}

func (u CreateWorkflowWorkflow) MarshalJSON() ([]byte, error) {
	if u.SendWithFailoverMessage != nil {
		return json.Marshal(u.SendWithFailoverMessage)
	}

	if u.SendMessage != nil {
		return json.Marshal(u.SendMessage)
	}

	return nil, nil
}

// CreateWorkflow - Please note that last message does not have failover attribute inside it. All other messages must contain a failover attribute.
type CreateWorkflow struct {
	// The template that the Dispatch API will execute. For the initial version of the API the only available value will be failover
	Template *CreateWorkflowTemplateEnum `json:"template,omitempty"`
	// Contains a message object that must reflect the current /messages resource. All parameters within the content object reflect the /messages docs.
	Workflow []CreateWorkflowWorkflow `json:"workflow,omitempty"`
}
