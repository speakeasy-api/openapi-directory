/*
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

import * as utils from "../internal/utils";
import * as operations from "./models/operations";
import * as shared from "./models/shared";
import { AxiosInstance, AxiosRequestConfig, AxiosResponse } from "axios";

/**
 * Print shipping labels for any of the top global carriers in minutesâ€”instead of weeks. Simply [connect your existing carrier accounts](https://www.shipengine.com/docs/carriers/setup/) in the API dashboard, and then [begin creating labels](https://www.shipengine.com/docs/shipping/use-a-carrier-service/).
 *
 * @remarks
 *
 *
 * @see {@link https://www.shipengine.com/docs/labels/create-a-label/} - Follow this quick start guide to create your first shipping label with ShipEngine
 */
export class Labels {
  _defaultClient: AxiosInstance;
  _securityClient: AxiosInstance;
  _serverURL: string;
  _language: string;
  _sdkVersion: string;
  _genVersion: string;

  constructor(
    defaultClient: AxiosInstance,
    securityClient: AxiosInstance,
    serverURL: string,
    language: string,
    sdkVersion: string,
    genVersion: string
  ) {
    this._defaultClient = defaultClient;
    this._securityClient = securityClient;
    this._serverURL = serverURL;
    this._language = language;
    this._sdkVersion = sdkVersion;
    this._genVersion = genVersion;
  }

  /**
   * Purchase Label
   *
   * @remarks
   * Purchase and print a label for shipment
   */
  createLabel(
    req: shared.CreateLabelRequestBodyInput,
    config?: AxiosRequestConfig
  ): Promise<operations.CreateLabelResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new shared.CreateLabelRequestBodyInput(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/v1/labels";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "request",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CreateLabelResponse =
        new operations.CreateLabelResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.createLabelResponseBody = utils.objectToClass(
              httpRes?.data,
              shared.CreateLabelResponseBodyOutput
            );
          }
          break;
        case [400, 404, 500].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorResponseBody = utils.objectToClass(
              httpRes?.data,
              shared.ErrorResponseBody
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Purchase Label with Rate ID
   *
   * @remarks
   * When retrieving rates for shipments using the `/rates` endpoint, the returned information contains a `rate_id` property that can be used
   * to generate a label without having to refill in the shipment information repeatedly.
   *
   */
  createLabelFromRate(
    req: operations.CreateLabelFromRateRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.CreateLabelFromRateResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CreateLabelFromRateRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v1/labels/rates/{rate_id}",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "createLabelFromRateRequestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CreateLabelFromRateResponse =
        new operations.CreateLabelFromRateResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.createLabelFromRateResponseBody = utils.objectToClass(
              httpRes?.data,
              shared.CreateLabelFromRateResponseBodyOutput
            );
          }
          break;
        case [400, 404, 500].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorResponseBody = utils.objectToClass(
              httpRes?.data,
              shared.ErrorResponseBody
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Purchase Label with Shipment ID
   *
   * @remarks
   * Purchase a label using a shipment ID that has already been created with the desired address and
   * package info.
   *
   */
  createLabelFromShipment(
    req: operations.CreateLabelFromShipmentRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.CreateLabelFromShipmentResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CreateLabelFromShipmentRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v1/labels/shipment/{shipment_id}",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "createLabelFromShipmentRequestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CreateLabelFromShipmentResponse =
        new operations.CreateLabelFromShipmentResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.createLabelFromShipmentResponseBody = utils.objectToClass(
              httpRes?.data,
              shared.CreateLabelFromShipmentResponseBodyOutput
            );
          }
          break;
        case [400, 404, 500].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorResponseBody = utils.objectToClass(
              httpRes?.data,
              shared.ErrorResponseBody
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Create a return label
   *
   * @remarks
   * Create a return label
   */
  createReturnLabel(
    req: operations.CreateReturnLabelRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.CreateReturnLabelResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CreateReturnLabelRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v1/labels/{label_id}/return",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "createReturnLabelRequestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CreateReturnLabelResponse =
        new operations.CreateReturnLabelResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.createReturnLabelResponseBody = utils.objectToClass(
              httpRes?.data,
              shared.CreateReturnLabelResponseBodyOutput
            );
          }
          break;
        case [400, 404, 500].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorResponseBody = utils.objectToClass(
              httpRes?.data,
              shared.ErrorResponseBody
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Get Label By External Shipment ID
   *
   * @remarks
   * Find a label by using the external shipment id that was used during label creation
   *
   */
  getLabelByExternalShipmentId(
    req: operations.GetLabelByExternalShipmentIdRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetLabelByExternalShipmentIdResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetLabelByExternalShipmentIdRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v1/labels/external_shipment_id/{external_shipment_id}",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetLabelByExternalShipmentIdResponse =
        new operations.GetLabelByExternalShipmentIdResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getLabelByExternalShipmentIdResponseBody = utils.objectToClass(
              httpRes?.data,
              shared.GetLabelByExternalShipmentIdResponseBodyOutput
            );
          }
          break;
        case [400, 404, 500].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorResponseBody = utils.objectToClass(
              httpRes?.data,
              shared.ErrorResponseBody
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Get Label By ID
   *
   * @remarks
   * Retrieve information for individual labels.
   */
  getLabelById(
    req: operations.GetLabelByIdRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetLabelByIdResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetLabelByIdRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v1/labels/{label_id}",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetLabelByIdResponse =
        new operations.GetLabelByIdResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getLabelByIdResponseBody = utils.objectToClass(
              httpRes?.data,
              shared.GetLabelByIdResponseBodyOutput
            );
          }
          break;
        case [400, 404, 500].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorResponseBody = utils.objectToClass(
              httpRes?.data,
              shared.ErrorResponseBody
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Get Label Tracking Information
   *
   * @remarks
   * Retrieve the label's tracking information
   */
  getTrackingLogFromLabel(
    req: operations.GetTrackingLogFromLabelRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetTrackingLogFromLabelResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetTrackingLogFromLabelRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v1/labels/{label_id}/track",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetTrackingLogFromLabelResponse =
        new operations.GetTrackingLogFromLabelResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getTrackingLogFromLabelResponseBody = utils.objectToClass(
              httpRes?.data,
              shared.GetTrackingLogFromLabelResponseBody
            );
          }
          break;
        case [400, 404, 500].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorResponseBody = utils.objectToClass(
              httpRes?.data,
              shared.ErrorResponseBody
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * List labels
   *
   * @remarks
   * This endpoint returns a list of labels that you've [created](https://www.shipengine.com/docs/labels/create-a-label/). You can optionally filter the results as well as control their sort order and the number of results returned at a time.
   *
   * By default, all labels are returned, 25 at a time, starting with the most recently created ones.  You can combine multiple filter options to narrow-down the results.  For example, if you only want to get your UPS labels for your east coast warehouse you could query by both `warehouse_id` and `carrier_id`
   *
   */
  listLabels(
    req: operations.ListLabelsRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.ListLabelsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ListLabelsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/v1/labels";

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ListLabelsResponse =
        new operations.ListLabelsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listLabelsResponseBody = utils.objectToClass(httpRes?.data);
          }
          break;
        case [400, 500].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorResponseBody = utils.objectToClass(
              httpRes?.data,
              shared.ErrorResponseBody
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Void a Label By ID
   *
   * @remarks
   * Void a label by ID to get a refund.
   */
  voidLabel(
    req: operations.VoidLabelRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.VoidLabelResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.VoidLabelRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v1/labels/{label_id}/void",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "put",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.VoidLabelResponse =
        new operations.VoidLabelResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.voidLabelResponseBody = utils.objectToClass(
              httpRes?.data,
              shared.VoidLabelResponseBody
            );
          }
          break;
        case [400, 404, 500].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorResponseBody = utils.objectToClass(
              httpRes?.data,
              shared.ErrorResponseBody
            );
          }
          break;
      }

      return res;
    });
  }
}
