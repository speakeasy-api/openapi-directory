// Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.

package sdk

import (
	"context"
	"fmt"
	"net/http"
	"openapi/pkg/models/operations"
	"openapi/pkg/utils"
	"strings"
)

type skuApprovalSettings struct {
	defaultClient  HTTPClient
	securityClient HTTPClient
	serverURL      string
	language       string
	sdkVersion     string
	genVersion     string
}

func newSKUApprovalSettings(defaultClient, securityClient HTTPClient, serverURL, language, sdkVersion, genVersion string) *skuApprovalSettings {
	return &skuApprovalSettings{
		defaultClient:  defaultClient,
		securityClient: securityClient,
		serverURL:      serverURL,
		language:       language,
		sdkVersion:     sdkVersion,
		genVersion:     genVersion,
	}
}

// Getaccountconfig - Get Account's Approval Settings
// This endpoint retrieves the current approval settings of a marketplace's Received SKUs module. Its response includes:
//
// - `Score`: Matcher scores for approving and rejecting SKUs received from sellers.
//
// - `Matchers`: All Matchers configured on the marketplace, and their respective details.
//
// - `SpecificationsMapping`: Mapping of product and SKU specifications, per seller.
//
// - `MatchFlux`: This field determines the type of approval configuration applied to SKUs received from a seller.
//
// The possible values include:
//
// -`default`, where the Matcher reviews the SKU, and approves it based on its score.
//
// -`manual`, for manual approvals through the Received SKU UI, or Match API.
//
// -`autoApprove`, for every SKU received from a given seller to be approved automatically, regardless of their Matcher Score.
func (s *skuApprovalSettings) Getaccountconfig(ctx context.Context, request operations.GetaccountconfigRequest) (*operations.GetaccountconfigResponse, error) {
	baseURL := s.serverURL
	url := strings.TrimSuffix(baseURL, "/") + "/suggestions/configuration"

	req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	utils.PopulateHeaders(ctx, req, request)

	if err := utils.PopulateQueryParams(ctx, req, request, nil); err != nil {
		return nil, fmt.Errorf("error populating query params: %w", err)
	}

	client := s.securityClient

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.GetaccountconfigResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *operations.Getaccountconfig200ApplicationJSON
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.Getaccountconfig200ApplicationJSONObject = out
		}
	}

	return res, nil
}

// GetautoApprovevaluefromconfig - Get autoApprove Status in Account Settings
// This endpoint can be used to check whether the autoapprove setting is active or not, for a specific seller.
//
// If the response is `true`, the autoapprove setting is active. If the response is `false`, it is inactive.
func (s *skuApprovalSettings) GetautoApprovevaluefromconfig(ctx context.Context, request operations.GetautoApprovevaluefromconfigRequest) (*operations.GetautoApprovevaluefromconfigResponse, error) {
	baseURL := s.serverURL
	url := strings.TrimSuffix(baseURL, "/") + "/suggestions/configuration/autoapproval/toggle"

	req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	utils.PopulateHeaders(ctx, req, request)

	if err := utils.PopulateQueryParams(ctx, req, request, nil); err != nil {
		return nil, fmt.Errorf("error populating query params: %w", err)
	}

	client := s.securityClient

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.GetautoApprovevaluefromconfigResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *operations.GetautoApprovevaluefromconfig200ApplicationJSON
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.GetautoApprovevaluefromconfig200ApplicationJSONObject = out
		}
	}

	return res, nil
}

// Getselleraccountconfig - Get Seller's Approval Settings
// This endpoint retrieves the current Received SKUs approval settings applied to a specific seller. Its response includes:
//
// - `sellerId`: A string that identifies the seller in the marketplace.
//
// - `accountId`: Marketplace’s account ID.
//
// - `accountName`: Marketplace’s account name.
//
// - `mapping`: Mapping of SKU and product Specifications.
//
// - `matchFlux`: This field determines the type of approval configuration applied to SKUs received  from a seller.
//
// The possible values include:
//
// -`default`, where the Matcher reviews the SKU, and approves it based on its score.
//
// -`manual`, for manual approvals through the Received SKU UI and Match API.
//
// -`autoApprove`, for every SKU received from a given seller to be approved automatically, regardless of the Matcher Score.
func (s *skuApprovalSettings) Getselleraccountconfig(ctx context.Context, request operations.GetselleraccountconfigRequest) (*operations.GetselleraccountconfigResponse, error) {
	baseURL := s.serverURL
	url, err := utils.GenerateURL(ctx, baseURL, "/suggestions/configuration/seller/{sellerId}", request, nil)
	if err != nil {
		return nil, fmt.Errorf("error generating URL: %w", err)
	}

	req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	utils.PopulateHeaders(ctx, req, request)

	if err := utils.PopulateQueryParams(ctx, req, request, nil); err != nil {
		return nil, fmt.Errorf("error populating query params: %w", err)
	}

	client := s.securityClient

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.GetselleraccountconfigResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
	}

	return res, nil
}

// Putselleraccountconfig - Save Seller's Approval Settings
// Marketplaces use this endpoint to create or update approval settings to a specific seller, on the Received SKUs module.
//
// The request includes all the details necessary to implement the chosen approval settings.
func (s *skuApprovalSettings) Putselleraccountconfig(ctx context.Context, request operations.PutselleraccountconfigRequest) (*operations.PutselleraccountconfigResponse, error) {
	baseURL := s.serverURL
	url, err := utils.GenerateURL(ctx, baseURL, "/suggestions/configuration/seller/{sellerId}", request, nil)
	if err != nil {
		return nil, fmt.Errorf("error generating URL: %w", err)
	}

	bodyReader, reqContentType, err := utils.SerializeRequestBody(ctx, request, "PutselleraccountconfigRequest", "json")
	if err != nil {
		return nil, fmt.Errorf("error serializing request body: %w", err)
	}
	if bodyReader == nil {
		return nil, fmt.Errorf("request body is required")
	}

	req, err := http.NewRequestWithContext(ctx, "PUT", url, bodyReader)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	req.Header.Set("Content-Type", reqContentType)

	utils.PopulateHeaders(ctx, req, request)

	if err := utils.PopulateQueryParams(ctx, req, request, nil); err != nil {
		return nil, fmt.Errorf("error populating query params: %w", err)
	}

	client := s.securityClient

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.PutselleraccountconfigResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
	}

	return res, nil
}

// Saveaccountconfig - Save Account's Approval Settings
// Marketplaces use this endpoint to create or update approval settings on their Received SKUs module.
//
// The request includes all the details necessary to implement the chosen approval settings.
func (s *skuApprovalSettings) Saveaccountconfig(ctx context.Context, request operations.SaveaccountconfigRequest) (*operations.SaveaccountconfigResponse, error) {
	baseURL := s.serverURL
	url := strings.TrimSuffix(baseURL, "/") + "/suggestions/configuration"

	bodyReader, reqContentType, err := utils.SerializeRequestBody(ctx, request, "SaveaccountconfigRequest", "json")
	if err != nil {
		return nil, fmt.Errorf("error serializing request body: %w", err)
	}
	if bodyReader == nil {
		return nil, fmt.Errorf("request body is required")
	}

	req, err := http.NewRequestWithContext(ctx, "PUT", url, bodyReader)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	req.Header.Set("Content-Type", reqContentType)

	utils.PopulateHeaders(ctx, req, request)

	if err := utils.PopulateQueryParams(ctx, req, request, nil); err != nil {
		return nil, fmt.Errorf("error populating query params: %w", err)
	}

	client := s.securityClient

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.SaveaccountconfigResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *operations.Saveaccountconfig200ApplicationJSON
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.Saveaccountconfig200ApplicationJSONObject = out
		}
	}

	return res, nil
}

// Saveautoapproveforaccount - Activate autoApprove in Marketplace's Account
// This endpoint enables the autoapprove rule to a marketplace's whole Received SKUs module. Once enabling the rule, received SKUs will be automatically approved on your store, regardless of the seller.
//
//	For the autoapprove rule to work as expected, the approval [Matcher score](https://help.vtex.com/en/tutorial/entendendo-a-pontuacao-do-vtex-matcher--tutorials_424) should be set up as 80 (default value), but you can configure a different number through the field `Score` in [Save Account's Approval Settings](https://developers.vtex.com/vtex-rest-api/reference/saveaccountconfig).
func (s *skuApprovalSettings) Saveautoapproveforaccount(ctx context.Context, request operations.SaveautoapproveforaccountRequest) (*operations.SaveautoapproveforaccountResponse, error) {
	baseURL := s.serverURL
	url := strings.TrimSuffix(baseURL, "/") + "/suggestions/configuration/autoapproval/toggle"

	bodyReader, reqContentType, err := utils.SerializeRequestBody(ctx, request, "SaveautoapproveforaccountRequest", "json")
	if err != nil {
		return nil, fmt.Errorf("error serializing request body: %w", err)
	}
	if bodyReader == nil {
		return nil, fmt.Errorf("request body is required")
	}

	req, err := http.NewRequestWithContext(ctx, "PUT", url, bodyReader)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	req.Header.Set("Content-Type", reqContentType)

	utils.PopulateHeaders(ctx, req, request)

	if err := utils.PopulateQueryParams(ctx, req, request, nil); err != nil {
		return nil, fmt.Errorf("error populating query params: %w", err)
	}

	client := s.securityClient

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.SaveautoapproveforaccountResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *operations.Saveautoapproveforaccount200ApplicationJSON
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.Saveautoapproveforaccount200ApplicationJSONObject = out
		}
	}

	return res, nil
}

// Saveautoapproveforaccountseller - Activate autoApprove Setting for a Seller
// This endpoint enables the auto approve setting to received SKUs from a specific seller. Be aware that once enabling the rule through this request, all received SKUs from that seller will be automatically approved on your store, regardless of the Matcher Score.
func (s *skuApprovalSettings) Saveautoapproveforaccountseller(ctx context.Context, request operations.SaveautoapproveforaccountsellerRequest) (*operations.SaveautoapproveforaccountsellerResponse, error) {
	baseURL := s.serverURL
	url, err := utils.GenerateURL(ctx, baseURL, "/suggestions/configuration/autoapproval/toggle/seller/{sellerId}", request, nil)
	if err != nil {
		return nil, fmt.Errorf("error generating URL: %w", err)
	}

	bodyReader, reqContentType, err := utils.SerializeRequestBody(ctx, request, "SaveautoapproveforaccountsellerRequest", "json")
	if err != nil {
		return nil, fmt.Errorf("error serializing request body: %w", err)
	}
	if bodyReader == nil {
		return nil, fmt.Errorf("request body is required")
	}

	req, err := http.NewRequestWithContext(ctx, "PUT", url, bodyReader)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	req.Header.Set("Content-Type", reqContentType)

	utils.PopulateHeaders(ctx, req, request)

	if err := utils.PopulateQueryParams(ctx, req, request, nil); err != nil {
		return nil, fmt.Errorf("error populating query params: %w", err)
	}

	client := s.securityClient

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.SaveautoapproveforaccountsellerResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
	}

	return res, nil
}
