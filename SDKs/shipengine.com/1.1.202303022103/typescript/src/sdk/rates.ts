/*
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

import * as utils from "../internal/utils";
import * as operations from "./models/operations";
import * as shared from "./models/shared";
import { AxiosInstance, AxiosRequestConfig, AxiosResponse } from "axios";

/**
 * Make sure you ship as cost-effectively as possible by [quickly comparing rates](https://www.shipengine.com/docs/rates/) using the ShipEngine Rates API. As long as you have the carrier connected to your account, you'll be able to see and compare different rates and services.
 *
 * @remarks
 *
 *
 * @see {@link https://www.shipengine.com/docs/rates/} - This quick start guide shows you how to get shipping rates for multiple carriers so you can choose the fastest, cheapest, or most reliable option.
 *
 */
export class Rates {
  _defaultClient: AxiosInstance;
  _securityClient: AxiosInstance;
  _serverURL: string;
  _language: string;
  _sdkVersion: string;
  _genVersion: string;

  constructor(
    defaultClient: AxiosInstance,
    securityClient: AxiosInstance,
    serverURL: string,
    language: string,
    sdkVersion: string,
    genVersion: string
  ) {
    this._defaultClient = defaultClient;
    this._securityClient = securityClient;
    this._serverURL = serverURL;
    this._language = language;
    this._sdkVersion = sdkVersion;
    this._genVersion = genVersion;
  }

  /**
   * Get Shipping Rates
   *
   * @remarks
   * It's not uncommon that you want to give your customer the choice between whether they want to ship the fastest, cheapest, or the most trusted route. Most companies don't solely ship things using a single shipping option;
   * so we provide functionality to show you all your options!
   *
   */
  calculateRates(
    req: shared.CalculateRatesRequestBody,
    config?: AxiosRequestConfig
  ): Promise<operations.CalculateRatesResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new shared.CalculateRatesRequestBody(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/v1/rates";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "request",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CalculateRatesResponse =
        new operations.CalculateRatesResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.calculateRatesResponseBody = utils.objectToClass(
              httpRes?.data,
              shared.CalculateRatesResponseBody
            );
          }
          break;
        case [400, 500].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorResponseBody = utils.objectToClass(
              httpRes?.data,
              shared.ErrorResponseBody
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Get Bulk Rates
   *
   * @remarks
   * Get Bulk Shipment Rates
   */
  compareBulkRates(
    req: shared.CompareBulkRatesRequestBody,
    config?: AxiosRequestConfig
  ): Promise<operations.CompareBulkRatesResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new shared.CompareBulkRatesRequestBody(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/v1/rates/bulk";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "request",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CompareBulkRatesResponse =
        new operations.CompareBulkRatesResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.compareBulkRatesResponseBody = [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.compareBulkRatesResponseBody = utils.objectToClass(
              httpRes?.data,
              shared.BulkRate,
              resFieldDepth
            );
          }
          break;
        case [400, 500].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorResponseBody = utils.objectToClass(
              httpRes?.data,
              shared.ErrorResponseBody
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Estimate Rates
   *
   * @remarks
   * Get Rate Estimates
   */
  estimateRates(
    req: shared.EstimateRatesRequestBody,
    config?: AxiosRequestConfig
  ): Promise<operations.EstimateRatesResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new shared.EstimateRatesRequestBody(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/v1/rates/estimate";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "request",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.EstimateRatesResponse =
        new operations.EstimateRatesResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.estimateRatesResponseBody = [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.estimateRatesResponseBody = utils.objectToClass(
              httpRes?.data,
              shared.RateEstimate,
              resFieldDepth
            );
          }
          break;
        case [400, 500].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorResponseBody = utils.objectToClass(
              httpRes?.data,
              shared.ErrorResponseBody
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Get Rate By ID
   *
   * @remarks
   * Retrieve a previously queried rate by its ID
   */
  getRateById(
    req: operations.GetRateByIdRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetRateByIdResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetRateByIdRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(baseURL, "/v1/rates/{rate_id}", req);

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetRateByIdResponse =
        new operations.GetRateByIdResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getRateByIdResponseBody = utils.objectToClass(
              httpRes?.data,
              shared.GetRateByIdResponseBody
            );
          }
          break;
        case [400, 404, 500].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorResponseBody = utils.objectToClass(
              httpRes?.data,
              shared.ErrorResponseBody
            );
          }
          break;
      }

      return res;
    });
  }
}
