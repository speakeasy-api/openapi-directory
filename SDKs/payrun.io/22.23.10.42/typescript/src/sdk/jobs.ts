/*
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

import * as utils from "../internal/utils";
import * as operations from "./models/operations";
import * as shared from "./models/shared";
import { AxiosInstance, AxiosRequestConfig, AxiosResponse } from "axios";

export class Jobs {
  _defaultClient: AxiosInstance;
  _securityClient: AxiosInstance;
  _serverURL: string;
  _language: string;
  _sdkVersion: string;
  _genVersion: string;

  constructor(
    defaultClient: AxiosInstance,
    securityClient: AxiosInstance,
    serverURL: string,
    language: string,
    sdkVersion: string,
    genVersion: string
  ) {
    this._defaultClient = defaultClient;
    this._securityClient = securityClient;
    this._serverURL = serverURL;
    this._language = language;
    this._sdkVersion = sdkVersion;
    this._genVersion = genVersion;
  }

  /**
   * Delete the Batch job
   *
   * @remarks
   * Deletes the the Batch job
   */
  deleteBatchJob(
    req: operations.DeleteBatchJobRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.DeleteBatchJobResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DeleteBatchJobRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(baseURL, "/Jobs/Batch/{JobId}", req);

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };

    const r = client.request({
      url: url,
      method: "delete",
      headers: headers,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DeleteBatchJobResponse =
        new operations.DeleteBatchJobResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          break;
        case [400, 401, 404, 500].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorModel = utils.objectToClass(
              httpRes?.data,
              shared.ErrorModel
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Delete the CIS job
   *
   * @remarks
   * Deletes the the CIS job
   */
  deleteCisJob(
    req: operations.DeleteCisJobRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.DeleteCisJobResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DeleteCisJobRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(baseURL, "/Jobs/Cis/{JobId}", req);

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };

    const r = client.request({
      url: url,
      method: "delete",
      headers: headers,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DeleteCisJobResponse =
        new operations.DeleteCisJobResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          break;
        case [400, 401, 404, 500].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorModel = utils.objectToClass(
              httpRes?.data,
              shared.ErrorModel
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Delete the DPS job
   *
   * @remarks
   * Deletes the the DPS job
   */
  deleteDpsJob(
    req: operations.DeleteDpsJobRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.DeleteDpsJobResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DeleteDpsJobRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(baseURL, "/Jobs/Dps/{JobId}", req);

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };

    const r = client.request({
      url: url,
      method: "delete",
      headers: headers,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DeleteDpsJobResponse =
        new operations.DeleteDpsJobResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          break;
        case [400, 401, 404, 500].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorModel = utils.objectToClass(
              httpRes?.data,
              shared.ErrorModel
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Delete the pay run job
   *
   * @remarks
   * Deletes the the payrun job
   */
  deletePayRunJob(
    req: operations.DeletePayRunJobRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.DeletePayRunJobResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DeletePayRunJobRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/Jobs/PayRuns/{JobId}",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };

    const r = client.request({
      url: url,
      method: "delete",
      headers: headers,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DeletePayRunJobResponse =
        new operations.DeletePayRunJobResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          break;
        case [400, 401, 404, 500].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorModel = utils.objectToClass(
              httpRes?.data,
              shared.ErrorModel
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Delete the RTI job
   *
   * @remarks
   * Deletes the the RTI job
   */
  deleteRtiJob(
    req: operations.DeleteRtiJobRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.DeleteRtiJobResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DeleteRtiJobRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(baseURL, "/Jobs/Rti/{JobId}", req);

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };

    const r = client.request({
      url: url,
      method: "delete",
      headers: headers,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DeleteRtiJobResponse =
        new operations.DeleteRtiJobResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          break;
        case [400, 401, 404, 500].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorModel = utils.objectToClass(
              httpRes?.data,
              shared.ErrorModel
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Delete the Third Party job
   *
   * @remarks
   * Deletes the the Third Party job
   */
  deleteThirdPartyJob(
    req: operations.DeleteThirdPartyJobRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.DeleteThirdPartyJobResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DeleteThirdPartyJobRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/Jobs/ThirdParty/{JobId}",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };

    const r = client.request({
      url: url,
      method: "delete",
      headers: headers,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DeleteThirdPartyJobResponse =
        new operations.DeleteThirdPartyJobResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
        case [400, 401, 404, 500].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorModel = utils.objectToClass(
              httpRes?.data,
              shared.ErrorModel
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Get the Batch job information
   *
   * @remarks
   * Return the the Batch job information
   */
  getBatchJobInfo(
    req: operations.GetBatchJobInfoRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetBatchJobInfoResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetBatchJobInfoRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/Jobs/Batch/{JobId}/Info",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };

    const r = client.request({
      url: url,
      method: "get",
      headers: headers,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetBatchJobInfoResponse =
        new operations.GetBatchJobInfoResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.jobInfo = utils.objectToClass(httpRes?.data, shared.JobInfo);
          }
          break;
        case [400, 401, 404, 500].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorModel = utils.objectToClass(
              httpRes?.data,
              shared.ErrorModel
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Get the Batch job progress
   *
   * @remarks
   * Return the the Batch job progress
   */
  getBatchJobProgress(
    req: operations.GetBatchJobProgressRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetBatchJobProgressResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetBatchJobProgressRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/Jobs/Batch/{JobId}/Progress",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };

    const r = client.request({
      url: url,
      method: "get",
      headers: headers,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetBatchJobProgressResponse =
        new operations.GetBatchJobProgressResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          break;
        case [400, 401, 404, 500].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorModel = utils.objectToClass(
              httpRes?.data,
              shared.ErrorModel
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Get the Batch job status
   *
   * @remarks
   * Return the the Batch job status
   */
  getBatchJobStatus(
    req: operations.GetBatchJobStatusRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetBatchJobStatusResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetBatchJobStatusRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/Jobs/Batch/{JobId}/Status",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };

    const r = client.request({
      url: url,
      method: "get",
      headers: headers,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetBatchJobStatusResponse =
        new operations.GetBatchJobStatusResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          break;
        case [400, 401, 404, 500].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorModel = utils.objectToClass(
              httpRes?.data,
              shared.ErrorModel
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Get all Batch jobs
   *
   * @remarks
   * Gets all the Batch jobs
   */
  getBatchJobs(
    req: operations.GetBatchJobsRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetBatchJobsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetBatchJobsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/Jobs/Batch";

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };

    const r = client.request({
      url: url,
      method: "get",
      headers: headers,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetBatchJobsResponse =
        new operations.GetBatchJobsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.linkCollection = utils.objectToClass(
              httpRes?.data,
              shared.LinkCollection
            );
          }
          break;
        case [400, 401, 404, 500].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorModel = utils.objectToClass(
              httpRes?.data,
              shared.ErrorModel
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Get the CIS job information
   *
   * @remarks
   * Return the the CIS job information
   */
  getCisJobInfo(
    req: operations.GetCisJobInfoRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetCisJobInfoResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetCisJobInfoRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/Jobs/Cis/{JobId}/Info",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };

    const r = client.request({
      url: url,
      method: "get",
      headers: headers,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetCisJobInfoResponse =
        new operations.GetCisJobInfoResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.jobInfo = utils.objectToClass(httpRes?.data, shared.JobInfo);
          }
          break;
        case [400, 401, 404, 500].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorModel = utils.objectToClass(
              httpRes?.data,
              shared.ErrorModel
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Get the CIS job progress
   *
   * @remarks
   * Return the the CIS job progress
   */
  getCisJobProgress(
    req: operations.GetCisJobProgressRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetCisJobProgressResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetCisJobProgressRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/Jobs/Cis/{JobId}/Progress",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };

    const r = client.request({
      url: url,
      method: "get",
      headers: headers,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetCisJobProgressResponse =
        new operations.GetCisJobProgressResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          break;
        case [400, 401, 404, 500].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorModel = utils.objectToClass(
              httpRes?.data,
              shared.ErrorModel
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Get the CIS job status
   *
   * @remarks
   * Return the the CIS job status
   */
  getCisJobStatus(
    req: operations.GetCisJobStatusRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetCisJobStatusResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetCisJobStatusRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/Jobs/Cis/{JobId}/Status",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };

    const r = client.request({
      url: url,
      method: "get",
      headers: headers,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetCisJobStatusResponse =
        new operations.GetCisJobStatusResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          break;
        case [400, 401, 404, 500].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorModel = utils.objectToClass(
              httpRes?.data,
              shared.ErrorModel
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Get all CIS jobs
   *
   * @remarks
   * Gets all the CIS jobs
   */
  getCisJobs(
    req: operations.GetCisJobsRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetCisJobsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetCisJobsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/Jobs/Cis";

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };

    const r = client.request({
      url: url,
      method: "get",
      headers: headers,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetCisJobsResponse =
        new operations.GetCisJobsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.linkCollection = utils.objectToClass(
              httpRes?.data,
              shared.LinkCollection
            );
          }
          break;
        case [400, 401, 404, 500].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorModel = utils.objectToClass(
              httpRes?.data,
              shared.ErrorModel
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Get the DPS job information
   *
   * @remarks
   * Return the the DPS job information
   */
  getDpsJobInfo(
    req: operations.GetDpsJobInfoRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetDpsJobInfoResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetDpsJobInfoRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/Jobs/Dps/{JobId}/Info",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };

    const r = client.request({
      url: url,
      method: "get",
      headers: headers,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetDpsJobInfoResponse =
        new operations.GetDpsJobInfoResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.jobInfo = utils.objectToClass(httpRes?.data, shared.JobInfo);
          }
          break;
        case [400, 401, 404, 500].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorModel = utils.objectToClass(
              httpRes?.data,
              shared.ErrorModel
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Get the DPS job progress
   *
   * @remarks
   * Return the the DPS job progress
   */
  getDpsJobProgress(
    req: operations.GetDpsJobProgressRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetDpsJobProgressResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetDpsJobProgressRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/Jobs/Dps/{JobId}/Progress",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };

    const r = client.request({
      url: url,
      method: "get",
      headers: headers,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetDpsJobProgressResponse =
        new operations.GetDpsJobProgressResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          break;
        case [400, 401, 404, 500].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorModel = utils.objectToClass(
              httpRes?.data,
              shared.ErrorModel
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Get the DPS job status
   *
   * @remarks
   * Return the the DPS job status
   */
  getDpsJobStatus(
    req: operations.GetDpsJobStatusRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetDpsJobStatusResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetDpsJobStatusRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/Jobs/Dps/{JobId}/Status",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };

    const r = client.request({
      url: url,
      method: "get",
      headers: headers,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetDpsJobStatusResponse =
        new operations.GetDpsJobStatusResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          break;
        case [400, 401, 404, 500].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorModel = utils.objectToClass(
              httpRes?.data,
              shared.ErrorModel
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Get all DPS jobs
   *
   * @remarks
   * Gets all the DPS jobs
   */
  getDpsJobs(
    req: operations.GetDpsJobsRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetDpsJobsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetDpsJobsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/Jobs/Dps";

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };

    const r = client.request({
      url: url,
      method: "get",
      headers: headers,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetDpsJobsResponse =
        new operations.GetDpsJobsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.linkCollection = utils.objectToClass(
              httpRes?.data,
              shared.LinkCollection
            );
          }
          break;
        case [400, 401, 404, 500].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorModel = utils.objectToClass(
              httpRes?.data,
              shared.ErrorModel
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Gets all jobs relating to the employer.
   *
   * @remarks
   * Returns all job information objects for the specified employer.
   */
  getEmployerJobs(
    req: operations.GetEmployerJobsRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetEmployerJobsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetEmployerJobsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/Jobs/Employer/{EmployerId}",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };

    const r = client.request({
      url: url,
      method: "get",
      headers: headers,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetEmployerJobsResponse =
        new operations.GetEmployerJobsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            const resBody: string = JSON.stringify(httpRes?.data, null, 0);
            const out: Uint8Array = new Uint8Array(resBody.length);
            for (let i = 0; i < resBody.length; i++)
              out[i] = resBody.charCodeAt(i);
            res.getEmployerJobs200ApplicationJSONBinaryString = out;
          }
          break;
        case [400, 401, 404, 500].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorModel = utils.objectToClass(
              httpRes?.data,
              shared.ErrorModel
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Get the pay run job information
   *
   * @remarks
   * Return the the payrun job information
   */
  getPayRunJobInfo(
    req: operations.GetPayRunJobInfoRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetPayRunJobInfoResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetPayRunJobInfoRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/Jobs/PayRuns/{JobId}/Info",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };

    const r = client.request({
      url: url,
      method: "get",
      headers: headers,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetPayRunJobInfoResponse =
        new operations.GetPayRunJobInfoResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.jobInfo = utils.objectToClass(httpRes?.data, shared.JobInfo);
          }
          break;
        case [400, 401, 404, 500].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorModel = utils.objectToClass(
              httpRes?.data,
              shared.ErrorModel
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Get the pay run job progress
   *
   * @remarks
   * Return the the payrun job progress
   */
  getPayRunJobProgress(
    req: operations.GetPayRunJobProgressRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetPayRunJobProgressResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetPayRunJobProgressRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/Jobs/PayRuns/{JobId}/Progress",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };

    const r = client.request({
      url: url,
      method: "get",
      headers: headers,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetPayRunJobProgressResponse =
        new operations.GetPayRunJobProgressResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          break;
        case [400, 401, 404, 500].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorModel = utils.objectToClass(
              httpRes?.data,
              shared.ErrorModel
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Get the pay run job status
   *
   * @remarks
   * Return the the payrun job status
   */
  getPayRunJobStatus(
    req: operations.GetPayRunJobStatusRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetPayRunJobStatusResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetPayRunJobStatusRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/Jobs/PayRuns/{JobId}/Status",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };

    const r = client.request({
      url: url,
      method: "get",
      headers: headers,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetPayRunJobStatusResponse =
        new operations.GetPayRunJobStatusResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          break;
        case [400, 401, 404, 500].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorModel = utils.objectToClass(
              httpRes?.data,
              shared.ErrorModel
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Get all PayRun jobs
   *
   * @remarks
   * Gets all the pay run jobs
   */
  getPayRunJobs(
    req: operations.GetPayRunJobsRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetPayRunJobsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetPayRunJobsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/Jobs/PayRuns";

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };

    const r = client.request({
      url: url,
      method: "get",
      headers: headers,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetPayRunJobsResponse =
        new operations.GetPayRunJobsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.linkCollection = utils.objectToClass(
              httpRes?.data,
              shared.LinkCollection
            );
          }
          break;
        case [400, 401, 404, 500].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorModel = utils.objectToClass(
              httpRes?.data,
              shared.ErrorModel
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Get the RTI job information
   *
   * @remarks
   * Return the the RTI job information
   */
  getRtiJobInfo(
    req: operations.GetRtiJobInfoRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetRtiJobInfoResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetRtiJobInfoRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/Jobs/Rti/{JobId}/Info",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };

    const r = client.request({
      url: url,
      method: "get",
      headers: headers,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetRtiJobInfoResponse =
        new operations.GetRtiJobInfoResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.jobInfo = utils.objectToClass(httpRes?.data, shared.JobInfo);
          }
          break;
        case [400, 401, 404, 500].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorModel = utils.objectToClass(
              httpRes?.data,
              shared.ErrorModel
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Get the RTI job progress
   *
   * @remarks
   * Return the the RTI job progress
   */
  getRtiJobProgress(
    req: operations.GetRtiJobProgressRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetRtiJobProgressResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetRtiJobProgressRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/Jobs/Rti/{JobId}/Progress",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };

    const r = client.request({
      url: url,
      method: "get",
      headers: headers,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetRtiJobProgressResponse =
        new operations.GetRtiJobProgressResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          break;
        case [400, 401, 404, 500].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorModel = utils.objectToClass(
              httpRes?.data,
              shared.ErrorModel
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Get the RTI job status
   *
   * @remarks
   * Return the the RTI job status
   */
  getRtiJobStatus(
    req: operations.GetRtiJobStatusRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetRtiJobStatusResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetRtiJobStatusRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/Jobs/Rti/{JobId}/Status",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };

    const r = client.request({
      url: url,
      method: "get",
      headers: headers,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetRtiJobStatusResponse =
        new operations.GetRtiJobStatusResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          break;
        case [400, 401, 404, 500].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorModel = utils.objectToClass(
              httpRes?.data,
              shared.ErrorModel
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Get all RTI jobs
   *
   * @remarks
   * Gets all the RTI jobs
   */
  getRtiJobs(
    req: operations.GetRtiJobsRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetRtiJobsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetRtiJobsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/Jobs/Rti";

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };

    const r = client.request({
      url: url,
      method: "get",
      headers: headers,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetRtiJobsResponse =
        new operations.GetRtiJobsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.linkCollection = utils.objectToClass(
              httpRes?.data,
              shared.LinkCollection
            );
          }
          break;
        case [400, 401, 404, 500].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorModel = utils.objectToClass(
              httpRes?.data,
              shared.ErrorModel
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Get the Third Party job information
   *
   * @remarks
   * Return the the Third Party job information
   */
  getThirdPartyJobInfo(
    req: operations.GetThirdPartyJobInfoRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetThirdPartyJobInfoResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetThirdPartyJobInfoRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/Jobs/ThirdParty/{JobId}/Info",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };

    const r = client.request({
      url: url,
      method: "get",
      headers: headers,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetThirdPartyJobInfoResponse =
        new operations.GetThirdPartyJobInfoResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.jobInfo = utils.objectToClass(httpRes?.data, shared.JobInfo);
          }
          break;
        case [400, 401, 404, 500].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorModel = utils.objectToClass(
              httpRes?.data,
              shared.ErrorModel
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Get the Third Party job progress
   *
   * @remarks
   * Return the the Third Party job progress
   */
  getThirdPartyJobProgress(
    req: operations.GetThirdPartyJobProgressRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetThirdPartyJobProgressResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetThirdPartyJobProgressRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/Jobs/ThirdParty/{JobId}/Progress",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };

    const r = client.request({
      url: url,
      method: "get",
      headers: headers,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetThirdPartyJobProgressResponse =
        new operations.GetThirdPartyJobProgressResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          break;
        case [400, 401, 404, 500].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorModel = utils.objectToClass(
              httpRes?.data,
              shared.ErrorModel
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Get the Third Party job status
   *
   * @remarks
   * Return the the Third Party job status
   */
  getThirdPartyJobStatus(
    req: operations.GetThirdPartyJobStatusRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetThirdPartyJobStatusResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetThirdPartyJobStatusRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/Jobs/ThirdParty/{JobId}/Status",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };

    const r = client.request({
      url: url,
      method: "get",
      headers: headers,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetThirdPartyJobStatusResponse =
        new operations.GetThirdPartyJobStatusResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          break;
        case [400, 401, 404, 500].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorModel = utils.objectToClass(
              httpRes?.data,
              shared.ErrorModel
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Get all Third Party jobs
   *
   * @remarks
   * Gets all the Third Party jobs
   */
  getThirdPartyJobs(
    req: operations.GetThirdPartyJobsRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetThirdPartyJobsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetThirdPartyJobsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/Jobs/ThirdParty";

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };

    const r = client.request({
      url: url,
      method: "get",
      headers: headers,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetThirdPartyJobsResponse =
        new operations.GetThirdPartyJobsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.linkCollection = utils.objectToClass(
              httpRes?.data,
              shared.LinkCollection
            );
          }
          break;
        case [400, 401, 404, 500].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorModel = utils.objectToClass(
              httpRes?.data,
              shared.ErrorModel
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Create new Batch job
   *
   * @remarks
   * Adds a new Batch job to the queue and returns the job info
   */
  postNewBatchJob(
    req: operations.PostNewBatchJobRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.PostNewBatchJobResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PostNewBatchJobRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/Jobs/Batch";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "batchJobInstruction",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._defaultClient;

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PostNewBatchJobResponse =
        new operations.PostNewBatchJobResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.link = utils.objectToClass(httpRes?.data, shared.Link);
          }
          break;
        case [400, 401, 404, 500].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorModel = utils.objectToClass(
              httpRes?.data,
              shared.ErrorModel
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Create new CIS job
   *
   * @remarks
   * Adds a new CIS job to the queue and returns the job info
   */
  postNewCisJob(
    req: operations.PostNewCisJobRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.PostNewCisJobResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PostNewCisJobRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/Jobs/Cis";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "cisJobInstructionBase",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._defaultClient;

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PostNewCisJobResponse =
        new operations.PostNewCisJobResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.link = utils.objectToClass(httpRes?.data, shared.Link);
          }
          break;
        case [400, 401, 404, 500].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorModel = utils.objectToClass(
              httpRes?.data,
              shared.ErrorModel
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Create new DPS job
   *
   * @remarks
   * Creates the new DPS job to the queue and returns the job info
   */
  postNewDpsJob(
    req: operations.PostNewDpsJobRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.PostNewDpsJobResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PostNewDpsJobRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/Jobs/Dps";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "dpsJobInstruction",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._defaultClient;

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PostNewDpsJobResponse =
        new operations.PostNewDpsJobResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.link = utils.objectToClass(httpRes?.data, shared.Link);
          }
          break;
        case [400, 401, 404, 500].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorModel = utils.objectToClass(
              httpRes?.data,
              shared.ErrorModel
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Create new PayRun job
   *
   * @remarks
   * Creates the new pay run job to the queue and returns the job info
   */
  postNewPayRunJob(
    req: operations.PostNewPayRunJobRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.PostNewPayRunJobResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PostNewPayRunJobRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/Jobs/PayRuns";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "payRunJobInstruction",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._defaultClient;

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PostNewPayRunJobResponse =
        new operations.PostNewPayRunJobResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.link = utils.objectToClass(httpRes?.data, shared.Link);
          }
          break;
        case [400, 401, 404, 500].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorModel = utils.objectToClass(
              httpRes?.data,
              shared.ErrorModel
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Create new RTI job
   *
   * @remarks
   * Creates the new RTI job to the queue and returns the job info
   */
  postNewRtiJob(
    req: operations.PostNewRtiJobRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.PostNewRtiJobResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PostNewRtiJobRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/Jobs/Rti";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "rtiJobInstruction",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._defaultClient;

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PostNewRtiJobResponse =
        new operations.PostNewRtiJobResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.link = utils.objectToClass(httpRes?.data, shared.Link);
          }
          break;
        case [400, 401, 404, 500].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorModel = utils.objectToClass(
              httpRes?.data,
              shared.ErrorModel
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Create new Third Party job
   *
   * @remarks
   * Adds a new Third Party job to the queue and returns the job info
   */
  postNewThirdPartyJob(
    req: operations.PostNewThirdPartyJobRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.PostNewThirdPartyJobResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PostNewThirdPartyJobRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/Jobs/ThirdParty";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "thirdPartyJobInstruction",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._defaultClient;

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PostNewThirdPartyJobResponse =
        new operations.PostNewThirdPartyJobResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.link = utils.objectToClass(httpRes?.data, shared.Link);
          }
          break;
        case [400, 401, 404, 500].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorModel = utils.objectToClass(
              httpRes?.data,
              shared.ErrorModel
            );
          }
          break;
      }

      return res;
    });
  }
}
