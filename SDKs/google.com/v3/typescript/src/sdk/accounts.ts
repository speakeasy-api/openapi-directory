/*
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

import * as utils from "../internal/utils";
import * as operations from "./models/operations";
import * as shared from "./models/shared";
import { AxiosInstance, AxiosRequestConfig, AxiosResponse } from "axios";

export class Accounts {
  _defaultClient: AxiosInstance;
  _securityClient: AxiosInstance;
  _serverURL: string;
  _language: string;
  _sdkVersion: string;
  _genVersion: string;

  constructor(
    defaultClient: AxiosInstance,
    securityClient: AxiosInstance,
    serverURL: string,
    language: string,
    sdkVersion: string,
    genVersion: string
  ) {
    this._defaultClient = defaultClient;
    this._securityClient = securityClient;
    this._serverURL = serverURL;
    this._language = language;
    this._sdkVersion = sdkVersion;
    this._genVersion = genVersion;
  }

  /**
   * Creates a new account link between a Hotel Center account and a Google Ads account.
   */
  travelpartnerAccountsAccountLinksCreate(
    req: operations.TravelpartnerAccountsAccountLinksCreateRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.TravelpartnerAccountsAccountLinksCreateResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.TravelpartnerAccountsAccountLinksCreateRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v3/{parent}/accountLinks",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "accountLink",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.TravelpartnerAccountsAccountLinksCreateResponse =
        new operations.TravelpartnerAccountsAccountLinksCreateResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.accountLink = utils.objectToClass(
              httpRes?.data,
              shared.AccountLink
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Deletes an account link.
   */
  travelpartnerAccountsAccountLinksDelete(
    req: operations.TravelpartnerAccountsAccountLinksDeleteRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.TravelpartnerAccountsAccountLinksDeleteResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.TravelpartnerAccountsAccountLinksDeleteRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(baseURL, "/v3/{name}", req);

    const client: AxiosInstance = this._defaultClient;

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.TravelpartnerAccountsAccountLinksDeleteResponse =
        new operations.TravelpartnerAccountsAccountLinksDeleteResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.empty = utils.objectToClass(httpRes?.data);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Returns the account links for a Hotel Center account.
   */
  travelpartnerAccountsAccountLinksList(
    req: operations.TravelpartnerAccountsAccountLinksListRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.TravelpartnerAccountsAccountLinksListResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.TravelpartnerAccountsAccountLinksListRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v3/{parent}/accountLinks",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.TravelpartnerAccountsAccountLinksListResponse =
        new operations.TravelpartnerAccountsAccountLinksListResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listAccountLinksResponse = utils.objectToClass(
              httpRes?.data,
              shared.ListAccountLinksResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Creates a new brand. Because Google detects brands from your existing properties, you only need this operation when you want to configure a brand before you send its properties to Google. Note that it might take a couple of days after your listing feed first provides a brand for the brand to appear.
   */
  travelpartnerAccountsBrandsCreate(
    req: operations.TravelpartnerAccountsBrandsCreateRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.TravelpartnerAccountsBrandsCreateResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.TravelpartnerAccountsBrandsCreateRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(baseURL, "/v3/{parent}/brands", req);

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "brandInput",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.TravelpartnerAccountsBrandsCreateResponse =
        new operations.TravelpartnerAccountsBrandsCreateResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.brand = utils.objectToClass(httpRes?.data, shared.Brand);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Returns the brands for a partner account.
   */
  travelpartnerAccountsBrandsList(
    req: operations.TravelpartnerAccountsBrandsListRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.TravelpartnerAccountsBrandsListResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.TravelpartnerAccountsBrandsListRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(baseURL, "/v3/{parent}/brands", req);

    const client: AxiosInstance = this._defaultClient;

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.TravelpartnerAccountsBrandsListResponse =
        new operations.TravelpartnerAccountsBrandsListResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listBrandsResponse = utils.objectToClass(
              httpRes?.data,
              shared.ListBrandsResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Updates a brand.
   */
  travelpartnerAccountsBrandsPatch(
    req: operations.TravelpartnerAccountsBrandsPatchRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.TravelpartnerAccountsBrandsPatchResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.TravelpartnerAccountsBrandsPatchRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(baseURL, "/v3/{name}", req);

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "brandInput",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "patch",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.TravelpartnerAccountsBrandsPatchResponse =
        new operations.TravelpartnerAccountsBrandsPatchResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.brand = utils.objectToClass(httpRes?.data, shared.Brand);
          }
          break;
      }

      return res;
    });
  }

  /**
   * **DEPRECATED:** Use PropertyPerformanceReportService.QueryPropertyPerformanceReport, which also has impression reporting, instead. Provides the ability to query (get, filter, and segment) a free booking links report for a specific account.
   */
  travelpartnerAccountsFreeBookingLinksReportViewsQuery(
    req: operations.TravelpartnerAccountsFreeBookingLinksReportViewsQueryRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.TravelpartnerAccountsFreeBookingLinksReportViewsQueryResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.TravelpartnerAccountsFreeBookingLinksReportViewsQueryRequest(
          req
        );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v3/{name}/freeBookingLinksReportViews:query",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.TravelpartnerAccountsFreeBookingLinksReportViewsQueryResponse =
        new operations.TravelpartnerAccountsFreeBookingLinksReportViewsQueryResponse(
          {
            statusCode: httpRes.status,
            contentType: contentType,
            rawResponse: httpRes,
          }
        );
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.queryFreeBookingLinksReportResponse = utils.objectToClass(
              httpRes?.data,
              shared.QueryFreeBookingLinksReportResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Returns the list of hotel views.
   */
  travelpartnerAccountsHotelViewsList(
    req: operations.TravelpartnerAccountsHotelViewsListRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.TravelpartnerAccountsHotelViewsListResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.TravelpartnerAccountsHotelViewsListRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v3/{parent}/hotelViews",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.TravelpartnerAccountsHotelViewsListResponse =
        new operations.TravelpartnerAccountsHotelViewsListResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listHotelViewsResponse = utils.objectToClass(
              httpRes?.data,
              shared.ListHotelViewsResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Returns summarized information about hotels.
   */
  travelpartnerAccountsHotelViewsSummarize(
    req: operations.TravelpartnerAccountsHotelViewsSummarizeRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.TravelpartnerAccountsHotelViewsSummarizeResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.TravelpartnerAccountsHotelViewsSummarizeRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v3/{parent}/hotelViews:summarize",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.TravelpartnerAccountsHotelViewsSummarizeResponse =
        new operations.TravelpartnerAccountsHotelViewsSummarizeResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.summarizeHotelViewsResponse = utils.objectToClass(
              httpRes?.data,
              shared.SummarizeHotelViewsResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Collection-level custom method to update the Live on Google status for multiple properties. Each call can turn on or off multiple hotels. To turn some hotels on and turn some hotels off, you will have to make multiple calls.
   */
  travelpartnerAccountsHotelsSetLiveOnGoogle(
    req: operations.TravelpartnerAccountsHotelsSetLiveOnGoogleRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.TravelpartnerAccountsHotelsSetLiveOnGoogleResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.TravelpartnerAccountsHotelsSetLiveOnGoogleRequest(
        req
      );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v3/{account}/hotels:setLiveOnGoogle",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "setLiveOnGoogleRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.TravelpartnerAccountsHotelsSetLiveOnGoogleResponse =
        new operations.TravelpartnerAccountsHotelsSetLiveOnGoogleResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.setLiveOnGoogleResponse = utils.objectToClass(
              httpRes?.data,
              shared.SetLiveOnGoogleResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Uploads a new icon and starts its review process. Generates an `icon_id` and includes it in the icon's resource name, which is the format `accounts/{account_id}/icons/{icon_id}` Returns HTTP status 400 and doesn't trigger the review process if the icon has any of these conditions: * Image is not in PNG format, or not convertible to PNG format. * Size less than 72 pixels * Size greater than 1200 pixels * Aspect ratio other than 1:1
   */
  travelpartnerAccountsIconsCreate(
    req: operations.TravelpartnerAccountsIconsCreateRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.TravelpartnerAccountsIconsCreateResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.TravelpartnerAccountsIconsCreateRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(baseURL, "/v3/{parent}/icons", req);

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "iconInput",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.TravelpartnerAccountsIconsCreateResponse =
        new operations.TravelpartnerAccountsIconsCreateResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.icon = utils.objectToClass(httpRes?.data, shared.Icon);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Returns the `Icon`s for a partner account.
   */
  travelpartnerAccountsIconsList(
    req: operations.TravelpartnerAccountsIconsListRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.TravelpartnerAccountsIconsListResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.TravelpartnerAccountsIconsListRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(baseURL, "/v3/{parent}/icons", req);

    const client: AxiosInstance = this._defaultClient;

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.TravelpartnerAccountsIconsListResponse =
        new operations.TravelpartnerAccountsIconsListResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listIconsResponse = utils.objectToClass(
              httpRes?.data,
              shared.ListIconsResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * returns verified listings with data issues and serving eligibilities
   */
  travelpartnerAccountsListingsVerify(
    req: operations.TravelpartnerAccountsListingsVerifyRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.TravelpartnerAccountsListingsVerifyResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.TravelpartnerAccountsListingsVerifyRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v3/{parent}/listings:verify",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "verifyListingsRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.TravelpartnerAccountsListingsVerifyResponse =
        new operations.TravelpartnerAccountsListingsVerifyResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.verifyListingsResponse = utils.objectToClass(
              httpRes?.data,
              shared.VerifyListingsResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Provides the ability to query (get, filter, and segment) a participation report for a particular account.
   */
  travelpartnerAccountsParticipationReportViewsQuery(
    req: operations.TravelpartnerAccountsParticipationReportViewsQueryRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.TravelpartnerAccountsParticipationReportViewsQueryResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.TravelpartnerAccountsParticipationReportViewsQueryRequest(
          req
        );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v3/{name}/participationReportViews:query",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.TravelpartnerAccountsParticipationReportViewsQueryResponse =
        new operations.TravelpartnerAccountsParticipationReportViewsQueryResponse(
          {
            statusCode: httpRes.status,
            contentType: contentType,
            rawResponse: httpRes,
          }
        );
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.queryParticipationReportResponse = utils.objectToClass(
              httpRes?.data,
              shared.QueryParticipationReportResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Lists the available price accuracy views.
   */
  travelpartnerAccountsPriceAccuracyViewsList(
    req: operations.TravelpartnerAccountsPriceAccuracyViewsListRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.TravelpartnerAccountsPriceAccuracyViewsListResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.TravelpartnerAccountsPriceAccuracyViewsListRequest(
        req
      );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v3/{parent}/priceAccuracyViews",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.TravelpartnerAccountsPriceAccuracyViewsListResponse =
        new operations.TravelpartnerAccountsPriceAccuracyViewsListResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listPriceAccuracyViewsResponse = utils.objectToClass(
              httpRes?.data,
              shared.ListPriceAccuracyViewsResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Returns the price accuracy summary.
   */
  travelpartnerAccountsPriceAccuracyViewsSummarize(
    req: operations.TravelpartnerAccountsPriceAccuracyViewsSummarizeRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.TravelpartnerAccountsPriceAccuracyViewsSummarizeResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.TravelpartnerAccountsPriceAccuracyViewsSummarizeRequest(
          req
        );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v3/{parent}/priceAccuracyViews:summarize",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.TravelpartnerAccountsPriceAccuracyViewsSummarizeResponse =
        new operations.TravelpartnerAccountsPriceAccuracyViewsSummarizeResponse(
          {
            statusCode: httpRes.status,
            contentType: contentType,
            rawResponse: httpRes,
          }
        );
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.summarizePriceAccuracyResponse = utils.objectToClass(
              httpRes?.data,
              shared.SummarizePriceAccuracyResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Returns the latest price coverage view in full detail.
   */
  travelpartnerAccountsPriceCoverageViewsGetLatest(
    req: operations.TravelpartnerAccountsPriceCoverageViewsGetLatestRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.TravelpartnerAccountsPriceCoverageViewsGetLatestResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.TravelpartnerAccountsPriceCoverageViewsGetLatestRequest(
          req
        );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v3/{parent}/priceCoverageViews:latest",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.TravelpartnerAccountsPriceCoverageViewsGetLatestResponse =
        new operations.TravelpartnerAccountsPriceCoverageViewsGetLatestResponse(
          {
            statusCode: httpRes.status,
            contentType: contentType,
            rawResponse: httpRes,
          }
        );
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.priceCoverageView = utils.objectToClass(
              httpRes?.data,
              shared.PriceCoverageView
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Returns the entire price coverage history.
   */
  travelpartnerAccountsPriceCoverageViewsList(
    req: operations.TravelpartnerAccountsPriceCoverageViewsListRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.TravelpartnerAccountsPriceCoverageViewsListResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.TravelpartnerAccountsPriceCoverageViewsListRequest(
        req
      );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v3/{parent}/priceCoverageViews",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.TravelpartnerAccountsPriceCoverageViewsListResponse =
        new operations.TravelpartnerAccountsPriceCoverageViewsListResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listPriceCoverageViewsResponse = utils.objectToClass(
              httpRes?.data,
              shared.ListPriceCoverageViewsResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Provides the ability to query (get, filter, and segment) a property performance links report for a specific account.
   */
  travelpartnerAccountsPropertyPerformanceReportViewsQuery(
    req: operations.TravelpartnerAccountsPropertyPerformanceReportViewsQueryRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.TravelpartnerAccountsPropertyPerformanceReportViewsQueryResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.TravelpartnerAccountsPropertyPerformanceReportViewsQueryRequest(
          req
        );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v3/{name}/propertyPerformanceReportViews:query",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.TravelpartnerAccountsPropertyPerformanceReportViewsQueryResponse =
        new operations.TravelpartnerAccountsPropertyPerformanceReportViewsQueryResponse(
          {
            statusCode: httpRes.status,
            contentType: contentType,
            rawResponse: httpRes,
          }
        );
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.queryPropertyPerformanceReportResponse = utils.objectToClass(
              httpRes?.data,
              shared.QueryPropertyPerformanceReportResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Creates a reconciliation report and uploads it to Google.
   */
  travelpartnerAccountsReconciliationReportsCreate(
    req: operations.TravelpartnerAccountsReconciliationReportsCreateRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.TravelpartnerAccountsReconciliationReportsCreateResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.TravelpartnerAccountsReconciliationReportsCreateRequest(
          req
        );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v3/{parent}/reconciliationReports",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "reconciliationReport",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.TravelpartnerAccountsReconciliationReportsCreateResponse =
        new operations.TravelpartnerAccountsReconciliationReportsCreateResponse(
          {
            statusCode: httpRes.status,
            contentType: contentType,
            rawResponse: httpRes,
          }
        );
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.createReconciliationReportResponse = utils.objectToClass(
              httpRes?.data,
              shared.CreateReconciliationReportResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Returns a reconciliation report.
   */
  travelpartnerAccountsReconciliationReportsGet(
    req: operations.TravelpartnerAccountsReconciliationReportsGetRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.TravelpartnerAccountsReconciliationReportsGetResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.TravelpartnerAccountsReconciliationReportsGetRequest(
        req
      );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(baseURL, "/v3/{name}", req);

    const client: AxiosInstance = this._defaultClient;

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.TravelpartnerAccountsReconciliationReportsGetResponse =
        new operations.TravelpartnerAccountsReconciliationReportsGetResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.reconciliationReport = utils.objectToClass(
              httpRes?.data,
              shared.ReconciliationReport
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Returns a list of the names of created reconciliation reports.
   */
  travelpartnerAccountsReconciliationReportsList(
    req: operations.TravelpartnerAccountsReconciliationReportsListRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.TravelpartnerAccountsReconciliationReportsListResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.TravelpartnerAccountsReconciliationReportsListRequest(
          req
        );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v3/{parent}/reconciliationReports",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.TravelpartnerAccountsReconciliationReportsListResponse =
        new operations.TravelpartnerAccountsReconciliationReportsListResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listReconciliationReportsResponse = utils.objectToClass(
              httpRes?.data,
              shared.ListReconciliationReportsResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Validates a reconciliation report.
   */
  travelpartnerAccountsReconciliationReportsValidate(
    req: operations.TravelpartnerAccountsReconciliationReportsValidateRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.TravelpartnerAccountsReconciliationReportsValidateResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.TravelpartnerAccountsReconciliationReportsValidateRequest(
          req
        );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v3/{parent}/reconciliationReports:validate",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "reconciliationReport",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.TravelpartnerAccountsReconciliationReportsValidateResponse =
        new operations.TravelpartnerAccountsReconciliationReportsValidateResponse(
          {
            statusCode: httpRes.status,
            contentType: contentType,
            rawResponse: httpRes,
          }
        );
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.validateReconciliationReportResponse = utils.objectToClass(
              httpRes?.data,
              shared.ValidateReconciliationReportResponse
            );
          }
          break;
      }

      return res;
    });
  }
}
