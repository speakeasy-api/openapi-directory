"use strict";
/*
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.OrderBy = void 0;
var utils_1 = require("../../../internal/utils");
var dimensionorderby_1 = require("./dimensionorderby");
var metricorderby_1 = require("./metricorderby");
var pivotorderby_1 = require("./pivotorderby");
var class_transformer_1 = require("class-transformer");
/**
 * Order bys define how rows will be sorted in the response. For example, ordering rows by descending event count is one ordering, and ordering rows by the event name string is a different ordering.
 */
var OrderBy = /** @class */ (function (_super) {
    __extends(OrderBy, _super);
    function OrderBy() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate([
        (0, utils_1.SpeakeasyMetadata)(),
        (0, class_transformer_1.Expose)({ name: "desc" }),
        __metadata("design:type", Boolean)
    ], OrderBy.prototype, "desc", void 0);
    __decorate([
        (0, utils_1.SpeakeasyMetadata)(),
        (0, class_transformer_1.Expose)({ name: "dimension" }),
        (0, class_transformer_1.Type)(function () { return dimensionorderby_1.DimensionOrderBy; }),
        __metadata("design:type", dimensionorderby_1.DimensionOrderBy)
    ], OrderBy.prototype, "dimension", void 0);
    __decorate([
        (0, utils_1.SpeakeasyMetadata)(),
        (0, class_transformer_1.Expose)({ name: "metric" }),
        (0, class_transformer_1.Type)(function () { return metricorderby_1.MetricOrderBy; }),
        __metadata("design:type", metricorderby_1.MetricOrderBy)
    ], OrderBy.prototype, "metric", void 0);
    __decorate([
        (0, utils_1.SpeakeasyMetadata)(),
        (0, class_transformer_1.Expose)({ name: "pivot" }),
        (0, class_transformer_1.Type)(function () { return pivotorderby_1.PivotOrderBy; }),
        __metadata("design:type", pivotorderby_1.PivotOrderBy)
    ], OrderBy.prototype, "pivot", void 0);
    return OrderBy;
}(utils_1.SpeakeasyBase));
exports.OrderBy = OrderBy;
