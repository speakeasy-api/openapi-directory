"""Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT."""

import requests as requests_http
from . import utils
from sdk.models import operations, shared
from typing import Any, Optional

SERVERS = [
    "http://appmesh.{region}.amazonaws.com",
    r"""The AWS App Mesh multi-region endpoint"""
    "https://appmesh.{region}.amazonaws.com",
    r"""The AWS App Mesh multi-region endpoint"""
    "http://appmesh.{region}.amazonaws.com.cn",
    r"""The AWS App Mesh endpoint for China (Beijing) and China (Ningxia)"""
    "https://appmesh.{region}.amazonaws.com.cn",
    r"""The AWS App Mesh endpoint for China (Beijing) and China (Ningxia)"""
]
"""Contains the list of servers available to the SDK"""

class SDK:
    r"""<p>AWS App Mesh is a service mesh based on the Envoy proxy that makes it easy to monitor and
             control containerized microservices. App Mesh standardizes how your microservices
             communicate, giving you end-to-end visibility and helping to ensure high-availability for
             your applications.</p>
             <p>App Mesh gives you consistent visibility and network traffic controls for every
             microservice in an application. You can use App Mesh with Amazon ECS
             (using the Amazon EC2 launch type), Amazon EKS, and Kubernetes on AWS.</p>
             <note>
                <p>App Mesh supports containerized microservice applications that use service discovery
                naming for their components. To use App Mesh, you must have a containerized application
                running on Amazon EC2 instances, hosted in either Amazon ECS, Amazon EKS, or Kubernetes on AWS. For
                more information about service discovery on Amazon ECS, see <a href=\"http://docs.aws.amazon.com/AmazonECS/latest/developerguide/service-discovery.html\">Service Discovery</a> in the
                   <i>Amazon Elastic Container Service Developer Guide</i>. Kubernetes <code>kube-dns</code> is supported.
                For more information, see <a href=\"https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/\">DNS
                   for Services and Pods</a> in the Kubernetes documentation.</p>
             </note>
    https://docs.aws.amazon.com/appmesh/ - Amazon Web Services documentation
    """

    _client: requests_http.Session
    _security_client: requests_http.Session
    _server_url: str = SERVERS[0]
    _language: str = "python"
    _sdk_version: str = "0.0.1"
    _gen_version: str = "internal"

    def __init__(self,
                 security: shared.Security = None,
                 server_url: str = None,
                 url_params: dict[str, str] = None,
                 client: requests_http.Session = None
                 ) -> None:
        """Instantiates the SDK configuring it with the provided parameters.
        
        :param security: The security details required for authentication
        :type security: shared.Security
        :param server_url: The server URL to use for all operations
        :type server_url: str
        :param url_params: Parameters to optionally template the server URL with
        :type url_params: dict[str, str]
        :param client: The requests.Session HTTP client to use for all operations
        :type client: requests_http.Session        
        """
        self._client = requests_http.Session()
        
        
        if server_url is not None:
            if url_params is not None:
                self._server_url = utils.template_url(server_url, url_params)
            else:
                self._server_url = server_url

        if client is not None:
            self._client = client
        
        self._security_client = utils.configure_security_client(self._client, security)
        

        
    
    
    def create_mesh(self, request: operations.CreateMeshRequest) -> operations.CreateMeshResponse:
        r"""<p>Creates a new service mesh. A service mesh is a logical boundary for network traffic
                 between the services that reside within it.</p>
                 <p>After you create your service mesh, you can create virtual nodes, virtual routers, and
                 routes to distribute traffic between the applications in your mesh.</p>
        """
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/meshes'
        
        headers = utils.get_headers(request)
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = self._security_client
        
        http_res = client.request('PUT', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.CreateMeshResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.CreateMeshOutput])
                res.create_mesh_output = out
        elif http_res.status_code == 480:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.bad_request_exception = out
        elif http_res.status_code == 481:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.conflict_exception = out
        elif http_res.status_code == 482:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.forbidden_exception = out
        elif http_res.status_code == 483:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.internal_server_error_exception = out
        elif http_res.status_code == 484:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.limit_exceeded_exception = out
        elif http_res.status_code == 485:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.not_found_exception = out
        elif http_res.status_code == 486:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.service_unavailable_exception = out
        elif http_res.status_code == 487:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.too_many_requests_exception = out

        return res

    def create_route(self, request: operations.CreateRouteRequest) -> operations.CreateRouteResponse:
        r"""<p>Creates a new route that is associated with a virtual router.</p>
                 <p>You can use the <code>prefix</code> parameter in your route specification for path-based
                 routing of requests. For example, if your virtual router service name is
                    <code>my-service.local</code>, and you want the route to match requests to
                    <code>my-service.local/metrics</code>, then your prefix should be
                 <code>/metrics</code>.</p>
                 <p>If your route matches a request, you can distribute traffic to one or more target
                 virtual nodes with relative weighting.</p>
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.CreateRouteRequest, base_url, '/meshes/{meshName}/virtualRouter/{virtualRouterName}/routes', request)
        
        headers = utils.get_headers(request)
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = self._security_client
        
        http_res = client.request('PUT', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.CreateRouteResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.CreateRouteOutput])
                res.create_route_output = out
        elif http_res.status_code == 480:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.bad_request_exception = out
        elif http_res.status_code == 481:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.conflict_exception = out
        elif http_res.status_code == 482:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.forbidden_exception = out
        elif http_res.status_code == 483:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.internal_server_error_exception = out
        elif http_res.status_code == 484:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.limit_exceeded_exception = out
        elif http_res.status_code == 485:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.not_found_exception = out
        elif http_res.status_code == 486:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.service_unavailable_exception = out
        elif http_res.status_code == 487:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.too_many_requests_exception = out

        return res

    def create_virtual_node(self, request: operations.CreateVirtualNodeRequest) -> operations.CreateVirtualNodeResponse:
        r"""<p>Creates a new virtual node within a service mesh.</p>
                 <p>A virtual node acts as logical pointer to a particular task group, such as an Amazon ECS
                 service or a Kubernetes deployment. When you create a virtual node, you must specify the
                 DNS service discovery name for your task group.</p>
                 <p>Any inbound traffic that your virtual node expects should be specified as a
                    <code>listener</code>. Any outbound traffic that your virtual node expects to reach
                 should be specified as a <code>backend</code>.</p>
                 <p>The response metadata for your new virtual node contains the <code>arn</code> that is
                 associated with the virtual node. Set this value (either the full ARN or the truncated
                 resource name, for example, <code>mesh/default/virtualNode/simpleapp</code>, as the
                    <code>APPMESH_VIRTUAL_NODE_NAME</code> environment variable for your task group's Envoy
                 proxy container in your task definition or pod spec. This is then mapped to the
                    <code>node.id</code> and <code>node.cluster</code> Envoy parameters.</p>
                 <note>
                    <p>If you require your Envoy stats or tracing to use a different name, you can override
                    the <code>node.cluster</code> value that is set by
                       <code>APPMESH_VIRTUAL_NODE_NAME</code> with the
                       <code>APPMESH_VIRTUAL_NODE_CLUSTER</code> environment variable.</p>
                 </note>
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.CreateVirtualNodeRequest, base_url, '/meshes/{meshName}/virtualNodes', request)
        
        headers = utils.get_headers(request)
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = self._security_client
        
        http_res = client.request('PUT', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.CreateVirtualNodeResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.CreateVirtualNodeOutput])
                res.create_virtual_node_output = out
        elif http_res.status_code == 480:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.bad_request_exception = out
        elif http_res.status_code == 481:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.conflict_exception = out
        elif http_res.status_code == 482:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.forbidden_exception = out
        elif http_res.status_code == 483:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.internal_server_error_exception = out
        elif http_res.status_code == 484:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.limit_exceeded_exception = out
        elif http_res.status_code == 485:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.not_found_exception = out
        elif http_res.status_code == 486:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.service_unavailable_exception = out
        elif http_res.status_code == 487:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.too_many_requests_exception = out

        return res

    def create_virtual_router(self, request: operations.CreateVirtualRouterRequest) -> operations.CreateVirtualRouterResponse:
        r"""<p>Creates a new virtual router within a service mesh.</p>
                 <p>Virtual routers handle traffic for one or more service names within your mesh. After you
                 create your virtual router, create and associate routes for your virtual router that direct
                 incoming requests to different virtual nodes.</p>
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.CreateVirtualRouterRequest, base_url, '/meshes/{meshName}/virtualRouters', request)
        
        headers = utils.get_headers(request)
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = self._security_client
        
        http_res = client.request('PUT', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.CreateVirtualRouterResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.CreateVirtualRouterOutput])
                res.create_virtual_router_output = out
        elif http_res.status_code == 480:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.bad_request_exception = out
        elif http_res.status_code == 481:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.conflict_exception = out
        elif http_res.status_code == 482:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.forbidden_exception = out
        elif http_res.status_code == 483:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.internal_server_error_exception = out
        elif http_res.status_code == 484:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.limit_exceeded_exception = out
        elif http_res.status_code == 485:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.not_found_exception = out
        elif http_res.status_code == 486:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.service_unavailable_exception = out
        elif http_res.status_code == 487:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.too_many_requests_exception = out

        return res

    def delete_mesh(self, request: operations.DeleteMeshRequest) -> operations.DeleteMeshResponse:
        r"""<p>Deletes an existing service mesh.</p>
                 <p>You must delete all resources (routes, virtual routers, virtual nodes) in the service
                 mesh before you can delete the mesh itself.</p>
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.DeleteMeshRequest, base_url, '/meshes/{meshName}', request)
        
        headers = utils.get_headers(request)
        
        client = self._security_client
        
        http_res = client.request('DELETE', url, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DeleteMeshResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.DeleteMeshOutput])
                res.delete_mesh_output = out
        elif http_res.status_code == 480:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.bad_request_exception = out
        elif http_res.status_code == 481:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.forbidden_exception = out
        elif http_res.status_code == 482:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.internal_server_error_exception = out
        elif http_res.status_code == 483:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.not_found_exception = out
        elif http_res.status_code == 484:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.resource_in_use_exception = out
        elif http_res.status_code == 485:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.service_unavailable_exception = out
        elif http_res.status_code == 486:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.too_many_requests_exception = out

        return res

    def delete_route(self, request: operations.DeleteRouteRequest) -> operations.DeleteRouteResponse:
        r"""Deletes an existing route."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.DeleteRouteRequest, base_url, '/meshes/{meshName}/virtualRouter/{virtualRouterName}/routes/{routeName}', request)
        
        headers = utils.get_headers(request)
        
        client = self._security_client
        
        http_res = client.request('DELETE', url, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DeleteRouteResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.DeleteRouteOutput])
                res.delete_route_output = out
        elif http_res.status_code == 480:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.bad_request_exception = out
        elif http_res.status_code == 481:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.forbidden_exception = out
        elif http_res.status_code == 482:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.internal_server_error_exception = out
        elif http_res.status_code == 483:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.not_found_exception = out
        elif http_res.status_code == 484:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.resource_in_use_exception = out
        elif http_res.status_code == 485:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.service_unavailable_exception = out
        elif http_res.status_code == 486:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.too_many_requests_exception = out

        return res

    def delete_virtual_node(self, request: operations.DeleteVirtualNodeRequest) -> operations.DeleteVirtualNodeResponse:
        r"""Deletes an existing virtual node."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.DeleteVirtualNodeRequest, base_url, '/meshes/{meshName}/virtualNodes/{virtualNodeName}', request)
        
        headers = utils.get_headers(request)
        
        client = self._security_client
        
        http_res = client.request('DELETE', url, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DeleteVirtualNodeResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.DeleteVirtualNodeOutput])
                res.delete_virtual_node_output = out
        elif http_res.status_code == 480:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.bad_request_exception = out
        elif http_res.status_code == 481:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.forbidden_exception = out
        elif http_res.status_code == 482:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.internal_server_error_exception = out
        elif http_res.status_code == 483:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.not_found_exception = out
        elif http_res.status_code == 484:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.resource_in_use_exception = out
        elif http_res.status_code == 485:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.service_unavailable_exception = out
        elif http_res.status_code == 486:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.too_many_requests_exception = out

        return res

    def delete_virtual_router(self, request: operations.DeleteVirtualRouterRequest) -> operations.DeleteVirtualRouterResponse:
        r"""<p>Deletes an existing virtual router.</p>
                 <p>You must delete any routes associated with the virtual router before you can delete the
                 router itself.</p>
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.DeleteVirtualRouterRequest, base_url, '/meshes/{meshName}/virtualRouters/{virtualRouterName}', request)
        
        headers = utils.get_headers(request)
        
        client = self._security_client
        
        http_res = client.request('DELETE', url, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DeleteVirtualRouterResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.DeleteVirtualRouterOutput])
                res.delete_virtual_router_output = out
        elif http_res.status_code == 480:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.bad_request_exception = out
        elif http_res.status_code == 481:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.forbidden_exception = out
        elif http_res.status_code == 482:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.internal_server_error_exception = out
        elif http_res.status_code == 483:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.not_found_exception = out
        elif http_res.status_code == 484:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.resource_in_use_exception = out
        elif http_res.status_code == 485:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.service_unavailable_exception = out
        elif http_res.status_code == 486:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.too_many_requests_exception = out

        return res

    def describe_mesh(self, request: operations.DescribeMeshRequest) -> operations.DescribeMeshResponse:
        r"""Describes an existing service mesh."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.DescribeMeshRequest, base_url, '/meshes/{meshName}', request)
        
        headers = utils.get_headers(request)
        
        client = self._security_client
        
        http_res = client.request('GET', url, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DescribeMeshResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.DescribeMeshOutput])
                res.describe_mesh_output = out
        elif http_res.status_code == 480:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.bad_request_exception = out
        elif http_res.status_code == 481:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.forbidden_exception = out
        elif http_res.status_code == 482:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.internal_server_error_exception = out
        elif http_res.status_code == 483:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.not_found_exception = out
        elif http_res.status_code == 484:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.service_unavailable_exception = out
        elif http_res.status_code == 485:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.too_many_requests_exception = out

        return res

    def describe_route(self, request: operations.DescribeRouteRequest) -> operations.DescribeRouteResponse:
        r"""Describes an existing route."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.DescribeRouteRequest, base_url, '/meshes/{meshName}/virtualRouter/{virtualRouterName}/routes/{routeName}', request)
        
        headers = utils.get_headers(request)
        
        client = self._security_client
        
        http_res = client.request('GET', url, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DescribeRouteResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.DescribeRouteOutput])
                res.describe_route_output = out
        elif http_res.status_code == 480:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.bad_request_exception = out
        elif http_res.status_code == 481:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.forbidden_exception = out
        elif http_res.status_code == 482:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.internal_server_error_exception = out
        elif http_res.status_code == 483:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.not_found_exception = out
        elif http_res.status_code == 484:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.service_unavailable_exception = out
        elif http_res.status_code == 485:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.too_many_requests_exception = out

        return res

    def describe_virtual_node(self, request: operations.DescribeVirtualNodeRequest) -> operations.DescribeVirtualNodeResponse:
        r"""Describes an existing virtual node."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.DescribeVirtualNodeRequest, base_url, '/meshes/{meshName}/virtualNodes/{virtualNodeName}', request)
        
        headers = utils.get_headers(request)
        
        client = self._security_client
        
        http_res = client.request('GET', url, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DescribeVirtualNodeResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.DescribeVirtualNodeOutput])
                res.describe_virtual_node_output = out
        elif http_res.status_code == 480:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.bad_request_exception = out
        elif http_res.status_code == 481:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.forbidden_exception = out
        elif http_res.status_code == 482:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.internal_server_error_exception = out
        elif http_res.status_code == 483:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.not_found_exception = out
        elif http_res.status_code == 484:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.service_unavailable_exception = out
        elif http_res.status_code == 485:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.too_many_requests_exception = out

        return res

    def describe_virtual_router(self, request: operations.DescribeVirtualRouterRequest) -> operations.DescribeVirtualRouterResponse:
        r"""Describes an existing virtual router."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.DescribeVirtualRouterRequest, base_url, '/meshes/{meshName}/virtualRouters/{virtualRouterName}', request)
        
        headers = utils.get_headers(request)
        
        client = self._security_client
        
        http_res = client.request('GET', url, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DescribeVirtualRouterResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.DescribeVirtualRouterOutput])
                res.describe_virtual_router_output = out
        elif http_res.status_code == 480:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.bad_request_exception = out
        elif http_res.status_code == 481:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.forbidden_exception = out
        elif http_res.status_code == 482:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.internal_server_error_exception = out
        elif http_res.status_code == 483:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.not_found_exception = out
        elif http_res.status_code == 484:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.service_unavailable_exception = out
        elif http_res.status_code == 485:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.too_many_requests_exception = out

        return res

    def list_meshes(self, request: operations.ListMeshesRequest) -> operations.ListMeshesResponse:
        r"""Returns a list of existing service meshes."""
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/meshes'
        
        headers = utils.get_headers(request)
        query_params = utils.get_query_params(operations.ListMeshesRequest, request)
        
        client = self._security_client
        
        http_res = client.request('GET', url, params=query_params, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ListMeshesResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ListMeshesOutput])
                res.list_meshes_output = out
        elif http_res.status_code == 480:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.bad_request_exception = out
        elif http_res.status_code == 481:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.forbidden_exception = out
        elif http_res.status_code == 482:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.internal_server_error_exception = out
        elif http_res.status_code == 483:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.not_found_exception = out
        elif http_res.status_code == 484:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.service_unavailable_exception = out
        elif http_res.status_code == 485:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.too_many_requests_exception = out

        return res

    def list_routes(self, request: operations.ListRoutesRequest) -> operations.ListRoutesResponse:
        r"""Returns a list of existing routes in a service mesh."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.ListRoutesRequest, base_url, '/meshes/{meshName}/virtualRouter/{virtualRouterName}/routes', request)
        
        headers = utils.get_headers(request)
        query_params = utils.get_query_params(operations.ListRoutesRequest, request)
        
        client = self._security_client
        
        http_res = client.request('GET', url, params=query_params, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ListRoutesResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ListRoutesOutput])
                res.list_routes_output = out
        elif http_res.status_code == 480:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.bad_request_exception = out
        elif http_res.status_code == 481:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.forbidden_exception = out
        elif http_res.status_code == 482:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.internal_server_error_exception = out
        elif http_res.status_code == 483:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.not_found_exception = out
        elif http_res.status_code == 484:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.service_unavailable_exception = out
        elif http_res.status_code == 485:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.too_many_requests_exception = out

        return res

    def list_virtual_nodes(self, request: operations.ListVirtualNodesRequest) -> operations.ListVirtualNodesResponse:
        r"""Returns a list of existing virtual nodes."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.ListVirtualNodesRequest, base_url, '/meshes/{meshName}/virtualNodes', request)
        
        headers = utils.get_headers(request)
        query_params = utils.get_query_params(operations.ListVirtualNodesRequest, request)
        
        client = self._security_client
        
        http_res = client.request('GET', url, params=query_params, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ListVirtualNodesResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ListVirtualNodesOutput])
                res.list_virtual_nodes_output = out
        elif http_res.status_code == 480:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.bad_request_exception = out
        elif http_res.status_code == 481:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.forbidden_exception = out
        elif http_res.status_code == 482:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.internal_server_error_exception = out
        elif http_res.status_code == 483:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.not_found_exception = out
        elif http_res.status_code == 484:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.service_unavailable_exception = out
        elif http_res.status_code == 485:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.too_many_requests_exception = out

        return res

    def list_virtual_routers(self, request: operations.ListVirtualRoutersRequest) -> operations.ListVirtualRoutersResponse:
        r"""Returns a list of existing virtual routers in a service mesh."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.ListVirtualRoutersRequest, base_url, '/meshes/{meshName}/virtualRouters', request)
        
        headers = utils.get_headers(request)
        query_params = utils.get_query_params(operations.ListVirtualRoutersRequest, request)
        
        client = self._security_client
        
        http_res = client.request('GET', url, params=query_params, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ListVirtualRoutersResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ListVirtualRoutersOutput])
                res.list_virtual_routers_output = out
        elif http_res.status_code == 480:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.bad_request_exception = out
        elif http_res.status_code == 481:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.forbidden_exception = out
        elif http_res.status_code == 482:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.internal_server_error_exception = out
        elif http_res.status_code == 483:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.not_found_exception = out
        elif http_res.status_code == 484:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.service_unavailable_exception = out
        elif http_res.status_code == 485:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.too_many_requests_exception = out

        return res

    def update_route(self, request: operations.UpdateRouteRequest) -> operations.UpdateRouteResponse:
        r"""Updates an existing route for a specified service mesh and virtual router."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.UpdateRouteRequest, base_url, '/meshes/{meshName}/virtualRouter/{virtualRouterName}/routes/{routeName}', request)
        
        headers = utils.get_headers(request)
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = self._security_client
        
        http_res = client.request('PUT', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.UpdateRouteResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.UpdateRouteOutput])
                res.update_route_output = out
        elif http_res.status_code == 480:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.bad_request_exception = out
        elif http_res.status_code == 481:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.conflict_exception = out
        elif http_res.status_code == 482:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.forbidden_exception = out
        elif http_res.status_code == 483:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.internal_server_error_exception = out
        elif http_res.status_code == 484:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.limit_exceeded_exception = out
        elif http_res.status_code == 485:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.not_found_exception = out
        elif http_res.status_code == 486:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.service_unavailable_exception = out
        elif http_res.status_code == 487:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.too_many_requests_exception = out

        return res

    def update_virtual_node(self, request: operations.UpdateVirtualNodeRequest) -> operations.UpdateVirtualNodeResponse:
        r"""Updates an existing virtual node in a specified service mesh."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.UpdateVirtualNodeRequest, base_url, '/meshes/{meshName}/virtualNodes/{virtualNodeName}', request)
        
        headers = utils.get_headers(request)
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = self._security_client
        
        http_res = client.request('PUT', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.UpdateVirtualNodeResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.UpdateVirtualNodeOutput])
                res.update_virtual_node_output = out
        elif http_res.status_code == 480:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.bad_request_exception = out
        elif http_res.status_code == 481:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.conflict_exception = out
        elif http_res.status_code == 482:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.forbidden_exception = out
        elif http_res.status_code == 483:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.internal_server_error_exception = out
        elif http_res.status_code == 484:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.limit_exceeded_exception = out
        elif http_res.status_code == 485:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.not_found_exception = out
        elif http_res.status_code == 486:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.service_unavailable_exception = out
        elif http_res.status_code == 487:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.too_many_requests_exception = out

        return res

    def update_virtual_router(self, request: operations.UpdateVirtualRouterRequest) -> operations.UpdateVirtualRouterResponse:
        r"""Updates an existing virtual router in a specified service mesh."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.UpdateVirtualRouterRequest, base_url, '/meshes/{meshName}/virtualRouters/{virtualRouterName}', request)
        
        headers = utils.get_headers(request)
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = self._security_client
        
        http_res = client.request('PUT', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.UpdateVirtualRouterResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.UpdateVirtualRouterOutput])
                res.update_virtual_router_output = out
        elif http_res.status_code == 480:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.bad_request_exception = out
        elif http_res.status_code == 481:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.conflict_exception = out
        elif http_res.status_code == 482:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.forbidden_exception = out
        elif http_res.status_code == 483:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.internal_server_error_exception = out
        elif http_res.status_code == 484:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.limit_exceeded_exception = out
        elif http_res.status_code == 485:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.not_found_exception = out
        elif http_res.status_code == 486:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.service_unavailable_exception = out
        elif http_res.status_code == 487:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.too_many_requests_exception = out

        return res

    