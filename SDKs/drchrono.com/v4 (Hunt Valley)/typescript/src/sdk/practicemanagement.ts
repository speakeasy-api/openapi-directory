/*
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

import * as utils from "../internal/utils";
import * as operations from "./models/operations";
import * as shared from "./models/shared";
import { AxiosInstance, AxiosRequestConfig, AxiosResponse } from "axios";

/**
 * Create and manage practice management resources
 */
export class PracticeManagement {
  _defaultClient: AxiosInstance;
  _securityClient: AxiosInstance;
  _serverURL: string;
  _language: string;
  _sdkVersion: string;
  _genVersion: string;

  constructor(
    defaultClient: AxiosInstance,
    securityClient: AxiosInstance,
    serverURL: string,
    language: string,
    sdkVersion: string,
    genVersion: string
  ) {
    this._defaultClient = defaultClient;
    this._securityClient = securityClient;
    this._serverURL = serverURL;
    this._language = language;
    this._sdkVersion = sdkVersion;
    this._genVersion = genVersion;
  }

  /**
   * Retrieve or search inventory categories
   */
  inventoryCategoriesList(
    req: operations.InventoryCategoriesListRequest,
    security: operations.InventoryCategoriesListSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.InventoryCategoriesListResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.InventoryCategoriesListRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/api/inventory_categories";
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.InventoryCategoriesListSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.InventoryCategoriesListResponse =
        new operations.InventoryCategoriesListResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.inventoryCategoriesList200ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.InventoryCategoriesList200ApplicationJSON
              );
          }
          break;
        case [400, 401, 403, 404, 405, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Retrieve an existing inventory category
   */
  inventoryCategoriesRead(
    req: operations.InventoryCategoriesReadRequest,
    security: operations.InventoryCategoriesReadSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.InventoryCategoriesReadResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.InventoryCategoriesReadRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/api/inventory_categories/{id}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.InventoryCategoriesReadSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.InventoryCategoriesReadResponse =
        new operations.InventoryCategoriesReadResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.inventoryCategory = utils.objectToClass(
              httpRes?.data,
              shared.InventoryCategory
            );
          }
          break;
        case [400, 401, 403, 404, 405, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Create vaccine inventory
   */
  inventoryVaccinesCreate(
    req: operations.InventoryVaccinesCreateRequest,
    security: operations.InventoryVaccinesCreateSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.InventoryVaccinesCreateResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.InventoryVaccinesCreateRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/api/inventory_vaccines";
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.InventoryVaccinesCreateSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "post",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.InventoryVaccinesCreateResponse =
        new operations.InventoryVaccinesCreateResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.inventoryVaccine = utils.objectToClass(
              httpRes?.data,
              shared.InventoryVaccine
            );
          }
          break;
        case [400, 401, 403, 404, 405, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Retrieve or search vaccine inventories
   */
  inventoryVaccinesList(
    req: operations.InventoryVaccinesListRequest,
    security: operations.InventoryVaccinesListSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.InventoryVaccinesListResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.InventoryVaccinesListRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/api/inventory_vaccines";
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.InventoryVaccinesListSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.InventoryVaccinesListResponse =
        new operations.InventoryVaccinesListResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.inventoryVaccinesList200ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.InventoryVaccinesList200ApplicationJSON
              );
          }
          break;
        case [400, 401, 403, 404, 405, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Retrieve an existing vaccine inventory
   */
  inventoryVaccinesRead(
    req: operations.InventoryVaccinesReadRequest,
    security: operations.InventoryVaccinesReadSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.InventoryVaccinesReadResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.InventoryVaccinesReadRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/api/inventory_vaccines/{id}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.InventoryVaccinesReadSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.InventoryVaccinesReadResponse =
        new operations.InventoryVaccinesReadResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.inventoryVaccine = utils.objectToClass(
              httpRes?.data,
              shared.InventoryVaccine
            );
          }
          break;
        case [400, 401, 403, 404, 405, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Create messages in doctor's message center
   */
  messagesCreate(
    req: operations.MessagesCreateRequest,
    security: operations.MessagesCreateSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.MessagesCreateResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.MessagesCreateRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/api/messages";
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.MessagesCreateSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "post",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.MessagesCreateResponse =
        new operations.MessagesCreateResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.doctorMessage = utils.objectToClass(
              httpRes?.data,
              shared.DoctorMessage
            );
          }
          break;
        case [400, 401, 403, 404, 405, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Delete an existing message in doctor's message center
   */
  messagesDelete(
    req: operations.MessagesDeleteRequest,
    security: operations.MessagesDeleteSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.MessagesDeleteResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.MessagesDeleteRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(baseURL, "/api/messages/{id}", req);
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.MessagesDeleteSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.MessagesDeleteResponse =
        new operations.MessagesDeleteResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case [204, 400, 401, 403, 404, 405, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Retrieve or search messages in doctor's message center
   */
  messagesList(
    req: operations.MessagesListRequest,
    security: operations.MessagesListSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.MessagesListResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.MessagesListRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/api/messages";
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.MessagesListSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.MessagesListResponse =
        new operations.MessagesListResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.messagesList200ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.MessagesList200ApplicationJSON
            );
          }
          break;
        case [400, 401, 403, 404, 405, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Update an existing message in doctor's message center
   */
  messagesPartialUpdate(
    req: operations.MessagesPartialUpdateRequest,
    security: operations.MessagesPartialUpdateSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.MessagesPartialUpdateResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.MessagesPartialUpdateRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(baseURL, "/api/messages/{id}", req);
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.MessagesPartialUpdateSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "patch",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.MessagesPartialUpdateResponse =
        new operations.MessagesPartialUpdateResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case [204, 400, 401, 403, 404, 405, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Retrieve an existing message in doctor's message center
   */
  messagesRead(
    req: operations.MessagesReadRequest,
    security: operations.MessagesReadSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.MessagesReadResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.MessagesReadRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(baseURL, "/api/messages/{id}", req);
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.MessagesReadSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.MessagesReadResponse =
        new operations.MessagesReadResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.doctorMessage = utils.objectToClass(
              httpRes?.data,
              shared.DoctorMessage
            );
          }
          break;
        case [400, 401, 403, 404, 405, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Update an existing message in doctor's message center
   */
  messagesUpdate(
    req: operations.MessagesUpdateRequest,
    security: operations.MessagesUpdateSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.MessagesUpdateResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.MessagesUpdateRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(baseURL, "/api/messages/{id}", req);
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.MessagesUpdateSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "put",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.MessagesUpdateResponse =
        new operations.MessagesUpdateResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case [204, 400, 401, 403, 404, 405, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Add an exam room to the office
   */
  officesAddExamRoom(
    req: operations.OfficesAddExamRoomRequest,
    security: operations.OfficesAddExamRoomSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.OfficesAddExamRoomResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.OfficesAddExamRoomRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/api/offices/{id}/add_exam_room",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.OfficesAddExamRoomSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "post",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.OfficesAddExamRoomResponse =
        new operations.OfficesAddExamRoomResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.office = utils.objectToClass(httpRes?.data, shared.Office);
          }
          break;
        case [400, 401, 403, 404, 405, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Retrieve or search offices
   */
  officesList(
    req: operations.OfficesListRequest,
    security: operations.OfficesListSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.OfficesListResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.OfficesListRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/api/offices";
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.OfficesListSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.OfficesListResponse =
        new operations.OfficesListResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.officesList200ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.OfficesList200ApplicationJSON
            );
          }
          break;
        case [400, 401, 403, 404, 405, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Update an existing office
   */
  officesPartialUpdate(
    req: operations.OfficesPartialUpdateRequest,
    security: operations.OfficesPartialUpdateSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.OfficesPartialUpdateResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.OfficesPartialUpdateRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(baseURL, "/api/offices/{id}", req);
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.OfficesPartialUpdateSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "patch",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.OfficesPartialUpdateResponse =
        new operations.OfficesPartialUpdateResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case [204, 400, 401, 403, 404, 405, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Retrieve an existing office
   */
  officesRead(
    req: operations.OfficesReadRequest,
    security: operations.OfficesReadSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.OfficesReadResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.OfficesReadRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(baseURL, "/api/offices/{id}", req);
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.OfficesReadSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.OfficesReadResponse =
        new operations.OfficesReadResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.office = utils.objectToClass(httpRes?.data, shared.Office);
          }
          break;
        case [400, 401, 403, 404, 405, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Update an existing office
   */
  officesUpdate(
    req: operations.OfficesUpdateRequest,
    security: operations.OfficesUpdateSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.OfficesUpdateResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.OfficesUpdateRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(baseURL, "/api/offices/{id}", req);
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.OfficesUpdateSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "put",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.OfficesUpdateResponse =
        new operations.OfficesUpdateResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case [204, 400, 401, 403, 404, 405, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Create a task category
   */
  taskCategoriesCreate(
    req: operations.TaskCategoriesCreateRequest,
    security: operations.TaskCategoriesCreateSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.TaskCategoriesCreateResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.TaskCategoriesCreateRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/api/task_categories";
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.TaskCategoriesCreateSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "post",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.TaskCategoriesCreateResponse =
        new operations.TaskCategoriesCreateResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.taskCategory = utils.objectToClass(
              httpRes?.data,
              shared.TaskCategory
            );
          }
          break;
        case [400, 401, 403, 404, 405, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Retrieve or search task categories
   */
  taskCategoriesList(
    req: operations.TaskCategoriesListRequest,
    security: operations.TaskCategoriesListSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.TaskCategoriesListResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.TaskCategoriesListRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/api/task_categories";
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.TaskCategoriesListSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.TaskCategoriesListResponse =
        new operations.TaskCategoriesListResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.taskCategoriesList200ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.TaskCategoriesList200ApplicationJSON
              );
          }
          break;
        case [400, 401, 403, 404, 405, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Update an existing task category
   */
  taskCategoriesPartialUpdate(
    req: operations.TaskCategoriesPartialUpdateRequest,
    security: operations.TaskCategoriesPartialUpdateSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.TaskCategoriesPartialUpdateResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.TaskCategoriesPartialUpdateRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/api/task_categories/{id}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.TaskCategoriesPartialUpdateSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "patch",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.TaskCategoriesPartialUpdateResponse =
        new operations.TaskCategoriesPartialUpdateResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case [204, 400, 401, 403, 404, 405, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Retrieve an existing task category
   */
  taskCategoriesRead(
    req: operations.TaskCategoriesReadRequest,
    security: operations.TaskCategoriesReadSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.TaskCategoriesReadResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.TaskCategoriesReadRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/api/task_categories/{id}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.TaskCategoriesReadSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.TaskCategoriesReadResponse =
        new operations.TaskCategoriesReadResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.taskCategory = utils.objectToClass(
              httpRes?.data,
              shared.TaskCategory
            );
          }
          break;
        case [400, 401, 403, 404, 405, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Update an existing task category
   */
  taskCategoriesUpdate(
    req: operations.TaskCategoriesUpdateRequest,
    security: operations.TaskCategoriesUpdateSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.TaskCategoriesUpdateResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.TaskCategoriesUpdateRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/api/task_categories/{id}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.TaskCategoriesUpdateSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "put",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.TaskCategoriesUpdateResponse =
        new operations.TaskCategoriesUpdateResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case [204, 400, 401, 403, 404, 405, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Create a task note
   */
  taskNotesCreate(
    req: operations.TaskNotesCreateRequest,
    security: operations.TaskNotesCreateSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.TaskNotesCreateResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.TaskNotesCreateRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/api/task_notes";
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.TaskNotesCreateSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "post",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.TaskNotesCreateResponse =
        new operations.TaskNotesCreateResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.taskNote = utils.objectToClass(httpRes?.data, shared.TaskNote);
          }
          break;
        case [400, 401, 403, 404, 405, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Retrieve or search task notes
   */
  taskNotesList(
    req: operations.TaskNotesListRequest,
    security: operations.TaskNotesListSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.TaskNotesListResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.TaskNotesListRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/api/task_notes";
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.TaskNotesListSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.TaskNotesListResponse =
        new operations.TaskNotesListResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.taskNotesList200ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.TaskNotesList200ApplicationJSON
            );
          }
          break;
        case [400, 401, 403, 404, 405, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Update an existing task note
   */
  taskNotesPartialUpdate(
    req: operations.TaskNotesPartialUpdateRequest,
    security: operations.TaskNotesPartialUpdateSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.TaskNotesPartialUpdateResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.TaskNotesPartialUpdateRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(baseURL, "/api/task_notes/{id}", req);
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.TaskNotesPartialUpdateSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "patch",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.TaskNotesPartialUpdateResponse =
        new operations.TaskNotesPartialUpdateResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case [204, 400, 401, 403, 404, 405, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Retrieve an existing task note
   */
  taskNotesRead(
    req: operations.TaskNotesReadRequest,
    security: operations.TaskNotesReadSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.TaskNotesReadResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.TaskNotesReadRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(baseURL, "/api/task_notes/{id}", req);
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.TaskNotesReadSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.TaskNotesReadResponse =
        new operations.TaskNotesReadResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.taskNote = utils.objectToClass(httpRes?.data, shared.TaskNote);
          }
          break;
        case [400, 401, 403, 404, 405, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Update an existing task note
   */
  taskNotesUpdate(
    req: operations.TaskNotesUpdateRequest,
    security: operations.TaskNotesUpdateSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.TaskNotesUpdateResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.TaskNotesUpdateRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(baseURL, "/api/task_notes/{id}", req);
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.TaskNotesUpdateSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "put",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.TaskNotesUpdateResponse =
        new operations.TaskNotesUpdateResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case [204, 400, 401, 403, 404, 405, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Create a task status
   */
  taskStatusesCreate(
    req: operations.TaskStatusesCreateRequest,
    security: operations.TaskStatusesCreateSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.TaskStatusesCreateResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.TaskStatusesCreateRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/api/task_statuses";
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.TaskStatusesCreateSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "post",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.TaskStatusesCreateResponse =
        new operations.TaskStatusesCreateResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.taskStatus = utils.objectToClass(
              httpRes?.data,
              shared.TaskStatus
            );
          }
          break;
        case [400, 401, 403, 404, 405, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Retrieve or search task statuses
   */
  taskStatusesList(
    req: operations.TaskStatusesListRequest,
    security: operations.TaskStatusesListSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.TaskStatusesListResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.TaskStatusesListRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/api/task_statuses";
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.TaskStatusesListSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.TaskStatusesListResponse =
        new operations.TaskStatusesListResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.taskStatusesList200ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.TaskStatusesList200ApplicationJSON
            );
          }
          break;
        case [400, 401, 403, 404, 405, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Update an existing task status
   */
  taskStatusesPartialUpdate(
    req: operations.TaskStatusesPartialUpdateRequest,
    security: operations.TaskStatusesPartialUpdateSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.TaskStatusesPartialUpdateResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.TaskStatusesPartialUpdateRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/api/task_statuses/{id}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.TaskStatusesPartialUpdateSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "patch",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.TaskStatusesPartialUpdateResponse =
        new operations.TaskStatusesPartialUpdateResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case [204, 400, 401, 403, 404, 405, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Retrieve an existing task status
   */
  taskStatusesRead(
    req: operations.TaskStatusesReadRequest,
    security: operations.TaskStatusesReadSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.TaskStatusesReadResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.TaskStatusesReadRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/api/task_statuses/{id}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.TaskStatusesReadSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.TaskStatusesReadResponse =
        new operations.TaskStatusesReadResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.taskStatus = utils.objectToClass(
              httpRes?.data,
              shared.TaskStatus
            );
          }
          break;
        case [400, 401, 403, 404, 405, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Update an existing task status
   */
  taskStatusesUpdate(
    req: operations.TaskStatusesUpdateRequest,
    security: operations.TaskStatusesUpdateSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.TaskStatusesUpdateResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.TaskStatusesUpdateRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/api/task_statuses/{id}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.TaskStatusesUpdateSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "put",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.TaskStatusesUpdateResponse =
        new operations.TaskStatusesUpdateResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case [204, 400, 401, 403, 404, 405, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Create a task template
   */
  taskTemplatesCreate(
    req: operations.TaskTemplatesCreateRequest,
    security: operations.TaskTemplatesCreateSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.TaskTemplatesCreateResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.TaskTemplatesCreateRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/api/task_templates";
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.TaskTemplatesCreateSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "post",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.TaskTemplatesCreateResponse =
        new operations.TaskTemplatesCreateResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.taskTemplate = utils.objectToClass(
              httpRes?.data,
              shared.TaskTemplate
            );
          }
          break;
        case [400, 401, 403, 404, 405, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Retrieve or search task templates
   */
  taskTemplatesList(
    req: operations.TaskTemplatesListRequest,
    security: operations.TaskTemplatesListSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.TaskTemplatesListResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.TaskTemplatesListRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/api/task_templates";
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.TaskTemplatesListSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.TaskTemplatesListResponse =
        new operations.TaskTemplatesListResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.taskTemplatesList200ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.TaskTemplatesList200ApplicationJSON
            );
          }
          break;
        case [400, 401, 403, 404, 405, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Update an existing task template
   */
  taskTemplatesPartialUpdate(
    req: operations.TaskTemplatesPartialUpdateRequest,
    security: operations.TaskTemplatesPartialUpdateSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.TaskTemplatesPartialUpdateResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.TaskTemplatesPartialUpdateRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/api/task_templates/{id}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.TaskTemplatesPartialUpdateSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "patch",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.TaskTemplatesPartialUpdateResponse =
        new operations.TaskTemplatesPartialUpdateResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case [204, 400, 401, 403, 404, 405, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Retrieve an existing task template
   */
  taskTemplatesRead(
    req: operations.TaskTemplatesReadRequest,
    security: operations.TaskTemplatesReadSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.TaskTemplatesReadResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.TaskTemplatesReadRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/api/task_templates/{id}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.TaskTemplatesReadSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.TaskTemplatesReadResponse =
        new operations.TaskTemplatesReadResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.taskTemplate = utils.objectToClass(
              httpRes?.data,
              shared.TaskTemplate
            );
          }
          break;
        case [400, 401, 403, 404, 405, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Update an existing task template
   */
  taskTemplatesUpdate(
    req: operations.TaskTemplatesUpdateRequest,
    security: operations.TaskTemplatesUpdateSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.TaskTemplatesUpdateResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.TaskTemplatesUpdateRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/api/task_templates/{id}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.TaskTemplatesUpdateSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "put",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.TaskTemplatesUpdateResponse =
        new operations.TaskTemplatesUpdateResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case [204, 400, 401, 403, 404, 405, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Create a task
   */
  tasksCreate(
    req: operations.TasksCreateRequest,
    security: operations.TasksCreateSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.TasksCreateResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.TasksCreateRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/api/tasks";
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.TasksCreateSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "post",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.TasksCreateResponse =
        new operations.TasksCreateResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.task = utils.objectToClass(httpRes?.data, shared.Task);
          }
          break;
        case [400, 401, 403, 404, 405, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Retrieve or search tasks
   */
  tasksList(
    req: operations.TasksListRequest,
    security: operations.TasksListSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.TasksListResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.TasksListRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/api/tasks";
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.TasksListSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.TasksListResponse =
        new operations.TasksListResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.tasksList200ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.TasksList200ApplicationJSON
            );
          }
          break;
        case [400, 401, 403, 404, 405, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Update an existing task
   */
  tasksPartialUpdate(
    req: operations.TasksPartialUpdateRequest,
    security: operations.TasksPartialUpdateSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.TasksPartialUpdateResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.TasksPartialUpdateRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(baseURL, "/api/tasks/{id}", req);
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.TasksPartialUpdateSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "patch",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.TasksPartialUpdateResponse =
        new operations.TasksPartialUpdateResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case [204, 400, 401, 403, 404, 405, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Retrieve an existing task
   */
  tasksRead(
    req: operations.TasksReadRequest,
    security: operations.TasksReadSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.TasksReadResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.TasksReadRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(baseURL, "/api/tasks/{id}", req);
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.TasksReadSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.TasksReadResponse =
        new operations.TasksReadResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.task = utils.objectToClass(httpRes?.data, shared.Task);
          }
          break;
        case [400, 401, 403, 404, 405, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Update an existing task
   */
  tasksUpdate(
    req: operations.TasksUpdateRequest,
    security: operations.TasksUpdateSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.TasksUpdateResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.TasksUpdateRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(baseURL, "/api/tasks/{id}", req);
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.TasksUpdateSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "put",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.TasksUpdateResponse =
        new operations.TasksUpdateResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case [204, 400, 401, 403, 404, 405, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }
}
