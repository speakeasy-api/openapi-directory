/*
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

import * as utils from "../internal/utils";
import * as operations from "./models/operations";
import { AxiosInstance, AxiosRequestConfig, AxiosResponse } from "axios";

export class AssetsPrices {
  _defaultClient: AxiosInstance;
  _securityClient: AxiosInstance;
  _serverURL: string;
  _language: string;
  _sdkVersion: string;
  _genVersion: string;

  constructor(
    defaultClient: AxiosInstance,
    securityClient: AxiosInstance,
    serverURL: string,
    language: string,
    sdkVersion: string,
    genVersion: string
  ) {
    this._defaultClient = defaultClient;
    this._securityClient = securityClient;
    this._serverURL = serverURL;
    this._language = language;
    this._sdkVersion = sdkVersion;
    this._genVersion = genVersion;
  }

  /**
   * Adjusted Prices
   *
   * @remarks
   * Compute the backward-adjusted prices of one or several asset(s) for one or several date(s) from:
   * * Unadjusted prices
   * * Capital distributions, like stock dividends
   * * Splits, like stock splits
   *
   * The adjustment base date is chosen to be the last date for which unadjusted prices are available, which implies that:
   * * The price on the last date for which unadjusted prices are available is left unadjusted
   * * The price on any other date is adjusted based on the capital distributions and the splits which occurred between this date and the last date for which unadjusted prices are available
   *
   * References
   * * [Center for Research in Security Prices](https://www.crsp.org/products/documentation/crsp-calculations)
   *
   */
  postAssetsPricesAdjusted(
    req: operations.PostAssetsPricesAdjustedRequestBody,
    config?: AxiosRequestConfig
  ): Promise<operations.PostAssetsPricesAdjustedResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PostAssetsPricesAdjustedRequestBody(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/assets/prices/adjusted";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "request",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PostAssetsPricesAdjustedResponse =
        new operations.PostAssetsPricesAdjustedResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.postAssetsPricesAdjusted200ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.PostAssetsPricesAdjusted200ApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Forward-Adjusted Prices
   *
   * @remarks
   * Compute the forward-adjusted prices of one or several asset(s) for one or several date(s) from:
   * * Unadjusted prices
   * * Capital distributions, like stock dividends
   * * Splits, like stock splits
   *
   * The adjustment base date is chosen to be the first date for which unadjusted prices are available, which implies that:
   * * The price on the first date for which unadjusted prices are available is left unadjusted
   * * The price on any other date is adjusted based on the capital distributions and the splits which occurred between this date and the first date for which unadjusted prices are available
   *
   * References
   * * [Center for Research in Security Prices](https://www.crsp.org/products/documentation/crsp-calculations)
   *
   */
  postAssetsPricesAdjustedForward(
    req: operations.PostAssetsPricesAdjustedForwardRequestBody,
    config?: AxiosRequestConfig
  ): Promise<operations.PostAssetsPricesAdjustedForwardResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PostAssetsPricesAdjustedForwardRequestBody(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/assets/prices/adjusted/forward";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "request",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PostAssetsPricesAdjustedForwardResponse =
        new operations.PostAssetsPricesAdjustedForwardResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.postAssetsPricesAdjustedForward200ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.PostAssetsPricesAdjustedForward200ApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }
}
