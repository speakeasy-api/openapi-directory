// Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.

package sdk

import (
	"context"
	"fmt"
	"net/http"
	"openapi/pkg/models/operations"
	"openapi/pkg/models/shared"
	"openapi/pkg/utils"
)

// pullrequests - Pull requests are a feature that makes it easier for developers
// to collaborate using Bitbucket. They provide a user-friendly web
// interface for discussing proposed changes before integrating them
// into the official project.
type pullrequests struct {
	defaultClient  HTTPClient
	securityClient HTTPClient
	serverURL      string
	language       string
	sdkVersion     string
	genVersion     string
}

func newPullrequests(defaultClient, securityClient HTTPClient, serverURL, language, sdkVersion, genVersion string) *pullrequests {
	return &pullrequests{
		defaultClient:  defaultClient,
		securityClient: securityClient,
		serverURL:      serverURL,
		language:       language,
		sdkVersion:     sdkVersion,
		genVersion:     genVersion,
	}
}

// DeleteRepositoriesWorkspaceRepoSlugDefaultReviewersTargetUsername - Remove a user from the default reviewers
// Removes a default reviewer from the repository.
func (s *pullrequests) DeleteRepositoriesWorkspaceRepoSlugDefaultReviewersTargetUsername(ctx context.Context, request operations.DeleteRepositoriesWorkspaceRepoSlugDefaultReviewersTargetUsernameRequest, security operations.DeleteRepositoriesWorkspaceRepoSlugDefaultReviewersTargetUsernameSecurity) (*operations.DeleteRepositoriesWorkspaceRepoSlugDefaultReviewersTargetUsernameResponse, error) {
	baseURL := s.serverURL
	url, err := utils.GenerateURL(ctx, baseURL, "/repositories/{workspace}/{repo_slug}/default-reviewers/{target_username}", request, nil)
	if err != nil {
		return nil, fmt.Errorf("error generating URL: %w", err)
	}

	req, err := http.NewRequestWithContext(ctx, "DELETE", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	client := utils.ConfigureSecurityClient(s.defaultClient, security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.DeleteRepositoriesWorkspaceRepoSlugDefaultReviewersTargetUsernameResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 204:
	case httpRes.StatusCode == 403:
		fallthrough
	case httpRes.StatusCode == 404:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out map[string]interface{}
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.Error = out
		}
	}

	return res, nil
}

// DeleteRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIDApprove - Unapprove a pull request
// Redact the authenticated user's approval of the specified pull
// request.
func (s *pullrequests) DeleteRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIDApprove(ctx context.Context, request operations.DeleteRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIDApproveRequest, security operations.DeleteRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIDApproveSecurity) (*operations.DeleteRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIDApproveResponse, error) {
	baseURL := s.serverURL
	url, err := utils.GenerateURL(ctx, baseURL, "/repositories/{workspace}/{repo_slug}/pullrequests/{pull_request_id}/approve", request, nil)
	if err != nil {
		return nil, fmt.Errorf("error generating URL: %w", err)
	}

	req, err := http.NewRequestWithContext(ctx, "DELETE", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	client := utils.ConfigureSecurityClient(s.defaultClient, security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.DeleteRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIDApproveResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 204:
	case httpRes.StatusCode == 400:
		fallthrough
	case httpRes.StatusCode == 401:
		fallthrough
	case httpRes.StatusCode == 404:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out map[string]interface{}
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.Error = out
		}
	}

	return res, nil
}

// DeleteRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIDCommentsCommentID - Delete a comment on a pull request
// Deletes a specific pull request comment.
func (s *pullrequests) DeleteRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIDCommentsCommentID(ctx context.Context, request operations.DeleteRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIDCommentsCommentIDRequest, security operations.DeleteRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIDCommentsCommentIDSecurity) (*operations.DeleteRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIDCommentsCommentIDResponse, error) {
	baseURL := s.serverURL
	url, err := utils.GenerateURL(ctx, baseURL, "/repositories/{workspace}/{repo_slug}/pullrequests/{pull_request_id}/comments/{comment_id}", request, nil)
	if err != nil {
		return nil, fmt.Errorf("error generating URL: %w", err)
	}

	req, err := http.NewRequestWithContext(ctx, "DELETE", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	client := utils.ConfigureSecurityClient(s.defaultClient, security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.DeleteRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIDCommentsCommentIDResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 204:
	case httpRes.StatusCode == 403:
		fallthrough
	case httpRes.StatusCode == 404:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out map[string]interface{}
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.Error = out
		}
	}

	return res, nil
}

// DeleteRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIDCommentsCommentIDResolve - Reopen a comment thread
func (s *pullrequests) DeleteRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIDCommentsCommentIDResolve(ctx context.Context, request operations.DeleteRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIDCommentsCommentIDResolveRequest, security operations.DeleteRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIDCommentsCommentIDResolveSecurity) (*operations.DeleteRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIDCommentsCommentIDResolveResponse, error) {
	baseURL := s.serverURL
	url, err := utils.GenerateURL(ctx, baseURL, "/repositories/{workspace}/{repo_slug}/pullrequests/{pull_request_id}/comments/{comment_id}/resolve", request, nil)
	if err != nil {
		return nil, fmt.Errorf("error generating URL: %w", err)
	}

	req, err := http.NewRequestWithContext(ctx, "DELETE", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	client := utils.ConfigureSecurityClient(s.defaultClient, security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.DeleteRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIDCommentsCommentIDResolveResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 204:
	case httpRes.StatusCode == 403:
		fallthrough
	case httpRes.StatusCode == 404:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out map[string]interface{}
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.Error = out
		}
	}

	return res, nil
}

// DeleteRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIDRequestChanges - Remove change request for a pull request
func (s *pullrequests) DeleteRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIDRequestChanges(ctx context.Context, request operations.DeleteRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIDRequestChangesRequest, security operations.DeleteRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIDRequestChangesSecurity) (*operations.DeleteRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIDRequestChangesResponse, error) {
	baseURL := s.serverURL
	url, err := utils.GenerateURL(ctx, baseURL, "/repositories/{workspace}/{repo_slug}/pullrequests/{pull_request_id}/request-changes", request, nil)
	if err != nil {
		return nil, fmt.Errorf("error generating URL: %w", err)
	}

	req, err := http.NewRequestWithContext(ctx, "DELETE", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	client := utils.ConfigureSecurityClient(s.defaultClient, security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.DeleteRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIDRequestChangesResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 204:
	case httpRes.StatusCode == 400:
		fallthrough
	case httpRes.StatusCode == 401:
		fallthrough
	case httpRes.StatusCode == 404:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out map[string]interface{}
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.Error = out
		}
	}

	return res, nil
}

// GetPullrequestsForCommit - List pull requests that contain a commit
// Returns a paginated list of all pull requests as part of which this commit was reviewed. Pull Request Commit Links app must be installed first before using this API; installation automatically occurs when 'Go to pull request' is clicked from the web interface for a commit's details.
func (s *pullrequests) GetPullrequestsForCommit(ctx context.Context, request operations.GetPullrequestsForCommitRequest) (*operations.GetPullrequestsForCommitResponse, error) {
	baseURL := s.serverURL
	url, err := utils.GenerateURL(ctx, baseURL, "/repositories/{workspace}/{repo_slug}/commit/{commit}/pullrequests", request, nil)
	if err != nil {
		return nil, fmt.Errorf("error generating URL: %w", err)
	}

	req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	if err := utils.PopulateQueryParams(ctx, req, request, nil); err != nil {
		return nil, fmt.Errorf("error populating query params: %w", err)
	}

	client := s.defaultClient

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.GetPullrequestsForCommitResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		fallthrough
	case httpRes.StatusCode == 202:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *shared.PaginatedPullrequests
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.PaginatedPullrequests = out
		}
	case httpRes.StatusCode == 404:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out map[string]interface{}
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.Error = out
		}
	}

	return res, nil
}

// GetPullrequestsSelectedUser - List pull requests for a user
// Returns all pull requests authored by the specified user.
//
// By default only open pull requests are returned. This can be controlled
// using the `state` query parameter. To retrieve pull requests that are
// in one of multiple states, repeat the `state` parameter for each
// individual state.
//
// This endpoint also supports filtering and sorting of the results. See
// [filtering and sorting](/cloud/bitbucket/rest/intro/#filtering) for more details.
func (s *pullrequests) GetPullrequestsSelectedUser(ctx context.Context, request operations.GetPullrequestsSelectedUserRequest, security operations.GetPullrequestsSelectedUserSecurity) (*operations.GetPullrequestsSelectedUserResponse, error) {
	baseURL := s.serverURL
	url, err := utils.GenerateURL(ctx, baseURL, "/pullrequests/{selected_user}", request, nil)
	if err != nil {
		return nil, fmt.Errorf("error generating URL: %w", err)
	}

	req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	if err := utils.PopulateQueryParams(ctx, req, request, nil); err != nil {
		return nil, fmt.Errorf("error populating query params: %w", err)
	}

	client := utils.ConfigureSecurityClient(s.defaultClient, security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.GetPullrequestsSelectedUserResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *shared.PaginatedPullrequests
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.PaginatedPullrequests = out
		}
	case httpRes.StatusCode == 404:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out map[string]interface{}
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.Error = out
		}
	}

	return res, nil
}

// GetRepositoriesWorkspaceRepoSlugDefaultReviewers - List default reviewers
// Returns the repository's default reviewers.
//
// These are the users that are automatically added as reviewers on every
// new pull request that is created. To obtain the repository's default reviewers
// as well as the default reviewers inherited from the project, use the
// [effective-default-reveiwers](#api-repositories-workspace-repo-slug-effective-default-reviewers-get) endpoint.
func (s *pullrequests) GetRepositoriesWorkspaceRepoSlugDefaultReviewers(ctx context.Context, request operations.GetRepositoriesWorkspaceRepoSlugDefaultReviewersRequest, security operations.GetRepositoriesWorkspaceRepoSlugDefaultReviewersSecurity) (*operations.GetRepositoriesWorkspaceRepoSlugDefaultReviewersResponse, error) {
	baseURL := s.serverURL
	url, err := utils.GenerateURL(ctx, baseURL, "/repositories/{workspace}/{repo_slug}/default-reviewers", request, nil)
	if err != nil {
		return nil, fmt.Errorf("error generating URL: %w", err)
	}

	req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	client := utils.ConfigureSecurityClient(s.defaultClient, security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.GetRepositoriesWorkspaceRepoSlugDefaultReviewersResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *shared.PaginatedAccounts
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.PaginatedAccounts = out
		}
	case httpRes.StatusCode == 403:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out map[string]interface{}
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.Error = out
		}
	}

	return res, nil
}

// GetRepositoriesWorkspaceRepoSlugDefaultReviewersTargetUsername - Get a default reviewer
// Returns the specified reviewer.
//
// This can be used to test whether a user is among the repository's
// default reviewers list. A 404 indicates that that specified user is not
// a default reviewer.
func (s *pullrequests) GetRepositoriesWorkspaceRepoSlugDefaultReviewersTargetUsername(ctx context.Context, request operations.GetRepositoriesWorkspaceRepoSlugDefaultReviewersTargetUsernameRequest, security operations.GetRepositoriesWorkspaceRepoSlugDefaultReviewersTargetUsernameSecurity) (*operations.GetRepositoriesWorkspaceRepoSlugDefaultReviewersTargetUsernameResponse, error) {
	baseURL := s.serverURL
	url, err := utils.GenerateURL(ctx, baseURL, "/repositories/{workspace}/{repo_slug}/default-reviewers/{target_username}", request, nil)
	if err != nil {
		return nil, fmt.Errorf("error generating URL: %w", err)
	}

	req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	client := utils.ConfigureSecurityClient(s.defaultClient, security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.GetRepositoriesWorkspaceRepoSlugDefaultReviewersTargetUsernameResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out map[string]interface{}
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.Account = out
		}
	case httpRes.StatusCode == 403:
		fallthrough
	case httpRes.StatusCode == 404:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out map[string]interface{}
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.Error = out
		}
	}

	return res, nil
}

// GetRepositoriesWorkspaceRepoSlugEffectiveDefaultReviewers - List effective default reviewers
// Returns the repository's effective default reviewers. This includes both default
// reviewers defined at the repository level as well as those inherited from its project.
//
// These are the users that are automatically added as reviewers on every
// new pull request that is created.
//
// ```
// $ curl https://api.bitbucket.org/2.0/repositories/{workspace_slug}/{repo_slug}/effective-default-reviewers?page=1&pagelen=20
//
//	{
//	    "pagelen": 20,
//	    "values": [
//	        {
//	            "user": {
//	                "display_name": "Patrick Wolf",
//	                "uuid": "{9565301a-a3cf-4b5d-88f4-dd6af8078d7e}"
//	            },
//	            "reviewer_type": "project",
//	            "type": "default_reviewer",
//	        },
//	        {
//	            "user": {
//	                "display_name": "Davis Lee",
//	                "uuid": "{f0e0e8e9-66c1-4b85-a784-44a9eb9ef1a6}"
//	            },
//	            "reviewer_type": "repository",
//	            "type": "default_reviewer",
//	        }
//	    ],
//	    "page": 1,
//	    "size": 2
//	}
//
// ```
func (s *pullrequests) GetRepositoriesWorkspaceRepoSlugEffectiveDefaultReviewers(ctx context.Context, request operations.GetRepositoriesWorkspaceRepoSlugEffectiveDefaultReviewersRequest, security operations.GetRepositoriesWorkspaceRepoSlugEffectiveDefaultReviewersSecurity) (*operations.GetRepositoriesWorkspaceRepoSlugEffectiveDefaultReviewersResponse, error) {
	baseURL := s.serverURL
	url, err := utils.GenerateURL(ctx, baseURL, "/repositories/{workspace}/{repo_slug}/effective-default-reviewers", request, nil)
	if err != nil {
		return nil, fmt.Errorf("error generating URL: %w", err)
	}

	req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	client := utils.ConfigureSecurityClient(s.defaultClient, security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.GetRepositoriesWorkspaceRepoSlugEffectiveDefaultReviewersResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *shared.PaginatedDefaultReviewerAndType
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.PaginatedDefaultReviewerAndType = out
		}
	case httpRes.StatusCode == 403:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out map[string]interface{}
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.Error = out
		}
	}

	return res, nil
}

// GetRepositoriesWorkspaceRepoSlugPullrequests - List pull requests
// Returns all pull requests on the specified repository.
//
// By default only open pull requests are returned. This can be controlled
// using the `state` query parameter. To retrieve pull requests that are
// in one of multiple states, repeat the `state` parameter for each
// individual state.
//
// This endpoint also supports filtering and sorting of the results. See
// [filtering and sorting](/cloud/bitbucket/rest/intro/#filtering) for more details.
func (s *pullrequests) GetRepositoriesWorkspaceRepoSlugPullrequests(ctx context.Context, request operations.GetRepositoriesWorkspaceRepoSlugPullrequestsRequest, security operations.GetRepositoriesWorkspaceRepoSlugPullrequestsSecurity) (*operations.GetRepositoriesWorkspaceRepoSlugPullrequestsResponse, error) {
	baseURL := s.serverURL
	url, err := utils.GenerateURL(ctx, baseURL, "/repositories/{workspace}/{repo_slug}/pullrequests", request, nil)
	if err != nil {
		return nil, fmt.Errorf("error generating URL: %w", err)
	}

	req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	if err := utils.PopulateQueryParams(ctx, req, request, nil); err != nil {
		return nil, fmt.Errorf("error populating query params: %w", err)
	}

	client := utils.ConfigureSecurityClient(s.defaultClient, security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.GetRepositoriesWorkspaceRepoSlugPullrequestsResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *shared.PaginatedPullrequests
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.PaginatedPullrequests = out
		}
	case httpRes.StatusCode == 401:
	case httpRes.StatusCode == 404:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out map[string]interface{}
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.Error = out
		}
	}

	return res, nil
}

// GetRepositoriesWorkspaceRepoSlugPullrequestsActivity - List a pull request activity log
// Returns a paginated list of the pull request's activity log.
//
// This handler serves both a v20 and internal endpoint. The v20 endpoint
// returns reviewer comments, updates, approvals and request changes. The internal
// endpoint includes those plus tasks and attachments.
//
// Comments created on a file or a line of code have an inline property.
//
// Comment example:
// ```
//
//	{
//	    "pagelen": 20,
//	    "values": [
//	        {
//	            "comment": {
//	                "links": {
//	                    "self": {
//	                        "href": "https://api.bitbucket.org/2.0/repositories/atlassian/atlaskit-mk-2/pullrequests/5695/comments/118571088"
//	                    },
//	                    "html": {
//	                        "href": "https://bitbucket.org/atlassian/atlaskit-mk-2/pull-requests/5695/_/diff#comment-118571088"
//	                    }
//	                },
//	                "deleted": false,
//	                "pullrequest": {
//	                    "type": "pullrequest",
//	                    "id": 5695,
//	                    "links": {
//	                        "self": {
//	                            "href": "https://api.bitbucket.org/2.0/repositories/atlassian/atlaskit-mk-2/pullrequests/5695"
//	                        },
//	                        "html": {
//	                            "href": "https://bitbucket.org/atlassian/atlaskit-mk-2/pull-requests/5695"
//	                        }
//	                    },
//	                    "title": "username/NONE: small change from onFocus to onClick to handle tabbing through the page and not expand the editor unless a click event triggers it"
//	                },
//	                "content": {
//	                    "raw": "inline with to a dn from lines",
//	                    "markup": "markdown",
//	                    "html": "<p>inline with to a dn from lines</p>",
//	                    "type": "rendered"
//	                },
//	                "created_on": "2019-09-27T00:33:46.039178+00:00",
//	                "user": {
//	                    "display_name": "Name Lastname",
//	                    "uuid": "{}",
//	                    "links": {
//	                        "self": {
//	                            "href": "https://api.bitbucket.org/2.0/users/%7B%7D"
//	                        },
//	                        "html": {
//	                            "href": "https://bitbucket.org/%7B%7D/"
//	                        },
//	                        "avatar": {
//	                            "href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/:/128"
//	                        }
//	                    },
//	                    "type": "user",
//	                    "nickname": "Name",
//	                    "account_id": ""
//	                },
//	                "created_on": "2019-09-27T00:33:46.039178+00:00",
//	                "user": {
//	                    "display_name": "Name Lastname",
//	                    "uuid": "{}",
//	                    "links": {
//	                        "self": {
//	                            "href": "https://api.bitbucket.org/2.0/users/%7B%7D"
//	                        },
//	                        "html": {
//	                            "href": "https://bitbucket.org/%7B%7D/"
//	                        },
//	                        "avatar": {
//	                            "href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/:/128"
//	                        }
//	                    },
//	                    "type": "user",
//	                    "nickname": "Name",
//	                    "account_id": ""
//	                },
//	                "updated_on": "2019-09-27T00:33:46.055384+00:00",
//	                "inline": {
//	                    "context_lines": "",
//	                    "to": null,
//	                    "path": "",
//	                    "outdated": false,
//	                    "from": 211
//	                },
//	                "type": "pullrequest_comment",
//	                "id": 118571088
//	            },
//	            "pull_request": {
//	                "type": "pullrequest",
//	                "id": 5695,
//	                "links": {
//	                    "self": {
//	                        "href": "https://api.bitbucket.org/2.0/repositories/atlassian/atlaskit-mk-2/pullrequests/5695"
//	                    },
//	                    "html": {
//	                        "href": "https://bitbucket.org/atlassian/atlaskit-mk-2/pull-requests/5695"
//	                    }
//	                },
//	                "title": "username/NONE: small change from onFocus to onClick to handle tabbing through the page and not expand the editor unless a click event triggers it"
//	            }
//	        }
//	    ]
//	}
//
// ```
//
// Updates include a state property of OPEN, MERGED, or DECLINED.
//
// Update example:
// ```
//
//	{
//	    "pagelen": 20,
//	    "values": [
//	        {
//	            "update": {
//	                "description": "",
//	                "title": "username/NONE: small change from onFocus to onClick to handle tabbing through the page and not expand the editor unless a click event triggers it",
//	                "destination": {
//	                    "commit": {
//	                        "type": "commit",
//	                        "hash": "6a2c16e4a152",
//	                        "links": {
//	                            "self": {
//	                                "href": "https://api.bitbucket.org/2.0/repositories/atlassian/atlaskit-mk-2/commit/6a2c16e4a152"
//	                            },
//	                            "html": {
//	                                "href": "https://bitbucket.org/atlassian/atlaskit-mk-2/commits/6a2c16e4a152"
//	                            }
//	                        }
//	                    },
//	                    "branch": {
//	                        "name": "master"
//	                    },
//	                    "repository": {
//	                        "name": "Atlaskit-MK-2",
//	                        "type": "repository",
//	                        "full_name": "atlassian/atlaskit-mk-2",
//	                        "links": {
//	                            "self": {
//	                                "href": "https://api.bitbucket.org/2.0/repositories/atlassian/atlaskit-mk-2"
//	                            },
//	                            "html": {
//	                                "href": "https://bitbucket.org/atlassian/atlaskit-mk-2"
//	                            },
//	                            "avatar": {
//	                                "href": "https://bytebucket.org/ravatar/%7B%7D?ts=js"
//	                            }
//	                        },
//	                        "uuid": "{}"
//	                    }
//	                },
//	                "reason": "",
//	                "source": {
//	                    "commit": {
//	                        "type": "commit",
//	                        "hash": "728c8bad1813",
//	                        "links": {
//	                            "self": {
//	                                "href": "https://api.bitbucket.org/2.0/repositories/atlassian/atlaskit-mk-2/commit/728c8bad1813"
//	                            },
//	                            "html": {
//	                                "href": "https://bitbucket.org/atlassian/atlaskit-mk-2/commits/728c8bad1813"
//	                            }
//	                        }
//	                    },
//	                    "branch": {
//	                        "name": "username/NONE-add-onClick-prop-for-accessibility"
//	                    },
//	                    "repository": {
//	                        "name": "Atlaskit-MK-2",
//	                        "type": "repository",
//	                        "full_name": "atlassian/atlaskit-mk-2",
//	                        "links": {
//	                            "self": {
//	                                "href": "https://api.bitbucket.org/2.0/repositories/atlassian/atlaskit-mk-2"
//	                            },
//	                            "html": {
//	                                "href": "https://bitbucket.org/atlassian/atlaskit-mk-2"
//	                            },
//	                            "avatar": {
//	                                "href": "https://bytebucket.org/ravatar/%7B%7D?ts=js"
//	                            }
//	                        },
//	                        "uuid": "{}"
//	                    }
//	                },
//	                "state": "OPEN",
//	                "author": {
//	                    "display_name": "Name Lastname",
//	                    "uuid": "{}",
//	                    "links": {
//	                        "self": {
//	                            "href": "https://api.bitbucket.org/2.0/users/%7B%7D"
//	                        },
//	                        "html": {
//	                            "href": "https://bitbucket.org/%7B%7D/"
//	                        },
//	                        "avatar": {
//	                            "href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/:/128"
//	                        }
//	                    },
//	                    "type": "user",
//	                    "nickname": "Name",
//	                    "account_id": ""
//	                },
//	                "date": "2019-05-10T06:48:25.305565+00:00"
//	            },
//	            "pull_request": {
//	                "type": "pullrequest",
//	                "id": 5695,
//	                "links": {
//	                    "self": {
//	                        "href": "https://api.bitbucket.org/2.0/repositories/atlassian/atlaskit-mk-2/pullrequests/5695"
//	                    },
//	                    "html": {
//	                        "href": "https://bitbucket.org/atlassian/atlaskit-mk-2/pull-requests/5695"
//	                    }
//	                },
//	                "title": "username/NONE: small change from onFocus to onClick to handle tabbing through the page and not expand the editor unless a click event triggers it"
//	            }
//	        }
//	    ]
//	}
//
// ```
//
// Approval example:
// ```
//
//	{
//	    "pagelen": 20,
//	    "values": [
//	        {
//	            "approval": {
//	                "date": "2019-09-27T00:37:19.849534+00:00",
//	                "pullrequest": {
//	                    "type": "pullrequest",
//	                    "id": 5695,
//	                    "links": {
//	                        "self": {
//	                            "href": "https://api.bitbucket.org/2.0/repositories/atlassian/atlaskit-mk-2/pullrequests/5695"
//	                        },
//	                        "html": {
//	                            "href": "https://bitbucket.org/atlassian/atlaskit-mk-2/pull-requests/5695"
//	                        }
//	                    },
//	                    "title": "username/NONE: small change from onFocus to onClick to handle tabbing through the page and not expand the editor unless a click event triggers it"
//	                },
//	                "user": {
//	                    "display_name": "Name Lastname",
//	                    "uuid": "{}",
//	                    "links": {
//	                        "self": {
//	                            "href": "https://api.bitbucket.org/2.0/users/%7B%7D"
//	                        },
//	                        "html": {
//	                            "href": "https://bitbucket.org/%7B%7D/"
//	                        },
//	                        "avatar": {
//	                            "href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/:/128"
//	                        }
//	                    },
//	                    "type": "user",
//	                    "nickname": "Name",
//	                    "account_id": ""
//	                }
//	            },
//	            "pull_request": {
//	                "type": "pullrequest",
//	                "id": 5695,
//	                "links": {
//	                    "self": {
//	                        "href": "https://api.bitbucket.org/2.0/repositories/atlassian/atlaskit-mk-2/pullrequests/5695"
//	                    },
//	                    "html": {
//	                        "href": "https://bitbucket.org/atlassian/atlaskit-mk-2/pull-requests/5695"
//	                    }
//	                },
//	                "title": "username/NONE: small change from onFocus to onClick to handle tabbing through the page and not expand the editor unless a click event triggers it"
//	            }
//	        }
//	    ]
//	}
//
// ```
func (s *pullrequests) GetRepositoriesWorkspaceRepoSlugPullrequestsActivity(ctx context.Context, request operations.GetRepositoriesWorkspaceRepoSlugPullrequestsActivityRequest, security operations.GetRepositoriesWorkspaceRepoSlugPullrequestsActivitySecurity) (*operations.GetRepositoriesWorkspaceRepoSlugPullrequestsActivityResponse, error) {
	baseURL := s.serverURL
	url, err := utils.GenerateURL(ctx, baseURL, "/repositories/{workspace}/{repo_slug}/pullrequests/activity", request, nil)
	if err != nil {
		return nil, fmt.Errorf("error generating URL: %w", err)
	}

	req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	client := utils.ConfigureSecurityClient(s.defaultClient, security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.GetRepositoriesWorkspaceRepoSlugPullrequestsActivityResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		fallthrough
	case httpRes.StatusCode == 401:
	case httpRes.StatusCode == 404:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out map[string]interface{}
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.Error = out
		}
	}

	return res, nil
}

// GetRepositoriesWorkspaceRepoSlugPullrequestsPullRequestID - Get a pull request
// Returns the specified pull request.
func (s *pullrequests) GetRepositoriesWorkspaceRepoSlugPullrequestsPullRequestID(ctx context.Context, request operations.GetRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIDRequest, security operations.GetRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIDSecurity) (*operations.GetRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIDResponse, error) {
	baseURL := s.serverURL
	url, err := utils.GenerateURL(ctx, baseURL, "/repositories/{workspace}/{repo_slug}/pullrequests/{pull_request_id}", request, nil)
	if err != nil {
		return nil, fmt.Errorf("error generating URL: %w", err)
	}

	req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	client := utils.ConfigureSecurityClient(s.defaultClient, security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.GetRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIDResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out map[string]interface{}
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.Pullrequest = out
		}
	case httpRes.StatusCode == 401:
	case httpRes.StatusCode == 404:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out map[string]interface{}
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.Error = out
		}
	}

	return res, nil
}

// GetRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIDActivity - List a pull request activity log
// Returns a paginated list of the pull request's activity log.
//
// This handler serves both a v20 and internal endpoint. The v20 endpoint
// returns reviewer comments, updates, approvals and request changes. The internal
// endpoint includes those plus tasks and attachments.
//
// Comments created on a file or a line of code have an inline property.
//
// Comment example:
// ```
//
//	{
//	    "pagelen": 20,
//	    "values": [
//	        {
//	            "comment": {
//	                "links": {
//	                    "self": {
//	                        "href": "https://api.bitbucket.org/2.0/repositories/atlassian/atlaskit-mk-2/pullrequests/5695/comments/118571088"
//	                    },
//	                    "html": {
//	                        "href": "https://bitbucket.org/atlassian/atlaskit-mk-2/pull-requests/5695/_/diff#comment-118571088"
//	                    }
//	                },
//	                "deleted": false,
//	                "pullrequest": {
//	                    "type": "pullrequest",
//	                    "id": 5695,
//	                    "links": {
//	                        "self": {
//	                            "href": "https://api.bitbucket.org/2.0/repositories/atlassian/atlaskit-mk-2/pullrequests/5695"
//	                        },
//	                        "html": {
//	                            "href": "https://bitbucket.org/atlassian/atlaskit-mk-2/pull-requests/5695"
//	                        }
//	                    },
//	                    "title": "username/NONE: small change from onFocus to onClick to handle tabbing through the page and not expand the editor unless a click event triggers it"
//	                },
//	                "content": {
//	                    "raw": "inline with to a dn from lines",
//	                    "markup": "markdown",
//	                    "html": "<p>inline with to a dn from lines</p>",
//	                    "type": "rendered"
//	                },
//	                "created_on": "2019-09-27T00:33:46.039178+00:00",
//	                "user": {
//	                    "display_name": "Name Lastname",
//	                    "uuid": "{}",
//	                    "links": {
//	                        "self": {
//	                            "href": "https://api.bitbucket.org/2.0/users/%7B%7D"
//	                        },
//	                        "html": {
//	                            "href": "https://bitbucket.org/%7B%7D/"
//	                        },
//	                        "avatar": {
//	                            "href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/:/128"
//	                        }
//	                    },
//	                    "type": "user",
//	                    "nickname": "Name",
//	                    "account_id": ""
//	                },
//	                "created_on": "2019-09-27T00:33:46.039178+00:00",
//	                "user": {
//	                    "display_name": "Name Lastname",
//	                    "uuid": "{}",
//	                    "links": {
//	                        "self": {
//	                            "href": "https://api.bitbucket.org/2.0/users/%7B%7D"
//	                        },
//	                        "html": {
//	                            "href": "https://bitbucket.org/%7B%7D/"
//	                        },
//	                        "avatar": {
//	                            "href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/:/128"
//	                        }
//	                    },
//	                    "type": "user",
//	                    "nickname": "Name",
//	                    "account_id": ""
//	                },
//	                "updated_on": "2019-09-27T00:33:46.055384+00:00",
//	                "inline": {
//	                    "context_lines": "",
//	                    "to": null,
//	                    "path": "",
//	                    "outdated": false,
//	                    "from": 211
//	                },
//	                "type": "pullrequest_comment",
//	                "id": 118571088
//	            },
//	            "pull_request": {
//	                "type": "pullrequest",
//	                "id": 5695,
//	                "links": {
//	                    "self": {
//	                        "href": "https://api.bitbucket.org/2.0/repositories/atlassian/atlaskit-mk-2/pullrequests/5695"
//	                    },
//	                    "html": {
//	                        "href": "https://bitbucket.org/atlassian/atlaskit-mk-2/pull-requests/5695"
//	                    }
//	                },
//	                "title": "username/NONE: small change from onFocus to onClick to handle tabbing through the page and not expand the editor unless a click event triggers it"
//	            }
//	        }
//	    ]
//	}
//
// ```
//
// Updates include a state property of OPEN, MERGED, or DECLINED.
//
// Update example:
// ```
//
//	{
//	    "pagelen": 20,
//	    "values": [
//	        {
//	            "update": {
//	                "description": "",
//	                "title": "username/NONE: small change from onFocus to onClick to handle tabbing through the page and not expand the editor unless a click event triggers it",
//	                "destination": {
//	                    "commit": {
//	                        "type": "commit",
//	                        "hash": "6a2c16e4a152",
//	                        "links": {
//	                            "self": {
//	                                "href": "https://api.bitbucket.org/2.0/repositories/atlassian/atlaskit-mk-2/commit/6a2c16e4a152"
//	                            },
//	                            "html": {
//	                                "href": "https://bitbucket.org/atlassian/atlaskit-mk-2/commits/6a2c16e4a152"
//	                            }
//	                        }
//	                    },
//	                    "branch": {
//	                        "name": "master"
//	                    },
//	                    "repository": {
//	                        "name": "Atlaskit-MK-2",
//	                        "type": "repository",
//	                        "full_name": "atlassian/atlaskit-mk-2",
//	                        "links": {
//	                            "self": {
//	                                "href": "https://api.bitbucket.org/2.0/repositories/atlassian/atlaskit-mk-2"
//	                            },
//	                            "html": {
//	                                "href": "https://bitbucket.org/atlassian/atlaskit-mk-2"
//	                            },
//	                            "avatar": {
//	                                "href": "https://bytebucket.org/ravatar/%7B%7D?ts=js"
//	                            }
//	                        },
//	                        "uuid": "{}"
//	                    }
//	                },
//	                "reason": "",
//	                "source": {
//	                    "commit": {
//	                        "type": "commit",
//	                        "hash": "728c8bad1813",
//	                        "links": {
//	                            "self": {
//	                                "href": "https://api.bitbucket.org/2.0/repositories/atlassian/atlaskit-mk-2/commit/728c8bad1813"
//	                            },
//	                            "html": {
//	                                "href": "https://bitbucket.org/atlassian/atlaskit-mk-2/commits/728c8bad1813"
//	                            }
//	                        }
//	                    },
//	                    "branch": {
//	                        "name": "username/NONE-add-onClick-prop-for-accessibility"
//	                    },
//	                    "repository": {
//	                        "name": "Atlaskit-MK-2",
//	                        "type": "repository",
//	                        "full_name": "atlassian/atlaskit-mk-2",
//	                        "links": {
//	                            "self": {
//	                                "href": "https://api.bitbucket.org/2.0/repositories/atlassian/atlaskit-mk-2"
//	                            },
//	                            "html": {
//	                                "href": "https://bitbucket.org/atlassian/atlaskit-mk-2"
//	                            },
//	                            "avatar": {
//	                                "href": "https://bytebucket.org/ravatar/%7B%7D?ts=js"
//	                            }
//	                        },
//	                        "uuid": "{}"
//	                    }
//	                },
//	                "state": "OPEN",
//	                "author": {
//	                    "display_name": "Name Lastname",
//	                    "uuid": "{}",
//	                    "links": {
//	                        "self": {
//	                            "href": "https://api.bitbucket.org/2.0/users/%7B%7D"
//	                        },
//	                        "html": {
//	                            "href": "https://bitbucket.org/%7B%7D/"
//	                        },
//	                        "avatar": {
//	                            "href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/:/128"
//	                        }
//	                    },
//	                    "type": "user",
//	                    "nickname": "Name",
//	                    "account_id": ""
//	                },
//	                "date": "2019-05-10T06:48:25.305565+00:00"
//	            },
//	            "pull_request": {
//	                "type": "pullrequest",
//	                "id": 5695,
//	                "links": {
//	                    "self": {
//	                        "href": "https://api.bitbucket.org/2.0/repositories/atlassian/atlaskit-mk-2/pullrequests/5695"
//	                    },
//	                    "html": {
//	                        "href": "https://bitbucket.org/atlassian/atlaskit-mk-2/pull-requests/5695"
//	                    }
//	                },
//	                "title": "username/NONE: small change from onFocus to onClick to handle tabbing through the page and not expand the editor unless a click event triggers it"
//	            }
//	        }
//	    ]
//	}
//
// ```
//
// Approval example:
// ```
//
//	{
//	    "pagelen": 20,
//	    "values": [
//	        {
//	            "approval": {
//	                "date": "2019-09-27T00:37:19.849534+00:00",
//	                "pullrequest": {
//	                    "type": "pullrequest",
//	                    "id": 5695,
//	                    "links": {
//	                        "self": {
//	                            "href": "https://api.bitbucket.org/2.0/repositories/atlassian/atlaskit-mk-2/pullrequests/5695"
//	                        },
//	                        "html": {
//	                            "href": "https://bitbucket.org/atlassian/atlaskit-mk-2/pull-requests/5695"
//	                        }
//	                    },
//	                    "title": "username/NONE: small change from onFocus to onClick to handle tabbing through the page and not expand the editor unless a click event triggers it"
//	                },
//	                "user": {
//	                    "display_name": "Name Lastname",
//	                    "uuid": "{}",
//	                    "links": {
//	                        "self": {
//	                            "href": "https://api.bitbucket.org/2.0/users/%7B%7D"
//	                        },
//	                        "html": {
//	                            "href": "https://bitbucket.org/%7B%7D/"
//	                        },
//	                        "avatar": {
//	                            "href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/:/128"
//	                        }
//	                    },
//	                    "type": "user",
//	                    "nickname": "Name",
//	                    "account_id": ""
//	                }
//	            },
//	            "pull_request": {
//	                "type": "pullrequest",
//	                "id": 5695,
//	                "links": {
//	                    "self": {
//	                        "href": "https://api.bitbucket.org/2.0/repositories/atlassian/atlaskit-mk-2/pullrequests/5695"
//	                    },
//	                    "html": {
//	                        "href": "https://bitbucket.org/atlassian/atlaskit-mk-2/pull-requests/5695"
//	                    }
//	                },
//	                "title": "username/NONE: small change from onFocus to onClick to handle tabbing through the page and not expand the editor unless a click event triggers it"
//	            }
//	        }
//	    ]
//	}
//
// ```
func (s *pullrequests) GetRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIDActivity(ctx context.Context, request operations.GetRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIDActivityRequest, security operations.GetRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIDActivitySecurity) (*operations.GetRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIDActivityResponse, error) {
	baseURL := s.serverURL
	url, err := utils.GenerateURL(ctx, baseURL, "/repositories/{workspace}/{repo_slug}/pullrequests/{pull_request_id}/activity", request, nil)
	if err != nil {
		return nil, fmt.Errorf("error generating URL: %w", err)
	}

	req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	client := utils.ConfigureSecurityClient(s.defaultClient, security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.GetRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIDActivityResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		fallthrough
	case httpRes.StatusCode == 401:
	case httpRes.StatusCode == 404:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out map[string]interface{}
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.Error = out
		}
	}

	return res, nil
}

// GetRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIDComments - List comments on a pull request
// Returns a paginated list of the pull request's comments.
//
// This includes both global, inline comments and replies.
//
// The default sorting is oldest to newest and can be overridden with
// the `sort` query parameter.
//
// This endpoint also supports filtering and sorting of the results. See
// [filtering and sorting](/cloud/bitbucket/rest/intro/#filtering) for more
// details.
func (s *pullrequests) GetRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIDComments(ctx context.Context, request operations.GetRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIDCommentsRequest, security operations.GetRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIDCommentsSecurity) (*operations.GetRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIDCommentsResponse, error) {
	baseURL := s.serverURL
	url, err := utils.GenerateURL(ctx, baseURL, "/repositories/{workspace}/{repo_slug}/pullrequests/{pull_request_id}/comments", request, nil)
	if err != nil {
		return nil, fmt.Errorf("error generating URL: %w", err)
	}

	req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	client := utils.ConfigureSecurityClient(s.defaultClient, security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.GetRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIDCommentsResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *shared.PaginatedPullrequestComments
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.PaginatedPullrequestComments = out
		}
	case httpRes.StatusCode == 403:
		fallthrough
	case httpRes.StatusCode == 404:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out map[string]interface{}
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.Error = out
		}
	}

	return res, nil
}

// GetRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIDCommentsCommentID - Get a comment on a pull request
// Returns a specific pull request comment.
func (s *pullrequests) GetRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIDCommentsCommentID(ctx context.Context, request operations.GetRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIDCommentsCommentIDRequest, security operations.GetRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIDCommentsCommentIDSecurity) (*operations.GetRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIDCommentsCommentIDResponse, error) {
	baseURL := s.serverURL
	url, err := utils.GenerateURL(ctx, baseURL, "/repositories/{workspace}/{repo_slug}/pullrequests/{pull_request_id}/comments/{comment_id}", request, nil)
	if err != nil {
		return nil, fmt.Errorf("error generating URL: %w", err)
	}

	req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	client := utils.ConfigureSecurityClient(s.defaultClient, security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.GetRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIDCommentsCommentIDResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out map[string]interface{}
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.PullrequestComment = out
		}
	case httpRes.StatusCode == 403:
		fallthrough
	case httpRes.StatusCode == 404:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out map[string]interface{}
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.Error = out
		}
	}

	return res, nil
}

// GetRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIDCommits - List commits on a pull request
// Returns a paginated list of the pull request's commits.
//
// These are the commits that are being merged into the destination
// branch when the pull requests gets accepted.
func (s *pullrequests) GetRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIDCommits(ctx context.Context, request operations.GetRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIDCommitsRequest, security operations.GetRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIDCommitsSecurity) (*operations.GetRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIDCommitsResponse, error) {
	baseURL := s.serverURL
	url, err := utils.GenerateURL(ctx, baseURL, "/repositories/{workspace}/{repo_slug}/pullrequests/{pull_request_id}/commits", request, nil)
	if err != nil {
		return nil, fmt.Errorf("error generating URL: %w", err)
	}

	req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	client := utils.ConfigureSecurityClient(s.defaultClient, security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.GetRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIDCommitsResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
	case httpRes.StatusCode == 403:
		fallthrough
	case httpRes.StatusCode == 404:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out map[string]interface{}
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.Error = out
		}
	}

	return res, nil
}

// GetRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIDDiff - List changes in a pull request
// Redirects to the [repository diff](/cloud/bitbucket/rest/api-group-commits/#api-repositories-workspace-repo-slug-diff-spec-get)
// with the revspec that corresponds to the pull request.
func (s *pullrequests) GetRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIDDiff(ctx context.Context, request operations.GetRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIDDiffRequest, security operations.GetRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIDDiffSecurity) (*operations.GetRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIDDiffResponse, error) {
	baseURL := s.serverURL
	url, err := utils.GenerateURL(ctx, baseURL, "/repositories/{workspace}/{repo_slug}/pullrequests/{pull_request_id}/diff", request, nil)
	if err != nil {
		return nil, fmt.Errorf("error generating URL: %w", err)
	}

	req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	client := utils.ConfigureSecurityClient(s.defaultClient, security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.GetRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIDDiffResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 302:
	}

	return res, nil
}

// GetRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIDDiffstat - Get the diff stat for a pull request
// Redirects to the [repository diffstat](/cloud/bitbucket/rest/api-group-commits/#api-repositories-workspace-repo-slug-diffstat-spec-get)
// with the revspec that corresponds to the pull request.
func (s *pullrequests) GetRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIDDiffstat(ctx context.Context, request operations.GetRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIDDiffstatRequest, security operations.GetRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIDDiffstatSecurity) (*operations.GetRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIDDiffstatResponse, error) {
	baseURL := s.serverURL
	url, err := utils.GenerateURL(ctx, baseURL, "/repositories/{workspace}/{repo_slug}/pullrequests/{pull_request_id}/diffstat", request, nil)
	if err != nil {
		return nil, fmt.Errorf("error generating URL: %w", err)
	}

	req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	client := utils.ConfigureSecurityClient(s.defaultClient, security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.GetRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIDDiffstatResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 302:
	}

	return res, nil
}

// GetRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIDMergeTaskStatusTaskID - Get the merge task status for a pull request
// When merging a pull request takes too long, the client receives a
// task ID along with a 202 status code. The task ID can be used in a call
// to this endpoint to check the status of a merge task.
//
// ```
// curl -X GET https://api.bitbucket.org/2.0/repositories/atlassian/bitbucket/pullrequests/2286/merge/task-status/<task_id>
// ```
//
// If the merge task is not yet finished, a PENDING status will be returned.
//
// ```
// HTTP/2 200
//
//	{
//	    "task_status": "PENDING",
//	    "links": {
//	        "self": {
//	            "href": "https://api.bitbucket.org/2.0/repositories/atlassian/bitbucket/pullrequests/2286/merge/task-status/<task_id>"
//	        }
//	    }
//	}
//
// ```
//
// If the merge was successful, a SUCCESS status will be returned.
//
// ```
// HTTP/2 200
//
//	{
//	    "task_status": "SUCCESS",
//	    "links": {
//	        "self": {
//	            "href": "https://api.bitbucket.org/2.0/repositories/atlassian/bitbucket/pullrequests/2286/merge/task-status/<task_id>"
//	        }
//	    },
//	    "merge_result": <the merged pull request object>
//	}
//
// ```
//
// If the merge task failed, an error will be returned.
//
// ```
//
//	{
//	    "type": "error",
//	    "error": {
//	        "message": "<error message>"
//	    }
//	}
//
// ```
func (s *pullrequests) GetRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIDMergeTaskStatusTaskID(ctx context.Context, request operations.GetRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIDMergeTaskStatusTaskIDRequest, security operations.GetRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIDMergeTaskStatusTaskIDSecurity) (*operations.GetRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIDMergeTaskStatusTaskIDResponse, error) {
	baseURL := s.serverURL
	url, err := utils.GenerateURL(ctx, baseURL, "/repositories/{workspace}/{repo_slug}/pullrequests/{pull_request_id}/merge/task-status/{task_id}", request, nil)
	if err != nil {
		return nil, fmt.Errorf("error generating URL: %w", err)
	}

	req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	client := utils.ConfigureSecurityClient(s.defaultClient, security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.GetRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIDMergeTaskStatusTaskIDResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		fallthrough
	case httpRes.StatusCode == 400:
		fallthrough
	case httpRes.StatusCode == 403:
	}

	return res, nil
}

// GetRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIDPatch - Get the patch for a pull request
// Redirects to the [repository patch](/cloud/bitbucket/rest/api-group-commits/#api-repositories-workspace-repo-slug-patch-spec-get)
// with the revspec that corresponds to pull request.
func (s *pullrequests) GetRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIDPatch(ctx context.Context, request operations.GetRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIDPatchRequest, security operations.GetRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIDPatchSecurity) (*operations.GetRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIDPatchResponse, error) {
	baseURL := s.serverURL
	url, err := utils.GenerateURL(ctx, baseURL, "/repositories/{workspace}/{repo_slug}/pullrequests/{pull_request_id}/patch", request, nil)
	if err != nil {
		return nil, fmt.Errorf("error generating URL: %w", err)
	}

	req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	client := utils.ConfigureSecurityClient(s.defaultClient, security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.GetRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIDPatchResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 302:
	}

	return res, nil
}

// GetRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIDStatuses - List commit statuses for a pull request
// Returns all statuses (e.g. build results) for the given pull
// request.
func (s *pullrequests) GetRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIDStatuses(ctx context.Context, request operations.GetRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIDStatusesRequest, security operations.GetRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIDStatusesSecurity) (*operations.GetRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIDStatusesResponse, error) {
	baseURL := s.serverURL
	url, err := utils.GenerateURL(ctx, baseURL, "/repositories/{workspace}/{repo_slug}/pullrequests/{pull_request_id}/statuses", request, nil)
	if err != nil {
		return nil, fmt.Errorf("error generating URL: %w", err)
	}

	req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	if err := utils.PopulateQueryParams(ctx, req, request, nil); err != nil {
		return nil, fmt.Errorf("error populating query params: %w", err)
	}

	client := utils.ConfigureSecurityClient(s.defaultClient, security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.GetRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIDStatusesResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *shared.PaginatedCommitstatuses
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.PaginatedCommitstatuses = out
		}
	case httpRes.StatusCode == 401:
	case httpRes.StatusCode == 404:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out map[string]interface{}
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.Error = out
		}
	}

	return res, nil
}

// PostRepositoriesWorkspaceRepoSlugPullrequests - Create a pull request
// Creates a new pull request where the destination repository is
// this repository and the author is the authenticated user.
//
// The minimum required fields to create a pull request are `title` and
// `source`, specified by a branch name.
//
// ```
//
//	curl https://api.bitbucket.org/2.0/repositories/my-workspace/my-repository/pullrequests \
//	    -u my-username:my-password \
//	    --request POST \
//	    --header 'Content-Type: application/json' \
//	    --data '{
//	        "title": "My Title",
//	        "source": {
//	            "branch": {
//	                "name": "staging"
//	            }
//	        }
//	    }'
//
// ```
//
// If the pull request's `destination` is not specified, it will default
// to the `repository.mainbranch`. To open a pull request to a
// different branch, say from a feature branch to a staging branch,
// specify a `destination` (same format as the `source`):
//
// ```
//
//	{
//	    "title": "My Title",
//	    "source": {
//	        "branch": {
//	            "name": "my-feature-branch"
//	        }
//	    },
//	    "destination": {
//	        "branch": {
//	            "name": "staging"
//	        }
//	    }
//	}
//
// ```
//
// Reviewers can be specified by adding an array of user objects as the
// `reviewers` property.
//
// ```
//
//	{
//	    "title": "My Title",
//	    "source": {
//	        "branch": {
//	            "name": "my-feature-branch"
//	        }
//	    },
//	    "reviewers": [
//	        {
//	            "uuid": "{504c3b62-8120-4f0c-a7bc-87800b9d6f70}"
//	        }
//	    ]
//	}
//
// ```
//
// Other fields:
//
// * `description` - a string
// * `close_source_branch` - boolean that specifies if the source branch should be closed upon merging
func (s *pullrequests) PostRepositoriesWorkspaceRepoSlugPullrequests(ctx context.Context, request operations.PostRepositoriesWorkspaceRepoSlugPullrequestsRequest, security operations.PostRepositoriesWorkspaceRepoSlugPullrequestsSecurity) (*operations.PostRepositoriesWorkspaceRepoSlugPullrequestsResponse, error) {
	baseURL := s.serverURL
	url, err := utils.GenerateURL(ctx, baseURL, "/repositories/{workspace}/{repo_slug}/pullrequests", request, nil)
	if err != nil {
		return nil, fmt.Errorf("error generating URL: %w", err)
	}

	bodyReader, reqContentType, err := utils.SerializeRequestBody(ctx, request, "RequestBody", "json")
	if err != nil {
		return nil, fmt.Errorf("error serializing request body: %w", err)
	}

	req, err := http.NewRequestWithContext(ctx, "POST", url, bodyReader)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	req.Header.Set("Content-Type", reqContentType)

	client := utils.ConfigureSecurityClient(s.defaultClient, security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.PostRepositoriesWorkspaceRepoSlugPullrequestsResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 201:
		res.Headers = httpRes.Header

		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out map[string]interface{}
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.Pullrequest = out
		}
	case httpRes.StatusCode == 400:
		fallthrough
	case httpRes.StatusCode == 401:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out map[string]interface{}
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.Error = out
		}
	}

	return res, nil
}

// PostRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIDApprove - Approve a pull request
// Approve the specified pull request as the authenticated user.
func (s *pullrequests) PostRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIDApprove(ctx context.Context, request operations.PostRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIDApproveRequest, security operations.PostRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIDApproveSecurity) (*operations.PostRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIDApproveResponse, error) {
	baseURL := s.serverURL
	url, err := utils.GenerateURL(ctx, baseURL, "/repositories/{workspace}/{repo_slug}/pullrequests/{pull_request_id}/approve", request, nil)
	if err != nil {
		return nil, fmt.Errorf("error generating URL: %w", err)
	}

	req, err := http.NewRequestWithContext(ctx, "POST", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	client := utils.ConfigureSecurityClient(s.defaultClient, security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.PostRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIDApproveResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out map[string]interface{}
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.Participant = out
		}
	case httpRes.StatusCode == 401:
		fallthrough
	case httpRes.StatusCode == 404:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out map[string]interface{}
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.Error = out
		}
	}

	return res, nil
}

// PostRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIDComments - Create a comment on a pull request
// Creates a new pull request comment.
//
// Returns the newly created pull request comment.
func (s *pullrequests) PostRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIDComments(ctx context.Context, request operations.PostRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIDCommentsRequest, security operations.PostRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIDCommentsSecurity) (*operations.PostRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIDCommentsResponse, error) {
	baseURL := s.serverURL
	url, err := utils.GenerateURL(ctx, baseURL, "/repositories/{workspace}/{repo_slug}/pullrequests/{pull_request_id}/comments", request, nil)
	if err != nil {
		return nil, fmt.Errorf("error generating URL: %w", err)
	}

	bodyReader, reqContentType, err := utils.SerializeRequestBody(ctx, request, "RequestBody", "json")
	if err != nil {
		return nil, fmt.Errorf("error serializing request body: %w", err)
	}
	if bodyReader == nil {
		return nil, fmt.Errorf("request body is required")
	}

	req, err := http.NewRequestWithContext(ctx, "POST", url, bodyReader)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	req.Header.Set("Content-Type", reqContentType)

	client := utils.ConfigureSecurityClient(s.defaultClient, security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.PostRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIDCommentsResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 201:
		res.Headers = httpRes.Header

		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out map[string]interface{}
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.PullrequestComment = out
		}
	case httpRes.StatusCode == 403:
		fallthrough
	case httpRes.StatusCode == 404:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out map[string]interface{}
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.Error = out
		}
	}

	return res, nil
}

// PostRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIDCommentsCommentIDResolve - Resolve a comment thread
func (s *pullrequests) PostRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIDCommentsCommentIDResolve(ctx context.Context, request operations.PostRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIDCommentsCommentIDResolveRequest, security operations.PostRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIDCommentsCommentIDResolveSecurity) (*operations.PostRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIDCommentsCommentIDResolveResponse, error) {
	baseURL := s.serverURL
	url, err := utils.GenerateURL(ctx, baseURL, "/repositories/{workspace}/{repo_slug}/pullrequests/{pull_request_id}/comments/{comment_id}/resolve", request, nil)
	if err != nil {
		return nil, fmt.Errorf("error generating URL: %w", err)
	}

	req, err := http.NewRequestWithContext(ctx, "POST", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	client := utils.ConfigureSecurityClient(s.defaultClient, security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.PostRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIDCommentsCommentIDResolveResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out map[string]interface{}
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.CommentResolution = out
		}
	case httpRes.StatusCode == 403:
		fallthrough
	case httpRes.StatusCode == 404:
		fallthrough
	case httpRes.StatusCode == 409:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out map[string]interface{}
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.Error = out
		}
	}

	return res, nil
}

// PostRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIDDecline - Decline a pull request
// Declines the pull request.
func (s *pullrequests) PostRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIDDecline(ctx context.Context, request operations.PostRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIDDeclineRequest, security operations.PostRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIDDeclineSecurity) (*operations.PostRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIDDeclineResponse, error) {
	baseURL := s.serverURL
	url, err := utils.GenerateURL(ctx, baseURL, "/repositories/{workspace}/{repo_slug}/pullrequests/{pull_request_id}/decline", request, nil)
	if err != nil {
		return nil, fmt.Errorf("error generating URL: %w", err)
	}

	req, err := http.NewRequestWithContext(ctx, "POST", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	client := utils.ConfigureSecurityClient(s.defaultClient, security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.PostRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIDDeclineResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out map[string]interface{}
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.Pullrequest = out
		}
	case httpRes.StatusCode == 555:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out map[string]interface{}
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.Error = out
		}
	}

	return res, nil
}

// PostRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIDMerge - Merge a pull request
// Merges the pull request.
func (s *pullrequests) PostRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIDMerge(ctx context.Context, request operations.PostRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIDMergeRequest, security operations.PostRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIDMergeSecurity) (*operations.PostRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIDMergeResponse, error) {
	baseURL := s.serverURL
	url, err := utils.GenerateURL(ctx, baseURL, "/repositories/{workspace}/{repo_slug}/pullrequests/{pull_request_id}/merge", request, nil)
	if err != nil {
		return nil, fmt.Errorf("error generating URL: %w", err)
	}

	bodyReader, reqContentType, err := utils.SerializeRequestBody(ctx, request, "RequestBody", "json")
	if err != nil {
		return nil, fmt.Errorf("error serializing request body: %w", err)
	}

	req, err := http.NewRequestWithContext(ctx, "POST", url, bodyReader)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	req.Header.Set("Content-Type", reqContentType)

	if err := utils.PopulateQueryParams(ctx, req, request, nil); err != nil {
		return nil, fmt.Errorf("error populating query params: %w", err)
	}

	client := utils.ConfigureSecurityClient(s.defaultClient, security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.PostRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIDMergeResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out map[string]interface{}
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.Pullrequest = out
		}
	case httpRes.StatusCode == 202:
	case httpRes.StatusCode == 555:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out map[string]interface{}
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.Error = out
		}
	}

	return res, nil
}

// PostRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIDRequestChanges - Request changes for a pull request
func (s *pullrequests) PostRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIDRequestChanges(ctx context.Context, request operations.PostRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIDRequestChangesRequest, security operations.PostRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIDRequestChangesSecurity) (*operations.PostRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIDRequestChangesResponse, error) {
	baseURL := s.serverURL
	url, err := utils.GenerateURL(ctx, baseURL, "/repositories/{workspace}/{repo_slug}/pullrequests/{pull_request_id}/request-changes", request, nil)
	if err != nil {
		return nil, fmt.Errorf("error generating URL: %w", err)
	}

	req, err := http.NewRequestWithContext(ctx, "POST", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	client := utils.ConfigureSecurityClient(s.defaultClient, security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.PostRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIDRequestChangesResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out map[string]interface{}
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.Participant = out
		}
	case httpRes.StatusCode == 400:
		fallthrough
	case httpRes.StatusCode == 401:
		fallthrough
	case httpRes.StatusCode == 404:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out map[string]interface{}
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.Error = out
		}
	}

	return res, nil
}

// PutRepositoriesWorkspaceRepoSlugDefaultReviewersTargetUsername - Add a user to the default reviewers
// Adds the specified user to the repository's list of default
// reviewers.
//
// This method is idempotent. Adding a user a second time has no effect.
func (s *pullrequests) PutRepositoriesWorkspaceRepoSlugDefaultReviewersTargetUsername(ctx context.Context, request operations.PutRepositoriesWorkspaceRepoSlugDefaultReviewersTargetUsernameRequest, security operations.PutRepositoriesWorkspaceRepoSlugDefaultReviewersTargetUsernameSecurity) (*operations.PutRepositoriesWorkspaceRepoSlugDefaultReviewersTargetUsernameResponse, error) {
	baseURL := s.serverURL
	url, err := utils.GenerateURL(ctx, baseURL, "/repositories/{workspace}/{repo_slug}/default-reviewers/{target_username}", request, nil)
	if err != nil {
		return nil, fmt.Errorf("error generating URL: %w", err)
	}

	req, err := http.NewRequestWithContext(ctx, "PUT", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	client := utils.ConfigureSecurityClient(s.defaultClient, security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.PutRepositoriesWorkspaceRepoSlugDefaultReviewersTargetUsernameResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out map[string]interface{}
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.Account = out
		}
	case httpRes.StatusCode == 400:
		fallthrough
	case httpRes.StatusCode == 403:
		fallthrough
	case httpRes.StatusCode == 404:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out map[string]interface{}
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.Error = out
		}
	}

	return res, nil
}

// PutRepositoriesWorkspaceRepoSlugPullrequestsPullRequestID - Update a pull request
// Mutates the specified pull request.
//
// This can be used to change the pull request's branches or description.
//
// Only open pull requests can be mutated.
func (s *pullrequests) PutRepositoriesWorkspaceRepoSlugPullrequestsPullRequestID(ctx context.Context, request operations.PutRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIDRequest, security operations.PutRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIDSecurity) (*operations.PutRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIDResponse, error) {
	baseURL := s.serverURL
	url, err := utils.GenerateURL(ctx, baseURL, "/repositories/{workspace}/{repo_slug}/pullrequests/{pull_request_id}", request, nil)
	if err != nil {
		return nil, fmt.Errorf("error generating URL: %w", err)
	}

	bodyReader, reqContentType, err := utils.SerializeRequestBody(ctx, request, "RequestBody", "json")
	if err != nil {
		return nil, fmt.Errorf("error serializing request body: %w", err)
	}

	req, err := http.NewRequestWithContext(ctx, "PUT", url, bodyReader)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	req.Header.Set("Content-Type", reqContentType)

	client := utils.ConfigureSecurityClient(s.defaultClient, security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.PutRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIDResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out map[string]interface{}
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.Pullrequest = out
		}
	case httpRes.StatusCode == 400:
		fallthrough
	case httpRes.StatusCode == 401:
		fallthrough
	case httpRes.StatusCode == 404:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out map[string]interface{}
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.Error = out
		}
	}

	return res, nil
}

// PutRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIDCommentsCommentID - Update a comment on a pull request
// Updates a specific pull request comment.
func (s *pullrequests) PutRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIDCommentsCommentID(ctx context.Context, request operations.PutRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIDCommentsCommentIDRequest, security operations.PutRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIDCommentsCommentIDSecurity) (*operations.PutRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIDCommentsCommentIDResponse, error) {
	baseURL := s.serverURL
	url, err := utils.GenerateURL(ctx, baseURL, "/repositories/{workspace}/{repo_slug}/pullrequests/{pull_request_id}/comments/{comment_id}", request, nil)
	if err != nil {
		return nil, fmt.Errorf("error generating URL: %w", err)
	}

	bodyReader, reqContentType, err := utils.SerializeRequestBody(ctx, request, "RequestBody", "json")
	if err != nil {
		return nil, fmt.Errorf("error serializing request body: %w", err)
	}
	if bodyReader == nil {
		return nil, fmt.Errorf("request body is required")
	}

	req, err := http.NewRequestWithContext(ctx, "PUT", url, bodyReader)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	req.Header.Set("Content-Type", reqContentType)

	client := utils.ConfigureSecurityClient(s.defaultClient, security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.PutRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIDCommentsCommentIDResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out map[string]interface{}
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.PullrequestComment = out
		}
	case httpRes.StatusCode == 403:
		fallthrough
	case httpRes.StatusCode == 404:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out map[string]interface{}
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.Error = out
		}
	}

	return res, nil
}
