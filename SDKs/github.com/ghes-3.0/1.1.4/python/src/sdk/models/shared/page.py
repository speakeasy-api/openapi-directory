"""Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT."""

from __future__ import annotations
import dataclasses
import dateutil.parser
from ..shared import pages_https_certificate as shared_pages_https_certificate
from ..shared import pages_source_hash as shared_pages_source_hash
from dataclasses_json import Undefined, dataclass_json
from datetime import datetime
from enum import Enum
from marshmallow import fields
from sdk import utils
from typing import Optional

class PageProtectedDomainStateEnum(str, Enum):
    r"""The state if the domain is verified"""
    PENDING = 'pending'
    VERIFIED = 'verified'
    UNVERIFIED = 'unverified'

class PageStatusEnum(str, Enum):
    r"""The status of the most recent build of the Page."""
    BUILT = 'built'
    BUILDING = 'building'
    ERRORED = 'errored'


@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class Page:
    r"""The configuration for GitHub Pages for a repository."""
    
    cname: str = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('cname') }})
    r"""The Pages site's custom domain"""  
    custom_404: bool = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('custom_404') }})
    r"""Whether the Page has a custom 404 page."""  
    public: bool = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('public') }})
    r"""Whether the GitHub Pages site is publicly visible. If set to `true`, the site is accessible to anyone on the internet. If set to `false`, the site will only be accessible to users who have at least `read` access to the repository that published the site."""  
    status: PageStatusEnum = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('status') }})
    r"""The status of the most recent build of the Page."""  
    url: str = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('url') }})
    r"""The API address for accessing this Page resource."""  
    html_url: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('html_url'), 'exclude': lambda f: f is None }})
    r"""The web address the Page can be accessed from."""  
    https_certificate: Optional[shared_pages_https_certificate.PagesHTTPSCertificate] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('https_certificate'), 'exclude': lambda f: f is None }})  
    https_enforced: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('https_enforced'), 'exclude': lambda f: f is None }})
    r"""Whether https is enabled on the domain"""  
    pending_domain_unverified_at: Optional[datetime] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('pending_domain_unverified_at'), 'encoder': utils.datetimeisoformat(True), 'decoder': dateutil.parser.isoparse, 'mm_field': fields.DateTime(format='iso'), 'exclude': lambda f: f is None }})
    r"""The timestamp when a pending domain becomes unverified."""  
    protected_domain_state: Optional[PageProtectedDomainStateEnum] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('protected_domain_state'), 'exclude': lambda f: f is None }})
    r"""The state if the domain is verified"""  
    source: Optional[shared_pages_source_hash.PagesSourceHash] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('source'), 'exclude': lambda f: f is None }})  
    