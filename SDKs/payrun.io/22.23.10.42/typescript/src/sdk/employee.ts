/*
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

import * as utils from "../internal/utils";
import * as operations from "./models/operations";
import * as shared from "./models/shared";
import { AxiosInstance, AxiosRequestConfig, AxiosResponse } from "axios";

export class Employee {
  _defaultClient: AxiosInstance;
  _securityClient: AxiosInstance;
  _serverURL: string;
  _language: string;
  _sdkVersion: string;
  _genVersion: string;

  constructor(
    defaultClient: AxiosInstance,
    securityClient: AxiosInstance,
    serverURL: string,
    language: string,
    sdkVersion: string,
    genVersion: string
  ) {
    this._defaultClient = defaultClient;
    this._securityClient = securityClient;
    this._serverURL = serverURL;
    this._language = language;
    this._sdkVersion = sdkVersion;
    this._genVersion = genVersion;
  }

  /**
   * Delete an Employee
   *
   * @remarks
   * Delete the specified employee
   */
  deleteEmployee(
    req: operations.DeleteEmployeeRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.DeleteEmployeeResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DeleteEmployeeRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/Employer/{EmployerId}/Employee/{EmployeeId}",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };

    const r = client.request({
      url: url,
      method: "delete",
      headers: headers,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DeleteEmployeeResponse =
        new operations.DeleteEmployeeResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
        case [400, 401, 404, 500].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorModel = utils.objectToClass(
              httpRes?.data,
              shared.ErrorModel
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Delete an Employee revision matching the specified revision date.
   *
   * @remarks
   * Deletes the specified employee revision for the matching revision date
   */
  deleteEmployeeRevision(
    req: operations.DeleteEmployeeRevisionRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.DeleteEmployeeRevisionResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DeleteEmployeeRevisionRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/Employer/{EmployerId}/Employee/{EmployeeId}/{EffectiveDate}",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };

    const r = client.request({
      url: url,
      method: "delete",
      headers: headers,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DeleteEmployeeRevisionResponse =
        new operations.DeleteEmployeeRevisionResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
        case [400, 401, 404, 500].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorModel = utils.objectToClass(
              httpRes?.data,
              shared.ErrorModel
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Delete an Employee revision matching the specified revision number.
   *
   * @remarks
   * Deletes the specified employee revision for the matching revision number
   */
  deleteEmployeeRevisionByNumber(
    req: operations.DeleteEmployeeRevisionByNumberRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.DeleteEmployeeRevisionByNumberResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DeleteEmployeeRevisionByNumberRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/Employer/{EmployerId}/Employee/{EmployeeId}/Revision/{RevisionNumber}",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };

    const r = client.request({
      url: url,
      method: "delete",
      headers: headers,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DeleteEmployeeRevisionByNumberResponse =
        new operations.DeleteEmployeeRevisionByNumberResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
        case [400, 401, 404, 500].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorModel = utils.objectToClass(
              httpRes?.data,
              shared.ErrorModel
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Deletes employee secret
   *
   * @remarks
   * Deletes an employee secret from the given resource location
   */
  deleteEmployeeSecret(
    req: operations.DeleteEmployeeSecretRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.DeleteEmployeeSecretResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DeleteEmployeeSecretRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/Employer/{EmployerId}/Employee/{EmployeeId}/Secret/{SecretId}",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };

    const r = client.request({
      url: url,
      method: "delete",
      headers: headers,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DeleteEmployeeSecretResponse =
        new operations.DeleteEmployeeSecretResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
        case [400, 401, 404, 500].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorModel = utils.objectToClass(
              httpRes?.data,
              shared.ErrorModel
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Get the auto enrolment assessment
   *
   * @remarks
   * Gets the auto enrolment assessment from the specified employee
   */
  getAEAssessmentFromEmployee(
    req: operations.GetAEAssessmentFromEmployeeRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetAEAssessmentFromEmployeeResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetAEAssessmentFromEmployeeRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/Employer/{EmployerId}/Employee/{EmployeeId}/AEAssessment/{AEAssessmentId}",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };

    const r = client.request({
      url: url,
      method: "get",
      headers: headers,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetAEAssessmentFromEmployeeResponse =
        new operations.GetAEAssessmentFromEmployeeResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.aeAssessment = utils.objectToClass(
              httpRes?.data,
              shared.AEAssessment
            );
          }
          break;
        case [400, 401, 404, 500].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorModel = utils.objectToClass(
              httpRes?.data,
              shared.ErrorModel
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Get the auto enrolment assessments
   *
   * @remarks
   * Gets all auto enrolment assessments from the specified employee
   */
  getAEAssessmentsFromEmployee(
    req: operations.GetAEAssessmentsFromEmployeeRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetAEAssessmentsFromEmployeeResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetAEAssessmentsFromEmployeeRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/Employer/{EmployerId}/Employee/{EmployeeId}/AEAssessments",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };

    const r = client.request({
      url: url,
      method: "get",
      headers: headers,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetAEAssessmentsFromEmployeeResponse =
        new operations.GetAEAssessmentsFromEmployeeResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.linkCollection = utils.objectToClass(
              httpRes?.data,
              shared.LinkCollection
            );
          }
          break;
        case [400, 401, 404, 500].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorModel = utils.objectToClass(
              httpRes?.data,
              shared.ErrorModel
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Get all employee tags
   *
   * @remarks
   * Gets all the employee tags
   */
  getAllEmployeeTags(
    req: operations.GetAllEmployeeTagsRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetAllEmployeeTagsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetAllEmployeeTagsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/Employer/{EmployerId}/Employees/Tags",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };

    const r = client.request({
      url: url,
      method: "get",
      headers: headers,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetAllEmployeeTagsResponse =
        new operations.GetAllEmployeeTagsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.linkCollection = utils.objectToClass(
              httpRes?.data,
              shared.LinkCollection
            );
          }
          break;
        case [400, 401, 404, 500].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorModel = utils.objectToClass(
              httpRes?.data,
              shared.ErrorModel
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Get links to all commentaries for the specified employee
   *
   * @remarks
   * Get links to all commentaries for the specified employee.
   */
  getCommentariesFromEmployee(
    req: operations.GetCommentariesFromEmployeeRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetCommentariesFromEmployeeResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetCommentariesFromEmployeeRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/Employer/{EmployerId}/Employee/{EmployeeId}/Commentaries",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };

    const r = client.request({
      url: url,
      method: "get",
      headers: headers,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetCommentariesFromEmployeeResponse =
        new operations.GetCommentariesFromEmployeeResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.linkCollection = utils.objectToClass(
              httpRes?.data,
              shared.LinkCollection
            );
          }
          break;
        case [400, 401, 404, 500].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorModel = utils.objectToClass(
              httpRes?.data,
              shared.ErrorModel
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Get commentary from employee
   *
   * @remarks
   * Gets the specified commentary report from the employee
   */
  getCommentaryFromEmployee(
    req: operations.GetCommentaryFromEmployeeRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetCommentaryFromEmployeeResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetCommentaryFromEmployeeRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/Employer/{EmployerId}/Employee/{EmployeeId}/Commentary/{CommentaryId}",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };

    const r = client.request({
      url: url,
      method: "get",
      headers: headers,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetCommentaryFromEmployeeResponse =
        new operations.GetCommentaryFromEmployeeResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.commentary = utils.objectToClass(
              httpRes?.data,
              shared.Commentary
            );
          }
          break;
        case [400, 401, 404, 500].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorModel = utils.objectToClass(
              httpRes?.data,
              shared.ErrorModel
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Get commentary from payrun by specified employee.
   *
   * @remarks
   * Get commentary from payrun by specified employee.
   */
  getCommentaryFromPayRunByEmployee(
    req: operations.GetCommentaryFromPayRunByEmployeeRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetCommentaryFromPayRunByEmployeeResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetCommentaryFromPayRunByEmployeeRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/Employer/{EmployerId}/PaySchedule/{PayScheduleId}/PayRun/{PayRunId}/Employee/{EmployeeId}/Commentary",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };

    const r = client.request({
      url: url,
      method: "get",
      headers: headers,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetCommentaryFromPayRunByEmployeeResponse =
        new operations.GetCommentaryFromPayRunByEmployeeResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.commentary = utils.objectToClass(
              httpRes?.data,
              shared.Commentary
            );
          }
          break;
        case [400, 401, 404, 500].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorModel = utils.objectToClass(
              httpRes?.data,
              shared.ErrorModel
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Get employee by effective date.
   *
   * @remarks
   * Returns the employee's state at the specified effective date.
   */
  getEmployeeByEffectiveDate(
    req: operations.GetEmployeeByEffectiveDateRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetEmployeeByEffectiveDateResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetEmployeeByEffectiveDateRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/Employer/{EmployerId}/Employee/{EmployeeId}/{EffectiveDate}",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };

    const r = client.request({
      url: url,
      method: "get",
      headers: headers,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetEmployeeByEffectiveDateResponse =
        new operations.GetEmployeeByEffectiveDateResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.employee = utils.objectToClass(httpRes?.data, shared.Employee);
          }
          break;
        case [400, 401, 404, 500].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorModel = utils.objectToClass(
              httpRes?.data,
              shared.ErrorModel
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Get employee from employer
   *
   * @remarks
   * Gets the specified employee from employer by employee code.
   */
  getEmployeeFromEmployer(
    req: operations.GetEmployeeFromEmployerRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetEmployeeFromEmployerResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetEmployeeFromEmployerRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/Employer/{EmployerId}/Employee/{EmployeeId}",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };

    const r = client.request({
      url: url,
      method: "get",
      headers: headers,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetEmployeeFromEmployerResponse =
        new operations.GetEmployeeFromEmployerResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.employee = utils.objectToClass(httpRes?.data, shared.Employee);
          }
          break;
        case [400, 401, 404, 500].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorModel = utils.objectToClass(
              httpRes?.data,
              shared.ErrorModel
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Gets the employee by revision number
   *
   * @remarks
   * Get the employee revision matching the specified revision number
   */
  getEmployeeRevisionByNumber(
    req: operations.GetEmployeeRevisionByNumberRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetEmployeeRevisionByNumberResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetEmployeeRevisionByNumberRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/Employer/{EmployerId}/Employee/{EmployeeId}/Revision/{RevisionNumber}",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };

    const r = client.request({
      url: url,
      method: "get",
      headers: headers,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetEmployeeRevisionByNumberResponse =
        new operations.GetEmployeeRevisionByNumberResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.employee = utils.objectToClass(httpRes?.data, shared.Employee);
          }
          break;
        case [400, 401, 404, 500].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorModel = utils.objectToClass(
              httpRes?.data,
              shared.ErrorModel
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Get all employee revision summaries
   *
   * @remarks
   * Gets links to all employee revision summaries
   */
  getEmployeeRevisionSummaries(
    req: operations.GetEmployeeRevisionSummariesRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetEmployeeRevisionSummariesResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetEmployeeRevisionSummariesRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/Employer/{EmployerId}/Employee/{EmployeeId}/Revisions/Summary",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };

    const r = client.request({
      url: url,
      method: "get",
      headers: headers,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetEmployeeRevisionSummariesResponse =
        new operations.GetEmployeeRevisionSummariesResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.linkCollection = utils.objectToClass(
              httpRes?.data,
              shared.LinkCollection
            );
          }
          break;
        case [400, 401, 404, 500].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorModel = utils.objectToClass(
              httpRes?.data,
              shared.ErrorModel
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Gets the employee summary by revision number
   *
   * @remarks
   * Get the employee revision summary matching the specified revision number
   */
  getEmployeeRevisionSummaryByNumber(
    req: operations.GetEmployeeRevisionSummaryByNumberRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetEmployeeRevisionSummaryByNumberResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetEmployeeRevisionSummaryByNumberRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/Employer/{EmployerId}/Employee/{EmployeeId}/Revision/{RevisionNumber}/Summary",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };

    const r = client.request({
      url: url,
      method: "get",
      headers: headers,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetEmployeeRevisionSummaryByNumberResponse =
        new operations.GetEmployeeRevisionSummaryByNumberResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.employeeSummary = httpRes?.data;
          }
          break;
        case [400, 401, 404, 500].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorModel = utils.objectToClass(
              httpRes?.data,
              shared.ErrorModel
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Get all employee revisions
   *
   * @remarks
   * Gets links to all employee revisions
   */
  getEmployeeRevisions(
    req: operations.GetEmployeeRevisionsRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetEmployeeRevisionsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetEmployeeRevisionsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/Employer/{EmployerId}/Employee/{EmployeeId}/Revisions",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };

    const r = client.request({
      url: url,
      method: "get",
      headers: headers,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetEmployeeRevisionsResponse =
        new operations.GetEmployeeRevisionsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.linkCollection = utils.objectToClass(
              httpRes?.data,
              shared.LinkCollection
            );
          }
          break;
        case [400, 401, 404, 500].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorModel = utils.objectToClass(
              httpRes?.data,
              shared.ErrorModel
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Get employee secret
   *
   * @remarks
   * Get the public visible employee secret object
   */
  getEmployeeSecret(
    req: operations.GetEmployeeSecretRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetEmployeeSecretResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetEmployeeSecretRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/Employer/{EmployerId}/Employee/{EmployeeId}/Secret/{SecretId}",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };

    const r = client.request({
      url: url,
      method: "get",
      headers: headers,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetEmployeeSecretResponse =
        new operations.GetEmployeeSecretResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.employeeSecret = utils.objectToClass(
              httpRes?.data,
              shared.EmployeeSecret
            );
          }
          break;
        case [400, 401, 404, 500].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorModel = utils.objectToClass(
              httpRes?.data,
              shared.ErrorModel
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Get all employee secret links
   *
   * @remarks
   * Get all the employee secret links
   */
  getEmployeeSecrets(
    req: operations.GetEmployeeSecretsRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetEmployeeSecretsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetEmployeeSecretsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/Employer/{EmployerId}/Employee/{EmployeeId}/Secrets",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };

    const r = client.request({
      url: url,
      method: "get",
      headers: headers,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetEmployeeSecretsResponse =
        new operations.GetEmployeeSecretsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.linkCollection = utils.objectToClass(
              httpRes?.data,
              shared.LinkCollection
            );
          }
          break;
        case [400, 401, 404, 500].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorModel = utils.objectToClass(
              httpRes?.data,
              shared.ErrorModel
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Get employee summaries from employer at a given effective date.
   *
   * @remarks
   * Get links to all employee summaries for the employer on specified effective date.
   */
  getEmployeeSummariesByEffectiveDate(
    req: operations.GetEmployeeSummariesByEffectiveDateRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetEmployeeSummariesByEffectiveDateResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetEmployeeSummariesByEffectiveDateRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/Employer/{EmployerId}/Employees/{EffectiveDate}/Summary",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };

    const r = client.request({
      url: url,
      method: "get",
      headers: headers,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetEmployeeSummariesByEffectiveDateResponse =
        new operations.GetEmployeeSummariesByEffectiveDateResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.linkCollection = utils.objectToClass(
              httpRes?.data,
              shared.LinkCollection
            );
          }
          break;
        case [400, 401, 404, 500].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorModel = utils.objectToClass(
              httpRes?.data,
              shared.ErrorModel
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Get employee summaries from employer.
   *
   * @remarks
   * Get links to all employee summaries for the specified employer.
   */
  getEmployeeSummariesFromEmployer(
    req: operations.GetEmployeeSummariesFromEmployerRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetEmployeeSummariesFromEmployerResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetEmployeeSummariesFromEmployerRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/Employer/{EmployerId}/Employees/Summary",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };

    const r = client.request({
      url: url,
      method: "get",
      headers: headers,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetEmployeeSummariesFromEmployerResponse =
        new operations.GetEmployeeSummariesFromEmployerResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.linkCollection = utils.objectToClass(
              httpRes?.data,
              shared.LinkCollection
            );
          }
          break;
        case [400, 401, 404, 500].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorModel = utils.objectToClass(
              httpRes?.data,
              shared.ErrorModel
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Get employee summary by effective date.
   *
   * @remarks
   * Gets the employee summary for the specified effective date.
   */
  getEmployeeSummaryByEffectiveDate(
    req: operations.GetEmployeeSummaryByEffectiveDateRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetEmployeeSummaryByEffectiveDateResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetEmployeeSummaryByEffectiveDateRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/Employer/{EmployerId}/Employee/{EmployeeId}/{EffectiveDate}/Summary",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };

    const r = client.request({
      url: url,
      method: "get",
      headers: headers,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetEmployeeSummaryByEffectiveDateResponse =
        new operations.GetEmployeeSummaryByEffectiveDateResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.employeeSummary = httpRes?.data;
          }
          break;
        case [400, 401, 404, 500].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorModel = utils.objectToClass(
              httpRes?.data,
              shared.ErrorModel
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Get employee summary from employer
   *
   * @remarks
   * Gets the specified employee summary data from employer by employee code.
   */
  getEmployeeSummaryFromEmployer(
    req: operations.GetEmployeeSummaryFromEmployerRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetEmployeeSummaryFromEmployerResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetEmployeeSummaryFromEmployerRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/Employer/{EmployerId}/Employee/{EmployeeId}/Summary",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };

    const r = client.request({
      url: url,
      method: "get",
      headers: headers,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetEmployeeSummaryFromEmployerResponse =
        new operations.GetEmployeeSummaryFromEmployerResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.employeeSummary = httpRes?.data;
          }
          break;
        case [400, 401, 404, 500].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorModel = utils.objectToClass(
              httpRes?.data,
              shared.ErrorModel
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Get employees from employer at a given effective date.
   *
   * @remarks
   * Get links to all employees for the employer on specified effective date.
   */
  getEmployeesByEffectiveDate(
    req: operations.GetEmployeesByEffectiveDateRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetEmployeesByEffectiveDateResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetEmployeesByEffectiveDateRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/Employer/{EmployerId}/Employees/{EffectiveDate}",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };

    const r = client.request({
      url: url,
      method: "get",
      headers: headers,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetEmployeesByEffectiveDateResponse =
        new operations.GetEmployeesByEffectiveDateResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.linkCollection = utils.objectToClass(
              httpRes?.data,
              shared.LinkCollection
            );
          }
          break;
        case [400, 401, 404, 500].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorModel = utils.objectToClass(
              httpRes?.data,
              shared.ErrorModel
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Get employees from employer.
   *
   * @remarks
   * Get links to all employees for the specified employer.
   */
  getEmployeesFromEmployer(
    req: operations.GetEmployeesFromEmployerRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetEmployeesFromEmployerResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetEmployeesFromEmployerRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/Employer/{EmployerId}/Employees",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };

    const r = client.request({
      url: url,
      method: "get",
      headers: headers,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetEmployeesFromEmployerResponse =
        new operations.GetEmployeesFromEmployerResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.linkCollection = utils.objectToClass(
              httpRes?.data,
              shared.LinkCollection
            );
          }
          break;
        case [400, 401, 404, 500].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorModel = utils.objectToClass(
              httpRes?.data,
              shared.ErrorModel
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Get employees from the pay run
   *
   * @remarks
   * Gets links to all employees included in the specified pay run.
   */
  getEmployeesFromPayRun(
    req: operations.GetEmployeesFromPayRunRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetEmployeesFromPayRunResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetEmployeesFromPayRunRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/Employer/{EmployerId}/PaySchedule/{PayScheduleId}/PayRun/{PayRunId}/Employees",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };

    const r = client.request({
      url: url,
      method: "get",
      headers: headers,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetEmployeesFromPayRunResponse =
        new operations.GetEmployeesFromPayRunResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.linkCollection = utils.objectToClass(
              httpRes?.data,
              shared.LinkCollection
            );
          }
          break;
        case [400, 401, 404, 500].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorModel = utils.objectToClass(
              httpRes?.data,
              shared.ErrorModel
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Get all employees revisions from a pay schedule.
   *
   * @remarks
   * Gets links to all employee revisions that have ever existed in the specified pay schedule.
   */
  getEmployeesFromPaySchedule(
    req: operations.GetEmployeesFromPayScheduleRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetEmployeesFromPayScheduleResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetEmployeesFromPayScheduleRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/Employer/{EmployerId}/PaySchedule/{PayScheduleId}/Employees",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };

    const r = client.request({
      url: url,
      method: "get",
      headers: headers,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetEmployeesFromPayScheduleResponse =
        new operations.GetEmployeesFromPayScheduleResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.linkCollection = utils.objectToClass(
              httpRes?.data,
              shared.LinkCollection
            );
          }
          break;
        case [400, 401, 404, 500].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorModel = utils.objectToClass(
              httpRes?.data,
              shared.ErrorModel
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Get employees from a pay schedule on effective date.
   *
   * @remarks
   * Gets links to all employee revisions in the specified pay schedule for the given effective date.
   */
  getEmployeesFromPayScheduleOnEffectiveDate(
    req: operations.GetEmployeesFromPayScheduleOnEffectiveDateRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetEmployeesFromPayScheduleOnEffectiveDateResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetEmployeesFromPayScheduleOnEffectiveDateRequest(
        req
      );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/Employer/{EmployerId}/PaySchedule/{PayScheduleId}/Employees/{EffectiveDate}",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };

    const r = client.request({
      url: url,
      method: "get",
      headers: headers,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetEmployeesFromPayScheduleOnEffectiveDateResponse =
        new operations.GetEmployeesFromPayScheduleOnEffectiveDateResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.linkCollection = utils.objectToClass(
              httpRes?.data,
              shared.LinkCollection
            );
          }
          break;
        case [400, 401, 404, 500].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorModel = utils.objectToClass(
              httpRes?.data,
              shared.ErrorModel
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Get employees with tag
   *
   * @remarks
   * Gets the employees with the tag
   */
  getEmployeesWithTag(
    req: operations.GetEmployeesWithTagRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetEmployeesWithTagResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetEmployeesWithTagRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/Employer/{EmployerId}/Employees/Tag/{TagId}",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };

    const r = client.request({
      url: url,
      method: "get",
      headers: headers,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetEmployeesWithTagResponse =
        new operations.GetEmployeesWithTagResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.linkCollection = utils.objectToClass(
              httpRes?.data,
              shared.LinkCollection
            );
          }
          break;
        case [400, 401, 404, 500].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorModel = utils.objectToClass(
              httpRes?.data,
              shared.ErrorModel
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Gets the pay runs from the employee
   *
   * @remarks
   * Get links to all pay runs for the specified employee.
   */
  getPayRunsFromEmployee(
    req: operations.GetPayRunsFromEmployeeRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetPayRunsFromEmployeeResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetPayRunsFromEmployeeRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/Employer/{EmployerId}/Employee/{EmployeeId}/PayRuns",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };

    const r = client.request({
      url: url,
      method: "get",
      headers: headers,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetPayRunsFromEmployeeResponse =
        new operations.GetPayRunsFromEmployeeResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.linkCollection = utils.objectToClass(
              httpRes?.data,
              shared.LinkCollection
            );
          }
          break;
        case [400, 401, 404, 500].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorModel = utils.objectToClass(
              httpRes?.data,
              shared.ErrorModel
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Patches the employee
   *
   * @remarks
   * Patches the specified employee with the supplied values
   */
  patchEmployee(
    req: operations.PatchEmployeeRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.PatchEmployeeResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PatchEmployeeRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/Employer/{EmployerId}/Employee/{EmployeeId}",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "employee",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._defaultClient;

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "patch",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PatchEmployeeResponse =
        new operations.PatchEmployeeResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.employee = utils.objectToClass(httpRes?.data, shared.Employee);
          }
          break;
        case [400, 401, 404, 500].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorModel = utils.objectToClass(
              httpRes?.data,
              shared.ErrorModel
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Create a new Employee
   *
   * @remarks
   * Create a new employee object
   */
  postEmployeeIntoEmployer(
    req: operations.PostEmployeeIntoEmployerRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.PostEmployeeIntoEmployerResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PostEmployeeIntoEmployerRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/Employer/{EmployerId}/Employees",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "employee",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._defaultClient;

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PostEmployeeIntoEmployerResponse =
        new operations.PostEmployeeIntoEmployerResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.link = utils.objectToClass(httpRes?.data, shared.Link);
          }
          break;
        case [400, 401, 404, 500].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorModel = utils.objectToClass(
              httpRes?.data,
              shared.ErrorModel
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Create a new employee secret
   *
   * @remarks
   * Create new employee secret using auto generated resource location key
   */
  postEmployeeSecret(
    req: operations.PostEmployeeSecretRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.PostEmployeeSecretResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PostEmployeeSecretRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/Employer/{EmployerId}/Employee/{EmployeeId}/Secrets",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PostEmployeeSecretResponse =
        new operations.PostEmployeeSecretResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.link = utils.objectToClass(httpRes?.data, shared.Link);
          }
          break;
        case [400, 401, 404, 500].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorModel = utils.objectToClass(
              httpRes?.data,
              shared.ErrorModel
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Updates the Employee
   *
   * @remarks
   * Updates the existing specified employee object
   */
  putEmployeeIntoEmployer(
    req: operations.PutEmployeeIntoEmployerRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.PutEmployeeIntoEmployerResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PutEmployeeIntoEmployerRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/Employer/{EmployerId}/Employee/{EmployeeId}",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "employee",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._defaultClient;

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "put",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PutEmployeeIntoEmployerResponse =
        new operations.PutEmployeeIntoEmployerResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.employee = utils.objectToClass(httpRes?.data, shared.Employee);
          }
          break;
        case [400, 401, 404, 500].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorModel = utils.objectToClass(
              httpRes?.data,
              shared.ErrorModel
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Create a new employee secret
   *
   * @remarks
   * Create / update an employee secret at the given resource location
   */
  putEmployeeSecret(
    req: operations.PutEmployeeSecretRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.PutEmployeeSecretResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PutEmployeeSecretRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/Employer/{EmployerId}/Employee/{EmployeeId}/Secret/{SecretId}",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };

    const r = client.request({
      url: url,
      method: "put",
      headers: headers,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PutEmployeeSecretResponse =
        new operations.PutEmployeeSecretResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.employeeSecret = utils.objectToClass(
              httpRes?.data,
              shared.EmployeeSecret
            );
          }
          break;
        case [400, 401, 404, 500].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorModel = utils.objectToClass(
              httpRes?.data,
              shared.ErrorModel
            );
          }
          break;
      }

      return res;
    });
  }
}
