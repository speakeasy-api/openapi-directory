<?php

/**
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

declare(strict_types=1);

namespace OpenAPI\OpenAPI\Models\Operations;


class CreateResolverRequestBody
{
    /**
     * The caching configuration for a resolver that has caching activated.
     * 
     * @var ?\OpenAPI\OpenAPI\Models\Operations\CreateResolverRequestBodyCachingConfig $cachingConfig
     */
	#[\JMS\Serializer\Annotation\SerializedName('cachingConfig')]
    #[\JMS\Serializer\Annotation\Type('OpenAPI\OpenAPI\Models\Operations\CreateResolverRequestBodyCachingConfig')]
    #[\JMS\Serializer\Annotation\SkipWhenEmpty]
    public ?CreateResolverRequestBodyCachingConfig $cachingConfig = null;
    
    /**
     * The <code>resolver</code> code that contains the request and response functions. When code is used, the <code>runtime</code> is required. The <code>runtime</code> value must be <code>APPSYNC_JS</code>.
     * 
     * @var ?string $code
     */
	#[\JMS\Serializer\Annotation\SerializedName('code')]
    #[\JMS\Serializer\Annotation\Type('string')]
    #[\JMS\Serializer\Annotation\SkipWhenEmpty]
    public ?string $code = null;
    
    /**
     * The name of the data source for which the resolver is being created.
     * 
     * @var ?string $dataSourceName
     */
	#[\JMS\Serializer\Annotation\SerializedName('dataSourceName')]
    #[\JMS\Serializer\Annotation\Type('string')]
    #[\JMS\Serializer\Annotation\SkipWhenEmpty]
    public ?string $dataSourceName = null;
    
    /**
     * The name of the field to attach the resolver to.
     * 
     * @var string $fieldName
     */
	#[\JMS\Serializer\Annotation\SerializedName('fieldName')]
    #[\JMS\Serializer\Annotation\Type('string')]
    public string $fieldName;
    
    /**
     * <p>The resolver type.</p> <ul> <li> <p> <b>UNIT</b>: A UNIT resolver type. A UNIT resolver is the default resolver type. You can use a UNIT resolver to run a GraphQL query against a single data source.</p> </li> <li> <p> <b>PIPELINE</b>: A PIPELINE resolver type. You can use a PIPELINE resolver to invoke a series of <code>Function</code> objects in a serial manner. You can use a pipeline resolver to run a GraphQL query against multiple data sources.</p> </li> </ul>
     * 
     * @var ?\OpenAPI\OpenAPI\Models\Operations\CreateResolverRequestBodyKindEnum $kind
     */
	#[\JMS\Serializer\Annotation\SerializedName('kind')]
    #[\JMS\Serializer\Annotation\Type('enum<OpenAPI\OpenAPI\Models\Operations\CreateResolverRequestBodyKindEnum>')]
    #[\JMS\Serializer\Annotation\SkipWhenEmpty]
    public ?CreateResolverRequestBodyKindEnum $kind = null;
    
    /**
     * The maximum batching size for a resolver.
     * 
     * @var ?int $maxBatchSize
     */
	#[\JMS\Serializer\Annotation\SerializedName('maxBatchSize')]
    #[\JMS\Serializer\Annotation\Type('int')]
    #[\JMS\Serializer\Annotation\SkipWhenEmpty]
    public ?int $maxBatchSize = null;
    
    /**
     * The pipeline configuration for a resolver of kind <code>PIPELINE</code>.
     * 
     * @var ?\OpenAPI\OpenAPI\Models\Operations\CreateResolverRequestBodyPipelineConfig $pipelineConfig
     */
	#[\JMS\Serializer\Annotation\SerializedName('pipelineConfig')]
    #[\JMS\Serializer\Annotation\Type('OpenAPI\OpenAPI\Models\Operations\CreateResolverRequestBodyPipelineConfig')]
    #[\JMS\Serializer\Annotation\SkipWhenEmpty]
    public ?CreateResolverRequestBodyPipelineConfig $pipelineConfig = null;
    
    /**
     * <p>The mapping template to use for requests.</p> <p>A resolver uses a request mapping template to convert a GraphQL expression into a format that a data source can understand. Mapping templates are written in Apache Velocity Template Language (VTL).</p> <p>VTL request mapping templates are optional when using an Lambda data source. For all other data sources, VTL request and response mapping templates are required.</p>
     * 
     * @var ?string $requestMappingTemplate
     */
	#[\JMS\Serializer\Annotation\SerializedName('requestMappingTemplate')]
    #[\JMS\Serializer\Annotation\Type('string')]
    #[\JMS\Serializer\Annotation\SkipWhenEmpty]
    public ?string $requestMappingTemplate = null;
    
    /**
     * The mapping template to use for responses from the data source.
     * 
     * @var ?string $responseMappingTemplate
     */
	#[\JMS\Serializer\Annotation\SerializedName('responseMappingTemplate')]
    #[\JMS\Serializer\Annotation\Type('string')]
    #[\JMS\Serializer\Annotation\SkipWhenEmpty]
    public ?string $responseMappingTemplate = null;
    
    /**
     * Describes a runtime used by an Amazon Web Services AppSync pipeline resolver or Amazon Web Services AppSync function. Specifies the name and version of the runtime to use. Note that if a runtime is specified, code must also be specified.
     * 
     * @var ?\OpenAPI\OpenAPI\Models\Operations\CreateResolverRequestBodyRuntime $runtime
     */
	#[\JMS\Serializer\Annotation\SerializedName('runtime')]
    #[\JMS\Serializer\Annotation\Type('OpenAPI\OpenAPI\Models\Operations\CreateResolverRequestBodyRuntime')]
    #[\JMS\Serializer\Annotation\SkipWhenEmpty]
    public ?CreateResolverRequestBodyRuntime $runtime = null;
    
    /**
     * <p>Describes a Sync configuration for a resolver.</p> <p>Specifies which Conflict Detection strategy and Resolution strategy to use when the resolver is invoked.</p>
     * 
     * @var ?\OpenAPI\OpenAPI\Models\Operations\CreateResolverRequestBodySyncConfig $syncConfig
     */
	#[\JMS\Serializer\Annotation\SerializedName('syncConfig')]
    #[\JMS\Serializer\Annotation\Type('OpenAPI\OpenAPI\Models\Operations\CreateResolverRequestBodySyncConfig')]
    #[\JMS\Serializer\Annotation\SkipWhenEmpty]
    public ?CreateResolverRequestBodySyncConfig $syncConfig = null;
    
	public function __construct()
	{
		$this->cachingConfig = null;
		$this->code = null;
		$this->dataSourceName = null;
		$this->fieldName = "";
		$this->kind = null;
		$this->maxBatchSize = null;
		$this->pipelineConfig = null;
		$this->requestMappingTemplate = null;
		$this->responseMappingTemplate = null;
		$this->runtime = null;
		$this->syncConfig = null;
	}
}
