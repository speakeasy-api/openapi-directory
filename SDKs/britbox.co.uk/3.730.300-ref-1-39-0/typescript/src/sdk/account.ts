/*
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

import * as utils from "../internal/utils";
import * as operations from "./models/operations";
import * as shared from "./models/shared";
import { AxiosInstance, AxiosRequestConfig, AxiosResponse } from "axios";

export class Account {
  _defaultClient: AxiosInstance;
  _securityClient: AxiosInstance;
  _serverURL: string;
  _language: string;
  _sdkVersion: string;
  _genVersion: string;

  constructor(
    defaultClient: AxiosInstance,
    securityClient: AxiosInstance,
    serverURL: string,
    language: string,
    sdkVersion: string,
    genVersion: string
  ) {
    this._defaultClient = defaultClient;
    this._securityClient = securityClient;
    this._serverURL = serverURL;
    this._language = language;
    this._sdkVersion = sdkVersion;
    this._genVersion = genVersion;
  }

  /**
   * Add a new payment method to an account.
   */
  addPaymentMethod(
    req: operations.AddPaymentMethodRequest,
    security: operations.AddPaymentMethodSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.AddPaymentMethodResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.AddPaymentMethodRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/account/billing/methods";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "addPaymentMethodRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.AddPaymentMethodSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url + queryParams,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.AddPaymentMethodResponse =
        new operations.AddPaymentMethodResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.paymentMethod = utils.objectToClass(
              httpRes?.data,
              shared.PaymentMethod
            );
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.serviceError = utils.objectToClass(
              httpRes?.data,
              shared.ServiceError
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Authorize a device from a generated device authorization code.
   *
   * This is the second step in the process of authorizing a device by pin code.
   *
   * Firstly the device must request a generated authorization code via the
   * `/authorization/device/code` endpoint.
   *
   * This endpoint then authorizes the device associated with the code to sign in
   * to a user account. Typically this endpoint will be called from a page
   * presented in the web app under the account section.
   *
   * Once authorized, the device will then be able to sign in to that account
   * via the `/authorization/device` endpoint, without needing to provide the
   * credentials of the user.
   *
   */
  authorizeDevice(
    req: operations.AuthorizeDeviceRequest,
    security: operations.AuthorizeDeviceSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.AuthorizeDeviceResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.AuthorizeDeviceRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/account/devices/authorization";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "deviceAuthorizationCode",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.AuthorizeDeviceSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url + queryParams,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.AuthorizeDeviceResponse =
        new operations.AuthorizeDeviceResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.serviceError = utils.objectToClass(
              httpRes?.data,
              shared.ServiceError
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Cancel a plan subscription.
   *
   * A cancelled subscription will continue to be valid until the subscription
   * expiry date or next renewal date.
   *
   */
  cancelSubscription(
    req: operations.CancelSubscriptionRequest,
    security: operations.CancelSubscriptionSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.CancelSubscriptionResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CancelSubscriptionRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/account/billing/subscriptions/{id}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.CancelSubscriptionSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CancelSubscriptionResponse =
        new operations.CancelSubscriptionResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.serviceError = utils.objectToClass(
              httpRes?.data,
              shared.ServiceError
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Change the password of an account.
   *
   * The expected token scope is Settings.
   *
   */
  changePassword(
    req: operations.ChangePasswordRequest,
    security: operations.ChangePasswordSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.ChangePasswordResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ChangePasswordRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/account/password";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "changePasswordRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ChangePasswordSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url + queryParams,
      method: "put",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ChangePasswordResponse =
        new operations.ChangePasswordResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.serviceError = utils.objectToClass(
              httpRes?.data,
              shared.ServiceError
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Change the pin of an account.
   */
  changePin(
    req: operations.ChangePinRequest,
    security: operations.ChangePinSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.ChangePinResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ChangePinRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/account/pin";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "changePinRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ChangePinSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url + queryParams,
      method: "put",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ChangePinResponse =
        new operations.ChangePinResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.serviceError = utils.objectToClass(
              httpRes?.data,
              shared.ServiceError
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Create a new profile under the active account.
   */
  createProfile(
    req: operations.CreateProfileRequest,
    security: operations.CreateProfileSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.CreateProfileResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CreateProfileRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/account/profiles";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "profileCreationRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.CreateProfileSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url + queryParams,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CreateProfileResponse =
        new operations.CreateProfileResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.profileDetail = utils.objectToClass(
              httpRes?.data,
              shared.ProfileDetail
            );
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.serviceError = utils.objectToClass(
              httpRes?.data,
              shared.ServiceError
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Delete a profile with a specific id under the active account.
   *
   * Note that you cannot delete the primary profile.
   *
   */
  deleteProfileWithId(
    req: operations.DeleteProfileWithIdRequest,
    security: operations.DeleteProfileWithIdSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.DeleteProfileWithIdResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DeleteProfileWithIdRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/account/profiles/{id}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.DeleteProfileWithIdSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DeleteProfileWithIdResponse =
        new operations.DeleteProfileWithIdResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.serviceError = utils.objectToClass(
              httpRes?.data,
              shared.ServiceError
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Deregister a playback device from an account.
   */
  deregisterDevice(
    req: operations.DeregisterDeviceRequest,
    security: operations.DeregisterDeviceSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.DeregisterDeviceResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DeregisterDeviceRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/account/devices/{id}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.DeregisterDeviceSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DeregisterDeviceResponse =
        new operations.DeregisterDeviceResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.serviceError = utils.objectToClass(
              httpRes?.data,
              shared.ServiceError
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Generate a new account nonce.
   *
   * A nonce may be required to help sign a response from a third party
   * service which will be passed back to these services.
   *
   * For example a Facebook single-sign-on request initiated by a client
   * application may first get a nonce from here to include in the request.
   * Facebook will then include the nonce in the auth token it issues. This
   * token can be passed back to our services and the nonce checked for validity.
   *
   */
  generateNonce(
    req: operations.GenerateNonceRequest,
    security: operations.GenerateNonceSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.GenerateNonceResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GenerateNonceRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/account/nonce";
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.GenerateNonceSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GenerateNonceResponse =
        new operations.GenerateNonceResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.accountNonce = utils.objectToClass(
              httpRes?.data,
              shared.AccountNonce
            );
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.serviceError = utils.objectToClass(
              httpRes?.data,
              shared.ServiceError
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Get the details of an account along with the profiles and entitlements under it.
   */
  getAccount(
    req: operations.GetAccountRequest,
    security: operations.GetAccountSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.GetAccountResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetAccountRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/account";
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.GetAccountSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetAccountResponse =
        new operations.GetAccountResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.account = utils.objectToClass(httpRes?.data);
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.serviceError = utils.objectToClass(
              httpRes?.data,
              shared.ServiceError
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Get a registered device.
   */
  getDevice(
    req: operations.GetDeviceRequest,
    security: operations.GetDeviceSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.GetDeviceResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetDeviceRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/account/devices/{id}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.GetDeviceSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetDeviceResponse =
        new operations.GetDeviceResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.device = utils.objectToClass(httpRes?.data, shared.Device);
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.serviceError = utils.objectToClass(
              httpRes?.data,
              shared.ServiceError
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Get all devices registered under this account.
   *
   * Also includes information around device registration and deregistration limits.
   *
   */
  getDevices(
    req: operations.GetDevicesRequest,
    security: operations.GetDevicesSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.GetDevicesResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetDevicesRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/account/devices";
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.GetDevicesSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetDevicesResponse =
        new operations.GetDevicesResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.accountDevices = utils.objectToClass(
              httpRes?.data,
              shared.AccountDevices
            );
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.serviceError = utils.objectToClass(
              httpRes?.data,
              shared.ServiceError
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Get all entitlements under the account.
   *
   * This list is returned under the call to get account information so a call here is
   * only required when wishing to refresh a local copy of entitlements.
   *
   */
  getEntitlements(
    req: operations.GetEntitlementsRequest,
    security: operations.GetEntitlementsSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.GetEntitlementsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetEntitlementsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/account/entitlements";
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.GetEntitlementsSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetEntitlementsResponse =
        new operations.GetEntitlementsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.entitlements = [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.entitlements = utils.objectToClass(
              httpRes?.data,
              shared.Entitlement,
              resFieldDepth
            );
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.serviceError = utils.objectToClass(
              httpRes?.data,
              shared.ServiceError
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Get the video files associated with an item given maximum resolution, device type
   * and one or more delivery types.
   *
   * This endpoint accepts an Account Catalog token, however if when requesting
   * playback files you receive an *403 status code with error code 1* then the file
   * you're requesting is classification restricted. This means you should switch
   * to target the `/account/items/{id}/videos-guarded` endpoint, passing it an Account
   * Playback token. If not already obtained, this token can be requested via the
   * `/itv/pinauthorization` endpoint with an account level pin.
   *
   * For convenience you may also access free / public files through this endpoint
   * instead of the /items/{id}/videos endpoint, when authenticated.
   *
   * Returns an array of video file objects which each include a url to a video.
   *
   * The first entry in the array contains what is predicted to be the best match.
   * The remainder of the entries, if any, may contain resolutions below what was
   * requests. For example if you request HD-720 the response may also contain
   * SD entries.
   *
   * If you specify multiple delivery types, then the response array will insert
   * types in the order you specify them in the query. For example `stream,progressive`
   * would return an array with 0 or more stream files followed by 0 or more progressive files.
   *
   * If no files are found a 404 is returned.
   *
   */
  getItemMediaFiles(
    req: operations.GetItemMediaFilesRequest,
    security: operations.GetItemMediaFilesSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.GetItemMediaFilesResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetItemMediaFilesRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/account/items/{id}/videos",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.GetItemMediaFilesSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetItemMediaFilesResponse =
        new operations.GetItemMediaFilesResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.mediaFiles = [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.mediaFiles = utils.objectToClass(
              httpRes?.data,
              shared.MediaFile,
              resFieldDepth
            );
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.serviceError = utils.objectToClass(
              httpRes?.data,
              shared.ServiceError
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Get the video files associated with an item given maximum resolution, device type
   * and one or more delivery types.
   *
   * This endpoint is identical to the `/account/items/{id}/videos` however it expects
   * an Account Playback token. This token, and in association this endpoint, is specifically
   * for use when playback files are classification restricted and require an account
   * level pin to access them.
   *
   * Returns an array of video file objects which each include a url to a video.
   *
   * The first entry in the array contains what is predicted to be the best match.
   * The remainder of the entries, if any, may contain resolutions below what was
   * requests. For example if you request HD-720 the response may also contain
   * SD entries.
   *
   * If you specify multiple delivery types, then the response array will insert
   * types in the order you specify them in the query. For example `stream,progressive`
   * would return an array with 0 or more stream files followed by 0 or more progressive files.
   *
   * If no files are found a 404 is returned.
   *
   */
  getItemMediaFilesGuarded(
    req: operations.GetItemMediaFilesGuardedRequest,
    security: operations.GetItemMediaFilesGuardedSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.GetItemMediaFilesGuardedResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetItemMediaFilesGuardedRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/account/items/{id}/videos-guarded",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.GetItemMediaFilesGuardedSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetItemMediaFilesGuardedResponse =
        new operations.GetItemMediaFilesGuardedResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.mediaFiles = [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.mediaFiles = utils.objectToClass(
              httpRes?.data,
              shared.MediaFile,
              resFieldDepth
            );
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.serviceError = utils.objectToClass(
              httpRes?.data,
              shared.ServiceError
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Get a payment method under an account.
   */
  getPaymentMethod(
    req: operations.GetPaymentMethodRequest,
    security: operations.GetPaymentMethodSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.GetPaymentMethodResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetPaymentMethodRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/account/billing/methods/{id}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.GetPaymentMethodSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetPaymentMethodResponse =
        new operations.GetPaymentMethodResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.paymentMethod = utils.objectToClass(
              httpRes?.data,
              shared.PaymentMethod
            );
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.serviceError = utils.objectToClass(
              httpRes?.data,
              shared.ServiceError
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Get the available payment methods under an account.
   */
  getPaymentMethods(
    req: operations.GetPaymentMethodsRequest,
    security: operations.GetPaymentMethodsSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.GetPaymentMethodsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetPaymentMethodsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/account/billing/methods";
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.GetPaymentMethodsSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetPaymentMethodsResponse =
        new operations.GetPaymentMethodsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.paymentMethods = [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.paymentMethods = utils.objectToClass(
              httpRes?.data,
              shared.PaymentMethod,
              resFieldDepth
            );
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.serviceError = utils.objectToClass(
              httpRes?.data,
              shared.ServiceError
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Get the summary of a profile with a specific id under the active account.
   */
  getProfileWithId(
    req: operations.GetProfileWithIdRequest,
    security: operations.GetProfileWithIdSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.GetProfileWithIdResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetProfileWithIdRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/account/profiles/{id}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.GetProfileWithIdSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetProfileWithIdResponse =
        new operations.GetProfileWithIdResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.profileSummary = utils.objectToClass(
              httpRes?.data,
              shared.ProfileSummary
            );
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.serviceError = utils.objectToClass(
              httpRes?.data,
              shared.ServiceError
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Get a list of all purchases made under an account.
   */
  getPurchases(
    req: operations.GetPurchasesRequest,
    security: operations.GetPurchasesSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.GetPurchasesResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetPurchasesRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/account/billing/purchases";
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.GetPurchasesSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetPurchasesResponse =
        new operations.GetPurchasesResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.purchases = [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.purchases = utils.objectToClass(
              httpRes?.data,
              shared.Purchase,
              resFieldDepth
            );
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.serviceError = utils.objectToClass(
              httpRes?.data,
              shared.ServiceError
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Purchase a plan or item offer.
   * The result of a successful transaction is a new entitlement.
   *
   */
  makePurchase(
    req: operations.MakePurchaseRequest,
    security: operations.MakePurchaseSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.MakePurchaseResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.MakePurchaseRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/account/billing/purchases";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "purchaseRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.MakePurchaseSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url + queryParams,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.MakePurchaseResponse =
        new operations.MakePurchaseResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.entitlement = utils.objectToClass(
              httpRes?.data,
              shared.Entitlement
            );
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.serviceError = utils.objectToClass(
              httpRes?.data,
              shared.ServiceError
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Register a playback device under an account.
   *
   * If a device with the same id already exists a `409` conflict will be returned.
   *
   */
  registerDevice(
    req: operations.RegisterDeviceRequest,
    security: operations.RegisterDeviceSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.RegisterDeviceResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.RegisterDeviceRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/account/devices";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "deviceRegistrationRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.RegisterDeviceSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url + queryParams,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.RegisterDeviceResponse =
        new operations.RegisterDeviceResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.device = utils.objectToClass(httpRes?.data, shared.Device);
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.serviceError = utils.objectToClass(
              httpRes?.data,
              shared.ServiceError
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Remove a payment method from an account.
   */
  removePaymentMethod(
    req: operations.RemovePaymentMethodRequest,
    security: operations.RemovePaymentMethodSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.RemovePaymentMethodResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.RemovePaymentMethodRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/account/billing/methods/{id}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.RemovePaymentMethodSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.RemovePaymentMethodResponse =
        new operations.RemovePaymentMethodResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.serviceError = utils.objectToClass(
              httpRes?.data,
              shared.ServiceError
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Rename a device
   */
  renameDevice(
    req: operations.RenameDeviceRequest,
    security: operations.RenameDeviceSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.RenameDeviceResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.RenameDeviceRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/account/devices/{id}/name",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.RenameDeviceSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "put",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.RenameDeviceResponse =
        new operations.RenameDeviceResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.serviceError = utils.objectToClass(
              httpRes?.data,
              shared.ServiceError
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Request that the email address tied to an account be verified.
   *
   * This will send a verification email to the email address of the primary profile containing
   * a link which, once clicked, completes the verification process via the /verify-email endpoint.
   *
   * Note that when an account is created this email is sent automatically so there's no need
   * to call this directly.
   *
   * If the user doesn't click the link before it expires then this endpoint can be called
   * to request a new verification email. In the future it may also be used if we add support
   * for changing an account email address.
   *
   */
  requestEmailVerification(
    req: operations.RequestEmailVerificationRequest,
    security: operations.RequestEmailVerificationSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.RequestEmailVerificationResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.RequestEmailVerificationRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/account/request-email-verification";
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.RequestEmailVerificationSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "post",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.RequestEmailVerificationResponse =
        new operations.RequestEmailVerificationResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.serviceError = utils.objectToClass(
              httpRes?.data,
              shared.ServiceError
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Update the details of an account.
   *
   * With the exception of the address, this supports partial updates, so you can send just the
   * properties you wish to update.
   *
   * When the address is provided any properties which are omitted from the address will be cleared.
   *
   */
  updateAccount(
    req: operations.UpdateAccountRequest,
    security: operations.UpdateAccountSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.UpdateAccountResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.UpdateAccountRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/account";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "accountUpdateRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.UpdateAccountSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url + queryParams,
      method: "patch",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UpdateAccountResponse =
        new operations.UpdateAccountResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.serviceError = utils.objectToClass(
              httpRes?.data,
              shared.ServiceError
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Update the summary of a profile with a specific id under the active account.
   *
   * This supports partial updates so you can send just the properties you wish to update.
   *
   */
  updateProfileWithId(
    req: operations.UpdateProfileWithIdRequest,
    security: operations.UpdateProfileWithIdSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.UpdateProfileWithIdResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.UpdateProfileWithIdRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/account/profiles/{id}",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "profileUpdateRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.UpdateProfileWithIdSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url + queryParams,
      method: "patch",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UpdateProfileWithIdResponse =
        new operations.UpdateProfileWithIdResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.serviceError = utils.objectToClass(
              httpRes?.data,
              shared.ServiceError
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Renew a cancelled subscription or switch subscription to a different plan.
   *
   * When renewing a cancelled subscription membership, hit this endpoint with
   * the id of subscription to renew.
   *
   * To switch plans provide the id of the current active subscription membership
   * of the account, and in the query specify the id of the plan to switch to.
   *
   */
  updateSubscription(
    req: operations.UpdateSubscriptionRequest,
    security: operations.UpdateSubscriptionSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.UpdateSubscriptionResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.UpdateSubscriptionRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/account/billing/subscriptions/{id}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.UpdateSubscriptionSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "put",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UpdateSubscriptionResponse =
        new operations.UpdateSubscriptionResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.serviceError = utils.objectToClass(
              httpRes?.data,
              shared.ServiceError
            );
          }
          break;
      }

      return res;
    });
  }
}
