"""Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT."""

import requests as requests_http
from . import utils
from sdk.models import operations, shared
from typing import Optional

SERVERS = [
    "https://numbers.twilio.com",
]
"""Contains the list of servers available to the SDK"""

class SDK:
    r"""This is the public Twilio REST API."""

    _client: requests_http.Session
    _security_client: requests_http.Session
    _server_url: str = SERVERS[0]
    _language: str = "python"
    _sdk_version: str = "0.0.1"
    _gen_version: str = "internal"

    def __init__(self,
                 server_url: str = None,
                 url_params: dict[str, str] = None,
                 client: requests_http.Session = None
                 ) -> None:
        """Instantiates the SDK configuring it with the provided parameters.
        
        :param server_url: The server URL to use for all operations
        :type server_url: str
        :param url_params: Parameters to optionally template the server URL with
        :type url_params: dict[str, str]
        :param client: The requests.Session HTTP client to use for all operations
        :type client: requests_http.Session        
        """
        self._client = requests_http.Session()
        
        
        if server_url is not None:
            if url_params is not None:
                self._server_url = utils.template_url(server_url, url_params)
            else:
                self._server_url = server_url

        if client is not None:
            self._client = client
        
        self._security_client = self._client
        

        
    
    
    def create_bundle(self, request: operations.CreateBundleCreateBundleRequest, security: operations.CreateBundleSecurity, server_url: Optional[str] = None) -> operations.CreateBundleResponse:
        r"""Create a new Bundle."""
        base_url = operations.CREATE_BUNDLE_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = base_url.removesuffix('/') + '/v2/RegulatoryCompliance/Bundles'
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request", 'form')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.CreateBundleResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 201:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.NumbersV2RegulatoryComplianceBundle])
                res.numbers_v2_regulatory_compliance_bundle = out

        return res

    def create_bundle_copy(self, request: operations.CreateBundleCopyRequest, security: operations.CreateBundleCopySecurity, server_url: Optional[str] = None) -> operations.CreateBundleCopyResponse:
        r"""Creates a new copy of a Bundle. It will internally create copies of all the bundle items (identities and documents) of the original bundle"""
        base_url = operations.CREATE_BUNDLE_COPY_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.CreateBundleCopyRequest, base_url, '/v2/RegulatoryCompliance/Bundles/{BundleSid}/Copies', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'form')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.CreateBundleCopyResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 201:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.NumbersV2RegulatoryComplianceBundleBundleCopy])
                res.numbers_v2_regulatory_compliance_bundle_bundle_copy = out

        return res

    def create_end_user(self, request: operations.CreateEndUserCreateEndUserRequest, security: operations.CreateEndUserSecurity, server_url: Optional[str] = None) -> operations.CreateEndUserResponse:
        r"""Create a new End User."""
        base_url = operations.CREATE_END_USER_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = base_url.removesuffix('/') + '/v2/RegulatoryCompliance/EndUsers'
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request", 'form')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.CreateEndUserResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 201:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.NumbersV2RegulatoryComplianceEndUser])
                res.numbers_v2_regulatory_compliance_end_user = out

        return res

    def create_evaluation(self, request: operations.CreateEvaluationRequest, security: operations.CreateEvaluationSecurity, server_url: Optional[str] = None) -> operations.CreateEvaluationResponse:
        r"""Creates an evaluation for a bundle"""
        base_url = operations.CREATE_EVALUATION_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.CreateEvaluationRequest, base_url, '/v2/RegulatoryCompliance/Bundles/{BundleSid}/Evaluations', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.CreateEvaluationResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 201:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.NumbersV2RegulatoryComplianceBundleEvaluation])
                res.numbers_v2_regulatory_compliance_bundle_evaluation = out

        return res

    def create_item_assignment(self, request: operations.CreateItemAssignmentRequest, security: operations.CreateItemAssignmentSecurity, server_url: Optional[str] = None) -> operations.CreateItemAssignmentResponse:
        r"""Create a new Assigned Item."""
        base_url = operations.CREATE_ITEM_ASSIGNMENT_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.CreateItemAssignmentRequest, base_url, '/v2/RegulatoryCompliance/Bundles/{BundleSid}/ItemAssignments', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'form')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.CreateItemAssignmentResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 201:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.NumbersV2RegulatoryComplianceBundleItemAssignment])
                res.numbers_v2_regulatory_compliance_bundle_item_assignment = out

        return res

    def create_replace_items(self, request: operations.CreateReplaceItemsRequest, security: operations.CreateReplaceItemsSecurity, server_url: Optional[str] = None) -> operations.CreateReplaceItemsResponse:
        r"""Replaces all bundle items in the target bundle (specified in the path) with all the bundle items of the source bundle (specified by the from_bundle_sid body param)"""
        base_url = operations.CREATE_REPLACE_ITEMS_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.CreateReplaceItemsRequest, base_url, '/v2/RegulatoryCompliance/Bundles/{BundleSid}/ReplaceItems', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'form')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.CreateReplaceItemsResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 201:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.NumbersV2RegulatoryComplianceBundleReplaceItems])
                res.numbers_v2_regulatory_compliance_bundle_replace_items = out

        return res

    def create_supporting_document(self, request: operations.CreateSupportingDocumentCreateSupportingDocumentRequest, security: operations.CreateSupportingDocumentSecurity, server_url: Optional[str] = None) -> operations.CreateSupportingDocumentResponse:
        r"""Create a new Supporting Document."""
        base_url = operations.CREATE_SUPPORTING_DOCUMENT_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = base_url.removesuffix('/') + '/v2/RegulatoryCompliance/SupportingDocuments'
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request", 'form')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.CreateSupportingDocumentResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 201:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.NumbersV2RegulatoryComplianceSupportingDocument])
                res.numbers_v2_regulatory_compliance_supporting_document = out

        return res

    def delete_bundle(self, request: operations.DeleteBundleRequest, security: operations.DeleteBundleSecurity, server_url: Optional[str] = None) -> operations.DeleteBundleResponse:
        r"""Delete a specific Bundle."""
        base_url = operations.DELETE_BUNDLE_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.DeleteBundleRequest, base_url, '/v2/RegulatoryCompliance/Bundles/{Sid}', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('DELETE', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DeleteBundleResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        

        return res

    def delete_end_user(self, request: operations.DeleteEndUserRequest, security: operations.DeleteEndUserSecurity, server_url: Optional[str] = None) -> operations.DeleteEndUserResponse:
        r"""Delete a specific End User."""
        base_url = operations.DELETE_END_USER_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.DeleteEndUserRequest, base_url, '/v2/RegulatoryCompliance/EndUsers/{Sid}', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('DELETE', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DeleteEndUserResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        

        return res

    def delete_item_assignment(self, request: operations.DeleteItemAssignmentRequest, security: operations.DeleteItemAssignmentSecurity, server_url: Optional[str] = None) -> operations.DeleteItemAssignmentResponse:
        r"""Remove an Assignment Item Instance."""
        base_url = operations.DELETE_ITEM_ASSIGNMENT_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.DeleteItemAssignmentRequest, base_url, '/v2/RegulatoryCompliance/Bundles/{BundleSid}/ItemAssignments/{Sid}', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('DELETE', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DeleteItemAssignmentResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        

        return res

    def delete_supporting_document(self, request: operations.DeleteSupportingDocumentRequest, security: operations.DeleteSupportingDocumentSecurity, server_url: Optional[str] = None) -> operations.DeleteSupportingDocumentResponse:
        r"""Delete a specific Supporting Document."""
        base_url = operations.DELETE_SUPPORTING_DOCUMENT_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.DeleteSupportingDocumentRequest, base_url, '/v2/RegulatoryCompliance/SupportingDocuments/{Sid}', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('DELETE', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DeleteSupportingDocumentResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        

        return res

    def fetch_bundle(self, request: operations.FetchBundleRequest, security: operations.FetchBundleSecurity, server_url: Optional[str] = None) -> operations.FetchBundleResponse:
        r"""Fetch a specific Bundle instance."""
        base_url = operations.FETCH_BUNDLE_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.FetchBundleRequest, base_url, '/v2/RegulatoryCompliance/Bundles/{Sid}', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.FetchBundleResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.NumbersV2RegulatoryComplianceBundle])
                res.numbers_v2_regulatory_compliance_bundle = out

        return res

    def fetch_end_user(self, request: operations.FetchEndUserRequest, security: operations.FetchEndUserSecurity, server_url: Optional[str] = None) -> operations.FetchEndUserResponse:
        r"""Fetch specific End User Instance."""
        base_url = operations.FETCH_END_USER_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.FetchEndUserRequest, base_url, '/v2/RegulatoryCompliance/EndUsers/{Sid}', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.FetchEndUserResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.NumbersV2RegulatoryComplianceEndUser])
                res.numbers_v2_regulatory_compliance_end_user = out

        return res

    def fetch_end_user_type(self, request: operations.FetchEndUserTypeRequest, security: operations.FetchEndUserTypeSecurity, server_url: Optional[str] = None) -> operations.FetchEndUserTypeResponse:
        r"""Fetch a specific End-User Type Instance."""
        base_url = operations.FETCH_END_USER_TYPE_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.FetchEndUserTypeRequest, base_url, '/v2/RegulatoryCompliance/EndUserTypes/{Sid}', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.FetchEndUserTypeResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.NumbersV2RegulatoryComplianceEndUserType])
                res.numbers_v2_regulatory_compliance_end_user_type = out

        return res

    def fetch_evaluation(self, request: operations.FetchEvaluationRequest, security: operations.FetchEvaluationSecurity, server_url: Optional[str] = None) -> operations.FetchEvaluationResponse:
        r"""Fetch specific Evaluation Instance."""
        base_url = operations.FETCH_EVALUATION_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.FetchEvaluationRequest, base_url, '/v2/RegulatoryCompliance/Bundles/{BundleSid}/Evaluations/{Sid}', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.FetchEvaluationResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.NumbersV2RegulatoryComplianceBundleEvaluation])
                res.numbers_v2_regulatory_compliance_bundle_evaluation = out

        return res

    def fetch_item_assignment(self, request: operations.FetchItemAssignmentRequest, security: operations.FetchItemAssignmentSecurity, server_url: Optional[str] = None) -> operations.FetchItemAssignmentResponse:
        r"""Fetch specific Assigned Item Instance."""
        base_url = operations.FETCH_ITEM_ASSIGNMENT_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.FetchItemAssignmentRequest, base_url, '/v2/RegulatoryCompliance/Bundles/{BundleSid}/ItemAssignments/{Sid}', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.FetchItemAssignmentResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.NumbersV2RegulatoryComplianceBundleItemAssignment])
                res.numbers_v2_regulatory_compliance_bundle_item_assignment = out

        return res

    def fetch_regulation(self, request: operations.FetchRegulationRequest, security: operations.FetchRegulationSecurity, server_url: Optional[str] = None) -> operations.FetchRegulationResponse:
        r"""Fetch specific Regulation Instance."""
        base_url = operations.FETCH_REGULATION_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.FetchRegulationRequest, base_url, '/v2/RegulatoryCompliance/Regulations/{Sid}', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.FetchRegulationResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.NumbersV2RegulatoryComplianceRegulation])
                res.numbers_v2_regulatory_compliance_regulation = out

        return res

    def fetch_supporting_document(self, request: operations.FetchSupportingDocumentRequest, security: operations.FetchSupportingDocumentSecurity, server_url: Optional[str] = None) -> operations.FetchSupportingDocumentResponse:
        r"""Fetch specific Supporting Document Instance."""
        base_url = operations.FETCH_SUPPORTING_DOCUMENT_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.FetchSupportingDocumentRequest, base_url, '/v2/RegulatoryCompliance/SupportingDocuments/{Sid}', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.FetchSupportingDocumentResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.NumbersV2RegulatoryComplianceSupportingDocument])
                res.numbers_v2_regulatory_compliance_supporting_document = out

        return res

    def fetch_supporting_document_type(self, request: operations.FetchSupportingDocumentTypeRequest, security: operations.FetchSupportingDocumentTypeSecurity, server_url: Optional[str] = None) -> operations.FetchSupportingDocumentTypeResponse:
        r"""Fetch a specific Supporting Document Type Instance."""
        base_url = operations.FETCH_SUPPORTING_DOCUMENT_TYPE_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.FetchSupportingDocumentTypeRequest, base_url, '/v2/RegulatoryCompliance/SupportingDocumentTypes/{Sid}', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.FetchSupportingDocumentTypeResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.NumbersV2RegulatoryComplianceSupportingDocumentType])
                res.numbers_v2_regulatory_compliance_supporting_document_type = out

        return res

    def list_bundle(self, request: operations.ListBundleRequest, security: operations.ListBundleSecurity, server_url: Optional[str] = None) -> operations.ListBundleResponse:
        r"""Retrieve a list of all Bundles for an account."""
        base_url = operations.LIST_BUNDLE_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = base_url.removesuffix('/') + '/v2/RegulatoryCompliance/Bundles'
        
        query_params = utils.get_query_params(operations.ListBundleRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ListBundleResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.ListBundleListBundleResponse])
                res.list_bundle_response = out

        return res

    def list_bundle_copy(self, request: operations.ListBundleCopyRequest, security: operations.ListBundleCopySecurity, server_url: Optional[str] = None) -> operations.ListBundleCopyResponse:
        r"""Retrieve a list of all Bundles Copies for a Bundle."""
        base_url = operations.LIST_BUNDLE_COPY_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.ListBundleCopyRequest, base_url, '/v2/RegulatoryCompliance/Bundles/{BundleSid}/Copies', request)
        
        query_params = utils.get_query_params(operations.ListBundleCopyRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ListBundleCopyResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.ListBundleCopyListBundleCopyResponse])
                res.list_bundle_copy_response = out

        return res

    def list_end_user(self, request: operations.ListEndUserRequest, security: operations.ListEndUserSecurity, server_url: Optional[str] = None) -> operations.ListEndUserResponse:
        r"""Retrieve a list of all End User for an account."""
        base_url = operations.LIST_END_USER_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = base_url.removesuffix('/') + '/v2/RegulatoryCompliance/EndUsers'
        
        query_params = utils.get_query_params(operations.ListEndUserRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ListEndUserResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.ListEndUserListEndUserResponse])
                res.list_end_user_response = out

        return res

    def list_end_user_type(self, request: operations.ListEndUserTypeRequest, security: operations.ListEndUserTypeSecurity, server_url: Optional[str] = None) -> operations.ListEndUserTypeResponse:
        r"""Retrieve a list of all End-User Types."""
        base_url = operations.LIST_END_USER_TYPE_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = base_url.removesuffix('/') + '/v2/RegulatoryCompliance/EndUserTypes'
        
        query_params = utils.get_query_params(operations.ListEndUserTypeRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ListEndUserTypeResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.ListEndUserTypeListEndUserTypeResponse])
                res.list_end_user_type_response = out

        return res

    def list_evaluation(self, request: operations.ListEvaluationRequest, security: operations.ListEvaluationSecurity, server_url: Optional[str] = None) -> operations.ListEvaluationResponse:
        r"""Retrieve a list of Evaluations associated to the Bundle resource."""
        base_url = operations.LIST_EVALUATION_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.ListEvaluationRequest, base_url, '/v2/RegulatoryCompliance/Bundles/{BundleSid}/Evaluations', request)
        
        query_params = utils.get_query_params(operations.ListEvaluationRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ListEvaluationResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.ListEvaluationListEvaluationResponse])
                res.list_evaluation_response = out

        return res

    def list_item_assignment(self, request: operations.ListItemAssignmentRequest, security: operations.ListItemAssignmentSecurity, server_url: Optional[str] = None) -> operations.ListItemAssignmentResponse:
        r"""Retrieve a list of all Assigned Items for an account."""
        base_url = operations.LIST_ITEM_ASSIGNMENT_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.ListItemAssignmentRequest, base_url, '/v2/RegulatoryCompliance/Bundles/{BundleSid}/ItemAssignments', request)
        
        query_params = utils.get_query_params(operations.ListItemAssignmentRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ListItemAssignmentResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.ListItemAssignmentListItemAssignmentResponse])
                res.list_item_assignment_response = out

        return res

    def list_regulation(self, request: operations.ListRegulationRequest, security: operations.ListRegulationSecurity, server_url: Optional[str] = None) -> operations.ListRegulationResponse:
        r"""Retrieve a list of all Regulations."""
        base_url = operations.LIST_REGULATION_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = base_url.removesuffix('/') + '/v2/RegulatoryCompliance/Regulations'
        
        query_params = utils.get_query_params(operations.ListRegulationRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ListRegulationResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.ListRegulationListRegulationResponse])
                res.list_regulation_response = out

        return res

    def list_supporting_document(self, request: operations.ListSupportingDocumentRequest, security: operations.ListSupportingDocumentSecurity, server_url: Optional[str] = None) -> operations.ListSupportingDocumentResponse:
        r"""Retrieve a list of all Supporting Document for an account."""
        base_url = operations.LIST_SUPPORTING_DOCUMENT_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = base_url.removesuffix('/') + '/v2/RegulatoryCompliance/SupportingDocuments'
        
        query_params = utils.get_query_params(operations.ListSupportingDocumentRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ListSupportingDocumentResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.ListSupportingDocumentListSupportingDocumentResponse])
                res.list_supporting_document_response = out

        return res

    def list_supporting_document_type(self, request: operations.ListSupportingDocumentTypeRequest, security: operations.ListSupportingDocumentTypeSecurity, server_url: Optional[str] = None) -> operations.ListSupportingDocumentTypeResponse:
        r"""Retrieve a list of all Supporting Document Types."""
        base_url = operations.LIST_SUPPORTING_DOCUMENT_TYPE_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = base_url.removesuffix('/') + '/v2/RegulatoryCompliance/SupportingDocumentTypes'
        
        query_params = utils.get_query_params(operations.ListSupportingDocumentTypeRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ListSupportingDocumentTypeResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.ListSupportingDocumentTypeListSupportingDocumentTypeResponse])
                res.list_supporting_document_type_response = out

        return res

    def update_bundle(self, request: operations.UpdateBundleRequest, security: operations.UpdateBundleSecurity, server_url: Optional[str] = None) -> operations.UpdateBundleResponse:
        r"""Updates a Bundle in an account."""
        base_url = operations.UPDATE_BUNDLE_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.UpdateBundleRequest, base_url, '/v2/RegulatoryCompliance/Bundles/{Sid}', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'form')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.UpdateBundleResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.NumbersV2RegulatoryComplianceBundle])
                res.numbers_v2_regulatory_compliance_bundle = out

        return res

    def update_end_user(self, request: operations.UpdateEndUserRequest, security: operations.UpdateEndUserSecurity, server_url: Optional[str] = None) -> operations.UpdateEndUserResponse:
        r"""Update an existing End User."""
        base_url = operations.UPDATE_END_USER_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.UpdateEndUserRequest, base_url, '/v2/RegulatoryCompliance/EndUsers/{Sid}', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'form')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.UpdateEndUserResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.NumbersV2RegulatoryComplianceEndUser])
                res.numbers_v2_regulatory_compliance_end_user = out

        return res

    def update_supporting_document(self, request: operations.UpdateSupportingDocumentRequest, security: operations.UpdateSupportingDocumentSecurity, server_url: Optional[str] = None) -> operations.UpdateSupportingDocumentResponse:
        r"""Update an existing Supporting Document."""
        base_url = operations.UPDATE_SUPPORTING_DOCUMENT_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.UpdateSupportingDocumentRequest, base_url, '/v2/RegulatoryCompliance/SupportingDocuments/{Sid}', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'form')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.UpdateSupportingDocumentResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.NumbersV2RegulatoryComplianceSupportingDocument])
                res.numbers_v2_regulatory_compliance_supporting_document = out

        return res

    