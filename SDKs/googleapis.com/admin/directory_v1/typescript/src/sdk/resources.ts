/*
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

import * as utils from "../internal/utils";
import * as operations from "./models/operations";
import * as shared from "./models/shared";
import { AxiosInstance, AxiosRequestConfig, AxiosResponse } from "axios";

export class Resources {
  _defaultClient: AxiosInstance;
  _securityClient: AxiosInstance;
  _serverURL: string;
  _language: string;
  _sdkVersion: string;
  _genVersion: string;

  constructor(
    defaultClient: AxiosInstance,
    securityClient: AxiosInstance,
    serverURL: string,
    language: string,
    sdkVersion: string,
    genVersion: string
  ) {
    this._defaultClient = defaultClient;
    this._securityClient = securityClient;
    this._serverURL = serverURL;
    this._language = language;
    this._sdkVersion = sdkVersion;
    this._genVersion = genVersion;
  }

  /**
   * Deletes a building.
   */
  directoryResourcesBuildingsDelete(
    req: operations.DirectoryResourcesBuildingsDeleteRequest,
    security: operations.DirectoryResourcesBuildingsDeleteSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.DirectoryResourcesBuildingsDeleteResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DirectoryResourcesBuildingsDeleteRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/admin/directory/v1/customer/{customer}/resources/buildings/{buildingId}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.DirectoryResourcesBuildingsDeleteSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DirectoryResourcesBuildingsDeleteResponse =
        new operations.DirectoryResourcesBuildingsDeleteResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          break;
      }

      return res;
    });
  }

  /**
   * Retrieves a building.
   */
  directoryResourcesBuildingsGet(
    req: operations.DirectoryResourcesBuildingsGetRequest,
    security: operations.DirectoryResourcesBuildingsGetSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.DirectoryResourcesBuildingsGetResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DirectoryResourcesBuildingsGetRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/admin/directory/v1/customer/{customer}/resources/buildings/{buildingId}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.DirectoryResourcesBuildingsGetSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DirectoryResourcesBuildingsGetResponse =
        new operations.DirectoryResourcesBuildingsGetResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.building = utils.objectToClass(httpRes?.data, shared.Building);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Inserts a building.
   */
  directoryResourcesBuildingsInsert(
    req: operations.DirectoryResourcesBuildingsInsertRequest,
    security: operations.DirectoryResourcesBuildingsInsertSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.DirectoryResourcesBuildingsInsertResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DirectoryResourcesBuildingsInsertRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/admin/directory/v1/customer/{customer}/resources/buildings",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "building",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.DirectoryResourcesBuildingsInsertSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DirectoryResourcesBuildingsInsertResponse =
        new operations.DirectoryResourcesBuildingsInsertResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.building = utils.objectToClass(httpRes?.data, shared.Building);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Retrieves a list of buildings for an account.
   */
  directoryResourcesBuildingsList(
    req: operations.DirectoryResourcesBuildingsListRequest,
    security: operations.DirectoryResourcesBuildingsListSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.DirectoryResourcesBuildingsListResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DirectoryResourcesBuildingsListRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/admin/directory/v1/customer/{customer}/resources/buildings",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.DirectoryResourcesBuildingsListSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DirectoryResourcesBuildingsListResponse =
        new operations.DirectoryResourcesBuildingsListResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.buildings = utils.objectToClass(
              httpRes?.data,
              shared.Buildings
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Patches a building.
   */
  directoryResourcesBuildingsPatch(
    req: operations.DirectoryResourcesBuildingsPatchRequest,
    security: operations.DirectoryResourcesBuildingsPatchSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.DirectoryResourcesBuildingsPatchResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DirectoryResourcesBuildingsPatchRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/admin/directory/v1/customer/{customer}/resources/buildings/{buildingId}",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "building",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.DirectoryResourcesBuildingsPatchSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "patch",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DirectoryResourcesBuildingsPatchResponse =
        new operations.DirectoryResourcesBuildingsPatchResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.building = utils.objectToClass(httpRes?.data, shared.Building);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Updates a building.
   */
  directoryResourcesBuildingsUpdate(
    req: operations.DirectoryResourcesBuildingsUpdateRequest,
    security: operations.DirectoryResourcesBuildingsUpdateSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.DirectoryResourcesBuildingsUpdateResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DirectoryResourcesBuildingsUpdateRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/admin/directory/v1/customer/{customer}/resources/buildings/{buildingId}",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "building",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.DirectoryResourcesBuildingsUpdateSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "put",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DirectoryResourcesBuildingsUpdateResponse =
        new operations.DirectoryResourcesBuildingsUpdateResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.building = utils.objectToClass(httpRes?.data, shared.Building);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Deletes a calendar resource.
   */
  directoryResourcesCalendarsDelete(
    req: operations.DirectoryResourcesCalendarsDeleteRequest,
    security: operations.DirectoryResourcesCalendarsDeleteSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.DirectoryResourcesCalendarsDeleteResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DirectoryResourcesCalendarsDeleteRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/admin/directory/v1/customer/{customer}/resources/calendars/{calendarResourceId}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.DirectoryResourcesCalendarsDeleteSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DirectoryResourcesCalendarsDeleteResponse =
        new operations.DirectoryResourcesCalendarsDeleteResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          break;
      }

      return res;
    });
  }

  /**
   * Retrieves a calendar resource.
   */
  directoryResourcesCalendarsGet(
    req: operations.DirectoryResourcesCalendarsGetRequest,
    security: operations.DirectoryResourcesCalendarsGetSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.DirectoryResourcesCalendarsGetResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DirectoryResourcesCalendarsGetRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/admin/directory/v1/customer/{customer}/resources/calendars/{calendarResourceId}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.DirectoryResourcesCalendarsGetSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DirectoryResourcesCalendarsGetResponse =
        new operations.DirectoryResourcesCalendarsGetResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.calendarResource = utils.objectToClass(
              httpRes?.data,
              shared.CalendarResource
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Inserts a calendar resource.
   */
  directoryResourcesCalendarsInsert(
    req: operations.DirectoryResourcesCalendarsInsertRequest,
    security: operations.DirectoryResourcesCalendarsInsertSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.DirectoryResourcesCalendarsInsertResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DirectoryResourcesCalendarsInsertRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/admin/directory/v1/customer/{customer}/resources/calendars",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "calendarResource",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.DirectoryResourcesCalendarsInsertSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DirectoryResourcesCalendarsInsertResponse =
        new operations.DirectoryResourcesCalendarsInsertResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.calendarResource = utils.objectToClass(
              httpRes?.data,
              shared.CalendarResource
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Retrieves a list of calendar resources for an account.
   */
  directoryResourcesCalendarsList(
    req: operations.DirectoryResourcesCalendarsListRequest,
    security: operations.DirectoryResourcesCalendarsListSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.DirectoryResourcesCalendarsListResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DirectoryResourcesCalendarsListRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/admin/directory/v1/customer/{customer}/resources/calendars",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.DirectoryResourcesCalendarsListSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DirectoryResourcesCalendarsListResponse =
        new operations.DirectoryResourcesCalendarsListResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.calendarResources = utils.objectToClass(
              httpRes?.data,
              shared.CalendarResources
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Patches a calendar resource.
   */
  directoryResourcesCalendarsPatch(
    req: operations.DirectoryResourcesCalendarsPatchRequest,
    security: operations.DirectoryResourcesCalendarsPatchSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.DirectoryResourcesCalendarsPatchResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DirectoryResourcesCalendarsPatchRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/admin/directory/v1/customer/{customer}/resources/calendars/{calendarResourceId}",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "calendarResource",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.DirectoryResourcesCalendarsPatchSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "patch",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DirectoryResourcesCalendarsPatchResponse =
        new operations.DirectoryResourcesCalendarsPatchResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.calendarResource = utils.objectToClass(
              httpRes?.data,
              shared.CalendarResource
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Updates a calendar resource. This method supports patch semantics, meaning you only need to include the fields you wish to update. Fields that are not present in the request will be preserved.
   */
  directoryResourcesCalendarsUpdate(
    req: operations.DirectoryResourcesCalendarsUpdateRequest,
    security: operations.DirectoryResourcesCalendarsUpdateSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.DirectoryResourcesCalendarsUpdateResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DirectoryResourcesCalendarsUpdateRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/admin/directory/v1/customer/{customer}/resources/calendars/{calendarResourceId}",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "calendarResource",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.DirectoryResourcesCalendarsUpdateSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "put",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DirectoryResourcesCalendarsUpdateResponse =
        new operations.DirectoryResourcesCalendarsUpdateResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.calendarResource = utils.objectToClass(
              httpRes?.data,
              shared.CalendarResource
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Deletes a feature.
   */
  directoryResourcesFeaturesDelete(
    req: operations.DirectoryResourcesFeaturesDeleteRequest,
    security: operations.DirectoryResourcesFeaturesDeleteSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.DirectoryResourcesFeaturesDeleteResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DirectoryResourcesFeaturesDeleteRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/admin/directory/v1/customer/{customer}/resources/features/{featureKey}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.DirectoryResourcesFeaturesDeleteSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DirectoryResourcesFeaturesDeleteResponse =
        new operations.DirectoryResourcesFeaturesDeleteResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          break;
      }

      return res;
    });
  }

  /**
   * Retrieves a feature.
   */
  directoryResourcesFeaturesGet(
    req: operations.DirectoryResourcesFeaturesGetRequest,
    security: operations.DirectoryResourcesFeaturesGetSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.DirectoryResourcesFeaturesGetResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DirectoryResourcesFeaturesGetRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/admin/directory/v1/customer/{customer}/resources/features/{featureKey}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.DirectoryResourcesFeaturesGetSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DirectoryResourcesFeaturesGetResponse =
        new operations.DirectoryResourcesFeaturesGetResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.feature = utils.objectToClass(httpRes?.data, shared.Feature);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Inserts a feature.
   */
  directoryResourcesFeaturesInsert(
    req: operations.DirectoryResourcesFeaturesInsertRequest,
    security: operations.DirectoryResourcesFeaturesInsertSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.DirectoryResourcesFeaturesInsertResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DirectoryResourcesFeaturesInsertRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/admin/directory/v1/customer/{customer}/resources/features",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "feature",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.DirectoryResourcesFeaturesInsertSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DirectoryResourcesFeaturesInsertResponse =
        new operations.DirectoryResourcesFeaturesInsertResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.feature = utils.objectToClass(httpRes?.data, shared.Feature);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Retrieves a list of features for an account.
   */
  directoryResourcesFeaturesList(
    req: operations.DirectoryResourcesFeaturesListRequest,
    security: operations.DirectoryResourcesFeaturesListSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.DirectoryResourcesFeaturesListResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DirectoryResourcesFeaturesListRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/admin/directory/v1/customer/{customer}/resources/features",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.DirectoryResourcesFeaturesListSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DirectoryResourcesFeaturesListResponse =
        new operations.DirectoryResourcesFeaturesListResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.features = utils.objectToClass(httpRes?.data, shared.Features);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Patches a feature.
   */
  directoryResourcesFeaturesPatch(
    req: operations.DirectoryResourcesFeaturesPatchRequest,
    security: operations.DirectoryResourcesFeaturesPatchSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.DirectoryResourcesFeaturesPatchResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DirectoryResourcesFeaturesPatchRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/admin/directory/v1/customer/{customer}/resources/features/{featureKey}",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "feature",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.DirectoryResourcesFeaturesPatchSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "patch",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DirectoryResourcesFeaturesPatchResponse =
        new operations.DirectoryResourcesFeaturesPatchResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.feature = utils.objectToClass(httpRes?.data, shared.Feature);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Renames a feature.
   */
  directoryResourcesFeaturesRename(
    req: operations.DirectoryResourcesFeaturesRenameRequest,
    security: operations.DirectoryResourcesFeaturesRenameSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.DirectoryResourcesFeaturesRenameResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DirectoryResourcesFeaturesRenameRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/admin/directory/v1/customer/{customer}/resources/features/{oldName}/rename",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "featureRename",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.DirectoryResourcesFeaturesRenameSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DirectoryResourcesFeaturesRenameResponse =
        new operations.DirectoryResourcesFeaturesRenameResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          break;
      }

      return res;
    });
  }

  /**
   * Updates a feature.
   */
  directoryResourcesFeaturesUpdate(
    req: operations.DirectoryResourcesFeaturesUpdateRequest,
    security: operations.DirectoryResourcesFeaturesUpdateSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.DirectoryResourcesFeaturesUpdateResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DirectoryResourcesFeaturesUpdateRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/admin/directory/v1/customer/{customer}/resources/features/{featureKey}",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "feature",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.DirectoryResourcesFeaturesUpdateSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "put",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DirectoryResourcesFeaturesUpdateResponse =
        new operations.DirectoryResourcesFeaturesUpdateResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.feature = utils.objectToClass(httpRes?.data, shared.Feature);
          }
          break;
      }

      return res;
    });
  }
}
