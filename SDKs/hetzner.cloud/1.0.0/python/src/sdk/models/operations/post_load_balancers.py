"""Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT."""

from __future__ import annotations
import dataclasses
import requests as requests_http
from dataclasses_json import Undefined, dataclass_json
from enum import Enum
from sdk import utils
from typing import Optional

class PostLoadBalancersCreateLoadBalancerRequestLoadBalancerAlgorithmTypeEnum(str, Enum):
    r"""Type of the algorithm"""
    ROUND_ROBIN = 'round_robin'
    LEAST_CONNECTIONS = 'least_connections'


@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class PostLoadBalancersCreateLoadBalancerRequestLoadBalancerAlgorithm:
    r"""Algorithm of the Load Balancer"""
    
    type: PostLoadBalancersCreateLoadBalancerRequestLoadBalancerAlgorithmTypeEnum = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('type') }})
    r"""Type of the algorithm"""  
    

@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class PostLoadBalancersCreateLoadBalancerRequestLabels:
    r"""User-defined labels (key-value pairs)"""
    
    labelkey: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('labelkey'), 'exclude': lambda f: f is None }})
    r"""New label"""  
    

@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class PostLoadBalancersCreateLoadBalancerRequestLoadBalancerServiceLoadBalancerServiceHealthCheckHTTP:
    r"""Additional configuration for protocol http"""
    
    domain: str = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('domain') }})
    r"""Host header to send in the HTTP request. May not contain spaces, percent or backslash symbols. Can be null, in that case no host header is sent."""  
    path: str = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('path') }})
    r"""HTTP path to use for health checks. May not contain literal spaces, use percent-encoding instead."""  
    response: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('response'), 'exclude': lambda f: f is None }})
    r"""String that must be contained in HTTP response in order to pass the health check"""  
    status_codes: Optional[list[str]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('status_codes'), 'exclude': lambda f: f is None }})
    r"""List of returned HTTP status codes in order to pass the health check. Supports the wildcards `?` for exactly one character and `*` for multiple ones. The default is to pass the health check for any status code between 2?? and 3??."""  
    tls: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('tls'), 'exclude': lambda f: f is None }})
    r"""Use HTTPS for health check"""  
    
class PostLoadBalancersCreateLoadBalancerRequestLoadBalancerServiceLoadBalancerServiceHealthCheckProtocolEnum(str, Enum):
    r"""Type of the health check"""
    TCP = 'tcp'
    HTTP = 'http'


@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class PostLoadBalancersCreateLoadBalancerRequestLoadBalancerServiceLoadBalancerServiceHealthCheck:
    r"""Service health check"""
    
    interval: int = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('interval') }})
    r"""Time interval in seconds health checks are performed"""  
    port: int = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('port') }})
    r"""Port the health check will be performed on"""  
    protocol: PostLoadBalancersCreateLoadBalancerRequestLoadBalancerServiceLoadBalancerServiceHealthCheckProtocolEnum = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('protocol') }})
    r"""Type of the health check"""  
    retries: int = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('retries') }})
    r"""Unsuccessful retries needed until a target is considered unhealthy; an unhealthy target needs the same number of successful retries to become healthy again"""  
    timeout: int = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('timeout') }})
    r"""Time in seconds after an attempt is considered a timeout"""  
    http: Optional[PostLoadBalancersCreateLoadBalancerRequestLoadBalancerServiceLoadBalancerServiceHealthCheckHTTP] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('http'), 'exclude': lambda f: f is None }})
    r"""Additional configuration for protocol http"""  
    

@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class PostLoadBalancersCreateLoadBalancerRequestLoadBalancerServiceLoadBalancerServiceHTTP:
    r"""Configuration option for protocols http and https"""
    
    certificates: Optional[list[int]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('certificates'), 'exclude': lambda f: f is None }})
    r"""IDs of the Certificates to use for TLS/SSL termination by the Load Balancer; empty for TLS/SSL passthrough or if `protocol` is \\"http\\" """  
    cookie_lifetime: Optional[int] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('cookie_lifetime'), 'exclude': lambda f: f is None }})
    r"""Lifetime of the cookie used for sticky sessions"""  
    cookie_name: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('cookie_name'), 'exclude': lambda f: f is None }})
    r"""Name of the cookie used for sticky sessions"""  
    redirect_http: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('redirect_http'), 'exclude': lambda f: f is None }})
    r"""Redirect HTTP requests to HTTPS. Only available if protocol is \\"https\\". Default `false`"""  
    sticky_sessions: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('sticky_sessions'), 'exclude': lambda f: f is None }})
    r"""Use sticky sessions. Only available if protocol is \\"http\\" or \\"https\\". Default `false`"""  
    
class PostLoadBalancersCreateLoadBalancerRequestLoadBalancerServiceProtocolEnum(str, Enum):
    r"""Protocol of the Load Balancer"""
    TCP = 'tcp'
    HTTP = 'http'
    HTTPS = 'https'


@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class PostLoadBalancersCreateLoadBalancerRequestLoadBalancerService:
    
    destination_port: int = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('destination_port') }})
    r"""Port the Load Balancer will balance to"""  
    health_check: PostLoadBalancersCreateLoadBalancerRequestLoadBalancerServiceLoadBalancerServiceHealthCheck = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('health_check') }})
    r"""Service health check"""  
    listen_port: int = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('listen_port') }})
    r"""Port the Load Balancer listens on"""  
    protocol: PostLoadBalancersCreateLoadBalancerRequestLoadBalancerServiceProtocolEnum = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('protocol') }})
    r"""Protocol of the Load Balancer"""  
    proxyprotocol: bool = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('proxyprotocol') }})
    r"""Is Proxyprotocol enabled or not"""  
    http: Optional[PostLoadBalancersCreateLoadBalancerRequestLoadBalancerServiceLoadBalancerServiceHTTP] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('http'), 'exclude': lambda f: f is None }})
    r"""Configuration option for protocols http and https"""  
    
class PostLoadBalancersCreateLoadBalancerRequestLoadBalancerTargetHealthStatusStatusEnum(str, Enum):
    HEALTHY = 'healthy'
    UNHEALTHY = 'unhealthy'
    UNKNOWN = 'unknown'


@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class PostLoadBalancersCreateLoadBalancerRequestLoadBalancerTargetHealthStatus:
    
    listen_port: Optional[int] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('listen_port'), 'exclude': lambda f: f is None }})  
    status: Optional[PostLoadBalancersCreateLoadBalancerRequestLoadBalancerTargetHealthStatusStatusEnum] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('status'), 'exclude': lambda f: f is None }})  
    

@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class PostLoadBalancersCreateLoadBalancerRequestLoadBalancerTargetIP:
    r"""IP targets where the traffic should be routed through. It is only possible to use the (Public or vSwitch) IPs of Hetzner Online Root Servers belonging to the project owner. IPs belonging to other users are blocked. Additionally IPs belonging to services provided by Hetzner Cloud (Servers, Load Balancers, ...) are blocked as well."""
    
    ip: str = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('ip') }})
    r"""IP of a server that belongs to the same customer (public IPv4/IPv6) or private IP in a Subnetwork type vswitch."""  
    

@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class PostLoadBalancersCreateLoadBalancerRequestLoadBalancerTargetLabelSelector:
    r"""Label selector and a list of selected targets"""
    
    selector: str = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('selector') }})
    r"""Label selector"""  
    

@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class PostLoadBalancersCreateLoadBalancerRequestLoadBalancerTargetLoadBalancerTargetServer:
    r"""Server where the traffic should be routed through"""
    
    id: int = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('id') }})
    r"""ID of the Server"""  
    
class PostLoadBalancersCreateLoadBalancerRequestLoadBalancerTargetTargetsHealthStatusStatusEnum(str, Enum):
    HEALTHY = 'healthy'
    UNHEALTHY = 'unhealthy'
    UNKNOWN = 'unknown'


@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class PostLoadBalancersCreateLoadBalancerRequestLoadBalancerTargetTargetsHealthStatus:
    
    listen_port: Optional[int] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('listen_port'), 'exclude': lambda f: f is None }})  
    status: Optional[PostLoadBalancersCreateLoadBalancerRequestLoadBalancerTargetTargetsHealthStatusStatusEnum] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('status'), 'exclude': lambda f: f is None }})  
    

@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class PostLoadBalancersCreateLoadBalancerRequestLoadBalancerTargetTargetsServer:
    
    id: int = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('id') }})
    r"""ID of the Server"""  
    

@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class PostLoadBalancersCreateLoadBalancerRequestLoadBalancerTargetTargets:
    
    health_status: Optional[list[PostLoadBalancersCreateLoadBalancerRequestLoadBalancerTargetTargetsHealthStatus]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('health_status'), 'exclude': lambda f: f is None }})  
    server: Optional[PostLoadBalancersCreateLoadBalancerRequestLoadBalancerTargetTargetsServer] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('server'), 'exclude': lambda f: f is None }})  
    type: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('type'), 'exclude': lambda f: f is None }})  
    use_private_ip: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('use_private_ip'), 'exclude': lambda f: f is None }})  
    
class PostLoadBalancersCreateLoadBalancerRequestLoadBalancerTargetTypeEnum(str, Enum):
    r"""Type of the resource"""
    SERVER = 'server'
    LABEL_SELECTOR = 'label_selector'
    IP = 'ip'


@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class PostLoadBalancersCreateLoadBalancerRequestLoadBalancerTarget:
    
    type: PostLoadBalancersCreateLoadBalancerRequestLoadBalancerTargetTypeEnum = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('type') }})
    r"""Type of the resource"""  
    health_status: Optional[list[PostLoadBalancersCreateLoadBalancerRequestLoadBalancerTargetHealthStatus]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('health_status'), 'exclude': lambda f: f is None }})
    r"""List of health statuses of the services on this target"""  
    ip: Optional[PostLoadBalancersCreateLoadBalancerRequestLoadBalancerTargetIP] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('ip'), 'exclude': lambda f: f is None }})
    r"""IP targets where the traffic should be routed through. It is only possible to use the (Public or vSwitch) IPs of Hetzner Online Root Servers belonging to the project owner. IPs belonging to other users are blocked. Additionally IPs belonging to services provided by Hetzner Cloud (Servers, Load Balancers, ...) are blocked as well."""  
    label_selector: Optional[PostLoadBalancersCreateLoadBalancerRequestLoadBalancerTargetLabelSelector] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('label_selector'), 'exclude': lambda f: f is None }})
    r"""Label selector and a list of selected targets"""  
    server: Optional[PostLoadBalancersCreateLoadBalancerRequestLoadBalancerTargetLoadBalancerTargetServer] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('server'), 'exclude': lambda f: f is None }})
    r"""Server where the traffic should be routed through"""  
    targets: Optional[list[PostLoadBalancersCreateLoadBalancerRequestLoadBalancerTargetTargets]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('targets'), 'exclude': lambda f: f is None }})
    r"""List of selected targets"""  
    use_private_ip: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('use_private_ip'), 'exclude': lambda f: f is None }})
    r"""Use the private network IP instead of the public IP. Default value is false."""  
    

@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class PostLoadBalancersCreateLoadBalancerRequest:
    
    algorithm: PostLoadBalancersCreateLoadBalancerRequestLoadBalancerAlgorithm = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('algorithm') }})
    r"""Algorithm of the Load Balancer"""  
    load_balancer_type: str = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('load_balancer_type') }})
    r"""ID or name of the Load Balancer type this Load Balancer should be created with"""  
    name: str = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('name') }})
    r"""Name of the Load Balancer"""  
    labels: Optional[PostLoadBalancersCreateLoadBalancerRequestLabels] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('labels'), 'exclude': lambda f: f is None }})
    r"""User-defined labels (key-value pairs)"""  
    location: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('location'), 'exclude': lambda f: f is None }})
    r"""ID or name of Location to create Load Balancer in"""  
    network: Optional[int] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('network'), 'exclude': lambda f: f is None }})
    r"""ID of the network the Load Balancer should be attached to on creation"""  
    network_zone: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('network_zone'), 'exclude': lambda f: f is None }})
    r"""Name of network zone"""  
    public_interface: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('public_interface'), 'exclude': lambda f: f is None }})
    r"""Enable or disable the public interface of the Load Balancer"""  
    services: Optional[list[PostLoadBalancersCreateLoadBalancerRequestLoadBalancerService]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('services'), 'exclude': lambda f: f is None }})
    r"""Array of services"""  
    targets: Optional[list[PostLoadBalancersCreateLoadBalancerRequestLoadBalancerTarget]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('targets'), 'exclude': lambda f: f is None }})
    r"""Array of targets"""  
    

@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class PostLoadBalancers201ApplicationJSONActionError:
    r"""Error message for the Action if error occurred, otherwise null"""
    
    code: str = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('code') }})
    r"""Fixed machine readable code"""  
    message: str = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('message') }})
    r"""Humanized error message"""  
    

@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class PostLoadBalancers201ApplicationJSONActionResources:
    
    id: int = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('id') }})
    r"""ID of the Resource"""  
    type: str = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('type') }})
    r"""Type of resource referenced"""  
    
class PostLoadBalancers201ApplicationJSONActionStatusEnum(str, Enum):
    r"""Status of the Action"""
    SUCCESS = 'success'
    RUNNING = 'running'
    ERROR = 'error'


@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class PostLoadBalancers201ApplicationJSONAction:
    
    command: str = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('command') }})
    r"""Command executed in the Action"""  
    error: PostLoadBalancers201ApplicationJSONActionError = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('error') }})
    r"""Error message for the Action if error occurred, otherwise null"""  
    finished: str = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('finished') }})
    r"""Point in time when the Action was finished (in ISO-8601 format). Only set if the Action is finished otherwise null."""  
    id: int = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('id') }})
    r"""ID of the Resource"""  
    progress: float = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('progress') }})
    r"""Progress of Action in percent"""  
    resources: list[PostLoadBalancers201ApplicationJSONActionResources] = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('resources') }})
    r"""Resources the Action relates to"""  
    started: str = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('started') }})
    r"""Point in time when the Action was started (in ISO-8601 format)"""  
    status: PostLoadBalancers201ApplicationJSONActionStatusEnum = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('status') }})
    r"""Status of the Action"""  
    
class PostLoadBalancers201ApplicationJSONLoadBalancerAlgorithmTypeEnum(str, Enum):
    r"""Type of the algorithm"""
    ROUND_ROBIN = 'round_robin'
    LEAST_CONNECTIONS = 'least_connections'


@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class PostLoadBalancers201ApplicationJSONLoadBalancerAlgorithm:
    r"""Algorithm of the Load Balancer"""
    
    type: PostLoadBalancers201ApplicationJSONLoadBalancerAlgorithmTypeEnum = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('type') }})
    r"""Type of the algorithm"""  
    

@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class PostLoadBalancers201ApplicationJSONLoadBalancerLoadBalancerTypePricesPriceHourly:
    r"""Hourly costs for a Resource in this Location"""
    
    gross: str = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('gross') }})
    r"""Price with VAT added"""  
    net: str = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('net') }})
    r"""Price without VAT"""  
    

@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class PostLoadBalancers201ApplicationJSONLoadBalancerLoadBalancerTypePricesPriceMonthly:
    r"""Monthly costs for a Resource in this Location"""
    
    gross: str = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('gross') }})
    r"""Price with VAT added"""  
    net: str = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('net') }})
    r"""Price without VAT"""  
    

@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class PostLoadBalancers201ApplicationJSONLoadBalancerLoadBalancerTypePrices:
    
    location: str = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('location') }})
    r"""Name of the Location the price is for"""  
    price_hourly: PostLoadBalancers201ApplicationJSONLoadBalancerLoadBalancerTypePricesPriceHourly = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('price_hourly') }})
    r"""Hourly costs for a Resource in this Location"""  
    price_monthly: PostLoadBalancers201ApplicationJSONLoadBalancerLoadBalancerTypePricesPriceMonthly = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('price_monthly') }})
    r"""Monthly costs for a Resource in this Location"""  
    

@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class PostLoadBalancers201ApplicationJSONLoadBalancerLoadBalancerType:
    
    deprecated: str = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('deprecated') }})
    r"""Point in time when the Load Balancer type is deprecated (in ISO-8601 format)"""  
    description: str = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('description') }})
    r"""Description of the Load Balancer type"""  
    id: float = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('id') }})
    r"""ID of the Load Balancer type"""  
    max_assigned_certificates: float = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('max_assigned_certificates') }})
    r"""Number of SSL Certificates that can be assigned to a single Load Balancer"""  
    max_connections: float = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('max_connections') }})
    r"""Number of maximum simultaneous open connections"""  
    max_services: float = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('max_services') }})
    r"""Number of services a Load Balancer of this type can have"""  
    max_targets: float = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('max_targets') }})
    r"""Number of targets a single Load Balancer can have"""  
    name: str = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('name') }})
    r"""Unique identifier of the Load Balancer type"""  
    prices: list[PostLoadBalancers201ApplicationJSONLoadBalancerLoadBalancerTypePrices] = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('prices') }})
    r"""Prices in different network zones"""  
    

@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class PostLoadBalancers201ApplicationJSONLoadBalancerLocation:
    
    city: str = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('city') }})
    r"""City the Location is closest to"""  
    country: str = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('country') }})
    r"""ISO 3166-1 alpha-2 code of the country the Location resides in"""  
    description: str = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('description') }})
    r"""Description of the Location"""  
    id: float = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('id') }})
    r"""ID of the Location"""  
    latitude: float = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('latitude') }})
    r"""Latitude of the city closest to the Location"""  
    longitude: float = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('longitude') }})
    r"""Longitude of the city closest to the Location"""  
    name: str = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('name') }})
    r"""Unique identifier of the Location"""  
    network_zone: str = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('network_zone') }})
    r"""Name of network zone this Location resides in"""  
    

@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class PostLoadBalancers201ApplicationJSONLoadBalancerPrivateNet:
    
    ip: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('ip'), 'exclude': lambda f: f is None }})  
    network: Optional[int] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('network'), 'exclude': lambda f: f is None }})  
    

@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class PostLoadBalancers201ApplicationJSONLoadBalancerProtection:
    r"""Protection configuration for the Resource"""
    
    delete: bool = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('delete') }})
    r"""If true, prevents the Resource from being deleted"""  
    

@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class PostLoadBalancers201ApplicationJSONLoadBalancerPublicNetIpv4:
    r"""IP address (v4)"""
    
    dns_ptr: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('dns_ptr'), 'exclude': lambda f: f is None }})
    r"""Reverse DNS PTR entry for the IPv4 address of this Load Balancer"""  
    ip: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('ip'), 'exclude': lambda f: f is None }})
    r"""IP address (v4) of this Load Balancer"""  
    

@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class PostLoadBalancers201ApplicationJSONLoadBalancerPublicNetIpv6:
    r"""IP address (v6)"""
    
    dns_ptr: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('dns_ptr'), 'exclude': lambda f: f is None }})
    r"""Reverse DNS PTR entry for the IPv6 address of this Load Balancer"""  
    ip: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('ip'), 'exclude': lambda f: f is None }})
    r"""IP address (v6) of this Load Balancer"""  
    

@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class PostLoadBalancers201ApplicationJSONLoadBalancerPublicNet:
    r"""Public network information"""
    
    enabled: bool = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('enabled') }})
    r"""Public Interface enabled or not"""  
    ipv4: PostLoadBalancers201ApplicationJSONLoadBalancerPublicNetIpv4 = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('ipv4') }})
    r"""IP address (v4)"""  
    ipv6: PostLoadBalancers201ApplicationJSONLoadBalancerPublicNetIpv6 = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('ipv6') }})
    r"""IP address (v6)"""  
    

@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class PostLoadBalancers201ApplicationJSONLoadBalancerLoadBalancerServiceLoadBalancerServiceHealthCheckHTTP:
    r"""Additional configuration for protocol http"""
    
    domain: str = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('domain') }})
    r"""Host header to send in the HTTP request. May not contain spaces, percent or backslash symbols. Can be null, in that case no host header is sent."""  
    path: str = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('path') }})
    r"""HTTP path to use for health checks. May not contain literal spaces, use percent-encoding instead."""  
    response: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('response'), 'exclude': lambda f: f is None }})
    r"""String that must be contained in HTTP response in order to pass the health check"""  
    status_codes: Optional[list[str]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('status_codes'), 'exclude': lambda f: f is None }})
    r"""List of returned HTTP status codes in order to pass the health check. Supports the wildcards `?` for exactly one character and `*` for multiple ones. The default is to pass the health check for any status code between 2?? and 3??."""  
    tls: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('tls'), 'exclude': lambda f: f is None }})
    r"""Use HTTPS for health check"""  
    
class PostLoadBalancers201ApplicationJSONLoadBalancerLoadBalancerServiceLoadBalancerServiceHealthCheckProtocolEnum(str, Enum):
    r"""Type of the health check"""
    TCP = 'tcp'
    HTTP = 'http'


@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class PostLoadBalancers201ApplicationJSONLoadBalancerLoadBalancerServiceLoadBalancerServiceHealthCheck:
    r"""Service health check"""
    
    interval: int = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('interval') }})
    r"""Time interval in seconds health checks are performed"""  
    port: int = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('port') }})
    r"""Port the health check will be performed on"""  
    protocol: PostLoadBalancers201ApplicationJSONLoadBalancerLoadBalancerServiceLoadBalancerServiceHealthCheckProtocolEnum = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('protocol') }})
    r"""Type of the health check"""  
    retries: int = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('retries') }})
    r"""Unsuccessful retries needed until a target is considered unhealthy; an unhealthy target needs the same number of successful retries to become healthy again"""  
    timeout: int = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('timeout') }})
    r"""Time in seconds after an attempt is considered a timeout"""  
    http: Optional[PostLoadBalancers201ApplicationJSONLoadBalancerLoadBalancerServiceLoadBalancerServiceHealthCheckHTTP] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('http'), 'exclude': lambda f: f is None }})
    r"""Additional configuration for protocol http"""  
    

@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class PostLoadBalancers201ApplicationJSONLoadBalancerLoadBalancerServiceLoadBalancerServiceHTTP:
    r"""Configuration option for protocols http and https"""
    
    certificates: Optional[list[int]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('certificates'), 'exclude': lambda f: f is None }})
    r"""IDs of the Certificates to use for TLS/SSL termination by the Load Balancer; empty for TLS/SSL passthrough or if `protocol` is \\"http\\" """  
    cookie_lifetime: Optional[int] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('cookie_lifetime'), 'exclude': lambda f: f is None }})
    r"""Lifetime of the cookie used for sticky sessions"""  
    cookie_name: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('cookie_name'), 'exclude': lambda f: f is None }})
    r"""Name of the cookie used for sticky sessions"""  
    redirect_http: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('redirect_http'), 'exclude': lambda f: f is None }})
    r"""Redirect HTTP requests to HTTPS. Only available if protocol is \\"https\\". Default `false`"""  
    sticky_sessions: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('sticky_sessions'), 'exclude': lambda f: f is None }})
    r"""Use sticky sessions. Only available if protocol is \\"http\\" or \\"https\\". Default `false`"""  
    
class PostLoadBalancers201ApplicationJSONLoadBalancerLoadBalancerServiceProtocolEnum(str, Enum):
    r"""Protocol of the Load Balancer"""
    TCP = 'tcp'
    HTTP = 'http'
    HTTPS = 'https'


@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class PostLoadBalancers201ApplicationJSONLoadBalancerLoadBalancerService:
    
    destination_port: int = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('destination_port') }})
    r"""Port the Load Balancer will balance to"""  
    health_check: PostLoadBalancers201ApplicationJSONLoadBalancerLoadBalancerServiceLoadBalancerServiceHealthCheck = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('health_check') }})
    r"""Service health check"""  
    listen_port: int = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('listen_port') }})
    r"""Port the Load Balancer listens on"""  
    protocol: PostLoadBalancers201ApplicationJSONLoadBalancerLoadBalancerServiceProtocolEnum = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('protocol') }})
    r"""Protocol of the Load Balancer"""  
    proxyprotocol: bool = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('proxyprotocol') }})
    r"""Is Proxyprotocol enabled or not"""  
    http: Optional[PostLoadBalancers201ApplicationJSONLoadBalancerLoadBalancerServiceLoadBalancerServiceHTTP] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('http'), 'exclude': lambda f: f is None }})
    r"""Configuration option for protocols http and https"""  
    
class PostLoadBalancers201ApplicationJSONLoadBalancerLoadBalancerTargetHealthStatusStatusEnum(str, Enum):
    HEALTHY = 'healthy'
    UNHEALTHY = 'unhealthy'
    UNKNOWN = 'unknown'


@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class PostLoadBalancers201ApplicationJSONLoadBalancerLoadBalancerTargetHealthStatus:
    
    listen_port: Optional[int] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('listen_port'), 'exclude': lambda f: f is None }})  
    status: Optional[PostLoadBalancers201ApplicationJSONLoadBalancerLoadBalancerTargetHealthStatusStatusEnum] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('status'), 'exclude': lambda f: f is None }})  
    

@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class PostLoadBalancers201ApplicationJSONLoadBalancerLoadBalancerTargetIP:
    r"""IP targets where the traffic should be routed through. It is only possible to use the (Public or vSwitch) IPs of Hetzner Online Root Servers belonging to the project owner. IPs belonging to other users are blocked. Additionally IPs belonging to services provided by Hetzner Cloud (Servers, Load Balancers, ...) are blocked as well."""
    
    ip: str = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('ip') }})
    r"""IP of a server that belongs to the same customer (public IPv4/IPv6) or private IP in a Subnetwork type vswitch."""  
    

@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class PostLoadBalancers201ApplicationJSONLoadBalancerLoadBalancerTargetLabelSelector:
    r"""Label selector and a list of selected targets"""
    
    selector: str = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('selector') }})
    r"""Label selector"""  
    

@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class PostLoadBalancers201ApplicationJSONLoadBalancerLoadBalancerTargetLoadBalancerTargetServer:
    r"""Server where the traffic should be routed through"""
    
    id: int = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('id') }})
    r"""ID of the Server"""  
    
class PostLoadBalancers201ApplicationJSONLoadBalancerLoadBalancerTargetTargetsHealthStatusStatusEnum(str, Enum):
    HEALTHY = 'healthy'
    UNHEALTHY = 'unhealthy'
    UNKNOWN = 'unknown'


@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class PostLoadBalancers201ApplicationJSONLoadBalancerLoadBalancerTargetTargetsHealthStatus:
    
    listen_port: Optional[int] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('listen_port'), 'exclude': lambda f: f is None }})  
    status: Optional[PostLoadBalancers201ApplicationJSONLoadBalancerLoadBalancerTargetTargetsHealthStatusStatusEnum] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('status'), 'exclude': lambda f: f is None }})  
    

@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class PostLoadBalancers201ApplicationJSONLoadBalancerLoadBalancerTargetTargetsServer:
    
    id: int = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('id') }})
    r"""ID of the Server"""  
    

@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class PostLoadBalancers201ApplicationJSONLoadBalancerLoadBalancerTargetTargets:
    
    health_status: Optional[list[PostLoadBalancers201ApplicationJSONLoadBalancerLoadBalancerTargetTargetsHealthStatus]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('health_status'), 'exclude': lambda f: f is None }})  
    server: Optional[PostLoadBalancers201ApplicationJSONLoadBalancerLoadBalancerTargetTargetsServer] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('server'), 'exclude': lambda f: f is None }})  
    type: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('type'), 'exclude': lambda f: f is None }})  
    use_private_ip: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('use_private_ip'), 'exclude': lambda f: f is None }})  
    
class PostLoadBalancers201ApplicationJSONLoadBalancerLoadBalancerTargetTypeEnum(str, Enum):
    r"""Type of the resource"""
    SERVER = 'server'
    LABEL_SELECTOR = 'label_selector'
    IP = 'ip'


@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class PostLoadBalancers201ApplicationJSONLoadBalancerLoadBalancerTarget:
    
    type: PostLoadBalancers201ApplicationJSONLoadBalancerLoadBalancerTargetTypeEnum = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('type') }})
    r"""Type of the resource"""  
    health_status: Optional[list[PostLoadBalancers201ApplicationJSONLoadBalancerLoadBalancerTargetHealthStatus]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('health_status'), 'exclude': lambda f: f is None }})
    r"""List of health statuses of the services on this target"""  
    ip: Optional[PostLoadBalancers201ApplicationJSONLoadBalancerLoadBalancerTargetIP] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('ip'), 'exclude': lambda f: f is None }})
    r"""IP targets where the traffic should be routed through. It is only possible to use the (Public or vSwitch) IPs of Hetzner Online Root Servers belonging to the project owner. IPs belonging to other users are blocked. Additionally IPs belonging to services provided by Hetzner Cloud (Servers, Load Balancers, ...) are blocked as well."""  
    label_selector: Optional[PostLoadBalancers201ApplicationJSONLoadBalancerLoadBalancerTargetLabelSelector] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('label_selector'), 'exclude': lambda f: f is None }})
    r"""Label selector and a list of selected targets"""  
    server: Optional[PostLoadBalancers201ApplicationJSONLoadBalancerLoadBalancerTargetLoadBalancerTargetServer] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('server'), 'exclude': lambda f: f is None }})
    r"""Server where the traffic should be routed through"""  
    targets: Optional[list[PostLoadBalancers201ApplicationJSONLoadBalancerLoadBalancerTargetTargets]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('targets'), 'exclude': lambda f: f is None }})
    r"""List of selected targets"""  
    use_private_ip: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('use_private_ip'), 'exclude': lambda f: f is None }})
    r"""Use the private network IP instead of the public IP. Default value is false."""  
    

@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class PostLoadBalancers201ApplicationJSONLoadBalancer:
    
    algorithm: PostLoadBalancers201ApplicationJSONLoadBalancerAlgorithm = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('algorithm') }})
    r"""Algorithm of the Load Balancer"""  
    created: str = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('created') }})
    r"""Point in time when the Resource was created (in ISO-8601 format)"""  
    id: int = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('id') }})
    r"""ID of the Resource"""  
    included_traffic: int = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('included_traffic') }})
    r"""Free Traffic for the current billing period in bytes"""  
    ingoing_traffic: int = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('ingoing_traffic') }})
    r"""Inbound Traffic for the current billing period in bytes"""  
    labels: dict[str, str] = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('labels') }})
    r"""User-defined labels (key-value pairs)"""  
    load_balancer_type: PostLoadBalancers201ApplicationJSONLoadBalancerLoadBalancerType = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('load_balancer_type') }})  
    location: PostLoadBalancers201ApplicationJSONLoadBalancerLocation = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('location') }})  
    name: str = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('name') }})
    r"""Name of the Resource. Must be unique per Project."""  
    outgoing_traffic: int = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('outgoing_traffic') }})
    r"""Outbound Traffic for the current billing period in bytes"""  
    private_net: list[PostLoadBalancers201ApplicationJSONLoadBalancerPrivateNet] = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('private_net') }})
    r"""Private networks information"""  
    protection: PostLoadBalancers201ApplicationJSONLoadBalancerProtection = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('protection') }})
    r"""Protection configuration for the Resource"""  
    public_net: PostLoadBalancers201ApplicationJSONLoadBalancerPublicNet = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('public_net') }})
    r"""Public network information"""  
    services: list[PostLoadBalancers201ApplicationJSONLoadBalancerLoadBalancerService] = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('services') }})
    r"""List of services that belong to this Load Balancer"""  
    targets: list[PostLoadBalancers201ApplicationJSONLoadBalancerLoadBalancerTarget] = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('targets') }})
    r"""List of targets that belong to this Load Balancer"""  
    

@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class PostLoadBalancers201ApplicationJSON:
    r"""The `load_balancer` key contains the Load Balancer that was just created"""
    
    action: PostLoadBalancers201ApplicationJSONAction = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('action') }})  
    load_balancer: PostLoadBalancers201ApplicationJSONLoadBalancer = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('load_balancer') }})  
    

@dataclasses.dataclass
class PostLoadBalancersResponse:
    
    content_type: str = dataclasses.field()  
    status_code: int = dataclasses.field()  
    post_load_balancers_201_application_json_object: Optional[PostLoadBalancers201ApplicationJSON] = dataclasses.field(default=None)
    r"""The `load_balancer` key contains the Load Balancer that was just created"""  
    raw_response: Optional[requests_http.Response] = dataclasses.field(default=None)  
    