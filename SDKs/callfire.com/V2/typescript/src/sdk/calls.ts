/*
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

import * as utils from "../internal/utils";
import * as operations from "./models/operations";
import * as shared from "./models/shared";
import { AxiosInstance, AxiosRequestConfig, AxiosResponse } from "axios";

export class Calls {
  _defaultClient: AxiosInstance;
  _securityClient: AxiosInstance;
  _serverURL: string;
  _language: string;
  _sdkVersion: string;
  _genVersion: string;

  constructor(
    defaultClient: AxiosInstance,
    securityClient: AxiosInstance,
    serverURL: string,
    language: string,
    sdkVersion: string,
    genVersion: string
  ) {
    this._defaultClient = defaultClient;
    this._securityClient = securityClient;
    this._serverURL = serverURL;
    this._language = language;
    this._sdkVersion = sdkVersion;
    this._genVersion = genVersion;
  }

  /**
   * Add batches to a call broadcast
   *
   * @remarks
   * The 'add batch' API allows user to add additional batches to an already created voice broadcast campaign. The added batch will go through the CallFire validation process, unlike in the recipients version of this API. That is why you can use the scrubDuplicates flag to remove duplicates from your batch. Batches may be added as a contact list id, a list of contact ids, or a list of numbers
   */
  addCallBroadcastBatch(
    req: operations.AddCallBroadcastBatchRequest,
    security: operations.AddCallBroadcastBatchSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.AddCallBroadcastBatchResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.AddCallBroadcastBatchRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/calls/broadcasts/{id}/batches",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "batchRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.AddCallBroadcastBatchSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.AddCallBroadcastBatchResponse =
        new operations.AddCallBroadcastBatchResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.resourceId = utils.objectToClass(
              httpRes?.data,
              shared.ResourceId
            );
          }
          break;
        case [400, 401, 403, 404, 500].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorResponse = utils.objectToClass(
              httpRes?.data,
              shared.ErrorResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Add recipients to a call broadcast
   *
   * @remarks
   * Use this API to add the recipients to an existing voice broadcast. Post a list of Recipient objects to be added to the voice broadcast campaign. These contacts will not go through validation process, and will be acted upon as they are added. Recipients may be added as a list of contact ids, or list of numbers
   */
  addCallBroadcastRecipients(
    req: operations.AddCallBroadcastRecipientsRequest,
    security: operations.AddCallBroadcastRecipientsSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.AddCallBroadcastRecipientsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.AddCallBroadcastRecipientsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/calls/broadcasts/{id}/recipients",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.AddCallBroadcastRecipientsSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.AddCallBroadcastRecipientsResponse =
        new operations.AddCallBroadcastRecipientsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.callList = utils.objectToClass(httpRes?.data, shared.CallList);
          }
          break;
        case [400, 401, 403, 404, 500].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorResponse = utils.objectToClass(
              httpRes?.data,
              shared.ErrorResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Archive voice broadcast
   *
   * @remarks
   * Archives a voice broadcast (voice broadcast will be hidden in search results)
   */
  archiveVoiceBroadcast(
    req: operations.ArchiveVoiceBroadcastRequest,
    security: operations.ArchiveVoiceBroadcastSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.ArchiveVoiceBroadcastResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ArchiveVoiceBroadcastRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/calls/broadcasts/{id}/archive",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ArchiveVoiceBroadcastSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "post",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ArchiveVoiceBroadcastResponse =
        new operations.ArchiveVoiceBroadcastResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case [400, 401, 403, 404, 500].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorResponse = utils.objectToClass(
              httpRes?.data,
              shared.ErrorResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Create a call broadcast
   *
   * @remarks
   * Creates a call broadcast campaign using the Call Broadcast API. Send a CallBroadcast in the message body to add details in a voice broadcast campaign. The campaign can be created without contacts and bare minimum configuration, but contacts will have to be added further on to use the campaign
   */
  createCallBroadcast(
    req: operations.CreateCallBroadcastRequest,
    security: operations.CreateCallBroadcastSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.CreateCallBroadcastResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CreateCallBroadcastRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/calls/broadcasts";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "callBroadcastInput",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.CreateCallBroadcastSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CreateCallBroadcastResponse =
        new operations.CreateCallBroadcastResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.resourceId = utils.objectToClass(
              httpRes?.data,
              shared.ResourceId
            );
          }
          break;
        case [400, 401, 403, 404, 500].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorResponse = utils.objectToClass(
              httpRes?.data,
              shared.ErrorResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Find call broadcasts
   *
   * @remarks
   * Searches for all voice broadcasts created by user. Can query on label, name, and the current running status of the campaign. Returns a paged list of voice broadcasts
   */
  findCallBroadcasts(
    req: operations.FindCallBroadcastsRequest,
    security: operations.FindCallBroadcastsSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.FindCallBroadcastsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.FindCallBroadcastsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/calls/broadcasts";
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.FindCallBroadcastsSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.FindCallBroadcastsResponse =
        new operations.FindCallBroadcastsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.callBroadcastPage = utils.objectToClass(
              httpRes?.data,
              shared.CallBroadcastPage
            );
          }
          break;
        case [400, 401, 403, 404, 500].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorResponse = utils.objectToClass(
              httpRes?.data,
              shared.ErrorResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Find calls
   *
   * @remarks
   * To search for all calls sent or received by the user. Use "id=0" for the campaignId parameter to query for all calls sent through the POST /calls API. See [call states and results](https://developers.callfire.com/results-responses-errors.html)
   */
  findCalls(
    req: operations.FindCallsRequest,
    security: operations.FindCallsSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.FindCallsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.FindCallsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/calls";
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.FindCallsSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.FindCallsResponse =
        new operations.FindCallsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.callPage = utils.objectToClass(httpRes?.data, shared.CallPage);
          }
          break;
        case [400, 401, 403, 404, 500].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorResponse = utils.objectToClass(
              httpRes?.data,
              shared.ErrorResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Find a specific call
   *
   * @remarks
   * Returns a single Call instance for a given call id.
   */
  getCall(
    req: operations.GetCallRequest,
    security: operations.GetCallSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.GetCallResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetCallRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(baseURL, "/calls/{id}", req);
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.GetCallSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetCallResponse = new operations.GetCallResponse({
        statusCode: httpRes.status,
        contentType: contentType,
        rawResponse: httpRes,
      });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.call = utils.objectToClass(httpRes?.data, shared.Call);
          }
          break;
        case [400, 401, 403, 404, 500].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorResponse = utils.objectToClass(
              httpRes?.data,
              shared.ErrorResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Find a specific call broadcast
   *
   * @remarks
   * Returns a single CallBroadcast instance for a given call broadcast campaign id
   */
  getCallBroadcast(
    req: operations.GetCallBroadcastRequest,
    security: operations.GetCallBroadcastSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.GetCallBroadcastResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetCallBroadcastRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/calls/broadcasts/{id}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.GetCallBroadcastSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetCallBroadcastResponse =
        new operations.GetCallBroadcastResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.callBroadcast = utils.objectToClass(
              httpRes?.data,
              shared.CallBroadcast
            );
          }
          break;
        case [400, 401, 403, 404, 500].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorResponse = utils.objectToClass(
              httpRes?.data,
              shared.ErrorResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Find batches in a call broadcast
   *
   * @remarks
   * This endpoint will enable the user to page through all of the batches for a particular voice broadcast campaign
   */
  getCallBroadcastBatches(
    req: operations.GetCallBroadcastBatchesRequest,
    security: operations.GetCallBroadcastBatchesSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.GetCallBroadcastBatchesResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetCallBroadcastBatchesRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/calls/broadcasts/{id}/batches",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.GetCallBroadcastBatchesSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetCallBroadcastBatchesResponse =
        new operations.GetCallBroadcastBatchesResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.batchPage = utils.objectToClass(
              httpRes?.data,
              shared.BatchPage
            );
          }
          break;
        case [400, 401, 403, 404, 500].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorResponse = utils.objectToClass(
              httpRes?.data,
              shared.ErrorResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Find calls in a call broadcast
   *
   * @remarks
   * This endpoint will enable the user to page through all calls for a particular call broadcast campaign
   */
  getCallBroadcastCalls(
    req: operations.GetCallBroadcastCallsRequest,
    security: operations.GetCallBroadcastCallsSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.GetCallBroadcastCallsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetCallBroadcastCallsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/calls/broadcasts/{id}/calls",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.GetCallBroadcastCallsSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetCallBroadcastCallsResponse =
        new operations.GetCallBroadcastCallsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.callPage = utils.objectToClass(httpRes?.data, shared.CallPage);
          }
          break;
        case [400, 401, 403, 404, 500].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorResponse = utils.objectToClass(
              httpRes?.data,
              shared.ErrorResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Get statistics on call broadcast
   *
   * @remarks
   * Returns broadcast statistics like total number of sent/received actions, total cost, number of remaining outbound actions, error count, etc
   */
  getCallBroadcastStats(
    req: operations.GetCallBroadcastStatsRequest,
    security: operations.GetCallBroadcastStatsSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.GetCallBroadcastStatsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetCallBroadcastStatsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/calls/broadcasts/{id}/stats",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.GetCallBroadcastStatsSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetCallBroadcastStatsResponse =
        new operations.GetCallBroadcastStatsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.callBroadcastStats = utils.objectToClass(
              httpRes?.data,
              shared.CallBroadcastStats
            );
          }
          break;
        case [400, 401, 403, 404, 500].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorResponse = utils.objectToClass(
              httpRes?.data,
              shared.ErrorResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Get call recording by id
   *
   * @remarks
   * Returns metadata of recording of a particular call. Metadata contains a link to a MP3 recording
   */
  getCallRecording(
    req: operations.GetCallRecordingRequest,
    security: operations.GetCallRecordingSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.GetCallRecordingResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetCallRecordingRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/calls/recordings/{id}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.GetCallRecordingSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetCallRecordingResponse =
        new operations.GetCallRecordingResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.callRecording = utils.objectToClass(
              httpRes?.data,
              shared.CallRecording
            );
          }
          break;
        case [400, 401, 403, 404, 500].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorResponse = utils.objectToClass(
              httpRes?.data,
              shared.ErrorResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Get call recording by name
   *
   * @remarks
   * Returns recording metadata of particular call. Metadata contains link to a MP3 recording
   */
  getCallRecordingByName(
    req: operations.GetCallRecordingByNameRequest,
    security: operations.GetCallRecordingByNameSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.GetCallRecordingByNameResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetCallRecordingByNameRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/calls/{id}/recordings/{name}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.GetCallRecordingByNameSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetCallRecordingByNameResponse =
        new operations.GetCallRecordingByNameResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.callRecording = utils.objectToClass(
              httpRes?.data,
              shared.CallRecording
            );
          }
          break;
        case [400, 401, 403, 404, 500].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorResponse = utils.objectToClass(
              httpRes?.data,
              shared.ErrorResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Get call recording in mp3 format
   *
   * @remarks
   * Returns an MP3 recording of particular call, response contains binary data, content type is 'audio/mpeg'
   */
  getCallRecordingMp3(
    req: operations.GetCallRecordingMp3Request,
    security: operations.GetCallRecordingMp3Security,
    config?: AxiosRequestConfig
  ): Promise<operations.GetCallRecordingMp3Response> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetCallRecordingMp3Request(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/calls/recordings/{id}.mp3",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.GetCallRecordingMp3Security(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetCallRecordingMp3Response =
        new operations.GetCallRecordingMp3Response({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.inputStream = utils.objectToClass(httpRes?.data);
          }
          break;
        case [400, 401, 403, 404, 500].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorResponse = utils.objectToClass(
              httpRes?.data,
              shared.ErrorResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Get call mp3 recording by name
   *
   * @remarks
   * Returns a MP3 recording of a particular call, response contains binary data, content type is 'audio/mpeg'
   */
  getCallRecordingMp3ByName(
    req: operations.GetCallRecordingMp3ByNameRequest,
    security: operations.GetCallRecordingMp3ByNameSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.GetCallRecordingMp3ByNameResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetCallRecordingMp3ByNameRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/calls/{id}/recordings/{name}.mp3",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.GetCallRecordingMp3ByNameSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetCallRecordingMp3ByNameResponse =
        new operations.GetCallRecordingMp3ByNameResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case [200, 400, 401, 403, 404, 500].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `audio/mpeg`)) {
            const resBody: string = JSON.stringify(httpRes?.data, null, 0);
            const out: Uint8Array = new Uint8Array(resBody.length);
            for (let i = 0; i < resBody.length; i++)
              out[i] = resBody.charCodeAt(i);
            res.body = out;
          }
          break;
      }

      return res;
    });
  }

  /**
   * Get call recordings for a call
   *
   * @remarks
   * Returns a list of recordings metadata of particular call. Metadata contains link to a MP3 recording
   */
  getCallRecordings(
    req: operations.GetCallRecordingsRequest,
    security: operations.GetCallRecordingsSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.GetCallRecordingsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetCallRecordingsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/calls/{id}/recordings",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.GetCallRecordingsSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetCallRecordingsResponse =
        new operations.GetCallRecordingsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.callRecordingList = utils.objectToClass(
              httpRes?.data,
              shared.CallRecordingList
            );
          }
          break;
        case [400, 401, 403, 404, 500].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorResponse = utils.objectToClass(
              httpRes?.data,
              shared.ErrorResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Send calls
   *
   * @remarks
   * Use the /calls API to send individual calls quickly. A verified Caller ID and sufficient credits are required to make a call. CallRecipient represents a single recipient identified by phone number or contact id in CallFire system. You can attach user-defined attributes to a Call action via CallRecipient.attributes property, attributes are available in Call action response
   */
  sendCalls(
    req: operations.SendCallsRequest,
    security: operations.SendCallsSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.SendCallsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.SendCallsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/calls";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.SendCallsSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.SendCallsResponse =
        new operations.SendCallsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.callList = utils.objectToClass(httpRes?.data, shared.CallList);
          }
          break;
        case [400, 401, 403, 404, 500].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorResponse = utils.objectToClass(
              httpRes?.data,
              shared.ErrorResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Start voice broadcast
   *
   * @remarks
   * Start a voice broadcast
   */
  startVoiceBroadcast(
    req: operations.StartVoiceBroadcastRequest,
    security: operations.StartVoiceBroadcastSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.StartVoiceBroadcastResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.StartVoiceBroadcastRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/calls/broadcasts/{id}/start",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.StartVoiceBroadcastSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "post",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.StartVoiceBroadcastResponse =
        new operations.StartVoiceBroadcastResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case [400, 401, 403, 404, 500].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorResponse = utils.objectToClass(
              httpRes?.data,
              shared.ErrorResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Stop voice broadcast
   *
   * @remarks
   * Stop a voice broadcast
   */
  stopVoiceBroadcast(
    req: operations.StopVoiceBroadcastRequest,
    security: operations.StopVoiceBroadcastSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.StopVoiceBroadcastResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.StopVoiceBroadcastRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/calls/broadcasts/{id}/stop",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.StopVoiceBroadcastSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "post",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.StopVoiceBroadcastResponse =
        new operations.StopVoiceBroadcastResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case [400, 401, 403, 404, 500].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorResponse = utils.objectToClass(
              httpRes?.data,
              shared.ErrorResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Disable/enable undialed recipients in broadcast
   *
   * @remarks
   * This operation lets the user to disable/enable undialed recipients in created broadcast
   */
  toggleCallBroadcastRecipientsStatus(
    req: operations.ToggleCallBroadcastRecipientsStatusRequest,
    security: operations.ToggleCallBroadcastRecipientsStatusSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.ToggleCallBroadcastRecipientsStatusResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ToggleCallBroadcastRecipientsStatusRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/calls/broadcasts/{id}/toggleRecipientsStatus",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ToggleCallBroadcastRecipientsStatusSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ToggleCallBroadcastRecipientsStatusResponse =
        new operations.ToggleCallBroadcastRecipientsStatusResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case [400, 401, 403, 404, 500].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorResponse = utils.objectToClass(
              httpRes?.data,
              shared.ErrorResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Update a call broadcast
   *
   * @remarks
   * This operation lets the user modify the configuration of a voice broadcast campaign after call broadcast campaign is created. See CallBroadcast for more information on what can/can't be updated on this API
   */
  updateCallBroadcast(
    req: operations.UpdateCallBroadcastRequest,
    security: operations.UpdateCallBroadcastSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.UpdateCallBroadcastResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.UpdateCallBroadcastRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/calls/broadcasts/{id}",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "callBroadcastInput",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.UpdateCallBroadcastSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "put",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UpdateCallBroadcastResponse =
        new operations.UpdateCallBroadcastResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case [400, 401, 403, 404, 500].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorResponse = utils.objectToClass(
              httpRes?.data,
              shared.ErrorResponse
            );
          }
          break;
      }

      return res;
    });
  }
}
