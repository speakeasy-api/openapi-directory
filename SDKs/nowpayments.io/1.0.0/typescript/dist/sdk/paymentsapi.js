"use strict";
/*
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.PaymentsAPI = void 0;
var utils = __importStar(require("../internal/utils"));
var operations = __importStar(require("./models/operations"));
var PaymentsAPI = /** @class */ (function () {
    function PaymentsAPI(defaultClient, securityClient, serverURL, language, sdkVersion, genVersion) {
        this._defaultClient = defaultClient;
        this._securityClient = securityClient;
        this._serverURL = serverURL;
        this._language = language;
        this._sdkVersion = sdkVersion;
        this._genVersion = genVersion;
    }
    /**
     * Get estimated price
     *
     * @remarks
     * This is a method for calculating the approximate price in cryptocurrency for a given value in Fiat currency. You will need to provide the initial cost in the Fiat currency (amount, currency_from) and the necessary cryptocurrency (currency_to)
     * Currently following fiat currencies are available: usd, eur, nzd, brl, gbp.
     */
    PaymentsAPI.prototype.getEstimatedPrice = function (req, config) {
        if (!(req instanceof utils.SpeakeasyBase)) {
            req = new operations.GetEstimatedPriceRequest(req);
        }
        var baseURL = this._serverURL;
        var url = baseURL.replace(/\/$/, "") + "/v1/estimate";
        var client = this._defaultClient;
        var headers = __assign(__assign({}, utils.getHeadersFromRequest(req)), config === null || config === void 0 ? void 0 : config.headers);
        var queryParams = utils.serializeQueryParams(req);
        var r = client.request(__assign({ url: url + queryParams, method: "get", headers: headers }, config));
        return r.then(function (httpRes) {
            var _a, _b;
            var contentType = (_b = (_a = httpRes === null || httpRes === void 0 ? void 0 : httpRes.headers) === null || _a === void 0 ? void 0 : _a["content-type"]) !== null && _b !== void 0 ? _b : "";
            if ((httpRes === null || httpRes === void 0 ? void 0 : httpRes.status) == null)
                throw new Error("status code not found in response: ".concat(httpRes));
            var res = new operations.GetEstimatedPriceResponse({
                statusCode: httpRes.status,
                contentType: contentType,
                rawResponse: httpRes,
                headers: utils.getHeadersFromResponse(httpRes.headers),
            });
            switch (true) {
                case (httpRes === null || httpRes === void 0 ? void 0 : httpRes.status) == 200:
                    if (utils.matchContentType(contentType, "application/json")) {
                        res.getEstimatedPrice200ApplicationJSONObject = utils.objectToClass(httpRes === null || httpRes === void 0 ? void 0 : httpRes.data, operations.GetEstimatedPrice200ApplicationJSON);
                    }
                    break;
            }
            return res;
        });
    };
    /**
     * Get list of payments
     *
     * @remarks
     * Returns the entire list of all transactions, created with certain API key.
     * The list of optional parameters:
     * - limit - number of records in one page. (possible values: from 1 to 500)
     * - page - the page number you want to get (possible values: from 0 to **page count - 1**)
     * - sortBy - sort the received list by a paramenter. Set to **created_at** by default (possible values: payment_id, payment_status, pay_address, price_amount, price_currency, pay_amount, actually_paid, pay_currency, order_id, order_description, purchase_id, outcome_amount, outcome_currency)
     * - orderBy - display the list in ascending or descending order. Set to **asc** by default (possible values: asc, desc)
     * - dateFrom - select the displayed period start date (date format: YYYY-MM-DD or yy-MM-ddTHH:mm:ss.SSSZ).
     * - dateTo - select the displayed period end date (date format: YYYY-MM-DD or yy-MM-ddTHH:mm:ss.SSSZ).
     */
    PaymentsAPI.prototype.getListOfPayments = function (req, config) {
        if (!(req instanceof utils.SpeakeasyBase)) {
            req = new operations.GetListOfPaymentsRequest(req);
        }
        var baseURL = this._serverURL;
        var url = baseURL.replace(/\/$/, "") + "/v1/payment/";
        var client = this._defaultClient;
        var headers = __assign(__assign({}, utils.getHeadersFromRequest(req)), config === null || config === void 0 ? void 0 : config.headers);
        var queryParams = utils.serializeQueryParams(req);
        var r = client.request(__assign({ url: url + queryParams, method: "get", headers: headers }, config));
        return r.then(function (httpRes) {
            var _a, _b;
            var contentType = (_b = (_a = httpRes === null || httpRes === void 0 ? void 0 : httpRes.headers) === null || _a === void 0 ? void 0 : _a["content-type"]) !== null && _b !== void 0 ? _b : "";
            if ((httpRes === null || httpRes === void 0 ? void 0 : httpRes.status) == null)
                throw new Error("status code not found in response: ".concat(httpRes));
            var res = new operations.GetListOfPaymentsResponse({
                statusCode: httpRes.status,
                contentType: contentType,
                rawResponse: httpRes,
                headers: utils.getHeadersFromResponse(httpRes.headers),
            });
            switch (true) {
                case (httpRes === null || httpRes === void 0 ? void 0 : httpRes.status) == 200:
                    if (utils.matchContentType(contentType, "application/json")) {
                        res.getListOfPayments200ApplicationJSONObject = utils.objectToClass(httpRes === null || httpRes === void 0 ? void 0 : httpRes.data, operations.GetListOfPayments200ApplicationJSON);
                    }
                    break;
            }
            return res;
        });
    };
    /**
     * Get payment status
     *
     * @remarks
     * Get the actual information about the payment. You need to provide the ID of the payment in the request.
     *
     * NOTE! You should make the get payment status request with the same API key that you used in the create payment request.
     * Here is the list of avalable statuses:
     * - waiting - waiting for the customer to send the payment. The initial status of each payment.
     * - confirming - the transaction is being processed on the blockchain. Appears when NOWPayments detect the funds from the user on the blockchain.
     * - confirmed -  the process is confirmed by the blockchain. Customer’s funds have accumulated enough confirmations.
     * - sending - the funds are being sent to your personal wallet. We are in the process of sending the funds to you.
     * - partially_paid -  it shows that the customer sent the less than the actual price. Appears when the funds have arrived in your wallet.
     * - finished - the funds have reached your personal address and the payment is finished.
     * - failed -  the payment wasn't completed due to the error of some kind.
     * - refunded -  the funds were refunded back to the user.
     * - expired - the user didn't send the funds to the specified address in the 24 hour time window.
     *
     * Additional info:
     * - outcome_amount - this parameter shows the amount that will be (or is already) received on your Outcome Wallet once the transaction is settled.
     * - outcome_currency - this parameter shows the currency in which the transaction will be settled.
     * - invoice_id - this parameter shows invoice ID from which the payment was created
     */
    PaymentsAPI.prototype.getPaymentStatus = function (req, config) {
        if (!(req instanceof utils.SpeakeasyBase)) {
            req = new operations.GetPaymentStatusRequest(req);
        }
        var baseURL = this._serverURL;
        var url = utils.generateURL(baseURL, "/v1/payment/{payment_id}", req);
        var client = this._defaultClient;
        var headers = __assign(__assign({}, utils.getHeadersFromRequest(req)), config === null || config === void 0 ? void 0 : config.headers);
        var r = client.request(__assign({ url: url, method: "get", headers: headers }, config));
        return r.then(function (httpRes) {
            var _a, _b;
            var contentType = (_b = (_a = httpRes === null || httpRes === void 0 ? void 0 : httpRes.headers) === null || _a === void 0 ? void 0 : _a["content-type"]) !== null && _b !== void 0 ? _b : "";
            if ((httpRes === null || httpRes === void 0 ? void 0 : httpRes.status) == null)
                throw new Error("status code not found in response: ".concat(httpRes));
            var res = new operations.GetPaymentStatusResponse({
                statusCode: httpRes.status,
                contentType: contentType,
                rawResponse: httpRes,
                headers: utils.getHeadersFromResponse(httpRes.headers),
            });
            switch (true) {
                case (httpRes === null || httpRes === void 0 ? void 0 : httpRes.status) == 200:
                    if (utils.matchContentType(contentType, "application/json")) {
                        res.getPaymentStatus200ApplicationJSONObject = utils.objectToClass(httpRes === null || httpRes === void 0 ? void 0 : httpRes.data, operations.GetPaymentStatus200ApplicationJSON);
                    }
                    break;
            }
            return res;
        });
    };
    /**
     * Get the minimum payment amount
     *
     * @remarks
     * Get the minimum payment amount for a specific pair.
     *
     * You can provide both currencies in the pair or just currency\_from, and we will calculate the minimum payment amount for currency\_from and currency which you have specified as the outcome in the Store Settings.
     *
     * You can also specify one of the fiat currencies in the currency\_from. In this case, the minimum payment will be calculated in this fiat currency.
     *
     * You can also add field fiat\_equivalent (optional field) to get the fiat equivalent of the minimum amount.
     *
     * In the case of several outcome wallets we will calculate the minimum amount in the same way we route your payment to a specific wallet.
     */
    PaymentsAPI.prototype.getTheMinimumPaymentAmount = function (req, config) {
        if (!(req instanceof utils.SpeakeasyBase)) {
            req = new operations.GetTheMinimumPaymentAmountRequest(req);
        }
        var baseURL = this._serverURL;
        var url = baseURL.replace(/\/$/, "") + "/v1/min-amount";
        var client = this._defaultClient;
        var headers = __assign(__assign({}, utils.getHeadersFromRequest(req)), config === null || config === void 0 ? void 0 : config.headers);
        var queryParams = utils.serializeQueryParams(req);
        var r = client.request(__assign({ url: url + queryParams, method: "get", headers: headers }, config));
        return r.then(function (httpRes) {
            var _a, _b;
            var contentType = (_b = (_a = httpRes === null || httpRes === void 0 ? void 0 : httpRes.headers) === null || _a === void 0 ? void 0 : _a["content-type"]) !== null && _b !== void 0 ? _b : "";
            if ((httpRes === null || httpRes === void 0 ? void 0 : httpRes.status) == null)
                throw new Error("status code not found in response: ".concat(httpRes));
            var res = new operations.GetTheMinimumPaymentAmountResponse({
                statusCode: httpRes.status,
                contentType: contentType,
                rawResponse: httpRes,
                headers: utils.getHeadersFromResponse(httpRes.headers),
            });
            switch (true) {
                case (httpRes === null || httpRes === void 0 ? void 0 : httpRes.status) == 200:
                    if (utils.matchContentType(contentType, "application/json")) {
                        res.getTheMinimumPaymentAmount200ApplicationJSONObject =
                            utils.objectToClass(httpRes === null || httpRes === void 0 ? void 0 : httpRes.data, operations.GetTheMinimumPaymentAmount200ApplicationJSON);
                    }
                    break;
            }
            return res;
        });
    };
    /**
     * Get/Update payment estimate
     *
     * @remarks
     * This endpoint is required to get the current estimate on the payment, and update the current estimate.
     * Please note! Calling this estimate before `expiration_estimate_date` will return the current estimate, it won’t be updated.
     *
     * `:id` \- payment ID, for which you want to get the estimate
     *
     * Response:
     * `id` \- payment ID
     * `token_id` - id of api key used to create this payment (please discard this parameter)
     * `pay_amount` - payment estimate, the exact amount the user will have to send to complete the payment
     * `expiration_estimate_date` - expiration date of this estimate
     */
    PaymentsAPI.prototype.getUpdatePaymentEstimate = function (req, config) {
        if (!(req instanceof utils.SpeakeasyBase)) {
            req = new operations.GetUpdatePaymentEstimateRequest(req);
        }
        var baseURL = this._serverURL;
        var url = utils.generateURL(baseURL, "/v1/payment/{id}/update-merchant-estimate", req);
        var client = this._defaultClient;
        var headers = __assign(__assign({}, utils.getHeadersFromRequest(req)), config === null || config === void 0 ? void 0 : config.headers);
        var r = client.request(__assign({ url: url, method: "post", headers: headers }, config));
        return r.then(function (httpRes) {
            var _a, _b;
            var contentType = (_b = (_a = httpRes === null || httpRes === void 0 ? void 0 : httpRes.headers) === null || _a === void 0 ? void 0 : _a["content-type"]) !== null && _b !== void 0 ? _b : "";
            if ((httpRes === null || httpRes === void 0 ? void 0 : httpRes.status) == null)
                throw new Error("status code not found in response: ".concat(httpRes));
            var res = new operations.GetUpdatePaymentEstimateResponse({
                statusCode: httpRes.status,
                contentType: contentType,
                rawResponse: httpRes,
                headers: utils.getHeadersFromResponse(httpRes.headers),
            });
            switch (true) {
                case (httpRes === null || httpRes === void 0 ? void 0 : httpRes.status) == 200:
                    if (utils.matchContentType(contentType, "application/json")) {
                        res.getUpdatePaymentEstimate200ApplicationJSONObject =
                            utils.objectToClass(httpRes === null || httpRes === void 0 ? void 0 : httpRes.data, operations.GetUpdatePaymentEstimate200ApplicationJSON);
                    }
                    break;
            }
            return res;
        });
    };
    return PaymentsAPI;
}());
exports.PaymentsAPI = PaymentsAPI;
