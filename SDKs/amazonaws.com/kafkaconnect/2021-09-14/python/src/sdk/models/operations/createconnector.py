"""Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT."""

from __future__ import annotations
import dataclasses
import requests as requests_http
from ..shared import apachekafkacluster as shared_apachekafkacluster
from ..shared import autoscaling as shared_autoscaling
from ..shared import createconnectorresponse as shared_createconnectorresponse
from ..shared import kafkaclusterclientauthenticationtype_enum as shared_kafkaclusterclientauthenticationtype_enum
from ..shared import kafkaclusterencryptionintransittype_enum as shared_kafkaclusterencryptionintransittype_enum
from ..shared import plugin as shared_plugin
from ..shared import provisionedcapacity as shared_provisionedcapacity
from ..shared import workerlogdelivery as shared_workerlogdelivery
from dataclasses_json import Undefined, dataclass_json
from sdk import utils
from typing import Any, Optional


@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class CreateConnectorRequestBodyCapacity:
    r"""Information about the capacity of the connector, whether it is auto scaled or provisioned."""
    
    auto_scaling: Optional[shared_autoscaling.AutoScaling] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('autoScaling'), 'exclude': lambda f: f is None }})  
    provisioned_capacity: Optional[shared_provisionedcapacity.ProvisionedCapacity] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('provisionedCapacity'), 'exclude': lambda f: f is None }})  
    

@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class CreateConnectorRequestBodyKafkaCluster:
    r"""The details of the Apache Kafka cluster to which the connector is connected."""
    
    apache_kafka_cluster: Optional[shared_apachekafkacluster.ApacheKafkaCluster] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('apacheKafkaCluster'), 'exclude': lambda f: f is None }})  
    

@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class CreateConnectorRequestBodyKafkaClusterClientAuthentication:
    r"""The client authentication information used in order to authenticate with the Apache Kafka cluster."""
    
    authentication_type: Optional[shared_kafkaclusterclientauthenticationtype_enum.KafkaClusterClientAuthenticationTypeEnum] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('authenticationType'), 'exclude': lambda f: f is None }})  
    

@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class CreateConnectorRequestBodyKafkaClusterEncryptionInTransit:
    r"""Details of encryption in transit to the Apache Kafka cluster."""
    
    encryption_type: Optional[shared_kafkaclusterencryptionintransittype_enum.KafkaClusterEncryptionInTransitTypeEnum] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('encryptionType'), 'exclude': lambda f: f is None }})  
    

@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class CreateConnectorRequestBodyLogDelivery:
    r"""Details about log delivery."""
    
    worker_log_delivery: Optional[shared_workerlogdelivery.WorkerLogDelivery] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('workerLogDelivery'), 'exclude': lambda f: f is None }})  
    

@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class CreateConnectorRequestBodyWorkerConfiguration:
    r"""The configuration of the workers, which are the processes that run the connector logic."""
    
    revision: Optional[int] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('revision'), 'exclude': lambda f: f is None }})  
    worker_configuration_arn: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('workerConfigurationArn'), 'exclude': lambda f: f is None }})  
    

@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class CreateConnectorRequestBody:
    
    capacity: CreateConnectorRequestBodyCapacity = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('capacity') }})
    r"""Information about the capacity of the connector, whether it is auto scaled or provisioned."""  
    connector_configuration: dict[str, str] = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('connectorConfiguration') }})
    r"""A map of keys to values that represent the configuration for the connector."""  
    connector_name: str = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('connectorName') }})
    r"""The name of the connector."""  
    kafka_cluster: CreateConnectorRequestBodyKafkaCluster = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('kafkaCluster') }})
    r"""The details of the Apache Kafka cluster to which the connector is connected."""  
    kafka_cluster_client_authentication: CreateConnectorRequestBodyKafkaClusterClientAuthentication = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('kafkaClusterClientAuthentication') }})
    r"""The client authentication information used in order to authenticate with the Apache Kafka cluster."""  
    kafka_cluster_encryption_in_transit: CreateConnectorRequestBodyKafkaClusterEncryptionInTransit = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('kafkaClusterEncryptionInTransit') }})
    r"""Details of encryption in transit to the Apache Kafka cluster."""  
    kafka_connect_version: str = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('kafkaConnectVersion') }})
    r"""The version of Kafka Connect. It has to be compatible with both the Apache Kafka cluster's version and the plugins."""  
    plugins: list[shared_plugin.Plugin] = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('plugins') }})
    r"""Specifies which plugins to use for the connector."""  
    service_execution_role_arn: str = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('serviceExecutionRoleArn') }})
    r"""The Amazon Resource Name (ARN) of the IAM role used by the connector to access the Amazon Web Services resources that it needs. The types of resources depends on the logic of the connector. For example, a connector that has Amazon S3 as a destination must have permissions that allow it to write to the S3 destination bucket."""  
    connector_description: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('connectorDescription'), 'exclude': lambda f: f is None }})
    r"""A summary description of the connector."""  
    log_delivery: Optional[CreateConnectorRequestBodyLogDelivery] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('logDelivery'), 'exclude': lambda f: f is None }})
    r"""Details about log delivery."""  
    worker_configuration: Optional[CreateConnectorRequestBodyWorkerConfiguration] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('workerConfiguration'), 'exclude': lambda f: f is None }})
    r"""The configuration of the workers, which are the processes that run the connector logic."""  
    

@dataclasses.dataclass
class CreateConnectorRequest:
    
    request_body: CreateConnectorRequestBody = dataclasses.field(metadata={'request': { 'media_type': 'application/json' }})  
    x_amz_algorithm: Optional[str] = dataclasses.field(default=None, metadata={'header': { 'field_name': 'X-Amz-Algorithm', 'style': 'simple', 'explode': False }})  
    x_amz_content_sha256: Optional[str] = dataclasses.field(default=None, metadata={'header': { 'field_name': 'X-Amz-Content-Sha256', 'style': 'simple', 'explode': False }})  
    x_amz_credential: Optional[str] = dataclasses.field(default=None, metadata={'header': { 'field_name': 'X-Amz-Credential', 'style': 'simple', 'explode': False }})  
    x_amz_date: Optional[str] = dataclasses.field(default=None, metadata={'header': { 'field_name': 'X-Amz-Date', 'style': 'simple', 'explode': False }})  
    x_amz_security_token: Optional[str] = dataclasses.field(default=None, metadata={'header': { 'field_name': 'X-Amz-Security-Token', 'style': 'simple', 'explode': False }})  
    x_amz_signature: Optional[str] = dataclasses.field(default=None, metadata={'header': { 'field_name': 'X-Amz-Signature', 'style': 'simple', 'explode': False }})  
    x_amz_signed_headers: Optional[str] = dataclasses.field(default=None, metadata={'header': { 'field_name': 'X-Amz-SignedHeaders', 'style': 'simple', 'explode': False }})  
    

@dataclasses.dataclass
class CreateConnectorResponse:
    
    content_type: str = dataclasses.field()  
    status_code: int = dataclasses.field()  
    bad_request_exception: Optional[Any] = dataclasses.field(default=None)
    r"""BadRequestException"""  
    conflict_exception: Optional[Any] = dataclasses.field(default=None)
    r"""ConflictException"""  
    create_connector_response: Optional[shared_createconnectorresponse.CreateConnectorResponse] = dataclasses.field(default=None)
    r"""Success"""  
    forbidden_exception: Optional[Any] = dataclasses.field(default=None)
    r"""ForbiddenException"""  
    internal_server_error_exception: Optional[Any] = dataclasses.field(default=None)
    r"""InternalServerErrorException"""  
    not_found_exception: Optional[Any] = dataclasses.field(default=None)
    r"""NotFoundException"""  
    raw_response: Optional[requests_http.Response] = dataclasses.field(default=None)  
    service_unavailable_exception: Optional[Any] = dataclasses.field(default=None)
    r"""ServiceUnavailableException"""  
    too_many_requests_exception: Optional[Any] = dataclasses.field(default=None)
    r"""TooManyRequestsException"""  
    unauthorized_exception: Optional[Any] = dataclasses.field(default=None)
    r"""UnauthorizedException"""  
    