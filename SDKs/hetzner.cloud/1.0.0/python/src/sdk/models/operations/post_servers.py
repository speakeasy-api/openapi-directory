"""Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT."""

from __future__ import annotations
import dataclasses
import requests as requests_http
from dataclasses_json import Undefined, dataclass_json
from enum import Enum
from sdk import utils
from typing import Any, Optional


@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class PostServersCreateServerRequestFirewalls:
    
    firewall: Optional[int] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('firewall'), 'exclude': lambda f: f is None }})
    r"""ID of the Firewall"""  
    

@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class PostServersCreateServerRequestPublicNet:
    r"""Public Network options"""
    
    enable_ipv4: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('enable_ipv4'), 'exclude': lambda f: f is None }})
    r"""Attach an IPv4 on the public NIC. If false, no IPv4 address will be attached. Defaults to true."""  
    enable_ipv6: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('enable_ipv6'), 'exclude': lambda f: f is None }})
    r"""Attach an IPv6 on the public NIC. If false, no IPv6 address will be attached. Defaults to true."""  
    ipv4: Optional[int] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('ipv4'), 'exclude': lambda f: f is None }})
    r"""ID of the ipv4 Primary IP to use. If omitted and enable_ipv4 is true, a new ipv4 Primary IP will automatically be created."""  
    ipv6: Optional[int] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('ipv6'), 'exclude': lambda f: f is None }})
    r"""ID of the ipv6 Primary IP to use. If omitted and enable_ipv6 is true, a new ipv6 Primary IP will automatically be created."""  
    

@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class PostServersCreateServerRequest:
    r"""Please note that Server names must be unique per Project and valid hostnames as per RFC 1123 (i.e. may only contain letters, digits, periods, and dashes).
    
    For `server_type` you can either use the ID as listed in `/server_types` or its name.
    
    For `image` you can either use the ID as listed in `/images` or its name.
    
    If you want to create the Server in a Location, you must set `location` to the ID or name as listed in `/locations`. This is the recommended way. You can be even more specific by setting `datacenter` to the ID or name as listed in `/datacenters`. However we only recommend this if you want to assign a specific Primary IP to the Server which is located in the specified Datacenter.
    
    Some properties like `start_after_create` or `automount` will trigger Actions after the Server is created. Those Actions are listed in the `next_actions` field in the response.
    
    For accessing your Server we strongly recommend to use SSH keys by passing the respective key IDs in `ssh_keys`. If you do not specify any `ssh_keys` we will generate a root password for you and return it in the response.
    
    Please note that provided user-data is stored in our systems. While we take measures to protect it we highly recommend that you donâ€™t use it to store passwords or other sensitive information.
    
    #### Call specific error codes
    
    | Code                             | Description                                                |
    |----------------------------------|------------------------------------------------------------|
    | `placement_error`                | An error during the placement occurred                     |
    | `primary_ip_assigned`            | The specified Primary IP is already assigned to a server   |
    | `primary_ip_datacenter_mismatch` | The specified Primary IP is in a different datacenter      |
    | `primary_ip_version_mismatch`    | The specified Primary IP has the wrong IP Version          |
    """
    
    image: str = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('image') }})
    r"""ID or name of the Image the Server is created from"""  
    name: str = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('name') }})
    r"""Name of the Server to create (must be unique per Project and a valid hostname as per RFC 1123)"""  
    server_type: str = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('server_type') }})
    r"""ID or name of the Server type this Server should be created with"""  
    automount: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('automount'), 'exclude': lambda f: f is None }})
    r"""Auto-mount Volumes after attach"""  
    datacenter: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('datacenter'), 'exclude': lambda f: f is None }})
    r"""ID or name of Datacenter to create Server in (must not be used together with location)"""  
    firewalls: Optional[list[PostServersCreateServerRequestFirewalls]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('firewalls'), 'exclude': lambda f: f is None }})
    r"""Firewalls which should be applied on the Server's public network interface at creation time"""  
    labels: Optional[dict[str, Any]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('labels'), 'exclude': lambda f: f is None }})
    r"""User-defined labels (key-value pairs)"""  
    location: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('location'), 'exclude': lambda f: f is None }})
    r"""ID or name of Location to create Server in (must not be used together with datacenter)"""  
    networks: Optional[list[int]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('networks'), 'exclude': lambda f: f is None }})
    r"""Network IDs which should be attached to the Server private network interface at the creation time"""  
    placement_group: Optional[int] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('placement_group'), 'exclude': lambda f: f is None }})
    r"""ID of the Placement Group the server should be in"""  
    public_net: Optional[PostServersCreateServerRequestPublicNet] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('public_net'), 'exclude': lambda f: f is None }})
    r"""Public Network options"""  
    ssh_keys: Optional[list[str]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('ssh_keys'), 'exclude': lambda f: f is None }})
    r"""SSH key IDs (`integer`) or names (`string`) which should be injected into the Server at creation time"""  
    start_after_create: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('start_after_create'), 'exclude': lambda f: f is None }})
    r"""Start Server right after creation. Defaults to true."""  
    user_data: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('user_data'), 'exclude': lambda f: f is None }})
    r"""Cloud-Init user data to use during Server creation. This field is limited to 32KiB."""  
    volumes: Optional[list[int]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('volumes'), 'exclude': lambda f: f is None }})
    r"""Volume IDs which should be attached to the Server at the creation time. Volumes must be in the same Location."""  
    

@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class PostServersCreateServerResponseActionError:
    r"""Error message for the Action if error occurred, otherwise null"""
    
    code: str = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('code') }})
    r"""Fixed machine readable code"""  
    message: str = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('message') }})
    r"""Humanized error message"""  
    

@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class PostServersCreateServerResponseActionResources:
    
    id: int = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('id') }})
    r"""ID of the Resource"""  
    type: str = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('type') }})
    r"""Type of resource referenced"""  
    
class PostServersCreateServerResponseActionStatusEnum(str, Enum):
    r"""Status of the Action"""
    SUCCESS = 'success'
    RUNNING = 'running'
    ERROR = 'error'


@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class PostServersCreateServerResponseAction:
    
    command: str = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('command') }})
    r"""Command executed in the Action"""  
    error: PostServersCreateServerResponseActionError = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('error') }})
    r"""Error message for the Action if error occurred, otherwise null"""  
    finished: str = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('finished') }})
    r"""Point in time when the Action was finished (in ISO-8601 format). Only set if the Action is finished otherwise null."""  
    id: int = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('id') }})
    r"""ID of the Resource"""  
    progress: float = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('progress') }})
    r"""Progress of Action in percent"""  
    resources: list[PostServersCreateServerResponseActionResources] = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('resources') }})
    r"""Resources the Action relates to"""  
    started: str = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('started') }})
    r"""Point in time when the Action was started (in ISO-8601 format)"""  
    status: PostServersCreateServerResponseActionStatusEnum = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('status') }})
    r"""Status of the Action"""  
    

@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class PostServersCreateServerResponseServerDatacenterLocation:
    
    city: str = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('city') }})
    r"""City the Location is closest to"""  
    country: str = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('country') }})
    r"""ISO 3166-1 alpha-2 code of the country the Location resides in"""  
    description: str = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('description') }})
    r"""Description of the Location"""  
    id: float = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('id') }})
    r"""ID of the Location"""  
    latitude: float = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('latitude') }})
    r"""Latitude of the city closest to the Location"""  
    longitude: float = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('longitude') }})
    r"""Longitude of the city closest to the Location"""  
    name: str = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('name') }})
    r"""Unique identifier of the Location"""  
    network_zone: str = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('network_zone') }})
    r"""Name of network zone this Location resides in"""  
    

@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class PostServersCreateServerResponseServerDatacenterServerTypes:
    r"""The Server types the Datacenter can handle"""
    
    available: list[float] = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('available') }})
    r"""IDs of Server types that are supported and for which the Datacenter has enough resources left"""  
    available_for_migration: list[float] = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('available_for_migration') }})
    r"""IDs of Server types that are supported and for which the Datacenter has enough resources left"""  
    supported: list[float] = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('supported') }})
    r"""IDs of Server types that are supported in the Datacenter"""  
    

@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class PostServersCreateServerResponseServerDatacenter:
    r"""Datacenter this Resource is located at"""
    
    description: str = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('description') }})
    r"""Description of the Datacenter"""  
    id: int = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('id') }})
    r"""ID of the Resource"""  
    location: PostServersCreateServerResponseServerDatacenterLocation = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('location') }})  
    name: str = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('name') }})
    r"""Unique identifier of the Datacenter"""  
    server_types: PostServersCreateServerResponseServerDatacenterServerTypes = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('server_types') }})
    r"""The Server types the Datacenter can handle"""  
    

@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class PostServersCreateServerResponseServerImageCreatedFrom:
    r"""Information about the Server the Image was created from"""
    
    id: int = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('id') }})
    r"""ID of the Server the Image was created from"""  
    name: str = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('name') }})
    r"""Server name at the time the Image was created"""  
    
class PostServersCreateServerResponseServerImageOsFlavorEnum(str, Enum):
    r"""Flavor of operating system contained in the Image"""
    UBUNTU = 'ubuntu'
    CENTOS = 'centos'
    DEBIAN = 'debian'
    FEDORA = 'fedora'
    UNKNOWN = 'unknown'


@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class PostServersCreateServerResponseServerImageProtection:
    r"""Protection configuration for the Resource"""
    
    delete: bool = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('delete') }})
    r"""If true, prevents the Resource from being deleted"""  
    
class PostServersCreateServerResponseServerImageStatusEnum(str, Enum):
    r"""Whether the Image can be used or if it's still being created or unavailable"""
    AVAILABLE = 'available'
    CREATING = 'creating'
    UNAVAILABLE = 'unavailable'

class PostServersCreateServerResponseServerImageTypeEnum(str, Enum):
    r"""Type of the Image"""
    SYSTEM = 'system'
    APP = 'app'
    SNAPSHOT = 'snapshot'
    BACKUP = 'backup'
    TEMPORARY = 'temporary'


@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class PostServersCreateServerResponseServerImage:
    
    bound_to: int = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('bound_to') }})
    r"""ID of Server the Image is bound to. Only set for Images of type `backup`."""  
    created: str = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('created') }})
    r"""Point in time when the Resource was created (in ISO-8601 format)"""  
    created_from: PostServersCreateServerResponseServerImageCreatedFrom = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('created_from') }})
    r"""Information about the Server the Image was created from"""  
    deleted: str = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('deleted') }})
    r"""Point in time where the Image was deleted (in ISO-8601 format)"""  
    deprecated: str = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('deprecated') }})
    r"""Point in time when the Image is considered to be deprecated (in ISO-8601 format)"""  
    description: str = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('description') }})
    r"""Description of the Image"""  
    disk_size: float = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('disk_size') }})
    r"""Size of the disk contained in the Image in GB"""  
    id: int = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('id') }})
    r"""ID of the Resource"""  
    image_size: float = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('image_size') }})
    r"""Size of the Image file in our storage in GB. For snapshot Images this is the value relevant for calculating costs for the Image."""  
    labels: dict[str, str] = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('labels') }})
    r"""User-defined labels (key-value pairs)"""  
    name: str = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('name') }})
    r"""Unique identifier of the Image. This value is only set for system Images."""  
    os_flavor: PostServersCreateServerResponseServerImageOsFlavorEnum = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('os_flavor') }})
    r"""Flavor of operating system contained in the Image"""  
    os_version: str = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('os_version') }})
    r"""Operating system version"""  
    protection: PostServersCreateServerResponseServerImageProtection = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('protection') }})
    r"""Protection configuration for the Resource"""  
    status: PostServersCreateServerResponseServerImageStatusEnum = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('status') }})
    r"""Whether the Image can be used or if it's still being created or unavailable"""  
    type: PostServersCreateServerResponseServerImageTypeEnum = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('type') }})
    r"""Type of the Image"""  
    rapid_deploy: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('rapid_deploy'), 'exclude': lambda f: f is None }})
    r"""Indicates that rapid deploy of the Image is available"""  
    
class PostServersCreateServerResponseServerIsoTypeEnum(str, Enum):
    r"""Type of the ISO"""
    PUBLIC = 'public'
    PRIVATE = 'private'


@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class PostServersCreateServerResponseServerIso:
    r"""ISO Image that is attached to this Server. Null if no ISO is attached."""
    
    deprecated: str = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('deprecated') }})
    r"""ISO 8601 timestamp of deprecation, null if ISO is still available. After the deprecation time it will no longer be possible to attach the ISO to Servers."""  
    description: str = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('description') }})
    r"""Description of the ISO"""  
    id: int = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('id') }})
    r"""ID of the Resource"""  
    name: str = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('name') }})
    r"""Unique identifier of the ISO. Only set for public ISOs"""  
    type: PostServersCreateServerResponseServerIsoTypeEnum = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('type') }})
    r"""Type of the ISO"""  
    
class PostServersCreateServerResponseServerPlacementGroupNullableTypeEnum(str, Enum):
    r"""Type of the Placement Group"""
    SPREAD = 'spread'


@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class PostServersCreateServerResponseServerPlacementGroupNullable:
    
    created: str = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('created') }})
    r"""Point in time when the Resource was created (in ISO-8601 format)"""  
    id: int = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('id') }})
    r"""ID of the Resource"""  
    labels: dict[str, str] = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('labels') }})
    r"""User-defined labels (key-value pairs)"""  
    name: str = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('name') }})
    r"""Name of the Resource. Must be unique per Project."""  
    servers: list[int] = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('servers') }})
    r"""Array of IDs of Servers that are part of this Placement Group"""  
    type: PostServersCreateServerResponseServerPlacementGroupNullableTypeEnum = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('type') }})
    r"""Type of the Placement Group"""  
    

@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class PostServersCreateServerResponseServerPrivateNet:
    
    alias_ips: Optional[list[str]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('alias_ips'), 'exclude': lambda f: f is None }})  
    ip: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('ip'), 'exclude': lambda f: f is None }})  
    mac_address: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('mac_address'), 'exclude': lambda f: f is None }})  
    network: Optional[int] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('network'), 'exclude': lambda f: f is None }})  
    

@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class PostServersCreateServerResponseServerProtection:
    r"""Protection configuration for the Server"""
    
    delete: bool = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('delete') }})
    r"""If true, prevents the Server from being deleted"""  
    rebuild: bool = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('rebuild') }})
    r"""If true, prevents the Server from being rebuilt"""  
    
class PostServersCreateServerResponseServerPublicNetServerPublicNetFirewallStatusEnum(str, Enum):
    r"""Status of the Firewall on the Server"""
    APPLIED = 'applied'
    PENDING = 'pending'


@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class PostServersCreateServerResponseServerPublicNetServerPublicNetFirewall:
    
    id: Optional[int] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('id'), 'exclude': lambda f: f is None }})
    r"""ID of the Resource"""  
    status: Optional[PostServersCreateServerResponseServerPublicNetServerPublicNetFirewallStatusEnum] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('status'), 'exclude': lambda f: f is None }})
    r"""Status of the Firewall on the Server"""  
    

@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class PostServersCreateServerResponseServerPublicNetIpv4:
    r"""IP address (v4) and its reverse DNS entry of this Server"""
    
    blocked: bool = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('blocked') }})
    r"""If the IP is blocked by our anti abuse dept"""  
    dns_ptr: str = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('dns_ptr') }})
    r"""Reverse DNS PTR entry for the IPv4 addresses of this Server"""  
    ip: str = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('ip') }})
    r"""IP address (v4) of this Server"""  
    id: Optional[int] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('id'), 'exclude': lambda f: f is None }})
    r"""ID of the Resource"""  
    

@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class PostServersCreateServerResponseServerPublicNetIpv6DNSPtr:
    
    dns_ptr: str = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('dns_ptr') }})
    r"""DNS pointer for the specific IP address"""  
    ip: str = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('ip') }})
    r"""Single IPv6 address of this Server for which the reverse DNS entry has been set up"""  
    

@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class PostServersCreateServerResponseServerPublicNetIpv6:
    r"""IPv6 network assigned to this Server and its reverse DNS entry"""
    
    blocked: bool = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('blocked') }})
    r"""If the IP is blocked by our anti abuse dept"""  
    dns_ptr: list[PostServersCreateServerResponseServerPublicNetIpv6DNSPtr] = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('dns_ptr') }})
    r"""Reverse DNS PTR entries for the IPv6 addresses of this Server, `null` by default"""  
    ip: str = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('ip') }})
    r"""IP address (v6) of this Server"""  
    id: Optional[int] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('id'), 'exclude': lambda f: f is None }})
    r"""ID of the Resource"""  
    

@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class PostServersCreateServerResponseServerPublicNet:
    r"""Public network information. The Server's IPv4 address can be found in `public_net->ipv4->ip`"""
    
    floating_ips: list[int] = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('floating_ips') }})
    r"""IDs of Floating IPs assigned to this Server"""  
    ipv4: PostServersCreateServerResponseServerPublicNetIpv4 = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('ipv4') }})
    r"""IP address (v4) and its reverse DNS entry of this Server"""  
    ipv6: PostServersCreateServerResponseServerPublicNetIpv6 = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('ipv6') }})
    r"""IPv6 network assigned to this Server and its reverse DNS entry"""  
    firewalls: Optional[list[PostServersCreateServerResponseServerPublicNetServerPublicNetFirewall]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('firewalls'), 'exclude': lambda f: f is None }})
    r"""Firewalls applied to the public network interface of this Server"""  
    
class PostServersCreateServerResponseServerServerTypeCPUTypeEnum(str, Enum):
    r"""Type of cpu"""
    SHARED = 'shared'
    DEDICATED = 'dedicated'


@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class PostServersCreateServerResponseServerServerTypePricesPriceHourly:
    r"""Hourly costs for a Server type in this Location"""
    
    gross: str = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('gross') }})
    r"""Price with VAT added"""  
    net: str = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('net') }})
    r"""Price without VAT"""  
    

@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class PostServersCreateServerResponseServerServerTypePricesPriceMonthly:
    r"""Monthly costs for a Server type in this Location"""
    
    gross: str = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('gross') }})
    r"""Price with VAT added"""  
    net: str = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('net') }})
    r"""Price without VAT"""  
    

@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class PostServersCreateServerResponseServerServerTypePrices:
    
    location: str = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('location') }})
    r"""Name of the Location the price is for"""  
    price_hourly: PostServersCreateServerResponseServerServerTypePricesPriceHourly = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('price_hourly') }})
    r"""Hourly costs for a Server type in this Location"""  
    price_monthly: PostServersCreateServerResponseServerServerTypePricesPriceMonthly = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('price_monthly') }})
    r"""Monthly costs for a Server type in this Location"""  
    
class PostServersCreateServerResponseServerServerTypeStorageTypeEnum(str, Enum):
    r"""Type of Server boot drive. Local has higher speed. Network has better availability."""
    LOCAL = 'local'
    NETWORK = 'network'


@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class PostServersCreateServerResponseServerServerType:
    r"""Type of Server - determines how much ram, disk and cpu a Server has"""
    
    cores: float = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('cores') }})
    r"""Number of cpu cores a Server of this type will have"""  
    cpu_type: PostServersCreateServerResponseServerServerTypeCPUTypeEnum = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('cpu_type') }})
    r"""Type of cpu"""  
    deprecated: bool = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('deprecated') }})
    r"""True if Server type is deprecated"""  
    description: str = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('description') }})
    r"""Description of the Server type"""  
    disk: float = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('disk') }})
    r"""Disk size a Server of this type will have in GB"""  
    id: int = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('id') }})
    r"""ID of the Server type"""  
    memory: float = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('memory') }})
    r"""Memory a Server of this type will have in GB"""  
    name: str = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('name') }})
    r"""Unique identifier of the Server type"""  
    prices: list[PostServersCreateServerResponseServerServerTypePrices] = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('prices') }})
    r"""Prices in different Locations"""  
    storage_type: PostServersCreateServerResponseServerServerTypeStorageTypeEnum = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('storage_type') }})
    r"""Type of Server boot drive. Local has higher speed. Network has better availability."""  
    
class PostServersCreateServerResponseServerStatusEnum(str, Enum):
    r"""Status of the Server"""
    RUNNING = 'running'
    INITIALIZING = 'initializing'
    STARTING = 'starting'
    STOPPING = 'stopping'
    OFF = 'off'
    DELETING = 'deleting'
    MIGRATING = 'migrating'
    REBUILDING = 'rebuilding'
    UNKNOWN = 'unknown'


@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class PostServersCreateServerResponseServer:
    
    backup_window: str = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('backup_window') }})
    r"""Time window (UTC) in which the backup will run, or null if the backups are not enabled"""  
    created: str = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('created') }})
    r"""Point in time when the Resource was created (in ISO-8601 format)"""  
    datacenter: PostServersCreateServerResponseServerDatacenter = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('datacenter') }})
    r"""Datacenter this Resource is located at"""  
    id: int = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('id') }})
    r"""ID of the Resource"""  
    image: PostServersCreateServerResponseServerImage = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('image') }})  
    included_traffic: float = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('included_traffic') }})
    r"""Free Traffic for the current billing period in bytes"""  
    ingoing_traffic: float = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('ingoing_traffic') }})
    r"""Inbound Traffic for the current billing period in bytes"""  
    iso: PostServersCreateServerResponseServerIso = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('iso') }})
    r"""ISO Image that is attached to this Server. Null if no ISO is attached."""  
    labels: dict[str, str] = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('labels') }})
    r"""User-defined labels (key-value pairs)"""  
    locked: bool = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('locked') }})
    r"""True if Server has been locked and is not available to user"""  
    name: str = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('name') }})
    r"""Name of the Server (must be unique per Project and a valid hostname as per RFC 1123)"""  
    outgoing_traffic: float = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('outgoing_traffic') }})
    r"""Outbound Traffic for the current billing period in bytes"""  
    primary_disk_size: float = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('primary_disk_size') }})
    r"""Size of the primary Disk"""  
    private_net: list[PostServersCreateServerResponseServerPrivateNet] = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('private_net') }})
    r"""Private networks information"""  
    protection: PostServersCreateServerResponseServerProtection = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('protection') }})
    r"""Protection configuration for the Server"""  
    public_net: PostServersCreateServerResponseServerPublicNet = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('public_net') }})
    r"""Public network information. The Server's IPv4 address can be found in `public_net->ipv4->ip`"""  
    rescue_enabled: bool = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('rescue_enabled') }})
    r"""True if rescue mode is enabled. Server will then boot into rescue system on next reboot"""  
    server_type: PostServersCreateServerResponseServerServerType = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('server_type') }})
    r"""Type of Server - determines how much ram, disk and cpu a Server has"""  
    status: PostServersCreateServerResponseServerStatusEnum = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('status') }})
    r"""Status of the Server"""  
    load_balancers: Optional[list[int]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('load_balancers'), 'exclude': lambda f: f is None }})  
    placement_group: Optional[PostServersCreateServerResponseServerPlacementGroupNullable] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('placement_group'), 'exclude': lambda f: f is None }})  
    volumes: Optional[list[int]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('volumes'), 'exclude': lambda f: f is None }})
    r"""IDs of Volumes assigned to this Server"""  
    

@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class PostServersCreateServerResponse:
    r"""The `server` key in the reply contains a Server object with this structure"""
    
    action: PostServersCreateServerResponseAction = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('action') }})  
    next_actions: list[PostServersCreateServerResponseAction] = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('next_actions') }})  
    root_password: str = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('root_password') }})
    r"""Root password when no SSH keys have been specified"""  
    server: PostServersCreateServerResponseServer = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('server') }})  
    

@dataclasses.dataclass
class PostServersResponse:
    
    content_type: str = dataclasses.field()  
    status_code: int = dataclasses.field()  
    create_server_response: Optional[PostServersCreateServerResponse] = dataclasses.field(default=None)
    r"""The `server` key in the reply contains a Server object with this structure"""  
    raw_response: Optional[requests_http.Response] = dataclasses.field(default=None)  
    