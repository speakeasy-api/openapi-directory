/*
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

import * as utils from "../internal/utils";
import * as operations from "./models/operations";
import * as shared from "./models/shared";
import { AxiosInstance, AxiosRequestConfig, AxiosResponse } from "axios";

export class Texts {
  _defaultClient: AxiosInstance;
  _securityClient: AxiosInstance;
  _serverURL: string;
  _language: string;
  _sdkVersion: string;
  _genVersion: string;

  constructor(
    defaultClient: AxiosInstance,
    securityClient: AxiosInstance,
    serverURL: string,
    language: string,
    sdkVersion: string,
    genVersion: string
  ) {
    this._defaultClient = defaultClient;
    this._securityClient = securityClient;
    this._serverURL = serverURL;
    this._language = language;
    this._sdkVersion = sdkVersion;
    this._genVersion = genVersion;
  }

  /**
   * Add batches to a text broadcast
   *
   * @remarks
   * Allows adding an extra batches to an already created text broadcast campaign. The batches which being  added pass the CallFire validation process (unlike in the recipients version of this API). That is why using of a scrubDuplicates flag remove duplicates from your batch. Batches may be added as a contact list id, a list of contact ids, or a list of numbers
   */
  addTextBroadcastBatch(
    req: operations.AddTextBroadcastBatchRequest,
    security: operations.AddTextBroadcastBatchSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.AddTextBroadcastBatchResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.AddTextBroadcastBatchRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/texts/broadcasts/{id}/batches",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "batchRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.AddTextBroadcastBatchSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.AddTextBroadcastBatchResponse =
        new operations.AddTextBroadcastBatchResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.resourceId = utils.objectToClass(
              httpRes?.data,
              shared.ResourceId
            );
          }
          break;
        case [400, 401, 403, 404, 500].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorResponse = utils.objectToClass(
              httpRes?.data,
              shared.ErrorResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Add recipients to a text broadcast
   *
   * @remarks
   * Use this API to add recipients to a text broadcast which is already created. Post a list of Recipient objects to be immediately added to the text broadcast campaign. These contacts will not go through validation process, and will be acted upon as they are added. Recipients may be added as a list of contact ids, or list of numbers
   */
  addTextBroadcastRecipients(
    req: operations.AddTextBroadcastRecipientsRequest,
    security: operations.AddTextBroadcastRecipientsSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.AddTextBroadcastRecipientsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.AddTextBroadcastRecipientsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/texts/broadcasts/{id}/recipients",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.AddTextBroadcastRecipientsSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.AddTextBroadcastRecipientsResponse =
        new operations.AddTextBroadcastRecipientsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.textList = utils.objectToClass(httpRes?.data, shared.TextList);
          }
          break;
        case [400, 401, 403, 404, 500].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorResponse = utils.objectToClass(
              httpRes?.data,
              shared.ErrorResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Archive text broadcast
   *
   * @remarks
   * Archives a text broadcast (and hides it in the search results)
   */
  archiveTextBroadcast(
    req: operations.ArchiveTextBroadcastRequest,
    security: operations.ArchiveTextBroadcastSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.ArchiveTextBroadcastResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ArchiveTextBroadcastRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/texts/broadcasts/{id}/archive",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ArchiveTextBroadcastSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "post",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ArchiveTextBroadcastResponse =
        new operations.ArchiveTextBroadcastResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case [400, 401, 403, 404, 500].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorResponse = utils.objectToClass(
              httpRes?.data,
              shared.ErrorResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Create an auto reply
   *
   * @remarks
   * CallFire gives you possibility to set up auto reply messages for your numbers and keywords. You can set a general auto reply for anyone who texts your number, keyword, and/or include a text to match, so that the auto reply would be sent only to those who text the matched text
   */
  createTextAutoReply(
    req: shared.TextAutoReply,
    security: operations.CreateTextAutoReplySecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.CreateTextAutoReplyResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new shared.TextAutoReply(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/texts/auto-replys";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "request",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.CreateTextAutoReplySecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CreateTextAutoReplyResponse =
        new operations.CreateTextAutoReplyResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.resourceId = utils.objectToClass(
              httpRes?.data,
              shared.ResourceId
            );
          }
          break;
        case [400, 401, 403, 404, 500].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorResponse = utils.objectToClass(
              httpRes?.data,
              shared.ErrorResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Create a text broadcast
   *
   * @remarks
   * Creates a text broadcast campaign using the Text Broadcast API. Send a TextBroadcast object in the message body to detail a text broadcast campaign. A campaign can be created without contacts and with bare minimum configuration, but contacts have to be added further on to use the campaign. It supports scheduling, retry logic, pattern-based messages.
   */
  createTextBroadcast(
    req: operations.CreateTextBroadcastRequest,
    security: operations.CreateTextBroadcastSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.CreateTextBroadcastResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CreateTextBroadcastRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/texts/broadcasts";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "textBroadcastInput",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.CreateTextBroadcastSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CreateTextBroadcastResponse =
        new operations.CreateTextBroadcastResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.resourceId = utils.objectToClass(
              httpRes?.data,
              shared.ResourceId
            );
          }
          break;
        case [400, 401, 403, 404, 500].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorResponse = utils.objectToClass(
              httpRes?.data,
              shared.ErrorResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Delete an auto reply
   *
   * @remarks
   * Deletes a text auto reply and removes the configuration. Can not delete a TextAutoReply which is currently active for a campaign
   */
  deleteTextAutoReply(
    req: operations.DeleteTextAutoReplyRequest,
    security: operations.DeleteTextAutoReplySecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.DeleteTextAutoReplyResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DeleteTextAutoReplyRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/texts/auto-replys/{id}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.DeleteTextAutoReplySecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DeleteTextAutoReplyResponse =
        new operations.DeleteTextAutoReplyResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case [400, 401, 403, 404, 500].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorResponse = utils.objectToClass(
              httpRes?.data,
              shared.ErrorResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Find auto replies
   *
   * @remarks
   * Find all text autoreplies created by user. Returns a paged list of TextAutoReply
   */
  findTextAutoReplys(
    req: operations.FindTextAutoReplysRequest,
    security: operations.FindTextAutoReplysSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.FindTextAutoReplysResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.FindTextAutoReplysRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/texts/auto-replys";
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.FindTextAutoReplysSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.FindTextAutoReplysResponse =
        new operations.FindTextAutoReplysResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.textAutoReplyPage = utils.objectToClass(
              httpRes?.data,
              shared.TextAutoReplyPage
            );
          }
          break;
        case [400, 401, 403, 404, 500].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorResponse = utils.objectToClass(
              httpRes?.data,
              shared.ErrorResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Find text broadcasts
   *
   * @remarks
   * Searches for all text broadcasts created by user. Can query on label, name, and the current running status of the campaign. Returns a paged list of text broadcasts
   */
  findTextBroadcasts(
    req: operations.FindTextBroadcastsRequest,
    security: operations.FindTextBroadcastsSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.FindTextBroadcastsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.FindTextBroadcastsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/texts/broadcasts";
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.FindTextBroadcastsSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.FindTextBroadcastsResponse =
        new operations.FindTextBroadcastsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.textBroadcastPage = utils.objectToClass(
              httpRes?.data,
              shared.TextBroadcastPage
            );
          }
          break;
        case [400, 401, 403, 404, 500].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorResponse = utils.objectToClass(
              httpRes?.data,
              shared.ErrorResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Find texts
   *
   * @remarks
   * Searches for texts sent or received by user. Use "campaignId=0" parameter to query for all texts sent through the POST /texts API. See [call states and results](https://developers.callfire.com/results-responses-errors.html)
   */
  findTexts(
    req: operations.FindTextsRequest,
    security: operations.FindTextsSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.FindTextsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.FindTextsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/texts";
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.FindTextsSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.FindTextsResponse =
        new operations.FindTextsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.textPage = utils.objectToClass(httpRes?.data, shared.TextPage);
          }
          break;
        case [400, 401, 403, 404, 500].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorResponse = utils.objectToClass(
              httpRes?.data,
              shared.ErrorResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Find a specific text
   *
   * @remarks
   * Returns a single Text instance for a given text id
   */
  getText(
    req: operations.GetTextRequest,
    security: operations.GetTextSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.GetTextResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetTextRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(baseURL, "/texts/{id}", req);
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.GetTextSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetTextResponse = new operations.GetTextResponse({
        statusCode: httpRes.status,
        contentType: contentType,
        rawResponse: httpRes,
      });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.text = utils.objectToClass(httpRes?.data, shared.Text);
          }
          break;
        case [400, 401, 403, 404, 500].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorResponse = utils.objectToClass(
              httpRes?.data,
              shared.ErrorResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Find a specific auto reply
   *
   * @remarks
   * Returns a single TextAutoReply instance for a given text auto reply id
   */
  getTextAutoReply(
    req: operations.GetTextAutoReplyRequest,
    security: operations.GetTextAutoReplySecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.GetTextAutoReplyResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetTextAutoReplyRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/texts/auto-replys/{id}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.GetTextAutoReplySecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetTextAutoReplyResponse =
        new operations.GetTextAutoReplyResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.textAutoReply = utils.objectToClass(
              httpRes?.data,
              shared.TextAutoReply
            );
          }
          break;
        case [400, 401, 403, 404, 500].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorResponse = utils.objectToClass(
              httpRes?.data,
              shared.ErrorResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Find a specific text broadcast
   *
   * @remarks
   * Returns a single TextBroadcast instance for a given text broadcast id
   */
  getTextBroadcast(
    req: operations.GetTextBroadcastRequest,
    security: operations.GetTextBroadcastSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.GetTextBroadcastResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetTextBroadcastRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/texts/broadcasts/{id}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.GetTextBroadcastSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetTextBroadcastResponse =
        new operations.GetTextBroadcastResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.textBroadcast = utils.objectToClass(
              httpRes?.data,
              shared.TextBroadcast
            );
          }
          break;
        case [400, 401, 403, 404, 500].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorResponse = utils.objectToClass(
              httpRes?.data,
              shared.ErrorResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Find batches in a text broadcast
   *
   * @remarks
   * This endpoint will enable the user to page through all of the batches for a particular text broadcast campaign
   */
  getTextBroadcastBatches(
    req: operations.GetTextBroadcastBatchesRequest,
    security: operations.GetTextBroadcastBatchesSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.GetTextBroadcastBatchesResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetTextBroadcastBatchesRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/texts/broadcasts/{id}/batches",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.GetTextBroadcastBatchesSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetTextBroadcastBatchesResponse =
        new operations.GetTextBroadcastBatchesResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.batchPage = utils.objectToClass(
              httpRes?.data,
              shared.BatchPage
            );
          }
          break;
        case [400, 401, 403, 404, 500].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorResponse = utils.objectToClass(
              httpRes?.data,
              shared.ErrorResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Get statistics on text broadcast
   *
   * @remarks
   * Returns the broadcast statistics. Example: total number of the sent/received actions, total cost, number of remaining outbound actions, error count, etc
   */
  getTextBroadcastStats(
    req: operations.GetTextBroadcastStatsRequest,
    security: operations.GetTextBroadcastStatsSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.GetTextBroadcastStatsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetTextBroadcastStatsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/texts/broadcasts/{id}/stats",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.GetTextBroadcastStatsSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetTextBroadcastStatsResponse =
        new operations.GetTextBroadcastStatsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.textBroadcastStatsDto = utils.objectToClass(
              httpRes?.data,
              shared.TextBroadcastStatsDto
            );
          }
          break;
        case [400, 401, 403, 404, 500].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorResponse = utils.objectToClass(
              httpRes?.data,
              shared.ErrorResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Find texts in a text broadcast
   *
   * @remarks
   * This endpoint will enable the user to page through all of the texts for a particular text broadcast campaign
   */
  getTextBroadcastTexts(
    req: operations.GetTextBroadcastTextsRequest,
    security: operations.GetTextBroadcastTextsSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.GetTextBroadcastTextsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetTextBroadcastTextsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/texts/broadcasts/{id}/texts",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.GetTextBroadcastTextsSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetTextBroadcastTextsResponse =
        new operations.GetTextBroadcastTextsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.textPage = utils.objectToClass(httpRes?.data, shared.TextPage);
          }
          break;
        case [400, 401, 403, 404, 500].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorResponse = utils.objectToClass(
              httpRes?.data,
              shared.ErrorResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Send texts
   *
   * @remarks
   * Use the /texts API to send individual texts quickly. By default all texts are going out from CallFire's dedicated short code. Example: 67076, 818818 etc
   */
  sendTexts(
    req: operations.SendTextsRequest,
    security: operations.SendTextsSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.SendTextsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.SendTextsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/texts";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.SendTextsSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.SendTextsResponse =
        new operations.SendTextsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.textList = utils.objectToClass(httpRes?.data, shared.TextList);
          }
          break;
        case [400, 401, 403, 404, 500].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorResponse = utils.objectToClass(
              httpRes?.data,
              shared.ErrorResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Start text broadcast
   *
   * @remarks
   * Starts a text broadcast
   */
  startTextBroadcast(
    req: operations.StartTextBroadcastRequest,
    security: operations.StartTextBroadcastSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.StartTextBroadcastResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.StartTextBroadcastRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/texts/broadcasts/{id}/start",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.StartTextBroadcastSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "post",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.StartTextBroadcastResponse =
        new operations.StartTextBroadcastResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case [400, 401, 403, 404, 500].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorResponse = utils.objectToClass(
              httpRes?.data,
              shared.ErrorResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Stop text broadcast
   *
   * @remarks
   * Stops a text broadcast
   */
  stopTextBroadcast(
    req: operations.StopTextBroadcastRequest,
    security: operations.StopTextBroadcastSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.StopTextBroadcastResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.StopTextBroadcastRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/texts/broadcasts/{id}/stop",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.StopTextBroadcastSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "post",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.StopTextBroadcastResponse =
        new operations.StopTextBroadcastResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case [400, 401, 403, 404, 500].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorResponse = utils.objectToClass(
              httpRes?.data,
              shared.ErrorResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Disable/enable undialed recipients in broadcast
   *
   * @remarks
   * This operation lets the user to disable/enable undialed contacts in created broadcast
   */
  toggleTextBroadcastRecipientsStatus(
    req: operations.ToggleTextBroadcastRecipientsStatusRequest,
    security: operations.ToggleTextBroadcastRecipientsStatusSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.ToggleTextBroadcastRecipientsStatusResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ToggleTextBroadcastRecipientsStatusRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/texts/broadcasts/{id}/toggleRecipientsStatus",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ToggleTextBroadcastRecipientsStatusSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ToggleTextBroadcastRecipientsStatusResponse =
        new operations.ToggleTextBroadcastRecipientsStatusResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case [400, 401, 403, 404, 500].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorResponse = utils.objectToClass(
              httpRes?.data,
              shared.ErrorResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Update a text broadcast
   *
   * @remarks
   * Allows modifying the configuration of existing text broadcast campaign. See TextBroadcast for more information on what can/can't be updated on this API
   */
  updateTextBroadcast(
    req: operations.UpdateTextBroadcastRequest,
    security: operations.UpdateTextBroadcastSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.UpdateTextBroadcastResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.UpdateTextBroadcastRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/texts/broadcasts/{id}",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "textBroadcastInput",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.UpdateTextBroadcastSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "put",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UpdateTextBroadcastResponse =
        new operations.UpdateTextBroadcastResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.textBroadcastCreateResponse = utils.objectToClass(
              httpRes?.data,
              shared.TextBroadcastCreateResponse
            );
          }
          break;
        case [400, 401, 403, 404, 500].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorResponse = utils.objectToClass(
              httpRes?.data,
              shared.ErrorResponse
            );
          }
          break;
      }

      return res;
    });
  }
}
