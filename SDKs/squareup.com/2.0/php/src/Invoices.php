<?php

/**
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

declare(strict_types=1);

namespace OpenAPI\OpenAPI;

class Invoices 
{

	// SDK private variables namespaced with _ to avoid conflicts with API models
	private \GuzzleHttp\ClientInterface $_defaultClient;
	private \GuzzleHttp\ClientInterface $_securityClient;
	private string $_serverUrl;
	private string $_language;
	private string $_sdkVersion;
	private string $_genVersion;	

	/**
	 * @param \GuzzleHttp\ClientInterface $defaultClient
	 * @param \GuzzleHttp\ClientInterface $securityClient
	 * @param string $serverUrl
	 * @param string $language
	 * @param string $sdkVersion
	 * @param string $genVersion
	 */
	public function __construct(\GuzzleHttp\ClientInterface $defaultClient, \GuzzleHttp\ClientInterface $securityClient, string $serverUrl, string $language, string $sdkVersion, string $genVersion)
	{
		$this->_defaultClient = $defaultClient;
		$this->_securityClient = $securityClient;
		$this->_serverUrl = $serverUrl;
		$this->_language = $language;
		$this->_sdkVersion = $sdkVersion;
		$this->_genVersion = $genVersion;
	}
	
    /**
     * CancelInvoice
     * 
     * Cancels an invoice. The seller cannot collect payments for 
     * the canceled invoice.
     * 
     * You cannot cancel an invoice in the `DRAFT` state or in a terminal state: `PAID`, `REFUNDED`, `CANCELED`, or `FAILED`.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\CancelInvoiceRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\CancelInvoiceSecurity $security
     * @return \OpenAPI\OpenAPI\Models\Operations\CancelInvoiceResponse
     */
	public function cancelInvoice(
        \OpenAPI\OpenAPI\Models\Operations\CancelInvoiceRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\CancelInvoiceSecurity $security,
    ): \OpenAPI\OpenAPI\Models\Operations\CancelInvoiceResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v2/invoices/{invoice_id}/cancel', \OpenAPI\OpenAPI\Models\Operations\CancelInvoiceRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "cancelInvoiceRequest", "json");
        if ($body === null) {
            throw new \Exception('Request body is required');
        }
        $options = array_merge_recursive($options, $body);
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\CancelInvoiceResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->cancelInvoiceResponse = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\CancelInvoiceResponse', 'json');
            }
        }

        return $response;
    }
	
    /**
     * CreateInvoice
     * 
     * Creates a draft [invoice](https://developer.squareup.com/reference/square_2021-08-18/objects/Invoice) 
     * for an order created using the Orders API.
     * 
     * A draft invoice remains in your account and no action is taken. 
     * You must publish the invoice before Square can process it (send it to the customer's email address or charge the customerâ€™s card on file).
     * 
     * @param \OpenAPI\OpenAPI\Models\Shared\CreateInvoiceRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\CreateInvoiceSecurity $security
     * @return \OpenAPI\OpenAPI\Models\Operations\CreateInvoiceResponse
     */
	public function createInvoice(
        \OpenAPI\OpenAPI\Models\Shared\CreateInvoiceRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\CreateInvoiceSecurity $security,
    ): \OpenAPI\OpenAPI\Models\Operations\CreateInvoiceResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v2/invoices');
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "request", "json");
        if ($body === null) {
            throw new \Exception('Request body is required');
        }
        $options = array_merge_recursive($options, $body);
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\CreateInvoiceResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->createInvoiceResponse = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\CreateInvoiceResponse', 'json');
            }
        }

        return $response;
    }
	
    /**
     * DeleteInvoice
     * 
     * Deletes the specified invoice. When an invoice is deleted, the 
     * associated order status changes to CANCELED. You can only delete a draft 
     * invoice (you cannot delete a published invoice, including one that is scheduled for processing).
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\DeleteInvoiceRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\DeleteInvoiceSecurity $security
     * @return \OpenAPI\OpenAPI\Models\Operations\DeleteInvoiceResponse
     */
	public function deleteInvoice(
        \OpenAPI\OpenAPI\Models\Operations\DeleteInvoiceRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\DeleteInvoiceSecurity $security,
    ): \OpenAPI\OpenAPI\Models\Operations\DeleteInvoiceResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v2/invoices/{invoice_id}', \OpenAPI\OpenAPI\Models\Operations\DeleteInvoiceRequest::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\DeleteInvoiceRequest::class, $request, null));
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('DELETE', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\DeleteInvoiceResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->deleteInvoiceResponse = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\DeleteInvoiceResponse', 'json');
            }
        }

        return $response;
    }
	
    /**
     * GetInvoice
     * 
     * Retrieves an invoice by invoice ID.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetInvoiceRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\GetInvoiceSecurity $security
     * @return \OpenAPI\OpenAPI\Models\Operations\GetInvoiceResponse
     */
	public function getInvoice(
        \OpenAPI\OpenAPI\Models\Operations\GetInvoiceRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\GetInvoiceSecurity $security,
    ): \OpenAPI\OpenAPI\Models\Operations\GetInvoiceResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v2/invoices/{invoice_id}', \OpenAPI\OpenAPI\Models\Operations\GetInvoiceRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetInvoiceResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->getInvoiceResponse = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\GetInvoiceResponse', 'json');
            }
        }

        return $response;
    }
	
    /**
     * ListInvoices
     * 
     * Returns a list of invoices for a given location. The response 
     * is paginated. If truncated, the response includes a `cursor` that you    
     * use in a subsequent request to retrieve the next set of invoices.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\ListInvoicesRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\ListInvoicesSecurity $security
     * @return \OpenAPI\OpenAPI\Models\Operations\ListInvoicesResponse
     */
	public function listInvoices(
        \OpenAPI\OpenAPI\Models\Operations\ListInvoicesRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\ListInvoicesSecurity $security,
    ): \OpenAPI\OpenAPI\Models\Operations\ListInvoicesResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v2/invoices');
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\ListInvoicesRequest::class, $request, null));
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\ListInvoicesResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->listInvoicesResponse = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\ListInvoicesResponse', 'json');
            }
        }

        return $response;
    }
	
    /**
     * PublishInvoice
     * 
     * Publishes the specified draft invoice. 
     * 
     * After an invoice is published, Square 
     * follows up based on the invoice configuration. For example, Square 
     * sends the invoice to the customer's email address, charges the customer's card on file, or does 
     * nothing. Square also makes the invoice available on a Square-hosted invoice page. 
     * 
     * The invoice `status` also changes from `DRAFT` to a status 
     * based on the invoice configuration. For example, the status changes to `UNPAID` if 
     * Square emails the invoice or `PARTIALLY_PAID` if Square charge a card on file for a portion of the 
     * invoice amount.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\PublishInvoiceRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\PublishInvoiceSecurity $security
     * @return \OpenAPI\OpenAPI\Models\Operations\PublishInvoiceResponse
     */
	public function publishInvoice(
        \OpenAPI\OpenAPI\Models\Operations\PublishInvoiceRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\PublishInvoiceSecurity $security,
    ): \OpenAPI\OpenAPI\Models\Operations\PublishInvoiceResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v2/invoices/{invoice_id}/publish', \OpenAPI\OpenAPI\Models\Operations\PublishInvoiceRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "publishInvoiceRequest", "json");
        if ($body === null) {
            throw new \Exception('Request body is required');
        }
        $options = array_merge_recursive($options, $body);
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\PublishInvoiceResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->publishInvoiceResponse = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\PublishInvoiceResponse', 'json');
            }
        }

        return $response;
    }
	
    /**
     * SearchInvoices
     * 
     * Searches for invoices from a location specified in 
     * the filter. You can optionally specify customers in the filter for whom to 
     * retrieve invoices. In the current implementation, you can only specify one location and 
     * optionally one customer.
     * 
     * The response is paginated. If truncated, the response includes a `cursor` 
     * that you use in a subsequent request to retrieve the next set of invoices.
     * 
     * @param \OpenAPI\OpenAPI\Models\Shared\SearchInvoicesRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\SearchInvoicesSecurity $security
     * @return \OpenAPI\OpenAPI\Models\Operations\SearchInvoicesResponse
     */
	public function searchInvoices(
        \OpenAPI\OpenAPI\Models\Shared\SearchInvoicesRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\SearchInvoicesSecurity $security,
    ): \OpenAPI\OpenAPI\Models\Operations\SearchInvoicesResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v2/invoices/search');
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "request", "json");
        if ($body === null) {
            throw new \Exception('Request body is required');
        }
        $options = array_merge_recursive($options, $body);
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\SearchInvoicesResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->searchInvoicesResponse = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\SearchInvoicesResponse', 'json');
            }
        }

        return $response;
    }
	
    /**
     * UpdateInvoice
     * 
     * Updates an invoice by modifying fields, clearing fields, or both. For most updates, you can use a sparse 
     * `Invoice` object to add fields or change values and use the `fields_to_clear` field to specify fields to clear. 
     * However, some restrictions apply. For example, you cannot change the `order_id` or `location_id` field and you 
     * must provide the complete `custom_fields` list to update a custom field. Published invoices have additional restrictions.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\UpdateInvoiceRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\UpdateInvoiceSecurity $security
     * @return \OpenAPI\OpenAPI\Models\Operations\UpdateInvoiceResponse
     */
	public function updateInvoice(
        \OpenAPI\OpenAPI\Models\Operations\UpdateInvoiceRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\UpdateInvoiceSecurity $security,
    ): \OpenAPI\OpenAPI\Models\Operations\UpdateInvoiceResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v2/invoices/{invoice_id}', \OpenAPI\OpenAPI\Models\Operations\UpdateInvoiceRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "updateInvoiceRequest", "json");
        if ($body === null) {
            throw new \Exception('Request body is required');
        }
        $options = array_merge_recursive($options, $body);
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('PUT', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\UpdateInvoiceResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->updateInvoiceResponse = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\UpdateInvoiceResponse', 'json');
            }
        }

        return $response;
    }
}