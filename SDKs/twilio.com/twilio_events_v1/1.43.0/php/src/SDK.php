<?php

/**
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

declare(strict_types=1);

namespace OpenAPI\OpenAPI;

/**
 * SDK - This is the public Twilio REST API.
 * 
 * @package OpenAPI\OpenAPI
 * @access public
 */
class SDK
{
	public const SERVERS = [
		'https://events.twilio.com',
	];
	
	public const CREATE_SINK_SERVERS = [
		'https://events.twilio.com',
	];
	
	public const CREATE_SINK_TEST_SERVERS = [
		'https://events.twilio.com',
	];
	
	public const CREATE_SINK_VALIDATE_SERVERS = [
		'https://events.twilio.com',
	];
	
	public const CREATE_SUBSCRIBED_EVENT_SERVERS = [
		'https://events.twilio.com',
	];
	
	public const CREATE_SUBSCRIPTION_SERVERS = [
		'https://events.twilio.com',
	];
	
	public const DELETE_SINK_SERVERS = [
		'https://events.twilio.com',
	];
	
	public const DELETE_SUBSCRIBED_EVENT_SERVERS = [
		'https://events.twilio.com',
	];
	
	public const DELETE_SUBSCRIPTION_SERVERS = [
		'https://events.twilio.com',
	];
	
	public const FETCH_EVENT_TYPE_SERVERS = [
		'https://events.twilio.com',
	];
	
	public const FETCH_SCHEMA_SERVERS = [
		'https://events.twilio.com',
	];
	
	public const FETCH_SCHEMA_VERSION_SERVERS = [
		'https://events.twilio.com',
	];
	
	public const FETCH_SINK_SERVERS = [
		'https://events.twilio.com',
	];
	
	public const FETCH_SUBSCRIBED_EVENT_SERVERS = [
		'https://events.twilio.com',
	];
	
	public const FETCH_SUBSCRIPTION_SERVERS = [
		'https://events.twilio.com',
	];
	
	public const LIST_EVENT_TYPE_SERVERS = [
		'https://events.twilio.com',
	];
	
	public const LIST_SCHEMA_VERSION_SERVERS = [
		'https://events.twilio.com',
	];
	
	public const LIST_SINK_SERVERS = [
		'https://events.twilio.com',
	];
	
	public const LIST_SUBSCRIBED_EVENT_SERVERS = [
		'https://events.twilio.com',
	];
	
	public const LIST_SUBSCRIPTION_SERVERS = [
		'https://events.twilio.com',
	];
	
	public const UPDATE_SINK_SERVERS = [
		'https://events.twilio.com',
	];
	
	public const UPDATE_SUBSCRIBED_EVENT_SERVERS = [
		'https://events.twilio.com',
	];
	
	public const UPDATE_SUBSCRIPTION_SERVERS = [
		'https://events.twilio.com',
	];
  		
	// SDK private variables namespaced with _ to avoid conflicts with API models
	private ?\GuzzleHttp\ClientInterface $_defaultClient;
	private ?\GuzzleHttp\ClientInterface $_securityClient;
	
	private string $_serverUrl;
	private string $_language = 'php';
	private string $_sdkVersion = '0.0.1';
	private string $_genVersion = 'internal';

	/**
	 * Returns a new instance of the SDK builder used to configure and create the SDK instance.
	 * 
	 * @return SDKBuilder
	 */
	public static function builder(): SDKBuilder
	{
		return new SDKBuilder();
	}

	/**
	 * @param \GuzzleHttp\ClientInterface|null $client
	 * @param string $serverUrl
	 * @param array<string, string>|null $params
	 */
	public function __construct(?\GuzzleHttp\ClientInterface $client, string $serverUrl, ?array $params)
	{
		$this->_defaultClient = $client;
		
		if ($this->_defaultClient === null) {
			$this->_defaultClient = new \GuzzleHttp\Client([
				'timeout' => 60,
			]);
		}

		$this->_securityClient = null;
		if ($this->_securityClient === null) {
			$this->_securityClient = $this->_defaultClient;
		}

		if (!empty($serverUrl)) {
			$this->_serverUrl = Utils\Utils::templateUrl($serverUrl, $params);
		}
		
		if (empty($this->_serverUrl)) {
			$this->_serverUrl = $this::SERVERS[0];
		}
	}
	
    /**
     * Create a new Sink
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\CreateSinkCreateSinkRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\CreateSinkSecurity $security
     * @param string $serverURL
     * @return \OpenAPI\OpenAPI\Models\Operations\CreateSinkResponse
     */
	public function createSink(
        \OpenAPI\OpenAPI\Models\Operations\CreateSinkCreateSinkRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\CreateSinkSecurity $security,
        ?string $serverURL = null,
    ): \OpenAPI\OpenAPI\Models\Operations\CreateSinkResponse
    {
        $baseUrl = SDK::CREATE_SINK_SERVERS[0];
        if (!empty($serverURL)) {
            $baseUrl = $serverURL;
        }
        
        $url = Utils\Utils::generateUrl($baseUrl, '/v1/Sinks');
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "request", "form");
        $options = array_merge_recursive($options, $body);
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\CreateSinkResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 201) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->eventsV1Sink = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\EventsV1Sink', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Create a new Sink Test Event for the given Sink.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\CreateSinkTestRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\CreateSinkTestSecurity $security
     * @param string $serverURL
     * @return \OpenAPI\OpenAPI\Models\Operations\CreateSinkTestResponse
     */
	public function createSinkTest(
        \OpenAPI\OpenAPI\Models\Operations\CreateSinkTestRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\CreateSinkTestSecurity $security,
        ?string $serverURL = null,
    ): \OpenAPI\OpenAPI\Models\Operations\CreateSinkTestResponse
    {
        $baseUrl = SDK::CREATE_SINK_TEST_SERVERS[0];
        if (!empty($serverURL)) {
            $baseUrl = $serverURL;
        }
        
        $url = Utils\Utils::generateUrl($baseUrl, '/v1/Sinks/{Sid}/Test', \OpenAPI\OpenAPI\Models\Operations\CreateSinkTestRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\CreateSinkTestResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 201) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->eventsV1SinkSinkTest = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\EventsV1SinkSinkTest', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Validate that a test event for a Sink was received.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\CreateSinkValidateRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\CreateSinkValidateSecurity $security
     * @param string $serverURL
     * @return \OpenAPI\OpenAPI\Models\Operations\CreateSinkValidateResponse
     */
	public function createSinkValidate(
        \OpenAPI\OpenAPI\Models\Operations\CreateSinkValidateRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\CreateSinkValidateSecurity $security,
        ?string $serverURL = null,
    ): \OpenAPI\OpenAPI\Models\Operations\CreateSinkValidateResponse
    {
        $baseUrl = SDK::CREATE_SINK_VALIDATE_SERVERS[0];
        if (!empty($serverURL)) {
            $baseUrl = $serverURL;
        }
        
        $url = Utils\Utils::generateUrl($baseUrl, '/v1/Sinks/{Sid}/Validate', \OpenAPI\OpenAPI\Models\Operations\CreateSinkValidateRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "requestBody", "form");
        $options = array_merge_recursive($options, $body);
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\CreateSinkValidateResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 201) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->eventsV1SinkSinkValidate = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\EventsV1SinkSinkValidate', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Create a new Subscribed Event type for the subscription
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\CreateSubscribedEventRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\CreateSubscribedEventSecurity $security
     * @param string $serverURL
     * @return \OpenAPI\OpenAPI\Models\Operations\CreateSubscribedEventResponse
     */
	public function createSubscribedEvent(
        \OpenAPI\OpenAPI\Models\Operations\CreateSubscribedEventRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\CreateSubscribedEventSecurity $security,
        ?string $serverURL = null,
    ): \OpenAPI\OpenAPI\Models\Operations\CreateSubscribedEventResponse
    {
        $baseUrl = SDK::CREATE_SUBSCRIBED_EVENT_SERVERS[0];
        if (!empty($serverURL)) {
            $baseUrl = $serverURL;
        }
        
        $url = Utils\Utils::generateUrl($baseUrl, '/v1/Subscriptions/{SubscriptionSid}/SubscribedEvents', \OpenAPI\OpenAPI\Models\Operations\CreateSubscribedEventRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "requestBody", "form");
        $options = array_merge_recursive($options, $body);
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\CreateSubscribedEventResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 201) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->eventsV1SubscriptionSubscribedEvent = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\EventsV1SubscriptionSubscribedEvent', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Create a new Subscription.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\CreateSubscriptionCreateSubscriptionRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\CreateSubscriptionSecurity $security
     * @param string $serverURL
     * @return \OpenAPI\OpenAPI\Models\Operations\CreateSubscriptionResponse
     */
	public function createSubscription(
        \OpenAPI\OpenAPI\Models\Operations\CreateSubscriptionCreateSubscriptionRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\CreateSubscriptionSecurity $security,
        ?string $serverURL = null,
    ): \OpenAPI\OpenAPI\Models\Operations\CreateSubscriptionResponse
    {
        $baseUrl = SDK::CREATE_SUBSCRIPTION_SERVERS[0];
        if (!empty($serverURL)) {
            $baseUrl = $serverURL;
        }
        
        $url = Utils\Utils::generateUrl($baseUrl, '/v1/Subscriptions');
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "request", "form");
        $options = array_merge_recursive($options, $body);
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\CreateSubscriptionResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 201) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->eventsV1Subscription = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\EventsV1Subscription', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Delete a specific Sink.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\DeleteSinkRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\DeleteSinkSecurity $security
     * @param string $serverURL
     * @return \OpenAPI\OpenAPI\Models\Operations\DeleteSinkResponse
     */
	public function deleteSink(
        \OpenAPI\OpenAPI\Models\Operations\DeleteSinkRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\DeleteSinkSecurity $security,
        ?string $serverURL = null,
    ): \OpenAPI\OpenAPI\Models\Operations\DeleteSinkResponse
    {
        $baseUrl = SDK::DELETE_SINK_SERVERS[0];
        if (!empty($serverURL)) {
            $baseUrl = $serverURL;
        }
        
        $url = Utils\Utils::generateUrl($baseUrl, '/v1/Sinks/{Sid}', \OpenAPI\OpenAPI\Models\Operations\DeleteSinkRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('DELETE', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\DeleteSinkResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 204) {
        }

        return $response;
    }
	
    /**
     * Remove an event type from a subscription.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\DeleteSubscribedEventRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\DeleteSubscribedEventSecurity $security
     * @param string $serverURL
     * @return \OpenAPI\OpenAPI\Models\Operations\DeleteSubscribedEventResponse
     */
	public function deleteSubscribedEvent(
        \OpenAPI\OpenAPI\Models\Operations\DeleteSubscribedEventRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\DeleteSubscribedEventSecurity $security,
        ?string $serverURL = null,
    ): \OpenAPI\OpenAPI\Models\Operations\DeleteSubscribedEventResponse
    {
        $baseUrl = SDK::DELETE_SUBSCRIBED_EVENT_SERVERS[0];
        if (!empty($serverURL)) {
            $baseUrl = $serverURL;
        }
        
        $url = Utils\Utils::generateUrl($baseUrl, '/v1/Subscriptions/{SubscriptionSid}/SubscribedEvents/{Type}', \OpenAPI\OpenAPI\Models\Operations\DeleteSubscribedEventRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('DELETE', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\DeleteSubscribedEventResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 204) {
        }

        return $response;
    }
	
    /**
     * Delete a specific Subscription.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\DeleteSubscriptionRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\DeleteSubscriptionSecurity $security
     * @param string $serverURL
     * @return \OpenAPI\OpenAPI\Models\Operations\DeleteSubscriptionResponse
     */
	public function deleteSubscription(
        \OpenAPI\OpenAPI\Models\Operations\DeleteSubscriptionRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\DeleteSubscriptionSecurity $security,
        ?string $serverURL = null,
    ): \OpenAPI\OpenAPI\Models\Operations\DeleteSubscriptionResponse
    {
        $baseUrl = SDK::DELETE_SUBSCRIPTION_SERVERS[0];
        if (!empty($serverURL)) {
            $baseUrl = $serverURL;
        }
        
        $url = Utils\Utils::generateUrl($baseUrl, '/v1/Subscriptions/{Sid}', \OpenAPI\OpenAPI\Models\Operations\DeleteSubscriptionRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('DELETE', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\DeleteSubscriptionResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 204) {
        }

        return $response;
    }
	
    /**
     * Fetch a specific Event Type.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\FetchEventTypeRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\FetchEventTypeSecurity $security
     * @param string $serverURL
     * @return \OpenAPI\OpenAPI\Models\Operations\FetchEventTypeResponse
     */
	public function fetchEventType(
        \OpenAPI\OpenAPI\Models\Operations\FetchEventTypeRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\FetchEventTypeSecurity $security,
        ?string $serverURL = null,
    ): \OpenAPI\OpenAPI\Models\Operations\FetchEventTypeResponse
    {
        $baseUrl = SDK::FETCH_EVENT_TYPE_SERVERS[0];
        if (!empty($serverURL)) {
            $baseUrl = $serverURL;
        }
        
        $url = Utils\Utils::generateUrl($baseUrl, '/v1/Types/{Type}', \OpenAPI\OpenAPI\Models\Operations\FetchEventTypeRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\FetchEventTypeResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->eventsV1EventType = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\EventsV1EventType', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Fetch a specific schema with its nested versions.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\FetchSchemaRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\FetchSchemaSecurity $security
     * @param string $serverURL
     * @return \OpenAPI\OpenAPI\Models\Operations\FetchSchemaResponse
     */
	public function fetchSchema(
        \OpenAPI\OpenAPI\Models\Operations\FetchSchemaRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\FetchSchemaSecurity $security,
        ?string $serverURL = null,
    ): \OpenAPI\OpenAPI\Models\Operations\FetchSchemaResponse
    {
        $baseUrl = SDK::FETCH_SCHEMA_SERVERS[0];
        if (!empty($serverURL)) {
            $baseUrl = $serverURL;
        }
        
        $url = Utils\Utils::generateUrl($baseUrl, '/v1/Schemas/{Id}', \OpenAPI\OpenAPI\Models\Operations\FetchSchemaRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\FetchSchemaResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->eventsV1Schema = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\EventsV1Schema', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Fetch a specific schema and version.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\FetchSchemaVersionRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\FetchSchemaVersionSecurity $security
     * @param string $serverURL
     * @return \OpenAPI\OpenAPI\Models\Operations\FetchSchemaVersionResponse
     */
	public function fetchSchemaVersion(
        \OpenAPI\OpenAPI\Models\Operations\FetchSchemaVersionRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\FetchSchemaVersionSecurity $security,
        ?string $serverURL = null,
    ): \OpenAPI\OpenAPI\Models\Operations\FetchSchemaVersionResponse
    {
        $baseUrl = SDK::FETCH_SCHEMA_VERSION_SERVERS[0];
        if (!empty($serverURL)) {
            $baseUrl = $serverURL;
        }
        
        $url = Utils\Utils::generateUrl($baseUrl, '/v1/Schemas/{Id}/Versions/{SchemaVersion}', \OpenAPI\OpenAPI\Models\Operations\FetchSchemaVersionRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\FetchSchemaVersionResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->eventsV1SchemaSchemaVersion = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\EventsV1SchemaSchemaVersion', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Fetch a specific Sink.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\FetchSinkRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\FetchSinkSecurity $security
     * @param string $serverURL
     * @return \OpenAPI\OpenAPI\Models\Operations\FetchSinkResponse
     */
	public function fetchSink(
        \OpenAPI\OpenAPI\Models\Operations\FetchSinkRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\FetchSinkSecurity $security,
        ?string $serverURL = null,
    ): \OpenAPI\OpenAPI\Models\Operations\FetchSinkResponse
    {
        $baseUrl = SDK::FETCH_SINK_SERVERS[0];
        if (!empty($serverURL)) {
            $baseUrl = $serverURL;
        }
        
        $url = Utils\Utils::generateUrl($baseUrl, '/v1/Sinks/{Sid}', \OpenAPI\OpenAPI\Models\Operations\FetchSinkRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\FetchSinkResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->eventsV1Sink = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\EventsV1Sink', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Read an Event for a Subscription.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\FetchSubscribedEventRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\FetchSubscribedEventSecurity $security
     * @param string $serverURL
     * @return \OpenAPI\OpenAPI\Models\Operations\FetchSubscribedEventResponse
     */
	public function fetchSubscribedEvent(
        \OpenAPI\OpenAPI\Models\Operations\FetchSubscribedEventRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\FetchSubscribedEventSecurity $security,
        ?string $serverURL = null,
    ): \OpenAPI\OpenAPI\Models\Operations\FetchSubscribedEventResponse
    {
        $baseUrl = SDK::FETCH_SUBSCRIBED_EVENT_SERVERS[0];
        if (!empty($serverURL)) {
            $baseUrl = $serverURL;
        }
        
        $url = Utils\Utils::generateUrl($baseUrl, '/v1/Subscriptions/{SubscriptionSid}/SubscribedEvents/{Type}', \OpenAPI\OpenAPI\Models\Operations\FetchSubscribedEventRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\FetchSubscribedEventResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->eventsV1SubscriptionSubscribedEvent = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\EventsV1SubscriptionSubscribedEvent', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Fetch a specific Subscription.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\FetchSubscriptionRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\FetchSubscriptionSecurity $security
     * @param string $serverURL
     * @return \OpenAPI\OpenAPI\Models\Operations\FetchSubscriptionResponse
     */
	public function fetchSubscription(
        \OpenAPI\OpenAPI\Models\Operations\FetchSubscriptionRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\FetchSubscriptionSecurity $security,
        ?string $serverURL = null,
    ): \OpenAPI\OpenAPI\Models\Operations\FetchSubscriptionResponse
    {
        $baseUrl = SDK::FETCH_SUBSCRIPTION_SERVERS[0];
        if (!empty($serverURL)) {
            $baseUrl = $serverURL;
        }
        
        $url = Utils\Utils::generateUrl($baseUrl, '/v1/Subscriptions/{Sid}', \OpenAPI\OpenAPI\Models\Operations\FetchSubscriptionRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\FetchSubscriptionResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->eventsV1Subscription = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\EventsV1Subscription', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Retrieve a paginated list of all the available Event Types.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\ListEventTypeRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\ListEventTypeSecurity $security
     * @param string $serverURL
     * @return \OpenAPI\OpenAPI\Models\Operations\ListEventTypeResponse
     */
	public function listEventType(
        \OpenAPI\OpenAPI\Models\Operations\ListEventTypeRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\ListEventTypeSecurity $security,
        ?string $serverURL = null,
    ): \OpenAPI\OpenAPI\Models\Operations\ListEventTypeResponse
    {
        $baseUrl = SDK::LIST_EVENT_TYPE_SERVERS[0];
        if (!empty($serverURL)) {
            $baseUrl = $serverURL;
        }
        
        $url = Utils\Utils::generateUrl($baseUrl, '/v1/Types');
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\ListEventTypeRequest::class, $request, null));
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\ListEventTypeResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->listEventTypeResponse = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Operations\ListEventTypeListEventTypeResponse', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Retrieve a paginated list of versions of the schema.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\ListSchemaVersionRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\ListSchemaVersionSecurity $security
     * @param string $serverURL
     * @return \OpenAPI\OpenAPI\Models\Operations\ListSchemaVersionResponse
     */
	public function listSchemaVersion(
        \OpenAPI\OpenAPI\Models\Operations\ListSchemaVersionRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\ListSchemaVersionSecurity $security,
        ?string $serverURL = null,
    ): \OpenAPI\OpenAPI\Models\Operations\ListSchemaVersionResponse
    {
        $baseUrl = SDK::LIST_SCHEMA_VERSION_SERVERS[0];
        if (!empty($serverURL)) {
            $baseUrl = $serverURL;
        }
        
        $url = Utils\Utils::generateUrl($baseUrl, '/v1/Schemas/{Id}/Versions', \OpenAPI\OpenAPI\Models\Operations\ListSchemaVersionRequest::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\ListSchemaVersionRequest::class, $request, null));
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\ListSchemaVersionResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->listSchemaVersionResponse = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Operations\ListSchemaVersionListSchemaVersionResponse', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Retrieve a paginated list of Sinks belonging to the account used to make the request.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\ListSinkRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\ListSinkSecurity $security
     * @param string $serverURL
     * @return \OpenAPI\OpenAPI\Models\Operations\ListSinkResponse
     */
	public function listSink(
        \OpenAPI\OpenAPI\Models\Operations\ListSinkRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\ListSinkSecurity $security,
        ?string $serverURL = null,
    ): \OpenAPI\OpenAPI\Models\Operations\ListSinkResponse
    {
        $baseUrl = SDK::LIST_SINK_SERVERS[0];
        if (!empty($serverURL)) {
            $baseUrl = $serverURL;
        }
        
        $url = Utils\Utils::generateUrl($baseUrl, '/v1/Sinks');
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\ListSinkRequest::class, $request, null));
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\ListSinkResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->listSinkResponse = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Operations\ListSinkListSinkResponse', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Retrieve a list of all Subscribed Event types for a Subscription.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\ListSubscribedEventRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\ListSubscribedEventSecurity $security
     * @param string $serverURL
     * @return \OpenAPI\OpenAPI\Models\Operations\ListSubscribedEventResponse
     */
	public function listSubscribedEvent(
        \OpenAPI\OpenAPI\Models\Operations\ListSubscribedEventRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\ListSubscribedEventSecurity $security,
        ?string $serverURL = null,
    ): \OpenAPI\OpenAPI\Models\Operations\ListSubscribedEventResponse
    {
        $baseUrl = SDK::LIST_SUBSCRIBED_EVENT_SERVERS[0];
        if (!empty($serverURL)) {
            $baseUrl = $serverURL;
        }
        
        $url = Utils\Utils::generateUrl($baseUrl, '/v1/Subscriptions/{SubscriptionSid}/SubscribedEvents', \OpenAPI\OpenAPI\Models\Operations\ListSubscribedEventRequest::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\ListSubscribedEventRequest::class, $request, null));
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\ListSubscribedEventResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->listSubscribedEventResponse = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Operations\ListSubscribedEventListSubscribedEventResponse', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Retrieve a paginated list of Subscriptions belonging to the account used to make the request.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\ListSubscriptionRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\ListSubscriptionSecurity $security
     * @param string $serverURL
     * @return \OpenAPI\OpenAPI\Models\Operations\ListSubscriptionResponse
     */
	public function listSubscription(
        \OpenAPI\OpenAPI\Models\Operations\ListSubscriptionRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\ListSubscriptionSecurity $security,
        ?string $serverURL = null,
    ): \OpenAPI\OpenAPI\Models\Operations\ListSubscriptionResponse
    {
        $baseUrl = SDK::LIST_SUBSCRIPTION_SERVERS[0];
        if (!empty($serverURL)) {
            $baseUrl = $serverURL;
        }
        
        $url = Utils\Utils::generateUrl($baseUrl, '/v1/Subscriptions');
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\ListSubscriptionRequest::class, $request, null));
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\ListSubscriptionResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->listSubscriptionResponse = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Operations\ListSubscriptionListSubscriptionResponse', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Update a specific Sink
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\UpdateSinkRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\UpdateSinkSecurity $security
     * @param string $serverURL
     * @return \OpenAPI\OpenAPI\Models\Operations\UpdateSinkResponse
     */
	public function updateSink(
        \OpenAPI\OpenAPI\Models\Operations\UpdateSinkRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\UpdateSinkSecurity $security,
        ?string $serverURL = null,
    ): \OpenAPI\OpenAPI\Models\Operations\UpdateSinkResponse
    {
        $baseUrl = SDK::UPDATE_SINK_SERVERS[0];
        if (!empty($serverURL)) {
            $baseUrl = $serverURL;
        }
        
        $url = Utils\Utils::generateUrl($baseUrl, '/v1/Sinks/{Sid}', \OpenAPI\OpenAPI\Models\Operations\UpdateSinkRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "requestBody", "form");
        $options = array_merge_recursive($options, $body);
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\UpdateSinkResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->eventsV1Sink = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\EventsV1Sink', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Update an Event for a Subscription.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\UpdateSubscribedEventRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\UpdateSubscribedEventSecurity $security
     * @param string $serverURL
     * @return \OpenAPI\OpenAPI\Models\Operations\UpdateSubscribedEventResponse
     */
	public function updateSubscribedEvent(
        \OpenAPI\OpenAPI\Models\Operations\UpdateSubscribedEventRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\UpdateSubscribedEventSecurity $security,
        ?string $serverURL = null,
    ): \OpenAPI\OpenAPI\Models\Operations\UpdateSubscribedEventResponse
    {
        $baseUrl = SDK::UPDATE_SUBSCRIBED_EVENT_SERVERS[0];
        if (!empty($serverURL)) {
            $baseUrl = $serverURL;
        }
        
        $url = Utils\Utils::generateUrl($baseUrl, '/v1/Subscriptions/{SubscriptionSid}/SubscribedEvents/{Type}', \OpenAPI\OpenAPI\Models\Operations\UpdateSubscribedEventRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "requestBody", "form");
        $options = array_merge_recursive($options, $body);
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\UpdateSubscribedEventResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->eventsV1SubscriptionSubscribedEvent = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\EventsV1SubscriptionSubscribedEvent', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Update a Subscription.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\UpdateSubscriptionRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\UpdateSubscriptionSecurity $security
     * @param string $serverURL
     * @return \OpenAPI\OpenAPI\Models\Operations\UpdateSubscriptionResponse
     */
	public function updateSubscription(
        \OpenAPI\OpenAPI\Models\Operations\UpdateSubscriptionRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\UpdateSubscriptionSecurity $security,
        ?string $serverURL = null,
    ): \OpenAPI\OpenAPI\Models\Operations\UpdateSubscriptionResponse
    {
        $baseUrl = SDK::UPDATE_SUBSCRIPTION_SERVERS[0];
        if (!empty($serverURL)) {
            $baseUrl = $serverURL;
        }
        
        $url = Utils\Utils::generateUrl($baseUrl, '/v1/Subscriptions/{Sid}', \OpenAPI\OpenAPI\Models\Operations\UpdateSubscriptionRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "requestBody", "form");
        $options = array_merge_recursive($options, $body);
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\UpdateSubscriptionResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->eventsV1Subscription = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\EventsV1Subscription', 'json');
            }
        }

        return $response;
    }
}