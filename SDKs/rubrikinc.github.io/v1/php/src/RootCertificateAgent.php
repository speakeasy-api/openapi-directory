<?php

/**
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

declare(strict_types=1);

namespace OpenAPI\OpenAPI;

class RootCertificateAgent 
{

	// SDK private variables namespaced with _ to avoid conflicts with API models
	private \GuzzleHttp\ClientInterface $_defaultClient;
	private \GuzzleHttp\ClientInterface $_securityClient;
	private string $_serverUrl;
	private string $_language;
	private string $_sdkVersion;
	private string $_genVersion;	

	/**
	 * @param \GuzzleHttp\ClientInterface $defaultClient
	 * @param \GuzzleHttp\ClientInterface $securityClient
	 * @param string $serverUrl
	 * @param string $language
	 * @param string $sdkVersion
	 * @param string $genVersion
	 */
	public function __construct(\GuzzleHttp\ClientInterface $defaultClient, \GuzzleHttp\ClientInterface $securityClient, string $serverUrl, string $language, string $sdkVersion, string $genVersion)
	{
		$this->_defaultClient = $defaultClient;
		$this->_securityClient = $securityClient;
		$this->_serverUrl = $serverUrl;
		$this->_language = $language;
		$this->_sdkVersion = $sdkVersion;
		$this->_genVersion = $genVersion;
	}
	
    /**
     * Mark a certificate to be added to agents
     * 
     * Mark a secondary cluster certificate to be asynchronously synced to all Rubrik Backup Service instances for which this cluster is the primary.
     * 
     * @param string $request
     * @return \OpenAPI\OpenAPI\Models\Operations\MarkAgentSecondaryCertificateResponse
     */
	public function markAgentSecondaryCertificate(
        string $request,
    ): \OpenAPI\OpenAPI\Models\Operations\MarkAgentSecondaryCertificateResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/certificate/agent');
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "request", "string");
        if ($body === null) {
            throw new \Exception('Request body is required');
        }
        $options = array_merge_recursive($options, $body);
        
        $httpResponse = $this->_securityClient->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\MarkAgentSecondaryCertificateResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 201) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->agentSecondaryCertificateInfo = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\AgentSecondaryCertificateInfo', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Get all potential agent secondary cluster certificates
     * 
     * Get all certificates that have been added to the cluster and qualify to be secondary cluster certificates for the Rubrik Backup Service. This call retrieves any certificates that are detected to be Rubrik cluster certificates.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\QueryAgentSecondaryCertificateRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\QueryAgentSecondaryCertificateResponse
     */
	public function queryAgentSecondaryCertificate(
        \OpenAPI\OpenAPI\Models\Operations\QueryAgentSecondaryCertificateRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\QueryAgentSecondaryCertificateResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/certificate/agent');
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\QueryAgentSecondaryCertificateRequest::class, $request, null));
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\QueryAgentSecondaryCertificateResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->agentSecondaryCertificateInfoListResponse = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\AgentSecondaryCertificateInfoListResponse', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Unmark a certificate that was previously marked
     * 
     * Unmark a previously marked secondary cluster certificate to be asynchronously removed from all Rubrik Backup Service instances for which this cluster is the primary.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\UnmarkAgentSecondaryCertificateRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\UnmarkAgentSecondaryCertificateResponse
     */
	public function unmarkAgentSecondaryCertificate(
        \OpenAPI\OpenAPI\Models\Operations\UnmarkAgentSecondaryCertificateRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\UnmarkAgentSecondaryCertificateResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/certificate/agent/{id}', \OpenAPI\OpenAPI\Models\Operations\UnmarkAgentSecondaryCertificateRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_securityClient->request('DELETE', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\UnmarkAgentSecondaryCertificateResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 204) {
        }

        return $response;
    }
}