"""Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT."""

import requests as requests_http
from . import utils
from sdk.models import operations, shared
from typing import Optional

class AppPkgm:
    r"""App Package management"""
    _client: requests_http.Session
    _security_client: requests_http.Session
    _server_url: str
    _language: str
    _sdk_version: str
    _gen_version: str

    def __init__(self, client: requests_http.Session, security_client: requests_http.Session, server_url: str, language: str, sdk_version: str, gen_version: str) -> None:
        self._client = client
        self._security_client = security_client
        self._server_url = server_url
        self._language = language
        self._sdk_version = sdk_version
        self._gen_version = gen_version
        
    def app_dget(self, request: operations.AppDGETRequest) -> operations.AppDGETResponse:
        r"""Reads the content of the AppD of on-boarded individual application package resources.
        Reads the content of the AppD of on-boarded individual application package resources.
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.AppDGETRequest, base_url, '/onboarded_app_packages/{appDId}/appd', request)
        
        query_params = utils.get_query_params(operations.AppDGETRequest, request)
        
        client = self._client
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.AppDGETResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/zip'):
                res.body = http_res.content
            if utils.match_content_type(content_type, 'text/plain'):
                res.app_d = http_res.content
        elif http_res.status_code in [400, 401, 403, 404, 406, 429]:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ProblemDetails])
                res.problem_details = out

        return res

    def app_d_id_get(self, request: operations.AppDIDGETRequest) -> operations.AppDIDGETResponse:
        r"""Fetch the onboarded application package content identified by appPkgId or appDId.
        Fetch the onboarded application package content identified by appPkgId or appDId.
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.AppDIDGETRequest, base_url, '/onboarded_app_packages/{appDId}/package_content', request)
        
        
        client = self._client
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.AppDIDGETResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code in [200, 206, 416]:
            pass
        elif http_res.status_code in [400, 401, 403, 404, 406, 429]:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ProblemDetails])
                res.problem_details = out

        return res

    def app_d_id_put(self, request: operations.AppDIDPUTRequest) -> operations.AppDIDPUTResponse:
        r"""Uploads the content of application package.
        Uploads the content of application package.
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.AppDIDPUTRequest, base_url, '/onboarded_app_packages/{appDId}/package_content', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'raw')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        
        client = self._client
        
        http_res = client.request('PUT', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.AppDIDPUTResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 202:
            pass
        elif http_res.status_code in [400, 401, 403, 404, 406, 409, 429]:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ProblemDetails])
                res.problem_details = out

        return res

    def app_pkg_get(self, request: operations.AppPkgGETRequest) -> operations.AppPkgGETResponse:
        r"""Fetch the onboarded application package content identified by appPkgId or appDId.
        Fetch the onboarded application package content identified by appPkgId or appDId.
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.AppPkgGETRequest, base_url, '/app_packages/{appPkgId}/package_content', request)
        
        
        client = self._client
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.AppPkgGETResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code in [200, 206, 416]:
            pass
        elif http_res.status_code in [400, 401, 403, 404, 406, 429]:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ProblemDetails])
                res.problem_details = out

        return res

    def app_pkg_id_get(self, request: operations.AppPkgIDGETRequest) -> operations.AppPkgIDGETResponse:
        r"""Reads the content of the AppD of on-boarded individual application package resources.
        Reads the content of the AppD of on-boarded individual application package resources.
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.AppPkgIDGETRequest, base_url, '/app_packages/{appPkgId}/appd', request)
        
        query_params = utils.get_query_params(operations.AppPkgIDGETRequest, request)
        
        client = self._client
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.AppPkgIDGETResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/zip'):
                res.body = http_res.content
            if utils.match_content_type(content_type, 'text/plain'):
                res.app_d = http_res.content
        elif http_res.status_code in [400, 401, 403, 404, 406, 429]:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ProblemDetails])
                res.problem_details = out

        return res

    def app_pkg_put(self, request: operations.AppPkgPUTRequest) -> operations.AppPkgPUTResponse:
        r"""Uploads the content of application package.
        Uploads the content of application package.
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.AppPkgPUTRequest, base_url, '/app_packages/{appPkgId}/package_content', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'raw')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        
        client = self._client
        
        http_res = client.request('PUT', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.AppPkgPUTResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 202:
            pass
        elif http_res.status_code in [400, 401, 403, 404, 406, 409, 429]:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ProblemDetails])
                res.problem_details = out

        return res

    def app_package_delete(self, request: operations.AppPackageDELETERequest) -> operations.AppPackageDELETEResponse:
        r"""Deletes an individual application package resources
        Deletes an individual application package resources
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.AppPackageDELETERequest, base_url, '/app_packages/{appPkgId}', request)
        
        
        client = self._client
        
        http_res = client.request('DELETE', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.AppPackageDELETEResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 204:
            pass
        elif http_res.status_code in [400, 401, 403, 404, 406, 429]:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ProblemDetails])
                res.problem_details = out

        return res

    def app_package_get(self, request: operations.AppPackageGETRequest) -> operations.AppPackageGETResponse:
        r"""Queries the information related to individual application package resources
        Queries the information related to individual application package resources
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.AppPackageGETRequest, base_url, '/app_packages/{appPkgId}', request)
        
        
        client = self._client
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.AppPackageGETResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.AppPkgInfo])
                res.app_pkg_info = out
        elif http_res.status_code in [400, 401, 403, 404, 406, 429]:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ProblemDetails])
                res.problem_details = out

        return res

    def app_package_patch(self, request: operations.AppPackagePATCHRequest) -> operations.AppPackagePATCHResponse:
        r"""Updates the operational state of an individual application package resource
        Updates the operational state of an individual application package resources
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.AppPackagePATCHRequest, base_url, '/app_packages/{appPkgId}', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "app_pkg_info_modifications", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = self._client
        
        http_res = client.request('PATCH', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.AppPackagePATCHResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.AppPkgInfoModifications])
                res.app_pkg_info_modifications = out
        elif http_res.status_code in [400, 401, 403, 404, 406, 409, 429]:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ProblemDetails])
                res.problem_details = out

        return res

    def app_packages_get(self, request: operations.AppPackagesGETRequest) -> operations.AppPackagesGETResponse:
        r"""Queries information relating to on-boarded application packages in the MEO
        queries information relating to on-boarded application packages in the MEO
        """
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/app_packages'
        
        query_params = utils.get_query_params(operations.AppPackagesGETRequest, request)
        
        client = self._client
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.AppPackagesGETResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[list[shared.AppPkgInfo]])
                res.app_pkg_infos = out
        elif http_res.status_code in [400, 401, 403, 404, 406, 429]:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ProblemDetails])
                res.problem_details = out

        return res

    def app_packages_post(self, request: shared.CreateAppPkg) -> operations.AppPackagesPOSTResponse:
        r"""Create a resource for on-boarding an application package to a MEO
        Create a resource for on-boarding an application package to a MEO
        """
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/app_packages'
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = self._client
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.AppPackagesPOSTResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 201:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[list[shared.AppPkgInfo]])
                res.app_pkg_infos = out
        elif http_res.status_code in [400, 401, 403, 404, 406, 429]:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ProblemDetails])
                res.problem_details = out

        return res

    def individual_subscription_delete(self, request: operations.IndividualSubscriptionDELETERequest) -> operations.IndividualSubscriptionDELETEResponse:
        r"""Deletes the individual subscription to notifications about application package changes in MEO.
        Deletes the individual subscription to notifications about application package changes in MEO.
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.IndividualSubscriptionDELETERequest, base_url, '/subscriptions/{subscriptionId}', request)
        
        
        client = self._client
        
        http_res = client.request('DELETE', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.IndividualSubscriptionDELETEResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 204:
            pass
        elif http_res.status_code in [401, 403, 404, 429]:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ProblemDetails])
                res.problem_details = out

        return res

    def individual_subscription_get(self, request: operations.IndividualSubscriptionGETRequest) -> operations.IndividualSubscriptionGETResponse:
        r"""Used to represent an individual subscription to notifications about application package changes.
        Used to represent an individual subscription to notifications about application package changes.
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.IndividualSubscriptionGETRequest, base_url, '/subscriptions/{subscriptionId}', request)
        
        
        client = self._client
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.IndividualSubscriptionGETResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.AppPkgSubscriptionInfo])
                res.app_pkg_subscription_info = out
        elif http_res.status_code in [400, 401, 403, 404, 406, 429]:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ProblemDetails])
                res.problem_details = out

        return res

    def subscriptions_get(self) -> operations.SubscriptionsGETResponse:
        r"""used to retrieve the information of subscriptions to individual application package resource in MEO
        used to retrieve the information of subscriptions to individual application package resource in MEO package
        """
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/subscriptions'
        
        
        client = self._client
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.SubscriptionsGETResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.AppPkgSubscriptionLinkList])
                res.app_pkg_subscription_link_list = out
        elif http_res.status_code in [400, 401, 403, 404, 406, 429]:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ProblemDetails])
                res.problem_details = out

        return res

    def subscriptions_post(self, request: shared.AppPkgSubscription) -> operations.SubscriptionsPOSTResponse:
        r"""Subscribe to notifications about on-boarding an application package
        Subscribe to notifications about on-boarding an application package
        """
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/subscriptions'
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = self._client
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.SubscriptionsPOSTResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 201:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.AppPkgSubscriptionInfo])
                res.app_pkg_subscription_info = out
        elif http_res.status_code in [400, 401, 403, 404, 406, 429]:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ProblemDetails])
                res.problem_details = out

        return res

    