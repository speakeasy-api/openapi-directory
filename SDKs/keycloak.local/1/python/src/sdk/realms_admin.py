"""Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT."""

import requests as requests_http
from . import utils
from sdk.models import operations, shared
from typing import Any, Optional

class RealmsAdmin:
    _client: requests_http.Session
    _security_client: requests_http.Session
    _server_url: str
    _language: str
    _sdk_version: str
    _gen_version: str

    def __init__(self, client: requests_http.Session, security_client: requests_http.Session, server_url: str, language: str, sdk_version: str, gen_version: str) -> None:
        self._client = client
        self._security_client = security_client
        self._server_url = server_url
        self._language = language
        self._sdk_version = sdk_version
        self._gen_version = gen_version
        
    def delete_realm_(self, request: operations.DeleteRealmRequest) -> operations.DeleteRealmResponse:
        r"""Delete the realm"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.DeleteRealmRequest, base_url, '/{realm}', request)
        
        
        client = self._security_client
        
        http_res = client.request('DELETE', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DeleteRealmResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        

        return res

    def delete_realm_admin_events(self, request: operations.DeleteRealmAdminEventsRequest) -> operations.DeleteRealmAdminEventsResponse:
        r"""Delete all admin events"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.DeleteRealmAdminEventsRequest, base_url, '/{realm}/admin-events', request)
        
        
        client = self._security_client
        
        http_res = client.request('DELETE', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DeleteRealmAdminEventsResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        

        return res

    def delete_realm_default_default_client_scopes_client_scope_id_(self, request: operations.DeleteRealmDefaultDefaultClientScopesClientScopeIDRequest) -> operations.DeleteRealmDefaultDefaultClientScopesClientScopeIDResponse:
        base_url = self._server_url
        
        url = utils.generate_url(operations.DeleteRealmDefaultDefaultClientScopesClientScopeIDRequest, base_url, '/{realm}/default-default-client-scopes/{clientScopeId}', request)
        
        
        client = self._security_client
        
        http_res = client.request('DELETE', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DeleteRealmDefaultDefaultClientScopesClientScopeIDResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        

        return res

    def delete_realm_default_groups_group_id_(self, request: operations.DeleteRealmDefaultGroupsGroupIDRequest) -> operations.DeleteRealmDefaultGroupsGroupIDResponse:
        base_url = self._server_url
        
        url = utils.generate_url(operations.DeleteRealmDefaultGroupsGroupIDRequest, base_url, '/{realm}/default-groups/{groupId}', request)
        
        
        client = self._security_client
        
        http_res = client.request('DELETE', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DeleteRealmDefaultGroupsGroupIDResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        

        return res

    def delete_realm_default_optional_client_scopes_client_scope_id_(self, request: operations.DeleteRealmDefaultOptionalClientScopesClientScopeIDRequest) -> operations.DeleteRealmDefaultOptionalClientScopesClientScopeIDResponse:
        base_url = self._server_url
        
        url = utils.generate_url(operations.DeleteRealmDefaultOptionalClientScopesClientScopeIDRequest, base_url, '/{realm}/default-optional-client-scopes/{clientScopeId}', request)
        
        
        client = self._security_client
        
        http_res = client.request('DELETE', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DeleteRealmDefaultOptionalClientScopesClientScopeIDResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        

        return res

    def delete_realm_events(self, request: operations.DeleteRealmEventsRequest) -> operations.DeleteRealmEventsResponse:
        r"""Delete all events"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.DeleteRealmEventsRequest, base_url, '/{realm}/events', request)
        
        
        client = self._security_client
        
        http_res = client.request('DELETE', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DeleteRealmEventsResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        

        return res

    def delete_realm_sessions_session_(self, request: operations.DeleteRealmSessionsSessionRequest) -> operations.DeleteRealmSessionsSessionResponse:
        r"""Remove a specific user session."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.DeleteRealmSessionsSessionRequest, base_url, '/{realm}/sessions/{session}', request)
        
        
        client = self._security_client
        
        http_res = client.request('DELETE', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DeleteRealmSessionsSessionResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        

        return res

    def get_realm_(self, request: operations.GetRealmRequest) -> operations.GetRealmResponse:
        r"""Get the top-level representation of the realm   It will not include nested information like User and Client representations."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.GetRealmRequest, base_url, '/{realm}', request)
        
        
        client = self._security_client
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetRealmResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code >= 200 and http_res.status_code < 300:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.RealmRepresentation])
                res.realm_representation = out

        return res

    def get_realm_admin_events(self, request: operations.GetRealmAdminEventsRequest) -> operations.GetRealmAdminEventsResponse:
        r"""Get admin events   Returns all admin events, or filters events based on URL query parameters listed here"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.GetRealmAdminEventsRequest, base_url, '/{realm}/admin-events', request)
        
        query_params = utils.get_query_params(operations.GetRealmAdminEventsRequest, request)
        
        client = self._security_client
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetRealmAdminEventsResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code >= 200 and http_res.status_code < 300:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[list[shared.AdminEventRepresentation]])
                res.admin_event_representations = out

        return res

    def get_realm_client_session_stats(self, request: operations.GetRealmClientSessionStatsRequest) -> operations.GetRealmClientSessionStatsResponse:
        r"""Get client session stats   Returns a JSON map."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.GetRealmClientSessionStatsRequest, base_url, '/{realm}/client-session-stats', request)
        
        
        client = self._security_client
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetRealmClientSessionStatsResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code >= 200 and http_res.status_code < 300:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[list[dict[str, Any]]])
                res.get_realm_client_session_stats_2_xx_application_json_objects = out

        return res

    def get_realm_credential_registrators(self, request: operations.GetRealmCredentialRegistratorsRequest) -> operations.GetRealmCredentialRegistratorsResponse:
        base_url = self._server_url
        
        url = utils.generate_url(operations.GetRealmCredentialRegistratorsRequest, base_url, '/{realm}/credential-registrators', request)
        
        
        client = self._security_client
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetRealmCredentialRegistratorsResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code >= 200 and http_res.status_code < 300:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[list[str]])
                res.get_realm_credential_registrators_2_xx_application_json_strings = out

        return res

    def get_realm_default_default_client_scopes(self, request: operations.GetRealmDefaultDefaultClientScopesRequest) -> operations.GetRealmDefaultDefaultClientScopesResponse:
        r"""Get realm default client scopes."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.GetRealmDefaultDefaultClientScopesRequest, base_url, '/{realm}/default-default-client-scopes', request)
        
        
        client = self._security_client
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetRealmDefaultDefaultClientScopesResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code >= 200 and http_res.status_code < 300:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[list[shared.ClientScopeRepresentation]])
                res.client_scope_representations = out

        return res

    def get_realm_default_groups(self, request: operations.GetRealmDefaultGroupsRequest) -> operations.GetRealmDefaultGroupsResponse:
        r"""Get group hierarchy."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.GetRealmDefaultGroupsRequest, base_url, '/{realm}/default-groups', request)
        
        
        client = self._security_client
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetRealmDefaultGroupsResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code >= 200 and http_res.status_code < 300:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[list[shared.GroupRepresentation]])
                res.group_representations = out

        return res

    def get_realm_default_optional_client_scopes(self, request: operations.GetRealmDefaultOptionalClientScopesRequest) -> operations.GetRealmDefaultOptionalClientScopesResponse:
        r"""Get realm optional client scopes."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.GetRealmDefaultOptionalClientScopesRequest, base_url, '/{realm}/default-optional-client-scopes', request)
        
        
        client = self._security_client
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetRealmDefaultOptionalClientScopesResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code >= 200 and http_res.status_code < 300:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[list[shared.ClientScopeRepresentation]])
                res.client_scope_representations = out

        return res

    def get_realm_events(self, request: operations.GetRealmEventsRequest) -> operations.GetRealmEventsResponse:
        r"""Get events   Returns all events, or filters them based on URL query parameters listed here"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.GetRealmEventsRequest, base_url, '/{realm}/events', request)
        
        query_params = utils.get_query_params(operations.GetRealmEventsRequest, request)
        
        client = self._security_client
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetRealmEventsResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code >= 200 and http_res.status_code < 300:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[list[shared.EventRepresentation]])
                res.event_representations = out

        return res

    def get_realm_events_config(self, request: operations.GetRealmEventsConfigRequest) -> operations.GetRealmEventsConfigResponse:
        r"""Get the events provider configuration   Returns JSON object with events provider configuration"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.GetRealmEventsConfigRequest, base_url, '/{realm}/events/config', request)
        
        
        client = self._security_client
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetRealmEventsConfigResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code >= 200 and http_res.status_code < 300:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.RealmEventsConfigRepresentation])
                res.realm_events_config_representation = out

        return res

    def get_realm_group_by_path_path_(self, request: operations.GetRealmGroupByPathPathRequest) -> operations.GetRealmGroupByPathPathResponse:
        base_url = self._server_url
        
        url = utils.generate_url(operations.GetRealmGroupByPathPathRequest, base_url, '/{realm}/group-by-path/{path}', request)
        
        
        client = self._security_client
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetRealmGroupByPathPathResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code >= 200 and http_res.status_code < 300:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.GroupRepresentation])
                res.group_representation = out

        return res

    def get_realm_users_management_permissions(self, request: operations.GetRealmUsersManagementPermissionsRequest) -> operations.GetRealmUsersManagementPermissionsResponse:
        base_url = self._server_url
        
        url = utils.generate_url(operations.GetRealmUsersManagementPermissionsRequest, base_url, '/{realm}/users-management-permissions', request)
        
        
        client = self._security_client
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetRealmUsersManagementPermissionsResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code >= 200 and http_res.status_code < 300:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ManagementPermissionReference])
                res.management_permission_reference = out

        return res

    def post_(self, request: shared.RealmRepresentation) -> operations.PostResponse:
        r"""Import a realm   Imports a realm from a full representation of that realm."""
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/'
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = self._security_client
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.PostResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        

        return res

    def post_realm_clear_keys_cache(self, request: operations.PostRealmClearKeysCacheRequest) -> operations.PostRealmClearKeysCacheResponse:
        r"""Clear cache of external public keys (Public keys of clients or Identity providers)"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.PostRealmClearKeysCacheRequest, base_url, '/{realm}/clear-keys-cache', request)
        
        
        client = self._security_client
        
        http_res = client.request('POST', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.PostRealmClearKeysCacheResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        

        return res

    def post_realm_clear_realm_cache(self, request: operations.PostRealmClearRealmCacheRequest) -> operations.PostRealmClearRealmCacheResponse:
        r"""Clear realm cache"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.PostRealmClearRealmCacheRequest, base_url, '/{realm}/clear-realm-cache', request)
        
        
        client = self._security_client
        
        http_res = client.request('POST', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.PostRealmClearRealmCacheResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        

        return res

    def post_realm_clear_user_cache(self, request: operations.PostRealmClearUserCacheRequest) -> operations.PostRealmClearUserCacheResponse:
        r"""Clear user cache"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.PostRealmClearUserCacheRequest, base_url, '/{realm}/clear-user-cache', request)
        
        
        client = self._security_client
        
        http_res = client.request('POST', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.PostRealmClearUserCacheResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        

        return res

    def post_realm_client_description_converter(self, request: operations.PostRealmClientDescriptionConverterRequest) -> operations.PostRealmClientDescriptionConverterResponse:
        r"""Base path for importing clients under this realm."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.PostRealmClientDescriptionConverterRequest, base_url, '/{realm}/client-description-converter', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'string')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = self._security_client
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.PostRealmClientDescriptionConverterResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code >= 200 and http_res.status_code < 300:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ClientRepresentation])
                res.client_representation = out

        return res

    def post_realm_logout_all(self, request: operations.PostRealmLogoutAllRequest) -> operations.PostRealmLogoutAllResponse:
        r"""Removes all user sessions."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.PostRealmLogoutAllRequest, base_url, '/{realm}/logout-all', request)
        
        
        client = self._security_client
        
        http_res = client.request('POST', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.PostRealmLogoutAllResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        

        return res

    def post_realm_partial_export(self, request: operations.PostRealmPartialExportRequest) -> operations.PostRealmPartialExportResponse:
        r"""Partial export of existing realm into a JSON file."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.PostRealmPartialExportRequest, base_url, '/{realm}/partial-export', request)
        
        query_params = utils.get_query_params(operations.PostRealmPartialExportRequest, request)
        
        client = self._security_client
        
        http_res = client.request('POST', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.PostRealmPartialExportResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code >= 200 and http_res.status_code < 300:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.RealmRepresentation])
                res.realm_representation = out

        return res

    def post_realm_partial_import(self, request: operations.PostRealmPartialImportRequest) -> operations.PostRealmPartialImportResponse:
        r"""Partial import from a JSON file to an existing realm."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.PostRealmPartialImportRequest, base_url, '/{realm}/partialImport', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "partial_import_representation", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = self._security_client
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.PostRealmPartialImportResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        

        return res

    def post_realm_push_revocation(self, request: operations.PostRealmPushRevocationRequest) -> operations.PostRealmPushRevocationResponse:
        r"""Push the realmâ€™s revocation policy to any client that has an admin url associated with it."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.PostRealmPushRevocationRequest, base_url, '/{realm}/push-revocation', request)
        
        
        client = self._security_client
        
        http_res = client.request('POST', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.PostRealmPushRevocationResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        

        return res

    def post_realm_test_ldap_connection(self, request: operations.PostRealmTestLDAPConnectionRequest) -> operations.PostRealmTestLDAPConnectionResponse:
        r"""Test LDAP connection"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.PostRealmTestLDAPConnectionRequest, base_url, '/{realm}/testLDAPConnection', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "test_ldap_connection_representation", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = self._security_client
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.PostRealmTestLDAPConnectionResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        

        return res

    def post_realm_test_smtp_connection(self, request: operations.PostRealmTestSMTPConnectionRequest) -> operations.PostRealmTestSMTPConnectionResponse:
        base_url = self._server_url
        
        url = utils.generate_url(operations.PostRealmTestSMTPConnectionRequest, base_url, '/{realm}/testSMTPConnection', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = self._security_client
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.PostRealmTestSMTPConnectionResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        

        return res

    def put_realm_(self, request: operations.PutRealmRequest) -> operations.PutRealmResponse:
        r"""Update the top-level information of the realm   Any user, roles or client information in the representation  will be ignored."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.PutRealmRequest, base_url, '/{realm}', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "realm_representation", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = self._security_client
        
        http_res = client.request('PUT', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.PutRealmResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        

        return res

    def put_realm_default_default_client_scopes_client_scope_id_(self, request: operations.PutRealmDefaultDefaultClientScopesClientScopeIDRequest) -> operations.PutRealmDefaultDefaultClientScopesClientScopeIDResponse:
        base_url = self._server_url
        
        url = utils.generate_url(operations.PutRealmDefaultDefaultClientScopesClientScopeIDRequest, base_url, '/{realm}/default-default-client-scopes/{clientScopeId}', request)
        
        
        client = self._security_client
        
        http_res = client.request('PUT', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.PutRealmDefaultDefaultClientScopesClientScopeIDResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        

        return res

    def put_realm_default_groups_group_id_(self, request: operations.PutRealmDefaultGroupsGroupIDRequest) -> operations.PutRealmDefaultGroupsGroupIDResponse:
        base_url = self._server_url
        
        url = utils.generate_url(operations.PutRealmDefaultGroupsGroupIDRequest, base_url, '/{realm}/default-groups/{groupId}', request)
        
        
        client = self._security_client
        
        http_res = client.request('PUT', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.PutRealmDefaultGroupsGroupIDResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        

        return res

    def put_realm_default_optional_client_scopes_client_scope_id_(self, request: operations.PutRealmDefaultOptionalClientScopesClientScopeIDRequest) -> operations.PutRealmDefaultOptionalClientScopesClientScopeIDResponse:
        base_url = self._server_url
        
        url = utils.generate_url(operations.PutRealmDefaultOptionalClientScopesClientScopeIDRequest, base_url, '/{realm}/default-optional-client-scopes/{clientScopeId}', request)
        
        
        client = self._security_client
        
        http_res = client.request('PUT', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.PutRealmDefaultOptionalClientScopesClientScopeIDResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        

        return res

    def put_realm_events_config(self, request: operations.PutRealmEventsConfigRequest) -> operations.PutRealmEventsConfigResponse:
        r"""Update the events provider   Change the events provider and/or its configuration"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.PutRealmEventsConfigRequest, base_url, '/{realm}/events/config', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "realm_events_config_representation", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = self._security_client
        
        http_res = client.request('PUT', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.PutRealmEventsConfigResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        

        return res

    def put_realm_users_management_permissions(self, request: operations.PutRealmUsersManagementPermissionsRequest) -> operations.PutRealmUsersManagementPermissionsResponse:
        base_url = self._server_url
        
        url = utils.generate_url(operations.PutRealmUsersManagementPermissionsRequest, base_url, '/{realm}/users-management-permissions', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "management_permission_reference", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = self._security_client
        
        http_res = client.request('PUT', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.PutRealmUsersManagementPermissionsResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code >= 200 and http_res.status_code < 300:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ManagementPermissionReference])
                res.management_permission_reference = out

        return res

    