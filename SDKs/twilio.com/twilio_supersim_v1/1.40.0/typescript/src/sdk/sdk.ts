/*
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

import * as utils from "../internal/utils";
import * as operations from "./models/operations";
import * as shared from "./models/shared";
import axios from "axios";
import { AxiosInstance, AxiosRequestConfig, AxiosResponse } from "axios";

/**
 * Contains the list of servers available to the SDK
 */
export const ServerList = ["https://supersim.twilio.com"] as const;

/**
 * The available configuration options for the SDK
 */
export type SDKProps = {
  /**
   * Allows overriding the default axios client used by the SDK
   */
  defaultClient?: AxiosInstance;
  /**
   * Allows overriding the default server URL used by the SDK
   */
  serverURL?: string;
};

/**
 * This is the public Twilio REST API.
 */
export class SDK {
  public _defaultClient: AxiosInstance;
  public _securityClient: AxiosInstance;
  public _serverURL: string;
  private _language = "typescript";
  private _sdkVersion = "0.0.1";
  private _genVersion = "internal";
  private _globals: any;

  constructor(props?: SDKProps) {
    this._serverURL = props?.serverURL ?? ServerList[0];

    this._defaultClient =
      props?.defaultClient ?? axios.create({ baseURL: this._serverURL });
    this._securityClient = this._defaultClient;
  }

  /**
   * Order an eSIM Profile.
   */
  createEsimProfile(
    req: operations.CreateEsimProfileCreateEsimProfileRequest,
    security: operations.CreateEsimProfileSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.CreateEsimProfileResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CreateEsimProfileCreateEsimProfileRequest(req);
    }

    let baseURL: string = operations.CreateEsimProfileServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = baseURL.replace(/\/$/, "") + "/v1/ESimProfiles";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "request",
        "form"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.CreateEsimProfileSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CreateEsimProfileResponse =
        new operations.CreateEsimProfileResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.supersimV1EsimProfile = utils.objectToClass(
              httpRes?.data,
              shared.SupersimV1EsimProfile
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Create a Fleet
   */
  createFleet(
    req: operations.CreateFleetCreateFleetRequest,
    security: operations.CreateFleetSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.CreateFleetResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CreateFleetCreateFleetRequest(req);
    }

    let baseURL: string = operations.CreateFleetServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = baseURL.replace(/\/$/, "") + "/v1/Fleets";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "request",
        "form"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.CreateFleetSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CreateFleetResponse =
        new operations.CreateFleetResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.supersimV1Fleet = utils.objectToClass(
              httpRes?.data,
              shared.SupersimV1Fleet
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Send an IP Command to a Super SIM.
   */
  createIpCommand(
    req: operations.CreateIpCommandCreateIpCommandRequest,
    security: operations.CreateIpCommandSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.CreateIpCommandResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CreateIpCommandCreateIpCommandRequest(req);
    }

    let baseURL: string = operations.CreateIpCommandServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = baseURL.replace(/\/$/, "") + "/v1/IpCommands";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "request",
        "form"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.CreateIpCommandSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CreateIpCommandResponse =
        new operations.CreateIpCommandResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.supersimV1IpCommand = utils.objectToClass(
              httpRes?.data,
              shared.SupersimV1IpCommand
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Create a new Network Access Profile
   */
  createNetworkAccessProfile(
    req: operations.CreateNetworkAccessProfileCreateNetworkAccessProfileRequest,
    security: operations.CreateNetworkAccessProfileSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.CreateNetworkAccessProfileResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.CreateNetworkAccessProfileCreateNetworkAccessProfileRequest(
          req
        );
    }

    let baseURL: string = operations.CreateNetworkAccessProfileServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string =
      baseURL.replace(/\/$/, "") + "/v1/NetworkAccessProfiles";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "request",
        "form"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.CreateNetworkAccessProfileSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CreateNetworkAccessProfileResponse =
        new operations.CreateNetworkAccessProfileResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.supersimV1NetworkAccessProfile = utils.objectToClass(
              httpRes?.data,
              shared.SupersimV1NetworkAccessProfile
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Add a Network resource to the Network Access Profile resource.
   */
  createNetworkAccessProfileNetwork(
    req: operations.CreateNetworkAccessProfileNetworkRequest,
    security: operations.CreateNetworkAccessProfileNetworkSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.CreateNetworkAccessProfileNetworkResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CreateNetworkAccessProfileNetworkRequest(req);
    }

    let baseURL: string =
      operations.CreateNetworkAccessProfileNetworkServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v1/NetworkAccessProfiles/{NetworkAccessProfileSid}/Networks",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "form"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.CreateNetworkAccessProfileNetworkSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CreateNetworkAccessProfileNetworkResponse =
        new operations.CreateNetworkAccessProfileNetworkResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.supersimV1NetworkAccessProfileNetworkAccessProfileNetwork =
              utils.objectToClass(
                httpRes?.data,
                shared.SupersimV1NetworkAccessProfileNetworkAccessProfileNetwork
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Register a Super SIM to your Account
   */
  createSim(
    req: operations.CreateSimCreateSimRequest,
    security: operations.CreateSimSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.CreateSimResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CreateSimCreateSimRequest(req);
    }

    let baseURL: string = operations.CreateSimServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = baseURL.replace(/\/$/, "") + "/v1/Sims";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "request",
        "form"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.CreateSimSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CreateSimResponse =
        new operations.CreateSimResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.supersimV1Sim = utils.objectToClass(
              httpRes?.data,
              shared.SupersimV1Sim
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Send SMS Command to a Sim.
   */
  createSmsCommand(
    req: operations.CreateSmsCommandCreateSmsCommandRequest,
    security: operations.CreateSmsCommandSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.CreateSmsCommandResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CreateSmsCommandCreateSmsCommandRequest(req);
    }

    let baseURL: string = operations.CreateSmsCommandServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = baseURL.replace(/\/$/, "") + "/v1/SmsCommands";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "request",
        "form"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.CreateSmsCommandSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CreateSmsCommandResponse =
        new operations.CreateSmsCommandResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.supersimV1SmsCommand = utils.objectToClass(
              httpRes?.data,
              shared.SupersimV1SmsCommand
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Remove a Network resource from the Network Access Profile resource's.
   */
  deleteNetworkAccessProfileNetwork(
    req: operations.DeleteNetworkAccessProfileNetworkRequest,
    security: operations.DeleteNetworkAccessProfileNetworkSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.DeleteNetworkAccessProfileNetworkResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DeleteNetworkAccessProfileNetworkRequest(req);
    }

    let baseURL: string =
      operations.DeleteNetworkAccessProfileNetworkServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v1/NetworkAccessProfiles/{NetworkAccessProfileSid}/Networks/{Sid}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.DeleteNetworkAccessProfileNetworkSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DeleteNetworkAccessProfileNetworkResponse =
        new operations.DeleteNetworkAccessProfileNetworkResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
      }

      return res;
    });
  }

  /**
   * Fetch an eSIM Profile.
   */
  fetchEsimProfile(
    req: operations.FetchEsimProfileRequest,
    security: operations.FetchEsimProfileSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.FetchEsimProfileResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.FetchEsimProfileRequest(req);
    }

    let baseURL: string = operations.FetchEsimProfileServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v1/ESimProfiles/{Sid}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.FetchEsimProfileSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.FetchEsimProfileResponse =
        new operations.FetchEsimProfileResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.supersimV1EsimProfile = utils.objectToClass(
              httpRes?.data,
              shared.SupersimV1EsimProfile
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Fetch a Fleet instance from your account.
   */
  fetchFleet(
    req: operations.FetchFleetRequest,
    security: operations.FetchFleetSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.FetchFleetResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.FetchFleetRequest(req);
    }

    let baseURL: string = operations.FetchFleetServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(baseURL, "/v1/Fleets/{Sid}", req);
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.FetchFleetSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.FetchFleetResponse =
        new operations.FetchFleetResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.supersimV1Fleet = utils.objectToClass(
              httpRes?.data,
              shared.SupersimV1Fleet
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Fetch IP Command instance from your account.
   */
  fetchIpCommand(
    req: operations.FetchIpCommandRequest,
    security: operations.FetchIpCommandSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.FetchIpCommandResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.FetchIpCommandRequest(req);
    }

    let baseURL: string = operations.FetchIpCommandServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(baseURL, "/v1/IpCommands/{Sid}", req);
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.FetchIpCommandSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.FetchIpCommandResponse =
        new operations.FetchIpCommandResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.supersimV1IpCommand = utils.objectToClass(
              httpRes?.data,
              shared.SupersimV1IpCommand
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Fetch a Network resource.
   */
  fetchNetwork(
    req: operations.FetchNetworkRequest,
    security: operations.FetchNetworkSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.FetchNetworkResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.FetchNetworkRequest(req);
    }

    let baseURL: string = operations.FetchNetworkServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(baseURL, "/v1/Networks/{Sid}", req);
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.FetchNetworkSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.FetchNetworkResponse =
        new operations.FetchNetworkResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.supersimV1Network = utils.objectToClass(
              httpRes?.data,
              shared.SupersimV1Network
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Fetch a Network Access Profile instance from your account.
   */
  fetchNetworkAccessProfile(
    req: operations.FetchNetworkAccessProfileRequest,
    security: operations.FetchNetworkAccessProfileSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.FetchNetworkAccessProfileResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.FetchNetworkAccessProfileRequest(req);
    }

    let baseURL: string = operations.FetchNetworkAccessProfileServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v1/NetworkAccessProfiles/{Sid}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.FetchNetworkAccessProfileSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.FetchNetworkAccessProfileResponse =
        new operations.FetchNetworkAccessProfileResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.supersimV1NetworkAccessProfile = utils.objectToClass(
              httpRes?.data,
              shared.SupersimV1NetworkAccessProfile
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Fetch a Network Access Profile resource's Network resource.
   */
  fetchNetworkAccessProfileNetwork(
    req: operations.FetchNetworkAccessProfileNetworkRequest,
    security: operations.FetchNetworkAccessProfileNetworkSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.FetchNetworkAccessProfileNetworkResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.FetchNetworkAccessProfileNetworkRequest(req);
    }

    let baseURL: string =
      operations.FetchNetworkAccessProfileNetworkServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v1/NetworkAccessProfiles/{NetworkAccessProfileSid}/Networks/{Sid}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.FetchNetworkAccessProfileNetworkSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.FetchNetworkAccessProfileNetworkResponse =
        new operations.FetchNetworkAccessProfileNetworkResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.supersimV1NetworkAccessProfileNetworkAccessProfileNetwork =
              utils.objectToClass(
                httpRes?.data,
                shared.SupersimV1NetworkAccessProfileNetworkAccessProfileNetwork
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Fetch a Super SIM instance from your account.
   */
  fetchSim(
    req: operations.FetchSimRequest,
    security: operations.FetchSimSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.FetchSimResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.FetchSimRequest(req);
    }

    let baseURL: string = operations.FetchSimServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(baseURL, "/v1/Sims/{Sid}", req);
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.FetchSimSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.FetchSimResponse = new operations.FetchSimResponse({
        statusCode: httpRes.status,
        contentType: contentType,
        rawResponse: httpRes,
      });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.supersimV1Sim = utils.objectToClass(
              httpRes?.data,
              shared.SupersimV1Sim
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Fetch SMS Command instance from your account.
   */
  fetchSmsCommand(
    req: operations.FetchSmsCommandRequest,
    security: operations.FetchSmsCommandSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.FetchSmsCommandResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.FetchSmsCommandRequest(req);
    }

    let baseURL: string = operations.FetchSmsCommandServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v1/SmsCommands/{Sid}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.FetchSmsCommandSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.FetchSmsCommandResponse =
        new operations.FetchSmsCommandResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.supersimV1SmsCommand = utils.objectToClass(
              httpRes?.data,
              shared.SupersimV1SmsCommand
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Retrieve a list of Billing Periods for a Super SIM.
   */
  listBillingPeriod(
    req: operations.ListBillingPeriodRequest,
    security: operations.ListBillingPeriodSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.ListBillingPeriodResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ListBillingPeriodRequest(req);
    }

    let baseURL: string = operations.ListBillingPeriodServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v1/Sims/{SimSid}/BillingPeriods",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ListBillingPeriodSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ListBillingPeriodResponse =
        new operations.ListBillingPeriodResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listBillingPeriodResponse = utils.objectToClass(
              httpRes?.data,
              operations.ListBillingPeriodListBillingPeriodResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Retrieve a list of eSIM Profiles.
   */
  listEsimProfile(
    req: operations.ListEsimProfileRequest,
    security: operations.ListEsimProfileSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.ListEsimProfileResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ListEsimProfileRequest(req);
    }

    let baseURL: string = operations.ListEsimProfileServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = baseURL.replace(/\/$/, "") + "/v1/ESimProfiles";
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ListEsimProfileSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ListEsimProfileResponse =
        new operations.ListEsimProfileResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listEsimProfileResponse = utils.objectToClass(
              httpRes?.data,
              operations.ListEsimProfileListEsimProfileResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Retrieve a list of Fleets from your account.
   */
  listFleet(
    req: operations.ListFleetRequest,
    security: operations.ListFleetSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.ListFleetResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ListFleetRequest(req);
    }

    let baseURL: string = operations.ListFleetServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = baseURL.replace(/\/$/, "") + "/v1/Fleets";
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ListFleetSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ListFleetResponse =
        new operations.ListFleetResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listFleetResponse = utils.objectToClass(
              httpRes?.data,
              operations.ListFleetListFleetResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Retrieve a list of IP Commands from your account.
   */
  listIpCommand(
    req: operations.ListIpCommandRequest,
    security: operations.ListIpCommandSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.ListIpCommandResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ListIpCommandRequest(req);
    }

    let baseURL: string = operations.ListIpCommandServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = baseURL.replace(/\/$/, "") + "/v1/IpCommands";
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ListIpCommandSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ListIpCommandResponse =
        new operations.ListIpCommandResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listIpCommandResponse = utils.objectToClass(
              httpRes?.data,
              operations.ListIpCommandListIpCommandResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Retrieve a list of Network resources.
   */
  listNetwork(
    req: operations.ListNetworkRequest,
    security: operations.ListNetworkSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.ListNetworkResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ListNetworkRequest(req);
    }

    let baseURL: string = operations.ListNetworkServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = baseURL.replace(/\/$/, "") + "/v1/Networks";
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ListNetworkSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ListNetworkResponse =
        new operations.ListNetworkResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listNetworkResponse = utils.objectToClass(
              httpRes?.data,
              operations.ListNetworkListNetworkResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Retrieve a list of Network Access Profiles from your account.
   */
  listNetworkAccessProfile(
    req: operations.ListNetworkAccessProfileRequest,
    security: operations.ListNetworkAccessProfileSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.ListNetworkAccessProfileResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ListNetworkAccessProfileRequest(req);
    }

    let baseURL: string = operations.ListNetworkAccessProfileServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string =
      baseURL.replace(/\/$/, "") + "/v1/NetworkAccessProfiles";
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ListNetworkAccessProfileSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ListNetworkAccessProfileResponse =
        new operations.ListNetworkAccessProfileResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listNetworkAccessProfileResponse = utils.objectToClass(
              httpRes?.data,
              operations.ListNetworkAccessProfileListNetworkAccessProfileResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Retrieve a list of Network Access Profile resource's Network resource.
   */
  listNetworkAccessProfileNetwork(
    req: operations.ListNetworkAccessProfileNetworkRequest,
    security: operations.ListNetworkAccessProfileNetworkSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.ListNetworkAccessProfileNetworkResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ListNetworkAccessProfileNetworkRequest(req);
    }

    let baseURL: string =
      operations.ListNetworkAccessProfileNetworkServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v1/NetworkAccessProfiles/{NetworkAccessProfileSid}/Networks",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ListNetworkAccessProfileNetworkSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ListNetworkAccessProfileNetworkResponse =
        new operations.ListNetworkAccessProfileNetworkResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listNetworkAccessProfileNetworkResponse = utils.objectToClass(
              httpRes?.data,
              operations.ListNetworkAccessProfileNetworkListNetworkAccessProfileNetworkResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Retrieve a list of Settings Updates.
   */
  listSettingsUpdate(
    req: operations.ListSettingsUpdateRequest,
    security: operations.ListSettingsUpdateSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.ListSettingsUpdateResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ListSettingsUpdateRequest(req);
    }

    let baseURL: string = operations.ListSettingsUpdateServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = baseURL.replace(/\/$/, "") + "/v1/SettingsUpdates";
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ListSettingsUpdateSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ListSettingsUpdateResponse =
        new operations.ListSettingsUpdateResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listSettingsUpdateResponse = utils.objectToClass(
              httpRes?.data,
              operations.ListSettingsUpdateListSettingsUpdateResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Retrieve a list of Super SIMs from your account.
   */
  listSim(
    req: operations.ListSimRequest,
    security: operations.ListSimSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.ListSimResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ListSimRequest(req);
    }

    let baseURL: string = operations.ListSimServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = baseURL.replace(/\/$/, "") + "/v1/Sims";
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ListSimSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ListSimResponse = new operations.ListSimResponse({
        statusCode: httpRes.status,
        contentType: contentType,
        rawResponse: httpRes,
      });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listSimResponse = utils.objectToClass(
              httpRes?.data,
              operations.ListSimListSimResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Retrieve a list of IP Addresses for the given Super SIM.
   */
  listSimIpAddress(
    req: operations.ListSimIpAddressRequest,
    security: operations.ListSimIpAddressSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.ListSimIpAddressResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ListSimIpAddressRequest(req);
    }

    let baseURL: string = operations.ListSimIpAddressServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v1/Sims/{SimSid}/IpAddresses",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ListSimIpAddressSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ListSimIpAddressResponse =
        new operations.ListSimIpAddressResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listSimIpAddressResponse = utils.objectToClass(
              httpRes?.data,
              operations.ListSimIpAddressListSimIpAddressResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Retrieve a list of SMS Commands from your account.
   */
  listSmsCommand(
    req: operations.ListSmsCommandRequest,
    security: operations.ListSmsCommandSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.ListSmsCommandResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ListSmsCommandRequest(req);
    }

    let baseURL: string = operations.ListSmsCommandServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = baseURL.replace(/\/$/, "") + "/v1/SmsCommands";
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ListSmsCommandSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ListSmsCommandResponse =
        new operations.ListSmsCommandResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listSmsCommandResponse = utils.objectToClass(
              httpRes?.data,
              operations.ListSmsCommandListSmsCommandResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * List UsageRecords
   */
  listUsageRecord(
    req: operations.ListUsageRecordRequest,
    security: operations.ListUsageRecordSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.ListUsageRecordResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ListUsageRecordRequest(req);
    }

    let baseURL: string = operations.ListUsageRecordServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = baseURL.replace(/\/$/, "") + "/v1/UsageRecords";
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ListUsageRecordSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ListUsageRecordResponse =
        new operations.ListUsageRecordResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listUsageRecordResponse = utils.objectToClass(
              httpRes?.data,
              operations.ListUsageRecordListUsageRecordResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Updates the given properties of a Super SIM Fleet instance from your account.
   */
  updateFleet(
    req: operations.UpdateFleetRequest,
    security: operations.UpdateFleetSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.UpdateFleetResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.UpdateFleetRequest(req);
    }

    let baseURL: string = operations.UpdateFleetServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(baseURL, "/v1/Fleets/{Sid}", req);

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "form"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.UpdateFleetSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UpdateFleetResponse =
        new operations.UpdateFleetResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.supersimV1Fleet = utils.objectToClass(
              httpRes?.data,
              shared.SupersimV1Fleet
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Updates the given properties of a Network Access Profile in your account.
   */
  updateNetworkAccessProfile(
    req: operations.UpdateNetworkAccessProfileRequest,
    security: operations.UpdateNetworkAccessProfileSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.UpdateNetworkAccessProfileResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.UpdateNetworkAccessProfileRequest(req);
    }

    let baseURL: string = operations.UpdateNetworkAccessProfileServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v1/NetworkAccessProfiles/{Sid}",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "form"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.UpdateNetworkAccessProfileSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UpdateNetworkAccessProfileResponse =
        new operations.UpdateNetworkAccessProfileResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.supersimV1NetworkAccessProfile = utils.objectToClass(
              httpRes?.data,
              shared.SupersimV1NetworkAccessProfile
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Updates the given properties of a Super SIM instance from your account.
   */
  updateSim(
    req: operations.UpdateSimRequest,
    security: operations.UpdateSimSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.UpdateSimResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.UpdateSimRequest(req);
    }

    let baseURL: string = operations.UpdateSimServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(baseURL, "/v1/Sims/{Sid}", req);

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "form"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.UpdateSimSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UpdateSimResponse =
        new operations.UpdateSimResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case [200, 202].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.supersimV1Sim = utils.objectToClass(
              httpRes?.data,
              shared.SupersimV1Sim
            );
          }
          break;
      }

      return res;
    });
  }
}
