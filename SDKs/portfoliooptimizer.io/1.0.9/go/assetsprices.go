// Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.

package sdk

import (
	"context"
	"fmt"
	"net/http"
	"openapi/pkg/models/operations"
	"openapi/pkg/utils"
	"strings"
)

type assetsPrices struct {
	defaultClient  HTTPClient
	securityClient HTTPClient
	serverURL      string
	language       string
	sdkVersion     string
	genVersion     string
}

func newAssetsPrices(defaultClient, securityClient HTTPClient, serverURL, language, sdkVersion, genVersion string) *assetsPrices {
	return &assetsPrices{
		defaultClient:  defaultClient,
		securityClient: securityClient,
		serverURL:      serverURL,
		language:       language,
		sdkVersion:     sdkVersion,
		genVersion:     genVersion,
	}
}

// PostAssetsPricesAdjusted - Adjusted Prices
// Compute the backward-adjusted prices of one or several asset(s) for one or several date(s) from:
// * Unadjusted prices
// * Capital distributions, like stock dividends
// * Splits, like stock splits
//
// The adjustment base date is chosen to be the last date for which unadjusted prices are available, which implies that:
// * The price on the last date for which unadjusted prices are available is left unadjusted
// * The price on any other date is adjusted based on the capital distributions and the splits which occurred between this date and the last date for which unadjusted prices are available
//
// References
// * [Center for Research in Security Prices](https://www.crsp.org/products/documentation/crsp-calculations)
func (s *assetsPrices) PostAssetsPricesAdjusted(ctx context.Context, request operations.PostAssetsPricesAdjustedRequestBody) (*operations.PostAssetsPricesAdjustedResponse, error) {
	baseURL := s.serverURL
	url := strings.TrimSuffix(baseURL, "/") + "/assets/prices/adjusted"

	bodyReader, reqContentType, err := utils.SerializeRequestBody(ctx, request, "Request", "json")
	if err != nil {
		return nil, fmt.Errorf("error serializing request body: %w", err)
	}
	if bodyReader == nil {
		return nil, fmt.Errorf("request body is required")
	}

	req, err := http.NewRequestWithContext(ctx, "POST", url, bodyReader)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	req.Header.Set("Content-Type", reqContentType)

	client := s.securityClient

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.PostAssetsPricesAdjustedResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *operations.PostAssetsPricesAdjusted200ApplicationJSON
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.PostAssetsPricesAdjusted200ApplicationJSONObject = out
		}
	}

	return res, nil
}

// PostAssetsPricesAdjustedForward - Forward-Adjusted Prices
// Compute the forward-adjusted prices of one or several asset(s) for one or several date(s) from:
// * Unadjusted prices
// * Capital distributions, like stock dividends
// * Splits, like stock splits
//
// The adjustment base date is chosen to be the first date for which unadjusted prices are available, which implies that:
// * The price on the first date for which unadjusted prices are available is left unadjusted
// * The price on any other date is adjusted based on the capital distributions and the splits which occurred between this date and the first date for which unadjusted prices are available
//
// References
// * [Center for Research in Security Prices](https://www.crsp.org/products/documentation/crsp-calculations)
func (s *assetsPrices) PostAssetsPricesAdjustedForward(ctx context.Context, request operations.PostAssetsPricesAdjustedForwardRequestBody) (*operations.PostAssetsPricesAdjustedForwardResponse, error) {
	baseURL := s.serverURL
	url := strings.TrimSuffix(baseURL, "/") + "/assets/prices/adjusted/forward"

	bodyReader, reqContentType, err := utils.SerializeRequestBody(ctx, request, "Request", "json")
	if err != nil {
		return nil, fmt.Errorf("error serializing request body: %w", err)
	}
	if bodyReader == nil {
		return nil, fmt.Errorf("request body is required")
	}

	req, err := http.NewRequestWithContext(ctx, "POST", url, bodyReader)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	req.Header.Set("Content-Type", reqContentType)

	client := s.securityClient

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.PostAssetsPricesAdjustedForwardResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *operations.PostAssetsPricesAdjustedForward200ApplicationJSON
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.PostAssetsPricesAdjustedForward200ApplicationJSONObject = out
		}
	}

	return res, nil
}
