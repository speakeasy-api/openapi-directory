<?php

/**
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

declare(strict_types=1);

namespace OpenAPI\OpenAPI;

class Banks 
{

	// SDK private variables namespaced with _ to avoid conflicts with API models
	private \GuzzleHttp\ClientInterface $_defaultClient;
	private \GuzzleHttp\ClientInterface $_securityClient;
	private string $_serverUrl;
	private string $_language;
	private string $_sdkVersion;
	private string $_genVersion;	

	/**
	 * @param \GuzzleHttp\ClientInterface $defaultClient
	 * @param \GuzzleHttp\ClientInterface $securityClient
	 * @param string $serverUrl
	 * @param string $language
	 * @param string $sdkVersion
	 * @param string $genVersion
	 */
	public function __construct(\GuzzleHttp\ClientInterface $defaultClient, \GuzzleHttp\ClientInterface $securityClient, string $serverUrl, string $language, string $sdkVersion, string $genVersion)
	{
		$this->_defaultClient = $defaultClient;
		$this->_securityClient = $securityClient;
		$this->_serverUrl = $serverUrl;
		$this->_language = $language;
		$this->_sdkVersion = $sdkVersion;
		$this->_genVersion = $genVersion;
	}
	
    /**
     * Delete the supplied category
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\DeleteBanksCategoriesIdCategoryRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\DeleteBanksCategoriesIdCategoryResponse
     */
	public function deleteBanksCategoriesIdCategory(
        \OpenAPI\OpenAPI\Models\Operations\DeleteBanksCategoriesIdCategoryRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\DeleteBanksCategoriesIdCategoryResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/banks/categories/{id_category}', \OpenAPI\OpenAPI\Models\Operations\DeleteBanksCategoriesIdCategoryRequest::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\DeleteBanksCategoriesIdCategoryRequest::class, $request, null));
        
        $httpResponse = $this->_defaultClient->request('DELETE', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\DeleteBanksCategoriesIdCategoryResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->connectorCategory = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\ConnectorCategory', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Delete a particular key-value pair on a transaction.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\DeleteCategoriesKeywordsIdKeywordRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\DeleteCategoriesKeywordsIdKeywordResponse
     */
	public function deleteCategoriesKeywordsIdKeyword(
        \OpenAPI\OpenAPI\Models\Operations\DeleteCategoriesKeywordsIdKeywordRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\DeleteCategoriesKeywordsIdKeywordResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/categories/keywords/{id_keyword}', \OpenAPI\OpenAPI\Models\Operations\DeleteCategoriesKeywordsIdKeywordRequest::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\DeleteCategoriesKeywordsIdKeywordRequest::class, $request, null));
        
        $httpResponse = $this->_defaultClient->request('DELETE', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\DeleteCategoriesKeywordsIdKeywordResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->keyword = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\Keyword', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Disable a connection source
     * 
     * This will make it so the specified source will not be synchronized anymore.<br><br>
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\DeleteConnectionsIdConnectionSourcesIdSourceRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\DeleteConnectionsIdConnectionSourcesIdSourceResponse
     */
	public function deleteConnectionsIdConnectionSourcesIdSource(
        \OpenAPI\OpenAPI\Models\Operations\DeleteConnectionsIdConnectionSourcesIdSourceRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\DeleteConnectionsIdConnectionSourcesIdSourceResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/connections/{id_connection}/sources/{id_source}', \OpenAPI\OpenAPI\Models\Operations\DeleteConnectionsIdConnectionSourcesIdSourceRequest::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\DeleteConnectionsIdConnectionSourcesIdSourceRequest::class, $request, null));
        
        $httpResponse = $this->_defaultClient->request('DELETE', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\DeleteConnectionsIdConnectionSourcesIdSourceResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->connectionSource = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\ConnectionSource', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Delete a single Logo object.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\DeleteConnectorsIdConnectorLogosIdLogoRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\DeleteConnectorsIdConnectorLogosIdLogoResponse
     */
	public function deleteConnectorsIdConnectorLogosIdLogo(
        \OpenAPI\OpenAPI\Models\Operations\DeleteConnectorsIdConnectorLogosIdLogoRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\DeleteConnectorsIdConnectorLogosIdLogoResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/connectors/{id_connector}/logos/{id_logo}', \OpenAPI\OpenAPI\Models\Operations\DeleteConnectorsIdConnectorLogosIdLogoRequest::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\DeleteConnectorsIdConnectorLogosIdLogoRequest::class, $request, null));
        
        $httpResponse = $this->_defaultClient->request('DELETE', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\DeleteConnectorsIdConnectorLogosIdLogoResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->connectorLogo = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\ConnectorLogo', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Delete a clustered transaction
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\DeleteUsersIdUserAccountsIdAccountTransactionsclustersIdTransactionsclusterRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\DeleteUsersIdUserAccountsIdAccountTransactionsclustersIdTransactionsclusterResponse
     */
	public function deleteUsersIdUserAccountsIdAccountTransactionsclustersIdTransactionscluster(
        \OpenAPI\OpenAPI\Models\Operations\DeleteUsersIdUserAccountsIdAccountTransactionsclustersIdTransactionsclusterRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\DeleteUsersIdUserAccountsIdAccountTransactionsclustersIdTransactionsclusterResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/users/{id_user}/accounts/{id_account}/transactionsclusters/{id_transactionscluster}', \OpenAPI\OpenAPI\Models\Operations\DeleteUsersIdUserAccountsIdAccountTransactionsclustersIdTransactionsclusterRequest::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\DeleteUsersIdUserAccountsIdAccountTransactionsclustersIdTransactionsclusterRequest::class, $request, null));
        
        $httpResponse = $this->_defaultClient->request('DELETE', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\DeleteUsersIdUserAccountsIdAccountTransactionsclustersIdTransactionsclusterResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->transactionsCluster = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\TransactionsCluster', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Delete a user-created transaction category
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\DeleteUsersIdUserCategoriesFullIdFullRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\DeleteUsersIdUserCategoriesFullIdFullResponse
     */
	public function deleteUsersIdUserCategoriesFullIdFull(
        \OpenAPI\OpenAPI\Models\Operations\DeleteUsersIdUserCategoriesFullIdFullRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\DeleteUsersIdUserCategoriesFullIdFullResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/users/{id_user}/categories/full/{id_full}', \OpenAPI\OpenAPI\Models\Operations\DeleteUsersIdUserCategoriesFullIdFullRequest::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\DeleteUsersIdUserCategoriesFullIdFullRequest::class, $request, null));
        
        $httpResponse = $this->_defaultClient->request('DELETE', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\DeleteUsersIdUserCategoriesFullIdFullResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->category = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\Category', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Delete all connections
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\DeleteUsersIdUserConnectionsRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\DeleteUsersIdUserConnectionsResponse
     */
	public function deleteUsersIdUserConnections(
        \OpenAPI\OpenAPI\Models\Operations\DeleteUsersIdUserConnectionsRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\DeleteUsersIdUserConnectionsResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/users/{id_user}/connections', \OpenAPI\OpenAPI\Models\Operations\DeleteUsersIdUserConnectionsRequest::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\DeleteUsersIdUserConnectionsRequest::class, $request, null));
        
        $httpResponse = $this->_defaultClient->request('DELETE', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\DeleteUsersIdUserConnectionsResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->connection = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\Connection', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Delete a connection.
     * 
     * This endpoint deletes a connection and all related accounts and transactions.<br><br>
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\DeleteUsersIdUserConnectionsIdConnectionRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\DeleteUsersIdUserConnectionsIdConnectionResponse
     */
	public function deleteUsersIdUserConnectionsIdConnection(
        \OpenAPI\OpenAPI\Models\Operations\DeleteUsersIdUserConnectionsIdConnectionRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\DeleteUsersIdUserConnectionsIdConnectionResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/users/{id_user}/connections/{id_connection}', \OpenAPI\OpenAPI\Models\Operations\DeleteUsersIdUserConnectionsIdConnectionRequest::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\DeleteUsersIdUserConnectionsIdConnectionRequest::class, $request, null));
        
        $httpResponse = $this->_defaultClient->request('DELETE', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\DeleteUsersIdUserConnectionsIdConnectionResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->connection = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\Connection', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Delete all accounts
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\DeleteUsersIdUserConnectionsIdConnectionAccountsRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\DeleteUsersIdUserConnectionsIdConnectionAccountsResponse
     */
	public function deleteUsersIdUserConnectionsIdConnectionAccounts(
        \OpenAPI\OpenAPI\Models\Operations\DeleteUsersIdUserConnectionsIdConnectionAccountsRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\DeleteUsersIdUserConnectionsIdConnectionAccountsResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/users/{id_user}/connections/{id_connection}/accounts', \OpenAPI\OpenAPI\Models\Operations\DeleteUsersIdUserConnectionsIdConnectionAccountsRequest::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\DeleteUsersIdUserConnectionsIdConnectionAccountsRequest::class, $request, null));
        
        $httpResponse = $this->_defaultClient->request('DELETE', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\DeleteUsersIdUserConnectionsIdConnectionAccountsResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->account = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\Account', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Delete an account.
     * 
     * It deletes a specific account.<br><br>
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\DeleteUsersIdUserConnectionsIdConnectionAccountsIdAccountRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\DeleteUsersIdUserConnectionsIdConnectionAccountsIdAccountResponse
     */
	public function deleteUsersIdUserConnectionsIdConnectionAccountsIdAccount(
        \OpenAPI\OpenAPI\Models\Operations\DeleteUsersIdUserConnectionsIdConnectionAccountsIdAccountRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\DeleteUsersIdUserConnectionsIdConnectionAccountsIdAccountResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/users/{id_user}/connections/{id_connection}/accounts/{id_account}', \OpenAPI\OpenAPI\Models\Operations\DeleteUsersIdUserConnectionsIdConnectionAccountsIdAccountRequest::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\DeleteUsersIdUserConnectionsIdConnectionAccountsIdAccountRequest::class, $request, null));
        
        $httpResponse = $this->_defaultClient->request('DELETE', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\DeleteUsersIdUserConnectionsIdConnectionAccountsIdAccountResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->account = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\Account', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Delete transactions
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\DeleteUsersIdUserConnectionsIdConnectionAccountsIdAccountTransactionsRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\DeleteUsersIdUserConnectionsIdConnectionAccountsIdAccountTransactionsResponse
     */
	public function deleteUsersIdUserConnectionsIdConnectionAccountsIdAccountTransactions(
        \OpenAPI\OpenAPI\Models\Operations\DeleteUsersIdUserConnectionsIdConnectionAccountsIdAccountTransactionsRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\DeleteUsersIdUserConnectionsIdConnectionAccountsIdAccountTransactionsResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/users/{id_user}/connections/{id_connection}/accounts/{id_account}/transactions', \OpenAPI\OpenAPI\Models\Operations\DeleteUsersIdUserConnectionsIdConnectionAccountsIdAccountTransactionsRequest::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\DeleteUsersIdUserConnectionsIdConnectionAccountsIdAccountTransactionsRequest::class, $request, null));
        
        $httpResponse = $this->_defaultClient->request('DELETE', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\DeleteUsersIdUserConnectionsIdConnectionAccountsIdAccountTransactionsResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->transaction = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\Transaction', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Delete all arbitrary key-value pairs of a transaction
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\DeleteUsersIdUserConnectionsIdConnectionAccountsIdAccountTransactionsIdTransactionInformationsRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\DeleteUsersIdUserConnectionsIdConnectionAccountsIdAccountTransactionsIdTransactionInformationsResponse
     */
	public function deleteUsersIdUserConnectionsIdConnectionAccountsIdAccountTransactionsIdTransactionInformations(
        \OpenAPI\OpenAPI\Models\Operations\DeleteUsersIdUserConnectionsIdConnectionAccountsIdAccountTransactionsIdTransactionInformationsRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\DeleteUsersIdUserConnectionsIdConnectionAccountsIdAccountTransactionsIdTransactionInformationsResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/users/{id_user}/connections/{id_connection}/accounts/{id_account}/transactions/{id_transaction}/informations', \OpenAPI\OpenAPI\Models\Operations\DeleteUsersIdUserConnectionsIdConnectionAccountsIdAccountTransactionsIdTransactionInformationsRequest::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\DeleteUsersIdUserConnectionsIdConnectionAccountsIdAccountTransactionsIdTransactionInformationsRequest::class, $request, null));
        
        $httpResponse = $this->_defaultClient->request('DELETE', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\DeleteUsersIdUserConnectionsIdConnectionAccountsIdAccountTransactionsIdTransactionInformationsResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->transactionInformation = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\TransactionInformation', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Delete a particular key-value pair on a transaction.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\DeleteUsersIdUserConnectionsIdConnectionAccountsIdAccountTransactionsIdTransactionInformationsIdInformationRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\DeleteUsersIdUserConnectionsIdConnectionAccountsIdAccountTransactionsIdTransactionInformationsIdInformationResponse
     */
	public function deleteUsersIdUserConnectionsIdConnectionAccountsIdAccountTransactionsIdTransactionInformationsIdInformation(
        \OpenAPI\OpenAPI\Models\Operations\DeleteUsersIdUserConnectionsIdConnectionAccountsIdAccountTransactionsIdTransactionInformationsIdInformationRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\DeleteUsersIdUserConnectionsIdConnectionAccountsIdAccountTransactionsIdTransactionInformationsIdInformationResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/users/{id_user}/connections/{id_connection}/accounts/{id_account}/transactions/{id_transaction}/informations/{id_information}', \OpenAPI\OpenAPI\Models\Operations\DeleteUsersIdUserConnectionsIdConnectionAccountsIdAccountTransactionsIdTransactionInformationsIdInformationRequest::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\DeleteUsersIdUserConnectionsIdConnectionAccountsIdAccountTransactionsIdTransactionInformationsIdInformationRequest::class, $request, null));
        
        $httpResponse = $this->_defaultClient->request('DELETE', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\DeleteUsersIdUserConnectionsIdConnectionAccountsIdAccountTransactionsIdTransactionInformationsIdInformationResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->transactionInformation = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\TransactionInformation', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Delete a clustered transaction
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\DeleteUsersIdUserConnectionsIdConnectionAccountsIdAccountTransactionsclustersIdTransactionsclusterRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\DeleteUsersIdUserConnectionsIdConnectionAccountsIdAccountTransactionsclustersIdTransactionsclusterResponse
     */
	public function deleteUsersIdUserConnectionsIdConnectionAccountsIdAccountTransactionsclustersIdTransactionscluster(
        \OpenAPI\OpenAPI\Models\Operations\DeleteUsersIdUserConnectionsIdConnectionAccountsIdAccountTransactionsclustersIdTransactionsclusterRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\DeleteUsersIdUserConnectionsIdConnectionAccountsIdAccountTransactionsclustersIdTransactionsclusterResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/users/{id_user}/connections/{id_connection}/accounts/{id_account}/transactionsclusters/{id_transactionscluster}', \OpenAPI\OpenAPI\Models\Operations\DeleteUsersIdUserConnectionsIdConnectionAccountsIdAccountTransactionsclustersIdTransactionsclusterRequest::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\DeleteUsersIdUserConnectionsIdConnectionAccountsIdAccountTransactionsclustersIdTransactionsclusterRequest::class, $request, null));
        
        $httpResponse = $this->_defaultClient->request('DELETE', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\DeleteUsersIdUserConnectionsIdConnectionAccountsIdAccountTransactionsclustersIdTransactionsclusterResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->transactionsCluster = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\TransactionsCluster', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Disable a connection source
     * 
     * This will make it so the specified source will not be synchronized anymore.<br><br>
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\DeleteUsersIdUserConnectionsIdConnectionSourcesIdSourceRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\DeleteUsersIdUserConnectionsIdConnectionSourcesIdSourceResponse
     */
	public function deleteUsersIdUserConnectionsIdConnectionSourcesIdSource(
        \OpenAPI\OpenAPI\Models\Operations\DeleteUsersIdUserConnectionsIdConnectionSourcesIdSourceRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\DeleteUsersIdUserConnectionsIdConnectionSourcesIdSourceResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/users/{id_user}/connections/{id_connection}/sources/{id_source}', \OpenAPI\OpenAPI\Models\Operations\DeleteUsersIdUserConnectionsIdConnectionSourcesIdSourceRequest::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\DeleteUsersIdUserConnectionsIdConnectionSourcesIdSourceRequest::class, $request, null));
        
        $httpResponse = $this->_defaultClient->request('DELETE', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\DeleteUsersIdUserConnectionsIdConnectionSourcesIdSourceResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->connectionSource = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\ConnectionSource', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Delete a clustered transaction
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\DeleteUsersIdUserConnectionsIdConnectionTransactionsclustersIdTransactionsclusterRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\DeleteUsersIdUserConnectionsIdConnectionTransactionsclustersIdTransactionsclusterResponse
     */
	public function deleteUsersIdUserConnectionsIdConnectionTransactionsclustersIdTransactionscluster(
        \OpenAPI\OpenAPI\Models\Operations\DeleteUsersIdUserConnectionsIdConnectionTransactionsclustersIdTransactionsclusterRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\DeleteUsersIdUserConnectionsIdConnectionTransactionsclustersIdTransactionsclusterResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/users/{id_user}/connections/{id_connection}/transactionsclusters/{id_transactionscluster}', \OpenAPI\OpenAPI\Models\Operations\DeleteUsersIdUserConnectionsIdConnectionTransactionsclustersIdTransactionsclusterRequest::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\DeleteUsersIdUserConnectionsIdConnectionTransactionsclustersIdTransactionsclusterRequest::class, $request, null));
        
        $httpResponse = $this->_defaultClient->request('DELETE', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\DeleteUsersIdUserConnectionsIdConnectionTransactionsclustersIdTransactionsclusterResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->transactionsCluster = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\TransactionsCluster', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Delete a clustered transaction
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\DeleteUsersIdUserTransactionsclustersIdTransactionsclusterRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\DeleteUsersIdUserTransactionsclustersIdTransactionsclusterResponse
     */
	public function deleteUsersIdUserTransactionsclustersIdTransactionscluster(
        \OpenAPI\OpenAPI\Models\Operations\DeleteUsersIdUserTransactionsclustersIdTransactionsclusterRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\DeleteUsersIdUserTransactionsclustersIdTransactionsclusterResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/users/{id_user}/transactionsclusters/{id_transactionscluster}', \OpenAPI\OpenAPI\Models\Operations\DeleteUsersIdUserTransactionsclustersIdTransactionsclusterRequest::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\DeleteUsersIdUserTransactionsclustersIdTransactionsclusterRequest::class, $request, null));
        
        $httpResponse = $this->_defaultClient->request('DELETE', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\DeleteUsersIdUserTransactionsclustersIdTransactionsclusterResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->transactionsCluster = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\TransactionsCluster', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Get account types
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetAccountTypesRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\GetAccountTypesResponse
     */
	public function getAccountTypes(
        \OpenAPI\OpenAPI\Models\Operations\GetAccountTypesRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\GetAccountTypesResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/account_types');
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\GetAccountTypesRequest::class, $request, null));
        
        $httpResponse = $this->_defaultClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetAccountTypesResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->getAccountTypes200ApplicationJSONObject = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Operations\GetAccountTypes200ApplicationJSON', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Get an account type
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetAccountTypesIdAccountTypeRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\GetAccountTypesIdAccountTypeResponse
     */
	public function getAccountTypesIdAccountType(
        \OpenAPI\OpenAPI\Models\Operations\GetAccountTypesIdAccountTypeRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\GetAccountTypesIdAccountTypeResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/account_types/{id_account_type}', \OpenAPI\OpenAPI\Models\Operations\GetAccountTypesIdAccountTypeRequest::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\GetAccountTypesIdAccountTypeRequest::class, $request, null));
        
        $httpResponse = $this->_defaultClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetAccountTypesIdAccountTypeResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->accountType = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\AccountType', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Get list of connectors
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetBanksRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\GetBanksResponse
     */
	public function getBanks(
        \OpenAPI\OpenAPI\Models\Operations\GetBanksRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\GetBanksResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/banks');
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\GetBanksRequest::class, $request, null));
        
        $httpResponse = $this->_defaultClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetBanksResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->getBanks200ApplicationJSONObject = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Operations\GetBanks200ApplicationJSON', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Get a connector
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetBanksIdBankRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\GetBanksIdBankResponse
     */
	public function getBanksIdBank(
        \OpenAPI\OpenAPI\Models\Operations\GetBanksIdBankRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\GetBanksIdBankResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/banks/{id_bank}', \OpenAPI\OpenAPI\Models\Operations\GetBanksIdBankRequest::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\GetBanksIdBankRequest::class, $request, null));
        
        $httpResponse = $this->_defaultClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetBanksIdBankResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->connector = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\Connector', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Get a subset of id_connection for a given bank. Different selection methode are possible
     * 
     * By default, it selects a set of 3 connections with the 'diversity' method<br><br>
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetBanksIdConnectorConnectionsRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\GetBanksIdConnectorConnectionsResponse
     */
	public function getBanksIdConnectorConnections(
        \OpenAPI\OpenAPI\Models\Operations\GetBanksIdConnectorConnectionsRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\GetBanksIdConnectorConnectionsResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/banks/{id_connector}/connections', \OpenAPI\OpenAPI\Models\Operations\GetBanksIdConnectorConnectionsRequest::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\GetBanksIdConnectorConnectionsRequest::class, $request, null));
        
        $httpResponse = $this->_defaultClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetBanksIdConnectorConnectionsResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->getBanksIdConnectorConnections200ApplicationJSONObject = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Operations\GetBanksIdConnectorConnections200ApplicationJSON', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Get all links to the files associated with this connector.
     * 
     * This endpoint returns all links to files associated with this connector.<br><br>
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetBanksIdConnectorLogosRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\GetBanksIdConnectorLogosResponse
     */
	public function getBanksIdConnectorLogos(
        \OpenAPI\OpenAPI\Models\Operations\GetBanksIdConnectorLogosRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\GetBanksIdConnectorLogosResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/banks/{id_connector}/logos', \OpenAPI\OpenAPI\Models\Operations\GetBanksIdConnectorLogosRequest::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\GetBanksIdConnectorLogosRequest::class, $request, null));
        
        $httpResponse = $this->_defaultClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetBanksIdConnectorLogosResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->getBanksIdConnectorLogos200ApplicationJSONObject = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Operations\GetBanksIdConnectorLogos200ApplicationJSON', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Get all links to the files associated with this connector.
     * 
     * This endpoint returns all links to files associated with this connector.<br><br>
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetBanksIdConnectorLogosMainRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\GetBanksIdConnectorLogosMainResponse
     */
	public function getBanksIdConnectorLogosMain(
        \OpenAPI\OpenAPI\Models\Operations\GetBanksIdConnectorLogosMainRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\GetBanksIdConnectorLogosMainResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/banks/{id_connector}/logos/main', \OpenAPI\OpenAPI\Models\Operations\GetBanksIdConnectorLogosMainRequest::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\GetBanksIdConnectorLogosMainRequest::class, $request, null));
        
        $httpResponse = $this->_defaultClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetBanksIdConnectorLogosMainResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->getBanksIdConnectorLogosMain200ApplicationJSONObject = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Operations\GetBanksIdConnectorLogosMain200ApplicationJSON', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Get all links to the files associated with this connector.
     * 
     * This endpoint returns all links to files associated with this connector.<br><br>
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetBanksIdConnectorLogosThumbnailRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\GetBanksIdConnectorLogosThumbnailResponse
     */
	public function getBanksIdConnectorLogosThumbnail(
        \OpenAPI\OpenAPI\Models\Operations\GetBanksIdConnectorLogosThumbnailRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\GetBanksIdConnectorLogosThumbnailResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/banks/{id_connector}/logos/thumbnail', \OpenAPI\OpenAPI\Models\Operations\GetBanksIdConnectorLogosThumbnailRequest::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\GetBanksIdConnectorLogosThumbnailRequest::class, $request, null));
        
        $httpResponse = $this->_defaultClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetBanksIdConnectorLogosThumbnailResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->getBanksIdConnectorLogosThumbnail200ApplicationJSONObject = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Operations\GetBanksIdConnectorLogosThumbnail200ApplicationJSON', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Get list of connector sources
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetBanksIdConnectorSourcesRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\GetBanksIdConnectorSourcesResponse
     */
	public function getBanksIdConnectorSources(
        \OpenAPI\OpenAPI\Models\Operations\GetBanksIdConnectorSourcesRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\GetBanksIdConnectorSourcesResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/banks/{id_connector}/sources', \OpenAPI\OpenAPI\Models\Operations\GetBanksIdConnectorSourcesRequest::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\GetBanksIdConnectorSourcesRequest::class, $request, null));
        
        $httpResponse = $this->_defaultClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetBanksIdConnectorSourcesResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->getBanksIdConnectorSources200ApplicationJSONObject = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Operations\GetBanksIdConnectorSources200ApplicationJSON', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Get fields specific to a domain and a source
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetBanksIdConnectorSourcesIdConnectorSourceFieldsRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\GetBanksIdConnectorSourcesIdConnectorSourceFieldsResponse
     */
	public function getBanksIdConnectorSourcesIdConnectorSourceFields(
        \OpenAPI\OpenAPI\Models\Operations\GetBanksIdConnectorSourcesIdConnectorSourceFieldsRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\GetBanksIdConnectorSourcesIdConnectorSourceFieldsResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/banks/{id_connector}/sources/{id_connector_source}/fields', \OpenAPI\OpenAPI\Models\Operations\GetBanksIdConnectorSourcesIdConnectorSourceFieldsRequest::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\GetBanksIdConnectorSourcesIdConnectorSourceFieldsRequest::class, $request, null));
        
        $httpResponse = $this->_defaultClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetBanksIdConnectorSourcesIdConnectorSourceFieldsResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->getBanksIdConnectorSourcesIdConnectorSourceFields200ApplicationJSONObject = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Operations\GetBanksIdConnectorSourcesIdConnectorSourceFields200ApplicationJSON', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Get the connector source
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetBanksIdConnectorSourcesIdSourceRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\GetBanksIdConnectorSourcesIdSourceResponse
     */
	public function getBanksIdConnectorSourcesIdSource(
        \OpenAPI\OpenAPI\Models\Operations\GetBanksIdConnectorSourcesIdSourceRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\GetBanksIdConnectorSourcesIdSourceResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/banks/{id_connector}/sources/{id_source}', \OpenAPI\OpenAPI\Models\Operations\GetBanksIdConnectorSourcesIdSourceRequest::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\GetBanksIdConnectorSourcesIdSourceRequest::class, $request, null));
        
        $httpResponse = $this->_defaultClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetBanksIdConnectorSourcesIdSourceResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->connectorSource = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\ConnectorSource', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Get all categories
     * 
     * Ressource to get all existing categories<br><br>
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetCategoriesRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\GetCategoriesResponse
     */
	public function getCategories(
        \OpenAPI\OpenAPI\Models\Operations\GetCategoriesRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\GetCategoriesResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/categories');
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\GetCategoriesRequest::class, $request, null));
        
        $httpResponse = $this->_defaultClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetCategoriesResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->getCategories200ApplicationJSONObject = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Operations\GetCategories200ApplicationJSON', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Get connections without a user
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetConnectionsRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\GetConnectionsResponse
     */
	public function getConnections(
        \OpenAPI\OpenAPI\Models\Operations\GetConnectionsRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\GetConnectionsResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/connections');
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\GetConnectionsRequest::class, $request, null));
        
        $httpResponse = $this->_defaultClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetConnectionsResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->getConnections200ApplicationJSONObject = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Operations\GetConnections200ApplicationJSON', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Get connection logs
     * 
     * Get logs about connections.<br><br>
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetConnectionsIdConnectionLogsRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\GetConnectionsIdConnectionLogsResponse
     */
	public function getConnectionsIdConnectionLogs(
        \OpenAPI\OpenAPI\Models\Operations\GetConnectionsIdConnectionLogsRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\GetConnectionsIdConnectionLogsResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/connections/{id_connection}/logs', \OpenAPI\OpenAPI\Models\Operations\GetConnectionsIdConnectionLogsRequest::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\GetConnectionsIdConnectionLogsRequest::class, $request, null));
        
        $httpResponse = $this->_defaultClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetConnectionsIdConnectionLogsResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->getConnectionsIdConnectionLogs200ApplicationJSONObject = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Operations\GetConnectionsIdConnectionLogs200ApplicationJSON', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Get connection sources
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetConnectionsIdConnectionSourcesRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\GetConnectionsIdConnectionSourcesResponse
     */
	public function getConnectionsIdConnectionSources(
        \OpenAPI\OpenAPI\Models\Operations\GetConnectionsIdConnectionSourcesRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\GetConnectionsIdConnectionSourcesResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/connections/{id_connection}/sources', \OpenAPI\OpenAPI\Models\Operations\GetConnectionsIdConnectionSourcesRequest::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\GetConnectionsIdConnectionSourcesRequest::class, $request, null));
        
        $httpResponse = $this->_defaultClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetConnectionsIdConnectionSourcesResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->getConnectionsIdConnectionSources200ApplicationJSONObject = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Operations\GetConnectionsIdConnectionSources200ApplicationJSON', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Get list of connectors
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetConnectorsRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\GetConnectorsResponse
     */
	public function getConnectors(
        \OpenAPI\OpenAPI\Models\Operations\GetConnectorsRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\GetConnectorsResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/connectors');
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\GetConnectorsRequest::class, $request, null));
        
        $httpResponse = $this->_defaultClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetConnectorsResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->getConnectors200ApplicationJSONObject = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Operations\GetConnectors200ApplicationJSON', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Get a connector
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetConnectorsIdConnectorRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\GetConnectorsIdConnectorResponse
     */
	public function getConnectorsIdConnector(
        \OpenAPI\OpenAPI\Models\Operations\GetConnectorsIdConnectorRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\GetConnectorsIdConnectorResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/connectors/{id_connector}', \OpenAPI\OpenAPI\Models\Operations\GetConnectorsIdConnectorRequest::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\GetConnectorsIdConnectorRequest::class, $request, null));
        
        $httpResponse = $this->_defaultClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetConnectorsIdConnectorResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->connector = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\Connector', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Get all links to the files associated with this connector.
     * 
     * This endpoint returns all links to files associated with this connector.<br><br>
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetConnectorsIdConnectorLogosRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\GetConnectorsIdConnectorLogosResponse
     */
	public function getConnectorsIdConnectorLogos(
        \OpenAPI\OpenAPI\Models\Operations\GetConnectorsIdConnectorLogosRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\GetConnectorsIdConnectorLogosResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/connectors/{id_connector}/logos', \OpenAPI\OpenAPI\Models\Operations\GetConnectorsIdConnectorLogosRequest::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\GetConnectorsIdConnectorLogosRequest::class, $request, null));
        
        $httpResponse = $this->_defaultClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetConnectorsIdConnectorLogosResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->getConnectorsIdConnectorLogos200ApplicationJSONObject = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Operations\GetConnectorsIdConnectorLogos200ApplicationJSON', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Get all links to the files associated with this connector.
     * 
     * This endpoint returns all links to files associated with this connector.<br><br>
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetConnectorsIdConnectorLogosMainRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\GetConnectorsIdConnectorLogosMainResponse
     */
	public function getConnectorsIdConnectorLogosMain(
        \OpenAPI\OpenAPI\Models\Operations\GetConnectorsIdConnectorLogosMainRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\GetConnectorsIdConnectorLogosMainResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/connectors/{id_connector}/logos/main', \OpenAPI\OpenAPI\Models\Operations\GetConnectorsIdConnectorLogosMainRequest::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\GetConnectorsIdConnectorLogosMainRequest::class, $request, null));
        
        $httpResponse = $this->_defaultClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetConnectorsIdConnectorLogosMainResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->getConnectorsIdConnectorLogosMain200ApplicationJSONObject = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Operations\GetConnectorsIdConnectorLogosMain200ApplicationJSON', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Get all links to the files associated with this connector.
     * 
     * This endpoint returns all links to files associated with this connector.<br><br>
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetConnectorsIdConnectorLogosThumbnailRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\GetConnectorsIdConnectorLogosThumbnailResponse
     */
	public function getConnectorsIdConnectorLogosThumbnail(
        \OpenAPI\OpenAPI\Models\Operations\GetConnectorsIdConnectorLogosThumbnailRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\GetConnectorsIdConnectorLogosThumbnailResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/connectors/{id_connector}/logos/thumbnail', \OpenAPI\OpenAPI\Models\Operations\GetConnectorsIdConnectorLogosThumbnailRequest::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\GetConnectorsIdConnectorLogosThumbnailRequest::class, $request, null));
        
        $httpResponse = $this->_defaultClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetConnectorsIdConnectorLogosThumbnailResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->getConnectorsIdConnectorLogosThumbnail200ApplicationJSONObject = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Operations\GetConnectorsIdConnectorLogosThumbnail200ApplicationJSON', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Get list of connector sources
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetConnectorsIdConnectorSourcesRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\GetConnectorsIdConnectorSourcesResponse
     */
	public function getConnectorsIdConnectorSources(
        \OpenAPI\OpenAPI\Models\Operations\GetConnectorsIdConnectorSourcesRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\GetConnectorsIdConnectorSourcesResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/connectors/{id_connector}/sources', \OpenAPI\OpenAPI\Models\Operations\GetConnectorsIdConnectorSourcesRequest::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\GetConnectorsIdConnectorSourcesRequest::class, $request, null));
        
        $httpResponse = $this->_defaultClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetConnectorsIdConnectorSourcesResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->getConnectorsIdConnectorSources200ApplicationJSONObject = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Operations\GetConnectorsIdConnectorSources200ApplicationJSON', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Get fields specific to a domain and a source
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetConnectorsIdConnectorSourcesIdConnectorSourceFieldsRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\GetConnectorsIdConnectorSourcesIdConnectorSourceFieldsResponse
     */
	public function getConnectorsIdConnectorSourcesIdConnectorSourceFields(
        \OpenAPI\OpenAPI\Models\Operations\GetConnectorsIdConnectorSourcesIdConnectorSourceFieldsRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\GetConnectorsIdConnectorSourcesIdConnectorSourceFieldsResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/connectors/{id_connector}/sources/{id_connector_source}/fields', \OpenAPI\OpenAPI\Models\Operations\GetConnectorsIdConnectorSourcesIdConnectorSourceFieldsRequest::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\GetConnectorsIdConnectorSourcesIdConnectorSourceFieldsRequest::class, $request, null));
        
        $httpResponse = $this->_defaultClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetConnectorsIdConnectorSourcesIdConnectorSourceFieldsResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->getConnectorsIdConnectorSourcesIdConnectorSourceFields200ApplicationJSONObject = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Operations\GetConnectorsIdConnectorSourcesIdConnectorSourceFields200ApplicationJSON', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Get the connector source
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetConnectorsIdConnectorSourcesIdSourceRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\GetConnectorsIdConnectorSourcesIdSourceResponse
     */
	public function getConnectorsIdConnectorSourcesIdSource(
        \OpenAPI\OpenAPI\Models\Operations\GetConnectorsIdConnectorSourcesIdSourceRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\GetConnectorsIdConnectorSourcesIdSourceResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/connectors/{id_connector}/sources/{id_source}', \OpenAPI\OpenAPI\Models\Operations\GetConnectorsIdConnectorSourcesIdSourceRequest::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\GetConnectorsIdConnectorSourcesIdSourceRequest::class, $request, null));
        
        $httpResponse = $this->_defaultClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetConnectorsIdConnectorSourcesIdSourceResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->connectorSource = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\ConnectorSource', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Get invoicing data for a given period (default is the current month).
     * 
     * You can get all the invoicing data or just specific ones by using the available parameters.<br><br>If no parameters are specified, no invoicing data is returned.<br><br>
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetInvoicingRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\GetInvoicingResponse
     */
	public function getInvoicing(
        \OpenAPI\OpenAPI\Models\Operations\GetInvoicingRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\GetInvoicingResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/invoicing');
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\GetInvoicingRequest::class, $request, null));
        
        $httpResponse = $this->_defaultClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetInvoicingResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
        }

        return $response;
    }
	
    /**
     * Get connection logs
     * 
     * Get logs about connections.<br><br>
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetLogsRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\GetLogsResponse
     */
	public function getLogs(
        \OpenAPI\OpenAPI\Models\Operations\GetLogsRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\GetLogsResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/logs');
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\GetLogsRequest::class, $request, null));
        
        $httpResponse = $this->_defaultClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetLogsResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->getLogs200ApplicationJSONObject = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Operations\GetLogs200ApplicationJSON', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Get list of connectors
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetProvidersRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\GetProvidersResponse
     */
	public function getProviders(
        \OpenAPI\OpenAPI\Models\Operations\GetProvidersRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\GetProvidersResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/providers');
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\GetProvidersRequest::class, $request, null));
        
        $httpResponse = $this->_defaultClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetProvidersResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->getProviders200ApplicationJSONObject = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Operations\GetProviders200ApplicationJSON', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Get a random subset of provider's id_connection
     * 
     * By default, it selects a set of 3 connections.<br><br>
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetProvidersIdConnectorConnectionsRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\GetProvidersIdConnectorConnectionsResponse
     */
	public function getProvidersIdConnectorConnections(
        \OpenAPI\OpenAPI\Models\Operations\GetProvidersIdConnectorConnectionsRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\GetProvidersIdConnectorConnectionsResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/providers/{id_connector}/connections', \OpenAPI\OpenAPI\Models\Operations\GetProvidersIdConnectorConnectionsRequest::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\GetProvidersIdConnectorConnectionsRequest::class, $request, null));
        
        $httpResponse = $this->_defaultClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetProvidersIdConnectorConnectionsResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->getProvidersIdConnectorConnections200ApplicationJSONObject = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Operations\GetProvidersIdConnectorConnections200ApplicationJSON', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Get all links to the files associated with this connector.
     * 
     * This endpoint returns all links to files associated with this connector.<br><br>
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetProvidersIdConnectorLogosRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\GetProvidersIdConnectorLogosResponse
     */
	public function getProvidersIdConnectorLogos(
        \OpenAPI\OpenAPI\Models\Operations\GetProvidersIdConnectorLogosRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\GetProvidersIdConnectorLogosResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/providers/{id_connector}/logos', \OpenAPI\OpenAPI\Models\Operations\GetProvidersIdConnectorLogosRequest::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\GetProvidersIdConnectorLogosRequest::class, $request, null));
        
        $httpResponse = $this->_defaultClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetProvidersIdConnectorLogosResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->getProvidersIdConnectorLogos200ApplicationJSONObject = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Operations\GetProvidersIdConnectorLogos200ApplicationJSON', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Get all links to the files associated with this connector.
     * 
     * This endpoint returns all links to files associated with this connector.<br><br>
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetProvidersIdConnectorLogosMainRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\GetProvidersIdConnectorLogosMainResponse
     */
	public function getProvidersIdConnectorLogosMain(
        \OpenAPI\OpenAPI\Models\Operations\GetProvidersIdConnectorLogosMainRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\GetProvidersIdConnectorLogosMainResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/providers/{id_connector}/logos/main', \OpenAPI\OpenAPI\Models\Operations\GetProvidersIdConnectorLogosMainRequest::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\GetProvidersIdConnectorLogosMainRequest::class, $request, null));
        
        $httpResponse = $this->_defaultClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetProvidersIdConnectorLogosMainResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->getProvidersIdConnectorLogosMain200ApplicationJSONObject = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Operations\GetProvidersIdConnectorLogosMain200ApplicationJSON', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Get all links to the files associated with this connector.
     * 
     * This endpoint returns all links to files associated with this connector.<br><br>
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetProvidersIdConnectorLogosThumbnailRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\GetProvidersIdConnectorLogosThumbnailResponse
     */
	public function getProvidersIdConnectorLogosThumbnail(
        \OpenAPI\OpenAPI\Models\Operations\GetProvidersIdConnectorLogosThumbnailRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\GetProvidersIdConnectorLogosThumbnailResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/providers/{id_connector}/logos/thumbnail', \OpenAPI\OpenAPI\Models\Operations\GetProvidersIdConnectorLogosThumbnailRequest::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\GetProvidersIdConnectorLogosThumbnailRequest::class, $request, null));
        
        $httpResponse = $this->_defaultClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetProvidersIdConnectorLogosThumbnailResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->getProvidersIdConnectorLogosThumbnail200ApplicationJSONObject = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Operations\GetProvidersIdConnectorLogosThumbnail200ApplicationJSON', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Get list of connector sources
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetProvidersIdConnectorSourcesRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\GetProvidersIdConnectorSourcesResponse
     */
	public function getProvidersIdConnectorSources(
        \OpenAPI\OpenAPI\Models\Operations\GetProvidersIdConnectorSourcesRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\GetProvidersIdConnectorSourcesResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/providers/{id_connector}/sources', \OpenAPI\OpenAPI\Models\Operations\GetProvidersIdConnectorSourcesRequest::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\GetProvidersIdConnectorSourcesRequest::class, $request, null));
        
        $httpResponse = $this->_defaultClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetProvidersIdConnectorSourcesResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->getProvidersIdConnectorSources200ApplicationJSONObject = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Operations\GetProvidersIdConnectorSources200ApplicationJSON', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Get fields specific to a domain and a source
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetProvidersIdConnectorSourcesIdConnectorSourceFieldsRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\GetProvidersIdConnectorSourcesIdConnectorSourceFieldsResponse
     */
	public function getProvidersIdConnectorSourcesIdConnectorSourceFields(
        \OpenAPI\OpenAPI\Models\Operations\GetProvidersIdConnectorSourcesIdConnectorSourceFieldsRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\GetProvidersIdConnectorSourcesIdConnectorSourceFieldsResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/providers/{id_connector}/sources/{id_connector_source}/fields', \OpenAPI\OpenAPI\Models\Operations\GetProvidersIdConnectorSourcesIdConnectorSourceFieldsRequest::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\GetProvidersIdConnectorSourcesIdConnectorSourceFieldsRequest::class, $request, null));
        
        $httpResponse = $this->_defaultClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetProvidersIdConnectorSourcesIdConnectorSourceFieldsResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->getProvidersIdConnectorSourcesIdConnectorSourceFields200ApplicationJSONObject = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Operations\GetProvidersIdConnectorSourcesIdConnectorSourceFields200ApplicationJSON', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Get the connector source
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetProvidersIdConnectorSourcesIdSourceRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\GetProvidersIdConnectorSourcesIdSourceResponse
     */
	public function getProvidersIdConnectorSourcesIdSource(
        \OpenAPI\OpenAPI\Models\Operations\GetProvidersIdConnectorSourcesIdSourceRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\GetProvidersIdConnectorSourcesIdSourceResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/providers/{id_connector}/sources/{id_source}', \OpenAPI\OpenAPI\Models\Operations\GetProvidersIdConnectorSourcesIdSourceRequest::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\GetProvidersIdConnectorSourcesIdSourceRequest::class, $request, null));
        
        $httpResponse = $this->_defaultClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetProvidersIdConnectorSourcesIdSourceResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->connectorSource = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\ConnectorSource', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Get a connector
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetProvidersIdProviderRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\GetProvidersIdProviderResponse
     */
	public function getProvidersIdProvider(
        \OpenAPI\OpenAPI\Models\Operations\GetProvidersIdProviderRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\GetProvidersIdProviderResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/providers/{id_provider}', \OpenAPI\OpenAPI\Models\Operations\GetProvidersIdProviderRequest::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\GetProvidersIdProviderRequest::class, $request, null));
        
        $httpResponse = $this->_defaultClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetProvidersIdProviderResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->connector = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\Connector', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Get details on all psd2 registrations
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetPsd2RegistrationsRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\GetPsd2RegistrationsResponse
     */
	public function getPsd2Registrations(
        \OpenAPI\OpenAPI\Models\Operations\GetPsd2RegistrationsRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\GetPsd2RegistrationsResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/psd2-registrations');
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\GetPsd2RegistrationsRequest::class, $request, null));
        
        $httpResponse = $this->_defaultClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetPsd2RegistrationsResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->getPsd2Registrations200ApplicationJSONObject = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Operations\GetPsd2Registrations200ApplicationJSON', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Get details for a given psd2 registration
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetPsd2RegistrationsIdPsd2RegistrationRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\GetPsd2RegistrationsIdPsd2RegistrationResponse
     */
	public function getPsd2RegistrationsIdPsd2Registration(
        \OpenAPI\OpenAPI\Models\Operations\GetPsd2RegistrationsIdPsd2RegistrationRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\GetPsd2RegistrationsIdPsd2RegistrationResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/psd2-registrations/{id_psd2-registration}', \OpenAPI\OpenAPI\Models\Operations\GetPsd2RegistrationsIdPsd2RegistrationRequest::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\GetPsd2RegistrationsIdPsd2RegistrationRequest::class, $request, null));
        
        $httpResponse = $this->_defaultClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetPsd2RegistrationsIdPsd2RegistrationResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->psd2Registration = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\Psd2Registration', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Get psd2 registration logs.
     * 
     * Get logs of psd2 registration. By default, it selects logs for the last month. You can use "min_date" and "max_date" to change boundary dates.<br><br>
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetPsd2RegistrationsIdPsd2registrationLogsRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\GetPsd2RegistrationsIdPsd2registrationLogsResponse
     */
	public function getPsd2RegistrationsIdPsd2registrationLogs(
        \OpenAPI\OpenAPI\Models\Operations\GetPsd2RegistrationsIdPsd2registrationLogsRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\GetPsd2RegistrationsIdPsd2registrationLogsResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/psd2-registrations/{id_psd2registration}/logs', \OpenAPI\OpenAPI\Models\Operations\GetPsd2RegistrationsIdPsd2registrationLogsRequest::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\GetPsd2RegistrationsIdPsd2registrationLogsRequest::class, $request, null));
        
        $httpResponse = $this->_defaultClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetPsd2RegistrationsIdPsd2registrationLogsResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->getPsd2RegistrationsIdPsd2registrationLogs200ApplicationJSONObject = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Operations\GetPsd2RegistrationsIdPsd2registrationLogs200ApplicationJSON', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Get account types
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetUsersIdUserAccountTypesRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\GetUsersIdUserAccountTypesResponse
     */
	public function getUsersIdUserAccountTypes(
        \OpenAPI\OpenAPI\Models\Operations\GetUsersIdUserAccountTypesRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\GetUsersIdUserAccountTypesResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/users/{id_user}/account_types', \OpenAPI\OpenAPI\Models\Operations\GetUsersIdUserAccountTypesRequest::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\GetUsersIdUserAccountTypesRequest::class, $request, null));
        
        $httpResponse = $this->_defaultClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetUsersIdUserAccountTypesResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->getUsersIdUserAccountTypes200ApplicationJSONObject = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Operations\GetUsersIdUserAccountTypes200ApplicationJSON', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Get an account type
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetUsersIdUserAccountTypesIdAccountTypeRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\GetUsersIdUserAccountTypesIdAccountTypeResponse
     */
	public function getUsersIdUserAccountTypesIdAccountType(
        \OpenAPI\OpenAPI\Models\Operations\GetUsersIdUserAccountTypesIdAccountTypeRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\GetUsersIdUserAccountTypesIdAccountTypeResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/users/{id_user}/account_types/{id_account_type}', \OpenAPI\OpenAPI\Models\Operations\GetUsersIdUserAccountTypesIdAccountTypeRequest::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\GetUsersIdUserAccountTypesIdAccountTypeRequest::class, $request, null));
        
        $httpResponse = $this->_defaultClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetUsersIdUserAccountTypesIdAccountTypeResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->accountType = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\AccountType', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Get the category
     * 
     * Ressource to get categories for the user's transactions<br><br>
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetUsersIdUserAccountsIdAccountCategoriesRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\GetUsersIdUserAccountsIdAccountCategoriesResponse
     */
	public function getUsersIdUserAccountsIdAccountCategories(
        \OpenAPI\OpenAPI\Models\Operations\GetUsersIdUserAccountsIdAccountCategoriesRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\GetUsersIdUserAccountsIdAccountCategoriesResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/users/{id_user}/accounts/{id_account}/categories', \OpenAPI\OpenAPI\Models\Operations\GetUsersIdUserAccountsIdAccountCategoriesRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_defaultClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetUsersIdUserAccountsIdAccountCategoriesResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
        }

        return $response;
    }
	
    /**
     * Get clustered transactions
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetUsersIdUserAccountsIdAccountTransactionsclustersRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\GetUsersIdUserAccountsIdAccountTransactionsclustersResponse
     */
	public function getUsersIdUserAccountsIdAccountTransactionsclusters(
        \OpenAPI\OpenAPI\Models\Operations\GetUsersIdUserAccountsIdAccountTransactionsclustersRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\GetUsersIdUserAccountsIdAccountTransactionsclustersResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/users/{id_user}/accounts/{id_account}/transactionsclusters', \OpenAPI\OpenAPI\Models\Operations\GetUsersIdUserAccountsIdAccountTransactionsclustersRequest::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\GetUsersIdUserAccountsIdAccountTransactionsclustersRequest::class, $request, null));
        
        $httpResponse = $this->_defaultClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetUsersIdUserAccountsIdAccountTransactionsclustersResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->getUsersIdUserAccountsIdAccountTransactionsclusters200ApplicationJSONObject = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Operations\GetUsersIdUserAccountsIdAccountTransactionsclusters200ApplicationJSON', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Get alerts
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetUsersIdUserAlertsRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\GetUsersIdUserAlertsResponse
     */
	public function getUsersIdUserAlerts(
        \OpenAPI\OpenAPI\Models\Operations\GetUsersIdUserAlertsRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\GetUsersIdUserAlertsResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/users/{id_user}/alerts', \OpenAPI\OpenAPI\Models\Operations\GetUsersIdUserAlertsRequest::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\GetUsersIdUserAlertsRequest::class, $request, null));
        
        $httpResponse = $this->_defaultClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetUsersIdUserAlertsResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->getUsersIdUserAlerts200ApplicationJSONObject = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Operations\GetUsersIdUserAlerts200ApplicationJSON', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Get the category
     * 
     * Ressource to get categories for the user's transactions<br><br>
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetUsersIdUserCategoriesRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\GetUsersIdUserCategoriesResponse
     */
	public function getUsersIdUserCategories(
        \OpenAPI\OpenAPI\Models\Operations\GetUsersIdUserCategoriesRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\GetUsersIdUserCategoriesResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/users/{id_user}/categories', \OpenAPI\OpenAPI\Models\Operations\GetUsersIdUserCategoriesRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_defaultClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetUsersIdUserCategoriesResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
        }

        return $response;
    }
	
    /**
     * Get the category
     * 
     * Ressource to get categories<br><br>
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetUsersIdUserCategoriesFullRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\GetUsersIdUserCategoriesFullResponse
     */
	public function getUsersIdUserCategoriesFull(
        \OpenAPI\OpenAPI\Models\Operations\GetUsersIdUserCategoriesFullRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\GetUsersIdUserCategoriesFullResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/users/{id_user}/categories/full', \OpenAPI\OpenAPI\Models\Operations\GetUsersIdUserCategoriesFullRequest::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\GetUsersIdUserCategoriesFullRequest::class, $request, null));
        
        $httpResponse = $this->_defaultClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetUsersIdUserCategoriesFullResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->getUsersIdUserCategoriesFull200ApplicationJSONObject = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Operations\GetUsersIdUserCategoriesFull200ApplicationJSON', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Get connections
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetUsersIdUserConnectionsRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\GetUsersIdUserConnectionsResponse
     */
	public function getUsersIdUserConnections(
        \OpenAPI\OpenAPI\Models\Operations\GetUsersIdUserConnectionsRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\GetUsersIdUserConnectionsResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/users/{id_user}/connections', \OpenAPI\OpenAPI\Models\Operations\GetUsersIdUserConnectionsRequest::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\GetUsersIdUserConnectionsRequest::class, $request, null));
        
        $httpResponse = $this->_defaultClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetUsersIdUserConnectionsResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->getUsersIdUserConnections200ApplicationJSONObject = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Operations\GetUsersIdUserConnections200ApplicationJSON', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Get accounts list.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetUsersIdUserConnectionsIdConnectionAccountsRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\GetUsersIdUserConnectionsIdConnectionAccountsResponse
     */
	public function getUsersIdUserConnectionsIdConnectionAccounts(
        \OpenAPI\OpenAPI\Models\Operations\GetUsersIdUserConnectionsIdConnectionAccountsRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\GetUsersIdUserConnectionsIdConnectionAccountsResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/users/{id_user}/connections/{id_connection}/accounts', \OpenAPI\OpenAPI\Models\Operations\GetUsersIdUserConnectionsIdConnectionAccountsRequest::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\GetUsersIdUserConnectionsIdConnectionAccountsRequest::class, $request, null));
        
        $httpResponse = $this->_defaultClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetUsersIdUserConnectionsIdConnectionAccountsResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->getUsersIdUserConnectionsIdConnectionAccounts200ApplicationJSONObject = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Operations\GetUsersIdUserConnectionsIdConnectionAccounts200ApplicationJSON', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Get the category
     * 
     * Ressource to get categories for the user's transactions<br><br>
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetUsersIdUserConnectionsIdConnectionAccountsIdAccountCategoriesRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\GetUsersIdUserConnectionsIdConnectionAccountsIdAccountCategoriesResponse
     */
	public function getUsersIdUserConnectionsIdConnectionAccountsIdAccountCategories(
        \OpenAPI\OpenAPI\Models\Operations\GetUsersIdUserConnectionsIdConnectionAccountsIdAccountCategoriesRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\GetUsersIdUserConnectionsIdConnectionAccountsIdAccountCategoriesResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/users/{id_user}/connections/{id_connection}/accounts/{id_account}/categories', \OpenAPI\OpenAPI\Models\Operations\GetUsersIdUserConnectionsIdConnectionAccountsIdAccountCategoriesRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_defaultClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetUsersIdUserConnectionsIdConnectionAccountsIdAccountCategoriesResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
        }

        return $response;
    }
	
    /**
     * Get deltas of accounts
     * 
     * Get account delta between sums of transactions and difference of account balance for the given period.<br><br>
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetUsersIdUserConnectionsIdConnectionAccountsIdAccountDeltaRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\GetUsersIdUserConnectionsIdConnectionAccountsIdAccountDeltaResponse
     */
	public function getUsersIdUserConnectionsIdConnectionAccountsIdAccountDelta(
        \OpenAPI\OpenAPI\Models\Operations\GetUsersIdUserConnectionsIdConnectionAccountsIdAccountDeltaRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\GetUsersIdUserConnectionsIdConnectionAccountsIdAccountDeltaResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/users/{id_user}/connections/{id_connection}/accounts/{id_account}/delta', \OpenAPI\OpenAPI\Models\Operations\GetUsersIdUserConnectionsIdConnectionAccountsIdAccountDeltaRequest::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\GetUsersIdUserConnectionsIdConnectionAccountsIdAccountDeltaRequest::class, $request, null));
        
        $httpResponse = $this->_defaultClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetUsersIdUserConnectionsIdConnectionAccountsIdAccountDeltaResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
        }

        return $response;
    }
	
    /**
     * Get accounts logs.
     * 
     * Get logs of account. By default, it selects logs for the last month. You can use "min_date" and "max_date" to change boundary dates.<br><br>
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetUsersIdUserConnectionsIdConnectionAccountsIdAccountLogsRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\GetUsersIdUserConnectionsIdConnectionAccountsIdAccountLogsResponse
     */
	public function getUsersIdUserConnectionsIdConnectionAccountsIdAccountLogs(
        \OpenAPI\OpenAPI\Models\Operations\GetUsersIdUserConnectionsIdConnectionAccountsIdAccountLogsRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\GetUsersIdUserConnectionsIdConnectionAccountsIdAccountLogsResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/users/{id_user}/connections/{id_connection}/accounts/{id_account}/logs', \OpenAPI\OpenAPI\Models\Operations\GetUsersIdUserConnectionsIdConnectionAccountsIdAccountLogsRequest::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\GetUsersIdUserConnectionsIdConnectionAccountsIdAccountLogsRequest::class, $request, null));
        
        $httpResponse = $this->_defaultClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetUsersIdUserConnectionsIdConnectionAccountsIdAccountLogsResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->getUsersIdUserConnectionsIdConnectionAccountsIdAccountLogs200ApplicationJSONObject = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Operations\GetUsersIdUserConnectionsIdConnectionAccountsIdAccountLogs200ApplicationJSON', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Get account sources
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetUsersIdUserConnectionsIdConnectionAccountsIdAccountSourcesRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\GetUsersIdUserConnectionsIdConnectionAccountsIdAccountSourcesResponse
     */
	public function getUsersIdUserConnectionsIdConnectionAccountsIdAccountSources(
        \OpenAPI\OpenAPI\Models\Operations\GetUsersIdUserConnectionsIdConnectionAccountsIdAccountSourcesRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\GetUsersIdUserConnectionsIdConnectionAccountsIdAccountSourcesResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/users/{id_user}/connections/{id_connection}/accounts/{id_account}/sources', \OpenAPI\OpenAPI\Models\Operations\GetUsersIdUserConnectionsIdConnectionAccountsIdAccountSourcesRequest::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\GetUsersIdUserConnectionsIdConnectionAccountsIdAccountSourcesRequest::class, $request, null));
        
        $httpResponse = $this->_defaultClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetUsersIdUserConnectionsIdConnectionAccountsIdAccountSourcesResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->getUsersIdUserConnectionsIdConnectionAccountsIdAccountSources200ApplicationJSONObject = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Operations\GetUsersIdUserConnectionsIdConnectionAccountsIdAccountSources200ApplicationJSON', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Get transactions
     * 
     * Get list of transactions.<br><br>By default, it selects transactions for the last month. You can use "min_date" and "max_date" to change boundary dates.<br><br>
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetUsersIdUserConnectionsIdConnectionAccountsIdAccountTransactionsRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\GetUsersIdUserConnectionsIdConnectionAccountsIdAccountTransactionsResponse
     */
	public function getUsersIdUserConnectionsIdConnectionAccountsIdAccountTransactions(
        \OpenAPI\OpenAPI\Models\Operations\GetUsersIdUserConnectionsIdConnectionAccountsIdAccountTransactionsRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\GetUsersIdUserConnectionsIdConnectionAccountsIdAccountTransactionsResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/users/{id_user}/connections/{id_connection}/accounts/{id_account}/transactions', \OpenAPI\OpenAPI\Models\Operations\GetUsersIdUserConnectionsIdConnectionAccountsIdAccountTransactionsRequest::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\GetUsersIdUserConnectionsIdConnectionAccountsIdAccountTransactionsRequest::class, $request, null));
        
        $httpResponse = $this->_defaultClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetUsersIdUserConnectionsIdConnectionAccountsIdAccountTransactionsResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->getUsersIdUserConnectionsIdConnectionAccountsIdAccountTransactions200ApplicationJSONObject = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Operations\GetUsersIdUserConnectionsIdConnectionAccountsIdAccountTransactions200ApplicationJSON', 'json');
            }
        }

        return $response;
    }
	
    /**
     * List all arbitrary key-value pairs on a transaction
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetUsersIdUserConnectionsIdConnectionAccountsIdAccountTransactionsIdTransactionInformationsRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\GetUsersIdUserConnectionsIdConnectionAccountsIdAccountTransactionsIdTransactionInformationsResponse
     */
	public function getUsersIdUserConnectionsIdConnectionAccountsIdAccountTransactionsIdTransactionInformations(
        \OpenAPI\OpenAPI\Models\Operations\GetUsersIdUserConnectionsIdConnectionAccountsIdAccountTransactionsIdTransactionInformationsRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\GetUsersIdUserConnectionsIdConnectionAccountsIdAccountTransactionsIdTransactionInformationsResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/users/{id_user}/connections/{id_connection}/accounts/{id_account}/transactions/{id_transaction}/informations', \OpenAPI\OpenAPI\Models\Operations\GetUsersIdUserConnectionsIdConnectionAccountsIdAccountTransactionsIdTransactionInformationsRequest::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\GetUsersIdUserConnectionsIdConnectionAccountsIdAccountTransactionsIdTransactionInformationsRequest::class, $request, null));
        
        $httpResponse = $this->_defaultClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetUsersIdUserConnectionsIdConnectionAccountsIdAccountTransactionsIdTransactionInformationsResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->getUsersIdUserConnectionsIdConnectionAccountsIdAccountTransactionsIdTransactionInformations200ApplicationJSONObject = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Operations\GetUsersIdUserConnectionsIdConnectionAccountsIdAccountTransactionsIdTransactionInformations200ApplicationJSON', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Get a particular arbitrary key-value pair on a transaction
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetUsersIdUserConnectionsIdConnectionAccountsIdAccountTransactionsIdTransactionInformationsIdInformationRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\GetUsersIdUserConnectionsIdConnectionAccountsIdAccountTransactionsIdTransactionInformationsIdInformationResponse
     */
	public function getUsersIdUserConnectionsIdConnectionAccountsIdAccountTransactionsIdTransactionInformationsIdInformation(
        \OpenAPI\OpenAPI\Models\Operations\GetUsersIdUserConnectionsIdConnectionAccountsIdAccountTransactionsIdTransactionInformationsIdInformationRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\GetUsersIdUserConnectionsIdConnectionAccountsIdAccountTransactionsIdTransactionInformationsIdInformationResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/users/{id_user}/connections/{id_connection}/accounts/{id_account}/transactions/{id_transaction}/informations/{id_information}', \OpenAPI\OpenAPI\Models\Operations\GetUsersIdUserConnectionsIdConnectionAccountsIdAccountTransactionsIdTransactionInformationsIdInformationRequest::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\GetUsersIdUserConnectionsIdConnectionAccountsIdAccountTransactionsIdTransactionInformationsIdInformationRequest::class, $request, null));
        
        $httpResponse = $this->_defaultClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetUsersIdUserConnectionsIdConnectionAccountsIdAccountTransactionsIdTransactionInformationsIdInformationResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->transactionInformation = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\TransactionInformation', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Get clustered transactions
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetUsersIdUserConnectionsIdConnectionAccountsIdAccountTransactionsclustersRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\GetUsersIdUserConnectionsIdConnectionAccountsIdAccountTransactionsclustersResponse
     */
	public function getUsersIdUserConnectionsIdConnectionAccountsIdAccountTransactionsclusters(
        \OpenAPI\OpenAPI\Models\Operations\GetUsersIdUserConnectionsIdConnectionAccountsIdAccountTransactionsclustersRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\GetUsersIdUserConnectionsIdConnectionAccountsIdAccountTransactionsclustersResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/users/{id_user}/connections/{id_connection}/accounts/{id_account}/transactionsclusters', \OpenAPI\OpenAPI\Models\Operations\GetUsersIdUserConnectionsIdConnectionAccountsIdAccountTransactionsclustersRequest::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\GetUsersIdUserConnectionsIdConnectionAccountsIdAccountTransactionsclustersRequest::class, $request, null));
        
        $httpResponse = $this->_defaultClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetUsersIdUserConnectionsIdConnectionAccountsIdAccountTransactionsclustersResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->getUsersIdUserConnectionsIdConnectionAccountsIdAccountTransactionsclusters200ApplicationJSONObject = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Operations\GetUsersIdUserConnectionsIdConnectionAccountsIdAccountTransactionsclusters200ApplicationJSON', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Get connection additionnal informations
     * 
     * <br><br>
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetUsersIdUserConnectionsIdConnectionInformationsRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\GetUsersIdUserConnectionsIdConnectionInformationsResponse
     */
	public function getUsersIdUserConnectionsIdConnectionInformations(
        \OpenAPI\OpenAPI\Models\Operations\GetUsersIdUserConnectionsIdConnectionInformationsRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\GetUsersIdUserConnectionsIdConnectionInformationsResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/users/{id_user}/connections/{id_connection}/informations', \OpenAPI\OpenAPI\Models\Operations\GetUsersIdUserConnectionsIdConnectionInformationsRequest::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\GetUsersIdUserConnectionsIdConnectionInformationsRequest::class, $request, null));
        
        $httpResponse = $this->_defaultClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetUsersIdUserConnectionsIdConnectionInformationsResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->getUsersIdUserConnectionsIdConnectionInformations200ApplicationJSONObject = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Operations\GetUsersIdUserConnectionsIdConnectionInformations200ApplicationJSON', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Get connection logs
     * 
     * Get logs about connections.<br><br>
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetUsersIdUserConnectionsIdConnectionLogsRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\GetUsersIdUserConnectionsIdConnectionLogsResponse
     */
	public function getUsersIdUserConnectionsIdConnectionLogs(
        \OpenAPI\OpenAPI\Models\Operations\GetUsersIdUserConnectionsIdConnectionLogsRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\GetUsersIdUserConnectionsIdConnectionLogsResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/users/{id_user}/connections/{id_connection}/logs', \OpenAPI\OpenAPI\Models\Operations\GetUsersIdUserConnectionsIdConnectionLogsRequest::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\GetUsersIdUserConnectionsIdConnectionLogsRequest::class, $request, null));
        
        $httpResponse = $this->_defaultClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetUsersIdUserConnectionsIdConnectionLogsResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->getUsersIdUserConnectionsIdConnectionLogs200ApplicationJSONObject = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Operations\GetUsersIdUserConnectionsIdConnectionLogs200ApplicationJSON', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Get connection sources
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetUsersIdUserConnectionsIdConnectionSourcesRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\GetUsersIdUserConnectionsIdConnectionSourcesResponse
     */
	public function getUsersIdUserConnectionsIdConnectionSources(
        \OpenAPI\OpenAPI\Models\Operations\GetUsersIdUserConnectionsIdConnectionSourcesRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\GetUsersIdUserConnectionsIdConnectionSourcesResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/users/{id_user}/connections/{id_connection}/sources', \OpenAPI\OpenAPI\Models\Operations\GetUsersIdUserConnectionsIdConnectionSourcesRequest::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\GetUsersIdUserConnectionsIdConnectionSourcesRequest::class, $request, null));
        
        $httpResponse = $this->_defaultClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetUsersIdUserConnectionsIdConnectionSourcesResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->getUsersIdUserConnectionsIdConnectionSources200ApplicationJSONObject = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Operations\GetUsersIdUserConnectionsIdConnectionSources200ApplicationJSON', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Get clustered transactions
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetUsersIdUserConnectionsIdConnectionTransactionsclustersRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\GetUsersIdUserConnectionsIdConnectionTransactionsclustersResponse
     */
	public function getUsersIdUserConnectionsIdConnectionTransactionsclusters(
        \OpenAPI\OpenAPI\Models\Operations\GetUsersIdUserConnectionsIdConnectionTransactionsclustersRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\GetUsersIdUserConnectionsIdConnectionTransactionsclustersResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/users/{id_user}/connections/{id_connection}/transactionsclusters', \OpenAPI\OpenAPI\Models\Operations\GetUsersIdUserConnectionsIdConnectionTransactionsclustersRequest::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\GetUsersIdUserConnectionsIdConnectionTransactionsclustersRequest::class, $request, null));
        
        $httpResponse = $this->_defaultClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetUsersIdUserConnectionsIdConnectionTransactionsclustersResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->getUsersIdUserConnectionsIdConnectionTransactionsclusters200ApplicationJSONObject = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Operations\GetUsersIdUserConnectionsIdConnectionTransactionsclusters200ApplicationJSON', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Get forecast
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetUsersIdUserForecastRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\GetUsersIdUserForecastResponse
     */
	public function getUsersIdUserForecast(
        \OpenAPI\OpenAPI\Models\Operations\GetUsersIdUserForecastRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\GetUsersIdUserForecastResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/users/{id_user}/forecast', \OpenAPI\OpenAPI\Models\Operations\GetUsersIdUserForecastRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_defaultClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetUsersIdUserForecastResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
        }

        return $response;
    }
	
    /**
     * Get connection logs
     * 
     * Get logs about connections.<br><br>
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetUsersIdUserLogsRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\GetUsersIdUserLogsResponse
     */
	public function getUsersIdUserLogs(
        \OpenAPI\OpenAPI\Models\Operations\GetUsersIdUserLogsRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\GetUsersIdUserLogsResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/users/{id_user}/logs', \OpenAPI\OpenAPI\Models\Operations\GetUsersIdUserLogsRequest::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\GetUsersIdUserLogsRequest::class, $request, null));
        
        $httpResponse = $this->_defaultClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetUsersIdUserLogsResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->getUsersIdUserLogs200ApplicationJSONObject = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Operations\GetUsersIdUserLogs200ApplicationJSON', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Get clustered transactions
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetUsersIdUserTransactionsclustersRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\GetUsersIdUserTransactionsclustersResponse
     */
	public function getUsersIdUserTransactionsclusters(
        \OpenAPI\OpenAPI\Models\Operations\GetUsersIdUserTransactionsclustersRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\GetUsersIdUserTransactionsclustersResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/users/{id_user}/transactionsclusters', \OpenAPI\OpenAPI\Models\Operations\GetUsersIdUserTransactionsclustersRequest::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\GetUsersIdUserTransactionsclustersRequest::class, $request, null));
        
        $httpResponse = $this->_defaultClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetUsersIdUserTransactionsclustersResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->getUsersIdUserTransactionsclusters200ApplicationJSONObject = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Operations\GetUsersIdUserTransactionsclusters200ApplicationJSON', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Create bank categories
     * 
     * It requires the name of the category to be created<br><br>
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\PostBanksCategoriesRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\PostBanksCategoriesResponse
     */
	public function postBanksCategories(
        \OpenAPI\OpenAPI\Models\Operations\PostBanksCategoriesRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\PostBanksCategoriesResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/banks/categories');
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "requestBody", "multipart");
        if ($body === null) {
            throw new \Exception('Request body is required');
        }
        $options = array_merge_recursive($options, $body);
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\PostBanksCategoriesRequest::class, $request, null));
        
        $httpResponse = $this->_defaultClient->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\PostBanksCategoriesResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->connectorCategory = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\ConnectorCategory', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Edit a bank categories
     * 
     * Edit the name for the supplied category.<br><br>
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\PostBanksCategoriesIdCategoryRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\PostBanksCategoriesIdCategoryResponse
     */
	public function postBanksCategoriesIdCategory(
        \OpenAPI\OpenAPI\Models\Operations\PostBanksCategoriesIdCategoryRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\PostBanksCategoriesIdCategoryResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/banks/categories/{id_category}', \OpenAPI\OpenAPI\Models\Operations\PostBanksCategoriesIdCategoryRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "requestBody", "multipart");
        if ($body === null) {
            throw new \Exception('Request body is required');
        }
        $options = array_merge_recursive($options, $body);
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\PostBanksCategoriesIdCategoryRequest::class, $request, null));
        
        $httpResponse = $this->_defaultClient->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\PostBanksCategoriesIdCategoryResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->connectorCategory = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\ConnectorCategory', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Add a new keyword associated with a category in the database.
     * 
     * If the keyword already exists the keyword is not added. Used for the categorization of transactions.<br><br>Form params: - id_category (integer): a reference towards the category associated with the keyword - keyword (string): the searched keyword - income (bool): 1 if the associated category represents an income else 0 - priority (integer): sets the priority for the keyword, used when categorizing<br><br>
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\PostCategoriesKeywordsRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\PostCategoriesKeywordsResponse
     */
	public function postCategoriesKeywords(
        \OpenAPI\OpenAPI\Models\Operations\PostCategoriesKeywordsRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\PostCategoriesKeywordsResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/categories/keywords');
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\PostCategoriesKeywordsRequest::class, $request, null));
        
        $httpResponse = $this->_defaultClient->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\PostCategoriesKeywordsResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->keyword = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\Keyword', 'json');
            }
        }

        return $response;
    }
	
    /**
     * categorize transactions without storing them
     * 
     * It requires an array of transaction dictionaries. Any fields of transactions that are not required will be kept in the response. The response contains the list of transactions with two more fields: id_category and state (it indicates how the transaction has been categorized)<br><br>
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\PostCategorizeRequestBody $request
     * @return \OpenAPI\OpenAPI\Models\Operations\PostCategorizeResponse
     */
	public function postCategorize(
        \OpenAPI\OpenAPI\Models\Operations\PostCategorizeRequestBody $request,
    ): \OpenAPI\OpenAPI\Models\Operations\PostCategorizeResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/categorize');
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "request", "multipart");
        if ($body === null) {
            throw new \Exception('Request body is required');
        }
        $options = array_merge_recursive($options, $body);
        
        $httpResponse = $this->_defaultClient->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\PostCategorizeResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->postCategorize200ApplicationJSONObject = $serializer->deserialize((string)$httpResponse->getBody(), 'array<string, mixed>', 'json');
            }
        }

        return $response;
    }
	
    /**
     * "
     * 
     * This endpoint is used to enable a source or force a synchronization on it.<br><br>
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\PostConnectionsIdConnectionSourcesIdSourceRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\PostConnectionsIdConnectionSourcesIdSourceResponse
     */
	public function postConnectionsIdConnectionSourcesIdSource(
        \OpenAPI\OpenAPI\Models\Operations\PostConnectionsIdConnectionSourcesIdSourceRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\PostConnectionsIdConnectionSourcesIdSourceResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/connections/{id_connection}/sources/{id_source}', \OpenAPI\OpenAPI\Models\Operations\PostConnectionsIdConnectionSourcesIdSourceRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "requestBody", "multipart");
        $options = array_merge_recursive($options, $body);
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\PostConnectionsIdConnectionSourcesIdSourceRequest::class, $request, null));
        
        $httpResponse = $this->_defaultClient->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\PostConnectionsIdConnectionSourcesIdSourceResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->connectionSource = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\ConnectionSource', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Request a new connector
     * 
     * Send a request to add a new connector<br><br>
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\PostConnectorsRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\PostConnectorsResponse
     */
	public function postConnectors(
        \OpenAPI\OpenAPI\Models\Operations\PostConnectorsRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\PostConnectorsResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/connectors');
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "requestBody", "multipart");
        if ($body === null) {
            throw new \Exception('Request body is required');
        }
        $options = array_merge_recursive($options, $body);
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\PostConnectorsRequest::class, $request, null));
        
        $httpResponse = $this->_defaultClient->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\PostConnectorsResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->connector = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\Connector', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Create a connector Logo
     * 
     * This endpoint creates a connector logo. You can either pass a file to as a parameter to insert and link it with the connector or pass an id_file to link a connector with an existing file. Will fail if the file is already linked with that connector.<br><br>Form params: - id_file (integer): The id of the file to link with that connector. - img (string): Path to the image to link with that connector.<br><br>
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\PostConnectorsIdConnectorLogosRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\PostConnectorsIdConnectorLogosResponse
     */
	public function postConnectorsIdConnectorLogos(
        \OpenAPI\OpenAPI\Models\Operations\PostConnectorsIdConnectorLogosRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\PostConnectorsIdConnectorLogosResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/connectors/{id_connector}/logos', \OpenAPI\OpenAPI\Models\Operations\PostConnectorsIdConnectorLogosRequest::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\PostConnectorsIdConnectorLogosRequest::class, $request, null));
        
        $httpResponse = $this->_defaultClient->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\PostConnectorsIdConnectorLogosResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->connectorLogo = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\ConnectorLogo', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Create clustered transaction
     * 
     * Form params : - next_date (date) required: Date of transaction - mean_amount (decimal) required: Mean Amount - wording (string) required: name of transaction - id_account (id) required: related account<br><br>
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\PostUsersIdUserAccountsIdAccountTransactionsclustersRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\PostUsersIdUserAccountsIdAccountTransactionsclustersResponse
     */
	public function postUsersIdUserAccountsIdAccountTransactionsclusters(
        \OpenAPI\OpenAPI\Models\Operations\PostUsersIdUserAccountsIdAccountTransactionsclustersRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\PostUsersIdUserAccountsIdAccountTransactionsclustersResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/users/{id_user}/accounts/{id_account}/transactionsclusters', \OpenAPI\OpenAPI\Models\Operations\PostUsersIdUserAccountsIdAccountTransactionsclustersRequest::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\PostUsersIdUserAccountsIdAccountTransactionsclustersRequest::class, $request, null));
        
        $httpResponse = $this->_defaultClient->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\PostUsersIdUserAccountsIdAccountTransactionsclustersResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->transactionsCluster = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\TransactionsCluster', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Create a new transaction category
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\PostUsersIdUserCategoriesFullRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\PostUsersIdUserCategoriesFullResponse
     */
	public function postUsersIdUserCategoriesFull(
        \OpenAPI\OpenAPI\Models\Operations\PostUsersIdUserCategoriesFullRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\PostUsersIdUserCategoriesFullResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/users/{id_user}/categories/full', \OpenAPI\OpenAPI\Models\Operations\PostUsersIdUserCategoriesFullRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "requestBody", "multipart");
        $options = array_merge_recursive($options, $body);
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\PostUsersIdUserCategoriesFullRequest::class, $request, null));
        
        $httpResponse = $this->_defaultClient->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\PostUsersIdUserCategoriesFullResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->category = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\Category', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Add a new connection.
     * 
     * Create a new connection to a given bank or provider. You have to give all needed parameters (use /banks/ID/fields or /providers/ID/fields to get them).<br><br>
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\PostUsersIdUserConnectionsRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\PostUsersIdUserConnectionsResponse
     */
	public function postUsersIdUserConnections(
        \OpenAPI\OpenAPI\Models\Operations\PostUsersIdUserConnectionsRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\PostUsersIdUserConnectionsResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/users/{id_user}/connections', \OpenAPI\OpenAPI\Models\Operations\PostUsersIdUserConnectionsRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "requestBody", "multipart");
        $options = array_merge_recursive($options, $body);
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\PostUsersIdUserConnectionsRequest::class, $request, null));
        
        $httpResponse = $this->_defaultClient->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\PostUsersIdUserConnectionsResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->connection = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\Connection', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Update a connection.
     * 
     * Give new parameters to change on the configuration of this connection (for example "password").<br><br>It tests connection to website, and if it fails, a 400 response is given with the error code "wrongpass" or "websiteUnavailable".<br><br>You can also supply meta-parameters on connection, like 'active' or 'expire'.<br><br>It's possible to execute the update/synchronization in the background with a query parameter. If done in background this endpoint will respond with data that is not yet updated. To obtain updated data, polling is required as the the data will be filled in the background.<br><br>
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\PostUsersIdUserConnectionsIdConnectionRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\PostUsersIdUserConnectionsIdConnectionResponse
     */
	public function postUsersIdUserConnectionsIdConnection(
        \OpenAPI\OpenAPI\Models\Operations\PostUsersIdUserConnectionsIdConnectionRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\PostUsersIdUserConnectionsIdConnectionResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/users/{id_user}/connections/{id_connection}', \OpenAPI\OpenAPI\Models\Operations\PostUsersIdUserConnectionsIdConnectionRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "requestBody", "multipart");
        $options = array_merge_recursive($options, $body);
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\PostUsersIdUserConnectionsIdConnectionRequest::class, $request, null));
        
        $httpResponse = $this->_defaultClient->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\PostUsersIdUserConnectionsIdConnectionResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->connection = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\Connection', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Create an account
     * 
     * This endpoint creates an account related to a connection or not.<br><br>
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\PostUsersIdUserConnectionsIdConnectionAccountsRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\PostUsersIdUserConnectionsIdConnectionAccountsResponse
     */
	public function postUsersIdUserConnectionsIdConnectionAccounts(
        \OpenAPI\OpenAPI\Models\Operations\PostUsersIdUserConnectionsIdConnectionAccountsRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\PostUsersIdUserConnectionsIdConnectionAccountsResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/users/{id_user}/connections/{id_connection}/accounts', \OpenAPI\OpenAPI\Models\Operations\PostUsersIdUserConnectionsIdConnectionAccountsRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "requestBody", "multipart");
        if ($body === null) {
            throw new \Exception('Request body is required');
        }
        $options = array_merge_recursive($options, $body);
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\PostUsersIdUserConnectionsIdConnectionAccountsRequest::class, $request, null));
        
        $httpResponse = $this->_defaultClient->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\PostUsersIdUserConnectionsIdConnectionAccountsResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->account = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\Account', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Create transactions
     * 
     * Create transactions for the supplied account or the account whose id is given with form parameters. It requires an array of transaction dictionaries.<br><br><br><br>
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\PostUsersIdUserConnectionsIdConnectionAccountsIdAccountTransactionsRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\PostUsersIdUserConnectionsIdConnectionAccountsIdAccountTransactionsResponse
     */
	public function postUsersIdUserConnectionsIdConnectionAccountsIdAccountTransactions(
        \OpenAPI\OpenAPI\Models\Operations\PostUsersIdUserConnectionsIdConnectionAccountsIdAccountTransactionsRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\PostUsersIdUserConnectionsIdConnectionAccountsIdAccountTransactionsResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/users/{id_user}/connections/{id_connection}/accounts/{id_account}/transactions', \OpenAPI\OpenAPI\Models\Operations\PostUsersIdUserConnectionsIdConnectionAccountsIdAccountTransactionsRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "requestBody", "multipart");
        if ($body === null) {
            throw new \Exception('Request body is required');
        }
        $options = array_merge_recursive($options, $body);
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\PostUsersIdUserConnectionsIdConnectionAccountsIdAccountTransactionsRequest::class, $request, null));
        
        $httpResponse = $this->_defaultClient->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\PostUsersIdUserConnectionsIdConnectionAccountsIdAccountTransactionsResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->transaction = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\Transaction', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Create clustered transaction
     * 
     * Form params : - next_date (date) required: Date of transaction - mean_amount (decimal) required: Mean Amount - wording (string) required: name of transaction - id_account (id) required: related account<br><br>
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\PostUsersIdUserConnectionsIdConnectionAccountsIdAccountTransactionsclustersRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\PostUsersIdUserConnectionsIdConnectionAccountsIdAccountTransactionsclustersResponse
     */
	public function postUsersIdUserConnectionsIdConnectionAccountsIdAccountTransactionsclusters(
        \OpenAPI\OpenAPI\Models\Operations\PostUsersIdUserConnectionsIdConnectionAccountsIdAccountTransactionsclustersRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\PostUsersIdUserConnectionsIdConnectionAccountsIdAccountTransactionsclustersResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/users/{id_user}/connections/{id_connection}/accounts/{id_account}/transactionsclusters', \OpenAPI\OpenAPI\Models\Operations\PostUsersIdUserConnectionsIdConnectionAccountsIdAccountTransactionsclustersRequest::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\PostUsersIdUserConnectionsIdConnectionAccountsIdAccountTransactionsclustersRequest::class, $request, null));
        
        $httpResponse = $this->_defaultClient->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\PostUsersIdUserConnectionsIdConnectionAccountsIdAccountTransactionsclustersResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->transactionsCluster = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\TransactionsCluster', 'json');
            }
        }

        return $response;
    }
	
    /**
     * "
     * 
     * This endpoint is used to enable a source or force a synchronization on it.<br><br>
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\PostUsersIdUserConnectionsIdConnectionSourcesIdSourceRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\PostUsersIdUserConnectionsIdConnectionSourcesIdSourceResponse
     */
	public function postUsersIdUserConnectionsIdConnectionSourcesIdSource(
        \OpenAPI\OpenAPI\Models\Operations\PostUsersIdUserConnectionsIdConnectionSourcesIdSourceRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\PostUsersIdUserConnectionsIdConnectionSourcesIdSourceResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/users/{id_user}/connections/{id_connection}/sources/{id_source}', \OpenAPI\OpenAPI\Models\Operations\PostUsersIdUserConnectionsIdConnectionSourcesIdSourceRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "requestBody", "multipart");
        $options = array_merge_recursive($options, $body);
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\PostUsersIdUserConnectionsIdConnectionSourcesIdSourceRequest::class, $request, null));
        
        $httpResponse = $this->_defaultClient->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\PostUsersIdUserConnectionsIdConnectionSourcesIdSourceResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->connectionSource = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\ConnectionSource', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Create clustered transaction
     * 
     * Form params : - next_date (date) required: Date of transaction - mean_amount (decimal) required: Mean Amount - wording (string) required: name of transaction - id_account (id) required: related account<br><br>
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\PostUsersIdUserConnectionsIdConnectionTransactionsclustersRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\PostUsersIdUserConnectionsIdConnectionTransactionsclustersResponse
     */
	public function postUsersIdUserConnectionsIdConnectionTransactionsclusters(
        \OpenAPI\OpenAPI\Models\Operations\PostUsersIdUserConnectionsIdConnectionTransactionsclustersRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\PostUsersIdUserConnectionsIdConnectionTransactionsclustersResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/users/{id_user}/connections/{id_connection}/transactionsclusters', \OpenAPI\OpenAPI\Models\Operations\PostUsersIdUserConnectionsIdConnectionTransactionsclustersRequest::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\PostUsersIdUserConnectionsIdConnectionTransactionsclustersRequest::class, $request, null));
        
        $httpResponse = $this->_defaultClient->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\PostUsersIdUserConnectionsIdConnectionTransactionsclustersResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->transactionsCluster = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\TransactionsCluster', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Create clustered transaction
     * 
     * Form params : - next_date (date) required: Date of transaction - mean_amount (decimal) required: Mean Amount - wording (string) required: name of transaction - id_account (id) required: related account<br><br>
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\PostUsersIdUserTransactionsclustersRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\PostUsersIdUserTransactionsclustersResponse
     */
	public function postUsersIdUserTransactionsclusters(
        \OpenAPI\OpenAPI\Models\Operations\PostUsersIdUserTransactionsclustersRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\PostUsersIdUserTransactionsclustersResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/users/{id_user}/transactionsclusters', \OpenAPI\OpenAPI\Models\Operations\PostUsersIdUserTransactionsclustersRequest::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\PostUsersIdUserTransactionsclustersRequest::class, $request, null));
        
        $httpResponse = $this->_defaultClient->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\PostUsersIdUserTransactionsclustersResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->transactionsCluster = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\TransactionsCluster', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Update connection source
     * 
     * This endpoint is used to enable a source or force a synchronization on it.<br><br>
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\PutConnectionsIdConnectionSourcesIdSourceRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\PutConnectionsIdConnectionSourcesIdSourceResponse
     */
	public function putConnectionsIdConnectionSourcesIdSource(
        \OpenAPI\OpenAPI\Models\Operations\PutConnectionsIdConnectionSourcesIdSourceRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\PutConnectionsIdConnectionSourcesIdSourceResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/connections/{id_connection}/sources/{id_source}', \OpenAPI\OpenAPI\Models\Operations\PutConnectionsIdConnectionSourcesIdSourceRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "requestBody", "multipart");
        $options = array_merge_recursive($options, $body);
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\PutConnectionsIdConnectionSourcesIdSourceRequest::class, $request, null));
        
        $httpResponse = $this->_defaultClient->request('PUT', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\PutConnectionsIdConnectionSourcesIdSourceResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->connectionSource = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\ConnectionSource', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Enable/disable several connectors
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\PutConnectorsRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\PutConnectorsResponse
     */
	public function putConnectors(
        \OpenAPI\OpenAPI\Models\Operations\PutConnectorsRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\PutConnectorsResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/connectors');
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "requestBody", "multipart");
        $options = array_merge_recursive($options, $body);
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\PutConnectorsRequest::class, $request, null));
        
        $httpResponse = $this->_defaultClient->request('PUT', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\PutConnectorsResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->connector = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\Connector', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Edit the provided connector
     * 
     * <br><br>
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\PutConnectorsIdConnectorRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\PutConnectorsIdConnectorResponse
     */
	public function putConnectorsIdConnector(
        \OpenAPI\OpenAPI\Models\Operations\PutConnectorsIdConnectorRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\PutConnectorsIdConnectorResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/connectors/{id_connector}', \OpenAPI\OpenAPI\Models\Operations\PutConnectorsIdConnectorRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "requestBody", "multipart");
        $options = array_merge_recursive($options, $body);
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\PutConnectorsIdConnectorRequest::class, $request, null));
        
        $httpResponse = $this->_defaultClient->request('PUT', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\PutConnectorsIdConnectorResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->connector = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\Connector', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Create or Update a connector Logo
     * 
     * This endpoint creates or update a connector logo. This logo is a mapping between a file (/file route) and a connector (/connectors route) or a provider (/providers route).<br><br>Form params: - id_file (integer): The id of the file to link with that connector.<br><br>
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\PutConnectorsIdConnectorLogosRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\PutConnectorsIdConnectorLogosResponse
     */
	public function putConnectorsIdConnectorLogos(
        \OpenAPI\OpenAPI\Models\Operations\PutConnectorsIdConnectorLogosRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\PutConnectorsIdConnectorLogosResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/connectors/{id_connector}/logos', \OpenAPI\OpenAPI\Models\Operations\PutConnectorsIdConnectorLogosRequest::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\PutConnectorsIdConnectorLogosRequest::class, $request, null));
        
        $httpResponse = $this->_defaultClient->request('PUT', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\PutConnectorsIdConnectorLogosResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->connectorLogo = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\ConnectorLogo', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Create or Update a connector Logo.
     * 
     * This endpoint creates or update a connector logo. This logo is a mapping between a file (/file route) and a connector (/connectors route) or a provider (/providers route).<br><br>Form params: - id_file (integer): The id of the file to link with that connector.<br><br>
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\PutConnectorsIdConnectorLogosIdLogoRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\PutConnectorsIdConnectorLogosIdLogoResponse
     */
	public function putConnectorsIdConnectorLogosIdLogo(
        \OpenAPI\OpenAPI\Models\Operations\PutConnectorsIdConnectorLogosIdLogoRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\PutConnectorsIdConnectorLogosIdLogoResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/connectors/{id_connector}/logos/{id_logo}', \OpenAPI\OpenAPI\Models\Operations\PutConnectorsIdConnectorLogosIdLogoRequest::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\PutConnectorsIdConnectorLogosIdLogoRequest::class, $request, null));
        
        $httpResponse = $this->_defaultClient->request('PUT', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\PutConnectorsIdConnectorLogosIdLogoResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->connectorLogo = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\ConnectorLogo', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Edit several connector sources
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\PutConnectorsIdConnectorSourcesRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\PutConnectorsIdConnectorSourcesResponse
     */
	public function putConnectorsIdConnectorSources(
        \OpenAPI\OpenAPI\Models\Operations\PutConnectorsIdConnectorSourcesRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\PutConnectorsIdConnectorSourcesResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/connectors/{id_connector}/sources', \OpenAPI\OpenAPI\Models\Operations\PutConnectorsIdConnectorSourcesRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "requestBody", "multipart");
        $options = array_merge_recursive($options, $body);
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\PutConnectorsIdConnectorSourcesRequest::class, $request, null));
        
        $httpResponse = $this->_defaultClient->request('PUT', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\PutConnectorsIdConnectorSourcesResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->connectorSource = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\ConnectorSource', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Edit the provided connector source
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\PutConnectorsIdConnectorSourcesIdSourceRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\PutConnectorsIdConnectorSourcesIdSourceResponse
     */
	public function putConnectorsIdConnectorSourcesIdSource(
        \OpenAPI\OpenAPI\Models\Operations\PutConnectorsIdConnectorSourcesIdSourceRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\PutConnectorsIdConnectorSourcesIdSourceResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/connectors/{id_connector}/sources/{id_source}', \OpenAPI\OpenAPI\Models\Operations\PutConnectorsIdConnectorSourcesIdSourceRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "requestBody", "multipart");
        $options = array_merge_recursive($options, $body);
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\PutConnectorsIdConnectorSourcesIdSourceRequest::class, $request, null));
        
        $httpResponse = $this->_defaultClient->request('PUT', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\PutConnectorsIdConnectorSourcesIdSourceResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->connectorSource = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\ConnectorSource', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Edit a clustered transaction
     * 
     * Form params : - next_date (date): Date of transaction - mean_amount (decimal): Mean Amount - wording (string): name of transaction - id_account (id): related account - id_category (id): related category - enabled (bool): is enabled<br><br>
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\PutUsersIdUserAccountsIdAccountTransactionsclustersIdTransactionsclusterRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\PutUsersIdUserAccountsIdAccountTransactionsclustersIdTransactionsclusterResponse
     */
	public function putUsersIdUserAccountsIdAccountTransactionsclustersIdTransactionscluster(
        \OpenAPI\OpenAPI\Models\Operations\PutUsersIdUserAccountsIdAccountTransactionsclustersIdTransactionsclusterRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\PutUsersIdUserAccountsIdAccountTransactionsclustersIdTransactionsclusterResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/users/{id_user}/accounts/{id_account}/transactionsclusters/{id_transactionscluster}', \OpenAPI\OpenAPI\Models\Operations\PutUsersIdUserAccountsIdAccountTransactionsclustersIdTransactionsclusterRequest::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\PutUsersIdUserAccountsIdAccountTransactionsclustersIdTransactionsclusterRequest::class, $request, null));
        
        $httpResponse = $this->_defaultClient->request('PUT', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\PutUsersIdUserAccountsIdAccountTransactionsclustersIdTransactionsclusterResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->transactionsCluster = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\TransactionsCluster', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Modify a user-created category
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\PutUsersIdUserCategoriesFullIdFullRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\PutUsersIdUserCategoriesFullIdFullResponse
     */
	public function putUsersIdUserCategoriesFullIdFull(
        \OpenAPI\OpenAPI\Models\Operations\PutUsersIdUserCategoriesFullIdFullRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\PutUsersIdUserCategoriesFullIdFullResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/users/{id_user}/categories/full/{id_full}', \OpenAPI\OpenAPI\Models\Operations\PutUsersIdUserCategoriesFullIdFullRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "requestBody", "multipart");
        $options = array_merge_recursive($options, $body);
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\PutUsersIdUserCategoriesFullIdFullRequest::class, $request, null));
        
        $httpResponse = $this->_defaultClient->request('PUT', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\PutUsersIdUserCategoriesFullIdFullResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->category = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\Category', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Force synchronisation of a connection.
     * 
     * We suggest to pass parameter expand=accounts[transactions] to get all *new* and *updated* transactions.<br><br>
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\PutUsersIdUserConnectionsIdConnectionRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\PutUsersIdUserConnectionsIdConnectionResponse
     */
	public function putUsersIdUserConnectionsIdConnection(
        \OpenAPI\OpenAPI\Models\Operations\PutUsersIdUserConnectionsIdConnectionRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\PutUsersIdUserConnectionsIdConnectionResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/users/{id_user}/connections/{id_connection}', \OpenAPI\OpenAPI\Models\Operations\PutUsersIdUserConnectionsIdConnectionRequest::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\PutUsersIdUserConnectionsIdConnectionRequest::class, $request, null));
        
        $httpResponse = $this->_defaultClient->request('PUT', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\PutUsersIdUserConnectionsIdConnectionResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->connection = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\Connection', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Update many accounts at once
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\PutUsersIdUserConnectionsIdConnectionAccountsRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\PutUsersIdUserConnectionsIdConnectionAccountsResponse
     */
	public function putUsersIdUserConnectionsIdConnectionAccounts(
        \OpenAPI\OpenAPI\Models\Operations\PutUsersIdUserConnectionsIdConnectionAccountsRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\PutUsersIdUserConnectionsIdConnectionAccountsResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/users/{id_user}/connections/{id_connection}/accounts', \OpenAPI\OpenAPI\Models\Operations\PutUsersIdUserConnectionsIdConnectionAccountsRequest::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\PutUsersIdUserConnectionsIdConnectionAccountsRequest::class, $request, null));
        
        $httpResponse = $this->_defaultClient->request('PUT', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\PutUsersIdUserConnectionsIdConnectionAccountsResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->account = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\Account', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Update an account
     * 
     * It updates a specific account<br><br>
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\PutUsersIdUserConnectionsIdConnectionAccountsIdAccountRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\PutUsersIdUserConnectionsIdConnectionAccountsIdAccountResponse
     */
	public function putUsersIdUserConnectionsIdConnectionAccountsIdAccount(
        \OpenAPI\OpenAPI\Models\Operations\PutUsersIdUserConnectionsIdConnectionAccountsIdAccountRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\PutUsersIdUserConnectionsIdConnectionAccountsIdAccountResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/users/{id_user}/connections/{id_connection}/accounts/{id_account}', \OpenAPI\OpenAPI\Models\Operations\PutUsersIdUserConnectionsIdConnectionAccountsIdAccountRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "requestBody", "multipart");
        $options = array_merge_recursive($options, $body);
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\PutUsersIdUserConnectionsIdConnectionAccountsIdAccountRequest::class, $request, null));
        
        $httpResponse = $this->_defaultClient->request('PUT', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\PutUsersIdUserConnectionsIdConnectionAccountsIdAccountResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->account = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\Account', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Edit a transaction meta-data
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\PutUsersIdUserConnectionsIdConnectionAccountsIdAccountTransactionsIdTransactionRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\PutUsersIdUserConnectionsIdConnectionAccountsIdAccountTransactionsIdTransactionResponse
     */
	public function putUsersIdUserConnectionsIdConnectionAccountsIdAccountTransactionsIdTransaction(
        \OpenAPI\OpenAPI\Models\Operations\PutUsersIdUserConnectionsIdConnectionAccountsIdAccountTransactionsIdTransactionRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\PutUsersIdUserConnectionsIdConnectionAccountsIdAccountTransactionsIdTransactionResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/users/{id_user}/connections/{id_connection}/accounts/{id_account}/transactions/{id_transaction}', \OpenAPI\OpenAPI\Models\Operations\PutUsersIdUserConnectionsIdConnectionAccountsIdAccountTransactionsIdTransactionRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "requestBody", "multipart");
        $options = array_merge_recursive($options, $body);
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\PutUsersIdUserConnectionsIdConnectionAccountsIdAccountTransactionsIdTransactionRequest::class, $request, null));
        
        $httpResponse = $this->_defaultClient->request('PUT', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\PutUsersIdUserConnectionsIdConnectionAccountsIdAccountTransactionsIdTransactionResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->transaction = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\Transaction', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Add or edit transaction arbitrary key-value pairs
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\PutUsersIdUserConnectionsIdConnectionAccountsIdAccountTransactionsIdTransactionInformationsRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\PutUsersIdUserConnectionsIdConnectionAccountsIdAccountTransactionsIdTransactionInformationsResponse
     */
	public function putUsersIdUserConnectionsIdConnectionAccountsIdAccountTransactionsIdTransactionInformations(
        \OpenAPI\OpenAPI\Models\Operations\PutUsersIdUserConnectionsIdConnectionAccountsIdAccountTransactionsIdTransactionInformationsRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\PutUsersIdUserConnectionsIdConnectionAccountsIdAccountTransactionsIdTransactionInformationsResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/users/{id_user}/connections/{id_connection}/accounts/{id_account}/transactions/{id_transaction}/informations', \OpenAPI\OpenAPI\Models\Operations\PutUsersIdUserConnectionsIdConnectionAccountsIdAccountTransactionsIdTransactionInformationsRequest::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\PutUsersIdUserConnectionsIdConnectionAccountsIdAccountTransactionsIdTransactionInformationsRequest::class, $request, null));
        
        $httpResponse = $this->_defaultClient->request('PUT', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\PutUsersIdUserConnectionsIdConnectionAccountsIdAccountTransactionsIdTransactionInformationsResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->transactionInformation = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\TransactionInformation', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Edit a clustered transaction
     * 
     * Form params : - next_date (date): Date of transaction - mean_amount (decimal): Mean Amount - wording (string): name of transaction - id_account (id): related account - id_category (id): related category - enabled (bool): is enabled<br><br>
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\PutUsersIdUserConnectionsIdConnectionAccountsIdAccountTransactionsclustersIdTransactionsclusterRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\PutUsersIdUserConnectionsIdConnectionAccountsIdAccountTransactionsclustersIdTransactionsclusterResponse
     */
	public function putUsersIdUserConnectionsIdConnectionAccountsIdAccountTransactionsclustersIdTransactionscluster(
        \OpenAPI\OpenAPI\Models\Operations\PutUsersIdUserConnectionsIdConnectionAccountsIdAccountTransactionsclustersIdTransactionsclusterRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\PutUsersIdUserConnectionsIdConnectionAccountsIdAccountTransactionsclustersIdTransactionsclusterResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/users/{id_user}/connections/{id_connection}/accounts/{id_account}/transactionsclusters/{id_transactionscluster}', \OpenAPI\OpenAPI\Models\Operations\PutUsersIdUserConnectionsIdConnectionAccountsIdAccountTransactionsclustersIdTransactionsclusterRequest::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\PutUsersIdUserConnectionsIdConnectionAccountsIdAccountTransactionsclustersIdTransactionsclusterRequest::class, $request, null));
        
        $httpResponse = $this->_defaultClient->request('PUT', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\PutUsersIdUserConnectionsIdConnectionAccountsIdAccountTransactionsclustersIdTransactionsclusterResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->transactionsCluster = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\TransactionsCluster', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Update connection source
     * 
     * This endpoint is used to enable a source or force a synchronization on it.<br><br>
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\PutUsersIdUserConnectionsIdConnectionSourcesIdSourceRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\PutUsersIdUserConnectionsIdConnectionSourcesIdSourceResponse
     */
	public function putUsersIdUserConnectionsIdConnectionSourcesIdSource(
        \OpenAPI\OpenAPI\Models\Operations\PutUsersIdUserConnectionsIdConnectionSourcesIdSourceRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\PutUsersIdUserConnectionsIdConnectionSourcesIdSourceResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/users/{id_user}/connections/{id_connection}/sources/{id_source}', \OpenAPI\OpenAPI\Models\Operations\PutUsersIdUserConnectionsIdConnectionSourcesIdSourceRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "requestBody", "multipart");
        $options = array_merge_recursive($options, $body);
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\PutUsersIdUserConnectionsIdConnectionSourcesIdSourceRequest::class, $request, null));
        
        $httpResponse = $this->_defaultClient->request('PUT', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\PutUsersIdUserConnectionsIdConnectionSourcesIdSourceResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->connectionSource = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\ConnectionSource', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Edit a clustered transaction
     * 
     * Form params : - next_date (date): Date of transaction - mean_amount (decimal): Mean Amount - wording (string): name of transaction - id_account (id): related account - id_category (id): related category - enabled (bool): is enabled<br><br>
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\PutUsersIdUserConnectionsIdConnectionTransactionsclustersIdTransactionsclusterRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\PutUsersIdUserConnectionsIdConnectionTransactionsclustersIdTransactionsclusterResponse
     */
	public function putUsersIdUserConnectionsIdConnectionTransactionsclustersIdTransactionscluster(
        \OpenAPI\OpenAPI\Models\Operations\PutUsersIdUserConnectionsIdConnectionTransactionsclustersIdTransactionsclusterRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\PutUsersIdUserConnectionsIdConnectionTransactionsclustersIdTransactionsclusterResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/users/{id_user}/connections/{id_connection}/transactionsclusters/{id_transactionscluster}', \OpenAPI\OpenAPI\Models\Operations\PutUsersIdUserConnectionsIdConnectionTransactionsclustersIdTransactionsclusterRequest::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\PutUsersIdUserConnectionsIdConnectionTransactionsclustersIdTransactionsclusterRequest::class, $request, null));
        
        $httpResponse = $this->_defaultClient->request('PUT', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\PutUsersIdUserConnectionsIdConnectionTransactionsclustersIdTransactionsclusterResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->transactionsCluster = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\TransactionsCluster', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Edit a clustered transaction
     * 
     * Form params : - next_date (date): Date of transaction - mean_amount (decimal): Mean Amount - wording (string): name of transaction - id_account (id): related account - id_category (id): related category - enabled (bool): is enabled<br><br>
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\PutUsersIdUserTransactionsclustersIdTransactionsclusterRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\PutUsersIdUserTransactionsclustersIdTransactionsclusterResponse
     */
	public function putUsersIdUserTransactionsclustersIdTransactionscluster(
        \OpenAPI\OpenAPI\Models\Operations\PutUsersIdUserTransactionsclustersIdTransactionsclusterRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\PutUsersIdUserTransactionsclustersIdTransactionsclusterResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/users/{id_user}/transactionsclusters/{id_transactionscluster}', \OpenAPI\OpenAPI\Models\Operations\PutUsersIdUserTransactionsclustersIdTransactionsclusterRequest::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\PutUsersIdUserTransactionsclustersIdTransactionsclusterRequest::class, $request, null));
        
        $httpResponse = $this->_defaultClient->request('PUT', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\PutUsersIdUserTransactionsclustersIdTransactionsclusterResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->transactionsCluster = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\TransactionsCluster', 'json');
            }
        }

        return $response;
    }
}