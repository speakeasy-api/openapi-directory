"""Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT."""

from __future__ import annotations
import dataclasses
import dateutil.parser
from ..shared import keylinedefinition as shared_keylinedefinition
from ..shared import priceladderdefinition as shared_priceladderdefinition
from ..shared import runnerdefinition as shared_runnerdefinition
from dataclasses_json import Undefined, dataclass_json
from datetime import datetime
from enum import Enum
from marshmallow import fields
from sdk import utils
from typing import Optional

class MarketDefinitionBettingTypeEnum(str, Enum):
    ODDS = 'ODDS'
    LINE = 'LINE'
    RANGE = 'RANGE'
    ASIAN_HANDICAP_DOUBLE_LINE = 'ASIAN_HANDICAP_DOUBLE_LINE'
    ASIAN_HANDICAP_SINGLE_LINE = 'ASIAN_HANDICAP_SINGLE_LINE'

class MarketDefinitionStatusEnum(str, Enum):
    INACTIVE = 'INACTIVE'
    OPEN = 'OPEN'
    SUSPENDED = 'SUSPENDED'
    CLOSED = 'CLOSED'


@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class MarketDefinition:
    
    bet_delay: Optional[int] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('betDelay'), 'exclude': lambda f: f is None }})  
    betting_type: Optional[MarketDefinitionBettingTypeEnum] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('bettingType'), 'exclude': lambda f: f is None }})  
    bsp_market: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('bspMarket'), 'exclude': lambda f: f is None }})  
    bsp_reconciled: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('bspReconciled'), 'exclude': lambda f: f is None }})  
    complete: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('complete'), 'exclude': lambda f: f is None }})  
    country_code: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('countryCode'), 'exclude': lambda f: f is None }})  
    cross_matching: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('crossMatching'), 'exclude': lambda f: f is None }})  
    discount_allowed: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('discountAllowed'), 'exclude': lambda f: f is None }})  
    each_way_divisor: Optional[float] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('eachWayDivisor'), 'exclude': lambda f: f is None }})  
    event_id: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('eventId'), 'exclude': lambda f: f is None }})  
    event_type_id: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('eventTypeId'), 'exclude': lambda f: f is None }})
    r"""The Event Type the market is contained within."""  
    in_play: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('inPlay'), 'exclude': lambda f: f is None }})  
    key_line_definition: Optional[shared_keylinedefinition.KeyLineDefinition] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('keyLineDefinition'), 'exclude': lambda f: f is None }})  
    line_interval: Optional[float] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('lineInterval'), 'exclude': lambda f: f is None }})
    r"""For Handicap and Line markets, the lines available on this market will be between the range of lineMinUnit and lineMaxUnit, in increments of the lineInterval value. e.g. If unit is runs, lineMinUnit=10, lineMaxUnit=20 and lineInterval=0.5, then valid lines include 10, 10.5, 11, 11.5 up to 20 runs."""  
    line_max_unit: Optional[float] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('lineMaxUnit'), 'exclude': lambda f: f is None }})
    r"""For Handicap and Line markets, the maximum value for the outcome, in market units for this market (eg 100 runs)."""  
    line_min_unit: Optional[float] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('lineMinUnit'), 'exclude': lambda f: f is None }})
    r"""For Handicap and Line markets, the minimum value for the outcome, in market units for this market (eg 0 runs)."""  
    market_base_rate: Optional[float] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('marketBaseRate'), 'exclude': lambda f: f is None }})  
    market_time: Optional[datetime] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('marketTime'), 'encoder': utils.datetimeisoformat(True), 'decoder': dateutil.parser.isoparse, 'mm_field': fields.DateTime(format='iso'), 'exclude': lambda f: f is None }})  
    market_type: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('marketType'), 'exclude': lambda f: f is None }})  
    number_of_active_runners: Optional[int] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('numberOfActiveRunners'), 'exclude': lambda f: f is None }})  
    number_of_winners: Optional[int] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('numberOfWinners'), 'exclude': lambda f: f is None }})  
    open_date: Optional[datetime] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('openDate'), 'encoder': utils.datetimeisoformat(True), 'decoder': dateutil.parser.isoparse, 'mm_field': fields.DateTime(format='iso'), 'exclude': lambda f: f is None }})  
    persistence_enabled: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('persistenceEnabled'), 'exclude': lambda f: f is None }})  
    price_ladder_definition: Optional[shared_priceladderdefinition.PriceLadderDefinition] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('priceLadderDefinition'), 'exclude': lambda f: f is None }})  
    race_type: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('raceType'), 'exclude': lambda f: f is None }})  
    regulators: Optional[list[str]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('regulators'), 'exclude': lambda f: f is None }})
    r"""The market regulators."""  
    runners: Optional[list[shared_runnerdefinition.RunnerDefinition]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('runners'), 'exclude': lambda f: f is None }})  
    runners_voidable: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('runnersVoidable'), 'exclude': lambda f: f is None }})  
    settled_time: Optional[datetime] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('settledTime'), 'encoder': utils.datetimeisoformat(True), 'decoder': dateutil.parser.isoparse, 'mm_field': fields.DateTime(format='iso'), 'exclude': lambda f: f is None }})  
    status: Optional[MarketDefinitionStatusEnum] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('status'), 'exclude': lambda f: f is None }})  
    suspend_time: Optional[datetime] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('suspendTime'), 'encoder': utils.datetimeisoformat(True), 'decoder': dateutil.parser.isoparse, 'mm_field': fields.DateTime(format='iso'), 'exclude': lambda f: f is None }})  
    timezone: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('timezone'), 'exclude': lambda f: f is None }})  
    turn_in_play_enabled: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('turnInPlayEnabled'), 'exclude': lambda f: f is None }})  
    venue: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('venue'), 'exclude': lambda f: f is None }})  
    version: Optional[int] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('version'), 'exclude': lambda f: f is None }})  
    