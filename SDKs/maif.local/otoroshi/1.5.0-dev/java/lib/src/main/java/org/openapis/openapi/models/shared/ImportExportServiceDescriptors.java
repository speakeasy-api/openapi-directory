/* 
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

package org.openapis.openapi.models.shared;

import com.fasterxml.jackson.annotation.JsonInclude.Include;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;

/**
 * ImportExportServiceDescriptors - An otoroshi service descriptor. Represent a forward HTTP call on a domain to another location with some optional api management mecanism
 */
public class ImportExportServiceDescriptors {
    /**
     * The configuration of the canary mode for a service descriptor
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("Canary")
    public Canary canary;

    public ImportExportServiceDescriptors withCanary(Canary canary) {
        this.canary = canary;
        return this;
    }
    
    /**
     * Specify headers that will be added to each client request. Useful to add authentication
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("additionalHeaders")
    public java.util.Map<String, String> additionalHeaders;

    public ImportExportServiceDescriptors withAdditionalHeaders(java.util.Map<String, String> additionalHeaders) {
        this.additionalHeaders = additionalHeaders;
        return this;
    }
    
    /**
     * The Open API configuration for your service (if one)
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("api")
    public ExposedApi api;

    public ImportExportServiceDescriptors withApi(ExposedApi api) {
        this.api = api;
        return this;
    }
    
    /**
     * A reference to a global auth module config
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("authConfigRef")
    public String authConfigRef;

    public ImportExportServiceDescriptors withAuthConfigRef(String authConfigRef) {
        this.authConfigRef = authConfigRef;
        return this;
    }
    
    /**
     * Display a construction page when a user try to use the service
     */
    @JsonProperty("buildMode")
    public Boolean buildMode;

    public ImportExportServiceDescriptors withBuildMode(Boolean buildMode) {
        this.buildMode = buildMode;
        return this;
    }
    
    /**
     * Configuration for the faults that can be injected in requests
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("chaosConfig")
    public ChaosConfig chaosConfig;

    public ImportExportServiceDescriptors withChaosConfig(ChaosConfig chaosConfig) {
        this.chaosConfig = chaosConfig;
        return this;
    }
    
    /**
     * The configuration of the circuit breaker for a service descriptor
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("clientConfig")
    public ClientConfig clientConfig;

    public ImportExportServiceDescriptors withClientConfig(ClientConfig clientConfig) {
        this.clientConfig = clientConfig;
        return this;
    }
    
    /**
     * A reference to validation authority
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("clientValidatorRef")
    public String clientValidatorRef;

    public ImportExportServiceDescriptors withClientValidatorRef(String clientValidatorRef) {
        this.clientValidatorRef = clientValidatorRef;
        return this;
    }
    
    /**
     * The configuration for cors support
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("cors")
    public CorsSettings cors;

    public ImportExportServiceDescriptors withCors(CorsSettings cors) {
        this.cors = cors;
        return this;
    }
    
    /**
     * The domain on which the service is available.
     */
    @JsonProperty("domain")
    public String domain;

    public ImportExportServiceDescriptors withDomain(String domain) {
        this.domain = domain;
        return this;
    }
    
    /**
     * Activate or deactivate your service. Once disabled, users will get an error page saying the service does not exist
     */
    @JsonProperty("enabled")
    public Boolean enabled;

    public ImportExportServiceDescriptors withEnabled(Boolean enabled) {
        this.enabled = enabled;
        return this;
    }
    
    /**
     * When enabled, Otoroshi will try to exchange headers with downstream service to ensure no one else can use the service from outside
     */
    @JsonProperty("enforceSecureCommunication")
    public Boolean enforceSecureCommunication;

    public ImportExportServiceDescriptors withEnforceSecureCommunication(Boolean enforceSecureCommunication) {
        this.enforceSecureCommunication = enforceSecureCommunication;
        return this;
    }
    
    /**
     * The line on which the service is available. Based on that value, the name of the line will be appended to the subdomain. For line prod, nothing will be appended. For example, if the subdomain is 'foo' and line is 'preprod', then the exposed service will be available at 'foo.preprod.mydomain'
     */
    @JsonProperty("env")
    public String env;

    public ImportExportServiceDescriptors withEnv(String env) {
        this.env = env;
        return this;
    }
    
    /**
     * Will force redirection to https:// if not present
     */
    @JsonProperty("forceHttps")
    public Boolean forceHttps;

    public ImportExportServiceDescriptors withForceHttps(Boolean forceHttps) {
        this.forceHttps = forceHttps;
        return this;
    }
    
    /**
     * Each service descriptor is attached to groups. A group can have one or more services. Each API key is linked to a group and allow access to every service in the group
     */
    @JsonProperty("groups")
    public String[] groups;

    public ImportExportServiceDescriptors withGroups(String[] groups) {
        this.groups = groups;
        return this;
    }
    
    /**
     * Configuration for gzip of service responses
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("gzip")
    public Gzip gzip;

    public ImportExportServiceDescriptors withGzip(Gzip gzip) {
        this.gzip = gzip;
        return this;
    }
    
    /**
     * Specify headers that will be verified after routing.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("headersVerification")
    public java.util.Map<String, String> headersVerification;

    public ImportExportServiceDescriptors withHeadersVerification(java.util.Map<String, String> headersVerification) {
        this.headersVerification = headersVerification;
        return this;
    }
    
    /**
     * The configuration for checking health of a service. Otoroshi will perform GET call on the URL to check if the service is still alive
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("healthCheck")
    public HealthCheck healthCheck;

    public ImportExportServiceDescriptors withHealthCheck(HealthCheck healthCheck) {
        this.healthCheck = healthCheck;
        return this;
    }
    
    /**
     * A unique random string to identify your service
     */
    @JsonProperty("id")
    public String id;

    public ImportExportServiceDescriptors withId(String id) {
        this.id = id;
        return this;
    }
    
    /**
     * The filtering configuration block for a service of globally.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("ipFiltering")
    public IpFiltering ipFiltering;

    public ImportExportServiceDescriptors withIpFiltering(IpFiltering ipFiltering) {
        this.ipFiltering = ipFiltering;
        return this;
    }
    
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("jwtVerifier")
    public Object jwtVerifier;

    public ImportExportServiceDescriptors withJwtVerifier(Object jwtVerifier) {
        this.jwtVerifier = jwtVerifier;
        return this;
    }
    
    /**
     * The host used localy, mainly localhost:xxxx
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("localHost")
    public String localHost;

    public ImportExportServiceDescriptors withLocalHost(String localHost) {
        this.localHost = localHost;
        return this;
    }
    
    /**
     * The scheme used localy, mainly http
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("localScheme")
    public String localScheme;

    public ImportExportServiceDescriptors withLocalScheme(String localScheme) {
        this.localScheme = localScheme;
        return this;
    }
    
    /**
     * Display a maintainance page when a user try to use the service
     */
    @JsonProperty("maintenanceMode")
    public Boolean maintenanceMode;

    public ImportExportServiceDescriptors withMaintenanceMode(Boolean maintenanceMode) {
        this.maintenanceMode = maintenanceMode;
        return this;
    }
    
    /**
     * Specify headers that MUST be present on client request to route it. Useful to implement versioning
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("matchingHeaders")
    public java.util.Map<String, String> matchingHeaders;

    public ImportExportServiceDescriptors withMatchingHeaders(java.util.Map<String, String> matchingHeaders) {
        this.matchingHeaders = matchingHeaders;
        return this;
    }
    
    /**
     * The root path on which the service is available
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("matchingRoot")
    public String matchingRoot;

    public ImportExportServiceDescriptors withMatchingRoot(String matchingRoot) {
        this.matchingRoot = matchingRoot;
        return this;
    }
    
    /**
     * Just a bunch of random properties
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("metadata")
    public java.util.Map<String, String> metadata;

    public ImportExportServiceDescriptors withMetadata(java.util.Map<String, String> metadata) {
        this.metadata = metadata;
        return this;
    }
    
    /**
     * The name of your service. Only for debug and human readability purposes
     */
    @JsonProperty("name")
    public String name;

    public ImportExportServiceDescriptors withName(String name) {
        this.name = name;
        return this;
    }
    
    /**
     * Host header will be overriden with Host of the target
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("overrideHost")
    public Boolean overrideHost;

    public ImportExportServiceDescriptors withOverrideHost(Boolean overrideHost) {
        this.overrideHost = overrideHost;
        return this;
    }
    
    /**
     * When enabled, user will be allowed to use the service (UI) only if they are registered users of the private apps domain
     */
    @JsonProperty("privateApp")
    public Boolean privateApp;

    public ImportExportServiceDescriptors withPrivateApp(Boolean privateApp) {
        this.privateApp = privateApp;
        return this;
    }
    
    /**
     * If you define a public pattern that is a little bit too much, you can make some of public URL private again
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("privatePatterns")
    public String[] privatePatterns;

    public ImportExportServiceDescriptors withPrivatePatterns(String[] privatePatterns) {
        this.privatePatterns = privatePatterns;
        return this;
    }
    
    /**
     * By default, every services are private only and you'll need an API key to access it. However, if you want to expose a public UI, you can define one or more public patterns (regex) to allow access to anybody. For example if you want to allow anybody on any URL, just use '/.*'
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("publicPatterns")
    public String[] publicPatterns;

    public ImportExportServiceDescriptors withPublicPatterns(String[] publicPatterns) {
        this.publicPatterns = publicPatterns;
        return this;
    }
    
    /**
     * If you work locally with Otoroshi, you may want to use that feature to redirect one particuliar service to a local host. For example, you can relocate https://foo.preprod.bar.com to http://localhost:8080 to make some tests
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("redirectToLocal")
    public Boolean redirectToLocal;

    public ImportExportServiceDescriptors withRedirectToLocal(Boolean redirectToLocal) {
        this.redirectToLocal = redirectToLocal;
        return this;
    }
    
    /**
     * The configuration for redirection per service
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("redirection")
    public RedirectionSettings redirection;

    public ImportExportServiceDescriptors withRedirection(RedirectionSettings redirection) {
        this.redirection = redirection;
        return this;
    }
    
    /**
     * Otoroshi will append this root to any target choosen. If the specified root is '/api/foo', then a request to https://yyyyyyy/bar will actually hit https://xxxxxxxxx/api/foo/bar
     */
    @JsonProperty("root")
    public String root;

    public ImportExportServiceDescriptors withRoot(String root) {
        this.root = root;
        return this;
    }
    
    /**
     * URI patterns excluded from secured communications
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("secComExcludedPatterns")
    public String[] secComExcludedPatterns;

    public ImportExportServiceDescriptors withSecComExcludedPatterns(String[] secComExcludedPatterns) {
        this.secComExcludedPatterns = secComExcludedPatterns;
        return this;
    }
    
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("secComSettings")
    public Object secComSettings;

    public ImportExportServiceDescriptors withSecComSettings(Object secComSettings) {
        this.secComSettings = secComSettings;
        return this;
    }
    
    /**
     * When enabled, Otoroshi will send headers to consumer like request id, client latency, overhead, etc ...
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("sendOtoroshiHeadersBack")
    public Boolean sendOtoroshiHeadersBack;

    public ImportExportServiceDescriptors withSendOtoroshiHeadersBack(Boolean sendOtoroshiHeadersBack) {
        this.sendOtoroshiHeadersBack = sendOtoroshiHeadersBack;
        return this;
    }
    
    /**
     * The configuration for statsd metrics push
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("statsdConfig")
    public StatsdConfig statsdConfig;

    public ImportExportServiceDescriptors withStatsdConfig(StatsdConfig statsdConfig) {
        this.statsdConfig = statsdConfig;
        return this;
    }
    
    /**
     * The subdomain on which the service is available
     */
    @JsonProperty("subdomain")
    public String subdomain;

    public ImportExportServiceDescriptors withSubdomain(String subdomain) {
        this.subdomain = subdomain;
        return this;
    }
    
    /**
     * The list of target that Otoroshi will proxy and expose through the subdomain defined before. Otoroshi will do round-robin load balancing between all those targets with circuit breaker mecanism to avoid cascading failures
     */
    @JsonProperty("targets")
    public Target[] targets;

    public ImportExportServiceDescriptors withTargets(Target[] targets) {
        this.targets = targets;
        return this;
    }
    
    /**
     * A reference to a request transformer
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("transformerRef")
    public String transformerRef;

    public ImportExportServiceDescriptors withTransformerRef(String transformerRef) {
        this.transformerRef = transformerRef;
        return this;
    }
    
    /**
     * The fact that this service will be seen by users and cannot be impacted by the Snow Monkey
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("userFacing")
    public Boolean userFacing;

    public ImportExportServiceDescriptors withUserFacing(Boolean userFacing) {
        this.userFacing = userFacing;
        return this;
    }
    
    /**
     * Send X-Forwarded-* headers
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("xForwardedHeaders")
    public Boolean xForwardedHeaders;

    public ImportExportServiceDescriptors withXForwardedHeaders(Boolean xForwardedHeaders) {
        this.xForwardedHeaders = xForwardedHeaders;
        return this;
    }
    
    public ImportExportServiceDescriptors(@JsonProperty("buildMode") Boolean buildMode, @JsonProperty("domain") String domain, @JsonProperty("enabled") Boolean enabled, @JsonProperty("enforceSecureCommunication") Boolean enforceSecureCommunication, @JsonProperty("env") String env, @JsonProperty("forceHttps") Boolean forceHttps, @JsonProperty("groups") String[] groups, @JsonProperty("id") String id, @JsonProperty("maintenanceMode") Boolean maintenanceMode, @JsonProperty("name") String name, @JsonProperty("privateApp") Boolean privateApp, @JsonProperty("root") String root, @JsonProperty("subdomain") String subdomain, @JsonProperty("targets") Target[] targets) {
        this.buildMode = buildMode;
        this.domain = domain;
        this.enabled = enabled;
        this.enforceSecureCommunication = enforceSecureCommunication;
        this.env = env;
        this.forceHttps = forceHttps;
        this.groups = groups;
        this.id = id;
        this.maintenanceMode = maintenanceMode;
        this.name = name;
        this.privateApp = privateApp;
        this.root = root;
        this.subdomain = subdomain;
        this.targets = targets;
  }
}
