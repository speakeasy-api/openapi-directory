<?php

/**
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

declare(strict_types=1);

namespace OpenAPI\OpenAPI;

class Users 
{

	// SDK private variables namespaced with _ to avoid conflicts with API models
	private \GuzzleHttp\ClientInterface $_defaultClient;
	private \GuzzleHttp\ClientInterface $_securityClient;
	private string $_serverUrl;
	private string $_language;
	private string $_sdkVersion;
	private string $_genVersion;	

	/**
	 * @param \GuzzleHttp\ClientInterface $defaultClient
	 * @param \GuzzleHttp\ClientInterface $securityClient
	 * @param string $serverUrl
	 * @param string $language
	 * @param string $sdkVersion
	 * @param string $genVersion
	 */
	public function __construct(\GuzzleHttp\ClientInterface $defaultClient, \GuzzleHttp\ClientInterface $securityClient, string $serverUrl, string $language, string $sdkVersion, string $genVersion)
	{
		$this->_defaultClient = $defaultClient;
		$this->_securityClient = $securityClient;
		$this->_serverUrl = $serverUrl;
		$this->_language = $language;
		$this->_sdkVersion = $sdkVersion;
		$this->_genVersion = $genVersion;
	}
	
    /**
     * Delete the user
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\DeleteRealmUsersIdRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\DeleteRealmUsersIdResponse
     */
	public function deleteRealmUsersId(
        \OpenAPI\OpenAPI\Models\Operations\DeleteRealmUsersIdRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\DeleteRealmUsersIdResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/{realm}/users/{id}', \OpenAPI\OpenAPI\Models\Operations\DeleteRealmUsersIdRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_securityClient->request('DELETE', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\DeleteRealmUsersIdResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if (($httpResponse->getStatusCode() >= 200 && $httpResponse->getStatusCode() < 300)) {
        }

        return $response;
    }
	
    /**
     * Revoke consent and offline tokens for particular client from user
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\DeleteRealmUsersIdConsentsClientRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\DeleteRealmUsersIdConsentsClientResponse
     */
	public function deleteRealmUsersIdConsentsClient(
        \OpenAPI\OpenAPI\Models\Operations\DeleteRealmUsersIdConsentsClientRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\DeleteRealmUsersIdConsentsClientResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/{realm}/users/{id}/consents/{client}', \OpenAPI\OpenAPI\Models\Operations\DeleteRealmUsersIdConsentsClientRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_securityClient->request('DELETE', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\DeleteRealmUsersIdConsentsClientResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if (($httpResponse->getStatusCode() >= 200 && $httpResponse->getStatusCode() < 300)) {
        }

        return $response;
    }
	
    /**
     * Remove a credential for a user
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\DeleteRealmUsersIdCredentialsCredentialIdRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\DeleteRealmUsersIdCredentialsCredentialIdResponse
     */
	public function deleteRealmUsersIdCredentialsCredentialId(
        \OpenAPI\OpenAPI\Models\Operations\DeleteRealmUsersIdCredentialsCredentialIdRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\DeleteRealmUsersIdCredentialsCredentialIdResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/{realm}/users/{id}/credentials/{credentialId}', \OpenAPI\OpenAPI\Models\Operations\DeleteRealmUsersIdCredentialsCredentialIdRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_securityClient->request('DELETE', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\DeleteRealmUsersIdCredentialsCredentialIdResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if (($httpResponse->getStatusCode() >= 200 && $httpResponse->getStatusCode() < 300)) {
        }

        return $response;
    }
	
    /**
     * Remove a social login provider from user
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\DeleteRealmUsersIdFederatedIdentityProviderRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\DeleteRealmUsersIdFederatedIdentityProviderResponse
     */
	public function deleteRealmUsersIdFederatedIdentityProvider(
        \OpenAPI\OpenAPI\Models\Operations\DeleteRealmUsersIdFederatedIdentityProviderRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\DeleteRealmUsersIdFederatedIdentityProviderResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/{realm}/users/{id}/federated-identity/{provider}', \OpenAPI\OpenAPI\Models\Operations\DeleteRealmUsersIdFederatedIdentityProviderRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_securityClient->request('DELETE', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\DeleteRealmUsersIdFederatedIdentityProviderResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if (($httpResponse->getStatusCode() >= 200 && $httpResponse->getStatusCode() < 300)) {
        }

        return $response;
    }
	
    /**
     * deleteRealmUsersIdGroupsGroupId
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\DeleteRealmUsersIdGroupsGroupIdRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\DeleteRealmUsersIdGroupsGroupIdResponse
     */
	public function deleteRealmUsersIdGroupsGroupId(
        \OpenAPI\OpenAPI\Models\Operations\DeleteRealmUsersIdGroupsGroupIdRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\DeleteRealmUsersIdGroupsGroupIdResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/{realm}/users/{id}/groups/{groupId}', \OpenAPI\OpenAPI\Models\Operations\DeleteRealmUsersIdGroupsGroupIdRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_securityClient->request('DELETE', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\DeleteRealmUsersIdGroupsGroupIdResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if (($httpResponse->getStatusCode() >= 200 && $httpResponse->getStatusCode() < 300)) {
        }

        return $response;
    }
	
    /**
     * Get users   Returns a list of users, filtered according to query parameters
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetRealmUsersRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\GetRealmUsersResponse
     */
	public function getRealmUsers(
        \OpenAPI\OpenAPI\Models\Operations\GetRealmUsersRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\GetRealmUsersResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/{realm}/users', \OpenAPI\OpenAPI\Models\Operations\GetRealmUsersRequest::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\GetRealmUsersRequest::class, $request, null));
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetRealmUsersResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if (($httpResponse->getStatusCode() >= 200 && $httpResponse->getStatusCode() < 300)) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->userRepresentations = $serializer->deserialize((string)$httpResponse->getBody(), 'array<OpenAPI\OpenAPI\Models\Shared\UserRepresentation>', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Returns the number of users that match the given criteria.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetRealmUsersCountRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\GetRealmUsersCountResponse
     */
	public function getRealmUsersCount(
        \OpenAPI\OpenAPI\Models\Operations\GetRealmUsersCountRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\GetRealmUsersCountResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/{realm}/users/count', \OpenAPI\OpenAPI\Models\Operations\GetRealmUsersCountRequest::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\GetRealmUsersCountRequest::class, $request, null));
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetRealmUsersCountResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if (($httpResponse->getStatusCode() >= 200 && $httpResponse->getStatusCode() < 300)) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->getRealmUsersCount2XXApplicationJSONInt32Integer = $serializer->deserialize((string)$httpResponse->getBody(), 'int', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Get representation of the user
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetRealmUsersIdRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\GetRealmUsersIdResponse
     */
	public function getRealmUsersId(
        \OpenAPI\OpenAPI\Models\Operations\GetRealmUsersIdRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\GetRealmUsersIdResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/{realm}/users/{id}', \OpenAPI\OpenAPI\Models\Operations\GetRealmUsersIdRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetRealmUsersIdResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if (($httpResponse->getStatusCode() >= 200 && $httpResponse->getStatusCode() < 300)) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->userRepresentation = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\UserRepresentation', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Return credential types, which are provided by the user storage where user is stored.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetRealmUsersIdConfiguredUserStorageCredentialTypesRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\GetRealmUsersIdConfiguredUserStorageCredentialTypesResponse
     */
	public function getRealmUsersIdConfiguredUserStorageCredentialTypes(
        \OpenAPI\OpenAPI\Models\Operations\GetRealmUsersIdConfiguredUserStorageCredentialTypesRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\GetRealmUsersIdConfiguredUserStorageCredentialTypesResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/{realm}/users/{id}/configured-user-storage-credential-types', \OpenAPI\OpenAPI\Models\Operations\GetRealmUsersIdConfiguredUserStorageCredentialTypesRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetRealmUsersIdConfiguredUserStorageCredentialTypesResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if (($httpResponse->getStatusCode() >= 200 && $httpResponse->getStatusCode() < 300)) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->getRealmUsersIdConfiguredUserStorageCredentialTypes2XXApplicationJSONStrings = $serializer->deserialize((string)$httpResponse->getBody(), 'array<string>', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Get consents granted by the user
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetRealmUsersIdConsentsRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\GetRealmUsersIdConsentsResponse
     */
	public function getRealmUsersIdConsents(
        \OpenAPI\OpenAPI\Models\Operations\GetRealmUsersIdConsentsRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\GetRealmUsersIdConsentsResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/{realm}/users/{id}/consents', \OpenAPI\OpenAPI\Models\Operations\GetRealmUsersIdConsentsRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetRealmUsersIdConsentsResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if (($httpResponse->getStatusCode() >= 200 && $httpResponse->getStatusCode() < 300)) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->getRealmUsersIdConsents2XXApplicationJSONObjects = $serializer->deserialize((string)$httpResponse->getBody(), 'array<array<string, mixed>>', 'json');
            }
        }

        return $response;
    }
	
    /**
     * getRealmUsersIdCredentials
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetRealmUsersIdCredentialsRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\GetRealmUsersIdCredentialsResponse
     */
	public function getRealmUsersIdCredentials(
        \OpenAPI\OpenAPI\Models\Operations\GetRealmUsersIdCredentialsRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\GetRealmUsersIdCredentialsResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/{realm}/users/{id}/credentials', \OpenAPI\OpenAPI\Models\Operations\GetRealmUsersIdCredentialsRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetRealmUsersIdCredentialsResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if (($httpResponse->getStatusCode() >= 200 && $httpResponse->getStatusCode() < 300)) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->credentialRepresentations = $serializer->deserialize((string)$httpResponse->getBody(), 'array<OpenAPI\OpenAPI\Models\Shared\CredentialRepresentation>', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Get social logins associated with the user
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetRealmUsersIdFederatedIdentityRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\GetRealmUsersIdFederatedIdentityResponse
     */
	public function getRealmUsersIdFederatedIdentity(
        \OpenAPI\OpenAPI\Models\Operations\GetRealmUsersIdFederatedIdentityRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\GetRealmUsersIdFederatedIdentityResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/{realm}/users/{id}/federated-identity', \OpenAPI\OpenAPI\Models\Operations\GetRealmUsersIdFederatedIdentityRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetRealmUsersIdFederatedIdentityResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if (($httpResponse->getStatusCode() >= 200 && $httpResponse->getStatusCode() < 300)) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->federatedIdentityRepresentations = $serializer->deserialize((string)$httpResponse->getBody(), 'array<OpenAPI\OpenAPI\Models\Shared\FederatedIdentityRepresentation>', 'json');
            }
        }

        return $response;
    }
	
    /**
     * getRealmUsersIdGroups
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetRealmUsersIdGroupsRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\GetRealmUsersIdGroupsResponse
     */
	public function getRealmUsersIdGroups(
        \OpenAPI\OpenAPI\Models\Operations\GetRealmUsersIdGroupsRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\GetRealmUsersIdGroupsResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/{realm}/users/{id}/groups', \OpenAPI\OpenAPI\Models\Operations\GetRealmUsersIdGroupsRequest::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\GetRealmUsersIdGroupsRequest::class, $request, null));
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetRealmUsersIdGroupsResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if (($httpResponse->getStatusCode() >= 200 && $httpResponse->getStatusCode() < 300)) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->groupRepresentations = $serializer->deserialize((string)$httpResponse->getBody(), 'array<OpenAPI\OpenAPI\Models\Shared\GroupRepresentation>', 'json');
            }
        }

        return $response;
    }
	
    /**
     * getRealmUsersIdGroupsCount
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetRealmUsersIdGroupsCountRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\GetRealmUsersIdGroupsCountResponse
     */
	public function getRealmUsersIdGroupsCount(
        \OpenAPI\OpenAPI\Models\Operations\GetRealmUsersIdGroupsCountRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\GetRealmUsersIdGroupsCountResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/{realm}/users/{id}/groups/count', \OpenAPI\OpenAPI\Models\Operations\GetRealmUsersIdGroupsCountRequest::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\GetRealmUsersIdGroupsCountRequest::class, $request, null));
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetRealmUsersIdGroupsCountResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if (($httpResponse->getStatusCode() >= 200 && $httpResponse->getStatusCode() < 300)) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->getRealmUsersIdGroupsCount2XXApplicationJSONObject = $serializer->deserialize((string)$httpResponse->getBody(), 'array<string, mixed>', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Get offline sessions associated with the user and client
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetRealmUsersIdOfflineSessionsClientIdRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\GetRealmUsersIdOfflineSessionsClientIdResponse
     */
	public function getRealmUsersIdOfflineSessionsClientId(
        \OpenAPI\OpenAPI\Models\Operations\GetRealmUsersIdOfflineSessionsClientIdRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\GetRealmUsersIdOfflineSessionsClientIdResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/{realm}/users/{id}/offline-sessions/{clientId}', \OpenAPI\OpenAPI\Models\Operations\GetRealmUsersIdOfflineSessionsClientIdRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetRealmUsersIdOfflineSessionsClientIdResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if (($httpResponse->getStatusCode() >= 200 && $httpResponse->getStatusCode() < 300)) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->userSessionRepresentations = $serializer->deserialize((string)$httpResponse->getBody(), 'array<OpenAPI\OpenAPI\Models\Shared\UserSessionRepresentation>', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Get sessions associated with the user
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetRealmUsersIdSessionsRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\GetRealmUsersIdSessionsResponse
     */
	public function getRealmUsersIdSessions(
        \OpenAPI\OpenAPI\Models\Operations\GetRealmUsersIdSessionsRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\GetRealmUsersIdSessionsResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/{realm}/users/{id}/sessions', \OpenAPI\OpenAPI\Models\Operations\GetRealmUsersIdSessionsRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetRealmUsersIdSessionsResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if (($httpResponse->getStatusCode() >= 200 && $httpResponse->getStatusCode() < 300)) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->userSessionRepresentations = $serializer->deserialize((string)$httpResponse->getBody(), 'array<OpenAPI\OpenAPI\Models\Shared\UserSessionRepresentation>', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Create a new user   Username must be unique.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\PostRealmUsersRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\PostRealmUsersResponse
     */
	public function postRealmUsers(
        \OpenAPI\OpenAPI\Models\Operations\PostRealmUsersRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\PostRealmUsersResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/{realm}/users', \OpenAPI\OpenAPI\Models\Operations\PostRealmUsersRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "userRepresentation", "json");
        if ($body === null) {
            throw new \Exception('Request body is required');
        }
        $options = array_merge_recursive($options, $body);
        
        $httpResponse = $this->_securityClient->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\PostRealmUsersResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if (($httpResponse->getStatusCode() >= 200 && $httpResponse->getStatusCode() < 300)) {
        }

        return $response;
    }
	
    /**
     * Move a credential to a position behind another credential
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\PostRealmUsersIdCredentialsCredentialIdMoveAfterNewPreviousCredentialIdRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\PostRealmUsersIdCredentialsCredentialIdMoveAfterNewPreviousCredentialIdResponse
     */
	public function postRealmUsersIdCredentialsCredentialIdMoveAfterNewPreviousCredentialId(
        \OpenAPI\OpenAPI\Models\Operations\PostRealmUsersIdCredentialsCredentialIdMoveAfterNewPreviousCredentialIdRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\PostRealmUsersIdCredentialsCredentialIdMoveAfterNewPreviousCredentialIdResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/{realm}/users/{id}/credentials/{credentialId}/moveAfter/{newPreviousCredentialId}', \OpenAPI\OpenAPI\Models\Operations\PostRealmUsersIdCredentialsCredentialIdMoveAfterNewPreviousCredentialIdRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_securityClient->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\PostRealmUsersIdCredentialsCredentialIdMoveAfterNewPreviousCredentialIdResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if (($httpResponse->getStatusCode() >= 200 && $httpResponse->getStatusCode() < 300)) {
        }

        return $response;
    }
	
    /**
     * Move a credential to a first position in the credentials list of the user
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\PostRealmUsersIdCredentialsCredentialIdMoveToFirstRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\PostRealmUsersIdCredentialsCredentialIdMoveToFirstResponse
     */
	public function postRealmUsersIdCredentialsCredentialIdMoveToFirst(
        \OpenAPI\OpenAPI\Models\Operations\PostRealmUsersIdCredentialsCredentialIdMoveToFirstRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\PostRealmUsersIdCredentialsCredentialIdMoveToFirstResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/{realm}/users/{id}/credentials/{credentialId}/moveToFirst', \OpenAPI\OpenAPI\Models\Operations\PostRealmUsersIdCredentialsCredentialIdMoveToFirstRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_securityClient->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\PostRealmUsersIdCredentialsCredentialIdMoveToFirstResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if (($httpResponse->getStatusCode() >= 200 && $httpResponse->getStatusCode() < 300)) {
        }

        return $response;
    }
	
    /**
     * Add a social login provider to the user
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\PostRealmUsersIdFederatedIdentityProviderRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\PostRealmUsersIdFederatedIdentityProviderResponse
     */
	public function postRealmUsersIdFederatedIdentityProvider(
        \OpenAPI\OpenAPI\Models\Operations\PostRealmUsersIdFederatedIdentityProviderRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\PostRealmUsersIdFederatedIdentityProviderResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/{realm}/users/{id}/federated-identity/{provider}', \OpenAPI\OpenAPI\Models\Operations\PostRealmUsersIdFederatedIdentityProviderRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "federatedIdentityRepresentation", "json");
        if ($body === null) {
            throw new \Exception('Request body is required');
        }
        $options = array_merge_recursive($options, $body);
        
        $httpResponse = $this->_securityClient->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\PostRealmUsersIdFederatedIdentityProviderResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if (($httpResponse->getStatusCode() >= 200 && $httpResponse->getStatusCode() < 300)) {
        }

        return $response;
    }
	
    /**
     * Impersonate the user
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\PostRealmUsersIdImpersonationRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\PostRealmUsersIdImpersonationResponse
     */
	public function postRealmUsersIdImpersonation(
        \OpenAPI\OpenAPI\Models\Operations\PostRealmUsersIdImpersonationRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\PostRealmUsersIdImpersonationResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/{realm}/users/{id}/impersonation', \OpenAPI\OpenAPI\Models\Operations\PostRealmUsersIdImpersonationRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_securityClient->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\PostRealmUsersIdImpersonationResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if (($httpResponse->getStatusCode() >= 200 && $httpResponse->getStatusCode() < 300)) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->postRealmUsersIdImpersonation2XXApplicationJSONObject = $serializer->deserialize((string)$httpResponse->getBody(), 'array<string, mixed>', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Remove all user sessions associated with the user   Also send notification to all clients that have an admin URL to invalidate the sessions for the particular user.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\PostRealmUsersIdLogoutRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\PostRealmUsersIdLogoutResponse
     */
	public function postRealmUsersIdLogout(
        \OpenAPI\OpenAPI\Models\Operations\PostRealmUsersIdLogoutRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\PostRealmUsersIdLogoutResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/{realm}/users/{id}/logout', \OpenAPI\OpenAPI\Models\Operations\PostRealmUsersIdLogoutRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_securityClient->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\PostRealmUsersIdLogoutResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if (($httpResponse->getStatusCode() >= 200 && $httpResponse->getStatusCode() < 300)) {
        }

        return $response;
    }
	
    /**
     * Update the user
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\PutRealmUsersIdRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\PutRealmUsersIdResponse
     */
	public function putRealmUsersId(
        \OpenAPI\OpenAPI\Models\Operations\PutRealmUsersIdRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\PutRealmUsersIdResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/{realm}/users/{id}', \OpenAPI\OpenAPI\Models\Operations\PutRealmUsersIdRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "userRepresentation", "json");
        if ($body === null) {
            throw new \Exception('Request body is required');
        }
        $options = array_merge_recursive($options, $body);
        
        $httpResponse = $this->_securityClient->request('PUT', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\PutRealmUsersIdResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if (($httpResponse->getStatusCode() >= 200 && $httpResponse->getStatusCode() < 300)) {
        }

        return $response;
    }
	
    /**
     * Update a credential label for a user
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\PutRealmUsersIdCredentialsCredentialIdUserLabelRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\PutRealmUsersIdCredentialsCredentialIdUserLabelResponse
     */
	public function putRealmUsersIdCredentialsCredentialIdUserLabel(
        \OpenAPI\OpenAPI\Models\Operations\PutRealmUsersIdCredentialsCredentialIdUserLabelRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\PutRealmUsersIdCredentialsCredentialIdUserLabelResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/{realm}/users/{id}/credentials/{credentialId}/userLabel', \OpenAPI\OpenAPI\Models\Operations\PutRealmUsersIdCredentialsCredentialIdUserLabelRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "requestBody", "string");
        if ($body === null) {
            throw new \Exception('Request body is required');
        }
        $options = array_merge_recursive($options, $body);
        
        $httpResponse = $this->_securityClient->request('PUT', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\PutRealmUsersIdCredentialsCredentialIdUserLabelResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if (($httpResponse->getStatusCode() >= 200 && $httpResponse->getStatusCode() < 300)) {
        }

        return $response;
    }
	
    /**
     * Disable all credentials for a user of a specific type
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\PutRealmUsersIdDisableCredentialTypesRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\PutRealmUsersIdDisableCredentialTypesResponse
     */
	public function putRealmUsersIdDisableCredentialTypes(
        \OpenAPI\OpenAPI\Models\Operations\PutRealmUsersIdDisableCredentialTypesRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\PutRealmUsersIdDisableCredentialTypesResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/{realm}/users/{id}/disable-credential-types', \OpenAPI\OpenAPI\Models\Operations\PutRealmUsersIdDisableCredentialTypesRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "requestBody", "json");
        if ($body === null) {
            throw new \Exception('Request body is required');
        }
        $options = array_merge_recursive($options, $body);
        
        $httpResponse = $this->_securityClient->request('PUT', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\PutRealmUsersIdDisableCredentialTypesResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if (($httpResponse->getStatusCode() >= 200 && $httpResponse->getStatusCode() < 300)) {
        }

        return $response;
    }
	
    /**
     * Send a update account email to the user   An email contains a link the user can click to perform a set of required actions.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\PutRealmUsersIdExecuteActionsEmailRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\PutRealmUsersIdExecuteActionsEmailResponse
     */
	public function putRealmUsersIdExecuteActionsEmail(
        \OpenAPI\OpenAPI\Models\Operations\PutRealmUsersIdExecuteActionsEmailRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\PutRealmUsersIdExecuteActionsEmailResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/{realm}/users/{id}/execute-actions-email', \OpenAPI\OpenAPI\Models\Operations\PutRealmUsersIdExecuteActionsEmailRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "requestBody", "json");
        if ($body === null) {
            throw new \Exception('Request body is required');
        }
        $options = array_merge_recursive($options, $body);
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\PutRealmUsersIdExecuteActionsEmailRequest::class, $request, null));
        
        $httpResponse = $this->_securityClient->request('PUT', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\PutRealmUsersIdExecuteActionsEmailResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if (($httpResponse->getStatusCode() >= 200 && $httpResponse->getStatusCode() < 300)) {
        }

        return $response;
    }
	
    /**
     * putRealmUsersIdGroupsGroupId
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\PutRealmUsersIdGroupsGroupIdRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\PutRealmUsersIdGroupsGroupIdResponse
     */
	public function putRealmUsersIdGroupsGroupId(
        \OpenAPI\OpenAPI\Models\Operations\PutRealmUsersIdGroupsGroupIdRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\PutRealmUsersIdGroupsGroupIdResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/{realm}/users/{id}/groups/{groupId}', \OpenAPI\OpenAPI\Models\Operations\PutRealmUsersIdGroupsGroupIdRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_securityClient->request('PUT', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\PutRealmUsersIdGroupsGroupIdResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if (($httpResponse->getStatusCode() >= 200 && $httpResponse->getStatusCode() < 300)) {
        }

        return $response;
    }
	
    /**
     * Set up a new password for the user.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\PutRealmUsersIdResetPasswordRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\PutRealmUsersIdResetPasswordResponse
     */
	public function putRealmUsersIdResetPassword(
        \OpenAPI\OpenAPI\Models\Operations\PutRealmUsersIdResetPasswordRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\PutRealmUsersIdResetPasswordResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/{realm}/users/{id}/reset-password', \OpenAPI\OpenAPI\Models\Operations\PutRealmUsersIdResetPasswordRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "credentialRepresentation", "json");
        if ($body === null) {
            throw new \Exception('Request body is required');
        }
        $options = array_merge_recursive($options, $body);
        
        $httpResponse = $this->_securityClient->request('PUT', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\PutRealmUsersIdResetPasswordResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if (($httpResponse->getStatusCode() >= 200 && $httpResponse->getStatusCode() < 300)) {
        }

        return $response;
    }
	
    /**
     * Send an email-verification email to the user   An email contains a link the user can click to verify their email address.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\PutRealmUsersIdSendVerifyEmailRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\PutRealmUsersIdSendVerifyEmailResponse
     */
	public function putRealmUsersIdSendVerifyEmail(
        \OpenAPI\OpenAPI\Models\Operations\PutRealmUsersIdSendVerifyEmailRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\PutRealmUsersIdSendVerifyEmailResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/{realm}/users/{id}/send-verify-email', \OpenAPI\OpenAPI\Models\Operations\PutRealmUsersIdSendVerifyEmailRequest::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\PutRealmUsersIdSendVerifyEmailRequest::class, $request, null));
        
        $httpResponse = $this->_securityClient->request('PUT', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\PutRealmUsersIdSendVerifyEmailResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if (($httpResponse->getStatusCode() >= 200 && $httpResponse->getStatusCode() < 300)) {
        }

        return $response;
    }
}