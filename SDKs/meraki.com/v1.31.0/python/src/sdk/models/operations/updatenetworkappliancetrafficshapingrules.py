"""Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT."""

from __future__ import annotations
import dataclasses
import requests as requests_http
from dataclasses_json import Undefined, dataclass_json
from enum import Enum
from sdk import utils
from typing import Any, Optional

class UpdateNetworkApplianceTrafficShapingRulesRequestBodyRulesDefinitionsTypeEnum(str, Enum):
    r"""The type of definition. Can be one of 'application', 'applicationCategory', 'host', 'port', 'ipRange' or 'localNet'."""
    APPLICATION = 'application'
    APPLICATION_CATEGORY = 'applicationCategory'
    HOST = 'host'
    IP_RANGE = 'ipRange'
    LOCAL_NET = 'localNet'
    PORT = 'port'


@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class UpdateNetworkApplianceTrafficShapingRulesRequestBodyRulesDefinitions:
    
    type: UpdateNetworkApplianceTrafficShapingRulesRequestBodyRulesDefinitionsTypeEnum = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('type') }})
    r"""The type of definition. Can be one of 'application', 'applicationCategory', 'host', 'port', 'ipRange' or 'localNet'."""  
    value: str = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('value') }})
    r"""If \\"type\\" is 'host', 'port', 'ipRange' or 'localNet', then \\"value\\" must be a string, matching either
        a hostname (e.g. \"somesite.com\"), a port (e.g. 8080), or an IP range (\"192.1.0.0\",
        \"192.1.0.0/16\", or \"10.1.0.0/16:80\"). 'localNet' also supports CIDR notation, excluding
        custom ports.
         If \"type\" is 'application' or 'applicationCategory', then \"value\" must be an object
        with the structure { \"id\": \"meraki:layer7/...\" }, where \"id\" is the application category or
        application ID (for a list of IDs for your network, use the trafficShaping/applicationCategories
        endpoint).
    """  
    

@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class UpdateNetworkApplianceTrafficShapingRulesRequestBodyRulesPerClientBandwidthLimitsBandwidthLimits:
    r"""The bandwidth limits object, specifying the upload ('limitUp') and download ('limitDown') speed in Kbps. These are only enforced if 'settings' is set to 'custom'."""
    
    limit_down: Optional[int] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('limitDown'), 'exclude': lambda f: f is None }})
    r"""The maximum download limit (integer, in Kbps)."""  
    limit_up: Optional[int] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('limitUp'), 'exclude': lambda f: f is None }})
    r"""The maximum upload limit (integer, in Kbps)."""  
    

@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class UpdateNetworkApplianceTrafficShapingRulesRequestBodyRulesPerClientBandwidthLimits:
    r"""An object describing the bandwidth settings for your rule."""
    
    bandwidth_limits: Optional[UpdateNetworkApplianceTrafficShapingRulesRequestBodyRulesPerClientBandwidthLimitsBandwidthLimits] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('bandwidthLimits'), 'exclude': lambda f: f is None }})
    r"""The bandwidth limits object, specifying the upload ('limitUp') and download ('limitDown') speed in Kbps. These are only enforced if 'settings' is set to 'custom'."""  
    settings: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('settings'), 'exclude': lambda f: f is None }})
    r"""How bandwidth limits are applied by your rule. Can be one of 'network default', 'ignore' or 'custom'."""  
    

@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class UpdateNetworkApplianceTrafficShapingRulesRequestBodyRules:
    
    definitions: list[UpdateNetworkApplianceTrafficShapingRulesRequestBodyRulesDefinitions] = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('definitions') }})
    r"""A list of objects describing the definitions of your traffic shaping rule. At least one definition is required."""  
    dscp_tag_value: Optional[int] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('dscpTagValue'), 'exclude': lambda f: f is None }})
    r"""The DSCP tag applied by your rule. null means 'Do not change DSCP tag'.
        For a list of possible tag values, use the trafficShaping/dscpTaggingOptions endpoint.
    """  
    per_client_bandwidth_limits: Optional[UpdateNetworkApplianceTrafficShapingRulesRequestBodyRulesPerClientBandwidthLimits] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('perClientBandwidthLimits'), 'exclude': lambda f: f is None }})
    r"""An object describing the bandwidth settings for your rule."""  
    priority: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('priority'), 'exclude': lambda f: f is None }})
    r"""A string, indicating the priority level for packets bound to your rule.
        Can be 'low', 'normal' or 'high'.
    """  
    

@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class UpdateNetworkApplianceTrafficShapingRulesRequestBody:
    
    default_rules_enabled: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('defaultRulesEnabled'), 'exclude': lambda f: f is None }})
    r"""Whether default traffic shaping rules are enabled (true) or disabled (false). There are 4 default rules, which can be seen on your network's traffic shaping page. Note that default rules count against the rule limit of 8."""  
    rules: Optional[list[UpdateNetworkApplianceTrafficShapingRulesRequestBodyRules]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('rules'), 'exclude': lambda f: f is None }})
    r"""An array of traffic shaping rules. Rules are applied in the order that
        they are specified in. An empty list (or null) means no rules. Note that
        you are allowed a maximum of 8 rules.
    """  
    

@dataclasses.dataclass
class UpdateNetworkApplianceTrafficShapingRulesRequest:
    
    network_id: str = dataclasses.field(metadata={'path_param': { 'field_name': 'networkId', 'style': 'simple', 'explode': False }})  
    request_body: Optional[UpdateNetworkApplianceTrafficShapingRulesRequestBody] = dataclasses.field(default=None, metadata={'request': { 'media_type': 'application/json' }})  
    

@dataclasses.dataclass
class UpdateNetworkApplianceTrafficShapingRulesResponse:
    
    content_type: str = dataclasses.field()  
    status_code: int = dataclasses.field()  
    raw_response: Optional[requests_http.Response] = dataclasses.field(default=None)  
    update_network_appliance_traffic_shaping_rules_200_application_json_object: Optional[dict[str, Any]] = dataclasses.field(default=None)
    r"""Successful operation"""  
    