// Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.

package shared

import (
	"bytes"
	"encoding/json"
	"errors"
	"fmt"
)

// ChannelFrom5 - Connect to a VBC extension
type ChannelFrom5 struct {
	Extension string `json:"extension"`
	// The type of connection. Must be `vbc`
	Type string `json:"type"`
}

type ChannelFrom4ContentTypeEnum string

const (
	ChannelFrom4ContentTypeEnumAudioL16RateEqual8000  ChannelFrom4ContentTypeEnum = "audio/l16;rate=8000"
	ChannelFrom4ContentTypeEnumAudioL16RateEqual16000 ChannelFrom4ContentTypeEnum = "audio/l16;rate=16000"
)

func (e *ChannelFrom4ContentTypeEnum) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return err
	}
	switch s {
	case "audio/l16;rate=8000":
		fallthrough
	case "audio/l16;rate=16000":
		*e = ChannelFrom4ContentTypeEnum(s)
		return nil
	default:
		return fmt.Errorf("invalid value for ChannelFrom4ContentTypeEnum: %s", s)
	}
}

// ChannelFrom4Headers - Details of the Websocket you want to connect to
type ChannelFrom4Headers struct {
	// This is an example header. You can provide any headers you may need
	CustomerID *string `json:"customer_id,omitempty"`
}

// ChannelFrom4 - Connect to a Websocket
type ChannelFrom4 struct {
	ContentType ChannelFrom4ContentTypeEnum `json:"content-type"`
	// Details of the Websocket you want to connect to
	Headers *ChannelFrom4Headers `json:"headers,omitempty"`
	// The type of connection. Must be `websocket`
	Type string  `json:"type"`
	URI  *string `json:"uri,omitempty"`
}

// ChannelFrom3 - Connect to a SIP Endpoint
type ChannelFrom3 struct {
	// The type of connection. Must be `sip`
	Type string `json:"type"`
	// The SIP URI to connect to
	URI *string `json:"uri,omitempty"`
}

// ChannelFrom2 - Connect to a Phone (PSTN) number
type ChannelFrom2 struct {
	// The phone number to connect to
	Number string `json:"number"`
	// The type of connection. Must be `phone`
	Type string `json:"type"`
}

// ChannelFrom1 - Connect to an App User
type ChannelFrom1 struct {
	// The type of connection. Must be `app`
	Type string `json:"type"`
	// The username to connect to
	User string `json:"user"`
}

type ChannelFromType string

const (
	ChannelFromTypeChannelFrom1 ChannelFromType = "channel_from_1"
	ChannelFromTypeChannelFrom2 ChannelFromType = "channel_from_2"
	ChannelFromTypeChannelFrom3 ChannelFromType = "channel_from_3"
	ChannelFromTypeChannelFrom4 ChannelFromType = "channel_from_4"
	ChannelFromTypeChannelFrom5 ChannelFromType = "channel_from_5"
)

type ChannelFrom struct {
	ChannelFrom1 *ChannelFrom1
	ChannelFrom2 *ChannelFrom2
	ChannelFrom3 *ChannelFrom3
	ChannelFrom4 *ChannelFrom4
	ChannelFrom5 *ChannelFrom5

	Type ChannelFromType
}

func CreateChannelFromChannelFrom1(channelFrom1 ChannelFrom1) ChannelFrom {
	typ := ChannelFromTypeChannelFrom1

	return ChannelFrom{
		ChannelFrom1: &channelFrom1,
		Type:         typ,
	}
}

func CreateChannelFromChannelFrom2(channelFrom2 ChannelFrom2) ChannelFrom {
	typ := ChannelFromTypeChannelFrom2

	return ChannelFrom{
		ChannelFrom2: &channelFrom2,
		Type:         typ,
	}
}

func CreateChannelFromChannelFrom3(channelFrom3 ChannelFrom3) ChannelFrom {
	typ := ChannelFromTypeChannelFrom3

	return ChannelFrom{
		ChannelFrom3: &channelFrom3,
		Type:         typ,
	}
}

func CreateChannelFromChannelFrom4(channelFrom4 ChannelFrom4) ChannelFrom {
	typ := ChannelFromTypeChannelFrom4

	return ChannelFrom{
		ChannelFrom4: &channelFrom4,
		Type:         typ,
	}
}

func CreateChannelFromChannelFrom5(channelFrom5 ChannelFrom5) ChannelFrom {
	typ := ChannelFromTypeChannelFrom5

	return ChannelFrom{
		ChannelFrom5: &channelFrom5,
		Type:         typ,
	}
}

func (u *ChannelFrom) UnmarshalJSON(data []byte) error {
	var d *json.Decoder

	channelFrom1 := new(ChannelFrom1)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&channelFrom1); err == nil {
		u.ChannelFrom1 = channelFrom1
		u.Type = ChannelFromTypeChannelFrom1
		return nil
	}

	channelFrom2 := new(ChannelFrom2)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&channelFrom2); err == nil {
		u.ChannelFrom2 = channelFrom2
		u.Type = ChannelFromTypeChannelFrom2
		return nil
	}

	channelFrom3 := new(ChannelFrom3)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&channelFrom3); err == nil {
		u.ChannelFrom3 = channelFrom3
		u.Type = ChannelFromTypeChannelFrom3
		return nil
	}

	channelFrom4 := new(ChannelFrom4)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&channelFrom4); err == nil {
		u.ChannelFrom4 = channelFrom4
		u.Type = ChannelFromTypeChannelFrom4
		return nil
	}

	channelFrom5 := new(ChannelFrom5)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&channelFrom5); err == nil {
		u.ChannelFrom5 = channelFrom5
		u.Type = ChannelFromTypeChannelFrom5
		return nil
	}

	return errors.New("could not unmarshal into supported union types")
}

func (u ChannelFrom) MarshalJSON() ([]byte, error) {
	if u.ChannelFrom1 != nil {
		return json.Marshal(u.ChannelFrom1)
	}

	if u.ChannelFrom2 != nil {
		return json.Marshal(u.ChannelFrom2)
	}

	if u.ChannelFrom3 != nil {
		return json.Marshal(u.ChannelFrom3)
	}

	if u.ChannelFrom4 != nil {
		return json.Marshal(u.ChannelFrom4)
	}

	if u.ChannelFrom5 != nil {
		return json.Marshal(u.ChannelFrom5)
	}

	return nil, nil
}

type ChannelLegIds struct {
	// The id of the leg. rtc_id and call_id are leg id
	LegID *string `json:"leg_id,omitempty"`
}

// ChannelTo2 - Connect to a Phone (PSTN) number
type ChannelTo2 struct {
	// Provide [DTMF digits](https://developer.nexmo.com/voice/voice-api/guides/dtmf) to send when the call is answered
	DtmfAnswer *string `json:"dtmfAnswer,omitempty"`
	// The phone number to connect to
	Number string `json:"number"`
	// The type of connection. Must be `phone`
	Type string `json:"type"`
}

type ChannelToType string

const (
	ChannelToTypeZero       ChannelToType = "0"
	ChannelToTypeChannelTo2 ChannelToType = "channel_to_2"
	ChannelToTypeTwo        ChannelToType = "2"
	ChannelToTypeThree      ChannelToType = "3"
	ChannelToTypeFour       ChannelToType = "4"
)

type ChannelTo struct {
	Zero       *Zero
	ChannelTo2 *ChannelTo2
	Two        *Two
	Three      *Three
	Four       *Four

	Type ChannelToType
}

func CreateChannelToZero(zero Zero) ChannelTo {
	typ := ChannelToTypeZero

	return ChannelTo{
		Zero: &zero,
		Type: typ,
	}
}

func CreateChannelToChannelTo2(channelTo2 ChannelTo2) ChannelTo {
	typ := ChannelToTypeChannelTo2

	return ChannelTo{
		ChannelTo2: &channelTo2,
		Type:       typ,
	}
}

func CreateChannelToTwo(two Two) ChannelTo {
	typ := ChannelToTypeTwo

	return ChannelTo{
		Two:  &two,
		Type: typ,
	}
}

func CreateChannelToThree(three Three) ChannelTo {
	typ := ChannelToTypeThree

	return ChannelTo{
		Three: &three,
		Type:  typ,
	}
}

func CreateChannelToFour(four Four) ChannelTo {
	typ := ChannelToTypeFour

	return ChannelTo{
		Four: &four,
		Type: typ,
	}
}

func (u *ChannelTo) UnmarshalJSON(data []byte) error {
	var d *json.Decoder

	zero := new(Zero)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&zero); err == nil {
		u.Zero = zero
		u.Type = ChannelToTypeZero
		return nil
	}

	channelTo2 := new(ChannelTo2)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&channelTo2); err == nil {
		u.ChannelTo2 = channelTo2
		u.Type = ChannelToTypeChannelTo2
		return nil
	}

	two := new(Two)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&two); err == nil {
		u.Two = two
		u.Type = ChannelToTypeTwo
		return nil
	}

	three := new(Three)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&three); err == nil {
		u.Three = three
		u.Type = ChannelToTypeThree
		return nil
	}

	four := new(Four)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&four); err == nil {
		u.Four = four
		u.Type = ChannelToTypeFour
		return nil
	}

	return errors.New("could not unmarshal into supported union types")
}

func (u ChannelTo) MarshalJSON() ([]byte, error) {
	if u.Zero != nil {
		return json.Marshal(u.Zero)
	}

	if u.ChannelTo2 != nil {
		return json.Marshal(u.ChannelTo2)
	}

	if u.Two != nil {
		return json.Marshal(u.Two)
	}

	if u.Three != nil {
		return json.Marshal(u.Three)
	}

	if u.Four != nil {
		return json.Marshal(u.Four)
	}

	return nil, nil
}

// Channel - A user who joins a conversation as a member can have one channel per membership type. Channels can be `app`, `phone`, `sip`, `websocket`, or `vbc`
type Channel struct {
	From *ChannelFrom `json:"from,omitempty"`
	// The id of the leg. rtc_id and call_id are leg id
	LegID *string `json:"leg_id,omitempty"`
	// Leg ids associated with this Channel. The first item in the array represents the main active Leg. The second item, if exists, represents a screen-share Leg.
	LegIds []ChannelLegIds `json:"leg_ids,omitempty"`
	To     *ChannelTo      `json:"to,omitempty"`
	// Channel type
	Type *ChannelTypeEnum `json:"type,omitempty"`
}
