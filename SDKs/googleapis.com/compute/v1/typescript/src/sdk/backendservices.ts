/*
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

import * as utils from "../internal/utils";
import * as operations from "./models/operations";
import * as shared from "./models/shared";
import { AxiosInstance, AxiosRequestConfig, AxiosResponse } from "axios";

export class BackendServices {
  _defaultClient: AxiosInstance;
  _securityClient: AxiosInstance;
  _serverURL: string;
  _language: string;
  _sdkVersion: string;
  _genVersion: string;

  constructor(
    defaultClient: AxiosInstance,
    securityClient: AxiosInstance,
    serverURL: string,
    language: string,
    sdkVersion: string,
    genVersion: string
  ) {
    this._defaultClient = defaultClient;
    this._securityClient = securityClient;
    this._serverURL = serverURL;
    this._language = language;
    this._sdkVersion = sdkVersion;
    this._genVersion = genVersion;
  }

  /**
   * Adds a key for validating requests with signed URLs for this backend service.
   */
  computeBackendServicesAddSignedUrlKey(
    req: operations.ComputeBackendServicesAddSignedUrlKeyRequest,
    security: operations.ComputeBackendServicesAddSignedUrlKeySecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.ComputeBackendServicesAddSignedUrlKeyResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ComputeBackendServicesAddSignedUrlKeyRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/projects/{project}/global/backendServices/{backendService}/addSignedUrlKey",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "signedUrlKey",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ComputeBackendServicesAddSignedUrlKeySecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ComputeBackendServicesAddSignedUrlKeyResponse =
        new operations.ComputeBackendServicesAddSignedUrlKeyResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.operation = utils.objectToClass(
              httpRes?.data,
              shared.Operation
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Retrieves the list of all BackendService resources, regional and global, available to the specified project.
   */
  computeBackendServicesAggregatedList(
    req: operations.ComputeBackendServicesAggregatedListRequest,
    security: operations.ComputeBackendServicesAggregatedListSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.ComputeBackendServicesAggregatedListResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ComputeBackendServicesAggregatedListRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/projects/{project}/aggregated/backendServices",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ComputeBackendServicesAggregatedListSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ComputeBackendServicesAggregatedListResponse =
        new operations.ComputeBackendServicesAggregatedListResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.backendServiceAggregatedList = utils.objectToClass(
              httpRes?.data,
              shared.BackendServiceAggregatedList
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Deletes the specified BackendService resource.
   */
  computeBackendServicesDelete(
    req: operations.ComputeBackendServicesDeleteRequest,
    security: operations.ComputeBackendServicesDeleteSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.ComputeBackendServicesDeleteResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ComputeBackendServicesDeleteRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/projects/{project}/global/backendServices/{backendService}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ComputeBackendServicesDeleteSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ComputeBackendServicesDeleteResponse =
        new operations.ComputeBackendServicesDeleteResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.operation = utils.objectToClass(
              httpRes?.data,
              shared.Operation
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Deletes a key for validating requests with signed URLs for this backend service.
   */
  computeBackendServicesDeleteSignedUrlKey(
    req: operations.ComputeBackendServicesDeleteSignedUrlKeyRequest,
    security: operations.ComputeBackendServicesDeleteSignedUrlKeySecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.ComputeBackendServicesDeleteSignedUrlKeyResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ComputeBackendServicesDeleteSignedUrlKeyRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/projects/{project}/global/backendServices/{backendService}/deleteSignedUrlKey",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.ComputeBackendServicesDeleteSignedUrlKeySecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "post",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ComputeBackendServicesDeleteSignedUrlKeyResponse =
        new operations.ComputeBackendServicesDeleteSignedUrlKeyResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.operation = utils.objectToClass(
              httpRes?.data,
              shared.Operation
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Returns the specified BackendService resource.
   */
  computeBackendServicesGet(
    req: operations.ComputeBackendServicesGetRequest,
    security: operations.ComputeBackendServicesGetSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.ComputeBackendServicesGetResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ComputeBackendServicesGetRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/projects/{project}/global/backendServices/{backendService}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ComputeBackendServicesGetSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ComputeBackendServicesGetResponse =
        new operations.ComputeBackendServicesGetResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.backendService = utils.objectToClass(
              httpRes?.data,
              shared.BackendService
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Gets the most recent health check results for this BackendService. Example request body: { "group": "/zones/us-east1-b/instanceGroups/lb-backend-example" }
   */
  computeBackendServicesGetHealth(
    req: operations.ComputeBackendServicesGetHealthRequest,
    security: operations.ComputeBackendServicesGetHealthSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.ComputeBackendServicesGetHealthResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ComputeBackendServicesGetHealthRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/projects/{project}/global/backendServices/{backendService}/getHealth",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "resourceGroupReference",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ComputeBackendServicesGetHealthSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ComputeBackendServicesGetHealthResponse =
        new operations.ComputeBackendServicesGetHealthResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.backendServiceGroupHealth = utils.objectToClass(
              httpRes?.data,
              shared.BackendServiceGroupHealth
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Gets the access control policy for a resource. May be empty if no such policy or resource exists.
   */
  computeBackendServicesGetIamPolicy(
    req: operations.ComputeBackendServicesGetIamPolicyRequest,
    security: operations.ComputeBackendServicesGetIamPolicySecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.ComputeBackendServicesGetIamPolicyResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ComputeBackendServicesGetIamPolicyRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/projects/{project}/global/backendServices/{resource}/getIamPolicy",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ComputeBackendServicesGetIamPolicySecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ComputeBackendServicesGetIamPolicyResponse =
        new operations.ComputeBackendServicesGetIamPolicyResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.policy = utils.objectToClass(httpRes?.data, shared.Policy);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Creates a BackendService resource in the specified project using the data included in the request. For more information, see Backend services overview .
   */
  computeBackendServicesInsert(
    req: operations.ComputeBackendServicesInsertRequest,
    security: operations.ComputeBackendServicesInsertSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.ComputeBackendServicesInsertResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ComputeBackendServicesInsertRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/projects/{project}/global/backendServices",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "backendService",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ComputeBackendServicesInsertSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ComputeBackendServicesInsertResponse =
        new operations.ComputeBackendServicesInsertResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.operation = utils.objectToClass(
              httpRes?.data,
              shared.Operation
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Retrieves the list of BackendService resources available to the specified project.
   */
  computeBackendServicesList(
    req: operations.ComputeBackendServicesListRequest,
    security: operations.ComputeBackendServicesListSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.ComputeBackendServicesListResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ComputeBackendServicesListRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/projects/{project}/global/backendServices",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ComputeBackendServicesListSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ComputeBackendServicesListResponse =
        new operations.ComputeBackendServicesListResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.backendServiceList = utils.objectToClass(
              httpRes?.data,
              shared.BackendServiceList
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Patches the specified BackendService resource with the data included in the request. For more information, see Backend services overview. This method supports PATCH semantics and uses the JSON merge patch format and processing rules.
   */
  computeBackendServicesPatch(
    req: operations.ComputeBackendServicesPatchRequest,
    security: operations.ComputeBackendServicesPatchSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.ComputeBackendServicesPatchResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ComputeBackendServicesPatchRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/projects/{project}/global/backendServices/{backendService}",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "backendService1",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ComputeBackendServicesPatchSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "patch",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ComputeBackendServicesPatchResponse =
        new operations.ComputeBackendServicesPatchResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.operation = utils.objectToClass(
              httpRes?.data,
              shared.Operation
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Sets the edge security policy for the specified backend service.
   */
  computeBackendServicesSetEdgeSecurityPolicy(
    req: operations.ComputeBackendServicesSetEdgeSecurityPolicyRequest,
    security: operations.ComputeBackendServicesSetEdgeSecurityPolicySecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.ComputeBackendServicesSetEdgeSecurityPolicyResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ComputeBackendServicesSetEdgeSecurityPolicyRequest(
        req
      );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/projects/{project}/global/backendServices/{backendService}/setEdgeSecurityPolicy",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "securityPolicyReference",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.ComputeBackendServicesSetEdgeSecurityPolicySecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ComputeBackendServicesSetEdgeSecurityPolicyResponse =
        new operations.ComputeBackendServicesSetEdgeSecurityPolicyResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.operation = utils.objectToClass(
              httpRes?.data,
              shared.Operation
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Sets the access control policy on the specified resource. Replaces any existing policy.
   */
  computeBackendServicesSetIamPolicy(
    req: operations.ComputeBackendServicesSetIamPolicyRequest,
    security: operations.ComputeBackendServicesSetIamPolicySecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.ComputeBackendServicesSetIamPolicyResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ComputeBackendServicesSetIamPolicyRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/projects/{project}/global/backendServices/{resource}/setIamPolicy",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "globalSetPolicyRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ComputeBackendServicesSetIamPolicySecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ComputeBackendServicesSetIamPolicyResponse =
        new operations.ComputeBackendServicesSetIamPolicyResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.policy = utils.objectToClass(httpRes?.data, shared.Policy);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Sets the Google Cloud Armor security policy for the specified backend service. For more information, see Google Cloud Armor Overview
   */
  computeBackendServicesSetSecurityPolicy(
    req: operations.ComputeBackendServicesSetSecurityPolicyRequest,
    security: operations.ComputeBackendServicesSetSecurityPolicySecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.ComputeBackendServicesSetSecurityPolicyResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ComputeBackendServicesSetSecurityPolicyRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/projects/{project}/global/backendServices/{backendService}/setSecurityPolicy",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "securityPolicyReference",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ComputeBackendServicesSetSecurityPolicySecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ComputeBackendServicesSetSecurityPolicyResponse =
        new operations.ComputeBackendServicesSetSecurityPolicyResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.operation = utils.objectToClass(
              httpRes?.data,
              shared.Operation
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Updates the specified BackendService resource with the data included in the request. For more information, see Backend services overview.
   */
  computeBackendServicesUpdate(
    req: operations.ComputeBackendServicesUpdateRequest,
    security: operations.ComputeBackendServicesUpdateSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.ComputeBackendServicesUpdateResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ComputeBackendServicesUpdateRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/projects/{project}/global/backendServices/{backendService}",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "backendService1",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ComputeBackendServicesUpdateSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "put",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ComputeBackendServicesUpdateResponse =
        new operations.ComputeBackendServicesUpdateResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.operation = utils.objectToClass(
              httpRes?.data,
              shared.Operation
            );
          }
          break;
      }

      return res;
    });
  }
}
