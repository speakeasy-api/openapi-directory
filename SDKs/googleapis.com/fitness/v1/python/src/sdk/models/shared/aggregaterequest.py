"""Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT."""

from __future__ import annotations
import dataclasses
from ..shared import aggregateby as shared_aggregateby
from ..shared import bucketbyactivity as shared_bucketbyactivity
from ..shared import bucketbysession as shared_bucketbysession
from ..shared import bucketbytime as shared_bucketbytime
from dataclasses_json import Undefined, dataclass_json
from enum import Enum
from sdk import utils
from typing import Optional

class AggregateRequestFilteredDataQualityStandardEnum(str, Enum):
    DATA_QUALITY_UNKNOWN = 'dataQualityUnknown'
    DATA_QUALITY_BLOOD_PRESSURE_ESH2002 = 'dataQualityBloodPressureEsh2002'
    DATA_QUALITY_BLOOD_PRESSURE_ESH2010 = 'dataQualityBloodPressureEsh2010'
    DATA_QUALITY_BLOOD_PRESSURE_AAMI = 'dataQualityBloodPressureAami'
    DATA_QUALITY_BLOOD_PRESSURE_BHS_AA = 'dataQualityBloodPressureBhsAA'
    DATA_QUALITY_BLOOD_PRESSURE_BHS_AB = 'dataQualityBloodPressureBhsAB'
    DATA_QUALITY_BLOOD_PRESSURE_BHS_BA = 'dataQualityBloodPressureBhsBA'
    DATA_QUALITY_BLOOD_PRESSURE_BHS_BB = 'dataQualityBloodPressureBhsBB'
    DATA_QUALITY_BLOOD_GLUCOSE_ISO151972003 = 'dataQualityBloodGlucoseIso151972003'
    DATA_QUALITY_BLOOD_GLUCOSE_ISO151972013 = 'dataQualityBloodGlucoseIso151972013'


@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class AggregateRequest:
    r"""Next id: 10"""
    
    aggregate_by: Optional[list[shared_aggregateby.AggregateBy]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('aggregateBy'), 'exclude': lambda f: f is None }})
    r"""The specification of data to be aggregated. At least one aggregateBy spec must be provided. All data that is specified will be aggregated using the same bucketing criteria. There will be one dataset in the response for every aggregateBy spec."""  
    bucket_by_activity_segment: Optional[shared_bucketbyactivity.BucketByActivity] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('bucketByActivitySegment'), 'exclude': lambda f: f is None }})  
    bucket_by_activity_type: Optional[shared_bucketbyactivity.BucketByActivity] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('bucketByActivityType'), 'exclude': lambda f: f is None }})  
    bucket_by_session: Optional[shared_bucketbysession.BucketBySession] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('bucketBySession'), 'exclude': lambda f: f is None }})  
    bucket_by_time: Optional[shared_bucketbytime.BucketByTime] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('bucketByTime'), 'exclude': lambda f: f is None }})  
    end_time_millis: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('endTimeMillis'), 'exclude': lambda f: f is None }})
    r"""The end of a window of time. Data that intersects with this time window will be aggregated. The time is in milliseconds since epoch, inclusive. The maximum allowed difference between start_time_millis // and end_time_millis is 7776000000 (roughly 90 days)."""  
    filtered_data_quality_standard: Optional[list[AggregateRequestFilteredDataQualityStandardEnum]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('filteredDataQualityStandard'), 'exclude': lambda f: f is None }})
    r"""DO NOT POPULATE THIS FIELD. It is ignored."""  
    start_time_millis: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('startTimeMillis'), 'exclude': lambda f: f is None }})
    r"""The start of a window of time. Data that intersects with this time window will be aggregated. The time is in milliseconds since epoch, inclusive."""  
    