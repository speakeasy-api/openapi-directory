/*
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

import * as utils from "../internal/utils";
import * as operations from "./models/operations";
import * as shared from "./models/shared";
import { AxiosInstance, AxiosRequestConfig, AxiosResponse } from "axios";

export class Accounts {
  _defaultClient: AxiosInstance;
  _securityClient: AxiosInstance;
  _serverURL: string;
  _language: string;
  _sdkVersion: string;
  _genVersion: string;

  constructor(
    defaultClient: AxiosInstance,
    securityClient: AxiosInstance,
    serverURL: string,
    language: string,
    sdkVersion: string,
    genVersion: string
  ) {
    this._defaultClient = defaultClient;
    this._securityClient = securityClient;
    this._serverURL = serverURL;
    this._language = language;
    this._sdkVersion = sdkVersion;
    this._genVersion = genVersion;
  }

  /**
   * Creates an ad unit. This method can only be used by projects enabled for the [AdSense for Platforms](https://developers.google.com/adsense/platforms/) product. Note that ad units can only be created for ad clients with an "AFC" product code. For more info see the [AdClient resource](/adsense/management/reference/rest/v2/accounts.adclients). For now, this method can only be used to create `DISPLAY` ad units. See: https://support.google.com/adsense/answer/9183566
   */
  adsenseAccountsAdclientsAdunitsCreate(
    req: operations.AdsenseAccountsAdclientsAdunitsCreateRequest,
    security: operations.AdsenseAccountsAdclientsAdunitsCreateSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.AdsenseAccountsAdclientsAdunitsCreateResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.AdsenseAccountsAdclientsAdunitsCreateRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(baseURL, "/v2/{parent}/adunits", req);

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "adUnitInput",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.AdsenseAccountsAdclientsAdunitsCreateSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.AdsenseAccountsAdclientsAdunitsCreateResponse =
        new operations.AdsenseAccountsAdclientsAdunitsCreateResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.adUnit = utils.objectToClass(httpRes?.data, shared.AdUnit);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Gets the ad unit code for a given ad unit. For more information, see [About the AdSense code](https://support.google.com/adsense/answer/9274634) and [Where to place the ad code in your HTML](https://support.google.com/adsense/answer/9190028).
   */
  adsenseAccountsAdclientsAdunitsGetAdcode(
    req: operations.AdsenseAccountsAdclientsAdunitsGetAdcodeRequest,
    security: operations.AdsenseAccountsAdclientsAdunitsGetAdcodeSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.AdsenseAccountsAdclientsAdunitsGetAdcodeResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.AdsenseAccountsAdclientsAdunitsGetAdcodeRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(baseURL, "/v2/{name}/adcode", req);
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.AdsenseAccountsAdclientsAdunitsGetAdcodeSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.AdsenseAccountsAdclientsAdunitsGetAdcodeResponse =
        new operations.AdsenseAccountsAdclientsAdunitsGetAdcodeResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.adUnitAdCode = utils.objectToClass(
              httpRes?.data,
              shared.AdUnitAdCode
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Lists all ad units under a specified account and ad client.
   */
  adsenseAccountsAdclientsAdunitsList(
    req: operations.AdsenseAccountsAdclientsAdunitsListRequest,
    security: operations.AdsenseAccountsAdclientsAdunitsListSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.AdsenseAccountsAdclientsAdunitsListResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.AdsenseAccountsAdclientsAdunitsListRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(baseURL, "/v2/{parent}/adunits", req);
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.AdsenseAccountsAdclientsAdunitsListSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.AdsenseAccountsAdclientsAdunitsListResponse =
        new operations.AdsenseAccountsAdclientsAdunitsListResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listAdUnitsResponse = utils.objectToClass(
              httpRes?.data,
              shared.ListAdUnitsResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Lists all the custom channels available for an ad unit.
   */
  adsenseAccountsAdclientsAdunitsListLinkedCustomChannels(
    req: operations.AdsenseAccountsAdclientsAdunitsListLinkedCustomChannelsRequest,
    security: operations.AdsenseAccountsAdclientsAdunitsListLinkedCustomChannelsSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.AdsenseAccountsAdclientsAdunitsListLinkedCustomChannelsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.AdsenseAccountsAdclientsAdunitsListLinkedCustomChannelsRequest(
          req
        );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v2/{parent}:listLinkedCustomChannels",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.AdsenseAccountsAdclientsAdunitsListLinkedCustomChannelsSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.AdsenseAccountsAdclientsAdunitsListLinkedCustomChannelsResponse =
        new operations.AdsenseAccountsAdclientsAdunitsListLinkedCustomChannelsResponse(
          {
            statusCode: httpRes.status,
            contentType: contentType,
            rawResponse: httpRes,
          }
        );
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listLinkedCustomChannelsResponse = utils.objectToClass(
              httpRes?.data,
              shared.ListLinkedCustomChannelsResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Creates a custom channel. This method can only be used by projects enabled for the [AdSense for Platforms](https://developers.google.com/adsense/platforms/) product.
   */
  adsenseAccountsAdclientsCustomchannelsCreate(
    req: operations.AdsenseAccountsAdclientsCustomchannelsCreateRequest,
    security: operations.AdsenseAccountsAdclientsCustomchannelsCreateSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.AdsenseAccountsAdclientsCustomchannelsCreateResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.AdsenseAccountsAdclientsCustomchannelsCreateRequest(
        req
      );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v2/{parent}/customchannels",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "customChannelInput",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.AdsenseAccountsAdclientsCustomchannelsCreateSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.AdsenseAccountsAdclientsCustomchannelsCreateResponse =
        new operations.AdsenseAccountsAdclientsCustomchannelsCreateResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.customChannel = utils.objectToClass(
              httpRes?.data,
              shared.CustomChannel
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Deletes a custom channel. This method can only be used by projects enabled for the [AdSense for Platforms](https://developers.google.com/adsense/platforms/) product.
   */
  adsenseAccountsAdclientsCustomchannelsDelete(
    req: operations.AdsenseAccountsAdclientsCustomchannelsDeleteRequest,
    security: operations.AdsenseAccountsAdclientsCustomchannelsDeleteSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.AdsenseAccountsAdclientsCustomchannelsDeleteResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.AdsenseAccountsAdclientsCustomchannelsDeleteRequest(
        req
      );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(baseURL, "/v2/{name}", req);
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.AdsenseAccountsAdclientsCustomchannelsDeleteSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.AdsenseAccountsAdclientsCustomchannelsDeleteResponse =
        new operations.AdsenseAccountsAdclientsCustomchannelsDeleteResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.empty = utils.objectToClass(httpRes?.data);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Lists all the custom channels available in an ad client.
   */
  adsenseAccountsAdclientsCustomchannelsList(
    req: operations.AdsenseAccountsAdclientsCustomchannelsListRequest,
    security: operations.AdsenseAccountsAdclientsCustomchannelsListSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.AdsenseAccountsAdclientsCustomchannelsListResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.AdsenseAccountsAdclientsCustomchannelsListRequest(
        req
      );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v2/{parent}/customchannels",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.AdsenseAccountsAdclientsCustomchannelsListSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.AdsenseAccountsAdclientsCustomchannelsListResponse =
        new operations.AdsenseAccountsAdclientsCustomchannelsListResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listCustomChannelsResponse = utils.objectToClass(
              httpRes?.data,
              shared.ListCustomChannelsResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Lists all the ad units available for a custom channel.
   */
  adsenseAccountsAdclientsCustomchannelsListLinkedAdUnits(
    req: operations.AdsenseAccountsAdclientsCustomchannelsListLinkedAdUnitsRequest,
    security: operations.AdsenseAccountsAdclientsCustomchannelsListLinkedAdUnitsSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.AdsenseAccountsAdclientsCustomchannelsListLinkedAdUnitsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.AdsenseAccountsAdclientsCustomchannelsListLinkedAdUnitsRequest(
          req
        );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v2/{parent}:listLinkedAdUnits",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.AdsenseAccountsAdclientsCustomchannelsListLinkedAdUnitsSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.AdsenseAccountsAdclientsCustomchannelsListLinkedAdUnitsResponse =
        new operations.AdsenseAccountsAdclientsCustomchannelsListLinkedAdUnitsResponse(
          {
            statusCode: httpRes.status,
            contentType: contentType,
            rawResponse: httpRes,
          }
        );
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listLinkedAdUnitsResponse = utils.objectToClass(
              httpRes?.data,
              shared.ListLinkedAdUnitsResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Updates a custom channel. This method can only be used by projects enabled for the [AdSense for Platforms](https://developers.google.com/adsense/platforms/) product.
   */
  adsenseAccountsAdclientsCustomchannelsPatch(
    req: operations.AdsenseAccountsAdclientsCustomchannelsPatchRequest,
    security: operations.AdsenseAccountsAdclientsCustomchannelsPatchSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.AdsenseAccountsAdclientsCustomchannelsPatchResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.AdsenseAccountsAdclientsCustomchannelsPatchRequest(
        req
      );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(baseURL, "/v2/{name}", req);

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "customChannelInput",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.AdsenseAccountsAdclientsCustomchannelsPatchSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "patch",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.AdsenseAccountsAdclientsCustomchannelsPatchResponse =
        new operations.AdsenseAccountsAdclientsCustomchannelsPatchResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.customChannel = utils.objectToClass(
              httpRes?.data,
              shared.CustomChannel
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Lists all the ad clients available in an account.
   */
  adsenseAccountsAdclientsList(
    req: operations.AdsenseAccountsAdclientsListRequest,
    security: operations.AdsenseAccountsAdclientsListSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.AdsenseAccountsAdclientsListResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.AdsenseAccountsAdclientsListRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v2/{parent}/adclients",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.AdsenseAccountsAdclientsListSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.AdsenseAccountsAdclientsListResponse =
        new operations.AdsenseAccountsAdclientsListResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listAdClientsResponse = utils.objectToClass(
              httpRes?.data,
              shared.ListAdClientsResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Lists active url channels.
   */
  adsenseAccountsAdclientsUrlchannelsList(
    req: operations.AdsenseAccountsAdclientsUrlchannelsListRequest,
    security: operations.AdsenseAccountsAdclientsUrlchannelsListSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.AdsenseAccountsAdclientsUrlchannelsListResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.AdsenseAccountsAdclientsUrlchannelsListRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v2/{parent}/urlchannels",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.AdsenseAccountsAdclientsUrlchannelsListSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.AdsenseAccountsAdclientsUrlchannelsListResponse =
        new operations.AdsenseAccountsAdclientsUrlchannelsListResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listUrlChannelsResponse = utils.objectToClass(
              httpRes?.data,
              shared.ListUrlChannelsResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Lists all the alerts available in an account.
   */
  adsenseAccountsAlertsList(
    req: operations.AdsenseAccountsAlertsListRequest,
    security: operations.AdsenseAccountsAlertsListSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.AdsenseAccountsAlertsListResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.AdsenseAccountsAlertsListRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(baseURL, "/v2/{parent}/alerts", req);
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.AdsenseAccountsAlertsListSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.AdsenseAccountsAlertsListResponse =
        new operations.AdsenseAccountsAlertsListResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listAlertsResponse = utils.objectToClass(
              httpRes?.data,
              shared.ListAlertsResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Gets the ad blocking recovery tag of an account.
   */
  adsenseAccountsGetAdBlockingRecoveryTag(
    req: operations.AdsenseAccountsGetAdBlockingRecoveryTagRequest,
    security: operations.AdsenseAccountsGetAdBlockingRecoveryTagSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.AdsenseAccountsGetAdBlockingRecoveryTagResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.AdsenseAccountsGetAdBlockingRecoveryTagRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v2/{name}/adBlockingRecoveryTag",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.AdsenseAccountsGetAdBlockingRecoveryTagSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.AdsenseAccountsGetAdBlockingRecoveryTagResponse =
        new operations.AdsenseAccountsGetAdBlockingRecoveryTagResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.adBlockingRecoveryTag = utils.objectToClass(
              httpRes?.data,
              shared.AdBlockingRecoveryTag
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Lists all accounts available to this user.
   */
  adsenseAccountsList(
    req: operations.AdsenseAccountsListRequest,
    security: operations.AdsenseAccountsListSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.AdsenseAccountsListResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.AdsenseAccountsListRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/v2/accounts";
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.AdsenseAccountsListSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.AdsenseAccountsListResponse =
        new operations.AdsenseAccountsListResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listAccountsResponse = utils.objectToClass(
              httpRes?.data,
              shared.ListAccountsResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Lists all accounts directly managed by the given AdSense account.
   */
  adsenseAccountsListChildAccounts(
    req: operations.AdsenseAccountsListChildAccountsRequest,
    security: operations.AdsenseAccountsListChildAccountsSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.AdsenseAccountsListChildAccountsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.AdsenseAccountsListChildAccountsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v2/{parent}:listChildAccounts",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.AdsenseAccountsListChildAccountsSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.AdsenseAccountsListChildAccountsResponse =
        new operations.AdsenseAccountsListChildAccountsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listChildAccountsResponse = utils.objectToClass(
              httpRes?.data,
              shared.ListChildAccountsResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Lists all the payments available for an account.
   */
  adsenseAccountsPaymentsList(
    req: operations.AdsenseAccountsPaymentsListRequest,
    security: operations.AdsenseAccountsPaymentsListSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.AdsenseAccountsPaymentsListResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.AdsenseAccountsPaymentsListRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v2/{parent}/payments",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.AdsenseAccountsPaymentsListSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.AdsenseAccountsPaymentsListResponse =
        new operations.AdsenseAccountsPaymentsListResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listPaymentsResponse = utils.objectToClass(
              httpRes?.data,
              shared.ListPaymentsResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Generates an ad hoc report.
   */
  adsenseAccountsReportsGenerate(
    req: operations.AdsenseAccountsReportsGenerateRequest,
    security: operations.AdsenseAccountsReportsGenerateSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.AdsenseAccountsReportsGenerateResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.AdsenseAccountsReportsGenerateRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v2/{account}/reports:generate",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.AdsenseAccountsReportsGenerateSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.AdsenseAccountsReportsGenerateResponse =
        new operations.AdsenseAccountsReportsGenerateResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.reportResult = utils.objectToClass(
              httpRes?.data,
              shared.ReportResult
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Generates a csv formatted ad hoc report.
   */
  adsenseAccountsReportsGenerateCsv(
    req: operations.AdsenseAccountsReportsGenerateCsvRequest,
    security: operations.AdsenseAccountsReportsGenerateCsvSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.AdsenseAccountsReportsGenerateCsvResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.AdsenseAccountsReportsGenerateCsvRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v2/{account}/reports:generateCsv",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.AdsenseAccountsReportsGenerateCsvSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.AdsenseAccountsReportsGenerateCsvResponse =
        new operations.AdsenseAccountsReportsGenerateCsvResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.httpBody = utils.objectToClass(httpRes?.data, shared.HttpBody);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Gets the saved report from the given resource name.
   */
  adsenseAccountsReportsGetSaved(
    req: operations.AdsenseAccountsReportsGetSavedRequest,
    security: operations.AdsenseAccountsReportsGetSavedSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.AdsenseAccountsReportsGetSavedResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.AdsenseAccountsReportsGetSavedRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(baseURL, "/v2/{name}/saved", req);
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.AdsenseAccountsReportsGetSavedSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.AdsenseAccountsReportsGetSavedResponse =
        new operations.AdsenseAccountsReportsGetSavedResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.savedReport = utils.objectToClass(
              httpRes?.data,
              shared.SavedReport
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Generates a saved report.
   */
  adsenseAccountsReportsSavedGenerate(
    req: operations.AdsenseAccountsReportsSavedGenerateRequest,
    security: operations.AdsenseAccountsReportsSavedGenerateSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.AdsenseAccountsReportsSavedGenerateResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.AdsenseAccountsReportsSavedGenerateRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v2/{name}/saved:generate",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.AdsenseAccountsReportsSavedGenerateSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.AdsenseAccountsReportsSavedGenerateResponse =
        new operations.AdsenseAccountsReportsSavedGenerateResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.reportResult = utils.objectToClass(
              httpRes?.data,
              shared.ReportResult
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Generates a csv formatted saved report.
   */
  adsenseAccountsReportsSavedGenerateCsv(
    req: operations.AdsenseAccountsReportsSavedGenerateCsvRequest,
    security: operations.AdsenseAccountsReportsSavedGenerateCsvSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.AdsenseAccountsReportsSavedGenerateCsvResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.AdsenseAccountsReportsSavedGenerateCsvRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v2/{name}/saved:generateCsv",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.AdsenseAccountsReportsSavedGenerateCsvSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.AdsenseAccountsReportsSavedGenerateCsvResponse =
        new operations.AdsenseAccountsReportsSavedGenerateCsvResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.httpBody = utils.objectToClass(httpRes?.data, shared.HttpBody);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Lists saved reports.
   */
  adsenseAccountsReportsSavedList(
    req: operations.AdsenseAccountsReportsSavedListRequest,
    security: operations.AdsenseAccountsReportsSavedListSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.AdsenseAccountsReportsSavedListResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.AdsenseAccountsReportsSavedListRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v2/{parent}/reports/saved",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.AdsenseAccountsReportsSavedListSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.AdsenseAccountsReportsSavedListResponse =
        new operations.AdsenseAccountsReportsSavedListResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listSavedReportsResponse = utils.objectToClass(
              httpRes?.data,
              shared.ListSavedReportsResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Gets information about the selected site.
   */
  adsenseAccountsSitesGet(
    req: operations.AdsenseAccountsSitesGetRequest,
    security: operations.AdsenseAccountsSitesGetSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.AdsenseAccountsSitesGetResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.AdsenseAccountsSitesGetRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(baseURL, "/v2/{name}", req);
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.AdsenseAccountsSitesGetSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.AdsenseAccountsSitesGetResponse =
        new operations.AdsenseAccountsSitesGetResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.site = utils.objectToClass(httpRes?.data, shared.Site);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Lists all the sites available in an account.
   */
  adsenseAccountsSitesList(
    req: operations.AdsenseAccountsSitesListRequest,
    security: operations.AdsenseAccountsSitesListSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.AdsenseAccountsSitesListResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.AdsenseAccountsSitesListRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(baseURL, "/v2/{parent}/sites", req);
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.AdsenseAccountsSitesListSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.AdsenseAccountsSitesListResponse =
        new operations.AdsenseAccountsSitesListResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listSitesResponse = utils.objectToClass(
              httpRes?.data,
              shared.ListSitesResponse
            );
          }
          break;
      }

      return res;
    });
  }
}
