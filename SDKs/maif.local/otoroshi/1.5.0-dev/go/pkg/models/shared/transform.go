// Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.

package shared

import (
	"bytes"
	"encoding/json"
	"errors"
)

type TransformAlgoSettingsType string

const (
	TransformAlgoSettingsTypeHSAlgoSettings   TransformAlgoSettingsType = "HSAlgoSettings"
	TransformAlgoSettingsTypeRSAlgoSettings   TransformAlgoSettingsType = "RSAlgoSettings"
	TransformAlgoSettingsTypeESAlgoSettings   TransformAlgoSettingsType = "ESAlgoSettings"
	TransformAlgoSettingsTypeJWKSAlgoSettings TransformAlgoSettingsType = "JWKSAlgoSettings"
)

type TransformAlgoSettings struct {
	HSAlgoSettings   *HSAlgoSettings
	RSAlgoSettings   *RSAlgoSettings
	ESAlgoSettings   *ESAlgoSettings
	JWKSAlgoSettings *JWKSAlgoSettings

	Type TransformAlgoSettingsType
}

func CreateTransformAlgoSettingsHSAlgoSettings(hsAlgoSettings HSAlgoSettings) TransformAlgoSettings {
	typ := TransformAlgoSettingsTypeHSAlgoSettings

	return TransformAlgoSettings{
		HSAlgoSettings: &hsAlgoSettings,
		Type:           typ,
	}
}

func CreateTransformAlgoSettingsRSAlgoSettings(rsAlgoSettings RSAlgoSettings) TransformAlgoSettings {
	typ := TransformAlgoSettingsTypeRSAlgoSettings

	return TransformAlgoSettings{
		RSAlgoSettings: &rsAlgoSettings,
		Type:           typ,
	}
}

func CreateTransformAlgoSettingsESAlgoSettings(esAlgoSettings ESAlgoSettings) TransformAlgoSettings {
	typ := TransformAlgoSettingsTypeESAlgoSettings

	return TransformAlgoSettings{
		ESAlgoSettings: &esAlgoSettings,
		Type:           typ,
	}
}

func CreateTransformAlgoSettingsJWKSAlgoSettings(jwksAlgoSettings JWKSAlgoSettings) TransformAlgoSettings {
	typ := TransformAlgoSettingsTypeJWKSAlgoSettings

	return TransformAlgoSettings{
		JWKSAlgoSettings: &jwksAlgoSettings,
		Type:             typ,
	}
}

func (u *TransformAlgoSettings) UnmarshalJSON(data []byte) error {
	var d *json.Decoder

	hsAlgoSettings := new(HSAlgoSettings)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&hsAlgoSettings); err == nil {
		u.HSAlgoSettings = hsAlgoSettings
		u.Type = TransformAlgoSettingsTypeHSAlgoSettings
		return nil
	}

	rsAlgoSettings := new(RSAlgoSettings)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&rsAlgoSettings); err == nil {
		u.RSAlgoSettings = rsAlgoSettings
		u.Type = TransformAlgoSettingsTypeRSAlgoSettings
		return nil
	}

	esAlgoSettings := new(ESAlgoSettings)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&esAlgoSettings); err == nil {
		u.ESAlgoSettings = esAlgoSettings
		u.Type = TransformAlgoSettingsTypeESAlgoSettings
		return nil
	}

	jwksAlgoSettings := new(JWKSAlgoSettings)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&jwksAlgoSettings); err == nil {
		u.JWKSAlgoSettings = jwksAlgoSettings
		u.Type = TransformAlgoSettingsTypeJWKSAlgoSettings
		return nil
	}

	return errors.New("could not unmarshal into supported union types")
}

func (u TransformAlgoSettings) MarshalJSON() ([]byte, error) {
	if u.HSAlgoSettings != nil {
		return json.Marshal(u.HSAlgoSettings)
	}

	if u.RSAlgoSettings != nil {
		return json.Marshal(u.RSAlgoSettings)
	}

	if u.ESAlgoSettings != nil {
		return json.Marshal(u.ESAlgoSettings)
	}

	if u.JWKSAlgoSettings != nil {
		return json.Marshal(u.JWKSAlgoSettings)
	}

	return nil, nil
}

// Transform - Strategy where signature and field values are verified, trasnformed and then token si re-signed
type Transform struct {
	AlgoSettings TransformAlgoSettings `json:"algoSettings"`
	// Settings to transform a JWT token and its location
	TransformSettings *TransformSettings `json:"transformSettings,omitempty"`
	// String with value Transform
	Type string `json:"type"`
	// Settings to verify the value of JWT token fields
	VerificationSettings VerificationSettings `json:"verificationSettings"`
}
