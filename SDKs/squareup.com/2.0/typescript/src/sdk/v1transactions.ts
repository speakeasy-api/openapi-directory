/*
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

import * as utils from "../internal/utils";
import * as operations from "./models/operations";
import * as shared from "./models/shared";
import { AxiosInstance, AxiosRequestConfig, AxiosResponse } from "axios";

export class V1Transactions {
  _defaultClient: AxiosInstance;
  _securityClient: AxiosInstance;
  _serverURL: string;
  _language: string;
  _sdkVersion: string;
  _genVersion: string;

  constructor(
    defaultClient: AxiosInstance,
    securityClient: AxiosInstance,
    serverURL: string,
    language: string,
    sdkVersion: string,
    genVersion: string
  ) {
    this._defaultClient = defaultClient;
    this._securityClient = securityClient;
    this._serverURL = serverURL;
    this._language = language;
    this._sdkVersion = sdkVersion;
    this._genVersion = genVersion;
  }

  /**
   * CreateRefund
   *
   * @remarks
   * Issues a refund for a previously processed payment. You must issue
   * a refund within 60 days of the associated payment.
   *
   * You cannot issue a partial refund for a split tender payment. You must
   * instead issue a full or partial refund for a particular tender, by
   * providing the applicable tender id to the V1CreateRefund endpoint.
   * Issuing a full refund for a split tender payment refunds all tenders
   * associated with the payment.
   *
   * Issuing a refund for a card payment is not reversible. For development
   * purposes, you can create fake cash payments in Square Point of Sale and
   * refund them.
   */
  createRefund(
    req: operations.CreateRefundRequest,
    security: operations.CreateRefundSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.CreateRefundResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CreateRefundRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v1/{location_id}/refunds",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "v1CreateRefundRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.CreateRefundSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CreateRefundResponse =
        new operations.CreateRefundResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.v1Refund = utils.objectToClass(httpRes?.data, shared.V1Refund);
          }
          break;
      }

      return res;
    });
  }

  /**
   * ListOrders
   *
   * @remarks
   * Provides summary information for a merchant's online store orders.
   */
  listOrders(
    req: operations.ListOrdersRequest,
    security: operations.ListOrdersSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.ListOrdersResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ListOrdersRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v1/{location_id}/orders",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ListOrdersSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ListOrdersResponse =
        new operations.ListOrdersResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.v1Orders = [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.v1Orders = utils.objectToClass(
              httpRes?.data,
              shared.V1Order,
              resFieldDepth
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * ListPayments
   *
   * @remarks
   * Provides summary information for all payments taken for a given
   * Square account during a date range. Date ranges cannot exceed 1 year in
   * length. See Date ranges for details of inclusive and exclusive dates.
   *
   * *Note**: Details for payments processed with Square Point of Sale while
   * in offline mode may not be transmitted to Square for up to 72 hours.
   * Offline payments have a `created_at` value that reflects the time the
   * payment was originally processed, not the time it was subsequently
   * transmitted to Square. Consequently, the ListPayments endpoint might
   * list an offline payment chronologically between online payments that
   * were seen in a previous request.
   */
  listPayments(
    req: operations.ListPaymentsRequest,
    security: operations.ListPaymentsSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.ListPaymentsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ListPaymentsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v1/{location_id}/payments",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ListPaymentsSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ListPaymentsResponse =
        new operations.ListPaymentsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.v1Payments = [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.v1Payments = utils.objectToClass(
              httpRes?.data,
              shared.V1Payment,
              resFieldDepth
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * ListRefunds
   *
   * @remarks
   * Provides the details for all refunds initiated by a merchant or any of the merchant's mobile staff during a date range. Date ranges cannot exceed one year in length.
   */
  listRefunds(
    req: operations.ListRefundsRequest,
    security: operations.ListRefundsSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.ListRefundsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ListRefundsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v1/{location_id}/refunds",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ListRefundsSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ListRefundsResponse =
        new operations.ListRefundsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.v1Refunds = [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.v1Refunds = utils.objectToClass(
              httpRes?.data,
              shared.V1Refund,
              resFieldDepth
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * ListSettlements
   *
   * @remarks
   * Provides summary information for all deposits and withdrawals
   * initiated by Square to a linked bank account during a date range. Date
   * ranges cannot exceed one year in length.
   *
   * *Note**: the ListSettlements endpoint does not provide entry
   * information.
   */
  listSettlements(
    req: operations.ListSettlementsRequest,
    security: operations.ListSettlementsSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.ListSettlementsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ListSettlementsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v1/{location_id}/settlements",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ListSettlementsSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ListSettlementsResponse =
        new operations.ListSettlementsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.v1Settlements = [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.v1Settlements = utils.objectToClass(
              httpRes?.data,
              shared.V1Settlement,
              resFieldDepth
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * RetrieveOrder
   *
   * @remarks
   * Provides comprehensive information for a single online store order, including the order's history.
   */
  retrieveOrder(
    req: operations.RetrieveOrderRequest,
    security: operations.RetrieveOrderSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.RetrieveOrderResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.RetrieveOrderRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v1/{location_id}/orders/{order_id}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.RetrieveOrderSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.RetrieveOrderResponse =
        new operations.RetrieveOrderResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.v1Order = utils.objectToClass(httpRes?.data, shared.V1Order);
          }
          break;
      }

      return res;
    });
  }

  /**
   * RetrievePayment
   *
   * @remarks
   * Provides comprehensive information for a single payment.
   */
  retrievePayment(
    req: operations.RetrievePaymentRequest,
    security: operations.RetrievePaymentSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.RetrievePaymentResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.RetrievePaymentRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v1/{location_id}/payments/{payment_id}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.RetrievePaymentSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.RetrievePaymentResponse =
        new operations.RetrievePaymentResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.v1Payment = utils.objectToClass(
              httpRes?.data,
              shared.V1Payment
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * RetrieveSettlement
   *
   * @remarks
   * Provides comprehensive information for a single settlement.
   *
   * The returned `Settlement` objects include an `entries` field that lists
   * the transactions that contribute to the settlement total. Most
   * settlement entries correspond to a payment payout, but settlement
   * entries are also generated for less common events, like refunds, manual
   * adjustments, or chargeback holds.
   *
   * Square initiates its regular deposits as indicated in the
   * [Deposit Options with Square](https://squareup.com/help/us/en/article/3807)
   * help article. Details for a regular deposit are usually not available
   * from Connect API endpoints before 10 p.m. PST the same day.
   *
   * Square does not know when an initiated settlement **completes**, only
   * whether it has failed. A completed settlement is typically reflected in
   * a bank account within 3 business days, but in exceptional cases it may
   * take longer.
   */
  retrieveSettlement(
    req: operations.RetrieveSettlementRequest,
    security: operations.RetrieveSettlementSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.RetrieveSettlementResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.RetrieveSettlementRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v1/{location_id}/settlements/{settlement_id}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.RetrieveSettlementSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.RetrieveSettlementResponse =
        new operations.RetrieveSettlementResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.v1Settlement = utils.objectToClass(
              httpRes?.data,
              shared.V1Settlement
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * UpdateOrder
   *
   * @remarks
   * Updates the details of an online store order. Every update you perform on an order corresponds to one of three actions:
   */
  updateOrder(
    req: operations.UpdateOrderRequest,
    security: operations.UpdateOrderSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.UpdateOrderResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.UpdateOrderRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v1/{location_id}/orders/{order_id}",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "v1UpdateOrderRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.UpdateOrderSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "put",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UpdateOrderResponse =
        new operations.UpdateOrderResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.v1Order = utils.objectToClass(httpRes?.data, shared.V1Order);
          }
          break;
      }

      return res;
    });
  }
}
