<?php

/**
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

declare(strict_types=1);

namespace OpenAPI\OpenAPI;

class Refs 
{

	// SDK private variables namespaced with _ to avoid conflicts with API models
	private \GuzzleHttp\ClientInterface $_defaultClient;
	private \GuzzleHttp\ClientInterface $_securityClient;
	private string $_serverUrl;
	private string $_language;
	private string $_sdkVersion;
	private string $_genVersion;	

	/**
	 * @param \GuzzleHttp\ClientInterface $defaultClient
	 * @param \GuzzleHttp\ClientInterface $securityClient
	 * @param string $serverUrl
	 * @param string $language
	 * @param string $sdkVersion
	 * @param string $genVersion
	 */
	public function __construct(\GuzzleHttp\ClientInterface $defaultClient, \GuzzleHttp\ClientInterface $securityClient, string $serverUrl, string $language, string $sdkVersion, string $genVersion)
	{
		$this->_defaultClient = $defaultClient;
		$this->_securityClient = $securityClient;
		$this->_serverUrl = $serverUrl;
		$this->_language = $language;
		$this->_sdkVersion = $sdkVersion;
		$this->_genVersion = $genVersion;
	}
	
    /**
     * Delete a branch
     * 
     * Delete a branch in the specified repository.
     * 
     * The main branch is not allowed to be deleted and will return a 400
     * response.
     * 
     * The branch name should not include any prefixes (e.g.
     * refs/heads).
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\DeleteRepositoriesWorkspaceRepoSlugRefsBranchesNameRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\DeleteRepositoriesWorkspaceRepoSlugRefsBranchesNameSecurity $security
     * @return \OpenAPI\OpenAPI\Models\Operations\DeleteRepositoriesWorkspaceRepoSlugRefsBranchesNameResponse
     */
	public function deleteRepositoriesWorkspaceRepoSlugRefsBranchesName(
        \OpenAPI\OpenAPI\Models\Operations\DeleteRepositoriesWorkspaceRepoSlugRefsBranchesNameRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\DeleteRepositoriesWorkspaceRepoSlugRefsBranchesNameSecurity $security,
    ): \OpenAPI\OpenAPI\Models\Operations\DeleteRepositoriesWorkspaceRepoSlugRefsBranchesNameResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/repositories/{workspace}/{repo_slug}/refs/branches/{name}', \OpenAPI\OpenAPI\Models\Operations\DeleteRepositoriesWorkspaceRepoSlugRefsBranchesNameRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('DELETE', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\DeleteRepositoriesWorkspaceRepoSlugRefsBranchesNameResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 204) {
        }
        else if ($httpResponse->getStatusCode() === 403 or $httpResponse->getStatusCode() === 404) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->error = $serializer->deserialize((string)$httpResponse->getBody(), 'array<string, mixed>', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Delete a tag
     * 
     * Delete a tag in the specified repository.
     * 
     * The tag name should not include any prefixes (e.g. refs/tags).
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\DeleteRepositoriesWorkspaceRepoSlugRefsTagsNameRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\DeleteRepositoriesWorkspaceRepoSlugRefsTagsNameSecurity $security
     * @return \OpenAPI\OpenAPI\Models\Operations\DeleteRepositoriesWorkspaceRepoSlugRefsTagsNameResponse
     */
	public function deleteRepositoriesWorkspaceRepoSlugRefsTagsName(
        \OpenAPI\OpenAPI\Models\Operations\DeleteRepositoriesWorkspaceRepoSlugRefsTagsNameRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\DeleteRepositoriesWorkspaceRepoSlugRefsTagsNameSecurity $security,
    ): \OpenAPI\OpenAPI\Models\Operations\DeleteRepositoriesWorkspaceRepoSlugRefsTagsNameResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/repositories/{workspace}/{repo_slug}/refs/tags/{name}', \OpenAPI\OpenAPI\Models\Operations\DeleteRepositoriesWorkspaceRepoSlugRefsTagsNameRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('DELETE', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\DeleteRepositoriesWorkspaceRepoSlugRefsTagsNameResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 204) {
        }
        else if ($httpResponse->getStatusCode() === 403 or $httpResponse->getStatusCode() === 404) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->error = $serializer->deserialize((string)$httpResponse->getBody(), 'array<string, mixed>', 'json');
            }
        }

        return $response;
    }
	
    /**
     * List branches and tags
     * 
     * Returns the branches and tags in the repository.
     * 
     * By default, results will be in the order the underlying source control system returns them and identical to
     * the ordering one sees when running "$ git show-ref". Note that this follows simple
     * lexical ordering of the ref names.
     * 
     * This can be undesirable as it does apply any natural sorting semantics, meaning for instance that refs are
     * sorted ["branch1", "branch10", "branch2", "v10", "v11", "v9"] instead of ["branch1", "branch2",
     * "branch10", "v9", "v10", "v11"].
     * 
     * Sorting can be changed using the ?sort= query parameter. When using ?sort=name to explicitly sort on ref name,
     * Bitbucket will apply natural sorting and interpret numerical values as numbers instead of strings.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetRepositoriesWorkspaceRepoSlugRefsRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\GetRepositoriesWorkspaceRepoSlugRefsSecurity $security
     * @return \OpenAPI\OpenAPI\Models\Operations\GetRepositoriesWorkspaceRepoSlugRefsResponse
     */
	public function getRepositoriesWorkspaceRepoSlugRefs(
        \OpenAPI\OpenAPI\Models\Operations\GetRepositoriesWorkspaceRepoSlugRefsRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\GetRepositoriesWorkspaceRepoSlugRefsSecurity $security,
    ): \OpenAPI\OpenAPI\Models\Operations\GetRepositoriesWorkspaceRepoSlugRefsResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/repositories/{workspace}/{repo_slug}/refs', \OpenAPI\OpenAPI\Models\Operations\GetRepositoriesWorkspaceRepoSlugRefsRequest::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\GetRepositoriesWorkspaceRepoSlugRefsRequest::class, $request, null));
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetRepositoriesWorkspaceRepoSlugRefsResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->paginatedRefs = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\PaginatedRefs', 'json');
            }
        }
        else if ($httpResponse->getStatusCode() === 403 or $httpResponse->getStatusCode() === 404) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->error = $serializer->deserialize((string)$httpResponse->getBody(), 'array<string, mixed>', 'json');
            }
        }

        return $response;
    }
	
    /**
     * List open branches
     * 
     * Returns a list of all open branches within the specified repository.
     *         Results will be in the order the source control manager returns them.
     * 
     *         ```
     *         $ curl -s https://api.bitbucket.org/2.0/repositories/atlassian/aui/refs/branches?pagelen=1 | jq .
     *         {
     *           "pagelen": 1,
     *           "size": 187,
     *           "values": [
     *             {
     *               "name": "issue-9.3/AUI-5343-assistive-class",
     *               "links": {
     *                 "commits": {
     *                   "href": "https://api.bitbucket.org/2.0/repositories/atlassian/aui/commits/issue-9.3/AUI-5343-assistive-class"
     *                 },
     *                 "self": {
     *                   "href": "https://api.bitbucket.org/2.0/repositories/atlassian/aui/refs/branches/issue-9.3/AUI-5343-assistive-class"
     *                 },
     *                 "html": {
     *                   "href": "https://bitbucket.org/atlassian/aui/branch/issue-9.3/AUI-5343-assistive-class"
     *                 }
     *               },
     *               "default_merge_strategy": "squash",
     *               "merge_strategies": [
     *                 "merge_commit",
     *                 "squash",
     *                 "fast_forward"
     *               ],
     *               "type": "branch",
     *               "target": {
     *                 "hash": "e5d1cde9069fcb9f0af90403a4de2150c125a148",
     *                 "repository": {
     *                   "links": {
     *                     "self": {
     *                       "href": "https://api.bitbucket.org/2.0/repositories/atlassian/aui"
     *                     },
     *                     "html": {
     *                       "href": "https://bitbucket.org/atlassian/aui"
     *                     },
     *                     "avatar": {
     *                       "href": "https://bytebucket.org/ravatar/%7B585074de-7b60-4fd1-81ed-e0bc7fafbda5%7D?ts=86317"
     *                     }
     *                   },
     *                   "type": "repository",
     *                   "name": "aui",
     *                   "full_name": "atlassian/aui",
     *                   "uuid": "{585074de-7b60-4fd1-81ed-e0bc7fafbda5}"
     *                 },
     *                 "links": {
     *                   "self": {
     *                     "href": "https://api.bitbucket.org/2.0/repositories/atlassian/aui/commit/e5d1cde9069fcb9f0af90403a4de2150c125a148"
     *                   },
     *                   "comments": {
     *                     "href": "https://api.bitbucket.org/2.0/repositories/atlassian/aui/commit/e5d1cde9069fcb9f0af90403a4de2150c125a148/comments"
     *                   },
     *                   "patch": {
     *                     "href": "https://api.bitbucket.org/2.0/repositories/atlassian/aui/patch/e5d1cde9069fcb9f0af90403a4de2150c125a148"
     *                   },
     *                   "html": {
     *                     "href": "https://bitbucket.org/atlassian/aui/commits/e5d1cde9069fcb9f0af90403a4de2150c125a148"
     *                   },
     *                   "diff": {
     *                     "href": "https://api.bitbucket.org/2.0/repositories/atlassian/aui/diff/e5d1cde9069fcb9f0af90403a4de2150c125a148"
     *                   },
     *                   "approve": {
     *                     "href": "https://api.bitbucket.org/2.0/repositories/atlassian/aui/commit/e5d1cde9069fcb9f0af90403a4de2150c125a148/approve"
     *                   },
     *                   "statuses": {
     *                     "href": "https://api.bitbucket.org/2.0/repositories/atlassian/aui/commit/e5d1cde9069fcb9f0af90403a4de2150c125a148/statuses"
     *                   }
     *                 },
     *                 "author": {
     *                   "raw": "Marcin Konopka <mkonopka@atlassian.com>",
     *                   "type": "author",
     *                   "user": {
     *                     "display_name": "Marcin Konopka",
     *                     "uuid": "{47cc24f4-2a05-4420-88fe-0417535a110a}",
     *                     "links": {
     *                       "self": {
     *                         "href": "https://api.bitbucket.org/2.0/users/%7B47cc24f4-2a05-4420-88fe-0417535a110a%7D"
     *                       },
     *                       "html": {
     *                         "href": "https://bitbucket.org/%7B47cc24f4-2a05-4420-88fe-0417535a110a%7D/"
     *                       },
     *                       "avatar": {
     *                         "href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/initials/MK-1.png"
     *                       }
     *                     },
     *                     "nickname": "Marcin Konopka",
     *                     "type": "user",
     *                     "account_id": "60113d2b47a9540069f4de03"
     *                   }
     *                 },
     *                 "parents": [
     *                   {
     *                     "hash": "87f7fc92b00464ae47b13ef65c91884e4ac9be51",
     *                     "type": "commit",
     *                     "links": {
     *                       "self": {
     *                         "href": "https://api.bitbucket.org/2.0/repositories/atlassian/aui/commit/87f7fc92b00464ae47b13ef65c91884e4ac9be51"
     *                       },
     *                       "html": {
     *                         "href": "https://bitbucket.org/atlassian/aui/commits/87f7fc92b00464ae47b13ef65c91884e4ac9be51"
     *                       }
     *                     }
     *                   }
     *                 ],
     *                 "date": "2021-04-13T13:44:49+00:00",
     *                 "message": "wip
     * ",
     *                 "type": "commit"
     *               }
     *             }
     *           ],
     *           "page": 1,
     *           "next": "https://api.bitbucket.org/2.0/repositories/atlassian/aui/refs/branches?pagelen=1&page=2"
     *         }
     *         ```
     * 
     *         Branches support [filtering and sorting](/cloud/bitbucket/rest/intro/#filtering)
     *         that can be used to search for specific branches. For instance, to find
     *         all branches that have "stab" in their name:
     * 
     *         ```
     *         curl -s https://api.bitbucket.org/2.0/repositories/atlassian/aui/refs/branches -G --data-urlencode 'q=name ~ "stab"'
     *         ```
     * 
     *         By default, results will be in the order the underlying source control system returns them and identical to
     *         the ordering one sees when running "$ git branch --list". Note that this follows simple
     *         lexical ordering of the ref names.
     * 
     *         This can be undesirable as it does apply any natural sorting semantics, meaning for instance that tags are
     *         sorted ["v10", "v11", "v9"] instead of ["v9", "v10", "v11"].
     * 
     *         Sorting can be changed using the ?q= query parameter. When using ?q=name to explicitly sort on ref name,
     *         Bitbucket will apply natural sorting and interpret numerical values as numbers instead of strings.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetRepositoriesWorkspaceRepoSlugRefsBranchesRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\GetRepositoriesWorkspaceRepoSlugRefsBranchesSecurity $security
     * @return \OpenAPI\OpenAPI\Models\Operations\GetRepositoriesWorkspaceRepoSlugRefsBranchesResponse
     */
	public function getRepositoriesWorkspaceRepoSlugRefsBranches(
        \OpenAPI\OpenAPI\Models\Operations\GetRepositoriesWorkspaceRepoSlugRefsBranchesRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\GetRepositoriesWorkspaceRepoSlugRefsBranchesSecurity $security,
    ): \OpenAPI\OpenAPI\Models\Operations\GetRepositoriesWorkspaceRepoSlugRefsBranchesResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/repositories/{workspace}/{repo_slug}/refs/branches', \OpenAPI\OpenAPI\Models\Operations\GetRepositoriesWorkspaceRepoSlugRefsBranchesRequest::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\GetRepositoriesWorkspaceRepoSlugRefsBranchesRequest::class, $request, null));
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetRepositoriesWorkspaceRepoSlugRefsBranchesResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->paginatedBranches = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\PaginatedBranches', 'json');
            }
        }
        else if ($httpResponse->getStatusCode() === 403 or $httpResponse->getStatusCode() === 404) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->error = $serializer->deserialize((string)$httpResponse->getBody(), 'array<string, mixed>', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Get a branch
     * 
     * Returns a branch object within the specified repository.
     * 
     *         ```
     *         $ curl -s https://api.bitbucket.org/2.0/repositories/atlassian/aui/refs/branches/master | jq .
     *         {
     *           "name": "master",
     *           "links": {
     *             "commits": {
     *               "href": "https://api.bitbucket.org/2.0/repositories/atlassian/aui/commits/master"
     *             },
     *             "self": {
     *               "href": "https://api.bitbucket.org/2.0/repositories/atlassian/aui/refs/branches/master"
     *             },
     *             "html": {
     *               "href": "https://bitbucket.org/atlassian/aui/branch/master"
     *             }
     *           },
     *           "default_merge_strategy": "squash",
     *           "merge_strategies": [
     *             "merge_commit",
     *             "squash",
     *             "fast_forward"
     *           ],
     *           "type": "branch",
     *           "target": {
     *             "hash": "e7d158ff7ed5538c28f94cd97a9ad569680fc94e",
     *             "repository": {
     *               "links": {
     *                 "self": {
     *                   "href": "https://api.bitbucket.org/2.0/repositories/atlassian/aui"
     *                 },
     *                 "html": {
     *                   "href": "https://bitbucket.org/atlassian/aui"
     *                 },
     *                 "avatar": {
     *                   "href": "https://bytebucket.org/ravatar/%7B585074de-7b60-4fd1-81ed-e0bc7fafbda5%7D?ts=86317"
     *                 }
     *               },
     *               "type": "repository",
     *               "name": "aui",
     *               "full_name": "atlassian/aui",
     *               "uuid": "{585074de-7b60-4fd1-81ed-e0bc7fafbda5}"
     *             },
     *             "links": {
     *               "self": {
     *                 "href": "https://api.bitbucket.org/2.0/repositories/atlassian/aui/commit/e7d158ff7ed5538c28f94cd97a9ad569680fc94e"
     *               },
     *               "comments": {
     *                 "href": "https://api.bitbucket.org/2.0/repositories/atlassian/aui/commit/e7d158ff7ed5538c28f94cd97a9ad569680fc94e/comments"
     *               },
     *               "patch": {
     *                 "href": "https://api.bitbucket.org/2.0/repositories/atlassian/aui/patch/e7d158ff7ed5538c28f94cd97a9ad569680fc94e"
     *               },
     *               "html": {
     *                 "href": "https://bitbucket.org/atlassian/aui/commits/e7d158ff7ed5538c28f94cd97a9ad569680fc94e"
     *               },
     *               "diff": {
     *                 "href": "https://api.bitbucket.org/2.0/repositories/atlassian/aui/diff/e7d158ff7ed5538c28f94cd97a9ad569680fc94e"
     *               },
     *               "approve": {
     *                 "href": "https://api.bitbucket.org/2.0/repositories/atlassian/aui/commit/e7d158ff7ed5538c28f94cd97a9ad569680fc94e/approve"
     *               },
     *               "statuses": {
     *                 "href": "https://api.bitbucket.org/2.0/repositories/atlassian/aui/commit/e7d158ff7ed5538c28f94cd97a9ad569680fc94e/statuses"
     *               }
     *             },
     *             "author": {
     *               "raw": "psre-renovate-bot <psre-renovate-bot@atlassian.com>",
     *               "type": "author",
     *               "user": {
     *                 "display_name": "psre-renovate-bot",
     *                 "uuid": "{250a442a-3ab3-4fcb-87c3-3c8f3df65ec7}",
     *                 "links": {
     *                   "self": {
     *                     "href": "https://api.bitbucket.org/2.0/users/%7B250a442a-3ab3-4fcb-87c3-3c8f3df65ec7%7D"
     *                   },
     *                   "html": {
     *                     "href": "https://bitbucket.org/%7B250a442a-3ab3-4fcb-87c3-3c8f3df65ec7%7D/"
     *                   },
     *                   "avatar": {
     *                     "href": "https://secure.gravatar.com/avatar/6972ee037c9f36360170a86f544071a2?d=https%3A%2F%2Favatar-management--avatars.us-west-2.prod.public.atl-paas.net%2Finitials%2FP-3.png"
     *                   }
     *                 },
     *                 "nickname": "Renovate Bot",
     *                 "type": "user",
     *                 "account_id": "5d5355e8c6b9320d9ea5b28d"
     *               }
     *             },
     *             "parents": [
     *               {
     *                 "hash": "eab868a309e75733de80969a7bed1ec6d4651e06",
     *                 "type": "commit",
     *                 "links": {
     *                   "self": {
     *                     "href": "https://api.bitbucket.org/2.0/repositories/atlassian/aui/commit/eab868a309e75733de80969a7bed1ec6d4651e06"
     *                   },
     *                   "html": {
     *                     "href": "https://bitbucket.org/atlassian/aui/commits/eab868a309e75733de80969a7bed1ec6d4651e06"
     *                   }
     *                 }
     *               }
     *             ],
     *             "date": "2021-04-12T06:44:38+00:00",
     *             "message": "Merged in issue/NONE-renovate-master-babel-monorepo (pull request #2883)
     * 
     * chore(deps): update babel monorepo to v7.13.15 (master)
     * 
     * Approved-by: Chris "Daz" Darroch
     * ",
     *             "type": "commit"
     *           }
     *         }
     *         ```
     * 
     *         This call requires authentication. Private repositories require the
     *         caller to authenticate with an account that has appropriate
     *         authorization.
     * 
     *         For Git, the branch name should not include any prefixes (e.g.
     *         refs/heads).
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetRepositoriesWorkspaceRepoSlugRefsBranchesNameRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\GetRepositoriesWorkspaceRepoSlugRefsBranchesNameSecurity $security
     * @return \OpenAPI\OpenAPI\Models\Operations\GetRepositoriesWorkspaceRepoSlugRefsBranchesNameResponse
     */
	public function getRepositoriesWorkspaceRepoSlugRefsBranchesName(
        \OpenAPI\OpenAPI\Models\Operations\GetRepositoriesWorkspaceRepoSlugRefsBranchesNameRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\GetRepositoriesWorkspaceRepoSlugRefsBranchesNameSecurity $security,
    ): \OpenAPI\OpenAPI\Models\Operations\GetRepositoriesWorkspaceRepoSlugRefsBranchesNameResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/repositories/{workspace}/{repo_slug}/refs/branches/{name}', \OpenAPI\OpenAPI\Models\Operations\GetRepositoriesWorkspaceRepoSlugRefsBranchesNameRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetRepositoriesWorkspaceRepoSlugRefsBranchesNameResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->branch = $serializer->deserialize((string)$httpResponse->getBody(), 'array<string, mixed>', 'json');
            }
        }
        else if ($httpResponse->getStatusCode() === 403 or $httpResponse->getStatusCode() === 404) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->error = $serializer->deserialize((string)$httpResponse->getBody(), 'array<string, mixed>', 'json');
            }
        }

        return $response;
    }
	
    /**
     * List tags
     * 
     * Returns the tags in the repository.
     * 
     * By default, results will be in the order the underlying source control system returns them and identical to
     * the ordering one sees when running "$ git tag --list". Note that this follows simple
     * lexical ordering of the ref names.
     * 
     * This can be undesirable as it does apply any natural sorting semantics, meaning for instance that tags are
     * sorted ["v10", "v11", "v9"] instead of ["v9", "v10", "v11"].
     * 
     * Sorting can be changed using the ?sort= query parameter. When using ?sort=name to explicitly sort on ref name,
     * Bitbucket will apply natural sorting and interpret numerical values as numbers instead of strings.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetRepositoriesWorkspaceRepoSlugRefsTagsRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\GetRepositoriesWorkspaceRepoSlugRefsTagsSecurity $security
     * @return \OpenAPI\OpenAPI\Models\Operations\GetRepositoriesWorkspaceRepoSlugRefsTagsResponse
     */
	public function getRepositoriesWorkspaceRepoSlugRefsTags(
        \OpenAPI\OpenAPI\Models\Operations\GetRepositoriesWorkspaceRepoSlugRefsTagsRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\GetRepositoriesWorkspaceRepoSlugRefsTagsSecurity $security,
    ): \OpenAPI\OpenAPI\Models\Operations\GetRepositoriesWorkspaceRepoSlugRefsTagsResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/repositories/{workspace}/{repo_slug}/refs/tags', \OpenAPI\OpenAPI\Models\Operations\GetRepositoriesWorkspaceRepoSlugRefsTagsRequest::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\GetRepositoriesWorkspaceRepoSlugRefsTagsRequest::class, $request, null));
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetRepositoriesWorkspaceRepoSlugRefsTagsResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->paginatedTags = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\PaginatedTags', 'json');
            }
        }
        else if ($httpResponse->getStatusCode() === 403 or $httpResponse->getStatusCode() === 404) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->error = $serializer->deserialize((string)$httpResponse->getBody(), 'array<string, mixed>', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Get a tag
     * 
     * Returns the specified tag.
     * 
     * ```
     * $ curl -s https://api.bitbucket.org/2.0/repositories/seanfarley/hg/refs/tags/3.8 -G | jq .
     * {
     *   "name": "3.8",
     *   "links": {
     *     "commits": {
     *       "href": "https://api.bitbucket.org/2.0/repositories/seanfarley/hg/commits/3.8"
     *     },
     *     "self": {
     *       "href": "https://api.bitbucket.org/2.0/repositories/seanfarley/hg/refs/tags/3.8"
     *     },
     *     "html": {
     *       "href": "https://bitbucket.org/seanfarley/hg/commits/tag/3.8"
     *     }
     *   },
     *   "tagger": {
     *     "raw": "Matt Mackall <mpm@selenic.com>",
     *     "type": "author",
     *     "user": {
     *       "username": "mpmselenic",
     *       "nickname": "mpmselenic",
     *       "display_name": "Matt Mackall",
     *       "type": "user",
     *       "uuid": "{a4934530-db4c-419c-a478-9ab4964c2ee7}",
     *       "links": {
     *         "self": {
     *           "href": "https://api.bitbucket.org/2.0/users/mpmselenic"
     *         },
     *         "html": {
     *           "href": "https://bitbucket.org/mpmselenic/"
     *         },
     *         "avatar": {
     *           "href": "https://bitbucket.org/account/mpmselenic/avatar/32/"
     *         }
     *       }
     *     }
     *   },
     *   "date": "2016-05-01T18:52:25+00:00",
     *   "message": "Added tag 3.8 for changeset f85de28eae32",
     *   "type": "tag",
     *   "target": {
     *     "hash": "f85de28eae32e7d3064b1a1321309071bbaaa069",
     *     "repository": {
     *       "links": {
     *         "self": {
     *           "href": "https://api.bitbucket.org/2.0/repositories/seanfarley/hg"
     *         },
     *         "html": {
     *           "href": "https://bitbucket.org/seanfarley/hg"
     *         },
     *         "avatar": {
     *           "href": "https://bitbucket.org/seanfarley/hg/avatar/32/"
     *         }
     *       },
     *       "type": "repository",
     *       "name": "hg",
     *       "full_name": "seanfarley/hg",
     *       "uuid": "{c75687fb-e99d-4579-9087-190dbd406d30}"
     *     },
     *     "links": {
     *       "self": {
     *         "href": "https://api.bitbucket.org/2.0/repositories/seanfarley/hg/commit/f85de28eae32e7d3064b1a1321309071bbaaa069"
     *       },
     *       "comments": {
     *         "href": "https://api.bitbucket.org/2.0/repositories/seanfarley/hg/commit/f85de28eae32e7d3064b1a1321309071bbaaa069/comments"
     *       },
     *       "patch": {
     *         "href": "https://api.bitbucket.org/2.0/repositories/seanfarley/hg/patch/f85de28eae32e7d3064b1a1321309071bbaaa069"
     *       },
     *       "html": {
     *         "href": "https://bitbucket.org/seanfarley/hg/commits/f85de28eae32e7d3064b1a1321309071bbaaa069"
     *       },
     *       "diff": {
     *         "href": "https://api.bitbucket.org/2.0/repositories/seanfarley/hg/diff/f85de28eae32e7d3064b1a1321309071bbaaa069"
     *       },
     *       "approve": {
     *         "href": "https://api.bitbucket.org/2.0/repositories/seanfarley/hg/commit/f85de28eae32e7d3064b1a1321309071bbaaa069/approve"
     *       },
     *       "statuses": {
     *         "href": "https://api.bitbucket.org/2.0/repositories/seanfarley/hg/commit/f85de28eae32e7d3064b1a1321309071bbaaa069/statuses"
     *       }
     *     },
     *     "author": {
     *       "raw": "Sean Farley <sean@farley.io>",
     *       "type": "author",
     *       "user": {
     *         "username": "seanfarley",
     *         "nickname": "seanfarley",
     *         "display_name": "Sean Farley",
     *         "type": "user",
     *         "uuid": "{a295f8a8-5876-4d43-89b5-3ad8c6c3c51d}",
     *         "links": {
     *           "self": {
     *             "href": "https://api.bitbucket.org/2.0/users/seanfarley"
     *           },
     *           "html": {
     *             "href": "https://bitbucket.org/seanfarley/"
     *           },
     *           "avatar": {
     *             "href": "https://bitbucket.org/account/seanfarley/avatar/32/"
     *           }
     *         }
     *       }
     *     },
     *     "parents": [
     *       {
     *         "hash": "9a98d0e5b07fc60887f9d3d34d9ac7d536f470d2",
     *         "type": "commit",
     *         "links": {
     *           "self": {
     *             "href": "https://api.bitbucket.org/2.0/repositories/seanfarley/hg/commit/9a98d0e5b07fc60887f9d3d34d9ac7d536f470d2"
     *           },
     *           "html": {
     *             "href": "https://bitbucket.org/seanfarley/hg/commits/9a98d0e5b07fc60887f9d3d34d9ac7d536f470d2"
     *           }
     *         }
     *       }
     *     ],
     *     "date": "2016-05-01T04:21:17+00:00",
     *     "message": "debian: alphabetize build deps",
     *     "type": "commit"
     *   }
     * }
     * ```
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetRepositoriesWorkspaceRepoSlugRefsTagsNameRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\GetRepositoriesWorkspaceRepoSlugRefsTagsNameSecurity $security
     * @return \OpenAPI\OpenAPI\Models\Operations\GetRepositoriesWorkspaceRepoSlugRefsTagsNameResponse
     */
	public function getRepositoriesWorkspaceRepoSlugRefsTagsName(
        \OpenAPI\OpenAPI\Models\Operations\GetRepositoriesWorkspaceRepoSlugRefsTagsNameRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\GetRepositoriesWorkspaceRepoSlugRefsTagsNameSecurity $security,
    ): \OpenAPI\OpenAPI\Models\Operations\GetRepositoriesWorkspaceRepoSlugRefsTagsNameResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/repositories/{workspace}/{repo_slug}/refs/tags/{name}', \OpenAPI\OpenAPI\Models\Operations\GetRepositoriesWorkspaceRepoSlugRefsTagsNameRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetRepositoriesWorkspaceRepoSlugRefsTagsNameResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->tag = $serializer->deserialize((string)$httpResponse->getBody(), 'array<string, mixed>', 'json');
            }
        }
        else if ($httpResponse->getStatusCode() === 403 or $httpResponse->getStatusCode() === 404) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->error = $serializer->deserialize((string)$httpResponse->getBody(), 'array<string, mixed>', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Create a branch
     * 
     * Creates a new branch in the specified repository.
     * 
     * The payload of the POST should consist of a JSON document that
     * contains the name of the tag and the target hash.
     * 
     * ```
     * curl https://api.bitbucket.org/2.0/repositories/seanfarley/hg/refs/branches \
     * -s -u seanfarley -X POST -H "Content-Type: application/json" \
     * -d '{
     *     "name" : "smf/create-feature",
     *     "target" : {
     *         "hash" : "default",
     *     }
     * }'
     * ```
     * 
     * This call requires authentication. Private repositories require the
     * caller to authenticate with an account that has appropriate
     * authorization.
     * 
     * The branch name should not include any prefixes (e.g.
     * refs/heads). This endpoint does support using short hash prefixes for
     * the commit hash, but it may return a 400 response if the provided
     * prefix is ambiguous. Using a full commit hash is the preferred
     * approach.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\PostRepositoriesWorkspaceRepoSlugRefsBranchesRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\PostRepositoriesWorkspaceRepoSlugRefsBranchesSecurity $security
     * @return \OpenAPI\OpenAPI\Models\Operations\PostRepositoriesWorkspaceRepoSlugRefsBranchesResponse
     */
	public function postRepositoriesWorkspaceRepoSlugRefsBranches(
        \OpenAPI\OpenAPI\Models\Operations\PostRepositoriesWorkspaceRepoSlugRefsBranchesRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\PostRepositoriesWorkspaceRepoSlugRefsBranchesSecurity $security,
    ): \OpenAPI\OpenAPI\Models\Operations\PostRepositoriesWorkspaceRepoSlugRefsBranchesResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/repositories/{workspace}/{repo_slug}/refs/branches', \OpenAPI\OpenAPI\Models\Operations\PostRepositoriesWorkspaceRepoSlugRefsBranchesRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\PostRepositoriesWorkspaceRepoSlugRefsBranchesResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 201) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->branch = $serializer->deserialize((string)$httpResponse->getBody(), 'array<string, mixed>', 'json');
            }
        }
        else if ($httpResponse->getStatusCode() === 403 or $httpResponse->getStatusCode() === 404) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->error = $serializer->deserialize((string)$httpResponse->getBody(), 'array<string, mixed>', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Create a tag
     * 
     * Creates a new tag in the specified repository.
     * 
     * The payload of the POST should consist of a JSON document that
     * contains the name of the tag and the target hash.
     * 
     * ```
     * curl https://api.bitbucket.org/2.0/repositories/jdoe/myrepo/refs/tags \
     * -s -u jdoe -X POST -H "Content-Type: application/json" \
     * -d '{
     *     "name" : "new-tag-name",
     *     "target" : {
     *         "hash" : "a1b2c3d4e5f6",
     *     }
     * }'
     * ```
     * 
     * This endpoint does support using short hash prefixes for the commit
     * hash, but it may return a 400 response if the provided prefix is
     * ambiguous. Using a full commit hash is the preferred approach.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\PostRepositoriesWorkspaceRepoSlugRefsTagsRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\PostRepositoriesWorkspaceRepoSlugRefsTagsSecurity $security
     * @return \OpenAPI\OpenAPI\Models\Operations\PostRepositoriesWorkspaceRepoSlugRefsTagsResponse
     */
	public function postRepositoriesWorkspaceRepoSlugRefsTags(
        \OpenAPI\OpenAPI\Models\Operations\PostRepositoriesWorkspaceRepoSlugRefsTagsRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\PostRepositoriesWorkspaceRepoSlugRefsTagsSecurity $security,
    ): \OpenAPI\OpenAPI\Models\Operations\PostRepositoriesWorkspaceRepoSlugRefsTagsResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/repositories/{workspace}/{repo_slug}/refs/tags', \OpenAPI\OpenAPI\Models\Operations\PostRepositoriesWorkspaceRepoSlugRefsTagsRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "requestBody", "json");
        if ($body === null) {
            throw new \Exception('Request body is required');
        }
        $options = array_merge_recursive($options, $body);
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\PostRepositoriesWorkspaceRepoSlugRefsTagsResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 201) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->tag = $serializer->deserialize((string)$httpResponse->getBody(), 'array<string, mixed>', 'json');
            }
        }
        else if ($httpResponse->getStatusCode() === 400) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->error = $serializer->deserialize((string)$httpResponse->getBody(), 'array<string, mixed>', 'json');
            }
        }

        return $response;
    }
}