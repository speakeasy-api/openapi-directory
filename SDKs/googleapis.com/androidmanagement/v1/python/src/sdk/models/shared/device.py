"""Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT."""

from __future__ import annotations
import dataclasses
from ..shared import applicationreport as shared_applicationreport
from ..shared import commoncriteriamodeinfo as shared_commoncriteriamodeinfo
from ..shared import devicesettings as shared_devicesettings
from ..shared import display as shared_display
from ..shared import hardwareinfo as shared_hardwareinfo
from ..shared import hardwarestatus as shared_hardwarestatus
from ..shared import memoryevent as shared_memoryevent
from ..shared import memoryinfo as shared_memoryinfo
from ..shared import networkinfo as shared_networkinfo
from ..shared import noncompliancedetail as shared_noncompliancedetail
from ..shared import passwordrequirements as shared_passwordrequirements
from ..shared import powermanagementevent as shared_powermanagementevent
from ..shared import securityposture as shared_securityposture
from ..shared import softwareinfo as shared_softwareinfo
from ..shared import user as shared_user
from ..shared import userfacingmessage as shared_userfacingmessage
from dataclasses_json import Undefined, dataclass_json
from enum import Enum
from sdk import utils
from typing import Optional

class DeviceAppliedStateEnum(str, Enum):
    r"""The state currently applied to the device."""
    DEVICE_STATE_UNSPECIFIED = 'DEVICE_STATE_UNSPECIFIED'
    ACTIVE = 'ACTIVE'
    DISABLED = 'DISABLED'
    DELETED = 'DELETED'
    PROVISIONING = 'PROVISIONING'

class DeviceManagementModeEnum(str, Enum):
    r"""The type of management mode Android Device Policy takes on the device. This influences which policy settings are supported."""
    MANAGEMENT_MODE_UNSPECIFIED = 'MANAGEMENT_MODE_UNSPECIFIED'
    DEVICE_OWNER = 'DEVICE_OWNER'
    PROFILE_OWNER = 'PROFILE_OWNER'

class DeviceOwnershipEnum(str, Enum):
    r"""Ownership of the managed device."""
    OWNERSHIP_UNSPECIFIED = 'OWNERSHIP_UNSPECIFIED'
    COMPANY_OWNED = 'COMPANY_OWNED'
    PERSONALLY_OWNED = 'PERSONALLY_OWNED'

class DeviceStateEnum(str, Enum):
    r"""The state to be applied to the device. This field can be modified by a patch request. Note that when calling enterprises.devices.patch, ACTIVE and DISABLED are the only allowable values. To enter the device into a DELETED state, call enterprises.devices.delete."""
    DEVICE_STATE_UNSPECIFIED = 'DEVICE_STATE_UNSPECIFIED'
    ACTIVE = 'ACTIVE'
    DISABLED = 'DISABLED'
    DELETED = 'DELETED'
    PROVISIONING = 'PROVISIONING'


@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class Device:
    r"""A device owned by an enterprise. Unless otherwise noted, all fields are read-only and can't be modified by enterprises.devices.patch."""
    
    api_level: Optional[int] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('apiLevel'), 'exclude': lambda f: f is None }})
    r"""The API level of the Android platform version running on the device."""  
    application_reports: Optional[list[shared_applicationreport.ApplicationReport]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('applicationReports'), 'exclude': lambda f: f is None }})
    r"""Reports for apps installed on the device. This information is only available when application_reports_enabled is true in the device's policy."""  
    applied_password_policies: Optional[list[shared_passwordrequirements.PasswordRequirements]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('appliedPasswordPolicies'), 'exclude': lambda f: f is None }})
    r"""The password requirements currently applied to the device. The applied requirements may be slightly different from those specified in passwordPolicies in some cases. fieldPath is set based on passwordPolicies."""  
    applied_policy_name: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('appliedPolicyName'), 'exclude': lambda f: f is None }})
    r"""The name of the policy currently applied to the device."""  
    applied_policy_version: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('appliedPolicyVersion'), 'exclude': lambda f: f is None }})
    r"""The version of the policy currently applied to the device."""  
    applied_state: Optional[DeviceAppliedStateEnum] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('appliedState'), 'exclude': lambda f: f is None }})
    r"""The state currently applied to the device."""  
    common_criteria_mode_info: Optional[shared_commoncriteriamodeinfo.CommonCriteriaModeInfo] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('commonCriteriaModeInfo'), 'exclude': lambda f: f is None }})
    r"""Information about Common Criteria Modeâ€”security standards defined in the Common Criteria for Information Technology Security Evaluation (https://www.commoncriteriaportal.org/) (CC).This information is only available if statusReportingSettings.commonCriteriaModeEnabled is true in the device's policy."""  
    device_settings: Optional[shared_devicesettings.DeviceSettings] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('deviceSettings'), 'exclude': lambda f: f is None }})
    r"""Information about security related device settings on device."""  
    disabled_reason: Optional[shared_userfacingmessage.UserFacingMessage] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('disabledReason'), 'exclude': lambda f: f is None }})
    r"""Provides a user-facing message with locale info. The maximum message length is 4096 characters."""  
    displays: Optional[list[shared_display.Display]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('displays'), 'exclude': lambda f: f is None }})
    r"""Detailed information about displays on the device. This information is only available if displayInfoEnabled is true in the device's policy."""  
    enrollment_time: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('enrollmentTime'), 'exclude': lambda f: f is None }})
    r"""The time of device enrollment."""  
    enrollment_token_data: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('enrollmentTokenData'), 'exclude': lambda f: f is None }})
    r"""If the device was enrolled with an enrollment token with additional data provided, this field contains that data."""  
    enrollment_token_name: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('enrollmentTokenName'), 'exclude': lambda f: f is None }})
    r"""If the device was enrolled with an enrollment token, this field contains the name of the token."""  
    hardware_info: Optional[shared_hardwareinfo.HardwareInfo] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('hardwareInfo'), 'exclude': lambda f: f is None }})
    r"""Information about device hardware. The fields related to temperature thresholds are only available if hardwareStatusEnabled is true in the device's policy."""  
    hardware_status_samples: Optional[list[shared_hardwarestatus.HardwareStatus]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('hardwareStatusSamples'), 'exclude': lambda f: f is None }})
    r"""Hardware status samples in chronological order. This information is only available if hardwareStatusEnabled is true in the device's policy."""  
    last_policy_compliance_report_time: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('lastPolicyComplianceReportTime'), 'exclude': lambda f: f is None }})
    r"""Deprecated."""  
    last_policy_sync_time: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('lastPolicySyncTime'), 'exclude': lambda f: f is None }})
    r"""The last time the device fetched its policy."""  
    last_status_report_time: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('lastStatusReportTime'), 'exclude': lambda f: f is None }})
    r"""The last time the device sent a status report."""  
    management_mode: Optional[DeviceManagementModeEnum] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('managementMode'), 'exclude': lambda f: f is None }})
    r"""The type of management mode Android Device Policy takes on the device. This influences which policy settings are supported."""  
    memory_events: Optional[list[shared_memoryevent.MemoryEvent]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('memoryEvents'), 'exclude': lambda f: f is None }})
    r"""Events related to memory and storage measurements in chronological order. This information is only available if memoryInfoEnabled is true in the device's policy."""  
    memory_info: Optional[shared_memoryinfo.MemoryInfo] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('memoryInfo'), 'exclude': lambda f: f is None }})
    r"""Information about device memory and storage."""  
    name: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('name'), 'exclude': lambda f: f is None }})
    r"""The name of the device in the form enterprises/{enterpriseId}/devices/{deviceId}."""  
    network_info: Optional[shared_networkinfo.NetworkInfo] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('networkInfo'), 'exclude': lambda f: f is None }})
    r"""Device network info."""  
    non_compliance_details: Optional[list[shared_noncompliancedetail.NonComplianceDetail]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('nonComplianceDetails'), 'exclude': lambda f: f is None }})
    r"""Details about policy settings that the device is not compliant with."""  
    ownership: Optional[DeviceOwnershipEnum] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('ownership'), 'exclude': lambda f: f is None }})
    r"""Ownership of the managed device."""  
    policy_compliant: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('policyCompliant'), 'exclude': lambda f: f is None }})
    r"""Whether the device is compliant with its policy."""  
    policy_name: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('policyName'), 'exclude': lambda f: f is None }})
    r"""The name of the policy applied to the device, in the form enterprises/{enterpriseId}/policies/{policyId}. If not specified, the policy_name for the device's user is applied. This field can be modified by a patch request. You can specify only the policyId when calling enterprises.devices.patch, as long as the policyId doesnâ€™t contain any slashes. The rest of the policy name is inferred."""  
    power_management_events: Optional[list[shared_powermanagementevent.PowerManagementEvent]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('powerManagementEvents'), 'exclude': lambda f: f is None }})
    r"""Power management events on the device in chronological order. This information is only available if powerManagementEventsEnabled is true in the device's policy."""  
    previous_device_names: Optional[list[str]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('previousDeviceNames'), 'exclude': lambda f: f is None }})
    r"""If the same physical device has been enrolled multiple times, this field contains its previous device names. The serial number is used as the unique identifier to determine if the same physical device has enrolled previously. The names are in chronological order."""  
    security_posture: Optional[shared_securityposture.SecurityPosture] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('securityPosture'), 'exclude': lambda f: f is None }})
    r"""The security posture of the device, as determined by the current device state and the policies applied."""  
    software_info: Optional[shared_softwareinfo.SoftwareInfo] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('softwareInfo'), 'exclude': lambda f: f is None }})
    r"""Information about device software."""  
    state: Optional[DeviceStateEnum] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('state'), 'exclude': lambda f: f is None }})
    r"""The state to be applied to the device. This field can be modified by a patch request. Note that when calling enterprises.devices.patch, ACTIVE and DISABLED are the only allowable values. To enter the device into a DELETED state, call enterprises.devices.delete."""  
    system_properties: Optional[dict[str, str]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('systemProperties'), 'exclude': lambda f: f is None }})
    r"""Map of selected system properties name and value related to the device. This information is only available if systemPropertiesEnabled is true in the device's policy."""  
    user: Optional[shared_user.User] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('user'), 'exclude': lambda f: f is None }})
    r"""A user belonging to an enterprise."""  
    user_name: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('userName'), 'exclude': lambda f: f is None }})
    r"""The resource name of the user that owns this device in the form enterprises/{enterpriseId}/users/{userId}."""  
    