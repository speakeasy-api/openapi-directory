/*
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

import * as utils from "../internal/utils";
import * as operations from "./models/operations";
import * as shared from "./models/shared";
import { AxiosInstance, AxiosRequestConfig, AxiosResponse } from "axios";

/**
 * Findings are security issues found during scans.
 *
 * @remarks
 * We try hard to present valid findings only. We give as much information
 * as possible to help you know exactly what to do, without having to
 * resort to outside resources.
 *
 * Findings come with all the data we gathered during the scan, a
 * suggestion on how to fix it, and a description of the vulnerability.
 *
 */
export class Findings {
  _defaultClient: AxiosInstance;
  _securityClient: AxiosInstance;
  _serverURL: string;
  _language: string;
  _sdkVersion: string;
  _genVersion: string;

  constructor(
    defaultClient: AxiosInstance,
    securityClient: AxiosInstance,
    serverURL: string,
    language: string,
    sdkVersion: string,
    genVersion: string
  ) {
    this._defaultClient = defaultClient;
    this._securityClient = securityClient;
    this._serverURL = serverURL;
    this._language = language;
    this._sdkVersion = sdkVersion;
    this._genVersion = genVersion;
  }

  /**
   * List target findings
   */
  getTargetsTargetIdFindings(
    req: operations.GetTargetsTargetIdFindingsRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetTargetsTargetIdFindingsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetTargetsTargetIdFindingsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/targets/{target_id}/findings/",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetTargetsTargetIdFindingsResponse =
        new operations.GetTargetsTargetIdFindingsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getTargetsTargetIdFindings200ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.GetTargetsTargetIdFindings200ApplicationJSON
              );
          }
          break;
        case httpRes?.status == 401:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getTargetsTargetIdFindings401ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.GetTargetsTargetIdFindings401ApplicationJSON
              );
          }
          break;
        case httpRes?.status == 404:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getTargetsTargetIdFindings404ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.GetTargetsTargetIdFindings404ApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Retrieve finding report PDF format
   */
  getTargetsTargetIdFindingsReport(
    req: operations.GetTargetsTargetIdFindingsReportRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetTargetsTargetIdFindingsReportResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetTargetsTargetIdFindingsReportRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/targets/{target_id}/findings/report/",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetTargetsTargetIdFindingsReportResponse =
        new operations.GetTargetsTargetIdFindingsReportResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/pdf`)) {
            const resBody: string = JSON.stringify(httpRes?.data, null, 0);
            const out: Uint8Array = new Uint8Array(resBody.length);
            for (let i = 0; i < resBody.length; i++)
              out[i] = resBody.charCodeAt(i);
            res.getTargetsTargetIdFindingsReport200ApplicationPdfBinaryString =
              out;
          }
          break;
        case httpRes?.status == 400:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getTargetsTargetIdFindingsReport400ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.GetTargetsTargetIdFindingsReport400ApplicationJSON
              );
          }
          break;
        case httpRes?.status == 401:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getTargetsTargetIdFindingsReport401ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.GetTargetsTargetIdFindingsReport401ApplicationJSON
              );
          }
          break;
        case httpRes?.status == 404:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getTargetsTargetIdFindingsReport404ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.GetTargetsTargetIdFindingsReport404ApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Retrieve finding
   */
  getTargetsTargetIdFindingsId(
    req: operations.GetTargetsTargetIdFindingsIdRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetTargetsTargetIdFindingsIdResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetTargetsTargetIdFindingsIdRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/targets/{target_id}/findings/{id}/",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetTargetsTargetIdFindingsIdResponse =
        new operations.GetTargetsTargetIdFindingsIdResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.finding = utils.objectToClass(httpRes?.data, shared.Finding);
          }
          break;
        case httpRes?.status == 401:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getTargetsTargetIdFindingsId401ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.GetTargetsTargetIdFindingsId401ApplicationJSON
              );
          }
          break;
        case httpRes?.status == 404:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getTargetsTargetIdFindingsId404ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.GetTargetsTargetIdFindingsId404ApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Finding activity log.
   *
   * @remarks
   * Finding activity log.
   */
  getTargetsTargetIdFindingsIdLog(
    req: operations.GetTargetsTargetIdFindingsIdLogRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetTargetsTargetIdFindingsIdLogResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetTargetsTargetIdFindingsIdLogRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/targets/{target_id}/findings/{id}/log/",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetTargetsTargetIdFindingsIdLogResponse =
        new operations.GetTargetsTargetIdFindingsIdLogResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.activities = [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.activities = utils.objectToClass(
              httpRes?.data,
              shared.Activity,
              resFieldDepth
            );
          }
          break;
        case httpRes?.status == 401:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getTargetsTargetIdFindingsIdLog401ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.GetTargetsTargetIdFindingsIdLog401ApplicationJSON
              );
          }
          break;
        case httpRes?.status == 404:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getTargetsTargetIdFindingsIdLog404ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.GetTargetsTargetIdFindingsIdLog404ApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Bulk update findings
   */
  patchTargetsTargetIdFindingsBulkUpdate(
    req: operations.PatchTargetsTargetIdFindingsBulkUpdateRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.PatchTargetsTargetIdFindingsBulkUpdateResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PatchTargetsTargetIdFindingsBulkUpdateRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/targets/{target_id}/findings/bulk/update/",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "findingBulkUpdateInput",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "patch",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PatchTargetsTargetIdFindingsBulkUpdateResponse =
        new operations.PatchTargetsTargetIdFindingsBulkUpdateResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          break;
        case httpRes?.status == 400:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.patchTargetsTargetIdFindingsBulkUpdate400ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.PatchTargetsTargetIdFindingsBulkUpdate400ApplicationJSON
              );
          }
          break;
        case httpRes?.status == 401:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.patchTargetsTargetIdFindingsBulkUpdate401ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.PatchTargetsTargetIdFindingsBulkUpdate401ApplicationJSON
              );
          }
          break;
        case httpRes?.status == 404:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.patchTargetsTargetIdFindingsBulkUpdate404ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.PatchTargetsTargetIdFindingsBulkUpdate404ApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Partial update finding
   */
  patchTargetsTargetIdFindingsId(
    req: operations.PatchTargetsTargetIdFindingsIdRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.PatchTargetsTargetIdFindingsIdResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PatchTargetsTargetIdFindingsIdRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/targets/{target_id}/findings/{id}/",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "findingUpdateInput",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "patch",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PatchTargetsTargetIdFindingsIdResponse =
        new operations.PatchTargetsTargetIdFindingsIdResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.finding = utils.objectToClass(httpRes?.data, shared.Finding);
          }
          break;
        case httpRes?.status == 400:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.patchTargetsTargetIdFindingsId400ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.PatchTargetsTargetIdFindingsId400ApplicationJSON
              );
          }
          break;
        case httpRes?.status == 401:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.patchTargetsTargetIdFindingsId401ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.PatchTargetsTargetIdFindingsId401ApplicationJSON
              );
          }
          break;
        case httpRes?.status == 403:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.patchTargetsTargetIdFindingsId403ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.PatchTargetsTargetIdFindingsId403ApplicationJSON
              );
          }
          break;
        case httpRes?.status == 404:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.patchTargetsTargetIdFindingsId404ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.PatchTargetsTargetIdFindingsId404ApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Finding report
   */
  postTargetsTargetIdFindingsBulkReport(
    req: operations.PostTargetsTargetIdFindingsBulkReportRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.PostTargetsTargetIdFindingsBulkReportResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PostTargetsTargetIdFindingsBulkReportRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/targets/{target_id}/findings/bulk/report/",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "findingBulkIds",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PostTargetsTargetIdFindingsBulkReportResponse =
        new operations.PostTargetsTargetIdFindingsBulkReportResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          break;
        case httpRes?.status == 400:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.postTargetsTargetIdFindingsBulkReport400ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.PostTargetsTargetIdFindingsBulkReport400ApplicationJSON
              );
          }
          break;
        case httpRes?.status == 401:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.postTargetsTargetIdFindingsBulkReport401ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.PostTargetsTargetIdFindingsBulkReport401ApplicationJSON
              );
          }
          break;
        case httpRes?.status == 404:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.postTargetsTargetIdFindingsBulkReport404ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.PostTargetsTargetIdFindingsBulkReport404ApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Bulk retest findings
   */
  postTargetsTargetIdFindingsBulkRetest(
    req: operations.PostTargetsTargetIdFindingsBulkRetestRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.PostTargetsTargetIdFindingsBulkRetestResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PostTargetsTargetIdFindingsBulkRetestRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/targets/{target_id}/findings/bulk/retest/",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "findingBulkRetest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PostTargetsTargetIdFindingsBulkRetestResponse =
        new operations.PostTargetsTargetIdFindingsBulkRetestResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          break;
        case httpRes?.status == 400:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.postTargetsTargetIdFindingsBulkRetest400ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.PostTargetsTargetIdFindingsBulkRetest400ApplicationJSON
              );
          }
          break;
        case httpRes?.status == 401:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.postTargetsTargetIdFindingsBulkRetest401ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.PostTargetsTargetIdFindingsBulkRetest401ApplicationJSON
              );
          }
          break;
        case httpRes?.status == 404:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.postTargetsTargetIdFindingsBulkRetest404ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.PostTargetsTargetIdFindingsBulkRetest404ApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Retest finding
   */
  postTargetsTargetIdFindingsIdRetest(
    req: operations.PostTargetsTargetIdFindingsIdRetestRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.PostTargetsTargetIdFindingsIdRetestResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PostTargetsTargetIdFindingsIdRetestRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/targets/{target_id}/findings/{id}/retest/",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "post",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PostTargetsTargetIdFindingsIdRetestResponse =
        new operations.PostTargetsTargetIdFindingsIdRetestResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.scan = utils.objectToClass(httpRes?.data, shared.Scan);
          }
          break;
        case httpRes?.status == 401:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.postTargetsTargetIdFindingsIdRetest401ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.PostTargetsTargetIdFindingsIdRetest401ApplicationJSON
              );
          }
          break;
        case httpRes?.status == 403:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.postTargetsTargetIdFindingsIdRetest403ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.PostTargetsTargetIdFindingsIdRetest403ApplicationJSON
              );
          }
          break;
        case httpRes?.status == 404:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.postTargetsTargetIdFindingsIdRetest404ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.PostTargetsTargetIdFindingsIdRetest404ApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Update finding
   */
  putTargetsTargetIdFindingsId(
    req: operations.PutTargetsTargetIdFindingsIdRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.PutTargetsTargetIdFindingsIdResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PutTargetsTargetIdFindingsIdRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/targets/{target_id}/findings/{id}/",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "findingUpdateInput",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "put",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PutTargetsTargetIdFindingsIdResponse =
        new operations.PutTargetsTargetIdFindingsIdResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.finding = utils.objectToClass(httpRes?.data, shared.Finding);
          }
          break;
        case httpRes?.status == 400:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.putTargetsTargetIdFindingsId400ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.PutTargetsTargetIdFindingsId400ApplicationJSON
              );
          }
          break;
        case httpRes?.status == 401:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.putTargetsTargetIdFindingsId401ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.PutTargetsTargetIdFindingsId401ApplicationJSON
              );
          }
          break;
        case httpRes?.status == 403:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.putTargetsTargetIdFindingsId403ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.PutTargetsTargetIdFindingsId403ApplicationJSON
              );
          }
          break;
        case httpRes?.status == 404:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.putTargetsTargetIdFindingsId404ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.PutTargetsTargetIdFindingsId404ApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }
}
