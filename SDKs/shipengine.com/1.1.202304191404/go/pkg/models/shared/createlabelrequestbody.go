// Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.

package shared

import (
	"encoding/json"
	"fmt"
	"time"
)

// CreateLabelRequestBodyDisplaySchemeEnum - The display format that the label should be shown in.
type CreateLabelRequestBodyDisplaySchemeEnum string

const (
	CreateLabelRequestBodyDisplaySchemeEnumLabel          CreateLabelRequestBodyDisplaySchemeEnum = "label"
	CreateLabelRequestBodyDisplaySchemeEnumQrCode         CreateLabelRequestBodyDisplaySchemeEnum = "qr_code"
	CreateLabelRequestBodyDisplaySchemeEnumLabelAndQrCode CreateLabelRequestBodyDisplaySchemeEnum = "label_and_qr_code"
)

func (e CreateLabelRequestBodyDisplaySchemeEnum) ToPointer() *CreateLabelRequestBodyDisplaySchemeEnum {
	return &e
}

func (e *CreateLabelRequestBodyDisplaySchemeEnum) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "label":
		fallthrough
	case "qr_code":
		fallthrough
	case "label_and_qr_code":
		*e = CreateLabelRequestBodyDisplaySchemeEnum(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CreateLabelRequestBodyDisplaySchemeEnum: %v", v)
	}
}

// CreateLabelRequestBodyLabelDownloadTypeEnum - There are two different ways to [download a label](https://www.shipengine.com/docs/labels/downloading/):
//
// |Label Download Type | Description
// |--------------------|------------------------------
// |`url`               |You will receive a URL, which you can use to download the label in a separate request. The URL will remain valid for 90 days.<br><br>This is the default if `label_download_type` is unspecified.
// |`inline`            |You will receive the Base64-encoded label as part of the response. No need for a second request to download the label.
type CreateLabelRequestBodyLabelDownloadTypeEnum string

const (
	CreateLabelRequestBodyLabelDownloadTypeEnumURL    CreateLabelRequestBodyLabelDownloadTypeEnum = "url"
	CreateLabelRequestBodyLabelDownloadTypeEnumInline CreateLabelRequestBodyLabelDownloadTypeEnum = "inline"
)

func (e CreateLabelRequestBodyLabelDownloadTypeEnum) ToPointer() *CreateLabelRequestBodyLabelDownloadTypeEnum {
	return &e
}

func (e *CreateLabelRequestBodyLabelDownloadTypeEnum) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "url":
		fallthrough
	case "inline":
		*e = CreateLabelRequestBodyLabelDownloadTypeEnum(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CreateLabelRequestBodyLabelDownloadTypeEnum: %v", v)
	}
}

// CreateLabelRequestBodyLabelFormatEnum - The possible file formats in which shipping labels can be downloaded.  We recommend `pdf` format because it is supported by all carriers, whereas some carriers do not support the `png` or `zpl` formats.
//
// |Label Format  | Supported Carriers
// |--------------|-----------------------------------
// |`pdf`         | All carriers
// |`png`         | `fedex` <br> `stamps_com` <br> `ups` <br> `usps`
// |`zpl`         | `access_worldwide` <br> `apc` <br> `asendia` <br> `dhl_global_mail` <br> `dhl_express` <br> `dhl_express_australia` <br> `dhl_express_canada` <br> `dhl_express_worldwide` <br> `dhl_express_uk` <br> `dpd` <br> `endicia` <br> `fedex` <br> `fedex_uk` <br> `firstmile` <br> `imex` <br> `newgistics` <br> `ontrac` <br> `rr_donnelley` <br> `stamps_com` <br> `ups` <br> `usps`
type CreateLabelRequestBodyLabelFormatEnum string

const (
	CreateLabelRequestBodyLabelFormatEnumPdf CreateLabelRequestBodyLabelFormatEnum = "pdf"
	CreateLabelRequestBodyLabelFormatEnumPng CreateLabelRequestBodyLabelFormatEnum = "png"
	CreateLabelRequestBodyLabelFormatEnumZpl CreateLabelRequestBodyLabelFormatEnum = "zpl"
)

func (e CreateLabelRequestBodyLabelFormatEnum) ToPointer() *CreateLabelRequestBodyLabelFormatEnum {
	return &e
}

func (e *CreateLabelRequestBodyLabelFormatEnum) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "pdf":
		fallthrough
	case "png":
		fallthrough
	case "zpl":
		*e = CreateLabelRequestBodyLabelFormatEnum(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CreateLabelRequestBodyLabelFormatEnum: %v", v)
	}
}

// CreateLabelRequestBodyLabelLayoutEnum - The available layouts (sizes) in which shipping labels can be downloaded.  The label format determines which sizes are supported.  `4x6` is supported for all label formats, whereas `letter` (8.5" x 11") is only supported for `pdf` format.
type CreateLabelRequestBodyLabelLayoutEnum string

const (
	CreateLabelRequestBodyLabelLayoutEnumFourx6 CreateLabelRequestBodyLabelLayoutEnum = "4x6"
	CreateLabelRequestBodyLabelLayoutEnumLetter CreateLabelRequestBodyLabelLayoutEnum = "letter"
)

func (e CreateLabelRequestBodyLabelLayoutEnum) ToPointer() *CreateLabelRequestBodyLabelLayoutEnum {
	return &e
}

func (e *CreateLabelRequestBodyLabelLayoutEnum) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "4x6":
		fallthrough
	case "letter":
		*e = CreateLabelRequestBodyLabelLayoutEnum(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CreateLabelRequestBodyLabelLayoutEnum: %v", v)
	}
}

// CreateLabelRequestBodyPartialShipmentDeliveryConfirmationEnum - The possible delivery confirmation values
type CreateLabelRequestBodyPartialShipmentDeliveryConfirmationEnum string

const (
	CreateLabelRequestBodyPartialShipmentDeliveryConfirmationEnumNone               CreateLabelRequestBodyPartialShipmentDeliveryConfirmationEnum = "none"
	CreateLabelRequestBodyPartialShipmentDeliveryConfirmationEnumDelivery           CreateLabelRequestBodyPartialShipmentDeliveryConfirmationEnum = "delivery"
	CreateLabelRequestBodyPartialShipmentDeliveryConfirmationEnumSignature          CreateLabelRequestBodyPartialShipmentDeliveryConfirmationEnum = "signature"
	CreateLabelRequestBodyPartialShipmentDeliveryConfirmationEnumAdultSignature     CreateLabelRequestBodyPartialShipmentDeliveryConfirmationEnum = "adult_signature"
	CreateLabelRequestBodyPartialShipmentDeliveryConfirmationEnumDirectSignature    CreateLabelRequestBodyPartialShipmentDeliveryConfirmationEnum = "direct_signature"
	CreateLabelRequestBodyPartialShipmentDeliveryConfirmationEnumDeliveryMailed     CreateLabelRequestBodyPartialShipmentDeliveryConfirmationEnum = "delivery_mailed"
	CreateLabelRequestBodyPartialShipmentDeliveryConfirmationEnumVerbalConfirmation CreateLabelRequestBodyPartialShipmentDeliveryConfirmationEnum = "verbal_confirmation"
)

func (e CreateLabelRequestBodyPartialShipmentDeliveryConfirmationEnum) ToPointer() *CreateLabelRequestBodyPartialShipmentDeliveryConfirmationEnum {
	return &e
}

func (e *CreateLabelRequestBodyPartialShipmentDeliveryConfirmationEnum) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "none":
		fallthrough
	case "delivery":
		fallthrough
	case "signature":
		fallthrough
	case "adult_signature":
		fallthrough
	case "direct_signature":
		fallthrough
	case "delivery_mailed":
		fallthrough
	case "verbal_confirmation":
		*e = CreateLabelRequestBodyPartialShipmentDeliveryConfirmationEnum(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CreateLabelRequestBodyPartialShipmentDeliveryConfirmationEnum: %v", v)
	}
}

// CreateLabelRequestBodyPartialShipmentInternationalShipmentOptionsPackageContentsEnum - The possible package contents values
type CreateLabelRequestBodyPartialShipmentInternationalShipmentOptionsPackageContentsEnum string

const (
	CreateLabelRequestBodyPartialShipmentInternationalShipmentOptionsPackageContentsEnumMerchandise   CreateLabelRequestBodyPartialShipmentInternationalShipmentOptionsPackageContentsEnum = "merchandise"
	CreateLabelRequestBodyPartialShipmentInternationalShipmentOptionsPackageContentsEnumDocuments     CreateLabelRequestBodyPartialShipmentInternationalShipmentOptionsPackageContentsEnum = "documents"
	CreateLabelRequestBodyPartialShipmentInternationalShipmentOptionsPackageContentsEnumGift          CreateLabelRequestBodyPartialShipmentInternationalShipmentOptionsPackageContentsEnum = "gift"
	CreateLabelRequestBodyPartialShipmentInternationalShipmentOptionsPackageContentsEnumReturnedGoods CreateLabelRequestBodyPartialShipmentInternationalShipmentOptionsPackageContentsEnum = "returned_goods"
	CreateLabelRequestBodyPartialShipmentInternationalShipmentOptionsPackageContentsEnumSample        CreateLabelRequestBodyPartialShipmentInternationalShipmentOptionsPackageContentsEnum = "sample"
)

func (e CreateLabelRequestBodyPartialShipmentInternationalShipmentOptionsPackageContentsEnum) ToPointer() *CreateLabelRequestBodyPartialShipmentInternationalShipmentOptionsPackageContentsEnum {
	return &e
}

func (e *CreateLabelRequestBodyPartialShipmentInternationalShipmentOptionsPackageContentsEnum) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "merchandise":
		fallthrough
	case "documents":
		fallthrough
	case "gift":
		fallthrough
	case "returned_goods":
		fallthrough
	case "sample":
		*e = CreateLabelRequestBodyPartialShipmentInternationalShipmentOptionsPackageContentsEnum(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CreateLabelRequestBodyPartialShipmentInternationalShipmentOptionsPackageContentsEnum: %v", v)
	}
}

// CreateLabelRequestBodyPartialShipmentInternationalShipmentOptionsNonDeliveryEnum - The possible non delivery values
type CreateLabelRequestBodyPartialShipmentInternationalShipmentOptionsNonDeliveryEnum string

const (
	CreateLabelRequestBodyPartialShipmentInternationalShipmentOptionsNonDeliveryEnumReturnToSender   CreateLabelRequestBodyPartialShipmentInternationalShipmentOptionsNonDeliveryEnum = "return_to_sender"
	CreateLabelRequestBodyPartialShipmentInternationalShipmentOptionsNonDeliveryEnumTreatAsAbandoned CreateLabelRequestBodyPartialShipmentInternationalShipmentOptionsNonDeliveryEnum = "treat_as_abandoned"
)

func (e CreateLabelRequestBodyPartialShipmentInternationalShipmentOptionsNonDeliveryEnum) ToPointer() *CreateLabelRequestBodyPartialShipmentInternationalShipmentOptionsNonDeliveryEnum {
	return &e
}

func (e *CreateLabelRequestBodyPartialShipmentInternationalShipmentOptionsNonDeliveryEnum) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "return_to_sender":
		fallthrough
	case "treat_as_abandoned":
		*e = CreateLabelRequestBodyPartialShipmentInternationalShipmentOptionsNonDeliveryEnum(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CreateLabelRequestBodyPartialShipmentInternationalShipmentOptionsNonDeliveryEnum: %v", v)
	}
}

// CreateLabelRequestBodyPartialShipmentInternationalShipmentOptionsInput - Options for international shipments, such as customs declarations.
type CreateLabelRequestBodyPartialShipmentInternationalShipmentOptionsInput struct {
	// The type of contents in this shipment.  This may impact import duties or customs treatment.
	Contents CreateLabelRequestBodyPartialShipmentInternationalShipmentOptionsPackageContentsEnum `json:"contents"`
	// Customs declarations for each item in the shipment.
	CustomsItems []CustomsItemInput `json:"customs_items,omitempty"`
	// Indicates what to do if a package is unable to be delivered.
	NonDelivery CreateLabelRequestBodyPartialShipmentInternationalShipmentOptionsNonDeliveryEnum `json:"non_delivery"`
}

// CreateLabelRequestBodyPartialShipmentInsuranceProviderEnum - The possible insurance provider values
type CreateLabelRequestBodyPartialShipmentInsuranceProviderEnum string

const (
	CreateLabelRequestBodyPartialShipmentInsuranceProviderEnumNone        CreateLabelRequestBodyPartialShipmentInsuranceProviderEnum = "none"
	CreateLabelRequestBodyPartialShipmentInsuranceProviderEnumShipsurance CreateLabelRequestBodyPartialShipmentInsuranceProviderEnum = "shipsurance"
	CreateLabelRequestBodyPartialShipmentInsuranceProviderEnumCarrier     CreateLabelRequestBodyPartialShipmentInsuranceProviderEnum = "carrier"
	CreateLabelRequestBodyPartialShipmentInsuranceProviderEnumThirdParty  CreateLabelRequestBodyPartialShipmentInsuranceProviderEnum = "third_party"
)

func (e CreateLabelRequestBodyPartialShipmentInsuranceProviderEnum) ToPointer() *CreateLabelRequestBodyPartialShipmentInsuranceProviderEnum {
	return &e
}

func (e *CreateLabelRequestBodyPartialShipmentInsuranceProviderEnum) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "none":
		fallthrough
	case "shipsurance":
		fallthrough
	case "carrier":
		fallthrough
	case "third_party":
		*e = CreateLabelRequestBodyPartialShipmentInsuranceProviderEnum(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CreateLabelRequestBodyPartialShipmentInsuranceProviderEnum: %v", v)
	}
}

// CreateLabelRequestBodyPartialShipmentOriginTypeEnum - Indicates if the package will be picked up or dropped off by the carrier
type CreateLabelRequestBodyPartialShipmentOriginTypeEnum string

const (
	CreateLabelRequestBodyPartialShipmentOriginTypeEnumPickup  CreateLabelRequestBodyPartialShipmentOriginTypeEnum = "pickup"
	CreateLabelRequestBodyPartialShipmentOriginTypeEnumDropOff CreateLabelRequestBodyPartialShipmentOriginTypeEnum = "drop_off"
)

func (e CreateLabelRequestBodyPartialShipmentOriginTypeEnum) ToPointer() *CreateLabelRequestBodyPartialShipmentOriginTypeEnum {
	return &e
}

func (e *CreateLabelRequestBodyPartialShipmentOriginTypeEnum) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "pickup":
		fallthrough
	case "drop_off":
		*e = CreateLabelRequestBodyPartialShipmentOriginTypeEnum(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CreateLabelRequestBodyPartialShipmentOriginTypeEnum: %v", v)
	}
}

// CreateLabelRequestBodyPartialShipmentInput - The information necessary to ship a package, such as the origin, the destination, the carrier service, and the package dimensions and weight.
type CreateLabelRequestBodyPartialShipmentInput struct {
	// Advanced shipment options.  These are entirely optional.
	AdvancedOptions AdvancedShipmentOptions `json:"advanced_options"`
	// The carrier account that is billed for the shipping charges
	CarrierID string `json:"carrier_id"`
	// The type of delivery confirmation that is required for this shipment.
	Confirmation CreateLabelRequestBodyPartialShipmentDeliveryConfirmationEnum `json:"confirmation"`
	// Customs information.  This is usually only needed for international shipments.
	//
	Customs CreateLabelRequestBodyPartialShipmentInternationalShipmentOptionsInput `json:"customs"`
	// ID that the Order Source assigned
	ExternalOrderID *string `json:"external_order_id,omitempty"`
	// A unique user-defined key to identify a shipment.  This can be used to retrieve the shipment.
	//
	// > **Warning:** The `external_shipment_id` is limited to 50 characters. Any additional characters will be truncated.
	//
	ExternalShipmentID *string `json:"external_shipment_id,omitempty"`
	// The insurance provider to use for any insured packages in the shipment.
	//
	InsuranceProvider CreateLabelRequestBodyPartialShipmentInsuranceProviderEnum `json:"insurance_provider"`
	// An optional indicator if the shipment is intended to be a return. Defaults to false if not provided.
	//
	IsReturn *bool `json:"is_return,omitempty"`
	// Describe the packages included in this shipment as related to potential metadata that was imported from
	// external order sources
	//
	Items           []ShipmentItem       `json:"items,omitempty"`
	OrderSourceCode *OrderSourceNameEnum `json:"order_source_code,omitempty"`
	// Indicates if the package will be picked up or dropped off by the carrier
	OriginType *CreateLabelRequestBodyPartialShipmentOriginTypeEnum `json:"origin_type,omitempty"`
	// The packages in the shipment.
	//
	// > **Note:** Some carriers only allow one package per shipment.  If you attempt to create a multi-package shipment for a carrier that doesn't allow it, an error will be returned.
	//
	Packages []PackageInput `json:"packages"`
	// The return address for this shipment.  Defaults to the `ship_from` address.
	//
	ReturnTo ShippingAddress `json:"return_to"`
	// The [carrier service](https://www.shipengine.com/docs/shipping/use-a-carrier-service/) used to ship the package, such as `fedex_ground`, `usps_first_class_mail`, `flat_rate_envelope`, etc.
	//
	ServiceCode string `json:"service_code"`
	// The date that the shipment was (or will be) shippped.  ShipEngine will take the day of week into consideration. For example, if the carrier does not operate on Sundays, then a package that would have shipped on Sunday will ship on Monday instead.
	//
	ShipDate time.Time `json:"ship_date"`
	// The shipment's origin address. If you frequently ship from the same location, consider [creating a warehouse](https://www.shipengine.com/docs/reference/create-warehouse/).  Then you can simply specify the `warehouse_id` rather than the complete address each time.
	//
	ShipFrom ShippingAddress `json:"ship_from"`
	// The recipient's mailing address
	ShipTo ShippingAddress `json:"ship_to"`
	// A non-unique user-defined number used to identify a shipment.  If undefined, this will match the external_shipment_id of the shipment.
	//
	// > **Warning:** The `shipment_number` is limited to 50 characters. Any additional characters will be truncated.
	//
	ShipmentNumber *string         `json:"shipment_number,omitempty"`
	TaxIdentifiers []TaxIdentifier `json:"tax_identifiers,omitempty"`
	// The [warehouse](https://www.shipengine.com/docs/shipping/ship-from-a-warehouse/) that the shipment is being shipped from.  Either `warehouse_id` or `ship_from` must be specified.
	//
	WarehouseID string `json:"warehouse_id"`
}

// CreateLabelRequestBodyValidateAddressEnum - The possible validate address values
type CreateLabelRequestBodyValidateAddressEnum string

const (
	CreateLabelRequestBodyValidateAddressEnumNoValidation     CreateLabelRequestBodyValidateAddressEnum = "no_validation"
	CreateLabelRequestBodyValidateAddressEnumValidateOnly     CreateLabelRequestBodyValidateAddressEnum = "validate_only"
	CreateLabelRequestBodyValidateAddressEnumValidateAndClean CreateLabelRequestBodyValidateAddressEnum = "validate_and_clean"
)

func (e CreateLabelRequestBodyValidateAddressEnum) ToPointer() *CreateLabelRequestBodyValidateAddressEnum {
	return &e
}

func (e *CreateLabelRequestBodyValidateAddressEnum) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "no_validation":
		fallthrough
	case "validate_only":
		fallthrough
	case "validate_and_clean":
		*e = CreateLabelRequestBodyValidateAddressEnum(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CreateLabelRequestBodyValidateAddressEnum: %v", v)
	}
}

// CreateLabelRequestBodyInput - A label represents the physical sticker that you affix to a package to ship it.  ShipEngine makes it easy for you to [create labels](https://www.shipengine.com/docs/labels/create-a-label/) and then download them in PDF, PNG, or ZPL format so you can print them.
type CreateLabelRequestBodyInput struct {
	// The label charge event.
	//
	ChargeEvent *LabelChargeEventEnum `json:"charge_event,omitempty"`
	// The display format that the label should be shown in.
	DisplayScheme *CreateLabelRequestBodyDisplaySchemeEnum `json:"display_scheme,omitempty"`
	// Indicates whether this is a return label.  You may also want to set the `rma_number` so you know what is being returned.
	//
	IsReturnLabel     *bool                                        `json:"is_return_label,omitempty"`
	LabelDownloadType *CreateLabelRequestBodyLabelDownloadTypeEnum `json:"label_download_type,omitempty"`
	// The file format that you want the label to be in.  We recommend `pdf` format because it is supported by all carriers, whereas some carriers do not support the `png` or `zpl` formats.
	//
	LabelFormat *CreateLabelRequestBodyLabelFormatEnum `json:"label_format,omitempty"`
	// The label image resource that was used to create a custom label image.
	LabelImageID *string `json:"label_image_id,omitempty"`
	// The layout (size) that you want the label to be in.  The `label_format` determines which sizes are allowed.  `4x6` is supported for all label formats, whereas `letter` (8.5" x 11") is only supported for `pdf` format.
	//
	LabelLayout *CreateLabelRequestBodyLabelLayoutEnum `json:"label_layout,omitempty"`
	// The `label_id` of the original (outgoing) label that the return label is for. This associates the two labels together, which is
	// required by some carriers.
	//
	OutboundLabelID *string `json:"outbound_label_id,omitempty"`
	// An optional Return Merchandise Authorization number.  This field is useful for return labels.  You can set it to any string value.
	//
	RmaNumber *string `json:"rma_number,omitempty"`
	// A unique identifier for a carrier drop off point where a merchant plans to deliver packages. This will take precedence over a shipment's ship from address.
	ShipFromServicePointID *string `json:"ship_from_service_point_id,omitempty"`
	// A unique identifier for a carrier service point where the shipment will be delivered by the carrier. This will take precedence over a shipment's ship to address.
	ShipToServicePointID *string `json:"ship_to_service_point_id,omitempty"`
	// The shipment information used to generate the label
	Shipment CreateLabelRequestBodyPartialShipmentInput `json:"shipment"`
	// Indicate if this label is being used only for testing purposes. If true, then no charge will be added to your account.
	TestLabel       *bool                                      `json:"test_label,omitempty"`
	ValidateAddress *CreateLabelRequestBodyValidateAddressEnum `json:"validate_address,omitempty"`
}
