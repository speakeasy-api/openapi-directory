<?php

/**
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

declare(strict_types=1);

namespace OpenAPI\OpenAPI;

/**
 * SDK - <fullname>Amazon CloudSearch Configuration Service</fullname> <p>You use the configuration service to create, configure, and manage search domains. Configuration service requests are submitted using the AWS Query protocol. AWS Query requests are HTTP or HTTPS requests submitted via HTTP GET or POST with a query parameter named Action.</p> <p>The endpoint for configuration service requests is region-specific: cloudsearch.<i>region</i>.amazonaws.com. For example, cloudsearch.us-east-1.amazonaws.com. For a current list of supported regions and endpoints, see <a href="http://docs.aws.amazon.com/general/latest/gr/rande.html#cloudsearch_region">Regions and Endpoints</a>.</p>
 * 
 * https://docs.aws.amazon.com/cloudsearch/ - Amazon Web Services documentation
 * 
 * @package OpenAPI\OpenAPI
 * @access public
 * @see https://docs.aws.amazon.com/cloudsearch/
 */
class SDK
{
	public const SERVERS = [
        /** The Amazon CloudSearch multi-region endpoint */
		'http://cloudsearch.{region}.amazonaws.com',
        /** The Amazon CloudSearch multi-region endpoint */
		'https://cloudsearch.{region}.amazonaws.com',
        /** The Amazon CloudSearch endpoint for China (Beijing) and China (Ningxia) */
		'http://cloudsearch.{region}.amazonaws.com.cn',
        /** The Amazon CloudSearch endpoint for China (Beijing) and China (Ningxia) */
		'https://cloudsearch.{region}.amazonaws.com.cn',
	];
  		
	// SDK private variables namespaced with _ to avoid conflicts with API models
	private ?\GuzzleHttp\ClientInterface $_defaultClient;
	private ?\GuzzleHttp\ClientInterface $_securityClient;
	private ?Models\Shared\Security $_security;
	private string $_serverUrl;
	private string $_language = 'php';
	private string $_sdkVersion = '0.0.1';
	private string $_genVersion = 'internal';

	/**
	 * Returns a new instance of the SDK builder used to configure and create the SDK instance.
	 * 
	 * @return SDKBuilder
	 */
	public static function builder(): SDKBuilder
	{
		return new SDKBuilder();
	}

	/**
	 * @param \GuzzleHttp\ClientInterface|null $client	 
	 * @param Models\Shared\Security|null $security
	 * @param string $serverUrl
	 * @param array<string, string>|null $params
	 */
	public function __construct(?\GuzzleHttp\ClientInterface $client, ?Models\Shared\Security $security, string $serverUrl, ?array $params)
	{
		$this->_defaultClient = $client;
		
		if ($this->_defaultClient === null) {
			$this->_defaultClient = new \GuzzleHttp\Client([
				'timeout' => 60,
			]);
		}

		$this->_securityClient = null;
		if ($security !== null) {
			$this->_security = $security;
			$this->_securityClient = Utils\Utils::configureSecurityClient($this->_defaultClient, $this->_security);
		}
		
		if ($this->_securityClient === null) {
			$this->_securityClient = $this->_defaultClient;
		}

		if (!empty($serverUrl)) {
			$this->_serverUrl = Utils\Utils::templateUrl($serverUrl, $params);
		}
		
		if (empty($this->_serverUrl)) {
			$this->_serverUrl = $this::SERVERS[0];
		}
	}
	
    /**
     * Creates a new search domain.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GETCreateDomainRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\GETCreateDomainResponse
     */
	public function getCreateDomain(
        \OpenAPI\OpenAPI\Models\Operations\GETCreateDomainRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\GETCreateDomainResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/#Action=CreateDomain');
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\GETCreateDomainRequest::class, $request, null));
        $options = array_merge_recursive($options, Utils\Utils::getHeaders($request));
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GETCreateDomainResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200 or $httpResponse->getStatusCode() === 409 or $httpResponse->getStatusCode() === 480 or $httpResponse->getStatusCode() === 500) {
            if (Utils\Utils::matchContentType($contentType, 'text/xml')) {
                $response->body = $httpResponse->getBody()->getContents();
            }
        }

        return $response;
    }
	
    /**
     * Configures a <code>RankExpression</code> for the search domain. Used to create new rank expressions and modify existing ones. If the expression exists, the new configuration replaces the old one. You can configure a maximum of 50 rank expressions.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GETDefineRankExpressionRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\GETDefineRankExpressionResponse
     */
	public function getDefineRankExpression(
        \OpenAPI\OpenAPI\Models\Operations\GETDefineRankExpressionRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\GETDefineRankExpressionResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/#Action=DefineRankExpression');
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\GETDefineRankExpressionRequest::class, $request, null));
        $options = array_merge_recursive($options, Utils\Utils::getHeaders($request));
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GETDefineRankExpressionResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200 or $httpResponse->getStatusCode() === 409 or $httpResponse->getStatusCode() === 480 or $httpResponse->getStatusCode() === 500) {
            if (Utils\Utils::matchContentType($contentType, 'text/xml')) {
                $response->body = $httpResponse->getBody()->getContents();
            }
        }

        return $response;
    }
	
    /**
     * Permanently deletes a search domain and all of its data.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GETDeleteDomainRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\GETDeleteDomainResponse
     */
	public function getDeleteDomain(
        \OpenAPI\OpenAPI\Models\Operations\GETDeleteDomainRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\GETDeleteDomainResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/#Action=DeleteDomain');
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\GETDeleteDomainRequest::class, $request, null));
        $options = array_merge_recursive($options, Utils\Utils::getHeaders($request));
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GETDeleteDomainResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200 or $httpResponse->getStatusCode() === 480 or $httpResponse->getStatusCode() === 500) {
            if (Utils\Utils::matchContentType($contentType, 'text/xml')) {
                $response->body = $httpResponse->getBody()->getContents();
            }
        }

        return $response;
    }
	
    /**
     * Removes an <code>IndexField</code> from the search domain.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GETDeleteIndexFieldRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\GETDeleteIndexFieldResponse
     */
	public function getDeleteIndexField(
        \OpenAPI\OpenAPI\Models\Operations\GETDeleteIndexFieldRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\GETDeleteIndexFieldResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/#Action=DeleteIndexField');
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\GETDeleteIndexFieldRequest::class, $request, null));
        $options = array_merge_recursive($options, Utils\Utils::getHeaders($request));
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GETDeleteIndexFieldResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200 or $httpResponse->getStatusCode() === 409 or $httpResponse->getStatusCode() === 480 or $httpResponse->getStatusCode() === 500) {
            if (Utils\Utils::matchContentType($contentType, 'text/xml')) {
                $response->body = $httpResponse->getBody()->getContents();
            }
        }

        return $response;
    }
	
    /**
     * Removes a <code>RankExpression</code> from the search domain.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GETDeleteRankExpressionRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\GETDeleteRankExpressionResponse
     */
	public function getDeleteRankExpression(
        \OpenAPI\OpenAPI\Models\Operations\GETDeleteRankExpressionRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\GETDeleteRankExpressionResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/#Action=DeleteRankExpression');
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\GETDeleteRankExpressionRequest::class, $request, null));
        $options = array_merge_recursive($options, Utils\Utils::getHeaders($request));
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GETDeleteRankExpressionResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200 or $httpResponse->getStatusCode() === 409 or $httpResponse->getStatusCode() === 480 or $httpResponse->getStatusCode() === 500) {
            if (Utils\Utils::matchContentType($contentType, 'text/xml')) {
                $response->body = $httpResponse->getBody()->getContents();
            }
        }

        return $response;
    }
	
    /**
     * Gets the availability options configured for a domain. By default, shows the configuration with any pending changes. Set the <code>Deployed</code> option to <code>true</code> to show the active configuration and exclude pending changes. For more information, see <a href="http://docs.aws.amazon.com/cloudsearch/latest/developerguide/configuring-availability-options.html" target="_blank">Configuring Availability Options</a> in the <i>Amazon CloudSearch Developer Guide</i>.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GETDescribeAvailabilityOptionsRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\GETDescribeAvailabilityOptionsResponse
     */
	public function getDescribeAvailabilityOptions(
        \OpenAPI\OpenAPI\Models\Operations\GETDescribeAvailabilityOptionsRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\GETDescribeAvailabilityOptionsResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/#Action=DescribeAvailabilityOptions');
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\GETDescribeAvailabilityOptionsRequest::class, $request, null));
        $options = array_merge_recursive($options, Utils\Utils::getHeaders($request));
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GETDescribeAvailabilityOptionsResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200 or $httpResponse->getStatusCode() === 409 or $httpResponse->getStatusCode() === 480 or $httpResponse->getStatusCode() === 500) {
            if (Utils\Utils::matchContentType($contentType, 'text/xml')) {
                $response->body = $httpResponse->getBody()->getContents();
            }
        }

        return $response;
    }
	
    /**
     * Gets the default search field configured for the search domain.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GETDescribeDefaultSearchFieldRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\GETDescribeDefaultSearchFieldResponse
     */
	public function getDescribeDefaultSearchField(
        \OpenAPI\OpenAPI\Models\Operations\GETDescribeDefaultSearchFieldRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\GETDescribeDefaultSearchFieldResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/#Action=DescribeDefaultSearchField');
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\GETDescribeDefaultSearchFieldRequest::class, $request, null));
        $options = array_merge_recursive($options, Utils\Utils::getHeaders($request));
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GETDescribeDefaultSearchFieldResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200 or $httpResponse->getStatusCode() === 409 or $httpResponse->getStatusCode() === 480 or $httpResponse->getStatusCode() === 500) {
            if (Utils\Utils::matchContentType($contentType, 'text/xml')) {
                $response->body = $httpResponse->getBody()->getContents();
            }
        }

        return $response;
    }
	
    /**
     * Gets information about the search domains owned by this account. Can be limited to specific domains. Shows all domains by default.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GETDescribeDomainsRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\GETDescribeDomainsResponse
     */
	public function getDescribeDomains(
        \OpenAPI\OpenAPI\Models\Operations\GETDescribeDomainsRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\GETDescribeDomainsResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/#Action=DescribeDomains');
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\GETDescribeDomainsRequest::class, $request, null));
        $options = array_merge_recursive($options, Utils\Utils::getHeaders($request));
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GETDescribeDomainsResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200 or $httpResponse->getStatusCode() === 480 or $httpResponse->getStatusCode() === 500) {
            if (Utils\Utils::matchContentType($contentType, 'text/xml')) {
                $response->body = $httpResponse->getBody()->getContents();
            }
        }

        return $response;
    }
	
    /**
     * Gets information about the index fields configured for the search domain. Can be limited to specific fields by name. Shows all fields by default.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GETDescribeIndexFieldsRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\GETDescribeIndexFieldsResponse
     */
	public function getDescribeIndexFields(
        \OpenAPI\OpenAPI\Models\Operations\GETDescribeIndexFieldsRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\GETDescribeIndexFieldsResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/#Action=DescribeIndexFields');
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\GETDescribeIndexFieldsRequest::class, $request, null));
        $options = array_merge_recursive($options, Utils\Utils::getHeaders($request));
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GETDescribeIndexFieldsResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200 or $httpResponse->getStatusCode() === 409 or $httpResponse->getStatusCode() === 480 or $httpResponse->getStatusCode() === 500) {
            if (Utils\Utils::matchContentType($contentType, 'text/xml')) {
                $response->body = $httpResponse->getBody()->getContents();
            }
        }

        return $response;
    }
	
    /**
     * Gets the rank expressions configured for the search domain. Can be limited to specific rank expressions by name. Shows all rank expressions by default. 
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GETDescribeRankExpressionsRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\GETDescribeRankExpressionsResponse
     */
	public function getDescribeRankExpressions(
        \OpenAPI\OpenAPI\Models\Operations\GETDescribeRankExpressionsRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\GETDescribeRankExpressionsResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/#Action=DescribeRankExpressions');
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\GETDescribeRankExpressionsRequest::class, $request, null));
        $options = array_merge_recursive($options, Utils\Utils::getHeaders($request));
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GETDescribeRankExpressionsResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200 or $httpResponse->getStatusCode() === 409 or $httpResponse->getStatusCode() === 480 or $httpResponse->getStatusCode() === 500) {
            if (Utils\Utils::matchContentType($contentType, 'text/xml')) {
                $response->body = $httpResponse->getBody()->getContents();
            }
        }

        return $response;
    }
	
    /**
     * Gets information about the resource-based policies that control access to the domain's document and search services.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GETDescribeServiceAccessPoliciesRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\GETDescribeServiceAccessPoliciesResponse
     */
	public function getDescribeServiceAccessPolicies(
        \OpenAPI\OpenAPI\Models\Operations\GETDescribeServiceAccessPoliciesRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\GETDescribeServiceAccessPoliciesResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/#Action=DescribeServiceAccessPolicies');
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\GETDescribeServiceAccessPoliciesRequest::class, $request, null));
        $options = array_merge_recursive($options, Utils\Utils::getHeaders($request));
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GETDescribeServiceAccessPoliciesResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200 or $httpResponse->getStatusCode() === 409 or $httpResponse->getStatusCode() === 480 or $httpResponse->getStatusCode() === 500) {
            if (Utils\Utils::matchContentType($contentType, 'text/xml')) {
                $response->body = $httpResponse->getBody()->getContents();
            }
        }

        return $response;
    }
	
    /**
     * Gets the stemming dictionary configured for the search domain.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GETDescribeStemmingOptionsRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\GETDescribeStemmingOptionsResponse
     */
	public function getDescribeStemmingOptions(
        \OpenAPI\OpenAPI\Models\Operations\GETDescribeStemmingOptionsRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\GETDescribeStemmingOptionsResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/#Action=DescribeStemmingOptions');
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\GETDescribeStemmingOptionsRequest::class, $request, null));
        $options = array_merge_recursive($options, Utils\Utils::getHeaders($request));
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GETDescribeStemmingOptionsResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200 or $httpResponse->getStatusCode() === 409 or $httpResponse->getStatusCode() === 480 or $httpResponse->getStatusCode() === 500) {
            if (Utils\Utils::matchContentType($contentType, 'text/xml')) {
                $response->body = $httpResponse->getBody()->getContents();
            }
        }

        return $response;
    }
	
    /**
     * Gets the stopwords configured for the search domain.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GETDescribeStopwordOptionsRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\GETDescribeStopwordOptionsResponse
     */
	public function getDescribeStopwordOptions(
        \OpenAPI\OpenAPI\Models\Operations\GETDescribeStopwordOptionsRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\GETDescribeStopwordOptionsResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/#Action=DescribeStopwordOptions');
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\GETDescribeStopwordOptionsRequest::class, $request, null));
        $options = array_merge_recursive($options, Utils\Utils::getHeaders($request));
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GETDescribeStopwordOptionsResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200 or $httpResponse->getStatusCode() === 409 or $httpResponse->getStatusCode() === 480 or $httpResponse->getStatusCode() === 500) {
            if (Utils\Utils::matchContentType($contentType, 'text/xml')) {
                $response->body = $httpResponse->getBody()->getContents();
            }
        }

        return $response;
    }
	
    /**
     * Gets the synonym dictionary configured for the search domain.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GETDescribeSynonymOptionsRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\GETDescribeSynonymOptionsResponse
     */
	public function getDescribeSynonymOptions(
        \OpenAPI\OpenAPI\Models\Operations\GETDescribeSynonymOptionsRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\GETDescribeSynonymOptionsResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/#Action=DescribeSynonymOptions');
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\GETDescribeSynonymOptionsRequest::class, $request, null));
        $options = array_merge_recursive($options, Utils\Utils::getHeaders($request));
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GETDescribeSynonymOptionsResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200 or $httpResponse->getStatusCode() === 409 or $httpResponse->getStatusCode() === 480 or $httpResponse->getStatusCode() === 500) {
            if (Utils\Utils::matchContentType($contentType, 'text/xml')) {
                $response->body = $httpResponse->getBody()->getContents();
            }
        }

        return $response;
    }
	
    /**
     * Tells the search domain to start indexing its documents using the latest text processing options and <code>IndexFields</code>. This operation must be invoked to make options whose <a>OptionStatus</a> has <code>OptionState</code> of <code>RequiresIndexDocuments</code> visible in search results.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GETIndexDocumentsRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\GETIndexDocumentsResponse
     */
	public function getIndexDocuments(
        \OpenAPI\OpenAPI\Models\Operations\GETIndexDocumentsRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\GETIndexDocumentsResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/#Action=IndexDocuments');
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\GETIndexDocumentsRequest::class, $request, null));
        $options = array_merge_recursive($options, Utils\Utils::getHeaders($request));
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GETIndexDocumentsResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200 or $httpResponse->getStatusCode() === 409 or $httpResponse->getStatusCode() === 480 or $httpResponse->getStatusCode() === 500) {
            if (Utils\Utils::matchContentType($contentType, 'text/xml')) {
                $response->body = $httpResponse->getBody()->getContents();
            }
        }

        return $response;
    }
	
    /**
     * Configures the availability options for a domain. Enabling the Multi-AZ option expands an Amazon CloudSearch domain to an additional Availability Zone in the same Region to increase fault tolerance in the event of a service disruption. Changes to the Multi-AZ option can take about half an hour to become active. For more information, see <a href="http://docs.aws.amazon.com/cloudsearch/latest/developerguide/configuring-availability-options.html" target="_blank">Configuring Availability Options</a> in the <i>Amazon CloudSearch Developer Guide</i>.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GETUpdateAvailabilityOptionsRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\GETUpdateAvailabilityOptionsResponse
     */
	public function getUpdateAvailabilityOptions(
        \OpenAPI\OpenAPI\Models\Operations\GETUpdateAvailabilityOptionsRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\GETUpdateAvailabilityOptionsResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/#Action=UpdateAvailabilityOptions');
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\GETUpdateAvailabilityOptionsRequest::class, $request, null));
        $options = array_merge_recursive($options, Utils\Utils::getHeaders($request));
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GETUpdateAvailabilityOptionsResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200 or $httpResponse->getStatusCode() === 409 or $httpResponse->getStatusCode() === 480 or $httpResponse->getStatusCode() === 500) {
            if (Utils\Utils::matchContentType($contentType, 'text/xml')) {
                $response->body = $httpResponse->getBody()->getContents();
            }
        }

        return $response;
    }
	
    /**
     * Configures the default search field for the search domain. The default search field is the text field that is searched when a search request does not specify which fields to search. By default, it is configured to include the contents of all of the domain's text fields. 
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GETUpdateDefaultSearchFieldRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\GETUpdateDefaultSearchFieldResponse
     */
	public function getUpdateDefaultSearchField(
        \OpenAPI\OpenAPI\Models\Operations\GETUpdateDefaultSearchFieldRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\GETUpdateDefaultSearchFieldResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/#Action=UpdateDefaultSearchField');
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\GETUpdateDefaultSearchFieldRequest::class, $request, null));
        $options = array_merge_recursive($options, Utils\Utils::getHeaders($request));
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GETUpdateDefaultSearchFieldResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200 or $httpResponse->getStatusCode() === 409 or $httpResponse->getStatusCode() === 480 or $httpResponse->getStatusCode() === 500) {
            if (Utils\Utils::matchContentType($contentType, 'text/xml')) {
                $response->body = $httpResponse->getBody()->getContents();
            }
        }

        return $response;
    }
	
    /**
     * Configures the policies that control access to the domain's document and search services. The maximum size of an access policy document is 100 KB.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GETUpdateServiceAccessPoliciesRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\GETUpdateServiceAccessPoliciesResponse
     */
	public function getUpdateServiceAccessPolicies(
        \OpenAPI\OpenAPI\Models\Operations\GETUpdateServiceAccessPoliciesRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\GETUpdateServiceAccessPoliciesResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/#Action=UpdateServiceAccessPolicies');
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\GETUpdateServiceAccessPoliciesRequest::class, $request, null));
        $options = array_merge_recursive($options, Utils\Utils::getHeaders($request));
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GETUpdateServiceAccessPoliciesResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200 or $httpResponse->getStatusCode() === 409 or $httpResponse->getStatusCode() === 480 or $httpResponse->getStatusCode() === 500) {
            if (Utils\Utils::matchContentType($contentType, 'text/xml')) {
                $response->body = $httpResponse->getBody()->getContents();
            }
        }

        return $response;
    }
	
    /**
     * Configures a stemming dictionary for the search domain. The stemming dictionary is used during indexing and when processing search requests. The maximum size of the stemming dictionary is 500 KB.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GETUpdateStemmingOptionsRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\GETUpdateStemmingOptionsResponse
     */
	public function getUpdateStemmingOptions(
        \OpenAPI\OpenAPI\Models\Operations\GETUpdateStemmingOptionsRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\GETUpdateStemmingOptionsResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/#Action=UpdateStemmingOptions');
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\GETUpdateStemmingOptionsRequest::class, $request, null));
        $options = array_merge_recursive($options, Utils\Utils::getHeaders($request));
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GETUpdateStemmingOptionsResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200 or $httpResponse->getStatusCode() === 409 or $httpResponse->getStatusCode() === 480 or $httpResponse->getStatusCode() === 500) {
            if (Utils\Utils::matchContentType($contentType, 'text/xml')) {
                $response->body = $httpResponse->getBody()->getContents();
            }
        }

        return $response;
    }
	
    /**
     * Configures stopwords for the search domain. Stopwords are used during indexing and when processing search requests. The maximum size of the stopwords dictionary is 10 KB.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GETUpdateStopwordOptionsRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\GETUpdateStopwordOptionsResponse
     */
	public function getUpdateStopwordOptions(
        \OpenAPI\OpenAPI\Models\Operations\GETUpdateStopwordOptionsRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\GETUpdateStopwordOptionsResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/#Action=UpdateStopwordOptions');
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\GETUpdateStopwordOptionsRequest::class, $request, null));
        $options = array_merge_recursive($options, Utils\Utils::getHeaders($request));
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GETUpdateStopwordOptionsResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200 or $httpResponse->getStatusCode() === 409 or $httpResponse->getStatusCode() === 480 or $httpResponse->getStatusCode() === 500) {
            if (Utils\Utils::matchContentType($contentType, 'text/xml')) {
                $response->body = $httpResponse->getBody()->getContents();
            }
        }

        return $response;
    }
	
    /**
     * Configures a synonym dictionary for the search domain. The synonym dictionary is used during indexing to configure mappings for terms that occur in text fields. The maximum size of the synonym dictionary is 100 KB. 
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GETUpdateSynonymOptionsRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\GETUpdateSynonymOptionsResponse
     */
	public function getUpdateSynonymOptions(
        \OpenAPI\OpenAPI\Models\Operations\GETUpdateSynonymOptionsRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\GETUpdateSynonymOptionsResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/#Action=UpdateSynonymOptions');
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\GETUpdateSynonymOptionsRequest::class, $request, null));
        $options = array_merge_recursive($options, Utils\Utils::getHeaders($request));
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GETUpdateSynonymOptionsResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200 or $httpResponse->getStatusCode() === 409 or $httpResponse->getStatusCode() === 480 or $httpResponse->getStatusCode() === 500) {
            if (Utils\Utils::matchContentType($contentType, 'text/xml')) {
                $response->body = $httpResponse->getBody()->getContents();
            }
        }

        return $response;
    }
	
    /**
     * Creates a new search domain.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\POSTCreateDomainRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\POSTCreateDomainResponse
     */
	public function postCreateDomain(
        \OpenAPI\OpenAPI\Models\Operations\POSTCreateDomainRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\POSTCreateDomainResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/#Action=CreateDomain');
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "requestBody", "raw");
        $options = array_merge_recursive($options, $body);
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\POSTCreateDomainRequest::class, $request, null));
        $options = array_merge_recursive($options, Utils\Utils::getHeaders($request));
        
        $httpResponse = $this->_securityClient->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\POSTCreateDomainResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200 or $httpResponse->getStatusCode() === 409 or $httpResponse->getStatusCode() === 480 or $httpResponse->getStatusCode() === 500) {
            if (Utils\Utils::matchContentType($contentType, 'text/xml')) {
                $response->body = $httpResponse->getBody()->getContents();
            }
        }

        return $response;
    }
	
    /**
     * Configures an <code>IndexField</code> for the search domain. Used to create new fields and modify existing ones. If the field exists, the new configuration replaces the old one. You can configure a maximum of 200 index fields.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\POSTDefineIndexFieldRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\POSTDefineIndexFieldResponse
     */
	public function postDefineIndexField(
        \OpenAPI\OpenAPI\Models\Operations\POSTDefineIndexFieldRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\POSTDefineIndexFieldResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/#Action=DefineIndexField');
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "requestBody", "raw");
        $options = array_merge_recursive($options, $body);
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\POSTDefineIndexFieldRequest::class, $request, null));
        $options = array_merge_recursive($options, Utils\Utils::getHeaders($request));
        
        $httpResponse = $this->_securityClient->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\POSTDefineIndexFieldResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200 or $httpResponse->getStatusCode() === 409 or $httpResponse->getStatusCode() === 480 or $httpResponse->getStatusCode() === 500) {
            if (Utils\Utils::matchContentType($contentType, 'text/xml')) {
                $response->body = $httpResponse->getBody()->getContents();
            }
        }

        return $response;
    }
	
    /**
     * Configures a <code>RankExpression</code> for the search domain. Used to create new rank expressions and modify existing ones. If the expression exists, the new configuration replaces the old one. You can configure a maximum of 50 rank expressions.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\POSTDefineRankExpressionRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\POSTDefineRankExpressionResponse
     */
	public function postDefineRankExpression(
        \OpenAPI\OpenAPI\Models\Operations\POSTDefineRankExpressionRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\POSTDefineRankExpressionResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/#Action=DefineRankExpression');
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "requestBody", "raw");
        $options = array_merge_recursive($options, $body);
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\POSTDefineRankExpressionRequest::class, $request, null));
        $options = array_merge_recursive($options, Utils\Utils::getHeaders($request));
        
        $httpResponse = $this->_securityClient->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\POSTDefineRankExpressionResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200 or $httpResponse->getStatusCode() === 409 or $httpResponse->getStatusCode() === 480 or $httpResponse->getStatusCode() === 500) {
            if (Utils\Utils::matchContentType($contentType, 'text/xml')) {
                $response->body = $httpResponse->getBody()->getContents();
            }
        }

        return $response;
    }
	
    /**
     * Permanently deletes a search domain and all of its data.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\POSTDeleteDomainRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\POSTDeleteDomainResponse
     */
	public function postDeleteDomain(
        \OpenAPI\OpenAPI\Models\Operations\POSTDeleteDomainRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\POSTDeleteDomainResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/#Action=DeleteDomain');
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "requestBody", "raw");
        $options = array_merge_recursive($options, $body);
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\POSTDeleteDomainRequest::class, $request, null));
        $options = array_merge_recursive($options, Utils\Utils::getHeaders($request));
        
        $httpResponse = $this->_securityClient->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\POSTDeleteDomainResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200 or $httpResponse->getStatusCode() === 480 or $httpResponse->getStatusCode() === 500) {
            if (Utils\Utils::matchContentType($contentType, 'text/xml')) {
                $response->body = $httpResponse->getBody()->getContents();
            }
        }

        return $response;
    }
	
    /**
     * Removes an <code>IndexField</code> from the search domain.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\POSTDeleteIndexFieldRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\POSTDeleteIndexFieldResponse
     */
	public function postDeleteIndexField(
        \OpenAPI\OpenAPI\Models\Operations\POSTDeleteIndexFieldRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\POSTDeleteIndexFieldResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/#Action=DeleteIndexField');
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "requestBody", "raw");
        $options = array_merge_recursive($options, $body);
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\POSTDeleteIndexFieldRequest::class, $request, null));
        $options = array_merge_recursive($options, Utils\Utils::getHeaders($request));
        
        $httpResponse = $this->_securityClient->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\POSTDeleteIndexFieldResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200 or $httpResponse->getStatusCode() === 409 or $httpResponse->getStatusCode() === 480 or $httpResponse->getStatusCode() === 500) {
            if (Utils\Utils::matchContentType($contentType, 'text/xml')) {
                $response->body = $httpResponse->getBody()->getContents();
            }
        }

        return $response;
    }
	
    /**
     * Removes a <code>RankExpression</code> from the search domain.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\POSTDeleteRankExpressionRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\POSTDeleteRankExpressionResponse
     */
	public function postDeleteRankExpression(
        \OpenAPI\OpenAPI\Models\Operations\POSTDeleteRankExpressionRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\POSTDeleteRankExpressionResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/#Action=DeleteRankExpression');
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "requestBody", "raw");
        $options = array_merge_recursive($options, $body);
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\POSTDeleteRankExpressionRequest::class, $request, null));
        $options = array_merge_recursive($options, Utils\Utils::getHeaders($request));
        
        $httpResponse = $this->_securityClient->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\POSTDeleteRankExpressionResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200 or $httpResponse->getStatusCode() === 409 or $httpResponse->getStatusCode() === 480 or $httpResponse->getStatusCode() === 500) {
            if (Utils\Utils::matchContentType($contentType, 'text/xml')) {
                $response->body = $httpResponse->getBody()->getContents();
            }
        }

        return $response;
    }
	
    /**
     * Gets the availability options configured for a domain. By default, shows the configuration with any pending changes. Set the <code>Deployed</code> option to <code>true</code> to show the active configuration and exclude pending changes. For more information, see <a href="http://docs.aws.amazon.com/cloudsearch/latest/developerguide/configuring-availability-options.html" target="_blank">Configuring Availability Options</a> in the <i>Amazon CloudSearch Developer Guide</i>.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\POSTDescribeAvailabilityOptionsRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\POSTDescribeAvailabilityOptionsResponse
     */
	public function postDescribeAvailabilityOptions(
        \OpenAPI\OpenAPI\Models\Operations\POSTDescribeAvailabilityOptionsRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\POSTDescribeAvailabilityOptionsResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/#Action=DescribeAvailabilityOptions');
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "requestBody", "raw");
        $options = array_merge_recursive($options, $body);
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\POSTDescribeAvailabilityOptionsRequest::class, $request, null));
        $options = array_merge_recursive($options, Utils\Utils::getHeaders($request));
        
        $httpResponse = $this->_securityClient->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\POSTDescribeAvailabilityOptionsResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200 or $httpResponse->getStatusCode() === 409 or $httpResponse->getStatusCode() === 480 or $httpResponse->getStatusCode() === 500) {
            if (Utils\Utils::matchContentType($contentType, 'text/xml')) {
                $response->body = $httpResponse->getBody()->getContents();
            }
        }

        return $response;
    }
	
    /**
     * Gets the default search field configured for the search domain.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\POSTDescribeDefaultSearchFieldRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\POSTDescribeDefaultSearchFieldResponse
     */
	public function postDescribeDefaultSearchField(
        \OpenAPI\OpenAPI\Models\Operations\POSTDescribeDefaultSearchFieldRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\POSTDescribeDefaultSearchFieldResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/#Action=DescribeDefaultSearchField');
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "requestBody", "raw");
        $options = array_merge_recursive($options, $body);
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\POSTDescribeDefaultSearchFieldRequest::class, $request, null));
        $options = array_merge_recursive($options, Utils\Utils::getHeaders($request));
        
        $httpResponse = $this->_securityClient->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\POSTDescribeDefaultSearchFieldResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200 or $httpResponse->getStatusCode() === 409 or $httpResponse->getStatusCode() === 480 or $httpResponse->getStatusCode() === 500) {
            if (Utils\Utils::matchContentType($contentType, 'text/xml')) {
                $response->body = $httpResponse->getBody()->getContents();
            }
        }

        return $response;
    }
	
    /**
     * Gets information about the search domains owned by this account. Can be limited to specific domains. Shows all domains by default.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\POSTDescribeDomainsRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\POSTDescribeDomainsResponse
     */
	public function postDescribeDomains(
        \OpenAPI\OpenAPI\Models\Operations\POSTDescribeDomainsRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\POSTDescribeDomainsResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/#Action=DescribeDomains');
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "requestBody", "raw");
        $options = array_merge_recursive($options, $body);
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\POSTDescribeDomainsRequest::class, $request, null));
        $options = array_merge_recursive($options, Utils\Utils::getHeaders($request));
        
        $httpResponse = $this->_securityClient->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\POSTDescribeDomainsResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200 or $httpResponse->getStatusCode() === 480 or $httpResponse->getStatusCode() === 500) {
            if (Utils\Utils::matchContentType($contentType, 'text/xml')) {
                $response->body = $httpResponse->getBody()->getContents();
            }
        }

        return $response;
    }
	
    /**
     * Gets information about the index fields configured for the search domain. Can be limited to specific fields by name. Shows all fields by default.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\POSTDescribeIndexFieldsRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\POSTDescribeIndexFieldsResponse
     */
	public function postDescribeIndexFields(
        \OpenAPI\OpenAPI\Models\Operations\POSTDescribeIndexFieldsRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\POSTDescribeIndexFieldsResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/#Action=DescribeIndexFields');
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "requestBody", "raw");
        $options = array_merge_recursive($options, $body);
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\POSTDescribeIndexFieldsRequest::class, $request, null));
        $options = array_merge_recursive($options, Utils\Utils::getHeaders($request));
        
        $httpResponse = $this->_securityClient->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\POSTDescribeIndexFieldsResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200 or $httpResponse->getStatusCode() === 409 or $httpResponse->getStatusCode() === 480 or $httpResponse->getStatusCode() === 500) {
            if (Utils\Utils::matchContentType($contentType, 'text/xml')) {
                $response->body = $httpResponse->getBody()->getContents();
            }
        }

        return $response;
    }
	
    /**
     * Gets the rank expressions configured for the search domain. Can be limited to specific rank expressions by name. Shows all rank expressions by default. 
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\POSTDescribeRankExpressionsRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\POSTDescribeRankExpressionsResponse
     */
	public function postDescribeRankExpressions(
        \OpenAPI\OpenAPI\Models\Operations\POSTDescribeRankExpressionsRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\POSTDescribeRankExpressionsResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/#Action=DescribeRankExpressions');
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "requestBody", "raw");
        $options = array_merge_recursive($options, $body);
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\POSTDescribeRankExpressionsRequest::class, $request, null));
        $options = array_merge_recursive($options, Utils\Utils::getHeaders($request));
        
        $httpResponse = $this->_securityClient->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\POSTDescribeRankExpressionsResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200 or $httpResponse->getStatusCode() === 409 or $httpResponse->getStatusCode() === 480 or $httpResponse->getStatusCode() === 500) {
            if (Utils\Utils::matchContentType($contentType, 'text/xml')) {
                $response->body = $httpResponse->getBody()->getContents();
            }
        }

        return $response;
    }
	
    /**
     * Gets information about the resource-based policies that control access to the domain's document and search services.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\POSTDescribeServiceAccessPoliciesRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\POSTDescribeServiceAccessPoliciesResponse
     */
	public function postDescribeServiceAccessPolicies(
        \OpenAPI\OpenAPI\Models\Operations\POSTDescribeServiceAccessPoliciesRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\POSTDescribeServiceAccessPoliciesResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/#Action=DescribeServiceAccessPolicies');
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "requestBody", "raw");
        $options = array_merge_recursive($options, $body);
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\POSTDescribeServiceAccessPoliciesRequest::class, $request, null));
        $options = array_merge_recursive($options, Utils\Utils::getHeaders($request));
        
        $httpResponse = $this->_securityClient->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\POSTDescribeServiceAccessPoliciesResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200 or $httpResponse->getStatusCode() === 409 or $httpResponse->getStatusCode() === 480 or $httpResponse->getStatusCode() === 500) {
            if (Utils\Utils::matchContentType($contentType, 'text/xml')) {
                $response->body = $httpResponse->getBody()->getContents();
            }
        }

        return $response;
    }
	
    /**
     * Gets the stemming dictionary configured for the search domain.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\POSTDescribeStemmingOptionsRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\POSTDescribeStemmingOptionsResponse
     */
	public function postDescribeStemmingOptions(
        \OpenAPI\OpenAPI\Models\Operations\POSTDescribeStemmingOptionsRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\POSTDescribeStemmingOptionsResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/#Action=DescribeStemmingOptions');
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "requestBody", "raw");
        $options = array_merge_recursive($options, $body);
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\POSTDescribeStemmingOptionsRequest::class, $request, null));
        $options = array_merge_recursive($options, Utils\Utils::getHeaders($request));
        
        $httpResponse = $this->_securityClient->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\POSTDescribeStemmingOptionsResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200 or $httpResponse->getStatusCode() === 409 or $httpResponse->getStatusCode() === 480 or $httpResponse->getStatusCode() === 500) {
            if (Utils\Utils::matchContentType($contentType, 'text/xml')) {
                $response->body = $httpResponse->getBody()->getContents();
            }
        }

        return $response;
    }
	
    /**
     * Gets the stopwords configured for the search domain.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\POSTDescribeStopwordOptionsRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\POSTDescribeStopwordOptionsResponse
     */
	public function postDescribeStopwordOptions(
        \OpenAPI\OpenAPI\Models\Operations\POSTDescribeStopwordOptionsRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\POSTDescribeStopwordOptionsResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/#Action=DescribeStopwordOptions');
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "requestBody", "raw");
        $options = array_merge_recursive($options, $body);
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\POSTDescribeStopwordOptionsRequest::class, $request, null));
        $options = array_merge_recursive($options, Utils\Utils::getHeaders($request));
        
        $httpResponse = $this->_securityClient->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\POSTDescribeStopwordOptionsResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200 or $httpResponse->getStatusCode() === 409 or $httpResponse->getStatusCode() === 480 or $httpResponse->getStatusCode() === 500) {
            if (Utils\Utils::matchContentType($contentType, 'text/xml')) {
                $response->body = $httpResponse->getBody()->getContents();
            }
        }

        return $response;
    }
	
    /**
     * Gets the synonym dictionary configured for the search domain.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\POSTDescribeSynonymOptionsRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\POSTDescribeSynonymOptionsResponse
     */
	public function postDescribeSynonymOptions(
        \OpenAPI\OpenAPI\Models\Operations\POSTDescribeSynonymOptionsRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\POSTDescribeSynonymOptionsResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/#Action=DescribeSynonymOptions');
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "requestBody", "raw");
        $options = array_merge_recursive($options, $body);
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\POSTDescribeSynonymOptionsRequest::class, $request, null));
        $options = array_merge_recursive($options, Utils\Utils::getHeaders($request));
        
        $httpResponse = $this->_securityClient->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\POSTDescribeSynonymOptionsResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200 or $httpResponse->getStatusCode() === 409 or $httpResponse->getStatusCode() === 480 or $httpResponse->getStatusCode() === 500) {
            if (Utils\Utils::matchContentType($contentType, 'text/xml')) {
                $response->body = $httpResponse->getBody()->getContents();
            }
        }

        return $response;
    }
	
    /**
     * Tells the search domain to start indexing its documents using the latest text processing options and <code>IndexFields</code>. This operation must be invoked to make options whose <a>OptionStatus</a> has <code>OptionState</code> of <code>RequiresIndexDocuments</code> visible in search results.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\POSTIndexDocumentsRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\POSTIndexDocumentsResponse
     */
	public function postIndexDocuments(
        \OpenAPI\OpenAPI\Models\Operations\POSTIndexDocumentsRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\POSTIndexDocumentsResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/#Action=IndexDocuments');
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "requestBody", "raw");
        $options = array_merge_recursive($options, $body);
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\POSTIndexDocumentsRequest::class, $request, null));
        $options = array_merge_recursive($options, Utils\Utils::getHeaders($request));
        
        $httpResponse = $this->_securityClient->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\POSTIndexDocumentsResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200 or $httpResponse->getStatusCode() === 409 or $httpResponse->getStatusCode() === 480 or $httpResponse->getStatusCode() === 500) {
            if (Utils\Utils::matchContentType($contentType, 'text/xml')) {
                $response->body = $httpResponse->getBody()->getContents();
            }
        }

        return $response;
    }
	
    /**
     * Configures the availability options for a domain. Enabling the Multi-AZ option expands an Amazon CloudSearch domain to an additional Availability Zone in the same Region to increase fault tolerance in the event of a service disruption. Changes to the Multi-AZ option can take about half an hour to become active. For more information, see <a href="http://docs.aws.amazon.com/cloudsearch/latest/developerguide/configuring-availability-options.html" target="_blank">Configuring Availability Options</a> in the <i>Amazon CloudSearch Developer Guide</i>.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\POSTUpdateAvailabilityOptionsRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\POSTUpdateAvailabilityOptionsResponse
     */
	public function postUpdateAvailabilityOptions(
        \OpenAPI\OpenAPI\Models\Operations\POSTUpdateAvailabilityOptionsRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\POSTUpdateAvailabilityOptionsResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/#Action=UpdateAvailabilityOptions');
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "requestBody", "raw");
        $options = array_merge_recursive($options, $body);
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\POSTUpdateAvailabilityOptionsRequest::class, $request, null));
        $options = array_merge_recursive($options, Utils\Utils::getHeaders($request));
        
        $httpResponse = $this->_securityClient->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\POSTUpdateAvailabilityOptionsResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200 or $httpResponse->getStatusCode() === 409 or $httpResponse->getStatusCode() === 480 or $httpResponse->getStatusCode() === 500) {
            if (Utils\Utils::matchContentType($contentType, 'text/xml')) {
                $response->body = $httpResponse->getBody()->getContents();
            }
        }

        return $response;
    }
	
    /**
     * Configures the default search field for the search domain. The default search field is the text field that is searched when a search request does not specify which fields to search. By default, it is configured to include the contents of all of the domain's text fields. 
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\POSTUpdateDefaultSearchFieldRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\POSTUpdateDefaultSearchFieldResponse
     */
	public function postUpdateDefaultSearchField(
        \OpenAPI\OpenAPI\Models\Operations\POSTUpdateDefaultSearchFieldRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\POSTUpdateDefaultSearchFieldResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/#Action=UpdateDefaultSearchField');
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "requestBody", "raw");
        $options = array_merge_recursive($options, $body);
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\POSTUpdateDefaultSearchFieldRequest::class, $request, null));
        $options = array_merge_recursive($options, Utils\Utils::getHeaders($request));
        
        $httpResponse = $this->_securityClient->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\POSTUpdateDefaultSearchFieldResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200 or $httpResponse->getStatusCode() === 409 or $httpResponse->getStatusCode() === 480 or $httpResponse->getStatusCode() === 500) {
            if (Utils\Utils::matchContentType($contentType, 'text/xml')) {
                $response->body = $httpResponse->getBody()->getContents();
            }
        }

        return $response;
    }
	
    /**
     * Configures the policies that control access to the domain's document and search services. The maximum size of an access policy document is 100 KB.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\POSTUpdateServiceAccessPoliciesRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\POSTUpdateServiceAccessPoliciesResponse
     */
	public function postUpdateServiceAccessPolicies(
        \OpenAPI\OpenAPI\Models\Operations\POSTUpdateServiceAccessPoliciesRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\POSTUpdateServiceAccessPoliciesResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/#Action=UpdateServiceAccessPolicies');
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "requestBody", "raw");
        $options = array_merge_recursive($options, $body);
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\POSTUpdateServiceAccessPoliciesRequest::class, $request, null));
        $options = array_merge_recursive($options, Utils\Utils::getHeaders($request));
        
        $httpResponse = $this->_securityClient->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\POSTUpdateServiceAccessPoliciesResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200 or $httpResponse->getStatusCode() === 409 or $httpResponse->getStatusCode() === 480 or $httpResponse->getStatusCode() === 500) {
            if (Utils\Utils::matchContentType($contentType, 'text/xml')) {
                $response->body = $httpResponse->getBody()->getContents();
            }
        }

        return $response;
    }
	
    /**
     * Configures a stemming dictionary for the search domain. The stemming dictionary is used during indexing and when processing search requests. The maximum size of the stemming dictionary is 500 KB.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\POSTUpdateStemmingOptionsRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\POSTUpdateStemmingOptionsResponse
     */
	public function postUpdateStemmingOptions(
        \OpenAPI\OpenAPI\Models\Operations\POSTUpdateStemmingOptionsRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\POSTUpdateStemmingOptionsResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/#Action=UpdateStemmingOptions');
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "requestBody", "raw");
        $options = array_merge_recursive($options, $body);
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\POSTUpdateStemmingOptionsRequest::class, $request, null));
        $options = array_merge_recursive($options, Utils\Utils::getHeaders($request));
        
        $httpResponse = $this->_securityClient->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\POSTUpdateStemmingOptionsResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200 or $httpResponse->getStatusCode() === 409 or $httpResponse->getStatusCode() === 480 or $httpResponse->getStatusCode() === 500) {
            if (Utils\Utils::matchContentType($contentType, 'text/xml')) {
                $response->body = $httpResponse->getBody()->getContents();
            }
        }

        return $response;
    }
	
    /**
     * Configures stopwords for the search domain. Stopwords are used during indexing and when processing search requests. The maximum size of the stopwords dictionary is 10 KB.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\POSTUpdateStopwordOptionsRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\POSTUpdateStopwordOptionsResponse
     */
	public function postUpdateStopwordOptions(
        \OpenAPI\OpenAPI\Models\Operations\POSTUpdateStopwordOptionsRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\POSTUpdateStopwordOptionsResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/#Action=UpdateStopwordOptions');
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "requestBody", "raw");
        $options = array_merge_recursive($options, $body);
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\POSTUpdateStopwordOptionsRequest::class, $request, null));
        $options = array_merge_recursive($options, Utils\Utils::getHeaders($request));
        
        $httpResponse = $this->_securityClient->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\POSTUpdateStopwordOptionsResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200 or $httpResponse->getStatusCode() === 409 or $httpResponse->getStatusCode() === 480 or $httpResponse->getStatusCode() === 500) {
            if (Utils\Utils::matchContentType($contentType, 'text/xml')) {
                $response->body = $httpResponse->getBody()->getContents();
            }
        }

        return $response;
    }
	
    /**
     * Configures a synonym dictionary for the search domain. The synonym dictionary is used during indexing to configure mappings for terms that occur in text fields. The maximum size of the synonym dictionary is 100 KB. 
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\POSTUpdateSynonymOptionsRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\POSTUpdateSynonymOptionsResponse
     */
	public function postUpdateSynonymOptions(
        \OpenAPI\OpenAPI\Models\Operations\POSTUpdateSynonymOptionsRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\POSTUpdateSynonymOptionsResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/#Action=UpdateSynonymOptions');
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "requestBody", "raw");
        $options = array_merge_recursive($options, $body);
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\POSTUpdateSynonymOptionsRequest::class, $request, null));
        $options = array_merge_recursive($options, Utils\Utils::getHeaders($request));
        
        $httpResponse = $this->_securityClient->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\POSTUpdateSynonymOptionsResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200 or $httpResponse->getStatusCode() === 409 or $httpResponse->getStatusCode() === 480 or $httpResponse->getStatusCode() === 500) {
            if (Utils\Utils::matchContentType($contentType, 'text/xml')) {
                $response->body = $httpResponse->getBody()->getContents();
            }
        }

        return $response;
    }
}