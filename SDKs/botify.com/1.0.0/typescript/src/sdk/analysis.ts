/*
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

import * as utils from "../internal/utils";
import * as operations from "./models/operations";
import * as shared from "./models/shared";
import { AxiosInstance, AxiosRequestConfig, AxiosResponse } from "axios";

export class Analysis {
  _defaultClient: AxiosInstance;
  _securityClient: AxiosInstance;
  _serverURL: string;
  _language: string;
  _sdkVersion: string;
  _genVersion: string;

  constructor(
    defaultClient: AxiosInstance,
    securityClient: AxiosInstance,
    serverURL: string,
    language: string,
    sdkVersion: string,
    genVersion: string
  ) {
    this._defaultClient = defaultClient;
    this._securityClient = securityClient;
    this._serverURL = serverURL;
    this._language = language;
    this._sdkVersion = sdkVersion;
    this._genVersion = genVersion;
  }

  /**
   * Creates a new UrlExport object and starts a task that will export the results into a csv
   *
   * @remarks
   * Creates a new UrlExport object and starts a task that will export the results into a csv. Returns the model id that manages the task
   */
  createUrlsExport(
    req: operations.CreateUrlsExportRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.CreateUrlsExportResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CreateUrlsExportRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/analyses/{username}/{project_slug}/{analysis_slug}/urls/export",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "urlsQuery",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CreateUrlsExportResponse =
        new operations.CreateUrlsExportResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.csvExportStatus = utils.objectToClass(
              httpRes?.data,
              shared.CsvExportStatus
            );
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.defaultPayload = utils.objectToClass(
              httpRes?.data,
              shared.DefaultPayload
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Get an Analysis detail
   *
   * @remarks
   * Get an Analysis detail
   */
  getAnalysisSummary(
    req: operations.GetAnalysisSummaryRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetAnalysisSummaryResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetAnalysisSummaryRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/analyses/{username}/{project_slug}/{analysis_slug}",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetAnalysisSummaryResponse =
        new operations.GetAnalysisSummaryResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.analysisDetail = utils.objectToClass(
              httpRes?.data,
              shared.AnalysisDetail
            );
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.defaultPayload = utils.objectToClass(
              httpRes?.data,
              shared.DefaultPayload
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Return global statistics for an analysis
   *
   * @remarks
   * Return global statistics for an analysis
   */
  getCrawlStatistics(
    req: operations.GetCrawlStatisticsRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetCrawlStatisticsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetCrawlStatisticsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/analyses/{username}/{project_slug}/{analysis_slug}/crawl_statistics",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetCrawlStatisticsResponse =
        new operations.GetCrawlStatisticsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.crawlStatistics = utils.objectToClass(
              httpRes?.data,
              shared.CrawlStatistics
            );
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.defaultPayload = utils.objectToClass(
              httpRes?.data,
              shared.DefaultPayload
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Return crawl statistics grouped by time frequency (1 min, 5 mins or 60 min)
   *
   * @remarks
   * Return crawl statistics grouped by time frequency (1 min, 5 mins or 60 min) for an analysis
   */
  getCrawlStatisticsByFrequency(
    req: operations.GetCrawlStatisticsByFrequencyRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetCrawlStatisticsByFrequencyResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetCrawlStatisticsByFrequencyRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/analyses/{username}/{project_slug}/{analysis_slug}/crawl_statistics/time",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetCrawlStatisticsByFrequencyResponse =
        new operations.GetCrawlStatisticsByFrequencyResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.crawlStatisticsTime = utils.objectToClass(
              httpRes?.data,
              shared.CrawlStatisticsTime
            );
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.defaultPayload = utils.objectToClass(
              httpRes?.data,
              shared.DefaultPayload
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Return a list of 1000 latest URLs crawled (all crawled URLs or only URLS with HTTP errors)
   *
   * @remarks
   * Return a list of 1000 latest URLs crawled (all crawled URLs or only URLS with HTTP errors)
   */
  getCrawlStatisticsUrls(
    req: operations.GetCrawlStatisticsUrlsRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetCrawlStatisticsUrlsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetCrawlStatisticsUrlsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/analyses/{username}/{project_slug}/{analysis_slug}/crawl_statistics/urls/{list_type}",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetCrawlStatisticsUrlsResponse =
        new operations.GetCrawlStatisticsUrlsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getCrawlStatisticsUrls200ApplicationJSONAnies =
              utils.objectToClass(httpRes?.data);
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.defaultPayload = utils.objectToClass(
              httpRes?.data,
              shared.DefaultPayload
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * List of Orphan URLs
   *
   * @remarks
   * List of Orphan URLs. URLs which generated visits from the selected source according to Google Analytics data, but were not crawled with by the Botify crawler (either because no links to them were found on the website, or because the crawler was not allowed to follow these links according to the project settings).   For a search engine (medium: origanic; sources: all, aol, ask, baidu, bing, google, naver, yahoo, yandex) or a social network (medium: social; sources: all, facebook, google+, linkedin, pinterest, reddit, tumblr, twitter)
   */
  getGanalyticsOrphanURLs(
    req: operations.GetGanalyticsOrphanURLsRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetGanalyticsOrphanURLsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetGanalyticsOrphanURLsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/analyses/{username}/{project_slug}/{analysis_slug}/features/ganalytics/orphan_urls/{medium}/{source}",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetGanalyticsOrphanURLsResponse =
        new operations.GetGanalyticsOrphanURLsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getGanalyticsOrphanURLs200ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.GetGanalyticsOrphanURLs200ApplicationJSON
              );
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.defaultPayload = utils.objectToClass(
              httpRes?.data,
              shared.DefaultPayload
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Get inlinks percentiles
   *
   * @remarks
   * Get inlinks percentiles
   */
  getLinksPercentiles(
    req: operations.GetLinksPercentilesRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetLinksPercentilesResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetLinksPercentilesRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/analyses/{username}/{project_slug}/{analysis_slug}/features/links/percentiles",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetLinksPercentilesResponse =
        new operations.GetLinksPercentilesResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.linksPercentiles = utils.objectToClass(
              httpRes?.data,
              shared.LinksPercentiles
            );
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.defaultPayload = utils.objectToClass(
              httpRes?.data,
              shared.DefaultPayload
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Top domains
   *
   * @remarks
   * Top domains
   */
  getLinksTopDomains(
    req: operations.GetLinksTopDomainsRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetLinksTopDomainsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetLinksTopDomainsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/analyses/{username}/{project_slug}/{analysis_slug}/features/top_domains/domains",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetLinksTopDomainsResponse =
        new operations.GetLinksTopDomainsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getLinksTopDomains200ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.GetLinksTopDomains200ApplicationJSON
              );
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.defaultPayload = utils.objectToClass(
              httpRes?.data,
              shared.DefaultPayload
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Top subddomains
   *
   * @remarks
   * Top subddomains
   */
  getLinksTopSubdomains(
    req: operations.GetLinksTopSubdomainsRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetLinksTopSubdomainsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetLinksTopSubdomainsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/analyses/{username}/{project_slug}/{analysis_slug}/features/top_domains/subdomains",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetLinksTopSubdomainsResponse =
        new operations.GetLinksTopSubdomainsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getLinksTopSubdomains200ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.GetLinksTopSubdomains200ApplicationJSON
              );
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.defaultPayload = utils.objectToClass(
              httpRes?.data,
              shared.DefaultPayload
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Lost pagerank
   *
   * @remarks
   * Lost pagerank
   */
  getPageRankLost(
    req: operations.GetPageRankLostRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetPageRankLostResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetPageRankLostRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/analyses/{username}/{project_slug}/{analysis_slug}/features/pagerank/lost",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetPageRankLostResponse =
        new operations.GetPageRankLostResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.pageRankLost = utils.objectToClass(
              httpRes?.data,
              shared.PageRankLost
            );
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.defaultPayload = utils.objectToClass(
              httpRes?.data,
              shared.DefaultPayload
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Get global information of the sitemaps found (sitemaps indexes, invalid sitemaps urls, etc
   *
   * @remarks
   * Get global information of the sitemaps found (sitemaps indexes, invalid sitemaps urls, etc.)
   */
  getSitemapsReport(
    req: operations.GetSitemapsReportRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetSitemapsReportResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetSitemapsReportRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/analyses/{username}/{project_slug}/{analysis_slug}/features/sitemaps/report",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetSitemapsReportResponse =
        new operations.GetSitemapsReportResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.sitemapsReport = utils.objectToClass(
              httpRes?.data,
              shared.SitemapsReport
            );
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.defaultPayload = utils.objectToClass(
              httpRes?.data,
              shared.DefaultPayload
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Sample list of URLs which were found in your sitemaps but outside of the
   *
   * @remarks
   * Sample list of URLs which were found in your sitemaps but outside of the crawl perimeter defined for the project, for instance domain/subdomain or protocol (HTTP/HTTPS) not allowed in the crawl settings.
   */
  getSitemapsSamplesOutOfConfig(
    req: operations.GetSitemapsSamplesOutOfConfigRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetSitemapsSamplesOutOfConfigResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetSitemapsSamplesOutOfConfigRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/analyses/{username}/{project_slug}/{analysis_slug}/features/sitemaps/samples/out_of_config",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetSitemapsSamplesOutOfConfigResponse =
        new operations.GetSitemapsSamplesOutOfConfigResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getSitemapsSamplesOutOfConfig200ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.GetSitemapsSamplesOutOfConfig200ApplicationJSON
              );
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.defaultPayload = utils.objectToClass(
              httpRes?.data,
              shared.DefaultPayload
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Sample list of URLs which were found in your sitemaps, within the project
   *
   * @remarks
   * Sample list of URLs which were found in your sitemaps, within the project allowed scope (allowed domains/subdomains/protocols), but not found by the Botify crawler.
   */
  getSitemapsSamplesSitemapsOnly(
    req: operations.GetSitemapsSamplesSitemapsOnlyRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetSitemapsSamplesSitemapsOnlyResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetSitemapsSamplesSitemapsOnlyRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/analyses/{username}/{project_slug}/{analysis_slug}/features/sitemaps/samples/sitemap_only",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetSitemapsSamplesSitemapsOnlyResponse =
        new operations.GetSitemapsSamplesSitemapsOnlyResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getSitemapsSamplesSitemapsOnly200ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.GetSitemapsSamplesSitemapsOnly200ApplicationJSON
              );
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.defaultPayload = utils.objectToClass(
              httpRes?.data,
              shared.DefaultPayload
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Gets the detail of an URL for an analysis
   *
   * @remarks
   * Gets the detail of an URL for an analysis
   */
  getUrlDetail(
    req: operations.GetUrlDetailRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetUrlDetailResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetUrlDetailRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/analyses/{username}/{project_slug}/{analysis_slug}/urls/{url}",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetUrlDetailResponse =
        new operations.GetUrlDetailResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.urlDetail = utils.objectToClass(httpRes?.data);
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.defaultPayload = utils.objectToClass(
              httpRes?.data,
              shared.DefaultPayload
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Executes a query and returns a paginated response
   *
   * @remarks
   * Executes a query and returns a paginated response
   */
  getUrls(
    req: operations.GetUrlsRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetUrlsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetUrlsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/analyses/{username}/{project_slug}/{analysis_slug}/urls",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "urlsQuery",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetUrlsResponse = new operations.GetUrlsResponse({
        statusCode: httpRes.status,
        contentType: contentType,
        rawResponse: httpRes,
      });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getUrls200ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.GetUrls200ApplicationJSON
            );
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.defaultPayload = utils.objectToClass(
              httpRes?.data,
              shared.DefaultPayload
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Query aggregator
   *
   * @remarks
   * Query aggregator. It accepts multiple queries
   */
  getUrlsAggs(
    req: operations.GetUrlsAggsRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetUrlsAggsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetUrlsAggsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/analyses/{username}/{project_slug}/{analysis_slug}/urls/aggs",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetUrlsAggsResponse =
        new operations.GetUrlsAggsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getUrlsAggs200ApplicationJSONAnies = utils.objectToClass(
              httpRes?.data
            );
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.defaultPayload = utils.objectToClass(
              httpRes?.data,
              shared.DefaultPayload
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Gets an Analysis datamodel
   *
   * @remarks
   * Gets an Analysis datamodel
   */
  getUrlsDatamodel(
    req: operations.GetUrlsDatamodelRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetUrlsDatamodelResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetUrlsDatamodelRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/analyses/{username}/{project_slug}/{analysis_slug}/urls/datamodel",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetUrlsDatamodelResponse =
        new operations.GetUrlsDatamodelResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.crawlDatamodel = utils.objectToClass(
              httpRes?.data,
              shared.CrawlDatamodel
            );
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.defaultPayload = utils.objectToClass(
              httpRes?.data,
              shared.DefaultPayload
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Checks the status of an CSVUrlExportJob object
   *
   * @remarks
   * Checks the status of an CSVUrlExportJob object. Returns json object with the status.
   */
  getUrlsExportStatus(
    req: operations.GetUrlsExportStatusRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetUrlsExportStatusResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetUrlsExportStatusRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/analyses/{username}/{project_slug}/{analysis_slug}/urls/export/{url_export_id}",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetUrlsExportStatusResponse =
        new operations.GetUrlsExportStatusResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.csvExportStatus = utils.objectToClass(
              httpRes?.data,
              shared.CsvExportStatus
            );
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.defaultPayload = utils.objectToClass(
              httpRes?.data,
              shared.DefaultPayload
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * A list of the CSV Exports requests and their current status
   *
   * @remarks
   * A list of the CSV Exports requests and their current status
   */
  getUrlsExports(
    req: operations.GetUrlsExportsRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetUrlsExportsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetUrlsExportsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/analyses/{username}/{project_slug}/{analysis_slug}/urls/export",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetUrlsExportsResponse =
        new operations.GetUrlsExportsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getUrlsExports200ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.GetUrlsExports200ApplicationJSON
            );
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.defaultPayload = utils.objectToClass(
              httpRes?.data,
              shared.DefaultPayload
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Return most frequent segments (= suggested patterns in the previous version)
   *
   * @remarks
   * Return most frequent segments (= suggested patterns in the previous version) for a Botify Query.
   */
  getUrlsSuggestedFilters(
    req: operations.GetUrlsSuggestedFiltersRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetUrlsSuggestedFiltersResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetUrlsSuggestedFiltersRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/analyses/{username}/{project_slug}/{analysis_slug}/urls/suggested_filters",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "urlsAggsQuery",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetUrlsSuggestedFiltersResponse =
        new operations.GetUrlsSuggestedFiltersResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.urlsAggsQuery = utils.objectToClass(
              httpRes?.data,
              shared.UrlsAggsQuery
            );
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.defaultPayload = utils.objectToClass(
              httpRes?.data,
              shared.DefaultPayload
            );
          }
          break;
      }

      return res;
    });
  }
}
