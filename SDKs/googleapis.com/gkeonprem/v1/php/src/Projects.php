<?php

/**
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

declare(strict_types=1);

namespace OpenAPI\OpenAPI;

class Projects 
{

	// SDK private variables namespaced with _ to avoid conflicts with API models
	private \GuzzleHttp\ClientInterface $_defaultClient;
	private \GuzzleHttp\ClientInterface $_securityClient;
	private string $_serverUrl;
	private string $_language;
	private string $_sdkVersion;
	private string $_genVersion;	

	/**
	 * @param \GuzzleHttp\ClientInterface $defaultClient
	 * @param \GuzzleHttp\ClientInterface $securityClient
	 * @param string $serverUrl
	 * @param string $language
	 * @param string $sdkVersion
	 * @param string $genVersion
	 */
	public function __construct(\GuzzleHttp\ClientInterface $defaultClient, \GuzzleHttp\ClientInterface $securityClient, string $serverUrl, string $language, string $sdkVersion, string $genVersion)
	{
		$this->_defaultClient = $defaultClient;
		$this->_securityClient = $securityClient;
		$this->_serverUrl = $serverUrl;
		$this->_language = $language;
		$this->_sdkVersion = $sdkVersion;
		$this->_genVersion = $genVersion;
	}
	
    /**
     * Creates a new bare metal admin cluster in a given project and location. The API needs to be combined with creating a bootstrap cluster to work. See: https://cloud.google.com/anthos/clusters/docs/bare-metal/latest/installing/creating-clusters/create-admin-cluster-api#prepare_bootstrap_environment
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GkeonpremProjectsLocationsBareMetalAdminClustersCreateRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\GkeonpremProjectsLocationsBareMetalAdminClustersCreateSecurity $security
     * @return \OpenAPI\OpenAPI\Models\Operations\GkeonpremProjectsLocationsBareMetalAdminClustersCreateResponse
     */
	public function gkeonpremProjectsLocationsBareMetalAdminClustersCreate(
        \OpenAPI\OpenAPI\Models\Operations\GkeonpremProjectsLocationsBareMetalAdminClustersCreateRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\GkeonpremProjectsLocationsBareMetalAdminClustersCreateSecurity $security,
    ): \OpenAPI\OpenAPI\Models\Operations\GkeonpremProjectsLocationsBareMetalAdminClustersCreateResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v1/{parent}/bareMetalAdminClusters', \OpenAPI\OpenAPI\Models\Operations\GkeonpremProjectsLocationsBareMetalAdminClustersCreateRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "bareMetalAdminClusterInput", "json");
        $options = array_merge_recursive($options, $body);
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\GkeonpremProjectsLocationsBareMetalAdminClustersCreateRequest::class, $request, null));
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GkeonpremProjectsLocationsBareMetalAdminClustersCreateResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->operation = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\Operation', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Enrolls an existing bare metal admin cluster to the Anthos On-Prem API within a given project and location. Through enrollment, an existing admin cluster will become Anthos On-Prem API managed. The corresponding GCP resources will be created and all future modifications to the cluster will be expected to be performed through the API.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GkeonpremProjectsLocationsBareMetalAdminClustersEnrollRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\GkeonpremProjectsLocationsBareMetalAdminClustersEnrollSecurity $security
     * @return \OpenAPI\OpenAPI\Models\Operations\GkeonpremProjectsLocationsBareMetalAdminClustersEnrollResponse
     */
	public function gkeonpremProjectsLocationsBareMetalAdminClustersEnroll(
        \OpenAPI\OpenAPI\Models\Operations\GkeonpremProjectsLocationsBareMetalAdminClustersEnrollRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\GkeonpremProjectsLocationsBareMetalAdminClustersEnrollSecurity $security,
    ): \OpenAPI\OpenAPI\Models\Operations\GkeonpremProjectsLocationsBareMetalAdminClustersEnrollResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v1/{parent}/bareMetalAdminClusters:enroll', \OpenAPI\OpenAPI\Models\Operations\GkeonpremProjectsLocationsBareMetalAdminClustersEnrollRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "enrollBareMetalAdminClusterRequest", "json");
        $options = array_merge_recursive($options, $body);
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\GkeonpremProjectsLocationsBareMetalAdminClustersEnrollRequest::class, $request, null));
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GkeonpremProjectsLocationsBareMetalAdminClustersEnrollResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->operation = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\Operation', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Lists bare metal admin clusters in a given project and location.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GkeonpremProjectsLocationsBareMetalAdminClustersListRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\GkeonpremProjectsLocationsBareMetalAdminClustersListSecurity $security
     * @return \OpenAPI\OpenAPI\Models\Operations\GkeonpremProjectsLocationsBareMetalAdminClustersListResponse
     */
	public function gkeonpremProjectsLocationsBareMetalAdminClustersList(
        \OpenAPI\OpenAPI\Models\Operations\GkeonpremProjectsLocationsBareMetalAdminClustersListRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\GkeonpremProjectsLocationsBareMetalAdminClustersListSecurity $security,
    ): \OpenAPI\OpenAPI\Models\Operations\GkeonpremProjectsLocationsBareMetalAdminClustersListResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v1/{parent}/bareMetalAdminClusters', \OpenAPI\OpenAPI\Models\Operations\GkeonpremProjectsLocationsBareMetalAdminClustersListRequest::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\GkeonpremProjectsLocationsBareMetalAdminClustersListRequest::class, $request, null));
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GkeonpremProjectsLocationsBareMetalAdminClustersListResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->listBareMetalAdminClustersResponse = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\ListBareMetalAdminClustersResponse', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Queries the bare metal admin cluster version config.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GkeonpremProjectsLocationsBareMetalAdminClustersQueryVersionConfigRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\GkeonpremProjectsLocationsBareMetalAdminClustersQueryVersionConfigSecurity $security
     * @return \OpenAPI\OpenAPI\Models\Operations\GkeonpremProjectsLocationsBareMetalAdminClustersQueryVersionConfigResponse
     */
	public function gkeonpremProjectsLocationsBareMetalAdminClustersQueryVersionConfig(
        \OpenAPI\OpenAPI\Models\Operations\GkeonpremProjectsLocationsBareMetalAdminClustersQueryVersionConfigRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\GkeonpremProjectsLocationsBareMetalAdminClustersQueryVersionConfigSecurity $security,
    ): \OpenAPI\OpenAPI\Models\Operations\GkeonpremProjectsLocationsBareMetalAdminClustersQueryVersionConfigResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v1/{parent}/bareMetalAdminClusters:queryVersionConfig', \OpenAPI\OpenAPI\Models\Operations\GkeonpremProjectsLocationsBareMetalAdminClustersQueryVersionConfigRequest::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\GkeonpremProjectsLocationsBareMetalAdminClustersQueryVersionConfigRequest::class, $request, null));
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GkeonpremProjectsLocationsBareMetalAdminClustersQueryVersionConfigResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->queryBareMetalAdminVersionConfigResponse = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\QueryBareMetalAdminVersionConfigResponse', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Creates a new bare metal node pool in a given project, location and Bare Metal cluster.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GkeonpremProjectsLocationsBareMetalClustersBareMetalNodePoolsCreateRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\GkeonpremProjectsLocationsBareMetalClustersBareMetalNodePoolsCreateSecurity $security
     * @return \OpenAPI\OpenAPI\Models\Operations\GkeonpremProjectsLocationsBareMetalClustersBareMetalNodePoolsCreateResponse
     */
	public function gkeonpremProjectsLocationsBareMetalClustersBareMetalNodePoolsCreate(
        \OpenAPI\OpenAPI\Models\Operations\GkeonpremProjectsLocationsBareMetalClustersBareMetalNodePoolsCreateRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\GkeonpremProjectsLocationsBareMetalClustersBareMetalNodePoolsCreateSecurity $security,
    ): \OpenAPI\OpenAPI\Models\Operations\GkeonpremProjectsLocationsBareMetalClustersBareMetalNodePoolsCreateResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v1/{parent}/bareMetalNodePools', \OpenAPI\OpenAPI\Models\Operations\GkeonpremProjectsLocationsBareMetalClustersBareMetalNodePoolsCreateRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "bareMetalNodePoolInput", "json");
        $options = array_merge_recursive($options, $body);
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\GkeonpremProjectsLocationsBareMetalClustersBareMetalNodePoolsCreateRequest::class, $request, null));
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GkeonpremProjectsLocationsBareMetalClustersBareMetalNodePoolsCreateResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->operation = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\Operation', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Enrolls an existing bare metal node pool to the Anthos On-Prem API within a given project and location. Through enrollment, an existing node pool will become Anthos On-Prem API managed. The corresponding GCP resources will be created.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GkeonpremProjectsLocationsBareMetalClustersBareMetalNodePoolsEnrollRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\GkeonpremProjectsLocationsBareMetalClustersBareMetalNodePoolsEnrollSecurity $security
     * @return \OpenAPI\OpenAPI\Models\Operations\GkeonpremProjectsLocationsBareMetalClustersBareMetalNodePoolsEnrollResponse
     */
	public function gkeonpremProjectsLocationsBareMetalClustersBareMetalNodePoolsEnroll(
        \OpenAPI\OpenAPI\Models\Operations\GkeonpremProjectsLocationsBareMetalClustersBareMetalNodePoolsEnrollRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\GkeonpremProjectsLocationsBareMetalClustersBareMetalNodePoolsEnrollSecurity $security,
    ): \OpenAPI\OpenAPI\Models\Operations\GkeonpremProjectsLocationsBareMetalClustersBareMetalNodePoolsEnrollResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v1/{parent}/bareMetalNodePools:enroll', \OpenAPI\OpenAPI\Models\Operations\GkeonpremProjectsLocationsBareMetalClustersBareMetalNodePoolsEnrollRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "enrollBareMetalNodePoolRequest", "json");
        $options = array_merge_recursive($options, $body);
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\GkeonpremProjectsLocationsBareMetalClustersBareMetalNodePoolsEnrollRequest::class, $request, null));
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GkeonpremProjectsLocationsBareMetalClustersBareMetalNodePoolsEnrollResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->operation = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\Operation', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Lists bare metal node pools in a given project, location and bare metal cluster.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GkeonpremProjectsLocationsBareMetalClustersBareMetalNodePoolsListRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\GkeonpremProjectsLocationsBareMetalClustersBareMetalNodePoolsListSecurity $security
     * @return \OpenAPI\OpenAPI\Models\Operations\GkeonpremProjectsLocationsBareMetalClustersBareMetalNodePoolsListResponse
     */
	public function gkeonpremProjectsLocationsBareMetalClustersBareMetalNodePoolsList(
        \OpenAPI\OpenAPI\Models\Operations\GkeonpremProjectsLocationsBareMetalClustersBareMetalNodePoolsListRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\GkeonpremProjectsLocationsBareMetalClustersBareMetalNodePoolsListSecurity $security,
    ): \OpenAPI\OpenAPI\Models\Operations\GkeonpremProjectsLocationsBareMetalClustersBareMetalNodePoolsListResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v1/{parent}/bareMetalNodePools', \OpenAPI\OpenAPI\Models\Operations\GkeonpremProjectsLocationsBareMetalClustersBareMetalNodePoolsListRequest::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\GkeonpremProjectsLocationsBareMetalClustersBareMetalNodePoolsListRequest::class, $request, null));
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GkeonpremProjectsLocationsBareMetalClustersBareMetalNodePoolsListResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->listBareMetalNodePoolsResponse = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\ListBareMetalNodePoolsResponse', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Creates a new bare metal cluster in a given project and location.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GkeonpremProjectsLocationsBareMetalClustersCreateRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\GkeonpremProjectsLocationsBareMetalClustersCreateSecurity $security
     * @return \OpenAPI\OpenAPI\Models\Operations\GkeonpremProjectsLocationsBareMetalClustersCreateResponse
     */
	public function gkeonpremProjectsLocationsBareMetalClustersCreate(
        \OpenAPI\OpenAPI\Models\Operations\GkeonpremProjectsLocationsBareMetalClustersCreateRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\GkeonpremProjectsLocationsBareMetalClustersCreateSecurity $security,
    ): \OpenAPI\OpenAPI\Models\Operations\GkeonpremProjectsLocationsBareMetalClustersCreateResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v1/{parent}/bareMetalClusters', \OpenAPI\OpenAPI\Models\Operations\GkeonpremProjectsLocationsBareMetalClustersCreateRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "bareMetalClusterInput", "json");
        $options = array_merge_recursive($options, $body);
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\GkeonpremProjectsLocationsBareMetalClustersCreateRequest::class, $request, null));
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GkeonpremProjectsLocationsBareMetalClustersCreateResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->operation = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\Operation', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Enrolls an existing bare metal user cluster and its node pools to the Anthos On-Prem API within a given project and location. Through enrollment, an existing cluster will become Anthos On-Prem API managed. The corresponding GCP resources will be created and all future modifications to the cluster and/or its node pools will be expected to be performed through the API.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GkeonpremProjectsLocationsBareMetalClustersEnrollRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\GkeonpremProjectsLocationsBareMetalClustersEnrollSecurity $security
     * @return \OpenAPI\OpenAPI\Models\Operations\GkeonpremProjectsLocationsBareMetalClustersEnrollResponse
     */
	public function gkeonpremProjectsLocationsBareMetalClustersEnroll(
        \OpenAPI\OpenAPI\Models\Operations\GkeonpremProjectsLocationsBareMetalClustersEnrollRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\GkeonpremProjectsLocationsBareMetalClustersEnrollSecurity $security,
    ): \OpenAPI\OpenAPI\Models\Operations\GkeonpremProjectsLocationsBareMetalClustersEnrollResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v1/{parent}/bareMetalClusters:enroll', \OpenAPI\OpenAPI\Models\Operations\GkeonpremProjectsLocationsBareMetalClustersEnrollRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "enrollBareMetalClusterRequest", "json");
        $options = array_merge_recursive($options, $body);
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\GkeonpremProjectsLocationsBareMetalClustersEnrollRequest::class, $request, null));
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GkeonpremProjectsLocationsBareMetalClustersEnrollResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->operation = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\Operation', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Lists bare metal clusters in a given project and location.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GkeonpremProjectsLocationsBareMetalClustersListRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\GkeonpremProjectsLocationsBareMetalClustersListSecurity $security
     * @return \OpenAPI\OpenAPI\Models\Operations\GkeonpremProjectsLocationsBareMetalClustersListResponse
     */
	public function gkeonpremProjectsLocationsBareMetalClustersList(
        \OpenAPI\OpenAPI\Models\Operations\GkeonpremProjectsLocationsBareMetalClustersListRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\GkeonpremProjectsLocationsBareMetalClustersListSecurity $security,
    ): \OpenAPI\OpenAPI\Models\Operations\GkeonpremProjectsLocationsBareMetalClustersListResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v1/{parent}/bareMetalClusters', \OpenAPI\OpenAPI\Models\Operations\GkeonpremProjectsLocationsBareMetalClustersListRequest::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\GkeonpremProjectsLocationsBareMetalClustersListRequest::class, $request, null));
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GkeonpremProjectsLocationsBareMetalClustersListResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->listBareMetalClustersResponse = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\ListBareMetalClustersResponse', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Queries the bare metal user cluster version config.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GkeonpremProjectsLocationsBareMetalClustersQueryVersionConfigRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\GkeonpremProjectsLocationsBareMetalClustersQueryVersionConfigSecurity $security
     * @return \OpenAPI\OpenAPI\Models\Operations\GkeonpremProjectsLocationsBareMetalClustersQueryVersionConfigResponse
     */
	public function gkeonpremProjectsLocationsBareMetalClustersQueryVersionConfig(
        \OpenAPI\OpenAPI\Models\Operations\GkeonpremProjectsLocationsBareMetalClustersQueryVersionConfigRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\GkeonpremProjectsLocationsBareMetalClustersQueryVersionConfigSecurity $security,
    ): \OpenAPI\OpenAPI\Models\Operations\GkeonpremProjectsLocationsBareMetalClustersQueryVersionConfigResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v1/{parent}/bareMetalClusters:queryVersionConfig', \OpenAPI\OpenAPI\Models\Operations\GkeonpremProjectsLocationsBareMetalClustersQueryVersionConfigRequest::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\GkeonpremProjectsLocationsBareMetalClustersQueryVersionConfigRequest::class, $request, null));
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GkeonpremProjectsLocationsBareMetalClustersQueryVersionConfigResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->queryBareMetalVersionConfigResponse = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\QueryBareMetalVersionConfigResponse', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Lists information about the supported locations for this service.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GkeonpremProjectsLocationsListRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\GkeonpremProjectsLocationsListSecurity $security
     * @return \OpenAPI\OpenAPI\Models\Operations\GkeonpremProjectsLocationsListResponse
     */
	public function gkeonpremProjectsLocationsList(
        \OpenAPI\OpenAPI\Models\Operations\GkeonpremProjectsLocationsListRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\GkeonpremProjectsLocationsListSecurity $security,
    ): \OpenAPI\OpenAPI\Models\Operations\GkeonpremProjectsLocationsListResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v1/{name}/locations', \OpenAPI\OpenAPI\Models\Operations\GkeonpremProjectsLocationsListRequest::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\GkeonpremProjectsLocationsListRequest::class, $request, null));
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GkeonpremProjectsLocationsListResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->listLocationsResponse = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\ListLocationsResponse', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Starts asynchronous cancellation on a long-running operation. The server makes a best effort to cancel the operation, but success is not guaranteed. If the server doesn't support this method, it returns `google.rpc.Code.UNIMPLEMENTED`. Clients can use Operations.GetOperation or other methods to check whether the cancellation succeeded or whether the operation completed despite cancellation. On successful cancellation, the operation is not deleted; instead, it becomes an operation with an Operation.error value with a google.rpc.Status.code of 1, corresponding to `Code.CANCELLED`.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GkeonpremProjectsLocationsOperationsCancelRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\GkeonpremProjectsLocationsOperationsCancelSecurity $security
     * @return \OpenAPI\OpenAPI\Models\Operations\GkeonpremProjectsLocationsOperationsCancelResponse
     */
	public function gkeonpremProjectsLocationsOperationsCancel(
        \OpenAPI\OpenAPI\Models\Operations\GkeonpremProjectsLocationsOperationsCancelRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\GkeonpremProjectsLocationsOperationsCancelSecurity $security,
    ): \OpenAPI\OpenAPI\Models\Operations\GkeonpremProjectsLocationsOperationsCancelResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v1/{name}:cancel', \OpenAPI\OpenAPI\Models\Operations\GkeonpremProjectsLocationsOperationsCancelRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "requestBody", "json");
        $options = array_merge_recursive($options, $body);
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\GkeonpremProjectsLocationsOperationsCancelRequest::class, $request, null));
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GkeonpremProjectsLocationsOperationsCancelResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->empty = $serializer->deserialize((string)$httpResponse->getBody(), 'array<string, mixed>', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Enrolls an existing VMware admin cluster to the Anthos On-Prem API within a given project and location. Through enrollment, an existing admin cluster will become Anthos On-Prem API managed. The corresponding GCP resources will be created and all future modifications to the cluster will be expected to be performed through the API.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GkeonpremProjectsLocationsVmwareAdminClustersEnrollRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\GkeonpremProjectsLocationsVmwareAdminClustersEnrollSecurity $security
     * @return \OpenAPI\OpenAPI\Models\Operations\GkeonpremProjectsLocationsVmwareAdminClustersEnrollResponse
     */
	public function gkeonpremProjectsLocationsVmwareAdminClustersEnroll(
        \OpenAPI\OpenAPI\Models\Operations\GkeonpremProjectsLocationsVmwareAdminClustersEnrollRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\GkeonpremProjectsLocationsVmwareAdminClustersEnrollSecurity $security,
    ): \OpenAPI\OpenAPI\Models\Operations\GkeonpremProjectsLocationsVmwareAdminClustersEnrollResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v1/{parent}/vmwareAdminClusters:enroll', \OpenAPI\OpenAPI\Models\Operations\GkeonpremProjectsLocationsVmwareAdminClustersEnrollRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "enrollVmwareAdminClusterRequest", "json");
        $options = array_merge_recursive($options, $body);
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\GkeonpremProjectsLocationsVmwareAdminClustersEnrollRequest::class, $request, null));
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GkeonpremProjectsLocationsVmwareAdminClustersEnrollResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->operation = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\Operation', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Lists VMware admin clusters in a given project and location.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GkeonpremProjectsLocationsVmwareAdminClustersListRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\GkeonpremProjectsLocationsVmwareAdminClustersListSecurity $security
     * @return \OpenAPI\OpenAPI\Models\Operations\GkeonpremProjectsLocationsVmwareAdminClustersListResponse
     */
	public function gkeonpremProjectsLocationsVmwareAdminClustersList(
        \OpenAPI\OpenAPI\Models\Operations\GkeonpremProjectsLocationsVmwareAdminClustersListRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\GkeonpremProjectsLocationsVmwareAdminClustersListSecurity $security,
    ): \OpenAPI\OpenAPI\Models\Operations\GkeonpremProjectsLocationsVmwareAdminClustersListResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v1/{parent}/vmwareAdminClusters', \OpenAPI\OpenAPI\Models\Operations\GkeonpremProjectsLocationsVmwareAdminClustersListRequest::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\GkeonpremProjectsLocationsVmwareAdminClustersListRequest::class, $request, null));
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GkeonpremProjectsLocationsVmwareAdminClustersListResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->listVmwareAdminClustersResponse = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\ListVmwareAdminClustersResponse', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Creates a new VMware cluster in a given project and location.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GkeonpremProjectsLocationsVmwareClustersCreateRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\GkeonpremProjectsLocationsVmwareClustersCreateSecurity $security
     * @return \OpenAPI\OpenAPI\Models\Operations\GkeonpremProjectsLocationsVmwareClustersCreateResponse
     */
	public function gkeonpremProjectsLocationsVmwareClustersCreate(
        \OpenAPI\OpenAPI\Models\Operations\GkeonpremProjectsLocationsVmwareClustersCreateRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\GkeonpremProjectsLocationsVmwareClustersCreateSecurity $security,
    ): \OpenAPI\OpenAPI\Models\Operations\GkeonpremProjectsLocationsVmwareClustersCreateResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v1/{parent}/vmwareClusters', \OpenAPI\OpenAPI\Models\Operations\GkeonpremProjectsLocationsVmwareClustersCreateRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "vmwareClusterInput", "json");
        $options = array_merge_recursive($options, $body);
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\GkeonpremProjectsLocationsVmwareClustersCreateRequest::class, $request, null));
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GkeonpremProjectsLocationsVmwareClustersCreateResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->operation = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\Operation', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Enrolls an existing VMware user cluster and its node pools to the Anthos On-Prem API within a given project and location. Through enrollment, an existing cluster will become Anthos On-Prem API managed. The corresponding GCP resources will be created and all future modifications to the cluster and/or its node pools will be expected to be performed through the API.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GkeonpremProjectsLocationsVmwareClustersEnrollRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\GkeonpremProjectsLocationsVmwareClustersEnrollSecurity $security
     * @return \OpenAPI\OpenAPI\Models\Operations\GkeonpremProjectsLocationsVmwareClustersEnrollResponse
     */
	public function gkeonpremProjectsLocationsVmwareClustersEnroll(
        \OpenAPI\OpenAPI\Models\Operations\GkeonpremProjectsLocationsVmwareClustersEnrollRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\GkeonpremProjectsLocationsVmwareClustersEnrollSecurity $security,
    ): \OpenAPI\OpenAPI\Models\Operations\GkeonpremProjectsLocationsVmwareClustersEnrollResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v1/{parent}/vmwareClusters:enroll', \OpenAPI\OpenAPI\Models\Operations\GkeonpremProjectsLocationsVmwareClustersEnrollRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "enrollVmwareClusterRequest", "json");
        $options = array_merge_recursive($options, $body);
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\GkeonpremProjectsLocationsVmwareClustersEnrollRequest::class, $request, null));
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GkeonpremProjectsLocationsVmwareClustersEnrollResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->operation = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\Operation', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Lists VMware Clusters in a given project and location.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GkeonpremProjectsLocationsVmwareClustersListRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\GkeonpremProjectsLocationsVmwareClustersListSecurity $security
     * @return \OpenAPI\OpenAPI\Models\Operations\GkeonpremProjectsLocationsVmwareClustersListResponse
     */
	public function gkeonpremProjectsLocationsVmwareClustersList(
        \OpenAPI\OpenAPI\Models\Operations\GkeonpremProjectsLocationsVmwareClustersListRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\GkeonpremProjectsLocationsVmwareClustersListSecurity $security,
    ): \OpenAPI\OpenAPI\Models\Operations\GkeonpremProjectsLocationsVmwareClustersListResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v1/{parent}/vmwareClusters', \OpenAPI\OpenAPI\Models\Operations\GkeonpremProjectsLocationsVmwareClustersListRequest::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\GkeonpremProjectsLocationsVmwareClustersListRequest::class, $request, null));
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GkeonpremProjectsLocationsVmwareClustersListResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->listVmwareClustersResponse = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\ListVmwareClustersResponse', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Queries the VMware user cluster version config.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GkeonpremProjectsLocationsVmwareClustersQueryVersionConfigRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\GkeonpremProjectsLocationsVmwareClustersQueryVersionConfigSecurity $security
     * @return \OpenAPI\OpenAPI\Models\Operations\GkeonpremProjectsLocationsVmwareClustersQueryVersionConfigResponse
     */
	public function gkeonpremProjectsLocationsVmwareClustersQueryVersionConfig(
        \OpenAPI\OpenAPI\Models\Operations\GkeonpremProjectsLocationsVmwareClustersQueryVersionConfigRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\GkeonpremProjectsLocationsVmwareClustersQueryVersionConfigSecurity $security,
    ): \OpenAPI\OpenAPI\Models\Operations\GkeonpremProjectsLocationsVmwareClustersQueryVersionConfigResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v1/{parent}/vmwareClusters:queryVersionConfig', \OpenAPI\OpenAPI\Models\Operations\GkeonpremProjectsLocationsVmwareClustersQueryVersionConfigRequest::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\GkeonpremProjectsLocationsVmwareClustersQueryVersionConfigRequest::class, $request, null));
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GkeonpremProjectsLocationsVmwareClustersQueryVersionConfigResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->queryVmwareVersionConfigResponse = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\QueryVmwareVersionConfigResponse', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Creates a new VMware node pool in a given project, location and VMWare cluster.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GkeonpremProjectsLocationsVmwareClustersVmwareNodePoolsCreateRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\GkeonpremProjectsLocationsVmwareClustersVmwareNodePoolsCreateSecurity $security
     * @return \OpenAPI\OpenAPI\Models\Operations\GkeonpremProjectsLocationsVmwareClustersVmwareNodePoolsCreateResponse
     */
	public function gkeonpremProjectsLocationsVmwareClustersVmwareNodePoolsCreate(
        \OpenAPI\OpenAPI\Models\Operations\GkeonpremProjectsLocationsVmwareClustersVmwareNodePoolsCreateRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\GkeonpremProjectsLocationsVmwareClustersVmwareNodePoolsCreateSecurity $security,
    ): \OpenAPI\OpenAPI\Models\Operations\GkeonpremProjectsLocationsVmwareClustersVmwareNodePoolsCreateResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v1/{parent}/vmwareNodePools', \OpenAPI\OpenAPI\Models\Operations\GkeonpremProjectsLocationsVmwareClustersVmwareNodePoolsCreateRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "vmwareNodePoolInput", "json");
        $options = array_merge_recursive($options, $body);
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\GkeonpremProjectsLocationsVmwareClustersVmwareNodePoolsCreateRequest::class, $request, null));
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GkeonpremProjectsLocationsVmwareClustersVmwareNodePoolsCreateResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->operation = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\Operation', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Deletes a single VMware node pool.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GkeonpremProjectsLocationsVmwareClustersVmwareNodePoolsDeleteRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\GkeonpremProjectsLocationsVmwareClustersVmwareNodePoolsDeleteSecurity $security
     * @return \OpenAPI\OpenAPI\Models\Operations\GkeonpremProjectsLocationsVmwareClustersVmwareNodePoolsDeleteResponse
     */
	public function gkeonpremProjectsLocationsVmwareClustersVmwareNodePoolsDelete(
        \OpenAPI\OpenAPI\Models\Operations\GkeonpremProjectsLocationsVmwareClustersVmwareNodePoolsDeleteRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\GkeonpremProjectsLocationsVmwareClustersVmwareNodePoolsDeleteSecurity $security,
    ): \OpenAPI\OpenAPI\Models\Operations\GkeonpremProjectsLocationsVmwareClustersVmwareNodePoolsDeleteResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v1/{name}', \OpenAPI\OpenAPI\Models\Operations\GkeonpremProjectsLocationsVmwareClustersVmwareNodePoolsDeleteRequest::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\GkeonpremProjectsLocationsVmwareClustersVmwareNodePoolsDeleteRequest::class, $request, null));
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('DELETE', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GkeonpremProjectsLocationsVmwareClustersVmwareNodePoolsDeleteResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->operation = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\Operation', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Enrolls a VMware node pool to Anthos On-Prem API
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GkeonpremProjectsLocationsVmwareClustersVmwareNodePoolsEnrollRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\GkeonpremProjectsLocationsVmwareClustersVmwareNodePoolsEnrollSecurity $security
     * @return \OpenAPI\OpenAPI\Models\Operations\GkeonpremProjectsLocationsVmwareClustersVmwareNodePoolsEnrollResponse
     */
	public function gkeonpremProjectsLocationsVmwareClustersVmwareNodePoolsEnroll(
        \OpenAPI\OpenAPI\Models\Operations\GkeonpremProjectsLocationsVmwareClustersVmwareNodePoolsEnrollRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\GkeonpremProjectsLocationsVmwareClustersVmwareNodePoolsEnrollSecurity $security,
    ): \OpenAPI\OpenAPI\Models\Operations\GkeonpremProjectsLocationsVmwareClustersVmwareNodePoolsEnrollResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v1/{parent}/vmwareNodePools:enroll', \OpenAPI\OpenAPI\Models\Operations\GkeonpremProjectsLocationsVmwareClustersVmwareNodePoolsEnrollRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "enrollVmwareNodePoolRequest", "json");
        $options = array_merge_recursive($options, $body);
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\GkeonpremProjectsLocationsVmwareClustersVmwareNodePoolsEnrollRequest::class, $request, null));
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GkeonpremProjectsLocationsVmwareClustersVmwareNodePoolsEnrollResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->operation = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\Operation', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Gets the access control policy for a resource. Returns an empty policy if the resource exists and does not have a policy set.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GkeonpremProjectsLocationsVmwareClustersVmwareNodePoolsGetIamPolicyRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\GkeonpremProjectsLocationsVmwareClustersVmwareNodePoolsGetIamPolicySecurity $security
     * @return \OpenAPI\OpenAPI\Models\Operations\GkeonpremProjectsLocationsVmwareClustersVmwareNodePoolsGetIamPolicyResponse
     */
	public function gkeonpremProjectsLocationsVmwareClustersVmwareNodePoolsGetIamPolicy(
        \OpenAPI\OpenAPI\Models\Operations\GkeonpremProjectsLocationsVmwareClustersVmwareNodePoolsGetIamPolicyRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\GkeonpremProjectsLocationsVmwareClustersVmwareNodePoolsGetIamPolicySecurity $security,
    ): \OpenAPI\OpenAPI\Models\Operations\GkeonpremProjectsLocationsVmwareClustersVmwareNodePoolsGetIamPolicyResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v1/{resource}:getIamPolicy', \OpenAPI\OpenAPI\Models\Operations\GkeonpremProjectsLocationsVmwareClustersVmwareNodePoolsGetIamPolicyRequest::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\GkeonpremProjectsLocationsVmwareClustersVmwareNodePoolsGetIamPolicyRequest::class, $request, null));
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GkeonpremProjectsLocationsVmwareClustersVmwareNodePoolsGetIamPolicyResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->policy = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\Policy', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Lists VMware node pools in a given project, location and VMWare cluster.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GkeonpremProjectsLocationsVmwareClustersVmwareNodePoolsListRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\GkeonpremProjectsLocationsVmwareClustersVmwareNodePoolsListSecurity $security
     * @return \OpenAPI\OpenAPI\Models\Operations\GkeonpremProjectsLocationsVmwareClustersVmwareNodePoolsListResponse
     */
	public function gkeonpremProjectsLocationsVmwareClustersVmwareNodePoolsList(
        \OpenAPI\OpenAPI\Models\Operations\GkeonpremProjectsLocationsVmwareClustersVmwareNodePoolsListRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\GkeonpremProjectsLocationsVmwareClustersVmwareNodePoolsListSecurity $security,
    ): \OpenAPI\OpenAPI\Models\Operations\GkeonpremProjectsLocationsVmwareClustersVmwareNodePoolsListResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v1/{parent}/vmwareNodePools', \OpenAPI\OpenAPI\Models\Operations\GkeonpremProjectsLocationsVmwareClustersVmwareNodePoolsListRequest::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\GkeonpremProjectsLocationsVmwareClustersVmwareNodePoolsListRequest::class, $request, null));
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GkeonpremProjectsLocationsVmwareClustersVmwareNodePoolsListResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->listVmwareNodePoolsResponse = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\ListVmwareNodePoolsResponse', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Gets the latest state of a long-running operation. Clients can use this method to poll the operation result at intervals as recommended by the API service.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GkeonpremProjectsLocationsVmwareClustersVmwareNodePoolsOperationsGetRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\GkeonpremProjectsLocationsVmwareClustersVmwareNodePoolsOperationsGetSecurity $security
     * @return \OpenAPI\OpenAPI\Models\Operations\GkeonpremProjectsLocationsVmwareClustersVmwareNodePoolsOperationsGetResponse
     */
	public function gkeonpremProjectsLocationsVmwareClustersVmwareNodePoolsOperationsGet(
        \OpenAPI\OpenAPI\Models\Operations\GkeonpremProjectsLocationsVmwareClustersVmwareNodePoolsOperationsGetRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\GkeonpremProjectsLocationsVmwareClustersVmwareNodePoolsOperationsGetSecurity $security,
    ): \OpenAPI\OpenAPI\Models\Operations\GkeonpremProjectsLocationsVmwareClustersVmwareNodePoolsOperationsGetResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v1/{name}', \OpenAPI\OpenAPI\Models\Operations\GkeonpremProjectsLocationsVmwareClustersVmwareNodePoolsOperationsGetRequest::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\GkeonpremProjectsLocationsVmwareClustersVmwareNodePoolsOperationsGetRequest::class, $request, null));
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GkeonpremProjectsLocationsVmwareClustersVmwareNodePoolsOperationsGetResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->operation = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\Operation', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Lists operations that match the specified filter in the request. If the server doesn't support this method, it returns `UNIMPLEMENTED`.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GkeonpremProjectsLocationsVmwareClustersVmwareNodePoolsOperationsListRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\GkeonpremProjectsLocationsVmwareClustersVmwareNodePoolsOperationsListSecurity $security
     * @return \OpenAPI\OpenAPI\Models\Operations\GkeonpremProjectsLocationsVmwareClustersVmwareNodePoolsOperationsListResponse
     */
	public function gkeonpremProjectsLocationsVmwareClustersVmwareNodePoolsOperationsList(
        \OpenAPI\OpenAPI\Models\Operations\GkeonpremProjectsLocationsVmwareClustersVmwareNodePoolsOperationsListRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\GkeonpremProjectsLocationsVmwareClustersVmwareNodePoolsOperationsListSecurity $security,
    ): \OpenAPI\OpenAPI\Models\Operations\GkeonpremProjectsLocationsVmwareClustersVmwareNodePoolsOperationsListResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v1/{name}/operations', \OpenAPI\OpenAPI\Models\Operations\GkeonpremProjectsLocationsVmwareClustersVmwareNodePoolsOperationsListRequest::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\GkeonpremProjectsLocationsVmwareClustersVmwareNodePoolsOperationsListRequest::class, $request, null));
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GkeonpremProjectsLocationsVmwareClustersVmwareNodePoolsOperationsListResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->listOperationsResponse = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\ListOperationsResponse', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Updates the parameters of a single VMware node pool.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GkeonpremProjectsLocationsVmwareClustersVmwareNodePoolsPatchRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\GkeonpremProjectsLocationsVmwareClustersVmwareNodePoolsPatchSecurity $security
     * @return \OpenAPI\OpenAPI\Models\Operations\GkeonpremProjectsLocationsVmwareClustersVmwareNodePoolsPatchResponse
     */
	public function gkeonpremProjectsLocationsVmwareClustersVmwareNodePoolsPatch(
        \OpenAPI\OpenAPI\Models\Operations\GkeonpremProjectsLocationsVmwareClustersVmwareNodePoolsPatchRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\GkeonpremProjectsLocationsVmwareClustersVmwareNodePoolsPatchSecurity $security,
    ): \OpenAPI\OpenAPI\Models\Operations\GkeonpremProjectsLocationsVmwareClustersVmwareNodePoolsPatchResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v1/{name}', \OpenAPI\OpenAPI\Models\Operations\GkeonpremProjectsLocationsVmwareClustersVmwareNodePoolsPatchRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "vmwareNodePoolInput", "json");
        $options = array_merge_recursive($options, $body);
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\GkeonpremProjectsLocationsVmwareClustersVmwareNodePoolsPatchRequest::class, $request, null));
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('PATCH', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GkeonpremProjectsLocationsVmwareClustersVmwareNodePoolsPatchResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->operation = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\Operation', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Sets the access control policy on the specified resource. Replaces any existing policy. Can return `NOT_FOUND`, `INVALID_ARGUMENT`, and `PERMISSION_DENIED` errors.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GkeonpremProjectsLocationsVmwareClustersVmwareNodePoolsSetIamPolicyRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\GkeonpremProjectsLocationsVmwareClustersVmwareNodePoolsSetIamPolicySecurity $security
     * @return \OpenAPI\OpenAPI\Models\Operations\GkeonpremProjectsLocationsVmwareClustersVmwareNodePoolsSetIamPolicyResponse
     */
	public function gkeonpremProjectsLocationsVmwareClustersVmwareNodePoolsSetIamPolicy(
        \OpenAPI\OpenAPI\Models\Operations\GkeonpremProjectsLocationsVmwareClustersVmwareNodePoolsSetIamPolicyRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\GkeonpremProjectsLocationsVmwareClustersVmwareNodePoolsSetIamPolicySecurity $security,
    ): \OpenAPI\OpenAPI\Models\Operations\GkeonpremProjectsLocationsVmwareClustersVmwareNodePoolsSetIamPolicyResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v1/{resource}:setIamPolicy', \OpenAPI\OpenAPI\Models\Operations\GkeonpremProjectsLocationsVmwareClustersVmwareNodePoolsSetIamPolicyRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "setIamPolicyRequest", "json");
        $options = array_merge_recursive($options, $body);
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\GkeonpremProjectsLocationsVmwareClustersVmwareNodePoolsSetIamPolicyRequest::class, $request, null));
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GkeonpremProjectsLocationsVmwareClustersVmwareNodePoolsSetIamPolicyResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->policy = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\Policy', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Returns permissions that a caller has on the specified resource. If the resource does not exist, this will return an empty set of permissions, not a `NOT_FOUND` error. Note: This operation is designed to be used for building permission-aware UIs and command-line tools, not for authorization checking. This operation may "fail open" without warning.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GkeonpremProjectsLocationsVmwareClustersVmwareNodePoolsTestIamPermissionsRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\GkeonpremProjectsLocationsVmwareClustersVmwareNodePoolsTestIamPermissionsSecurity $security
     * @return \OpenAPI\OpenAPI\Models\Operations\GkeonpremProjectsLocationsVmwareClustersVmwareNodePoolsTestIamPermissionsResponse
     */
	public function gkeonpremProjectsLocationsVmwareClustersVmwareNodePoolsTestIamPermissions(
        \OpenAPI\OpenAPI\Models\Operations\GkeonpremProjectsLocationsVmwareClustersVmwareNodePoolsTestIamPermissionsRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\GkeonpremProjectsLocationsVmwareClustersVmwareNodePoolsTestIamPermissionsSecurity $security,
    ): \OpenAPI\OpenAPI\Models\Operations\GkeonpremProjectsLocationsVmwareClustersVmwareNodePoolsTestIamPermissionsResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v1/{resource}:testIamPermissions', \OpenAPI\OpenAPI\Models\Operations\GkeonpremProjectsLocationsVmwareClustersVmwareNodePoolsTestIamPermissionsRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "testIamPermissionsRequest", "json");
        $options = array_merge_recursive($options, $body);
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\GkeonpremProjectsLocationsVmwareClustersVmwareNodePoolsTestIamPermissionsRequest::class, $request, null));
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GkeonpremProjectsLocationsVmwareClustersVmwareNodePoolsTestIamPermissionsResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->testIamPermissionsResponse = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\TestIamPermissionsResponse', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Unenrolls a VMware node pool to Anthos On-Prem API
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GkeonpremProjectsLocationsVmwareClustersVmwareNodePoolsUnenrollRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\GkeonpremProjectsLocationsVmwareClustersVmwareNodePoolsUnenrollSecurity $security
     * @return \OpenAPI\OpenAPI\Models\Operations\GkeonpremProjectsLocationsVmwareClustersVmwareNodePoolsUnenrollResponse
     */
	public function gkeonpremProjectsLocationsVmwareClustersVmwareNodePoolsUnenroll(
        \OpenAPI\OpenAPI\Models\Operations\GkeonpremProjectsLocationsVmwareClustersVmwareNodePoolsUnenrollRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\GkeonpremProjectsLocationsVmwareClustersVmwareNodePoolsUnenrollSecurity $security,
    ): \OpenAPI\OpenAPI\Models\Operations\GkeonpremProjectsLocationsVmwareClustersVmwareNodePoolsUnenrollResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v1/{name}:unenroll', \OpenAPI\OpenAPI\Models\Operations\GkeonpremProjectsLocationsVmwareClustersVmwareNodePoolsUnenrollRequest::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\GkeonpremProjectsLocationsVmwareClustersVmwareNodePoolsUnenrollRequest::class, $request, null));
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('DELETE', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GkeonpremProjectsLocationsVmwareClustersVmwareNodePoolsUnenrollResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->operation = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\Operation', 'json');
            }
        }

        return $response;
    }
}