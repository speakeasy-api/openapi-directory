/*
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

import * as utils from "../internal/utils";
import * as operations from "./models/operations";
import * as shared from "./models/shared";
import axios from "axios";
import { AxiosInstance, AxiosRequestConfig, AxiosResponse } from "axios";

/**
 * Contains the list of servers available to the SDK
 */
export const ServerList = ["https://trusthub.twilio.com"] as const;

/**
 * The available configuration options for the SDK
 */
export type SDKProps = {
  /**
   * Allows overriding the default axios client used by the SDK
   */
  defaultClient?: AxiosInstance;
  /**
   * Allows overriding the default server URL used by the SDK
   */
  serverURL?: string;
};

/**
 * This is the public Twilio REST API.
 */
export class SDK {
  public _defaultClient: AxiosInstance;
  public _securityClient: AxiosInstance;
  public _serverURL: string;
  private _language = "typescript";
  private _sdkVersion = "0.0.1";
  private _genVersion = "internal";
  private _globals: any;

  constructor(props?: SDKProps) {
    this._serverURL = props?.serverURL ?? ServerList[0];

    this._defaultClient =
      props?.defaultClient ?? axios.create({ baseURL: this._serverURL });
    this._securityClient = this._defaultClient;
  }

  /**
   * Create a new Customer-Profile.
   */
  createCustomerProfile(
    req: operations.CreateCustomerProfileCreateCustomerProfileRequest,
    security: operations.CreateCustomerProfileSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.CreateCustomerProfileResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CreateCustomerProfileCreateCustomerProfileRequest(
        req
      );
    }

    let baseURL: string = operations.CreateCustomerProfileServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = baseURL.replace(/\/$/, "") + "/v1/CustomerProfiles";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "request",
        "form"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.CreateCustomerProfileSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CreateCustomerProfileResponse =
        new operations.CreateCustomerProfileResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.trusthubV1CustomerProfile = utils.objectToClass(
              httpRes?.data,
              shared.TrusthubV1CustomerProfile
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Create a new Assigned Item.
   */
  createCustomerProfileChannelEndpointAssignment(
    req: operations.CreateCustomerProfileChannelEndpointAssignmentRequest,
    security: operations.CreateCustomerProfileChannelEndpointAssignmentSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.CreateCustomerProfileChannelEndpointAssignmentResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.CreateCustomerProfileChannelEndpointAssignmentRequest(
          req
        );
    }

    let baseURL: string =
      operations.CreateCustomerProfileChannelEndpointAssignmentServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v1/CustomerProfiles/{CustomerProfileSid}/ChannelEndpointAssignments",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "form"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.CreateCustomerProfileChannelEndpointAssignmentSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CreateCustomerProfileChannelEndpointAssignmentResponse =
        new operations.CreateCustomerProfileChannelEndpointAssignmentResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.trusthubV1CustomerProfileCustomerProfileChannelEndpointAssignment =
              utils.objectToClass(
                httpRes?.data,
                shared.TrusthubV1CustomerProfileCustomerProfileChannelEndpointAssignment
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Create a new Assigned Item.
   */
  createCustomerProfileEntityAssignment(
    req: operations.CreateCustomerProfileEntityAssignmentRequest,
    security: operations.CreateCustomerProfileEntityAssignmentSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.CreateCustomerProfileEntityAssignmentResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CreateCustomerProfileEntityAssignmentRequest(req);
    }

    let baseURL: string =
      operations.CreateCustomerProfileEntityAssignmentServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v1/CustomerProfiles/{CustomerProfileSid}/EntityAssignments",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "form"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.CreateCustomerProfileEntityAssignmentSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CreateCustomerProfileEntityAssignmentResponse =
        new operations.CreateCustomerProfileEntityAssignmentResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.trusthubV1CustomerProfileCustomerProfileEntityAssignment =
              utils.objectToClass(
                httpRes?.data,
                shared.TrusthubV1CustomerProfileCustomerProfileEntityAssignment
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Create a new Evaluation
   */
  createCustomerProfileEvaluation(
    req: operations.CreateCustomerProfileEvaluationRequest,
    security: operations.CreateCustomerProfileEvaluationSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.CreateCustomerProfileEvaluationResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CreateCustomerProfileEvaluationRequest(req);
    }

    let baseURL: string =
      operations.CreateCustomerProfileEvaluationServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v1/CustomerProfiles/{CustomerProfileSid}/Evaluations",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "form"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.CreateCustomerProfileEvaluationSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CreateCustomerProfileEvaluationResponse =
        new operations.CreateCustomerProfileEvaluationResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.trusthubV1CustomerProfileCustomerProfileEvaluation =
              utils.objectToClass(
                httpRes?.data,
                shared.TrusthubV1CustomerProfileCustomerProfileEvaluation
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Create a new End User.
   */
  createEndUser(
    req: operations.CreateEndUserCreateEndUserRequest,
    security: operations.CreateEndUserSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.CreateEndUserResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CreateEndUserCreateEndUserRequest(req);
    }

    let baseURL: string = operations.CreateEndUserServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = baseURL.replace(/\/$/, "") + "/v1/EndUsers";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "request",
        "form"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.CreateEndUserSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CreateEndUserResponse =
        new operations.CreateEndUserResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.trusthubV1EndUser = utils.objectToClass(
              httpRes?.data,
              shared.TrusthubV1EndUser
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Create a new Supporting Document.
   */
  createSupportingDocument(
    req: operations.CreateSupportingDocumentCreateSupportingDocumentRequest,
    security: operations.CreateSupportingDocumentSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.CreateSupportingDocumentResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.CreateSupportingDocumentCreateSupportingDocumentRequest(
          req
        );
    }

    let baseURL: string = operations.CreateSupportingDocumentServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = baseURL.replace(/\/$/, "") + "/v1/SupportingDocuments";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "request",
        "form"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.CreateSupportingDocumentSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CreateSupportingDocumentResponse =
        new operations.CreateSupportingDocumentResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.trusthubV1SupportingDocument = utils.objectToClass(
              httpRes?.data,
              shared.TrusthubV1SupportingDocument
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Create a new Customer-Profile.
   */
  createTrustProduct(
    req: operations.CreateTrustProductCreateTrustProductRequest,
    security: operations.CreateTrustProductSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.CreateTrustProductResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CreateTrustProductCreateTrustProductRequest(req);
    }

    let baseURL: string = operations.CreateTrustProductServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = baseURL.replace(/\/$/, "") + "/v1/TrustProducts";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "request",
        "form"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.CreateTrustProductSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CreateTrustProductResponse =
        new operations.CreateTrustProductResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.trusthubV1TrustProduct = utils.objectToClass(
              httpRes?.data,
              shared.TrusthubV1TrustProduct
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Create a new Assigned Item.
   */
  createTrustProductChannelEndpointAssignment(
    req: operations.CreateTrustProductChannelEndpointAssignmentRequest,
    security: operations.CreateTrustProductChannelEndpointAssignmentSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.CreateTrustProductChannelEndpointAssignmentResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CreateTrustProductChannelEndpointAssignmentRequest(
        req
      );
    }

    let baseURL: string =
      operations.CreateTrustProductChannelEndpointAssignmentServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v1/TrustProducts/{TrustProductSid}/ChannelEndpointAssignments",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "form"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.CreateTrustProductChannelEndpointAssignmentSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CreateTrustProductChannelEndpointAssignmentResponse =
        new operations.CreateTrustProductChannelEndpointAssignmentResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.trusthubV1TrustProductTrustProductChannelEndpointAssignment =
              utils.objectToClass(
                httpRes?.data,
                shared.TrusthubV1TrustProductTrustProductChannelEndpointAssignment
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Create a new Assigned Item.
   */
  createTrustProductEntityAssignment(
    req: operations.CreateTrustProductEntityAssignmentRequest,
    security: operations.CreateTrustProductEntityAssignmentSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.CreateTrustProductEntityAssignmentResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CreateTrustProductEntityAssignmentRequest(req);
    }

    let baseURL: string =
      operations.CreateTrustProductEntityAssignmentServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v1/TrustProducts/{TrustProductSid}/EntityAssignments",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "form"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.CreateTrustProductEntityAssignmentSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CreateTrustProductEntityAssignmentResponse =
        new operations.CreateTrustProductEntityAssignmentResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.trusthubV1TrustProductTrustProductEntityAssignment =
              utils.objectToClass(
                httpRes?.data,
                shared.TrusthubV1TrustProductTrustProductEntityAssignment
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Create a new Evaluation
   */
  createTrustProductEvaluation(
    req: operations.CreateTrustProductEvaluationRequest,
    security: operations.CreateTrustProductEvaluationSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.CreateTrustProductEvaluationResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CreateTrustProductEvaluationRequest(req);
    }

    let baseURL: string = operations.CreateTrustProductEvaluationServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v1/TrustProducts/{TrustProductSid}/Evaluations",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "form"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.CreateTrustProductEvaluationSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CreateTrustProductEvaluationResponse =
        new operations.CreateTrustProductEvaluationResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.trusthubV1TrustProductTrustProductEvaluation =
              utils.objectToClass(
                httpRes?.data,
                shared.TrusthubV1TrustProductTrustProductEvaluation
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Delete a specific Customer-Profile.
   */
  deleteCustomerProfile(
    req: operations.DeleteCustomerProfileRequest,
    security: operations.DeleteCustomerProfileSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.DeleteCustomerProfileResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DeleteCustomerProfileRequest(req);
    }

    let baseURL: string = operations.DeleteCustomerProfileServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v1/CustomerProfiles/{Sid}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.DeleteCustomerProfileSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DeleteCustomerProfileResponse =
        new operations.DeleteCustomerProfileResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
      }

      return res;
    });
  }

  /**
   * Remove an Assignment Item Instance.
   */
  deleteCustomerProfileChannelEndpointAssignment(
    req: operations.DeleteCustomerProfileChannelEndpointAssignmentRequest,
    security: operations.DeleteCustomerProfileChannelEndpointAssignmentSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.DeleteCustomerProfileChannelEndpointAssignmentResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.DeleteCustomerProfileChannelEndpointAssignmentRequest(
          req
        );
    }

    let baseURL: string =
      operations.DeleteCustomerProfileChannelEndpointAssignmentServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v1/CustomerProfiles/{CustomerProfileSid}/ChannelEndpointAssignments/{Sid}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.DeleteCustomerProfileChannelEndpointAssignmentSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DeleteCustomerProfileChannelEndpointAssignmentResponse =
        new operations.DeleteCustomerProfileChannelEndpointAssignmentResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
      }

      return res;
    });
  }

  /**
   * Remove an Assignment Item Instance.
   */
  deleteCustomerProfileEntityAssignment(
    req: operations.DeleteCustomerProfileEntityAssignmentRequest,
    security: operations.DeleteCustomerProfileEntityAssignmentSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.DeleteCustomerProfileEntityAssignmentResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DeleteCustomerProfileEntityAssignmentRequest(req);
    }

    let baseURL: string =
      operations.DeleteCustomerProfileEntityAssignmentServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v1/CustomerProfiles/{CustomerProfileSid}/EntityAssignments/{Sid}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.DeleteCustomerProfileEntityAssignmentSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DeleteCustomerProfileEntityAssignmentResponse =
        new operations.DeleteCustomerProfileEntityAssignmentResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
      }

      return res;
    });
  }

  /**
   * Delete a specific End User.
   */
  deleteEndUser(
    req: operations.DeleteEndUserRequest,
    security: operations.DeleteEndUserSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.DeleteEndUserResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DeleteEndUserRequest(req);
    }

    let baseURL: string = operations.DeleteEndUserServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(baseURL, "/v1/EndUsers/{Sid}", req);
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.DeleteEndUserSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DeleteEndUserResponse =
        new operations.DeleteEndUserResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
      }

      return res;
    });
  }

  /**
   * Delete a specific Supporting Document.
   */
  deleteSupportingDocument(
    req: operations.DeleteSupportingDocumentRequest,
    security: operations.DeleteSupportingDocumentSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.DeleteSupportingDocumentResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DeleteSupportingDocumentRequest(req);
    }

    let baseURL: string = operations.DeleteSupportingDocumentServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v1/SupportingDocuments/{Sid}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.DeleteSupportingDocumentSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DeleteSupportingDocumentResponse =
        new operations.DeleteSupportingDocumentResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
      }

      return res;
    });
  }

  /**
   * Delete a specific Customer-Profile.
   */
  deleteTrustProduct(
    req: operations.DeleteTrustProductRequest,
    security: operations.DeleteTrustProductSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.DeleteTrustProductResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DeleteTrustProductRequest(req);
    }

    let baseURL: string = operations.DeleteTrustProductServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v1/TrustProducts/{Sid}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.DeleteTrustProductSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DeleteTrustProductResponse =
        new operations.DeleteTrustProductResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
      }

      return res;
    });
  }

  /**
   * Remove an Assignment Item Instance.
   */
  deleteTrustProductChannelEndpointAssignment(
    req: operations.DeleteTrustProductChannelEndpointAssignmentRequest,
    security: operations.DeleteTrustProductChannelEndpointAssignmentSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.DeleteTrustProductChannelEndpointAssignmentResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DeleteTrustProductChannelEndpointAssignmentRequest(
        req
      );
    }

    let baseURL: string =
      operations.DeleteTrustProductChannelEndpointAssignmentServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v1/TrustProducts/{TrustProductSid}/ChannelEndpointAssignments/{Sid}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.DeleteTrustProductChannelEndpointAssignmentSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DeleteTrustProductChannelEndpointAssignmentResponse =
        new operations.DeleteTrustProductChannelEndpointAssignmentResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
      }

      return res;
    });
  }

  /**
   * Remove an Assignment Item Instance.
   */
  deleteTrustProductEntityAssignment(
    req: operations.DeleteTrustProductEntityAssignmentRequest,
    security: operations.DeleteTrustProductEntityAssignmentSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.DeleteTrustProductEntityAssignmentResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DeleteTrustProductEntityAssignmentRequest(req);
    }

    let baseURL: string =
      operations.DeleteTrustProductEntityAssignmentServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v1/TrustProducts/{TrustProductSid}/EntityAssignments/{Sid}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.DeleteTrustProductEntityAssignmentSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DeleteTrustProductEntityAssignmentResponse =
        new operations.DeleteTrustProductEntityAssignmentResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
      }

      return res;
    });
  }

  /**
   * Fetch a specific Customer-Profile instance.
   */
  fetchCustomerProfile(
    req: operations.FetchCustomerProfileRequest,
    security: operations.FetchCustomerProfileSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.FetchCustomerProfileResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.FetchCustomerProfileRequest(req);
    }

    let baseURL: string = operations.FetchCustomerProfileServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v1/CustomerProfiles/{Sid}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.FetchCustomerProfileSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.FetchCustomerProfileResponse =
        new operations.FetchCustomerProfileResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.trusthubV1CustomerProfile = utils.objectToClass(
              httpRes?.data,
              shared.TrusthubV1CustomerProfile
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Fetch specific Assigned Item Instance.
   */
  fetchCustomerProfileChannelEndpointAssignment(
    req: operations.FetchCustomerProfileChannelEndpointAssignmentRequest,
    security: operations.FetchCustomerProfileChannelEndpointAssignmentSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.FetchCustomerProfileChannelEndpointAssignmentResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.FetchCustomerProfileChannelEndpointAssignmentRequest(
        req
      );
    }

    let baseURL: string =
      operations.FetchCustomerProfileChannelEndpointAssignmentServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v1/CustomerProfiles/{CustomerProfileSid}/ChannelEndpointAssignments/{Sid}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.FetchCustomerProfileChannelEndpointAssignmentSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.FetchCustomerProfileChannelEndpointAssignmentResponse =
        new operations.FetchCustomerProfileChannelEndpointAssignmentResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.trusthubV1CustomerProfileCustomerProfileChannelEndpointAssignment =
              utils.objectToClass(
                httpRes?.data,
                shared.TrusthubV1CustomerProfileCustomerProfileChannelEndpointAssignment
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Fetch specific Assigned Item Instance.
   */
  fetchCustomerProfileEntityAssignment(
    req: operations.FetchCustomerProfileEntityAssignmentRequest,
    security: operations.FetchCustomerProfileEntityAssignmentSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.FetchCustomerProfileEntityAssignmentResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.FetchCustomerProfileEntityAssignmentRequest(req);
    }

    let baseURL: string =
      operations.FetchCustomerProfileEntityAssignmentServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v1/CustomerProfiles/{CustomerProfileSid}/EntityAssignments/{Sid}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.FetchCustomerProfileEntityAssignmentSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.FetchCustomerProfileEntityAssignmentResponse =
        new operations.FetchCustomerProfileEntityAssignmentResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.trusthubV1CustomerProfileCustomerProfileEntityAssignment =
              utils.objectToClass(
                httpRes?.data,
                shared.TrusthubV1CustomerProfileCustomerProfileEntityAssignment
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Fetch specific Evaluation Instance.
   */
  fetchCustomerProfileEvaluation(
    req: operations.FetchCustomerProfileEvaluationRequest,
    security: operations.FetchCustomerProfileEvaluationSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.FetchCustomerProfileEvaluationResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.FetchCustomerProfileEvaluationRequest(req);
    }

    let baseURL: string =
      operations.FetchCustomerProfileEvaluationServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v1/CustomerProfiles/{CustomerProfileSid}/Evaluations/{Sid}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.FetchCustomerProfileEvaluationSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.FetchCustomerProfileEvaluationResponse =
        new operations.FetchCustomerProfileEvaluationResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.trusthubV1CustomerProfileCustomerProfileEvaluation =
              utils.objectToClass(
                httpRes?.data,
                shared.TrusthubV1CustomerProfileCustomerProfileEvaluation
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Fetch specific End User Instance.
   */
  fetchEndUser(
    req: operations.FetchEndUserRequest,
    security: operations.FetchEndUserSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.FetchEndUserResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.FetchEndUserRequest(req);
    }

    let baseURL: string = operations.FetchEndUserServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(baseURL, "/v1/EndUsers/{Sid}", req);
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.FetchEndUserSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.FetchEndUserResponse =
        new operations.FetchEndUserResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.trusthubV1EndUser = utils.objectToClass(
              httpRes?.data,
              shared.TrusthubV1EndUser
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Fetch a specific End-User Type Instance.
   */
  fetchEndUserType(
    req: operations.FetchEndUserTypeRequest,
    security: operations.FetchEndUserTypeSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.FetchEndUserTypeResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.FetchEndUserTypeRequest(req);
    }

    let baseURL: string = operations.FetchEndUserTypeServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v1/EndUserTypes/{Sid}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.FetchEndUserTypeSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.FetchEndUserTypeResponse =
        new operations.FetchEndUserTypeResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.trusthubV1EndUserType = utils.objectToClass(
              httpRes?.data,
              shared.TrusthubV1EndUserType
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Fetch specific Policy Instance.
   */
  fetchPolicies(
    req: operations.FetchPoliciesRequest,
    security: operations.FetchPoliciesSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.FetchPoliciesResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.FetchPoliciesRequest(req);
    }

    let baseURL: string = operations.FetchPoliciesServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(baseURL, "/v1/Policies/{Sid}", req);
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.FetchPoliciesSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.FetchPoliciesResponse =
        new operations.FetchPoliciesResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.trusthubV1Policies = utils.objectToClass(
              httpRes?.data,
              shared.TrusthubV1Policies
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Fetch specific Supporting Document Instance.
   */
  fetchSupportingDocument(
    req: operations.FetchSupportingDocumentRequest,
    security: operations.FetchSupportingDocumentSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.FetchSupportingDocumentResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.FetchSupportingDocumentRequest(req);
    }

    let baseURL: string = operations.FetchSupportingDocumentServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v1/SupportingDocuments/{Sid}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.FetchSupportingDocumentSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.FetchSupportingDocumentResponse =
        new operations.FetchSupportingDocumentResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.trusthubV1SupportingDocument = utils.objectToClass(
              httpRes?.data,
              shared.TrusthubV1SupportingDocument
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Fetch a specific Supporting Document Type Instance.
   */
  fetchSupportingDocumentType(
    req: operations.FetchSupportingDocumentTypeRequest,
    security: operations.FetchSupportingDocumentTypeSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.FetchSupportingDocumentTypeResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.FetchSupportingDocumentTypeRequest(req);
    }

    let baseURL: string = operations.FetchSupportingDocumentTypeServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v1/SupportingDocumentTypes/{Sid}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.FetchSupportingDocumentTypeSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.FetchSupportingDocumentTypeResponse =
        new operations.FetchSupportingDocumentTypeResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.trusthubV1SupportingDocumentType = utils.objectToClass(
              httpRes?.data,
              shared.TrusthubV1SupportingDocumentType
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Fetch a specific Customer-Profile instance.
   */
  fetchTrustProduct(
    req: operations.FetchTrustProductRequest,
    security: operations.FetchTrustProductSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.FetchTrustProductResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.FetchTrustProductRequest(req);
    }

    let baseURL: string = operations.FetchTrustProductServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v1/TrustProducts/{Sid}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.FetchTrustProductSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.FetchTrustProductResponse =
        new operations.FetchTrustProductResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.trusthubV1TrustProduct = utils.objectToClass(
              httpRes?.data,
              shared.TrusthubV1TrustProduct
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Fetch specific Assigned Item Instance.
   */
  fetchTrustProductChannelEndpointAssignment(
    req: operations.FetchTrustProductChannelEndpointAssignmentRequest,
    security: operations.FetchTrustProductChannelEndpointAssignmentSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.FetchTrustProductChannelEndpointAssignmentResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.FetchTrustProductChannelEndpointAssignmentRequest(
        req
      );
    }

    let baseURL: string =
      operations.FetchTrustProductChannelEndpointAssignmentServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v1/TrustProducts/{TrustProductSid}/ChannelEndpointAssignments/{Sid}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.FetchTrustProductChannelEndpointAssignmentSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.FetchTrustProductChannelEndpointAssignmentResponse =
        new operations.FetchTrustProductChannelEndpointAssignmentResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.trusthubV1TrustProductTrustProductChannelEndpointAssignment =
              utils.objectToClass(
                httpRes?.data,
                shared.TrusthubV1TrustProductTrustProductChannelEndpointAssignment
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Fetch specific Assigned Item Instance.
   */
  fetchTrustProductEntityAssignment(
    req: operations.FetchTrustProductEntityAssignmentRequest,
    security: operations.FetchTrustProductEntityAssignmentSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.FetchTrustProductEntityAssignmentResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.FetchTrustProductEntityAssignmentRequest(req);
    }

    let baseURL: string =
      operations.FetchTrustProductEntityAssignmentServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v1/TrustProducts/{TrustProductSid}/EntityAssignments/{Sid}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.FetchTrustProductEntityAssignmentSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.FetchTrustProductEntityAssignmentResponse =
        new operations.FetchTrustProductEntityAssignmentResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.trusthubV1TrustProductTrustProductEntityAssignment =
              utils.objectToClass(
                httpRes?.data,
                shared.TrusthubV1TrustProductTrustProductEntityAssignment
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Fetch specific Evaluation Instance.
   */
  fetchTrustProductEvaluation(
    req: operations.FetchTrustProductEvaluationRequest,
    security: operations.FetchTrustProductEvaluationSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.FetchTrustProductEvaluationResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.FetchTrustProductEvaluationRequest(req);
    }

    let baseURL: string = operations.FetchTrustProductEvaluationServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v1/TrustProducts/{TrustProductSid}/Evaluations/{Sid}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.FetchTrustProductEvaluationSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.FetchTrustProductEvaluationResponse =
        new operations.FetchTrustProductEvaluationResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.trusthubV1TrustProductTrustProductEvaluation =
              utils.objectToClass(
                httpRes?.data,
                shared.TrusthubV1TrustProductTrustProductEvaluation
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Retrieve a list of all Customer-Profiles for an account.
   */
  listCustomerProfile(
    req: operations.ListCustomerProfileRequest,
    security: operations.ListCustomerProfileSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.ListCustomerProfileResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ListCustomerProfileRequest(req);
    }

    let baseURL: string = operations.ListCustomerProfileServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = baseURL.replace(/\/$/, "") + "/v1/CustomerProfiles";
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ListCustomerProfileSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ListCustomerProfileResponse =
        new operations.ListCustomerProfileResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listCustomerProfileResponse = utils.objectToClass(
              httpRes?.data,
              operations.ListCustomerProfileListCustomerProfileResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Retrieve a list of all Assigned Items for an account.
   */
  listCustomerProfileChannelEndpointAssignment(
    req: operations.ListCustomerProfileChannelEndpointAssignmentRequest,
    security: operations.ListCustomerProfileChannelEndpointAssignmentSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.ListCustomerProfileChannelEndpointAssignmentResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ListCustomerProfileChannelEndpointAssignmentRequest(
        req
      );
    }

    let baseURL: string =
      operations.ListCustomerProfileChannelEndpointAssignmentServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v1/CustomerProfiles/{CustomerProfileSid}/ChannelEndpointAssignments",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.ListCustomerProfileChannelEndpointAssignmentSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ListCustomerProfileChannelEndpointAssignmentResponse =
        new operations.ListCustomerProfileChannelEndpointAssignmentResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listCustomerProfileChannelEndpointAssignmentResponse =
              utils.objectToClass(
                httpRes?.data,
                operations.ListCustomerProfileChannelEndpointAssignmentListCustomerProfileChannelEndpointAssignmentResponse
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Retrieve a list of all Assigned Items for an account.
   */
  listCustomerProfileEntityAssignment(
    req: operations.ListCustomerProfileEntityAssignmentRequest,
    security: operations.ListCustomerProfileEntityAssignmentSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.ListCustomerProfileEntityAssignmentResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ListCustomerProfileEntityAssignmentRequest(req);
    }

    let baseURL: string =
      operations.ListCustomerProfileEntityAssignmentServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v1/CustomerProfiles/{CustomerProfileSid}/EntityAssignments",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ListCustomerProfileEntityAssignmentSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ListCustomerProfileEntityAssignmentResponse =
        new operations.ListCustomerProfileEntityAssignmentResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listCustomerProfileEntityAssignmentResponse =
              utils.objectToClass(
                httpRes?.data,
                operations.ListCustomerProfileEntityAssignmentListCustomerProfileEntityAssignmentResponse
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Retrieve a list of Evaluations associated to the customer_profile resource.
   */
  listCustomerProfileEvaluation(
    req: operations.ListCustomerProfileEvaluationRequest,
    security: operations.ListCustomerProfileEvaluationSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.ListCustomerProfileEvaluationResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ListCustomerProfileEvaluationRequest(req);
    }

    let baseURL: string = operations.ListCustomerProfileEvaluationServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v1/CustomerProfiles/{CustomerProfileSid}/Evaluations",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ListCustomerProfileEvaluationSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ListCustomerProfileEvaluationResponse =
        new operations.ListCustomerProfileEvaluationResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listCustomerProfileEvaluationResponse = utils.objectToClass(
              httpRes?.data,
              operations.ListCustomerProfileEvaluationListCustomerProfileEvaluationResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Retrieve a list of all End User for an account.
   */
  listEndUser(
    req: operations.ListEndUserRequest,
    security: operations.ListEndUserSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.ListEndUserResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ListEndUserRequest(req);
    }

    let baseURL: string = operations.ListEndUserServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = baseURL.replace(/\/$/, "") + "/v1/EndUsers";
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ListEndUserSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ListEndUserResponse =
        new operations.ListEndUserResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listEndUserResponse = utils.objectToClass(
              httpRes?.data,
              operations.ListEndUserListEndUserResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Retrieve a list of all End-User Types.
   */
  listEndUserType(
    req: operations.ListEndUserTypeRequest,
    security: operations.ListEndUserTypeSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.ListEndUserTypeResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ListEndUserTypeRequest(req);
    }

    let baseURL: string = operations.ListEndUserTypeServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = baseURL.replace(/\/$/, "") + "/v1/EndUserTypes";
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ListEndUserTypeSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ListEndUserTypeResponse =
        new operations.ListEndUserTypeResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listEndUserTypeResponse = utils.objectToClass(
              httpRes?.data,
              operations.ListEndUserTypeListEndUserTypeResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Retrieve a list of all Policys.
   */
  listPolicies(
    req: operations.ListPoliciesRequest,
    security: operations.ListPoliciesSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.ListPoliciesResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ListPoliciesRequest(req);
    }

    let baseURL: string = operations.ListPoliciesServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = baseURL.replace(/\/$/, "") + "/v1/Policies";
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ListPoliciesSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ListPoliciesResponse =
        new operations.ListPoliciesResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listPoliciesResponse = utils.objectToClass(
              httpRes?.data,
              operations.ListPoliciesListPoliciesResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Retrieve a list of all Supporting Document for an account.
   */
  listSupportingDocument(
    req: operations.ListSupportingDocumentRequest,
    security: operations.ListSupportingDocumentSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.ListSupportingDocumentResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ListSupportingDocumentRequest(req);
    }

    let baseURL: string = operations.ListSupportingDocumentServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = baseURL.replace(/\/$/, "") + "/v1/SupportingDocuments";
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ListSupportingDocumentSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ListSupportingDocumentResponse =
        new operations.ListSupportingDocumentResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listSupportingDocumentResponse = utils.objectToClass(
              httpRes?.data,
              operations.ListSupportingDocumentListSupportingDocumentResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Retrieve a list of all Supporting Document Types.
   */
  listSupportingDocumentType(
    req: operations.ListSupportingDocumentTypeRequest,
    security: operations.ListSupportingDocumentTypeSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.ListSupportingDocumentTypeResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ListSupportingDocumentTypeRequest(req);
    }

    let baseURL: string = operations.ListSupportingDocumentTypeServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string =
      baseURL.replace(/\/$/, "") + "/v1/SupportingDocumentTypes";
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ListSupportingDocumentTypeSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ListSupportingDocumentTypeResponse =
        new operations.ListSupportingDocumentTypeResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listSupportingDocumentTypeResponse = utils.objectToClass(
              httpRes?.data,
              operations.ListSupportingDocumentTypeListSupportingDocumentTypeResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Retrieve a list of all Customer-Profiles for an account.
   */
  listTrustProduct(
    req: operations.ListTrustProductRequest,
    security: operations.ListTrustProductSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.ListTrustProductResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ListTrustProductRequest(req);
    }

    let baseURL: string = operations.ListTrustProductServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = baseURL.replace(/\/$/, "") + "/v1/TrustProducts";
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ListTrustProductSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ListTrustProductResponse =
        new operations.ListTrustProductResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listTrustProductResponse = utils.objectToClass(
              httpRes?.data,
              operations.ListTrustProductListTrustProductResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Retrieve a list of all Assigned Items for an account.
   */
  listTrustProductChannelEndpointAssignment(
    req: operations.ListTrustProductChannelEndpointAssignmentRequest,
    security: operations.ListTrustProductChannelEndpointAssignmentSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.ListTrustProductChannelEndpointAssignmentResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ListTrustProductChannelEndpointAssignmentRequest(
        req
      );
    }

    let baseURL: string =
      operations.ListTrustProductChannelEndpointAssignmentServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v1/TrustProducts/{TrustProductSid}/ChannelEndpointAssignments",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.ListTrustProductChannelEndpointAssignmentSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ListTrustProductChannelEndpointAssignmentResponse =
        new operations.ListTrustProductChannelEndpointAssignmentResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listTrustProductChannelEndpointAssignmentResponse =
              utils.objectToClass(
                httpRes?.data,
                operations.ListTrustProductChannelEndpointAssignmentListTrustProductChannelEndpointAssignmentResponse
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Retrieve a list of all Assigned Items for an account.
   */
  listTrustProductEntityAssignment(
    req: operations.ListTrustProductEntityAssignmentRequest,
    security: operations.ListTrustProductEntityAssignmentSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.ListTrustProductEntityAssignmentResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ListTrustProductEntityAssignmentRequest(req);
    }

    let baseURL: string =
      operations.ListTrustProductEntityAssignmentServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v1/TrustProducts/{TrustProductSid}/EntityAssignments",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ListTrustProductEntityAssignmentSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ListTrustProductEntityAssignmentResponse =
        new operations.ListTrustProductEntityAssignmentResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listTrustProductEntityAssignmentResponse = utils.objectToClass(
              httpRes?.data,
              operations.ListTrustProductEntityAssignmentListTrustProductEntityAssignmentResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Retrieve a list of Evaluations associated to the trust_product resource.
   */
  listTrustProductEvaluation(
    req: operations.ListTrustProductEvaluationRequest,
    security: operations.ListTrustProductEvaluationSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.ListTrustProductEvaluationResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ListTrustProductEvaluationRequest(req);
    }

    let baseURL: string = operations.ListTrustProductEvaluationServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v1/TrustProducts/{TrustProductSid}/Evaluations",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ListTrustProductEvaluationSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ListTrustProductEvaluationResponse =
        new operations.ListTrustProductEvaluationResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listTrustProductEvaluationResponse = utils.objectToClass(
              httpRes?.data,
              operations.ListTrustProductEvaluationListTrustProductEvaluationResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Updates a Customer-Profile in an account.
   */
  updateCustomerProfile(
    req: operations.UpdateCustomerProfileRequest,
    security: operations.UpdateCustomerProfileSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.UpdateCustomerProfileResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.UpdateCustomerProfileRequest(req);
    }

    let baseURL: string = operations.UpdateCustomerProfileServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v1/CustomerProfiles/{Sid}",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "form"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.UpdateCustomerProfileSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UpdateCustomerProfileResponse =
        new operations.UpdateCustomerProfileResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.trusthubV1CustomerProfile = utils.objectToClass(
              httpRes?.data,
              shared.TrusthubV1CustomerProfile
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Update an existing End User.
   */
  updateEndUser(
    req: operations.UpdateEndUserRequest,
    security: operations.UpdateEndUserSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.UpdateEndUserResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.UpdateEndUserRequest(req);
    }

    let baseURL: string = operations.UpdateEndUserServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(baseURL, "/v1/EndUsers/{Sid}", req);

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "form"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.UpdateEndUserSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UpdateEndUserResponse =
        new operations.UpdateEndUserResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.trusthubV1EndUser = utils.objectToClass(
              httpRes?.data,
              shared.TrusthubV1EndUser
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Update an existing Supporting Document.
   */
  updateSupportingDocument(
    req: operations.UpdateSupportingDocumentRequest,
    security: operations.UpdateSupportingDocumentSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.UpdateSupportingDocumentResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.UpdateSupportingDocumentRequest(req);
    }

    let baseURL: string = operations.UpdateSupportingDocumentServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v1/SupportingDocuments/{Sid}",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "form"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.UpdateSupportingDocumentSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UpdateSupportingDocumentResponse =
        new operations.UpdateSupportingDocumentResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.trusthubV1SupportingDocument = utils.objectToClass(
              httpRes?.data,
              shared.TrusthubV1SupportingDocument
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Updates a Customer-Profile in an account.
   */
  updateTrustProduct(
    req: operations.UpdateTrustProductRequest,
    security: operations.UpdateTrustProductSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.UpdateTrustProductResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.UpdateTrustProductRequest(req);
    }

    let baseURL: string = operations.UpdateTrustProductServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v1/TrustProducts/{Sid}",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "form"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.UpdateTrustProductSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UpdateTrustProductResponse =
        new operations.UpdateTrustProductResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.trusthubV1TrustProduct = utils.objectToClass(
              httpRes?.data,
              shared.TrusthubV1TrustProduct
            );
          }
          break;
      }

      return res;
    });
  }
}
