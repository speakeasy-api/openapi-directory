/* 
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

package org.openapis.openapi.models.shared;

import com.fasterxml.jackson.annotation.JsonFormat;
import com.fasterxml.jackson.annotation.JsonInclude.Include;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import java.time.LocalDate;

/**
 * GETSubscriptionTypeWithSuccess - Container for custom fields of a Subscription object.
 * 
 */
public class GETSubscriptionTypeWithSuccess {
    /**
     * The Bundle product structures from Zuora Quotes if you utilize Bundling in Salesforce. Do not change the value in this field.
     * 
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("CpqBundleJsonId__QT")
    public String cpqBundleJsonIdQT;
    public GETSubscriptionTypeWithSuccess withCpqBundleJsonIdQT(String cpqBundleJsonIdQT) {
        this.cpqBundleJsonIdQT = cpqBundleJsonIdQT;
        return this;
    }
    
    /**
     * ID of the corresponding object in NetSuite. Only available if you have installed the [Zuora Connector for NetSuite](https://www.zuora.com/connect/app/?appId=265).
     * 
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("IntegrationId__NS")
    public String integrationIdNS;
    public GETSubscriptionTypeWithSuccess withIntegrationIdNS(String integrationIdNS) {
        this.integrationIdNS = integrationIdNS;
        return this;
    }
    
    /**
     * Status of the subscription's synchronization with NetSuite. Only available if you have installed the [Zuora Connector for NetSuite](https://www.zuora.com/connect/app/?appId=265).
     * 
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("IntegrationStatus__NS")
    public String integrationStatusNS;
    public GETSubscriptionTypeWithSuccess withIntegrationStatusNS(String integrationStatusNS) {
        this.integrationStatusNS = integrationStatusNS;
        return this;
    }
    
    /**
     * The closing date of the Opportunity. This field is used in Zuora data sources to report on Subscription metrics. If the subscription originated from Zuora Quotes, the value is populated with the value from Zuora Quotes.
     * 
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonFormat(shape = JsonFormat.Shape.STRING, pattern = "yyyy-MM-dd")
    @JsonProperty("OpportunityCloseDate__QT")
    public LocalDate opportunityCloseDateQT;
    public GETSubscriptionTypeWithSuccess withOpportunityCloseDateQT(LocalDate opportunityCloseDateQT) {
        this.opportunityCloseDateQT = opportunityCloseDateQT;
        return this;
    }
    
    /**
     * The unique identifier of the Opportunity. This field is used in Zuora data sources to report on Subscription metrics. If the subscription originated from Zuora Quotes, the value is populated with the value from Zuora Quotes.
     * 
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("OpportunityName__QT")
    public String opportunityNameQT;
    public GETSubscriptionTypeWithSuccess withOpportunityNameQT(String opportunityNameQT) {
        this.opportunityNameQT = opportunityNameQT;
        return this;
    }
    
    /**
     * The NetSuite project that the subscription was created from. Only available if you have installed the [Zuora Connector for NetSuite](https://www.zuora.com/connect/app/?appId=265).
     * 
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("Project__NS")
    public String projectNS;
    public GETSubscriptionTypeWithSuccess withProjectNS(String projectNS) {
        this.projectNS = projectNS;
        return this;
    }
    
    /**
     * The specific identifier for the type of business transaction the Quote represents such as New, Upsell, Downsell, Renewal or Churn. This field is used in Zuora data sources to report on Subscription metrics. If the subscription originated from Zuora Quotes, the value is populated with the value from Zuora Quotes.
     * 
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("QuoteBusinessType__QT")
    public String quoteBusinessTypeQT;
    public GETSubscriptionTypeWithSuccess withQuoteBusinessTypeQT(String quoteBusinessTypeQT) {
        this.quoteBusinessTypeQT = quoteBusinessTypeQT;
        return this;
    }
    
    /**
     * The unique identifier of the Quote. This field is used in Zuora data sources to report on Subscription metrics. If the subscription originated from Zuora Quotes, the value is populated with the value from Zuora Quotes.
     * 
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("QuoteNumber__QT")
    public String quoteNumberQT;
    public GETSubscriptionTypeWithSuccess withQuoteNumberQT(String quoteNumberQT) {
        this.quoteNumberQT = quoteNumberQT;
        return this;
    }
    
    /**
     * The Quote type that represents the subscription lifecycle stage such as New, Amendment, Renew or Cancel. This field is used in Zuora data sources to report on Subscription metrics. If the subscription originated from Zuora Quotes, the value is populated with the value from Zuora Quotes.
     * 
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("QuoteType__QT")
    public String quoteTypeQT;
    public GETSubscriptionTypeWithSuccess withQuoteTypeQT(String quoteTypeQT) {
        this.quoteTypeQT = quoteTypeQT;
        return this;
    }
    
    /**
     * The NetSuite sales order than the subscription was created from. Only available if you have installed the [Zuora Connector for NetSuite](https://www.zuora.com/connect/app/?appId=265).
     * 
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("SalesOrder__NS")
    public String salesOrderNS;
    public GETSubscriptionTypeWithSuccess withSalesOrderNS(String salesOrderNS) {
        this.salesOrderNS = salesOrderNS;
        return this;
    }
    
    /**
     * Date when the subscription was synchronized with NetSuite. Only available if you have installed the [Zuora Connector for NetSuite](https://www.zuora.com/connect/app/?appId=265).
     * 
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("SyncDate__NS")
    public String syncDateNS;
    public GETSubscriptionTypeWithSuccess withSyncDateNS(String syncDateNS) {
        this.syncDateNS = syncDateNS;
        return this;
    }
    
    /**
     * The ID of the account associated with this subscription.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("accountId")
    public String accountId;
    public GETSubscriptionTypeWithSuccess withAccountId(String accountId) {
        this.accountId = accountId;
        return this;
    }
    
    /**
     * The name of the account associated with this subscription.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("accountName")
    public String accountName;
    public GETSubscriptionTypeWithSuccess withAccountName(String accountName) {
        this.accountName = accountName;
        return this;
    }
    
    /**
     * The number of the account associated with this subscription.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("accountNumber")
    public String accountNumber;
    public GETSubscriptionTypeWithSuccess withAccountNumber(String accountNumber) {
        this.accountNumber = accountNumber;
        return this;
    }
    
    /**
     * If `true`, the subscription automatically renews at the end of the term. Default is `false`.
     * 
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("autoRenew")
    public Boolean autoRenew;
    public GETSubscriptionTypeWithSuccess withAutoRenew(Boolean autoRenew) {
        this.autoRenew = autoRenew;
        return this;
    }
    
    /**
     * Effective contract date for this subscription, as yyyy-mm-dd.
     * 
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonFormat(shape = JsonFormat.Shape.STRING, pattern = "yyyy-MM-dd")
    @JsonProperty("contractEffectiveDate")
    public LocalDate contractEffectiveDate;
    public GETSubscriptionTypeWithSuccess withContractEffectiveDate(LocalDate contractEffectiveDate) {
        this.contractEffectiveDate = contractEffectiveDate;
        return this;
    }
    
    /**
     * Monthly recurring revenue of the subscription.
     * 
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("contractedMrr")
    public Double contractedMrr;
    public GETSubscriptionTypeWithSuccess withContractedMrr(Double contractedMrr) {
        this.contractedMrr = contractedMrr;
        return this;
    }
    
    /**
     * The length of the period for the current subscription term.
     * 
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("currentTerm")
    public Long currentTerm;
    public GETSubscriptionTypeWithSuccess withCurrentTerm(Long currentTerm) {
        this.currentTerm = currentTerm;
        return this;
    }
    
    /**
     * The period type for the current subscription term.
     * 
     * Values are:
     * 
     * * `Month` (default)
     * * `Year`
     * * `Day`
     * * `Week`
     * 
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("currentTermPeriodType")
    public String currentTermPeriodType;
    public GETSubscriptionTypeWithSuccess withCurrentTermPeriodType(String currentTermPeriodType) {
        this.currentTermPeriodType = currentTermPeriodType;
        return this;
    }
    
    /**
     * The date on which the services or products within a subscription have been accepted by the customer, as yyyy-mm-dd.
     * 
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonFormat(shape = JsonFormat.Shape.STRING, pattern = "yyyy-MM-dd")
    @JsonProperty("customerAcceptanceDate")
    public LocalDate customerAcceptanceDate;
    public GETSubscriptionTypeWithSuccess withCustomerAcceptanceDate(LocalDate customerAcceptanceDate) {
        this.customerAcceptanceDate = customerAcceptanceDate;
        return this;
    }
    
    /**
     * Subscription ID.
     * 
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("id")
    public String id;
    public GETSubscriptionTypeWithSuccess withId(String id) {
        this.id = id;
        return this;
    }
    
    /**
     * The length of the period for the first subscription term.
     * 
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("initialTerm")
    public Long initialTerm;
    public GETSubscriptionTypeWithSuccess withInitialTerm(Long initialTerm) {
        this.initialTerm = initialTerm;
        return this;
    }
    
    /**
     * The period type for the first subscription term.
     * 
     * Values are:
     * 
     * * `Month` (default)
     * * `Year`
     * * `Day`
     * * `Week`
     * 
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("initialTermPeriodType")
    public String initialTermPeriodType;
    public GETSubscriptionTypeWithSuccess withInitialTermPeriodType(String initialTermPeriodType) {
        this.initialTermPeriodType = initialTermPeriodType;
        return this;
    }
    
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("invoiceOwnerAccountId")
    public String invoiceOwnerAccountId;
    public GETSubscriptionTypeWithSuccess withInvoiceOwnerAccountId(String invoiceOwnerAccountId) {
        this.invoiceOwnerAccountId = invoiceOwnerAccountId;
        return this;
    }
    
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("invoiceOwnerAccountName")
    public String invoiceOwnerAccountName;
    public GETSubscriptionTypeWithSuccess withInvoiceOwnerAccountName(String invoiceOwnerAccountName) {
        this.invoiceOwnerAccountName = invoiceOwnerAccountName;
        return this;
    }
    
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("invoiceOwnerAccountNumber")
    public String invoiceOwnerAccountNumber;
    public GETSubscriptionTypeWithSuccess withInvoiceOwnerAccountNumber(String invoiceOwnerAccountNumber) {
        this.invoiceOwnerAccountNumber = invoiceOwnerAccountNumber;
        return this;
    }
    
    /**
     * Separates a single subscription from other subscriptions and creates an invoice for the subscription. 
     * 
     * If the value is `true`, the subscription is billed separately from other subscriptions. If the value is `false`, the subscription is included with other subscriptions in the account invoice.
     * 
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("invoiceSeparately")
    public String invoiceSeparately;
    public GETSubscriptionTypeWithSuccess withInvoiceSeparately(String invoiceSeparately) {
        this.invoiceSeparately = invoiceSeparately;
        return this;
    }
    
    /**
     * A string of up to 65,535 characters.
     * 
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("notes")
    public String notes;
    public GETSubscriptionTypeWithSuccess withNotes(String notes) {
        this.notes = notes;
        return this;
    }
    
    /**
     * The order number of the order in which the changes on the subscription are made. 
     * 
     * **Note:** This field is only available if you have the [Order Metrics](https://knowledgecenter.zuora.com/BC_Subscription_Management/Orders/AA_Overview_of_Orders#Order_Metrics) feature enabled. If you wish to have access to the feature, submit a request at [Zuora Global Support](http://support.zuora.com/). We will investigate your use cases and data before enabling this feature for you.
     * 
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("orderNumber")
    public String orderNumber;
    public GETSubscriptionTypeWithSuccess withOrderNumber(String orderNumber) {
        this.orderNumber = orderNumber;
        return this;
    }
    
    /**
     * Container for rate plans.
     * 
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("ratePlans")
    public GETSubscriptionRatePlanType[] ratePlans;
    public GETSubscriptionTypeWithSuccess withRatePlans(GETSubscriptionRatePlanType[] ratePlans) {
        this.ratePlans = ratePlans;
        return this;
    }
    
    /**
     * Specifies whether a termed subscription will remain `TERMED` or change to `EVERGREEN` when it is renewed. 
     * 
     * Values are:
     * 
     * * `RENEW_WITH_SPECIFIC_TERM` (default)
     * * `RENEW_TO_EVERGREEN`
     * 
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("renewalSetting")
    public String renewalSetting;
    public GETSubscriptionTypeWithSuccess withRenewalSetting(String renewalSetting) {
        this.renewalSetting = renewalSetting;
        return this;
    }
    
    /**
     * The length of the period for the subscription renewal term.
     * 
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("renewalTerm")
    public Long renewalTerm;
    public GETSubscriptionTypeWithSuccess withRenewalTerm(Long renewalTerm) {
        this.renewalTerm = renewalTerm;
        return this;
    }
    
    /**
     * The period type for the subscription renewal term.
     * 
     * Values are:
     * 
     * * `Month` (default)
     * * `Year`
     * * `Day`
     * * `Week`
     * 
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("renewalTermPeriodType")
    public String renewalTermPeriodType;
    public GETSubscriptionTypeWithSuccess withRenewalTermPeriodType(String renewalTermPeriodType) {
        this.renewalTermPeriodType = renewalTermPeriodType;
        return this;
    }
    
    /**
     * An auto-generated decimal value uniquely tagged with a subscription. The value always contains one decimal place, for example, the revision of a new subscription is 1.0. If a further version of the subscription is created, the revision value will be increased by 1. Also, the revision value is always incremental regardless of deletion of subscription versions.
     * 
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("revision")
    public String revision;
    public GETSubscriptionTypeWithSuccess withRevision(String revision) {
        this.revision = revision;
        return this;
    }
    
    /**
     * The date on which the services or products within a subscription have been activated and access has been provided to the customer, as yyyy-mm-dd
     * 
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonFormat(shape = JsonFormat.Shape.STRING, pattern = "yyyy-MM-dd")
    @JsonProperty("serviceActivationDate")
    public LocalDate serviceActivationDate;
    public GETSubscriptionTypeWithSuccess withServiceActivationDate(LocalDate serviceActivationDate) {
        this.serviceActivationDate = serviceActivationDate;
        return this;
    }
    
    /**
     * Subscription status; possible values are:
     * 
     * * `Draft`
     * * `Pending Activation`
     * * `Pending Acceptance`
     * * `Active`
     * * `Cancelled`
     * * `Suspended` (This value is in Limited Availability.)
     * 
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("status")
    public String status;
    public GETSubscriptionTypeWithSuccess withStatus(String status) {
        this.status = status;
        return this;
    }
    
    /**
     * The date when the subscription term ends, where the subscription ends at midnight the day before.
     * For example, if the `subscriptionEndDate` is 12/31/2016, the subscriptions ends at midnight (00:00:00 hours) on 12/30/2016.
     * This date is the same as the term end date or the cancelation date, as appropriate.
     * 
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonFormat(shape = JsonFormat.Shape.STRING, pattern = "yyyy-MM-dd")
    @JsonProperty("subscriptionEndDate")
    public LocalDate subscriptionEndDate;
    public GETSubscriptionTypeWithSuccess withSubscriptionEndDate(LocalDate subscriptionEndDate) {
        this.subscriptionEndDate = subscriptionEndDate;
        return this;
    }
    
    /**
     * Subscription number.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("subscriptionNumber")
    public String subscriptionNumber;
    public GETSubscriptionTypeWithSuccess withSubscriptionNumber(String subscriptionNumber) {
        this.subscriptionNumber = subscriptionNumber;
        return this;
    }
    
    /**
     * Date the subscription becomes effective.
     * 
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonFormat(shape = JsonFormat.Shape.STRING, pattern = "yyyy-MM-dd")
    @JsonProperty("subscriptionStartDate")
    public LocalDate subscriptionStartDate;
    public GETSubscriptionTypeWithSuccess withSubscriptionStartDate(LocalDate subscriptionStartDate) {
        this.subscriptionStartDate = subscriptionStartDate;
        return this;
    }
    
    /**
     * Returns `true` if the request was processed successfully.
     * 
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("success")
    public Boolean success;
    public GETSubscriptionTypeWithSuccess withSuccess(Boolean success) {
        this.success = success;
        return this;
    }
    
    /**
     * Date the subscription term ends. If the subscription is evergreen, this is null or is the cancellation date (if one has been set).
     * 
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonFormat(shape = JsonFormat.Shape.STRING, pattern = "yyyy-MM-dd")
    @JsonProperty("termEndDate")
    public LocalDate termEndDate;
    public GETSubscriptionTypeWithSuccess withTermEndDate(LocalDate termEndDate) {
        this.termEndDate = termEndDate;
        return this;
    }
    
    /**
     * Date the subscription term begins. If this is a renewal subscription, this date is different from the subscription start date.
     * 
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonFormat(shape = JsonFormat.Shape.STRING, pattern = "yyyy-MM-dd")
    @JsonProperty("termStartDate")
    public LocalDate termStartDate;
    public GETSubscriptionTypeWithSuccess withTermStartDate(LocalDate termStartDate) {
        this.termStartDate = termStartDate;
        return this;
    }
    
    /**
     * Possible values are: `TERMED`, `EVERGREEN`.
     * 
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("termType")
    public String termType;
    public GETSubscriptionTypeWithSuccess withTermType(String termType) {
        this.termType = termType;
        return this;
    }
    
    /**
     * Total contracted value of the subscription.
     * 
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("totalContractedValue")
    public Double totalContractedValue;
    public GETSubscriptionTypeWithSuccess withTotalContractedValue(Double totalContractedValue) {
        this.totalContractedValue = totalContractedValue;
        return this;
    }
    
}
