<?php

/**
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

declare(strict_types=1);

namespace OpenAPI\OpenAPI;

class IssueTracker 
{

	// SDK private variables namespaced with _ to avoid conflicts with API models
	private \GuzzleHttp\ClientInterface $_defaultClient;
	private \GuzzleHttp\ClientInterface $_securityClient;
	private string $_serverUrl;
	private string $_language;
	private string $_sdkVersion;
	private string $_genVersion;	

	/**
	 * @param \GuzzleHttp\ClientInterface $defaultClient
	 * @param \GuzzleHttp\ClientInterface $securityClient
	 * @param string $serverUrl
	 * @param string $language
	 * @param string $sdkVersion
	 * @param string $genVersion
	 */
	public function __construct(\GuzzleHttp\ClientInterface $defaultClient, \GuzzleHttp\ClientInterface $securityClient, string $serverUrl, string $language, string $sdkVersion, string $genVersion)
	{
		$this->_defaultClient = $defaultClient;
		$this->_securityClient = $securityClient;
		$this->_serverUrl = $serverUrl;
		$this->_language = $language;
		$this->_sdkVersion = $sdkVersion;
		$this->_genVersion = $genVersion;
	}
	
    /**
     * Delete an issue
     * 
     * Deletes the specified issue. This requires write access to the
     * repository.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\DeleteRepositoriesWorkspaceRepoSlugIssuesIssueIdRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\DeleteRepositoriesWorkspaceRepoSlugIssuesIssueIdSecurity $security
     * @return \OpenAPI\OpenAPI\Models\Operations\DeleteRepositoriesWorkspaceRepoSlugIssuesIssueIdResponse
     */
	public function deleteRepositoriesWorkspaceRepoSlugIssuesIssueId(
        \OpenAPI\OpenAPI\Models\Operations\DeleteRepositoriesWorkspaceRepoSlugIssuesIssueIdRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\DeleteRepositoriesWorkspaceRepoSlugIssuesIssueIdSecurity $security,
    ): \OpenAPI\OpenAPI\Models\Operations\DeleteRepositoriesWorkspaceRepoSlugIssuesIssueIdResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/repositories/{workspace}/{repo_slug}/issues/{issue_id}', \OpenAPI\OpenAPI\Models\Operations\DeleteRepositoriesWorkspaceRepoSlugIssuesIssueIdRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('DELETE', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\DeleteRepositoriesWorkspaceRepoSlugIssuesIssueIdResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->issue = $serializer->deserialize((string)$httpResponse->getBody(), 'array<string, mixed>', 'json');
            }
        }
        else if ($httpResponse->getStatusCode() === 403 or $httpResponse->getStatusCode() === 404) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->error = $serializer->deserialize((string)$httpResponse->getBody(), 'array<string, mixed>', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Delete an attachment for an issue
     * 
     * Deletes an attachment.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\DeleteRepositoriesWorkspaceRepoSlugIssuesIssueIdAttachmentsPathRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\DeleteRepositoriesWorkspaceRepoSlugIssuesIssueIdAttachmentsPathSecurity $security
     * @return \OpenAPI\OpenAPI\Models\Operations\DeleteRepositoriesWorkspaceRepoSlugIssuesIssueIdAttachmentsPathResponse
     */
	public function deleteRepositoriesWorkspaceRepoSlugIssuesIssueIdAttachmentsPath(
        \OpenAPI\OpenAPI\Models\Operations\DeleteRepositoriesWorkspaceRepoSlugIssuesIssueIdAttachmentsPathRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\DeleteRepositoriesWorkspaceRepoSlugIssuesIssueIdAttachmentsPathSecurity $security,
    ): \OpenAPI\OpenAPI\Models\Operations\DeleteRepositoriesWorkspaceRepoSlugIssuesIssueIdAttachmentsPathResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/repositories/{workspace}/{repo_slug}/issues/{issue_id}/attachments/{path}', \OpenAPI\OpenAPI\Models\Operations\DeleteRepositoriesWorkspaceRepoSlugIssuesIssueIdAttachmentsPathRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('DELETE', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\DeleteRepositoriesWorkspaceRepoSlugIssuesIssueIdAttachmentsPathResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 204 or $httpResponse->getStatusCode() === 401) {
        }
        else if ($httpResponse->getStatusCode() === 404) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->error = $serializer->deserialize((string)$httpResponse->getBody(), 'array<string, mixed>', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Delete a comment on an issue
     * 
     * Deletes the specified comment.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\DeleteRepositoriesWorkspaceRepoSlugIssuesIssueIdCommentsCommentIdRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\DeleteRepositoriesWorkspaceRepoSlugIssuesIssueIdCommentsCommentIdSecurity $security
     * @return \OpenAPI\OpenAPI\Models\Operations\DeleteRepositoriesWorkspaceRepoSlugIssuesIssueIdCommentsCommentIdResponse
     */
	public function deleteRepositoriesWorkspaceRepoSlugIssuesIssueIdCommentsCommentId(
        \OpenAPI\OpenAPI\Models\Operations\DeleteRepositoriesWorkspaceRepoSlugIssuesIssueIdCommentsCommentIdRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\DeleteRepositoriesWorkspaceRepoSlugIssuesIssueIdCommentsCommentIdSecurity $security,
    ): \OpenAPI\OpenAPI\Models\Operations\DeleteRepositoriesWorkspaceRepoSlugIssuesIssueIdCommentsCommentIdResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/repositories/{workspace}/{repo_slug}/issues/{issue_id}/comments/{comment_id}', \OpenAPI\OpenAPI\Models\Operations\DeleteRepositoriesWorkspaceRepoSlugIssuesIssueIdCommentsCommentIdRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('DELETE', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\DeleteRepositoriesWorkspaceRepoSlugIssuesIssueIdCommentsCommentIdResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 204) {
        }

        return $response;
    }
	
    /**
     * Remove vote for an issue
     * 
     * Retract your vote.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\DeleteRepositoriesWorkspaceRepoSlugIssuesIssueIdVoteRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\DeleteRepositoriesWorkspaceRepoSlugIssuesIssueIdVoteSecurity $security
     * @return \OpenAPI\OpenAPI\Models\Operations\DeleteRepositoriesWorkspaceRepoSlugIssuesIssueIdVoteResponse
     */
	public function deleteRepositoriesWorkspaceRepoSlugIssuesIssueIdVote(
        \OpenAPI\OpenAPI\Models\Operations\DeleteRepositoriesWorkspaceRepoSlugIssuesIssueIdVoteRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\DeleteRepositoriesWorkspaceRepoSlugIssuesIssueIdVoteSecurity $security,
    ): \OpenAPI\OpenAPI\Models\Operations\DeleteRepositoriesWorkspaceRepoSlugIssuesIssueIdVoteResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/repositories/{workspace}/{repo_slug}/issues/{issue_id}/vote', \OpenAPI\OpenAPI\Models\Operations\DeleteRepositoriesWorkspaceRepoSlugIssuesIssueIdVoteRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('DELETE', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\DeleteRepositoriesWorkspaceRepoSlugIssuesIssueIdVoteResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if (true) { /** @phpstan-ignore-line */
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->error = $serializer->deserialize((string)$httpResponse->getBody(), 'array<string, mixed>', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Stop watching an issue
     * 
     * Stop watching this issue.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\DeleteRepositoriesWorkspaceRepoSlugIssuesIssueIdWatchRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\DeleteRepositoriesWorkspaceRepoSlugIssuesIssueIdWatchSecurity $security
     * @return \OpenAPI\OpenAPI\Models\Operations\DeleteRepositoriesWorkspaceRepoSlugIssuesIssueIdWatchResponse
     */
	public function deleteRepositoriesWorkspaceRepoSlugIssuesIssueIdWatch(
        \OpenAPI\OpenAPI\Models\Operations\DeleteRepositoriesWorkspaceRepoSlugIssuesIssueIdWatchRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\DeleteRepositoriesWorkspaceRepoSlugIssuesIssueIdWatchSecurity $security,
    ): \OpenAPI\OpenAPI\Models\Operations\DeleteRepositoriesWorkspaceRepoSlugIssuesIssueIdWatchResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/repositories/{workspace}/{repo_slug}/issues/{issue_id}/watch', \OpenAPI\OpenAPI\Models\Operations\DeleteRepositoriesWorkspaceRepoSlugIssuesIssueIdWatchRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('DELETE', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\DeleteRepositoriesWorkspaceRepoSlugIssuesIssueIdWatchResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 204 or $httpResponse->getStatusCode() === 401 or $httpResponse->getStatusCode() === 404) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->error = $serializer->deserialize((string)$httpResponse->getBody(), 'array<string, mixed>', 'json');
            }
        }

        return $response;
    }
	
    /**
     * List components
     * 
     * Returns the components that have been defined in the issue tracker.
     * 
     * This resource is only available on repositories that have the issue
     * tracker enabled.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetRepositoriesWorkspaceRepoSlugComponentsRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\GetRepositoriesWorkspaceRepoSlugComponentsSecurity $security
     * @return \OpenAPI\OpenAPI\Models\Operations\GetRepositoriesWorkspaceRepoSlugComponentsResponse
     */
	public function getRepositoriesWorkspaceRepoSlugComponents(
        \OpenAPI\OpenAPI\Models\Operations\GetRepositoriesWorkspaceRepoSlugComponentsRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\GetRepositoriesWorkspaceRepoSlugComponentsSecurity $security,
    ): \OpenAPI\OpenAPI\Models\Operations\GetRepositoriesWorkspaceRepoSlugComponentsResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/repositories/{workspace}/{repo_slug}/components', \OpenAPI\OpenAPI\Models\Operations\GetRepositoriesWorkspaceRepoSlugComponentsRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetRepositoriesWorkspaceRepoSlugComponentsResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->paginatedComponents = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\PaginatedComponents', 'json');
            }
        }
        else if ($httpResponse->getStatusCode() === 404) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->error = $serializer->deserialize((string)$httpResponse->getBody(), 'array<string, mixed>', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Get a component for issues
     * 
     * Returns the specified issue tracker component object.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetRepositoriesWorkspaceRepoSlugComponentsComponentIdRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\GetRepositoriesWorkspaceRepoSlugComponentsComponentIdSecurity $security
     * @return \OpenAPI\OpenAPI\Models\Operations\GetRepositoriesWorkspaceRepoSlugComponentsComponentIdResponse
     */
	public function getRepositoriesWorkspaceRepoSlugComponentsComponentId(
        \OpenAPI\OpenAPI\Models\Operations\GetRepositoriesWorkspaceRepoSlugComponentsComponentIdRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\GetRepositoriesWorkspaceRepoSlugComponentsComponentIdSecurity $security,
    ): \OpenAPI\OpenAPI\Models\Operations\GetRepositoriesWorkspaceRepoSlugComponentsComponentIdResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/repositories/{workspace}/{repo_slug}/components/{component_id}', \OpenAPI\OpenAPI\Models\Operations\GetRepositoriesWorkspaceRepoSlugComponentsComponentIdRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetRepositoriesWorkspaceRepoSlugComponentsComponentIdResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->component = $serializer->deserialize((string)$httpResponse->getBody(), 'array<string, mixed>', 'json');
            }
        }
        else if ($httpResponse->getStatusCode() === 404) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->error = $serializer->deserialize((string)$httpResponse->getBody(), 'array<string, mixed>', 'json');
            }
        }

        return $response;
    }
	
    /**
     * List issues
     * 
     * Returns the issues in the issue tracker.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetRepositoriesWorkspaceRepoSlugIssuesRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\GetRepositoriesWorkspaceRepoSlugIssuesSecurity $security
     * @return \OpenAPI\OpenAPI\Models\Operations\GetRepositoriesWorkspaceRepoSlugIssuesResponse
     */
	public function getRepositoriesWorkspaceRepoSlugIssues(
        \OpenAPI\OpenAPI\Models\Operations\GetRepositoriesWorkspaceRepoSlugIssuesRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\GetRepositoriesWorkspaceRepoSlugIssuesSecurity $security,
    ): \OpenAPI\OpenAPI\Models\Operations\GetRepositoriesWorkspaceRepoSlugIssuesResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/repositories/{workspace}/{repo_slug}/issues', \OpenAPI\OpenAPI\Models\Operations\GetRepositoriesWorkspaceRepoSlugIssuesRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetRepositoriesWorkspaceRepoSlugIssuesResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->paginatedIssues = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\PaginatedIssues', 'json');
            }
        }
        else if ($httpResponse->getStatusCode() === 404) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->error = $serializer->deserialize((string)$httpResponse->getBody(), 'array<string, mixed>', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Check issue export status
     * 
     * This endpoint is used to poll for the progress of an issue export
     * job and return the zip file after the job is complete.
     * As long as the job is running, this will return a 200 response
     * with in the response body a description of the current status.
     * 
     * After the job has been scheduled, but before it starts executing, this
     * endpoint's response is:
     * 
     * {
     *  "type": "issue_job_status",
     *  "status": "ACCEPTED",
     *  "phase": "Initializing",
     *  "total": 0,
     *  "count": 0,
     *  "pct": 0
     * }
     * 
     * 
     * Then once it starts running, it becomes:
     * 
     * {
     *  "type": "issue_job_status",
     *  "status": "STARTED",
     *  "phase": "Attachments",
     *  "total": 15,
     *  "count": 11,
     *  "pct": 73
     * }
     * 
     * Once the job has successfully completed, it returns a stream of the zip file.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetRepositoriesWorkspaceRepoSlugIssuesExportRepoNameIssuesTaskIdZipRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\GetRepositoriesWorkspaceRepoSlugIssuesExportRepoNameIssuesTaskIdZipSecurity $security
     * @return \OpenAPI\OpenAPI\Models\Operations\GetRepositoriesWorkspaceRepoSlugIssuesExportRepoNameIssuesTaskIdZipResponse
     */
	public function getRepositoriesWorkspaceRepoSlugIssuesExportRepoNameIssuesTaskIdZip(
        \OpenAPI\OpenAPI\Models\Operations\GetRepositoriesWorkspaceRepoSlugIssuesExportRepoNameIssuesTaskIdZipRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\GetRepositoriesWorkspaceRepoSlugIssuesExportRepoNameIssuesTaskIdZipSecurity $security,
    ): \OpenAPI\OpenAPI\Models\Operations\GetRepositoriesWorkspaceRepoSlugIssuesExportRepoNameIssuesTaskIdZipResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/repositories/{workspace}/{repo_slug}/issues/export/{repo_name}-issues-{task_id}.zip', \OpenAPI\OpenAPI\Models\Operations\GetRepositoriesWorkspaceRepoSlugIssuesExportRepoNameIssuesTaskIdZipRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetRepositoriesWorkspaceRepoSlugIssuesExportRepoNameIssuesTaskIdZipResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 202) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->issueJobStatus = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\IssueJobStatus', 'json');
            }
        }
        else if ($httpResponse->getStatusCode() === 401 or $httpResponse->getStatusCode() === 403 or $httpResponse->getStatusCode() === 404) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->error = $serializer->deserialize((string)$httpResponse->getBody(), 'array<string, mixed>', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Check issue import status
     * 
     * When using GET, this endpoint reports the status of the current import task. Request example:
     * 
     * ```
     * $ curl -u <username> -X GET https://api.bitbucket.org/2.0/repositories/<owner_username>/<repo_slug>/issues/import
     * ```
     * 
     * After the job has been scheduled, but before it starts executing, this endpoint's response is:
     * 
     * ```
     * < HTTP/1.1 202 Accepted
     * {
     *     "type": "issue_job_status",
     *     "status": "PENDING",
     *     "phase": "Attachments",
     *     "total": 15,
     *     "count": 0,
     *     "percent": 0
     * }
     * ```
     * 
     * Once it starts running, it is a 202 response with status STARTED and progress filled.
     * 
     * After it is finished, it becomes a 200 response with status SUCCESS or FAILURE.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetRepositoriesWorkspaceRepoSlugIssuesImportRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\GetRepositoriesWorkspaceRepoSlugIssuesImportSecurity $security
     * @return \OpenAPI\OpenAPI\Models\Operations\GetRepositoriesWorkspaceRepoSlugIssuesImportResponse
     */
	public function getRepositoriesWorkspaceRepoSlugIssuesImport(
        \OpenAPI\OpenAPI\Models\Operations\GetRepositoriesWorkspaceRepoSlugIssuesImportRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\GetRepositoriesWorkspaceRepoSlugIssuesImportSecurity $security,
    ): \OpenAPI\OpenAPI\Models\Operations\GetRepositoriesWorkspaceRepoSlugIssuesImportResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/repositories/{workspace}/{repo_slug}/issues/import', \OpenAPI\OpenAPI\Models\Operations\GetRepositoriesWorkspaceRepoSlugIssuesImportRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetRepositoriesWorkspaceRepoSlugIssuesImportResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200 or $httpResponse->getStatusCode() === 202) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->issueJobStatus = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\IssueJobStatus', 'json');
            }
        }
        else if ($httpResponse->getStatusCode() === 401 or $httpResponse->getStatusCode() === 403 or $httpResponse->getStatusCode() === 404) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->error = $serializer->deserialize((string)$httpResponse->getBody(), 'array<string, mixed>', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Get an issue
     * 
     * Returns the specified issue.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetRepositoriesWorkspaceRepoSlugIssuesIssueIdRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\GetRepositoriesWorkspaceRepoSlugIssuesIssueIdSecurity $security
     * @return \OpenAPI\OpenAPI\Models\Operations\GetRepositoriesWorkspaceRepoSlugIssuesIssueIdResponse
     */
	public function getRepositoriesWorkspaceRepoSlugIssuesIssueId(
        \OpenAPI\OpenAPI\Models\Operations\GetRepositoriesWorkspaceRepoSlugIssuesIssueIdRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\GetRepositoriesWorkspaceRepoSlugIssuesIssueIdSecurity $security,
    ): \OpenAPI\OpenAPI\Models\Operations\GetRepositoriesWorkspaceRepoSlugIssuesIssueIdResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/repositories/{workspace}/{repo_slug}/issues/{issue_id}', \OpenAPI\OpenAPI\Models\Operations\GetRepositoriesWorkspaceRepoSlugIssuesIssueIdRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetRepositoriesWorkspaceRepoSlugIssuesIssueIdResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->issue = $serializer->deserialize((string)$httpResponse->getBody(), 'array<string, mixed>', 'json');
            }
        }
        else if ($httpResponse->getStatusCode() === 403 or $httpResponse->getStatusCode() === 404 or $httpResponse->getStatusCode() === 410) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->error = $serializer->deserialize((string)$httpResponse->getBody(), 'array<string, mixed>', 'json');
            }
        }

        return $response;
    }
	
    /**
     * List attachments for an issue
     * 
     * Returns all attachments for this issue.
     * 
     * This returns the files' meta data. This does not return the files'
     * actual contents.
     * 
     * The files are always ordered by their upload date.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetRepositoriesWorkspaceRepoSlugIssuesIssueIdAttachmentsRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\GetRepositoriesWorkspaceRepoSlugIssuesIssueIdAttachmentsSecurity $security
     * @return \OpenAPI\OpenAPI\Models\Operations\GetRepositoriesWorkspaceRepoSlugIssuesIssueIdAttachmentsResponse
     */
	public function getRepositoriesWorkspaceRepoSlugIssuesIssueIdAttachments(
        \OpenAPI\OpenAPI\Models\Operations\GetRepositoriesWorkspaceRepoSlugIssuesIssueIdAttachmentsRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\GetRepositoriesWorkspaceRepoSlugIssuesIssueIdAttachmentsSecurity $security,
    ): \OpenAPI\OpenAPI\Models\Operations\GetRepositoriesWorkspaceRepoSlugIssuesIssueIdAttachmentsResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/repositories/{workspace}/{repo_slug}/issues/{issue_id}/attachments', \OpenAPI\OpenAPI\Models\Operations\GetRepositoriesWorkspaceRepoSlugIssuesIssueIdAttachmentsRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetRepositoriesWorkspaceRepoSlugIssuesIssueIdAttachmentsResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->paginatedIssueAttachments = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\PaginatedIssueAttachments', 'json');
            }
        }
        else if ($httpResponse->getStatusCode() === 401) {
        }
        else if ($httpResponse->getStatusCode() === 404) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->error = $serializer->deserialize((string)$httpResponse->getBody(), 'array<string, mixed>', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Get attachment for an issue
     * 
     * Returns the contents of the specified file attachment.
     * 
     * Note that this endpoint does not return a JSON response, but instead
     * returns a redirect pointing to the actual file that in turn will return
     * the raw contents.
     * 
     * The redirect URL contains a one-time token that has a limited lifetime.
     * As a result, the link should not be persisted, stored, or shared.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetRepositoriesWorkspaceRepoSlugIssuesIssueIdAttachmentsPathRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\GetRepositoriesWorkspaceRepoSlugIssuesIssueIdAttachmentsPathSecurity $security
     * @return \OpenAPI\OpenAPI\Models\Operations\GetRepositoriesWorkspaceRepoSlugIssuesIssueIdAttachmentsPathResponse
     */
	public function getRepositoriesWorkspaceRepoSlugIssuesIssueIdAttachmentsPath(
        \OpenAPI\OpenAPI\Models\Operations\GetRepositoriesWorkspaceRepoSlugIssuesIssueIdAttachmentsPathRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\GetRepositoriesWorkspaceRepoSlugIssuesIssueIdAttachmentsPathSecurity $security,
    ): \OpenAPI\OpenAPI\Models\Operations\GetRepositoriesWorkspaceRepoSlugIssuesIssueIdAttachmentsPathResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/repositories/{workspace}/{repo_slug}/issues/{issue_id}/attachments/{path}', \OpenAPI\OpenAPI\Models\Operations\GetRepositoriesWorkspaceRepoSlugIssuesIssueIdAttachmentsPathRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetRepositoriesWorkspaceRepoSlugIssuesIssueIdAttachmentsPathResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 302) {
            $response->headers = $httpResponse->getHeaders();
            
        }
        else if ($httpResponse->getStatusCode() === 401) {
        }
        else if ($httpResponse->getStatusCode() === 404) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->error = $serializer->deserialize((string)$httpResponse->getBody(), 'array<string, mixed>', 'json');
            }
        }

        return $response;
    }
	
    /**
     * List changes on an issue
     * 
     * Returns the list of all changes that have been made to the specified
     * issue. Changes are returned in chronological order with the oldest
     * change first.
     * 
     * Each time an issue is edited in the UI or through the API, an immutable
     * change record is created under the `/issues/123/changes` endpoint. It
     * also has a comment associated with the change.
     * 
     * Note that this operation is changing significantly, due to privacy changes.
     * See the [announcement](https://developer.atlassian.com/cloud/bitbucket/bitbucket-api-changes-gdpr/#changes-to-the-issue-changes-api)
     * for details.
     * 
     * ```
     * $ curl -s https://api.bitbucket.org/2.0/repositories/evzijst/dogslow/issues/1/changes - | jq .
     * 
     * {
     *   "pagelen": 20,
     *   "values": [
     *     {
     *       "changes": {
     *         "priority": {
     *           "new": "trivial",
     *           "old": "major"
     *         },
     *         "assignee": {
     *           "new": "",
     *           "old": "evzijst"
     *         },
     *         "assignee_account_id": {
     *           "new": "",
     *           "old": "557058:c0b72ad0-1cb5-4018-9cdc-0cde8492c443"
     *         },
     *         "kind": {
     *           "new": "enhancement",
     *           "old": "bug"
     *         }
     *       },
     *       "links": {
     *         "self": {
     *           "href": "https://api.bitbucket.org/2.0/repositories/evzijst/dogslow/issues/1/changes/2"
     *         },
     *         "html": {
     *           "href": "https://bitbucket.org/evzijst/dogslow/issues/1#comment-2"
     *         }
     *       },
     *       "issue": {
     *         "links": {
     *           "self": {
     *             "href": "https://api.bitbucket.org/2.0/repositories/evzijst/dogslow/issues/1"
     *           }
     *         },
     *         "type": "issue",
     *         "id": 1,
     *         "repository": {
     *           "links": {
     *             "self": {
     *               "href": "https://api.bitbucket.org/2.0/repositories/evzijst/dogslow"
     *             },
     *             "html": {
     *               "href": "https://bitbucket.org/evzijst/dogslow"
     *             },
     *             "avatar": {
     *               "href": "https://bitbucket.org/evzijst/dogslow/avatar/32/"
     *             }
     *           },
     *           "type": "repository",
     *           "name": "dogslow",
     *           "full_name": "evzijst/dogslow",
     *           "uuid": "{988b17c6-1a47-4e70-84ee-854d5f012bf6}"
     *         },
     *         "title": "Updated title"
     *       },
     *       "created_on": "2018-03-03T00:35:28.353630+00:00",
     *       "user": {
     *         "username": "evzijst",
     *         "nickname": "evzijst",
     *         "display_name": "evzijst",
     *         "type": "user",
     *         "uuid": "{aaa7972b-38af-4fb1-802d-6e3854c95778}",
     *         "links": {
     *           "self": {
     *             "href": "https://api.bitbucket.org/2.0/users/evzijst"
     *           },
     *           "html": {
     *             "href": "https://bitbucket.org/evzijst/"
     *           },
     *           "avatar": {
     *             "href": "https://bitbucket.org/account/evzijst/avatar/32/"
     *           }
     *         }
     *       },
     *       "message": {
     *         "raw": "Removed assignee, changed kind and priority.",
     *         "markup": "markdown",
     *         "html": "<p>Removed assignee, changed kind and priority.</p>",
     *         "type": "rendered"
     *       },
     *       "type": "issue_change",
     *       "id": 2
     *     }
     *   ],
     *   "page": 1
     * }
     * ```
     * 
     * Changes support [filtering and sorting](/cloud/bitbucket/rest/intro/#filtering) that
     * can be used to search for specific changes. For instance, to see
     * when an issue transitioned to "resolved":
     * 
     * ```
     * $ curl -s https://api.bitbucket.org/2.0/repositories/site/master/issues/1/changes \
     *    -G --data-urlencode='q=changes.state.new = "resolved"'
     * ```
     * 
     * This resource is only available on repositories that have the issue
     * tracker enabled.
     * 
     * N.B.
     * 
     * The `changes.assignee` and `changes.assignee_account_id` fields are not
     * a `user` object. Instead, they contain the raw `username` and
     * `account_id` of the user. This is to protect the integrity of the audit
     * log even after a user account gets deleted.
     * 
     * The `changes.assignee` field is deprecated will disappear in the
     * future. Use `changes.assignee_account_id` instead.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetRepositoriesWorkspaceRepoSlugIssuesIssueIdChangesRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\GetRepositoriesWorkspaceRepoSlugIssuesIssueIdChangesSecurity $security
     * @return \OpenAPI\OpenAPI\Models\Operations\GetRepositoriesWorkspaceRepoSlugIssuesIssueIdChangesResponse
     */
	public function getRepositoriesWorkspaceRepoSlugIssuesIssueIdChanges(
        \OpenAPI\OpenAPI\Models\Operations\GetRepositoriesWorkspaceRepoSlugIssuesIssueIdChangesRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\GetRepositoriesWorkspaceRepoSlugIssuesIssueIdChangesSecurity $security,
    ): \OpenAPI\OpenAPI\Models\Operations\GetRepositoriesWorkspaceRepoSlugIssuesIssueIdChangesResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/repositories/{workspace}/{repo_slug}/issues/{issue_id}/changes', \OpenAPI\OpenAPI\Models\Operations\GetRepositoriesWorkspaceRepoSlugIssuesIssueIdChangesRequest::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\GetRepositoriesWorkspaceRepoSlugIssuesIssueIdChangesRequest::class, $request, null));
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetRepositoriesWorkspaceRepoSlugIssuesIssueIdChangesResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->paginatedLogEntries = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\PaginatedLogEntries', 'json');
            }
        }
        else if ($httpResponse->getStatusCode() === 404) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->error = $serializer->deserialize((string)$httpResponse->getBody(), 'array<string, mixed>', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Get issue change object
     * 
     * Returns the specified issue change object.
     * 
     * This resource is only available on repositories that have the issue
     * tracker enabled.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetRepositoriesWorkspaceRepoSlugIssuesIssueIdChangesChangeIdRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\GetRepositoriesWorkspaceRepoSlugIssuesIssueIdChangesChangeIdSecurity $security
     * @return \OpenAPI\OpenAPI\Models\Operations\GetRepositoriesWorkspaceRepoSlugIssuesIssueIdChangesChangeIdResponse
     */
	public function getRepositoriesWorkspaceRepoSlugIssuesIssueIdChangesChangeId(
        \OpenAPI\OpenAPI\Models\Operations\GetRepositoriesWorkspaceRepoSlugIssuesIssueIdChangesChangeIdRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\GetRepositoriesWorkspaceRepoSlugIssuesIssueIdChangesChangeIdSecurity $security,
    ): \OpenAPI\OpenAPI\Models\Operations\GetRepositoriesWorkspaceRepoSlugIssuesIssueIdChangesChangeIdResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/repositories/{workspace}/{repo_slug}/issues/{issue_id}/changes/{change_id}', \OpenAPI\OpenAPI\Models\Operations\GetRepositoriesWorkspaceRepoSlugIssuesIssueIdChangesChangeIdRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetRepositoriesWorkspaceRepoSlugIssuesIssueIdChangesChangeIdResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->issueChange = $serializer->deserialize((string)$httpResponse->getBody(), 'array<string, mixed>', 'json');
            }
        }
        else if ($httpResponse->getStatusCode() === 404) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->error = $serializer->deserialize((string)$httpResponse->getBody(), 'array<string, mixed>', 'json');
            }
        }

        return $response;
    }
	
    /**
     * List comments on an issue
     * 
     * Returns a paginated list of all comments that were made on the
     * specified issue.
     * 
     * The default sorting is oldest to newest and can be overridden with
     * the `sort` query parameter.
     * 
     * This endpoint also supports filtering and sorting of the results. See
     * [filtering and sorting](/cloud/bitbucket/rest/intro/#filtering) for more details.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetRepositoriesWorkspaceRepoSlugIssuesIssueIdCommentsRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\GetRepositoriesWorkspaceRepoSlugIssuesIssueIdCommentsSecurity $security
     * @return \OpenAPI\OpenAPI\Models\Operations\GetRepositoriesWorkspaceRepoSlugIssuesIssueIdCommentsResponse
     */
	public function getRepositoriesWorkspaceRepoSlugIssuesIssueIdComments(
        \OpenAPI\OpenAPI\Models\Operations\GetRepositoriesWorkspaceRepoSlugIssuesIssueIdCommentsRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\GetRepositoriesWorkspaceRepoSlugIssuesIssueIdCommentsSecurity $security,
    ): \OpenAPI\OpenAPI\Models\Operations\GetRepositoriesWorkspaceRepoSlugIssuesIssueIdCommentsResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/repositories/{workspace}/{repo_slug}/issues/{issue_id}/comments', \OpenAPI\OpenAPI\Models\Operations\GetRepositoriesWorkspaceRepoSlugIssuesIssueIdCommentsRequest::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\GetRepositoriesWorkspaceRepoSlugIssuesIssueIdCommentsRequest::class, $request, null));
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetRepositoriesWorkspaceRepoSlugIssuesIssueIdCommentsResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->paginatedIssueComments = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\PaginatedIssueComments', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Get a comment on an issue
     * 
     * Returns the specified issue comment object.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetRepositoriesWorkspaceRepoSlugIssuesIssueIdCommentsCommentIdRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\GetRepositoriesWorkspaceRepoSlugIssuesIssueIdCommentsCommentIdSecurity $security
     * @return \OpenAPI\OpenAPI\Models\Operations\GetRepositoriesWorkspaceRepoSlugIssuesIssueIdCommentsCommentIdResponse
     */
	public function getRepositoriesWorkspaceRepoSlugIssuesIssueIdCommentsCommentId(
        \OpenAPI\OpenAPI\Models\Operations\GetRepositoriesWorkspaceRepoSlugIssuesIssueIdCommentsCommentIdRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\GetRepositoriesWorkspaceRepoSlugIssuesIssueIdCommentsCommentIdSecurity $security,
    ): \OpenAPI\OpenAPI\Models\Operations\GetRepositoriesWorkspaceRepoSlugIssuesIssueIdCommentsCommentIdResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/repositories/{workspace}/{repo_slug}/issues/{issue_id}/comments/{comment_id}', \OpenAPI\OpenAPI\Models\Operations\GetRepositoriesWorkspaceRepoSlugIssuesIssueIdCommentsCommentIdRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetRepositoriesWorkspaceRepoSlugIssuesIssueIdCommentsCommentIdResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->issueComment = $serializer->deserialize((string)$httpResponse->getBody(), 'array<string, mixed>', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Check if current user voted for an issue
     * 
     * Check whether the authenticated user has voted for this issue.
     * A 204 status code indicates that the user has voted, while a 404
     * implies they haven't.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetRepositoriesWorkspaceRepoSlugIssuesIssueIdVoteRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\GetRepositoriesWorkspaceRepoSlugIssuesIssueIdVoteSecurity $security
     * @return \OpenAPI\OpenAPI\Models\Operations\GetRepositoriesWorkspaceRepoSlugIssuesIssueIdVoteResponse
     */
	public function getRepositoriesWorkspaceRepoSlugIssuesIssueIdVote(
        \OpenAPI\OpenAPI\Models\Operations\GetRepositoriesWorkspaceRepoSlugIssuesIssueIdVoteRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\GetRepositoriesWorkspaceRepoSlugIssuesIssueIdVoteSecurity $security,
    ): \OpenAPI\OpenAPI\Models\Operations\GetRepositoriesWorkspaceRepoSlugIssuesIssueIdVoteResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/repositories/{workspace}/{repo_slug}/issues/{issue_id}/vote', \OpenAPI\OpenAPI\Models\Operations\GetRepositoriesWorkspaceRepoSlugIssuesIssueIdVoteRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetRepositoriesWorkspaceRepoSlugIssuesIssueIdVoteResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 204 or $httpResponse->getStatusCode() === 401 or $httpResponse->getStatusCode() === 404) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->error = $serializer->deserialize((string)$httpResponse->getBody(), 'array<string, mixed>', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Check if current user is watching a issue
     * 
     * Indicated whether or not the authenticated user is watching this
     * issue.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetRepositoriesWorkspaceRepoSlugIssuesIssueIdWatchRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\GetRepositoriesWorkspaceRepoSlugIssuesIssueIdWatchSecurity $security
     * @return \OpenAPI\OpenAPI\Models\Operations\GetRepositoriesWorkspaceRepoSlugIssuesIssueIdWatchResponse
     */
	public function getRepositoriesWorkspaceRepoSlugIssuesIssueIdWatch(
        \OpenAPI\OpenAPI\Models\Operations\GetRepositoriesWorkspaceRepoSlugIssuesIssueIdWatchRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\GetRepositoriesWorkspaceRepoSlugIssuesIssueIdWatchSecurity $security,
    ): \OpenAPI\OpenAPI\Models\Operations\GetRepositoriesWorkspaceRepoSlugIssuesIssueIdWatchResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/repositories/{workspace}/{repo_slug}/issues/{issue_id}/watch', \OpenAPI\OpenAPI\Models\Operations\GetRepositoriesWorkspaceRepoSlugIssuesIssueIdWatchRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetRepositoriesWorkspaceRepoSlugIssuesIssueIdWatchResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 204 or $httpResponse->getStatusCode() === 401 or $httpResponse->getStatusCode() === 404) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->error = $serializer->deserialize((string)$httpResponse->getBody(), 'array<string, mixed>', 'json');
            }
        }

        return $response;
    }
	
    /**
     * List milestones
     * 
     * Returns the milestones that have been defined in the issue tracker.
     * 
     * This resource is only available on repositories that have the issue
     * tracker enabled.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetRepositoriesWorkspaceRepoSlugMilestonesRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\GetRepositoriesWorkspaceRepoSlugMilestonesSecurity $security
     * @return \OpenAPI\OpenAPI\Models\Operations\GetRepositoriesWorkspaceRepoSlugMilestonesResponse
     */
	public function getRepositoriesWorkspaceRepoSlugMilestones(
        \OpenAPI\OpenAPI\Models\Operations\GetRepositoriesWorkspaceRepoSlugMilestonesRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\GetRepositoriesWorkspaceRepoSlugMilestonesSecurity $security,
    ): \OpenAPI\OpenAPI\Models\Operations\GetRepositoriesWorkspaceRepoSlugMilestonesResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/repositories/{workspace}/{repo_slug}/milestones', \OpenAPI\OpenAPI\Models\Operations\GetRepositoriesWorkspaceRepoSlugMilestonesRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetRepositoriesWorkspaceRepoSlugMilestonesResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->paginatedMilestones = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\PaginatedMilestones', 'json');
            }
        }
        else if ($httpResponse->getStatusCode() === 404) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->error = $serializer->deserialize((string)$httpResponse->getBody(), 'array<string, mixed>', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Get a milestone
     * 
     * Returns the specified issue tracker milestone object.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetRepositoriesWorkspaceRepoSlugMilestonesMilestoneIdRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\GetRepositoriesWorkspaceRepoSlugMilestonesMilestoneIdSecurity $security
     * @return \OpenAPI\OpenAPI\Models\Operations\GetRepositoriesWorkspaceRepoSlugMilestonesMilestoneIdResponse
     */
	public function getRepositoriesWorkspaceRepoSlugMilestonesMilestoneId(
        \OpenAPI\OpenAPI\Models\Operations\GetRepositoriesWorkspaceRepoSlugMilestonesMilestoneIdRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\GetRepositoriesWorkspaceRepoSlugMilestonesMilestoneIdSecurity $security,
    ): \OpenAPI\OpenAPI\Models\Operations\GetRepositoriesWorkspaceRepoSlugMilestonesMilestoneIdResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/repositories/{workspace}/{repo_slug}/milestones/{milestone_id}', \OpenAPI\OpenAPI\Models\Operations\GetRepositoriesWorkspaceRepoSlugMilestonesMilestoneIdRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetRepositoriesWorkspaceRepoSlugMilestonesMilestoneIdResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->milestone = $serializer->deserialize((string)$httpResponse->getBody(), 'array<string, mixed>', 'json');
            }
        }
        else if ($httpResponse->getStatusCode() === 404) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->error = $serializer->deserialize((string)$httpResponse->getBody(), 'array<string, mixed>', 'json');
            }
        }

        return $response;
    }
	
    /**
     * List defined versions for issues
     * 
     * Returns the versions that have been defined in the issue tracker.
     * 
     * This resource is only available on repositories that have the issue
     * tracker enabled.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetRepositoriesWorkspaceRepoSlugVersionsRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\GetRepositoriesWorkspaceRepoSlugVersionsSecurity $security
     * @return \OpenAPI\OpenAPI\Models\Operations\GetRepositoriesWorkspaceRepoSlugVersionsResponse
     */
	public function getRepositoriesWorkspaceRepoSlugVersions(
        \OpenAPI\OpenAPI\Models\Operations\GetRepositoriesWorkspaceRepoSlugVersionsRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\GetRepositoriesWorkspaceRepoSlugVersionsSecurity $security,
    ): \OpenAPI\OpenAPI\Models\Operations\GetRepositoriesWorkspaceRepoSlugVersionsResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/repositories/{workspace}/{repo_slug}/versions', \OpenAPI\OpenAPI\Models\Operations\GetRepositoriesWorkspaceRepoSlugVersionsRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetRepositoriesWorkspaceRepoSlugVersionsResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->paginatedVersions = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\PaginatedVersions', 'json');
            }
        }
        else if ($httpResponse->getStatusCode() === 404) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->error = $serializer->deserialize((string)$httpResponse->getBody(), 'array<string, mixed>', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Get a defined version for issues
     * 
     * Returns the specified issue tracker version object.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetRepositoriesWorkspaceRepoSlugVersionsVersionIdRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\GetRepositoriesWorkspaceRepoSlugVersionsVersionIdSecurity $security
     * @return \OpenAPI\OpenAPI\Models\Operations\GetRepositoriesWorkspaceRepoSlugVersionsVersionIdResponse
     */
	public function getRepositoriesWorkspaceRepoSlugVersionsVersionId(
        \OpenAPI\OpenAPI\Models\Operations\GetRepositoriesWorkspaceRepoSlugVersionsVersionIdRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\GetRepositoriesWorkspaceRepoSlugVersionsVersionIdSecurity $security,
    ): \OpenAPI\OpenAPI\Models\Operations\GetRepositoriesWorkspaceRepoSlugVersionsVersionIdResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/repositories/{workspace}/{repo_slug}/versions/{version_id}', \OpenAPI\OpenAPI\Models\Operations\GetRepositoriesWorkspaceRepoSlugVersionsVersionIdRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetRepositoriesWorkspaceRepoSlugVersionsVersionIdResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->version = $serializer->deserialize((string)$httpResponse->getBody(), 'array<string, mixed>', 'json');
            }
        }
        else if ($httpResponse->getStatusCode() === 404) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->error = $serializer->deserialize((string)$httpResponse->getBody(), 'array<string, mixed>', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Create an issue
     * 
     * Creates a new issue.
     * 
     * This call requires authentication. Private repositories or private
     * issue trackers require the caller to authenticate with an account that
     * has appropriate authorization.
     * 
     * The authenticated user is used for the issue's `reporter` field.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\PostRepositoriesWorkspaceRepoSlugIssuesRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\PostRepositoriesWorkspaceRepoSlugIssuesSecurity $security
     * @return \OpenAPI\OpenAPI\Models\Operations\PostRepositoriesWorkspaceRepoSlugIssuesResponse
     */
	public function postRepositoriesWorkspaceRepoSlugIssues(
        \OpenAPI\OpenAPI\Models\Operations\PostRepositoriesWorkspaceRepoSlugIssuesRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\PostRepositoriesWorkspaceRepoSlugIssuesSecurity $security,
    ): \OpenAPI\OpenAPI\Models\Operations\PostRepositoriesWorkspaceRepoSlugIssuesResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/repositories/{workspace}/{repo_slug}/issues', \OpenAPI\OpenAPI\Models\Operations\PostRepositoriesWorkspaceRepoSlugIssuesRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "requestBody", "json");
        if ($body === null) {
            throw new \Exception('Request body is required');
        }
        $options = array_merge_recursive($options, $body);
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\PostRepositoriesWorkspaceRepoSlugIssuesResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 201) {
            $response->headers = $httpResponse->getHeaders();
            
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->issue = $serializer->deserialize((string)$httpResponse->getBody(), 'array<string, mixed>', 'json');
            }
        }
        else if ($httpResponse->getStatusCode() === 401 or $httpResponse->getStatusCode() === 403 or $httpResponse->getStatusCode() === 404) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->error = $serializer->deserialize((string)$httpResponse->getBody(), 'array<string, mixed>', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Export issues
     * 
     * A POST request to this endpoint initiates a new background celery task that archives the repo's issues.
     * 
     * For example, you can run:
     * 
     * curl -u <username> -X POST http://api.bitbucket.org/2.0/repositories/<owner_username>/<repo_slug>/
     * issues/export
     * 
     * When the job has been accepted, it will return a 202 (Accepted) along with a unique url to this job in the
     * 'Location' response header. This url is the endpoint for where the user can obtain their zip files."
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\PostRepositoriesWorkspaceRepoSlugIssuesExportRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\PostRepositoriesWorkspaceRepoSlugIssuesExportSecurity $security
     * @return \OpenAPI\OpenAPI\Models\Operations\PostRepositoriesWorkspaceRepoSlugIssuesExportResponse
     */
	public function postRepositoriesWorkspaceRepoSlugIssuesExport(
        \OpenAPI\OpenAPI\Models\Operations\PostRepositoriesWorkspaceRepoSlugIssuesExportRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\PostRepositoriesWorkspaceRepoSlugIssuesExportSecurity $security,
    ): \OpenAPI\OpenAPI\Models\Operations\PostRepositoriesWorkspaceRepoSlugIssuesExportResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/repositories/{workspace}/{repo_slug}/issues/export', \OpenAPI\OpenAPI\Models\Operations\PostRepositoriesWorkspaceRepoSlugIssuesExportRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "requestBody", "json");
        $options = array_merge_recursive($options, $body);
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\PostRepositoriesWorkspaceRepoSlugIssuesExportResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 202) {
        }
        else if ($httpResponse->getStatusCode() === 401 or $httpResponse->getStatusCode() === 403 or $httpResponse->getStatusCode() === 404) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->error = $serializer->deserialize((string)$httpResponse->getBody(), 'array<string, mixed>', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Import issues
     * 
     * A POST request to this endpoint will import the zip file given by the archive parameter into the repository. All
     * existing issues will be deleted and replaced by the contents of the imported zip file.
     * 
     * Imports are done through a multipart/form-data POST. There is one valid and required form field, with the name
     * "archive," which needs to be a file field:
     * 
     * ```
     * $ curl -u <username> -X POST -F archive=@/path/to/file.zip https://api.bitbucket.org/2.0/repositories/<owner_username>/<repo_slug>/issues/import
     * ```
     * 
     * When the import job is accepted, here is example output:
     * 
     * ```
     * < HTTP/1.1 202 Accepted
     * 
     * {
     *     "type": "issue_job_status",
     *     "status": "ACCEPTED",
     *     "phase": "Attachments",
     *     "total": 15,
     *     "count": 0,
     *     "percent": 0
     * }
     * ```
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\PostRepositoriesWorkspaceRepoSlugIssuesImportRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\PostRepositoriesWorkspaceRepoSlugIssuesImportSecurity $security
     * @return \OpenAPI\OpenAPI\Models\Operations\PostRepositoriesWorkspaceRepoSlugIssuesImportResponse
     */
	public function postRepositoriesWorkspaceRepoSlugIssuesImport(
        \OpenAPI\OpenAPI\Models\Operations\PostRepositoriesWorkspaceRepoSlugIssuesImportRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\PostRepositoriesWorkspaceRepoSlugIssuesImportSecurity $security,
    ): \OpenAPI\OpenAPI\Models\Operations\PostRepositoriesWorkspaceRepoSlugIssuesImportResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/repositories/{workspace}/{repo_slug}/issues/import', \OpenAPI\OpenAPI\Models\Operations\PostRepositoriesWorkspaceRepoSlugIssuesImportRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\PostRepositoriesWorkspaceRepoSlugIssuesImportResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 202) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->issueJobStatus = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\IssueJobStatus', 'json');
            }
        }
        else if ($httpResponse->getStatusCode() === 401 or $httpResponse->getStatusCode() === 403 or $httpResponse->getStatusCode() === 404 or $httpResponse->getStatusCode() === 409) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->error = $serializer->deserialize((string)$httpResponse->getBody(), 'array<string, mixed>', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Upload an attachment to an issue
     * 
     * Upload new issue attachments.
     * 
     * To upload files, perform a `multipart/form-data` POST containing one
     * or more file fields.
     * 
     * When a file is uploaded with the same name as an existing attachment,
     * then the existing file will be replaced.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\PostRepositoriesWorkspaceRepoSlugIssuesIssueIdAttachmentsRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\PostRepositoriesWorkspaceRepoSlugIssuesIssueIdAttachmentsSecurity $security
     * @return \OpenAPI\OpenAPI\Models\Operations\PostRepositoriesWorkspaceRepoSlugIssuesIssueIdAttachmentsResponse
     */
	public function postRepositoriesWorkspaceRepoSlugIssuesIssueIdAttachments(
        \OpenAPI\OpenAPI\Models\Operations\PostRepositoriesWorkspaceRepoSlugIssuesIssueIdAttachmentsRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\PostRepositoriesWorkspaceRepoSlugIssuesIssueIdAttachmentsSecurity $security,
    ): \OpenAPI\OpenAPI\Models\Operations\PostRepositoriesWorkspaceRepoSlugIssuesIssueIdAttachmentsResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/repositories/{workspace}/{repo_slug}/issues/{issue_id}/attachments', \OpenAPI\OpenAPI\Models\Operations\PostRepositoriesWorkspaceRepoSlugIssuesIssueIdAttachmentsRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\PostRepositoriesWorkspaceRepoSlugIssuesIssueIdAttachmentsResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 201) {
            $response->headers = $httpResponse->getHeaders();
            
        }
        else if ($httpResponse->getStatusCode() === 400 or $httpResponse->getStatusCode() === 401) {
        }
        else if ($httpResponse->getStatusCode() === 404) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->error = $serializer->deserialize((string)$httpResponse->getBody(), 'array<string, mixed>', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Modify the state of an issue
     * 
     * Makes a change to the specified issue.
     * 
     * For example, to change an issue's state and assignee, create a new
     * change object that modifies these fields:
     * 
     * ```
     * curl https://api.bitbucket.org/2.0/site/master/issues/1234/changes \
     *   -s -u evzijst -X POST -H "Content-Type: application/json" \
     *   -d '{
     *     "changes": {
     *       "assignee_account_id": {
     *         "new": "557058:c0b72ad0-1cb5-4018-9cdc-0cde8492c443"
     *       },
     *       "state": {
     *         "new": 'resolved"
     *       }
     *     }
     *     "message": {
     *       "raw": "This is now resolved."
     *     }
     *   }'
     * ```
     * 
     * The above example also includes a custom comment to go alongside the
     * change. This comment will also be visible on the issue page in the UI.
     * 
     * The fields of the `changes` object are strings, not objects. This
     * allows for immutable change log records, even after user accounts,
     * milestones, or other objects recorded in a change entry, get renamed or
     * deleted.
     * 
     * The `assignee_account_id` field stores the account id. When POSTing a
     * new change and changing the assignee, the client should therefore use
     * the user's account_id in the `changes.assignee_account_id.new` field.
     * 
     * This call requires authentication. Private repositories or private
     * issue trackers require the caller to authenticate with an account that
     * has appropriate authorization.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\PostRepositoriesWorkspaceRepoSlugIssuesIssueIdChangesRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\PostRepositoriesWorkspaceRepoSlugIssuesIssueIdChangesSecurity $security
     * @return \OpenAPI\OpenAPI\Models\Operations\PostRepositoriesWorkspaceRepoSlugIssuesIssueIdChangesResponse
     */
	public function postRepositoriesWorkspaceRepoSlugIssuesIssueIdChanges(
        \OpenAPI\OpenAPI\Models\Operations\PostRepositoriesWorkspaceRepoSlugIssuesIssueIdChangesRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\PostRepositoriesWorkspaceRepoSlugIssuesIssueIdChangesSecurity $security,
    ): \OpenAPI\OpenAPI\Models\Operations\PostRepositoriesWorkspaceRepoSlugIssuesIssueIdChangesResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/repositories/{workspace}/{repo_slug}/issues/{issue_id}/changes', \OpenAPI\OpenAPI\Models\Operations\PostRepositoriesWorkspaceRepoSlugIssuesIssueIdChangesRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "requestBody", "json");
        if ($body === null) {
            throw new \Exception('Request body is required');
        }
        $options = array_merge_recursive($options, $body);
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\PostRepositoriesWorkspaceRepoSlugIssuesIssueIdChangesResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 201) {
            $response->headers = $httpResponse->getHeaders();
            
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->issueChange = $serializer->deserialize((string)$httpResponse->getBody(), 'array<string, mixed>', 'json');
            }
        }
        else if ($httpResponse->getStatusCode() === 401 or $httpResponse->getStatusCode() === 403 or $httpResponse->getStatusCode() === 404) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->error = $serializer->deserialize((string)$httpResponse->getBody(), 'array<string, mixed>', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Create a comment on an issue
     * 
     * Creates a new issue comment.
     * 
     * ```
     * $ curl https://api.bitbucket.org/2.0/repositories/atlassian/prlinks/issues/42/comments/ \
     *   -X POST -u evzijst \
     *   -H 'Content-Type: application/json' \
     *   -d '{"content": {"raw": "Lorem ipsum."}}'
     * ```
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\PostRepositoriesWorkspaceRepoSlugIssuesIssueIdCommentsRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\PostRepositoriesWorkspaceRepoSlugIssuesIssueIdCommentsSecurity $security
     * @return \OpenAPI\OpenAPI\Models\Operations\PostRepositoriesWorkspaceRepoSlugIssuesIssueIdCommentsResponse
     */
	public function postRepositoriesWorkspaceRepoSlugIssuesIssueIdComments(
        \OpenAPI\OpenAPI\Models\Operations\PostRepositoriesWorkspaceRepoSlugIssuesIssueIdCommentsRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\PostRepositoriesWorkspaceRepoSlugIssuesIssueIdCommentsSecurity $security,
    ): \OpenAPI\OpenAPI\Models\Operations\PostRepositoriesWorkspaceRepoSlugIssuesIssueIdCommentsResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/repositories/{workspace}/{repo_slug}/issues/{issue_id}/comments', \OpenAPI\OpenAPI\Models\Operations\PostRepositoriesWorkspaceRepoSlugIssuesIssueIdCommentsRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "requestBody", "json");
        if ($body === null) {
            throw new \Exception('Request body is required');
        }
        $options = array_merge_recursive($options, $body);
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\PostRepositoriesWorkspaceRepoSlugIssuesIssueIdCommentsResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 201) {
            $response->headers = $httpResponse->getHeaders();
            
        }
        else if ($httpResponse->getStatusCode() === 400) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->error = $serializer->deserialize((string)$httpResponse->getBody(), 'array<string, mixed>', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Update an issue
     * 
     * Modifies the issue.
     * 
     * ```
     * $ curl https://api.bitbucket.org/2.0/repostories/evzijst/dogslow/issues/123 \
     *   -u evzijst -s -X PUT -H 'Content-Type: application/json' \
     *   -d '{
     *   "title": "Updated title",
     *   "assignee": {
     *     "account_id": "5d5355e8c6b9320d9ea5b28d"
     *   },
     *   "priority": "minor",
     *   "version": {
     *     "name": "1.0"
     *   },
     *   "component": null
     * }'
     * ```
     * 
     * This example changes the `title`, `assignee`, `priority` and the
     * `version`. It also removes the value of the `component` from the issue
     * by setting the field to `null`. Any field not present keeps its existing
     * value.
     * 
     * Each time an issue is edited in the UI or through the API, an immutable
     * change record is created under the `/issues/123/changes` endpoint. It
     * also has a comment associated with the change.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\PutRepositoriesWorkspaceRepoSlugIssuesIssueIdRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\PutRepositoriesWorkspaceRepoSlugIssuesIssueIdSecurity $security
     * @return \OpenAPI\OpenAPI\Models\Operations\PutRepositoriesWorkspaceRepoSlugIssuesIssueIdResponse
     */
	public function putRepositoriesWorkspaceRepoSlugIssuesIssueId(
        \OpenAPI\OpenAPI\Models\Operations\PutRepositoriesWorkspaceRepoSlugIssuesIssueIdRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\PutRepositoriesWorkspaceRepoSlugIssuesIssueIdSecurity $security,
    ): \OpenAPI\OpenAPI\Models\Operations\PutRepositoriesWorkspaceRepoSlugIssuesIssueIdResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/repositories/{workspace}/{repo_slug}/issues/{issue_id}', \OpenAPI\OpenAPI\Models\Operations\PutRepositoriesWorkspaceRepoSlugIssuesIssueIdRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('PUT', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\PutRepositoriesWorkspaceRepoSlugIssuesIssueIdResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->issue = $serializer->deserialize((string)$httpResponse->getBody(), 'array<string, mixed>', 'json');
            }
        }
        else if ($httpResponse->getStatusCode() === 403 or $httpResponse->getStatusCode() === 404) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->error = $serializer->deserialize((string)$httpResponse->getBody(), 'array<string, mixed>', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Update a comment on an issue
     * 
     * Updates the content of the specified issue comment. Note that only
     * the `content.raw` field can be modified.
     * 
     * ```
     * $ curl https://api.bitbucket.org/2.0/repositories/atlassian/prlinks/issues/42/comments/5728901 \
     *   -X PUT -u evzijst \
     *   -H 'Content-Type: application/json' \
     *   -d '{"content": {"raw": "Lorem ipsum."}'
     * ```
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\PutRepositoriesWorkspaceRepoSlugIssuesIssueIdCommentsCommentIdRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\PutRepositoriesWorkspaceRepoSlugIssuesIssueIdCommentsCommentIdSecurity $security
     * @return \OpenAPI\OpenAPI\Models\Operations\PutRepositoriesWorkspaceRepoSlugIssuesIssueIdCommentsCommentIdResponse
     */
	public function putRepositoriesWorkspaceRepoSlugIssuesIssueIdCommentsCommentId(
        \OpenAPI\OpenAPI\Models\Operations\PutRepositoriesWorkspaceRepoSlugIssuesIssueIdCommentsCommentIdRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\PutRepositoriesWorkspaceRepoSlugIssuesIssueIdCommentsCommentIdSecurity $security,
    ): \OpenAPI\OpenAPI\Models\Operations\PutRepositoriesWorkspaceRepoSlugIssuesIssueIdCommentsCommentIdResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/repositories/{workspace}/{repo_slug}/issues/{issue_id}/comments/{comment_id}', \OpenAPI\OpenAPI\Models\Operations\PutRepositoriesWorkspaceRepoSlugIssuesIssueIdCommentsCommentIdRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "requestBody", "json");
        if ($body === null) {
            throw new \Exception('Request body is required');
        }
        $options = array_merge_recursive($options, $body);
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('PUT', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\PutRepositoriesWorkspaceRepoSlugIssuesIssueIdCommentsCommentIdResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->issueComment = $serializer->deserialize((string)$httpResponse->getBody(), 'array<string, mixed>', 'json');
            }
        }
        else if ($httpResponse->getStatusCode() === 400) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->error = $serializer->deserialize((string)$httpResponse->getBody(), 'array<string, mixed>', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Vote for an issue
     * 
     * Vote for this issue.
     * 
     * To cast your vote, do an empty PUT. The 204 status code indicates that
     * the operation was successful.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\PutRepositoriesWorkspaceRepoSlugIssuesIssueIdVoteRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\PutRepositoriesWorkspaceRepoSlugIssuesIssueIdVoteSecurity $security
     * @return \OpenAPI\OpenAPI\Models\Operations\PutRepositoriesWorkspaceRepoSlugIssuesIssueIdVoteResponse
     */
	public function putRepositoriesWorkspaceRepoSlugIssuesIssueIdVote(
        \OpenAPI\OpenAPI\Models\Operations\PutRepositoriesWorkspaceRepoSlugIssuesIssueIdVoteRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\PutRepositoriesWorkspaceRepoSlugIssuesIssueIdVoteSecurity $security,
    ): \OpenAPI\OpenAPI\Models\Operations\PutRepositoriesWorkspaceRepoSlugIssuesIssueIdVoteResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/repositories/{workspace}/{repo_slug}/issues/{issue_id}/vote', \OpenAPI\OpenAPI\Models\Operations\PutRepositoriesWorkspaceRepoSlugIssuesIssueIdVoteRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('PUT', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\PutRepositoriesWorkspaceRepoSlugIssuesIssueIdVoteResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 204 or $httpResponse->getStatusCode() === 401 or $httpResponse->getStatusCode() === 404) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->error = $serializer->deserialize((string)$httpResponse->getBody(), 'array<string, mixed>', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Watch an issue
     * 
     * Start watching this issue.
     * 
     * To start watching this issue, do an empty PUT. The 204 status code
     * indicates that the operation was successful.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\PutRepositoriesWorkspaceRepoSlugIssuesIssueIdWatchRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\PutRepositoriesWorkspaceRepoSlugIssuesIssueIdWatchSecurity $security
     * @return \OpenAPI\OpenAPI\Models\Operations\PutRepositoriesWorkspaceRepoSlugIssuesIssueIdWatchResponse
     */
	public function putRepositoriesWorkspaceRepoSlugIssuesIssueIdWatch(
        \OpenAPI\OpenAPI\Models\Operations\PutRepositoriesWorkspaceRepoSlugIssuesIssueIdWatchRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\PutRepositoriesWorkspaceRepoSlugIssuesIssueIdWatchSecurity $security,
    ): \OpenAPI\OpenAPI\Models\Operations\PutRepositoriesWorkspaceRepoSlugIssuesIssueIdWatchResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/repositories/{workspace}/{repo_slug}/issues/{issue_id}/watch', \OpenAPI\OpenAPI\Models\Operations\PutRepositoriesWorkspaceRepoSlugIssuesIssueIdWatchRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('PUT', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\PutRepositoriesWorkspaceRepoSlugIssuesIssueIdWatchResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 204 or $httpResponse->getStatusCode() === 401 or $httpResponse->getStatusCode() === 404) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->error = $serializer->deserialize((string)$httpResponse->getBody(), 'array<string, mixed>', 'json');
            }
        }

        return $response;
    }
}