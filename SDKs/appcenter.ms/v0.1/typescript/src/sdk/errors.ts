/*
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

import * as utils from "../internal/utils";
import * as operations from "./models/operations";
import * as shared from "./models/shared";
import { AxiosInstance, AxiosRequestConfig, AxiosResponse } from "axios";

export class Errors {
  _defaultClient: AxiosInstance;
  _securityClient: AxiosInstance;
  _serverURL: string;
  _language: string;
  _sdkVersion: string;
  _genVersion: string;

  constructor(
    defaultClient: AxiosInstance,
    securityClient: AxiosInstance,
    serverURL: string,
    language: string,
    sdkVersion: string,
    genVersion: string
  ) {
    this._defaultClient = defaultClient;
    this._securityClient = securityClient;
    this._serverURL = serverURL;
    this._language = language;
    this._sdkVersion = sdkVersion;
    this._genVersion = genVersion;
  }

  /**
   * List of app builds
   */
  errorsAppBuildsList(
    req: operations.ErrorsAppBuildsListRequest,
    security: operations.ErrorsAppBuildsListSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.ErrorsAppBuildsListResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ErrorsAppBuildsListRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v0.1/apps/{owner_name}/{app_name}/errors/availableAppBuilds",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ErrorsAppBuildsListSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ErrorsAppBuildsListResponse =
        new operations.ErrorsAppBuildsListResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorsAppBuildsList200ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.ErrorsAppBuildsList200ApplicationJSON
              );
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorsAppBuildsListDefaultApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.ErrorsAppBuildsListDefaultApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Get all available versions in the time range.
   */
  errorsAvailableVersions(
    req: operations.ErrorsAvailableVersionsRequest,
    security: operations.ErrorsAvailableVersionsSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.ErrorsAvailableVersionsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ErrorsAvailableVersionsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v0.1/apps/{owner_name}/{app_name}/errors/available_versions",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ErrorsAvailableVersionsSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ErrorsAvailableVersionsResponse =
        new operations.ErrorsAvailableVersionsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorsAvailableVersions200ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.ErrorsAvailableVersions200ApplicationJSON
              );
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorsAvailableVersionsDefaultApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.ErrorsAvailableVersionsDefaultApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Count of crashes or errors by day in the time range based the selected versions. If SingleErrorTypeParameter is not provided, defaults to handlederror.
   */
  errorsCountsPerDay(
    req: operations.ErrorsCountsPerDayRequest,
    security: operations.ErrorsCountsPerDaySecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.ErrorsCountsPerDayResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ErrorsCountsPerDayRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v0.1/apps/{owner_name}/{app_name}/errors/errorCountsPerDay",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ErrorsCountsPerDaySecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ErrorsCountsPerDayResponse =
        new operations.ErrorsCountsPerDayResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorsCountsPerDay200ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.ErrorsCountsPerDay200ApplicationJSON
              );
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorsCountsPerDayDefaultApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.ErrorsCountsPerDayDefaultApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Delete a specific error and related attachments and blobs for an app. Searchable data will not be deleted immediately and may take up to 30 days.
   */
  errorsDeleteError(
    req: operations.ErrorsDeleteErrorRequest,
    security: operations.ErrorsDeleteErrorSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.ErrorsDeleteErrorResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ErrorsDeleteErrorRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v0.1/apps/{owner_name}/{app_name}/errors/errorGroups/{errorGroupId}/errors/{errorId}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ErrorsDeleteErrorSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ErrorsDeleteErrorResponse =
        new operations.ErrorsDeleteErrorResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorsDeleteError200ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.ErrorsDeleteError200ApplicationJSON
            );
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorsDeleteErrorDefaultApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.ErrorsDeleteErrorDefaultApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Error attachment location.
   */
  errorsErrorAttachmentLocation(
    req: operations.ErrorsErrorAttachmentLocationRequest,
    security: operations.ErrorsErrorAttachmentLocationSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.ErrorsErrorAttachmentLocationResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ErrorsErrorAttachmentLocationRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v0.1/apps/{owner_name}/{app_name}/errors/{errorId}/attachments/{attachmentId}/location",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ErrorsErrorAttachmentLocationSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ErrorsErrorAttachmentLocationResponse =
        new operations.ErrorsErrorAttachmentLocationResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorsErrorAttachmentLocation200ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.ErrorsErrorAttachmentLocation200ApplicationJSON
              );
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorsErrorAttachmentLocationDefaultApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.ErrorsErrorAttachmentLocationDefaultApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Error attachment text.
   */
  errorsErrorAttachmentText(
    req: operations.ErrorsErrorAttachmentTextRequest,
    security: operations.ErrorsErrorAttachmentTextSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.ErrorsErrorAttachmentTextResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ErrorsErrorAttachmentTextRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v0.1/apps/{owner_name}/{app_name}/errors/{errorId}/attachments/{attachmentId}/text",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ErrorsErrorAttachmentTextSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ErrorsErrorAttachmentTextResponse =
        new operations.ErrorsErrorAttachmentTextResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorsErrorAttachmentText200ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.ErrorsErrorAttachmentText200ApplicationJSON
              );
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorsErrorAttachmentTextDefaultApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.ErrorsErrorAttachmentTextDefaultApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * List error attachments.
   */
  errorsErrorAttachments(
    req: operations.ErrorsErrorAttachmentsRequest,
    security: operations.ErrorsErrorAttachmentsSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.ErrorsErrorAttachmentsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ErrorsErrorAttachmentsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v0.1/apps/{owner_name}/{app_name}/errors/{errorId}/attachments",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ErrorsErrorAttachmentsSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ErrorsErrorAttachmentsResponse =
        new operations.ErrorsErrorAttachmentsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorsErrorAttachments200ApplicationJSONObjects = [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.errorsErrorAttachments200ApplicationJSONObjects =
              utils.objectToClass(
                httpRes?.data,
                operations.ErrorsErrorAttachments200ApplicationJSON,
                resFieldDepth
              );
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorsErrorAttachmentsDefaultApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.ErrorsErrorAttachmentsDefaultApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Download details for a specific error.
   */
  errorsErrorDownload(
    req: operations.ErrorsErrorDownloadRequest,
    security: operations.ErrorsErrorDownloadSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.ErrorsErrorDownloadResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ErrorsErrorDownloadRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v0.1/apps/{owner_name}/{app_name}/errors/errorGroups/{errorGroupId}/errors/{errorId}/download",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ErrorsErrorDownloadSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ErrorsErrorDownloadResponse =
        new operations.ErrorsErrorDownloadResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorsErrorDownload200ApplicationJSONFileObject =
              utils.objectToClass(httpRes?.data);
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorsErrorDownloadDefaultApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.ErrorsErrorDownloadDefaultApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Error groups list based on search parameters
   */
  errorsErrorGroupsSearch(
    req: operations.ErrorsErrorGroupsSearchRequest,
    security: operations.ErrorsErrorGroupsSearchSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.ErrorsErrorGroupsSearchResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ErrorsErrorGroupsSearchRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v0.1/apps/{owner_name}/{app_name}/errors/errorGroups/search",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ErrorsErrorGroupsSearchSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ErrorsErrorGroupsSearchResponse =
        new operations.ErrorsErrorGroupsSearchResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorsErrorGroupsSearch200ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.ErrorsErrorGroupsSearch200ApplicationJSON
              );
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorsErrorGroupsSearchDefaultApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.ErrorsErrorGroupsSearchDefaultApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Error location.
   */
  errorsErrorLocation(
    req: operations.ErrorsErrorLocationRequest,
    security: operations.ErrorsErrorLocationSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.ErrorsErrorLocationResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ErrorsErrorLocationRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v0.1/apps/{owner_name}/{app_name}/errors/errorGroups/{errorGroupId}/errors/{errorId}/location",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ErrorsErrorLocationSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ErrorsErrorLocationResponse =
        new operations.ErrorsErrorLocationResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorsErrorLocation200ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.ErrorsErrorLocation200ApplicationJSON
              );
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorsErrorLocationDefaultApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.ErrorsErrorLocationDefaultApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Errors list based on search parameters
   */
  errorsErrorSearch(
    req: operations.ErrorsErrorSearchRequest,
    security: operations.ErrorsErrorSearchSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.ErrorsErrorSearchResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ErrorsErrorSearchRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v0.1/apps/{owner_name}/{app_name}/errors/search",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ErrorsErrorSearchSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ErrorsErrorSearchResponse =
        new operations.ErrorsErrorSearchResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorsErrorSearch200ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.ErrorsErrorSearch200ApplicationJSON
            );
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorsErrorSearchDefaultApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.ErrorsErrorSearchDefaultApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Error Stacktrace details.
   */
  errorsErrorStackTrace(
    req: operations.ErrorsErrorStackTraceRequest,
    security: operations.ErrorsErrorStackTraceSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.ErrorsErrorStackTraceResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ErrorsErrorStackTraceRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v0.1/apps/{owner_name}/{app_name}/errors/errorGroups/{errorGroupId}/errors/{errorId}/stacktrace",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ErrorsErrorStackTraceSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ErrorsErrorStackTraceResponse =
        new operations.ErrorsErrorStackTraceResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.diagnosticsStackTrace = utils.objectToClass(
              httpRes?.data,
              shared.DiagnosticsStackTrace
            );
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorsErrorStackTraceDefaultApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.ErrorsErrorStackTraceDefaultApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Error details.
   */
  errorsGetErrorDetails(
    req: operations.ErrorsGetErrorDetailsRequest,
    security: operations.ErrorsGetErrorDetailsSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.ErrorsGetErrorDetailsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ErrorsGetErrorDetailsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v0.1/apps/{owner_name}/{app_name}/errors/errorGroups/{errorGroupId}/errors/{errorId}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ErrorsGetErrorDetailsSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ErrorsGetErrorDetailsResponse =
        new operations.ErrorsGetErrorDetailsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorsGetErrorDetails200ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.ErrorsGetErrorDetails200ApplicationJSON
              );
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorsGetErrorDetailsDefaultApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.ErrorsGetErrorDetailsDefaultApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Count of errors by day in the time range of the selected error group with selected version
   */
  errorsGroupCountsPerDay(
    req: operations.ErrorsGroupCountsPerDayRequest,
    security: operations.ErrorsGroupCountsPerDaySecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.ErrorsGroupCountsPerDayResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ErrorsGroupCountsPerDayRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v0.1/apps/{owner_name}/{app_name}/errors/errorGroups/{errorGroupId}/errorCountsPerDay",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ErrorsGroupCountsPerDaySecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ErrorsGroupCountsPerDayResponse =
        new operations.ErrorsGroupCountsPerDayResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorsGroupCountsPerDay200ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.ErrorsGroupCountsPerDay200ApplicationJSON
              );
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorsGroupCountsPerDayDefaultApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.ErrorsGroupCountsPerDayDefaultApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Error group details
   */
  errorsGroupDetails(
    req: operations.ErrorsGroupDetailsRequest,
    security: operations.ErrorsGroupDetailsSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.ErrorsGroupDetailsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ErrorsGroupDetailsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v0.1/apps/{owner_name}/{app_name}/errors/errorGroups/{errorGroupId}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ErrorsGroupDetailsSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ErrorsGroupDetailsResponse =
        new operations.ErrorsGroupDetailsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorsGroupDetails200ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.ErrorsGroupDetails200ApplicationJSON
              );
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorsGroupDetailsDefaultApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.ErrorsGroupDetailsDefaultApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Percentage of error-free devices by day in the time range. Api will return -1 if crash devices is greater than active devices
   */
  errorsGroupErrorFreeDevicePercentages(
    req: operations.ErrorsGroupErrorFreeDevicePercentagesRequest,
    security: operations.ErrorsGroupErrorFreeDevicePercentagesSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.ErrorsGroupErrorFreeDevicePercentagesResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ErrorsGroupErrorFreeDevicePercentagesRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v0.1/apps/{owner_name}/{app_name}/errors/errorGroups/{errorGroupId}/errorfreeDevicePercentages",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ErrorsGroupErrorFreeDevicePercentagesSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ErrorsGroupErrorFreeDevicePercentagesResponse =
        new operations.ErrorsGroupErrorFreeDevicePercentagesResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorsGroupErrorFreeDevicePercentages200ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.ErrorsGroupErrorFreeDevicePercentages200ApplicationJSON
              );
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorsGroupErrorFreeDevicePercentagesDefaultApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.ErrorsGroupErrorFreeDevicePercentagesDefaultApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Gets the stack trace for the error group.
   */
  errorsGroupErrorStackTrace(
    req: operations.ErrorsGroupErrorStackTraceRequest,
    security: operations.ErrorsGroupErrorStackTraceSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.ErrorsGroupErrorStackTraceResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ErrorsGroupErrorStackTraceRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v0.1/apps/{owner_name}/{app_name}/errors/errorGroups/{errorGroupId}/stacktrace",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ErrorsGroupErrorStackTraceSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ErrorsGroupErrorStackTraceResponse =
        new operations.ErrorsGroupErrorStackTraceResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.diagnosticsStackTrace = utils.objectToClass(
              httpRes?.data,
              shared.DiagnosticsStackTrace
            );
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorsGroupErrorStackTraceDefaultApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.ErrorsGroupErrorStackTraceDefaultApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * List of error groups
   */
  errorsGroupList(
    req: operations.ErrorsGroupListRequest,
    security: operations.ErrorsGroupListSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.ErrorsGroupListResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ErrorsGroupListRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v0.1/apps/{owner_name}/{app_name}/errors/errorGroups",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ErrorsGroupListSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ErrorsGroupListResponse =
        new operations.ErrorsGroupListResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorsGroupList200ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.ErrorsGroupList200ApplicationJSON
            );
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorsGroupListDefaultApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.ErrorsGroupListDefaultApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Top models of the selected error group.
   */
  errorsGroupModelCounts(
    req: operations.ErrorsGroupModelCountsRequest,
    security: operations.ErrorsGroupModelCountsSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.ErrorsGroupModelCountsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ErrorsGroupModelCountsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v0.1/apps/{owner_name}/{app_name}/errors/errorGroups/{errorGroupId}/models",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ErrorsGroupModelCountsSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ErrorsGroupModelCountsResponse =
        new operations.ErrorsGroupModelCountsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorsGroupModelCounts200ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.ErrorsGroupModelCounts200ApplicationJSON
              );
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorsGroupModelCountsDefaultApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.ErrorsGroupModelCountsDefaultApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Top OSes of the selected error group.
   */
  errorsGroupOperatingSystemCounts(
    req: operations.ErrorsGroupOperatingSystemCountsRequest,
    security: operations.ErrorsGroupOperatingSystemCountsSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.ErrorsGroupOperatingSystemCountsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ErrorsGroupOperatingSystemCountsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v0.1/apps/{owner_name}/{app_name}/errors/errorGroups/{errorGroupId}/operatingSystems",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ErrorsGroupOperatingSystemCountsSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ErrorsGroupOperatingSystemCountsResponse =
        new operations.ErrorsGroupOperatingSystemCountsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorsGroupOperatingSystemCounts200ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.ErrorsGroupOperatingSystemCounts200ApplicationJSON
              );
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorsGroupOperatingSystemCountsDefaultApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.ErrorsGroupOperatingSystemCountsDefaultApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Latest error details.
   */
  errorsLatestErrorDetails(
    req: operations.ErrorsLatestErrorDetailsRequest,
    security: operations.ErrorsLatestErrorDetailsSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.ErrorsLatestErrorDetailsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ErrorsLatestErrorDetailsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v0.1/apps/{owner_name}/{app_name}/errors/errorGroups/{errorGroupId}/errors/latest",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ErrorsLatestErrorDetailsSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ErrorsLatestErrorDetailsResponse =
        new operations.ErrorsLatestErrorDetailsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorsLatestErrorDetails200ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.ErrorsLatestErrorDetails200ApplicationJSON
              );
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorsLatestErrorDetailsDefaultApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.ErrorsLatestErrorDetailsDefaultApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Get all errors for group
   */
  errorsListForGroup(
    req: operations.ErrorsListForGroupRequest,
    security: operations.ErrorsListForGroupSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.ErrorsListForGroupResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ErrorsListForGroupRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v0.1/apps/{owner_name}/{app_name}/errors/errorGroups/{errorGroupId}/errors",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ErrorsListForGroupSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ErrorsListForGroupResponse =
        new operations.ErrorsListForGroupResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorsListForGroup200ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.ErrorsListForGroup200ApplicationJSON
              );
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorsListForGroupDefaultApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.ErrorsListForGroupDefaultApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Get session logs by error ID
   */
  errorsListSessionLogs(
    req: operations.ErrorsListSessionLogsRequest,
    security: operations.ErrorsListSessionLogsSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.ErrorsListSessionLogsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ErrorsListSessionLogsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v0.1/apps/{owner_name}/{app_name}/errors/{errorId}/sessionLogs",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ErrorsListSessionLogsSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ErrorsListSessionLogsResponse =
        new operations.ErrorsListSessionLogsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorsListSessionLogs200ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.ErrorsListSessionLogs200ApplicationJSON
              );
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorsListSessionLogsDefaultApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.ErrorsListSessionLogsDefaultApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Update error group state
   */
  errorsUpdateState(
    req: operations.ErrorsUpdateStateRequest,
    security: operations.ErrorsUpdateStateSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.ErrorsUpdateStateResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ErrorsUpdateStateRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v0.1/apps/{owner_name}/{app_name}/errors/errorGroups/{errorGroupId}",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ErrorsUpdateStateSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "patch",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ErrorsUpdateStateResponse =
        new operations.ErrorsUpdateStateResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorsUpdateState200ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.ErrorsUpdateState200ApplicationJSON
            );
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorsUpdateStateDefaultApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.ErrorsUpdateStateDefaultApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * gets the retention settings in days
   *
   * @remarks
   * gets the retention settings in days
   */
  errorsGetRetentionSettings(
    req: operations.ErrorsGetRetentionSettingsRequest,
    security: operations.ErrorsGetRetentionSettingsSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.ErrorsGetRetentionSettingsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ErrorsGetRetentionSettingsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v0.1/apps/{owner_name}/{app_name}/errors/retention_settings",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ErrorsGetRetentionSettingsSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ErrorsGetRetentionSettingsResponse =
        new operations.ErrorsGetRetentionSettingsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorsGetRetentionSettings200ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.ErrorsGetRetentionSettings200ApplicationJSON
              );
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorsGetRetentionSettingsDefaultApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.ErrorsGetRetentionSettingsDefaultApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }
}
