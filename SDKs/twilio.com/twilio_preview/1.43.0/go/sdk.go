// Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.

package sdk

import (
	"context"
	"fmt"
	"net/http"
	"openapi/pkg/models/operations"
	"openapi/pkg/models/shared"
	"openapi/pkg/utils"
	"strings"
	"time"
)

// ServerList contains the list of servers available to the SDK
var ServerList = []string{
	"https://preview.twilio.com",
}

// HTTPClient provides an interface for suplying the SDK with a custom HTTP client
type HTTPClient interface {
	Do(req *http.Request) (*http.Response, error)
}

// String provides a helper function to return a pointer to a string
func String(s string) *string { return &s }

// Bool provides a helper function to return a pointer to a bool
func Bool(b bool) *bool { return &b }

// Int provides a helper function to return a pointer to an int
func Int(i int) *int { return &i }

// Int64 provides a helper function to return a pointer to an int64
func Int64(i int64) *int64 { return &i }

// Float32 provides a helper function to return a pointer to a float32
func Float32(f float32) *float32 { return &f }

// Float64 provides a helper function to return a pointer to a float64
func Float64(f float64) *float64 { return &f }

// SDK - This is the public Twilio REST API.
type SDK struct {

	// Non-idiomatic field names below are to namespace fields from the fields names above to avoid name conflicts
	_defaultClient  HTTPClient
	_securityClient HTTPClient

	_serverURL  string
	_language   string
	_sdkVersion string
	_genVersion string
}

type SDKOption func(*SDK)

// WithServerURL allows the overriding of the default server URL
func WithServerURL(serverURL string) SDKOption {
	return func(sdk *SDK) {
		sdk._serverURL = serverURL
	}
}

// WithTemplatedServerURL allows the overriding of the default server URL with a templated URL populated with the provided parameters
func WithTemplatedServerURL(serverURL string, params map[string]string) SDKOption {
	return func(sdk *SDK) {
		if params != nil {
			serverURL = utils.ReplaceParameters(serverURL, params)
		}

		sdk._serverURL = serverURL
	}
}

// WithClient allows the overriding of the default HTTP client used by the SDK
func WithClient(client HTTPClient) SDKOption {
	return func(sdk *SDK) {
		sdk._defaultClient = client
	}
}

// New creates a new instance of the SDK with the provided options
func New(opts ...SDKOption) *SDK {
	sdk := &SDK{
		_language:   "go",
		_sdkVersion: "0.0.1",
		_genVersion: "internal",
	}
	for _, opt := range opts {
		opt(sdk)
	}

	// Use WithClient to override the default client if you would like to customize the timeout
	if sdk._defaultClient == nil {
		sdk._defaultClient = &http.Client{Timeout: 60 * time.Second}
	}
	if sdk._securityClient == nil {
		sdk._securityClient = sdk._defaultClient
	}

	if sdk._serverURL == "" {
		sdk._serverURL = ServerList[0]
	}

	return sdk
}

// CreateDeployedDevicesCertificate - Enroll a new Certificate credential to the Fleet, optionally giving it a friendly name and assigning to a Device.
func (s *SDK) CreateDeployedDevicesCertificate(ctx context.Context, request operations.CreateDeployedDevicesCertificateRequest, security operations.CreateDeployedDevicesCertificateSecurity, opts ...operations.Option) (*operations.CreateDeployedDevicesCertificateResponse, error) {
	o := operations.Options{}
	supportedOptions := []string{
		operations.SupportedOptionServerURL,
	}

	for _, opt := range opts {
		if err := opt(&o, supportedOptions...); err != nil {
			return nil, fmt.Errorf("error applying option: %w", err)
		}
	}
	baseURL := operations.CreateDeployedDevicesCertificateServerList[0]
	if o.ServerURL != nil {
		baseURL = *o.ServerURL
	}

	url, err := utils.GenerateURL(ctx, baseURL, "/DeployedDevices/Fleets/{FleetSid}/Certificates", request, nil)
	if err != nil {
		return nil, fmt.Errorf("error generating URL: %w", err)
	}

	bodyReader, reqContentType, err := utils.SerializeRequestBody(ctx, request, "RequestBody", "form")
	if err != nil {
		return nil, fmt.Errorf("error serializing request body: %w", err)
	}

	req, err := http.NewRequestWithContext(ctx, "POST", url, bodyReader)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	req.Header.Set("Content-Type", reqContentType)

	client := utils.ConfigureSecurityClient(s._defaultClient, security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.CreateDeployedDevicesCertificateResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 201:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *shared.PreviewDeployedDevicesFleetCertificate
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.PreviewDeployedDevicesFleetCertificate = out
		}
	}

	return res, nil
}

// CreateDeployedDevicesDeployment - Create a new Deployment in the Fleet, optionally giving it a friendly name and linking to a specific Twilio Sync service instance.
func (s *SDK) CreateDeployedDevicesDeployment(ctx context.Context, request operations.CreateDeployedDevicesDeploymentRequest, security operations.CreateDeployedDevicesDeploymentSecurity, opts ...operations.Option) (*operations.CreateDeployedDevicesDeploymentResponse, error) {
	o := operations.Options{}
	supportedOptions := []string{
		operations.SupportedOptionServerURL,
	}

	for _, opt := range opts {
		if err := opt(&o, supportedOptions...); err != nil {
			return nil, fmt.Errorf("error applying option: %w", err)
		}
	}
	baseURL := operations.CreateDeployedDevicesDeploymentServerList[0]
	if o.ServerURL != nil {
		baseURL = *o.ServerURL
	}

	url, err := utils.GenerateURL(ctx, baseURL, "/DeployedDevices/Fleets/{FleetSid}/Deployments", request, nil)
	if err != nil {
		return nil, fmt.Errorf("error generating URL: %w", err)
	}

	bodyReader, reqContentType, err := utils.SerializeRequestBody(ctx, request, "RequestBody", "form")
	if err != nil {
		return nil, fmt.Errorf("error serializing request body: %w", err)
	}

	req, err := http.NewRequestWithContext(ctx, "POST", url, bodyReader)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	req.Header.Set("Content-Type", reqContentType)

	client := utils.ConfigureSecurityClient(s._defaultClient, security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.CreateDeployedDevicesDeploymentResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 201:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *shared.PreviewDeployedDevicesFleetDeployment
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.PreviewDeployedDevicesFleetDeployment = out
		}
	}

	return res, nil
}

// CreateDeployedDevicesDevice - Create a new Device in the Fleet, optionally giving it a unique name, friendly name, and assigning to a Deployment and/or human identity.
func (s *SDK) CreateDeployedDevicesDevice(ctx context.Context, request operations.CreateDeployedDevicesDeviceRequest, security operations.CreateDeployedDevicesDeviceSecurity, opts ...operations.Option) (*operations.CreateDeployedDevicesDeviceResponse, error) {
	o := operations.Options{}
	supportedOptions := []string{
		operations.SupportedOptionServerURL,
	}

	for _, opt := range opts {
		if err := opt(&o, supportedOptions...); err != nil {
			return nil, fmt.Errorf("error applying option: %w", err)
		}
	}
	baseURL := operations.CreateDeployedDevicesDeviceServerList[0]
	if o.ServerURL != nil {
		baseURL = *o.ServerURL
	}

	url, err := utils.GenerateURL(ctx, baseURL, "/DeployedDevices/Fleets/{FleetSid}/Devices", request, nil)
	if err != nil {
		return nil, fmt.Errorf("error generating URL: %w", err)
	}

	bodyReader, reqContentType, err := utils.SerializeRequestBody(ctx, request, "RequestBody", "form")
	if err != nil {
		return nil, fmt.Errorf("error serializing request body: %w", err)
	}

	req, err := http.NewRequestWithContext(ctx, "POST", url, bodyReader)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	req.Header.Set("Content-Type", reqContentType)

	client := utils.ConfigureSecurityClient(s._defaultClient, security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.CreateDeployedDevicesDeviceResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 201:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *shared.PreviewDeployedDevicesFleetDevice
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.PreviewDeployedDevicesFleetDevice = out
		}
	}

	return res, nil
}

// CreateDeployedDevicesFleet - Create a new Fleet for scoping of deployed devices within your account.
func (s *SDK) CreateDeployedDevicesFleet(ctx context.Context, request operations.CreateDeployedDevicesFleetCreateDeployedDevicesFleetRequest, security operations.CreateDeployedDevicesFleetSecurity, opts ...operations.Option) (*operations.CreateDeployedDevicesFleetResponse, error) {
	o := operations.Options{}
	supportedOptions := []string{
		operations.SupportedOptionServerURL,
	}

	for _, opt := range opts {
		if err := opt(&o, supportedOptions...); err != nil {
			return nil, fmt.Errorf("error applying option: %w", err)
		}
	}
	baseURL := operations.CreateDeployedDevicesFleetServerList[0]
	if o.ServerURL != nil {
		baseURL = *o.ServerURL
	}

	url := strings.TrimSuffix(baseURL, "/") + "/DeployedDevices/Fleets"

	bodyReader, reqContentType, err := utils.SerializeRequestBody(ctx, request, "Request", "form")
	if err != nil {
		return nil, fmt.Errorf("error serializing request body: %w", err)
	}

	req, err := http.NewRequestWithContext(ctx, "POST", url, bodyReader)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	req.Header.Set("Content-Type", reqContentType)

	client := utils.ConfigureSecurityClient(s._defaultClient, security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.CreateDeployedDevicesFleetResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 201:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *shared.PreviewDeployedDevicesFleet
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.PreviewDeployedDevicesFleet = out
		}
	}

	return res, nil
}

// CreateDeployedDevicesKey - Create a new Key credential in the Fleet, optionally giving it a friendly name and assigning to a Device.
func (s *SDK) CreateDeployedDevicesKey(ctx context.Context, request operations.CreateDeployedDevicesKeyRequest, security operations.CreateDeployedDevicesKeySecurity, opts ...operations.Option) (*operations.CreateDeployedDevicesKeyResponse, error) {
	o := operations.Options{}
	supportedOptions := []string{
		operations.SupportedOptionServerURL,
	}

	for _, opt := range opts {
		if err := opt(&o, supportedOptions...); err != nil {
			return nil, fmt.Errorf("error applying option: %w", err)
		}
	}
	baseURL := operations.CreateDeployedDevicesKeyServerList[0]
	if o.ServerURL != nil {
		baseURL = *o.ServerURL
	}

	url, err := utils.GenerateURL(ctx, baseURL, "/DeployedDevices/Fleets/{FleetSid}/Keys", request, nil)
	if err != nil {
		return nil, fmt.Errorf("error generating URL: %w", err)
	}

	bodyReader, reqContentType, err := utils.SerializeRequestBody(ctx, request, "RequestBody", "form")
	if err != nil {
		return nil, fmt.Errorf("error serializing request body: %w", err)
	}

	req, err := http.NewRequestWithContext(ctx, "POST", url, bodyReader)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	req.Header.Set("Content-Type", reqContentType)

	client := utils.ConfigureSecurityClient(s._defaultClient, security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.CreateDeployedDevicesKeyResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 201:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *shared.PreviewDeployedDevicesFleetKey
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.PreviewDeployedDevicesFleetKey = out
		}
	}

	return res, nil
}

// CreateHostedNumbersAuthorizationDocument - Create an AuthorizationDocument for authorizing the hosting of phone number capabilities on Twilio's platform.
func (s *SDK) CreateHostedNumbersAuthorizationDocument(ctx context.Context, request operations.CreateHostedNumbersAuthorizationDocumentCreateHostedNumbersAuthorizationDocumentRequest, security operations.CreateHostedNumbersAuthorizationDocumentSecurity, opts ...operations.Option) (*operations.CreateHostedNumbersAuthorizationDocumentResponse, error) {
	o := operations.Options{}
	supportedOptions := []string{
		operations.SupportedOptionServerURL,
	}

	for _, opt := range opts {
		if err := opt(&o, supportedOptions...); err != nil {
			return nil, fmt.Errorf("error applying option: %w", err)
		}
	}
	baseURL := operations.CreateHostedNumbersAuthorizationDocumentServerList[0]
	if o.ServerURL != nil {
		baseURL = *o.ServerURL
	}

	url := strings.TrimSuffix(baseURL, "/") + "/HostedNumbers/AuthorizationDocuments"

	bodyReader, reqContentType, err := utils.SerializeRequestBody(ctx, request, "Request", "form")
	if err != nil {
		return nil, fmt.Errorf("error serializing request body: %w", err)
	}

	req, err := http.NewRequestWithContext(ctx, "POST", url, bodyReader)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	req.Header.Set("Content-Type", reqContentType)

	client := utils.ConfigureSecurityClient(s._defaultClient, security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.CreateHostedNumbersAuthorizationDocumentResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 201:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *shared.PreviewHostedNumbersAuthorizationDocument
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.PreviewHostedNumbersAuthorizationDocument = out
		}
	}

	return res, nil
}

// CreateHostedNumbersHostedNumberOrder - Host a phone number's capability on Twilio's platform.
func (s *SDK) CreateHostedNumbersHostedNumberOrder(ctx context.Context, request operations.CreateHostedNumbersHostedNumberOrderCreateHostedNumbersHostedNumberOrderRequest, security operations.CreateHostedNumbersHostedNumberOrderSecurity, opts ...operations.Option) (*operations.CreateHostedNumbersHostedNumberOrderResponse, error) {
	o := operations.Options{}
	supportedOptions := []string{
		operations.SupportedOptionServerURL,
	}

	for _, opt := range opts {
		if err := opt(&o, supportedOptions...); err != nil {
			return nil, fmt.Errorf("error applying option: %w", err)
		}
	}
	baseURL := operations.CreateHostedNumbersHostedNumberOrderServerList[0]
	if o.ServerURL != nil {
		baseURL = *o.ServerURL
	}

	url := strings.TrimSuffix(baseURL, "/") + "/HostedNumbers/HostedNumberOrders"

	bodyReader, reqContentType, err := utils.SerializeRequestBody(ctx, request, "Request", "form")
	if err != nil {
		return nil, fmt.Errorf("error serializing request body: %w", err)
	}

	req, err := http.NewRequestWithContext(ctx, "POST", url, bodyReader)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	req.Header.Set("Content-Type", reqContentType)

	client := utils.ConfigureSecurityClient(s._defaultClient, security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.CreateHostedNumbersHostedNumberOrderResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 201:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *shared.PreviewHostedNumbersHostedNumberOrder
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.PreviewHostedNumbersHostedNumberOrder = out
		}
	}

	return res, nil
}

// CreateMarketplaceInstalledAddOn - Install an Add-on for the Account specified.
func (s *SDK) CreateMarketplaceInstalledAddOn(ctx context.Context, request operations.CreateMarketplaceInstalledAddOnCreateMarketplaceInstalledAddOnRequest, security operations.CreateMarketplaceInstalledAddOnSecurity, opts ...operations.Option) (*operations.CreateMarketplaceInstalledAddOnResponse, error) {
	o := operations.Options{}
	supportedOptions := []string{
		operations.SupportedOptionServerURL,
	}

	for _, opt := range opts {
		if err := opt(&o, supportedOptions...); err != nil {
			return nil, fmt.Errorf("error applying option: %w", err)
		}
	}
	baseURL := operations.CreateMarketplaceInstalledAddOnServerList[0]
	if o.ServerURL != nil {
		baseURL = *o.ServerURL
	}

	url := strings.TrimSuffix(baseURL, "/") + "/marketplace/InstalledAddOns"

	bodyReader, reqContentType, err := utils.SerializeRequestBody(ctx, request, "Request", "form")
	if err != nil {
		return nil, fmt.Errorf("error serializing request body: %w", err)
	}

	req, err := http.NewRequestWithContext(ctx, "POST", url, bodyReader)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	req.Header.Set("Content-Type", reqContentType)

	client := utils.ConfigureSecurityClient(s._defaultClient, security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.CreateMarketplaceInstalledAddOnResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 201:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *shared.PreviewMarketplaceInstalledAddOn
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.PreviewMarketplaceInstalledAddOn = out
		}
	}

	return res, nil
}

func (s *SDK) CreateSyncDocument(ctx context.Context, request operations.CreateSyncDocumentRequest, security operations.CreateSyncDocumentSecurity, opts ...operations.Option) (*operations.CreateSyncDocumentResponse, error) {
	o := operations.Options{}
	supportedOptions := []string{
		operations.SupportedOptionServerURL,
	}

	for _, opt := range opts {
		if err := opt(&o, supportedOptions...); err != nil {
			return nil, fmt.Errorf("error applying option: %w", err)
		}
	}
	baseURL := operations.CreateSyncDocumentServerList[0]
	if o.ServerURL != nil {
		baseURL = *o.ServerURL
	}

	url, err := utils.GenerateURL(ctx, baseURL, "/Sync/Services/{ServiceSid}/Documents", request, nil)
	if err != nil {
		return nil, fmt.Errorf("error generating URL: %w", err)
	}

	bodyReader, reqContentType, err := utils.SerializeRequestBody(ctx, request, "RequestBody", "form")
	if err != nil {
		return nil, fmt.Errorf("error serializing request body: %w", err)
	}

	req, err := http.NewRequestWithContext(ctx, "POST", url, bodyReader)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	req.Header.Set("Content-Type", reqContentType)

	client := utils.ConfigureSecurityClient(s._defaultClient, security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.CreateSyncDocumentResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 201:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *shared.PreviewSyncServiceDocument
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.PreviewSyncServiceDocument = out
		}
	}

	return res, nil
}

func (s *SDK) CreateSyncService(ctx context.Context, request operations.CreateSyncServiceCreateSyncServiceRequest, security operations.CreateSyncServiceSecurity, opts ...operations.Option) (*operations.CreateSyncServiceResponse, error) {
	o := operations.Options{}
	supportedOptions := []string{
		operations.SupportedOptionServerURL,
	}

	for _, opt := range opts {
		if err := opt(&o, supportedOptions...); err != nil {
			return nil, fmt.Errorf("error applying option: %w", err)
		}
	}
	baseURL := operations.CreateSyncServiceServerList[0]
	if o.ServerURL != nil {
		baseURL = *o.ServerURL
	}

	url := strings.TrimSuffix(baseURL, "/") + "/Sync/Services"

	bodyReader, reqContentType, err := utils.SerializeRequestBody(ctx, request, "Request", "form")
	if err != nil {
		return nil, fmt.Errorf("error serializing request body: %w", err)
	}

	req, err := http.NewRequestWithContext(ctx, "POST", url, bodyReader)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	req.Header.Set("Content-Type", reqContentType)

	client := utils.ConfigureSecurityClient(s._defaultClient, security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.CreateSyncServiceResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 201:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *shared.PreviewSyncService
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.PreviewSyncService = out
		}
	}

	return res, nil
}

func (s *SDK) CreateSyncSyncList(ctx context.Context, request operations.CreateSyncSyncListRequest, security operations.CreateSyncSyncListSecurity, opts ...operations.Option) (*operations.CreateSyncSyncListResponse, error) {
	o := operations.Options{}
	supportedOptions := []string{
		operations.SupportedOptionServerURL,
	}

	for _, opt := range opts {
		if err := opt(&o, supportedOptions...); err != nil {
			return nil, fmt.Errorf("error applying option: %w", err)
		}
	}
	baseURL := operations.CreateSyncSyncListServerList[0]
	if o.ServerURL != nil {
		baseURL = *o.ServerURL
	}

	url, err := utils.GenerateURL(ctx, baseURL, "/Sync/Services/{ServiceSid}/Lists", request, nil)
	if err != nil {
		return nil, fmt.Errorf("error generating URL: %w", err)
	}

	bodyReader, reqContentType, err := utils.SerializeRequestBody(ctx, request, "RequestBody", "form")
	if err != nil {
		return nil, fmt.Errorf("error serializing request body: %w", err)
	}

	req, err := http.NewRequestWithContext(ctx, "POST", url, bodyReader)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	req.Header.Set("Content-Type", reqContentType)

	client := utils.ConfigureSecurityClient(s._defaultClient, security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.CreateSyncSyncListResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 201:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *shared.PreviewSyncServiceSyncList
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.PreviewSyncServiceSyncList = out
		}
	}

	return res, nil
}

func (s *SDK) CreateSyncSyncListItem(ctx context.Context, request operations.CreateSyncSyncListItemRequest, security operations.CreateSyncSyncListItemSecurity, opts ...operations.Option) (*operations.CreateSyncSyncListItemResponse, error) {
	o := operations.Options{}
	supportedOptions := []string{
		operations.SupportedOptionServerURL,
	}

	for _, opt := range opts {
		if err := opt(&o, supportedOptions...); err != nil {
			return nil, fmt.Errorf("error applying option: %w", err)
		}
	}
	baseURL := operations.CreateSyncSyncListItemServerList[0]
	if o.ServerURL != nil {
		baseURL = *o.ServerURL
	}

	url, err := utils.GenerateURL(ctx, baseURL, "/Sync/Services/{ServiceSid}/Lists/{ListSid}/Items", request, nil)
	if err != nil {
		return nil, fmt.Errorf("error generating URL: %w", err)
	}

	bodyReader, reqContentType, err := utils.SerializeRequestBody(ctx, request, "RequestBody", "form")
	if err != nil {
		return nil, fmt.Errorf("error serializing request body: %w", err)
	}

	req, err := http.NewRequestWithContext(ctx, "POST", url, bodyReader)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	req.Header.Set("Content-Type", reqContentType)

	client := utils.ConfigureSecurityClient(s._defaultClient, security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.CreateSyncSyncListItemResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 201:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *shared.PreviewSyncServiceSyncListSyncListItem
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.PreviewSyncServiceSyncListSyncListItem = out
		}
	}

	return res, nil
}

func (s *SDK) CreateSyncSyncMap(ctx context.Context, request operations.CreateSyncSyncMapRequest, security operations.CreateSyncSyncMapSecurity, opts ...operations.Option) (*operations.CreateSyncSyncMapResponse, error) {
	o := operations.Options{}
	supportedOptions := []string{
		operations.SupportedOptionServerURL,
	}

	for _, opt := range opts {
		if err := opt(&o, supportedOptions...); err != nil {
			return nil, fmt.Errorf("error applying option: %w", err)
		}
	}
	baseURL := operations.CreateSyncSyncMapServerList[0]
	if o.ServerURL != nil {
		baseURL = *o.ServerURL
	}

	url, err := utils.GenerateURL(ctx, baseURL, "/Sync/Services/{ServiceSid}/Maps", request, nil)
	if err != nil {
		return nil, fmt.Errorf("error generating URL: %w", err)
	}

	bodyReader, reqContentType, err := utils.SerializeRequestBody(ctx, request, "RequestBody", "form")
	if err != nil {
		return nil, fmt.Errorf("error serializing request body: %w", err)
	}

	req, err := http.NewRequestWithContext(ctx, "POST", url, bodyReader)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	req.Header.Set("Content-Type", reqContentType)

	client := utils.ConfigureSecurityClient(s._defaultClient, security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.CreateSyncSyncMapResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 201:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *shared.PreviewSyncServiceSyncMap
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.PreviewSyncServiceSyncMap = out
		}
	}

	return res, nil
}

func (s *SDK) CreateSyncSyncMapItem(ctx context.Context, request operations.CreateSyncSyncMapItemRequest, security operations.CreateSyncSyncMapItemSecurity, opts ...operations.Option) (*operations.CreateSyncSyncMapItemResponse, error) {
	o := operations.Options{}
	supportedOptions := []string{
		operations.SupportedOptionServerURL,
	}

	for _, opt := range opts {
		if err := opt(&o, supportedOptions...); err != nil {
			return nil, fmt.Errorf("error applying option: %w", err)
		}
	}
	baseURL := operations.CreateSyncSyncMapItemServerList[0]
	if o.ServerURL != nil {
		baseURL = *o.ServerURL
	}

	url, err := utils.GenerateURL(ctx, baseURL, "/Sync/Services/{ServiceSid}/Maps/{MapSid}/Items", request, nil)
	if err != nil {
		return nil, fmt.Errorf("error generating URL: %w", err)
	}

	bodyReader, reqContentType, err := utils.SerializeRequestBody(ctx, request, "RequestBody", "form")
	if err != nil {
		return nil, fmt.Errorf("error serializing request body: %w", err)
	}

	req, err := http.NewRequestWithContext(ctx, "POST", url, bodyReader)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	req.Header.Set("Content-Type", reqContentType)

	client := utils.ConfigureSecurityClient(s._defaultClient, security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.CreateSyncSyncMapItemResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 201:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *shared.PreviewSyncServiceSyncMapSyncMapItem
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.PreviewSyncServiceSyncMapSyncMapItem = out
		}
	}

	return res, nil
}

func (s *SDK) CreateUnderstandAssistant(ctx context.Context, request operations.CreateUnderstandAssistantCreateUnderstandAssistantRequest, security operations.CreateUnderstandAssistantSecurity, opts ...operations.Option) (*operations.CreateUnderstandAssistantResponse, error) {
	o := operations.Options{}
	supportedOptions := []string{
		operations.SupportedOptionServerURL,
	}

	for _, opt := range opts {
		if err := opt(&o, supportedOptions...); err != nil {
			return nil, fmt.Errorf("error applying option: %w", err)
		}
	}
	baseURL := operations.CreateUnderstandAssistantServerList[0]
	if o.ServerURL != nil {
		baseURL = *o.ServerURL
	}

	url := strings.TrimSuffix(baseURL, "/") + "/understand/Assistants"

	bodyReader, reqContentType, err := utils.SerializeRequestBody(ctx, request, "Request", "form")
	if err != nil {
		return nil, fmt.Errorf("error serializing request body: %w", err)
	}

	req, err := http.NewRequestWithContext(ctx, "POST", url, bodyReader)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	req.Header.Set("Content-Type", reqContentType)

	client := utils.ConfigureSecurityClient(s._defaultClient, security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.CreateUnderstandAssistantResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 201:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *shared.PreviewUnderstandAssistant
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.PreviewUnderstandAssistant = out
		}
	}

	return res, nil
}

func (s *SDK) CreateUnderstandField(ctx context.Context, request operations.CreateUnderstandFieldRequest, security operations.CreateUnderstandFieldSecurity, opts ...operations.Option) (*operations.CreateUnderstandFieldResponse, error) {
	o := operations.Options{}
	supportedOptions := []string{
		operations.SupportedOptionServerURL,
	}

	for _, opt := range opts {
		if err := opt(&o, supportedOptions...); err != nil {
			return nil, fmt.Errorf("error applying option: %w", err)
		}
	}
	baseURL := operations.CreateUnderstandFieldServerList[0]
	if o.ServerURL != nil {
		baseURL = *o.ServerURL
	}

	url, err := utils.GenerateURL(ctx, baseURL, "/understand/Assistants/{AssistantSid}/Tasks/{TaskSid}/Fields", request, nil)
	if err != nil {
		return nil, fmt.Errorf("error generating URL: %w", err)
	}

	bodyReader, reqContentType, err := utils.SerializeRequestBody(ctx, request, "RequestBody", "form")
	if err != nil {
		return nil, fmt.Errorf("error serializing request body: %w", err)
	}

	req, err := http.NewRequestWithContext(ctx, "POST", url, bodyReader)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	req.Header.Set("Content-Type", reqContentType)

	client := utils.ConfigureSecurityClient(s._defaultClient, security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.CreateUnderstandFieldResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 201:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *shared.PreviewUnderstandAssistantTaskField
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.PreviewUnderstandAssistantTaskField = out
		}
	}

	return res, nil
}

func (s *SDK) CreateUnderstandFieldType(ctx context.Context, request operations.CreateUnderstandFieldTypeRequest, security operations.CreateUnderstandFieldTypeSecurity, opts ...operations.Option) (*operations.CreateUnderstandFieldTypeResponse, error) {
	o := operations.Options{}
	supportedOptions := []string{
		operations.SupportedOptionServerURL,
	}

	for _, opt := range opts {
		if err := opt(&o, supportedOptions...); err != nil {
			return nil, fmt.Errorf("error applying option: %w", err)
		}
	}
	baseURL := operations.CreateUnderstandFieldTypeServerList[0]
	if o.ServerURL != nil {
		baseURL = *o.ServerURL
	}

	url, err := utils.GenerateURL(ctx, baseURL, "/understand/Assistants/{AssistantSid}/FieldTypes", request, nil)
	if err != nil {
		return nil, fmt.Errorf("error generating URL: %w", err)
	}

	bodyReader, reqContentType, err := utils.SerializeRequestBody(ctx, request, "RequestBody", "form")
	if err != nil {
		return nil, fmt.Errorf("error serializing request body: %w", err)
	}

	req, err := http.NewRequestWithContext(ctx, "POST", url, bodyReader)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	req.Header.Set("Content-Type", reqContentType)

	client := utils.ConfigureSecurityClient(s._defaultClient, security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.CreateUnderstandFieldTypeResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 201:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *shared.PreviewUnderstandAssistantFieldType
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.PreviewUnderstandAssistantFieldType = out
		}
	}

	return res, nil
}

func (s *SDK) CreateUnderstandFieldValue(ctx context.Context, request operations.CreateUnderstandFieldValueRequest, security operations.CreateUnderstandFieldValueSecurity, opts ...operations.Option) (*operations.CreateUnderstandFieldValueResponse, error) {
	o := operations.Options{}
	supportedOptions := []string{
		operations.SupportedOptionServerURL,
	}

	for _, opt := range opts {
		if err := opt(&o, supportedOptions...); err != nil {
			return nil, fmt.Errorf("error applying option: %w", err)
		}
	}
	baseURL := operations.CreateUnderstandFieldValueServerList[0]
	if o.ServerURL != nil {
		baseURL = *o.ServerURL
	}

	url, err := utils.GenerateURL(ctx, baseURL, "/understand/Assistants/{AssistantSid}/FieldTypes/{FieldTypeSid}/FieldValues", request, nil)
	if err != nil {
		return nil, fmt.Errorf("error generating URL: %w", err)
	}

	bodyReader, reqContentType, err := utils.SerializeRequestBody(ctx, request, "RequestBody", "form")
	if err != nil {
		return nil, fmt.Errorf("error serializing request body: %w", err)
	}

	req, err := http.NewRequestWithContext(ctx, "POST", url, bodyReader)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	req.Header.Set("Content-Type", reqContentType)

	client := utils.ConfigureSecurityClient(s._defaultClient, security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.CreateUnderstandFieldValueResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 201:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *shared.PreviewUnderstandAssistantFieldTypeFieldValue
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.PreviewUnderstandAssistantFieldTypeFieldValue = out
		}
	}

	return res, nil
}

func (s *SDK) CreateUnderstandModelBuild(ctx context.Context, request operations.CreateUnderstandModelBuildRequest, security operations.CreateUnderstandModelBuildSecurity, opts ...operations.Option) (*operations.CreateUnderstandModelBuildResponse, error) {
	o := operations.Options{}
	supportedOptions := []string{
		operations.SupportedOptionServerURL,
	}

	for _, opt := range opts {
		if err := opt(&o, supportedOptions...); err != nil {
			return nil, fmt.Errorf("error applying option: %w", err)
		}
	}
	baseURL := operations.CreateUnderstandModelBuildServerList[0]
	if o.ServerURL != nil {
		baseURL = *o.ServerURL
	}

	url, err := utils.GenerateURL(ctx, baseURL, "/understand/Assistants/{AssistantSid}/ModelBuilds", request, nil)
	if err != nil {
		return nil, fmt.Errorf("error generating URL: %w", err)
	}

	bodyReader, reqContentType, err := utils.SerializeRequestBody(ctx, request, "RequestBody", "form")
	if err != nil {
		return nil, fmt.Errorf("error serializing request body: %w", err)
	}

	req, err := http.NewRequestWithContext(ctx, "POST", url, bodyReader)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	req.Header.Set("Content-Type", reqContentType)

	client := utils.ConfigureSecurityClient(s._defaultClient, security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.CreateUnderstandModelBuildResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 201:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *shared.PreviewUnderstandAssistantModelBuild
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.PreviewUnderstandAssistantModelBuild = out
		}
	}

	return res, nil
}

func (s *SDK) CreateUnderstandQuery(ctx context.Context, request operations.CreateUnderstandQueryRequest, security operations.CreateUnderstandQuerySecurity, opts ...operations.Option) (*operations.CreateUnderstandQueryResponse, error) {
	o := operations.Options{}
	supportedOptions := []string{
		operations.SupportedOptionServerURL,
	}

	for _, opt := range opts {
		if err := opt(&o, supportedOptions...); err != nil {
			return nil, fmt.Errorf("error applying option: %w", err)
		}
	}
	baseURL := operations.CreateUnderstandQueryServerList[0]
	if o.ServerURL != nil {
		baseURL = *o.ServerURL
	}

	url, err := utils.GenerateURL(ctx, baseURL, "/understand/Assistants/{AssistantSid}/Queries", request, nil)
	if err != nil {
		return nil, fmt.Errorf("error generating URL: %w", err)
	}

	bodyReader, reqContentType, err := utils.SerializeRequestBody(ctx, request, "RequestBody", "form")
	if err != nil {
		return nil, fmt.Errorf("error serializing request body: %w", err)
	}

	req, err := http.NewRequestWithContext(ctx, "POST", url, bodyReader)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	req.Header.Set("Content-Type", reqContentType)

	client := utils.ConfigureSecurityClient(s._defaultClient, security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.CreateUnderstandQueryResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 201:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *shared.PreviewUnderstandAssistantQuery
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.PreviewUnderstandAssistantQuery = out
		}
	}

	return res, nil
}

func (s *SDK) CreateUnderstandSample(ctx context.Context, request operations.CreateUnderstandSampleRequest, security operations.CreateUnderstandSampleSecurity, opts ...operations.Option) (*operations.CreateUnderstandSampleResponse, error) {
	o := operations.Options{}
	supportedOptions := []string{
		operations.SupportedOptionServerURL,
	}

	for _, opt := range opts {
		if err := opt(&o, supportedOptions...); err != nil {
			return nil, fmt.Errorf("error applying option: %w", err)
		}
	}
	baseURL := operations.CreateUnderstandSampleServerList[0]
	if o.ServerURL != nil {
		baseURL = *o.ServerURL
	}

	url, err := utils.GenerateURL(ctx, baseURL, "/understand/Assistants/{AssistantSid}/Tasks/{TaskSid}/Samples", request, nil)
	if err != nil {
		return nil, fmt.Errorf("error generating URL: %w", err)
	}

	bodyReader, reqContentType, err := utils.SerializeRequestBody(ctx, request, "RequestBody", "form")
	if err != nil {
		return nil, fmt.Errorf("error serializing request body: %w", err)
	}

	req, err := http.NewRequestWithContext(ctx, "POST", url, bodyReader)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	req.Header.Set("Content-Type", reqContentType)

	client := utils.ConfigureSecurityClient(s._defaultClient, security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.CreateUnderstandSampleResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 201:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *shared.PreviewUnderstandAssistantTaskSample
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.PreviewUnderstandAssistantTaskSample = out
		}
	}

	return res, nil
}

func (s *SDK) CreateUnderstandTask(ctx context.Context, request operations.CreateUnderstandTaskRequest, security operations.CreateUnderstandTaskSecurity, opts ...operations.Option) (*operations.CreateUnderstandTaskResponse, error) {
	o := operations.Options{}
	supportedOptions := []string{
		operations.SupportedOptionServerURL,
	}

	for _, opt := range opts {
		if err := opt(&o, supportedOptions...); err != nil {
			return nil, fmt.Errorf("error applying option: %w", err)
		}
	}
	baseURL := operations.CreateUnderstandTaskServerList[0]
	if o.ServerURL != nil {
		baseURL = *o.ServerURL
	}

	url, err := utils.GenerateURL(ctx, baseURL, "/understand/Assistants/{AssistantSid}/Tasks", request, nil)
	if err != nil {
		return nil, fmt.Errorf("error generating URL: %w", err)
	}

	bodyReader, reqContentType, err := utils.SerializeRequestBody(ctx, request, "RequestBody", "form")
	if err != nil {
		return nil, fmt.Errorf("error serializing request body: %w", err)
	}

	req, err := http.NewRequestWithContext(ctx, "POST", url, bodyReader)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	req.Header.Set("Content-Type", reqContentType)

	client := utils.ConfigureSecurityClient(s._defaultClient, security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.CreateUnderstandTaskResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 201:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *shared.PreviewUnderstandAssistantTask
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.PreviewUnderstandAssistantTask = out
		}
	}

	return res, nil
}

func (s *SDK) CreateWirelessCommand(ctx context.Context, request operations.CreateWirelessCommandCreateWirelessCommandRequest, security operations.CreateWirelessCommandSecurity, opts ...operations.Option) (*operations.CreateWirelessCommandResponse, error) {
	o := operations.Options{}
	supportedOptions := []string{
		operations.SupportedOptionServerURL,
	}

	for _, opt := range opts {
		if err := opt(&o, supportedOptions...); err != nil {
			return nil, fmt.Errorf("error applying option: %w", err)
		}
	}
	baseURL := operations.CreateWirelessCommandServerList[0]
	if o.ServerURL != nil {
		baseURL = *o.ServerURL
	}

	url := strings.TrimSuffix(baseURL, "/") + "/wireless/Commands"

	bodyReader, reqContentType, err := utils.SerializeRequestBody(ctx, request, "Request", "form")
	if err != nil {
		return nil, fmt.Errorf("error serializing request body: %w", err)
	}

	req, err := http.NewRequestWithContext(ctx, "POST", url, bodyReader)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	req.Header.Set("Content-Type", reqContentType)

	client := utils.ConfigureSecurityClient(s._defaultClient, security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.CreateWirelessCommandResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 201:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *shared.PreviewWirelessCommand
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.PreviewWirelessCommand = out
		}
	}

	return res, nil
}

func (s *SDK) CreateWirelessRatePlan(ctx context.Context, request operations.CreateWirelessRatePlanCreateWirelessRatePlanRequest, security operations.CreateWirelessRatePlanSecurity, opts ...operations.Option) (*operations.CreateWirelessRatePlanResponse, error) {
	o := operations.Options{}
	supportedOptions := []string{
		operations.SupportedOptionServerURL,
	}

	for _, opt := range opts {
		if err := opt(&o, supportedOptions...); err != nil {
			return nil, fmt.Errorf("error applying option: %w", err)
		}
	}
	baseURL := operations.CreateWirelessRatePlanServerList[0]
	if o.ServerURL != nil {
		baseURL = *o.ServerURL
	}

	url := strings.TrimSuffix(baseURL, "/") + "/wireless/RatePlans"

	bodyReader, reqContentType, err := utils.SerializeRequestBody(ctx, request, "Request", "form")
	if err != nil {
		return nil, fmt.Errorf("error serializing request body: %w", err)
	}

	req, err := http.NewRequestWithContext(ctx, "POST", url, bodyReader)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	req.Header.Set("Content-Type", reqContentType)

	client := utils.ConfigureSecurityClient(s._defaultClient, security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.CreateWirelessRatePlanResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 201:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *shared.PreviewWirelessRatePlan
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.PreviewWirelessRatePlan = out
		}
	}

	return res, nil
}

// DeleteDeployedDevicesCertificate - Unregister a specific Certificate credential from the Fleet, effectively disallowing any inbound client connections that are presenting it.
func (s *SDK) DeleteDeployedDevicesCertificate(ctx context.Context, request operations.DeleteDeployedDevicesCertificateRequest, security operations.DeleteDeployedDevicesCertificateSecurity, opts ...operations.Option) (*operations.DeleteDeployedDevicesCertificateResponse, error) {
	o := operations.Options{}
	supportedOptions := []string{
		operations.SupportedOptionServerURL,
	}

	for _, opt := range opts {
		if err := opt(&o, supportedOptions...); err != nil {
			return nil, fmt.Errorf("error applying option: %w", err)
		}
	}
	baseURL := operations.DeleteDeployedDevicesCertificateServerList[0]
	if o.ServerURL != nil {
		baseURL = *o.ServerURL
	}

	url, err := utils.GenerateURL(ctx, baseURL, "/DeployedDevices/Fleets/{FleetSid}/Certificates/{Sid}", request, nil)
	if err != nil {
		return nil, fmt.Errorf("error generating URL: %w", err)
	}

	req, err := http.NewRequestWithContext(ctx, "DELETE", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	client := utils.ConfigureSecurityClient(s._defaultClient, security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.DeleteDeployedDevicesCertificateResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 204:
	}

	return res, nil
}

// DeleteDeployedDevicesDeployment - Delete a specific Deployment from the Fleet, leaving associated devices effectively undeployed.
func (s *SDK) DeleteDeployedDevicesDeployment(ctx context.Context, request operations.DeleteDeployedDevicesDeploymentRequest, security operations.DeleteDeployedDevicesDeploymentSecurity, opts ...operations.Option) (*operations.DeleteDeployedDevicesDeploymentResponse, error) {
	o := operations.Options{}
	supportedOptions := []string{
		operations.SupportedOptionServerURL,
	}

	for _, opt := range opts {
		if err := opt(&o, supportedOptions...); err != nil {
			return nil, fmt.Errorf("error applying option: %w", err)
		}
	}
	baseURL := operations.DeleteDeployedDevicesDeploymentServerList[0]
	if o.ServerURL != nil {
		baseURL = *o.ServerURL
	}

	url, err := utils.GenerateURL(ctx, baseURL, "/DeployedDevices/Fleets/{FleetSid}/Deployments/{Sid}", request, nil)
	if err != nil {
		return nil, fmt.Errorf("error generating URL: %w", err)
	}

	req, err := http.NewRequestWithContext(ctx, "DELETE", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	client := utils.ConfigureSecurityClient(s._defaultClient, security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.DeleteDeployedDevicesDeploymentResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 204:
	}

	return res, nil
}

// DeleteDeployedDevicesDevice - Delete a specific Device from the Fleet, also removing it from associated Deployments.
func (s *SDK) DeleteDeployedDevicesDevice(ctx context.Context, request operations.DeleteDeployedDevicesDeviceRequest, security operations.DeleteDeployedDevicesDeviceSecurity, opts ...operations.Option) (*operations.DeleteDeployedDevicesDeviceResponse, error) {
	o := operations.Options{}
	supportedOptions := []string{
		operations.SupportedOptionServerURL,
	}

	for _, opt := range opts {
		if err := opt(&o, supportedOptions...); err != nil {
			return nil, fmt.Errorf("error applying option: %w", err)
		}
	}
	baseURL := operations.DeleteDeployedDevicesDeviceServerList[0]
	if o.ServerURL != nil {
		baseURL = *o.ServerURL
	}

	url, err := utils.GenerateURL(ctx, baseURL, "/DeployedDevices/Fleets/{FleetSid}/Devices/{Sid}", request, nil)
	if err != nil {
		return nil, fmt.Errorf("error generating URL: %w", err)
	}

	req, err := http.NewRequestWithContext(ctx, "DELETE", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	client := utils.ConfigureSecurityClient(s._defaultClient, security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.DeleteDeployedDevicesDeviceResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 204:
	}

	return res, nil
}

// DeleteDeployedDevicesFleet - Delete a specific Fleet from your account, also destroys all nested resources: Devices, Deployments, Certificates, Keys.
func (s *SDK) DeleteDeployedDevicesFleet(ctx context.Context, request operations.DeleteDeployedDevicesFleetRequest, security operations.DeleteDeployedDevicesFleetSecurity, opts ...operations.Option) (*operations.DeleteDeployedDevicesFleetResponse, error) {
	o := operations.Options{}
	supportedOptions := []string{
		operations.SupportedOptionServerURL,
	}

	for _, opt := range opts {
		if err := opt(&o, supportedOptions...); err != nil {
			return nil, fmt.Errorf("error applying option: %w", err)
		}
	}
	baseURL := operations.DeleteDeployedDevicesFleetServerList[0]
	if o.ServerURL != nil {
		baseURL = *o.ServerURL
	}

	url, err := utils.GenerateURL(ctx, baseURL, "/DeployedDevices/Fleets/{Sid}", request, nil)
	if err != nil {
		return nil, fmt.Errorf("error generating URL: %w", err)
	}

	req, err := http.NewRequestWithContext(ctx, "DELETE", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	client := utils.ConfigureSecurityClient(s._defaultClient, security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.DeleteDeployedDevicesFleetResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 204:
	}

	return res, nil
}

// DeleteDeployedDevicesKey - Delete a specific Key credential from the Fleet, effectively disallowing any inbound client connections that are presenting it.
func (s *SDK) DeleteDeployedDevicesKey(ctx context.Context, request operations.DeleteDeployedDevicesKeyRequest, security operations.DeleteDeployedDevicesKeySecurity, opts ...operations.Option) (*operations.DeleteDeployedDevicesKeyResponse, error) {
	o := operations.Options{}
	supportedOptions := []string{
		operations.SupportedOptionServerURL,
	}

	for _, opt := range opts {
		if err := opt(&o, supportedOptions...); err != nil {
			return nil, fmt.Errorf("error applying option: %w", err)
		}
	}
	baseURL := operations.DeleteDeployedDevicesKeyServerList[0]
	if o.ServerURL != nil {
		baseURL = *o.ServerURL
	}

	url, err := utils.GenerateURL(ctx, baseURL, "/DeployedDevices/Fleets/{FleetSid}/Keys/{Sid}", request, nil)
	if err != nil {
		return nil, fmt.Errorf("error generating URL: %w", err)
	}

	req, err := http.NewRequestWithContext(ctx, "DELETE", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	client := utils.ConfigureSecurityClient(s._defaultClient, security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.DeleteDeployedDevicesKeyResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 204:
	}

	return res, nil
}

// DeleteHostedNumbersHostedNumberOrder - Cancel the HostedNumberOrder (only available when the status is in `received`).
func (s *SDK) DeleteHostedNumbersHostedNumberOrder(ctx context.Context, request operations.DeleteHostedNumbersHostedNumberOrderRequest, security operations.DeleteHostedNumbersHostedNumberOrderSecurity, opts ...operations.Option) (*operations.DeleteHostedNumbersHostedNumberOrderResponse, error) {
	o := operations.Options{}
	supportedOptions := []string{
		operations.SupportedOptionServerURL,
	}

	for _, opt := range opts {
		if err := opt(&o, supportedOptions...); err != nil {
			return nil, fmt.Errorf("error applying option: %w", err)
		}
	}
	baseURL := operations.DeleteHostedNumbersHostedNumberOrderServerList[0]
	if o.ServerURL != nil {
		baseURL = *o.ServerURL
	}

	url, err := utils.GenerateURL(ctx, baseURL, "/HostedNumbers/HostedNumberOrders/{Sid}", request, nil)
	if err != nil {
		return nil, fmt.Errorf("error generating URL: %w", err)
	}

	req, err := http.NewRequestWithContext(ctx, "DELETE", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	client := utils.ConfigureSecurityClient(s._defaultClient, security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.DeleteHostedNumbersHostedNumberOrderResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 204:
	}

	return res, nil
}

// DeleteMarketplaceInstalledAddOn - Remove an Add-on installation from your account
func (s *SDK) DeleteMarketplaceInstalledAddOn(ctx context.Context, request operations.DeleteMarketplaceInstalledAddOnRequest, security operations.DeleteMarketplaceInstalledAddOnSecurity, opts ...operations.Option) (*operations.DeleteMarketplaceInstalledAddOnResponse, error) {
	o := operations.Options{}
	supportedOptions := []string{
		operations.SupportedOptionServerURL,
	}

	for _, opt := range opts {
		if err := opt(&o, supportedOptions...); err != nil {
			return nil, fmt.Errorf("error applying option: %w", err)
		}
	}
	baseURL := operations.DeleteMarketplaceInstalledAddOnServerList[0]
	if o.ServerURL != nil {
		baseURL = *o.ServerURL
	}

	url, err := utils.GenerateURL(ctx, baseURL, "/marketplace/InstalledAddOns/{Sid}", request, nil)
	if err != nil {
		return nil, fmt.Errorf("error generating URL: %w", err)
	}

	req, err := http.NewRequestWithContext(ctx, "DELETE", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	client := utils.ConfigureSecurityClient(s._defaultClient, security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.DeleteMarketplaceInstalledAddOnResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 204:
	}

	return res, nil
}

func (s *SDK) DeleteSyncDocument(ctx context.Context, request operations.DeleteSyncDocumentRequest, security operations.DeleteSyncDocumentSecurity, opts ...operations.Option) (*operations.DeleteSyncDocumentResponse, error) {
	o := operations.Options{}
	supportedOptions := []string{
		operations.SupportedOptionServerURL,
	}

	for _, opt := range opts {
		if err := opt(&o, supportedOptions...); err != nil {
			return nil, fmt.Errorf("error applying option: %w", err)
		}
	}
	baseURL := operations.DeleteSyncDocumentServerList[0]
	if o.ServerURL != nil {
		baseURL = *o.ServerURL
	}

	url, err := utils.GenerateURL(ctx, baseURL, "/Sync/Services/{ServiceSid}/Documents/{Sid}", request, nil)
	if err != nil {
		return nil, fmt.Errorf("error generating URL: %w", err)
	}

	req, err := http.NewRequestWithContext(ctx, "DELETE", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	client := utils.ConfigureSecurityClient(s._defaultClient, security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.DeleteSyncDocumentResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 204:
	}

	return res, nil
}

// DeleteSyncDocumentPermission - Delete a specific Sync Document Permission.
func (s *SDK) DeleteSyncDocumentPermission(ctx context.Context, request operations.DeleteSyncDocumentPermissionRequest, security operations.DeleteSyncDocumentPermissionSecurity, opts ...operations.Option) (*operations.DeleteSyncDocumentPermissionResponse, error) {
	o := operations.Options{}
	supportedOptions := []string{
		operations.SupportedOptionServerURL,
	}

	for _, opt := range opts {
		if err := opt(&o, supportedOptions...); err != nil {
			return nil, fmt.Errorf("error applying option: %w", err)
		}
	}
	baseURL := operations.DeleteSyncDocumentPermissionServerList[0]
	if o.ServerURL != nil {
		baseURL = *o.ServerURL
	}

	url, err := utils.GenerateURL(ctx, baseURL, "/Sync/Services/{ServiceSid}/Documents/{DocumentSid}/Permissions/{Identity}", request, nil)
	if err != nil {
		return nil, fmt.Errorf("error generating URL: %w", err)
	}

	req, err := http.NewRequestWithContext(ctx, "DELETE", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	client := utils.ConfigureSecurityClient(s._defaultClient, security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.DeleteSyncDocumentPermissionResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 204:
	}

	return res, nil
}

func (s *SDK) DeleteSyncService(ctx context.Context, request operations.DeleteSyncServiceRequest, security operations.DeleteSyncServiceSecurity, opts ...operations.Option) (*operations.DeleteSyncServiceResponse, error) {
	o := operations.Options{}
	supportedOptions := []string{
		operations.SupportedOptionServerURL,
	}

	for _, opt := range opts {
		if err := opt(&o, supportedOptions...); err != nil {
			return nil, fmt.Errorf("error applying option: %w", err)
		}
	}
	baseURL := operations.DeleteSyncServiceServerList[0]
	if o.ServerURL != nil {
		baseURL = *o.ServerURL
	}

	url, err := utils.GenerateURL(ctx, baseURL, "/Sync/Services/{Sid}", request, nil)
	if err != nil {
		return nil, fmt.Errorf("error generating URL: %w", err)
	}

	req, err := http.NewRequestWithContext(ctx, "DELETE", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	client := utils.ConfigureSecurityClient(s._defaultClient, security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.DeleteSyncServiceResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 204:
	}

	return res, nil
}

func (s *SDK) DeleteSyncSyncList(ctx context.Context, request operations.DeleteSyncSyncListRequest, security operations.DeleteSyncSyncListSecurity, opts ...operations.Option) (*operations.DeleteSyncSyncListResponse, error) {
	o := operations.Options{}
	supportedOptions := []string{
		operations.SupportedOptionServerURL,
	}

	for _, opt := range opts {
		if err := opt(&o, supportedOptions...); err != nil {
			return nil, fmt.Errorf("error applying option: %w", err)
		}
	}
	baseURL := operations.DeleteSyncSyncListServerList[0]
	if o.ServerURL != nil {
		baseURL = *o.ServerURL
	}

	url, err := utils.GenerateURL(ctx, baseURL, "/Sync/Services/{ServiceSid}/Lists/{Sid}", request, nil)
	if err != nil {
		return nil, fmt.Errorf("error generating URL: %w", err)
	}

	req, err := http.NewRequestWithContext(ctx, "DELETE", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	client := utils.ConfigureSecurityClient(s._defaultClient, security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.DeleteSyncSyncListResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 204:
	}

	return res, nil
}

func (s *SDK) DeleteSyncSyncListItem(ctx context.Context, request operations.DeleteSyncSyncListItemRequest, security operations.DeleteSyncSyncListItemSecurity, opts ...operations.Option) (*operations.DeleteSyncSyncListItemResponse, error) {
	o := operations.Options{}
	supportedOptions := []string{
		operations.SupportedOptionServerURL,
	}

	for _, opt := range opts {
		if err := opt(&o, supportedOptions...); err != nil {
			return nil, fmt.Errorf("error applying option: %w", err)
		}
	}
	baseURL := operations.DeleteSyncSyncListItemServerList[0]
	if o.ServerURL != nil {
		baseURL = *o.ServerURL
	}

	url, err := utils.GenerateURL(ctx, baseURL, "/Sync/Services/{ServiceSid}/Lists/{ListSid}/Items/{Index}", request, nil)
	if err != nil {
		return nil, fmt.Errorf("error generating URL: %w", err)
	}

	req, err := http.NewRequestWithContext(ctx, "DELETE", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	utils.PopulateHeaders(ctx, req, request)

	client := utils.ConfigureSecurityClient(s._defaultClient, security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.DeleteSyncSyncListItemResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 204:
	}

	return res, nil
}

// DeleteSyncSyncListPermission - Delete a specific Sync List Permission.
func (s *SDK) DeleteSyncSyncListPermission(ctx context.Context, request operations.DeleteSyncSyncListPermissionRequest, security operations.DeleteSyncSyncListPermissionSecurity, opts ...operations.Option) (*operations.DeleteSyncSyncListPermissionResponse, error) {
	o := operations.Options{}
	supportedOptions := []string{
		operations.SupportedOptionServerURL,
	}

	for _, opt := range opts {
		if err := opt(&o, supportedOptions...); err != nil {
			return nil, fmt.Errorf("error applying option: %w", err)
		}
	}
	baseURL := operations.DeleteSyncSyncListPermissionServerList[0]
	if o.ServerURL != nil {
		baseURL = *o.ServerURL
	}

	url, err := utils.GenerateURL(ctx, baseURL, "/Sync/Services/{ServiceSid}/Lists/{ListSid}/Permissions/{Identity}", request, nil)
	if err != nil {
		return nil, fmt.Errorf("error generating URL: %w", err)
	}

	req, err := http.NewRequestWithContext(ctx, "DELETE", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	client := utils.ConfigureSecurityClient(s._defaultClient, security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.DeleteSyncSyncListPermissionResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 204:
	}

	return res, nil
}

func (s *SDK) DeleteSyncSyncMap(ctx context.Context, request operations.DeleteSyncSyncMapRequest, security operations.DeleteSyncSyncMapSecurity, opts ...operations.Option) (*operations.DeleteSyncSyncMapResponse, error) {
	o := operations.Options{}
	supportedOptions := []string{
		operations.SupportedOptionServerURL,
	}

	for _, opt := range opts {
		if err := opt(&o, supportedOptions...); err != nil {
			return nil, fmt.Errorf("error applying option: %w", err)
		}
	}
	baseURL := operations.DeleteSyncSyncMapServerList[0]
	if o.ServerURL != nil {
		baseURL = *o.ServerURL
	}

	url, err := utils.GenerateURL(ctx, baseURL, "/Sync/Services/{ServiceSid}/Maps/{Sid}", request, nil)
	if err != nil {
		return nil, fmt.Errorf("error generating URL: %w", err)
	}

	req, err := http.NewRequestWithContext(ctx, "DELETE", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	client := utils.ConfigureSecurityClient(s._defaultClient, security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.DeleteSyncSyncMapResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 204:
	}

	return res, nil
}

func (s *SDK) DeleteSyncSyncMapItem(ctx context.Context, request operations.DeleteSyncSyncMapItemRequest, security operations.DeleteSyncSyncMapItemSecurity, opts ...operations.Option) (*operations.DeleteSyncSyncMapItemResponse, error) {
	o := operations.Options{}
	supportedOptions := []string{
		operations.SupportedOptionServerURL,
	}

	for _, opt := range opts {
		if err := opt(&o, supportedOptions...); err != nil {
			return nil, fmt.Errorf("error applying option: %w", err)
		}
	}
	baseURL := operations.DeleteSyncSyncMapItemServerList[0]
	if o.ServerURL != nil {
		baseURL = *o.ServerURL
	}

	url, err := utils.GenerateURL(ctx, baseURL, "/Sync/Services/{ServiceSid}/Maps/{MapSid}/Items/{Key}", request, nil)
	if err != nil {
		return nil, fmt.Errorf("error generating URL: %w", err)
	}

	req, err := http.NewRequestWithContext(ctx, "DELETE", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	utils.PopulateHeaders(ctx, req, request)

	client := utils.ConfigureSecurityClient(s._defaultClient, security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.DeleteSyncSyncMapItemResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 204:
	}

	return res, nil
}

// DeleteSyncSyncMapPermission - Delete a specific Sync Map Permission.
func (s *SDK) DeleteSyncSyncMapPermission(ctx context.Context, request operations.DeleteSyncSyncMapPermissionRequest, security operations.DeleteSyncSyncMapPermissionSecurity, opts ...operations.Option) (*operations.DeleteSyncSyncMapPermissionResponse, error) {
	o := operations.Options{}
	supportedOptions := []string{
		operations.SupportedOptionServerURL,
	}

	for _, opt := range opts {
		if err := opt(&o, supportedOptions...); err != nil {
			return nil, fmt.Errorf("error applying option: %w", err)
		}
	}
	baseURL := operations.DeleteSyncSyncMapPermissionServerList[0]
	if o.ServerURL != nil {
		baseURL = *o.ServerURL
	}

	url, err := utils.GenerateURL(ctx, baseURL, "/Sync/Services/{ServiceSid}/Maps/{MapSid}/Permissions/{Identity}", request, nil)
	if err != nil {
		return nil, fmt.Errorf("error generating URL: %w", err)
	}

	req, err := http.NewRequestWithContext(ctx, "DELETE", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	client := utils.ConfigureSecurityClient(s._defaultClient, security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.DeleteSyncSyncMapPermissionResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 204:
	}

	return res, nil
}

func (s *SDK) DeleteUnderstandAssistant(ctx context.Context, request operations.DeleteUnderstandAssistantRequest, security operations.DeleteUnderstandAssistantSecurity, opts ...operations.Option) (*operations.DeleteUnderstandAssistantResponse, error) {
	o := operations.Options{}
	supportedOptions := []string{
		operations.SupportedOptionServerURL,
	}

	for _, opt := range opts {
		if err := opt(&o, supportedOptions...); err != nil {
			return nil, fmt.Errorf("error applying option: %w", err)
		}
	}
	baseURL := operations.DeleteUnderstandAssistantServerList[0]
	if o.ServerURL != nil {
		baseURL = *o.ServerURL
	}

	url, err := utils.GenerateURL(ctx, baseURL, "/understand/Assistants/{Sid}", request, nil)
	if err != nil {
		return nil, fmt.Errorf("error generating URL: %w", err)
	}

	req, err := http.NewRequestWithContext(ctx, "DELETE", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	client := utils.ConfigureSecurityClient(s._defaultClient, security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.DeleteUnderstandAssistantResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 204:
	}

	return res, nil
}

func (s *SDK) DeleteUnderstandField(ctx context.Context, request operations.DeleteUnderstandFieldRequest, security operations.DeleteUnderstandFieldSecurity, opts ...operations.Option) (*operations.DeleteUnderstandFieldResponse, error) {
	o := operations.Options{}
	supportedOptions := []string{
		operations.SupportedOptionServerURL,
	}

	for _, opt := range opts {
		if err := opt(&o, supportedOptions...); err != nil {
			return nil, fmt.Errorf("error applying option: %w", err)
		}
	}
	baseURL := operations.DeleteUnderstandFieldServerList[0]
	if o.ServerURL != nil {
		baseURL = *o.ServerURL
	}

	url, err := utils.GenerateURL(ctx, baseURL, "/understand/Assistants/{AssistantSid}/Tasks/{TaskSid}/Fields/{Sid}", request, nil)
	if err != nil {
		return nil, fmt.Errorf("error generating URL: %w", err)
	}

	req, err := http.NewRequestWithContext(ctx, "DELETE", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	client := utils.ConfigureSecurityClient(s._defaultClient, security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.DeleteUnderstandFieldResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 204:
	}

	return res, nil
}

func (s *SDK) DeleteUnderstandFieldType(ctx context.Context, request operations.DeleteUnderstandFieldTypeRequest, security operations.DeleteUnderstandFieldTypeSecurity, opts ...operations.Option) (*operations.DeleteUnderstandFieldTypeResponse, error) {
	o := operations.Options{}
	supportedOptions := []string{
		operations.SupportedOptionServerURL,
	}

	for _, opt := range opts {
		if err := opt(&o, supportedOptions...); err != nil {
			return nil, fmt.Errorf("error applying option: %w", err)
		}
	}
	baseURL := operations.DeleteUnderstandFieldTypeServerList[0]
	if o.ServerURL != nil {
		baseURL = *o.ServerURL
	}

	url, err := utils.GenerateURL(ctx, baseURL, "/understand/Assistants/{AssistantSid}/FieldTypes/{Sid}", request, nil)
	if err != nil {
		return nil, fmt.Errorf("error generating URL: %w", err)
	}

	req, err := http.NewRequestWithContext(ctx, "DELETE", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	client := utils.ConfigureSecurityClient(s._defaultClient, security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.DeleteUnderstandFieldTypeResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 204:
	}

	return res, nil
}

func (s *SDK) DeleteUnderstandFieldValue(ctx context.Context, request operations.DeleteUnderstandFieldValueRequest, security operations.DeleteUnderstandFieldValueSecurity, opts ...operations.Option) (*operations.DeleteUnderstandFieldValueResponse, error) {
	o := operations.Options{}
	supportedOptions := []string{
		operations.SupportedOptionServerURL,
	}

	for _, opt := range opts {
		if err := opt(&o, supportedOptions...); err != nil {
			return nil, fmt.Errorf("error applying option: %w", err)
		}
	}
	baseURL := operations.DeleteUnderstandFieldValueServerList[0]
	if o.ServerURL != nil {
		baseURL = *o.ServerURL
	}

	url, err := utils.GenerateURL(ctx, baseURL, "/understand/Assistants/{AssistantSid}/FieldTypes/{FieldTypeSid}/FieldValues/{Sid}", request, nil)
	if err != nil {
		return nil, fmt.Errorf("error generating URL: %w", err)
	}

	req, err := http.NewRequestWithContext(ctx, "DELETE", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	client := utils.ConfigureSecurityClient(s._defaultClient, security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.DeleteUnderstandFieldValueResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 204:
	}

	return res, nil
}

func (s *SDK) DeleteUnderstandModelBuild(ctx context.Context, request operations.DeleteUnderstandModelBuildRequest, security operations.DeleteUnderstandModelBuildSecurity, opts ...operations.Option) (*operations.DeleteUnderstandModelBuildResponse, error) {
	o := operations.Options{}
	supportedOptions := []string{
		operations.SupportedOptionServerURL,
	}

	for _, opt := range opts {
		if err := opt(&o, supportedOptions...); err != nil {
			return nil, fmt.Errorf("error applying option: %w", err)
		}
	}
	baseURL := operations.DeleteUnderstandModelBuildServerList[0]
	if o.ServerURL != nil {
		baseURL = *o.ServerURL
	}

	url, err := utils.GenerateURL(ctx, baseURL, "/understand/Assistants/{AssistantSid}/ModelBuilds/{Sid}", request, nil)
	if err != nil {
		return nil, fmt.Errorf("error generating URL: %w", err)
	}

	req, err := http.NewRequestWithContext(ctx, "DELETE", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	client := utils.ConfigureSecurityClient(s._defaultClient, security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.DeleteUnderstandModelBuildResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 204:
	}

	return res, nil
}

func (s *SDK) DeleteUnderstandQuery(ctx context.Context, request operations.DeleteUnderstandQueryRequest, security operations.DeleteUnderstandQuerySecurity, opts ...operations.Option) (*operations.DeleteUnderstandQueryResponse, error) {
	o := operations.Options{}
	supportedOptions := []string{
		operations.SupportedOptionServerURL,
	}

	for _, opt := range opts {
		if err := opt(&o, supportedOptions...); err != nil {
			return nil, fmt.Errorf("error applying option: %w", err)
		}
	}
	baseURL := operations.DeleteUnderstandQueryServerList[0]
	if o.ServerURL != nil {
		baseURL = *o.ServerURL
	}

	url, err := utils.GenerateURL(ctx, baseURL, "/understand/Assistants/{AssistantSid}/Queries/{Sid}", request, nil)
	if err != nil {
		return nil, fmt.Errorf("error generating URL: %w", err)
	}

	req, err := http.NewRequestWithContext(ctx, "DELETE", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	client := utils.ConfigureSecurityClient(s._defaultClient, security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.DeleteUnderstandQueryResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 204:
	}

	return res, nil
}

func (s *SDK) DeleteUnderstandSample(ctx context.Context, request operations.DeleteUnderstandSampleRequest, security operations.DeleteUnderstandSampleSecurity, opts ...operations.Option) (*operations.DeleteUnderstandSampleResponse, error) {
	o := operations.Options{}
	supportedOptions := []string{
		operations.SupportedOptionServerURL,
	}

	for _, opt := range opts {
		if err := opt(&o, supportedOptions...); err != nil {
			return nil, fmt.Errorf("error applying option: %w", err)
		}
	}
	baseURL := operations.DeleteUnderstandSampleServerList[0]
	if o.ServerURL != nil {
		baseURL = *o.ServerURL
	}

	url, err := utils.GenerateURL(ctx, baseURL, "/understand/Assistants/{AssistantSid}/Tasks/{TaskSid}/Samples/{Sid}", request, nil)
	if err != nil {
		return nil, fmt.Errorf("error generating URL: %w", err)
	}

	req, err := http.NewRequestWithContext(ctx, "DELETE", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	client := utils.ConfigureSecurityClient(s._defaultClient, security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.DeleteUnderstandSampleResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 204:
	}

	return res, nil
}

func (s *SDK) DeleteUnderstandTask(ctx context.Context, request operations.DeleteUnderstandTaskRequest, security operations.DeleteUnderstandTaskSecurity, opts ...operations.Option) (*operations.DeleteUnderstandTaskResponse, error) {
	o := operations.Options{}
	supportedOptions := []string{
		operations.SupportedOptionServerURL,
	}

	for _, opt := range opts {
		if err := opt(&o, supportedOptions...); err != nil {
			return nil, fmt.Errorf("error applying option: %w", err)
		}
	}
	baseURL := operations.DeleteUnderstandTaskServerList[0]
	if o.ServerURL != nil {
		baseURL = *o.ServerURL
	}

	url, err := utils.GenerateURL(ctx, baseURL, "/understand/Assistants/{AssistantSid}/Tasks/{Sid}", request, nil)
	if err != nil {
		return nil, fmt.Errorf("error generating URL: %w", err)
	}

	req, err := http.NewRequestWithContext(ctx, "DELETE", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	client := utils.ConfigureSecurityClient(s._defaultClient, security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.DeleteUnderstandTaskResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 204:
	}

	return res, nil
}

func (s *SDK) DeleteWirelessRatePlan(ctx context.Context, request operations.DeleteWirelessRatePlanRequest, security operations.DeleteWirelessRatePlanSecurity, opts ...operations.Option) (*operations.DeleteWirelessRatePlanResponse, error) {
	o := operations.Options{}
	supportedOptions := []string{
		operations.SupportedOptionServerURL,
	}

	for _, opt := range opts {
		if err := opt(&o, supportedOptions...); err != nil {
			return nil, fmt.Errorf("error applying option: %w", err)
		}
	}
	baseURL := operations.DeleteWirelessRatePlanServerList[0]
	if o.ServerURL != nil {
		baseURL = *o.ServerURL
	}

	url, err := utils.GenerateURL(ctx, baseURL, "/wireless/RatePlans/{Sid}", request, nil)
	if err != nil {
		return nil, fmt.Errorf("error generating URL: %w", err)
	}

	req, err := http.NewRequestWithContext(ctx, "DELETE", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	client := utils.ConfigureSecurityClient(s._defaultClient, security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.DeleteWirelessRatePlanResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 204:
	}

	return res, nil
}

// FetchDeployedDevicesCertificate - Fetch information about a specific Certificate credential in the Fleet.
func (s *SDK) FetchDeployedDevicesCertificate(ctx context.Context, request operations.FetchDeployedDevicesCertificateRequest, security operations.FetchDeployedDevicesCertificateSecurity, opts ...operations.Option) (*operations.FetchDeployedDevicesCertificateResponse, error) {
	o := operations.Options{}
	supportedOptions := []string{
		operations.SupportedOptionServerURL,
	}

	for _, opt := range opts {
		if err := opt(&o, supportedOptions...); err != nil {
			return nil, fmt.Errorf("error applying option: %w", err)
		}
	}
	baseURL := operations.FetchDeployedDevicesCertificateServerList[0]
	if o.ServerURL != nil {
		baseURL = *o.ServerURL
	}

	url, err := utils.GenerateURL(ctx, baseURL, "/DeployedDevices/Fleets/{FleetSid}/Certificates/{Sid}", request, nil)
	if err != nil {
		return nil, fmt.Errorf("error generating URL: %w", err)
	}

	req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	client := utils.ConfigureSecurityClient(s._defaultClient, security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.FetchDeployedDevicesCertificateResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *shared.PreviewDeployedDevicesFleetCertificate
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.PreviewDeployedDevicesFleetCertificate = out
		}
	}

	return res, nil
}

// FetchDeployedDevicesDeployment - Fetch information about a specific Deployment in the Fleet.
func (s *SDK) FetchDeployedDevicesDeployment(ctx context.Context, request operations.FetchDeployedDevicesDeploymentRequest, security operations.FetchDeployedDevicesDeploymentSecurity, opts ...operations.Option) (*operations.FetchDeployedDevicesDeploymentResponse, error) {
	o := operations.Options{}
	supportedOptions := []string{
		operations.SupportedOptionServerURL,
	}

	for _, opt := range opts {
		if err := opt(&o, supportedOptions...); err != nil {
			return nil, fmt.Errorf("error applying option: %w", err)
		}
	}
	baseURL := operations.FetchDeployedDevicesDeploymentServerList[0]
	if o.ServerURL != nil {
		baseURL = *o.ServerURL
	}

	url, err := utils.GenerateURL(ctx, baseURL, "/DeployedDevices/Fleets/{FleetSid}/Deployments/{Sid}", request, nil)
	if err != nil {
		return nil, fmt.Errorf("error generating URL: %w", err)
	}

	req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	client := utils.ConfigureSecurityClient(s._defaultClient, security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.FetchDeployedDevicesDeploymentResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *shared.PreviewDeployedDevicesFleetDeployment
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.PreviewDeployedDevicesFleetDeployment = out
		}
	}

	return res, nil
}

// FetchDeployedDevicesDevice - Fetch information about a specific Device in the Fleet.
func (s *SDK) FetchDeployedDevicesDevice(ctx context.Context, request operations.FetchDeployedDevicesDeviceRequest, security operations.FetchDeployedDevicesDeviceSecurity, opts ...operations.Option) (*operations.FetchDeployedDevicesDeviceResponse, error) {
	o := operations.Options{}
	supportedOptions := []string{
		operations.SupportedOptionServerURL,
	}

	for _, opt := range opts {
		if err := opt(&o, supportedOptions...); err != nil {
			return nil, fmt.Errorf("error applying option: %w", err)
		}
	}
	baseURL := operations.FetchDeployedDevicesDeviceServerList[0]
	if o.ServerURL != nil {
		baseURL = *o.ServerURL
	}

	url, err := utils.GenerateURL(ctx, baseURL, "/DeployedDevices/Fleets/{FleetSid}/Devices/{Sid}", request, nil)
	if err != nil {
		return nil, fmt.Errorf("error generating URL: %w", err)
	}

	req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	client := utils.ConfigureSecurityClient(s._defaultClient, security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.FetchDeployedDevicesDeviceResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *shared.PreviewDeployedDevicesFleetDevice
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.PreviewDeployedDevicesFleetDevice = out
		}
	}

	return res, nil
}

// FetchDeployedDevicesFleet - Fetch information about a specific Fleet in your account.
func (s *SDK) FetchDeployedDevicesFleet(ctx context.Context, request operations.FetchDeployedDevicesFleetRequest, security operations.FetchDeployedDevicesFleetSecurity, opts ...operations.Option) (*operations.FetchDeployedDevicesFleetResponse, error) {
	o := operations.Options{}
	supportedOptions := []string{
		operations.SupportedOptionServerURL,
	}

	for _, opt := range opts {
		if err := opt(&o, supportedOptions...); err != nil {
			return nil, fmt.Errorf("error applying option: %w", err)
		}
	}
	baseURL := operations.FetchDeployedDevicesFleetServerList[0]
	if o.ServerURL != nil {
		baseURL = *o.ServerURL
	}

	url, err := utils.GenerateURL(ctx, baseURL, "/DeployedDevices/Fleets/{Sid}", request, nil)
	if err != nil {
		return nil, fmt.Errorf("error generating URL: %w", err)
	}

	req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	client := utils.ConfigureSecurityClient(s._defaultClient, security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.FetchDeployedDevicesFleetResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *shared.PreviewDeployedDevicesFleet
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.PreviewDeployedDevicesFleet = out
		}
	}

	return res, nil
}

// FetchDeployedDevicesKey - Fetch information about a specific Key credential in the Fleet.
func (s *SDK) FetchDeployedDevicesKey(ctx context.Context, request operations.FetchDeployedDevicesKeyRequest, security operations.FetchDeployedDevicesKeySecurity, opts ...operations.Option) (*operations.FetchDeployedDevicesKeyResponse, error) {
	o := operations.Options{}
	supportedOptions := []string{
		operations.SupportedOptionServerURL,
	}

	for _, opt := range opts {
		if err := opt(&o, supportedOptions...); err != nil {
			return nil, fmt.Errorf("error applying option: %w", err)
		}
	}
	baseURL := operations.FetchDeployedDevicesKeyServerList[0]
	if o.ServerURL != nil {
		baseURL = *o.ServerURL
	}

	url, err := utils.GenerateURL(ctx, baseURL, "/DeployedDevices/Fleets/{FleetSid}/Keys/{Sid}", request, nil)
	if err != nil {
		return nil, fmt.Errorf("error generating URL: %w", err)
	}

	req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	client := utils.ConfigureSecurityClient(s._defaultClient, security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.FetchDeployedDevicesKeyResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *shared.PreviewDeployedDevicesFleetKey
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.PreviewDeployedDevicesFleetKey = out
		}
	}

	return res, nil
}

// FetchHostedNumbersAuthorizationDocument - Fetch a specific AuthorizationDocument.
func (s *SDK) FetchHostedNumbersAuthorizationDocument(ctx context.Context, request operations.FetchHostedNumbersAuthorizationDocumentRequest, security operations.FetchHostedNumbersAuthorizationDocumentSecurity, opts ...operations.Option) (*operations.FetchHostedNumbersAuthorizationDocumentResponse, error) {
	o := operations.Options{}
	supportedOptions := []string{
		operations.SupportedOptionServerURL,
	}

	for _, opt := range opts {
		if err := opt(&o, supportedOptions...); err != nil {
			return nil, fmt.Errorf("error applying option: %w", err)
		}
	}
	baseURL := operations.FetchHostedNumbersAuthorizationDocumentServerList[0]
	if o.ServerURL != nil {
		baseURL = *o.ServerURL
	}

	url, err := utils.GenerateURL(ctx, baseURL, "/HostedNumbers/AuthorizationDocuments/{Sid}", request, nil)
	if err != nil {
		return nil, fmt.Errorf("error generating URL: %w", err)
	}

	req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	client := utils.ConfigureSecurityClient(s._defaultClient, security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.FetchHostedNumbersAuthorizationDocumentResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *shared.PreviewHostedNumbersAuthorizationDocument
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.PreviewHostedNumbersAuthorizationDocument = out
		}
	}

	return res, nil
}

// FetchHostedNumbersHostedNumberOrder - Fetch a specific HostedNumberOrder.
func (s *SDK) FetchHostedNumbersHostedNumberOrder(ctx context.Context, request operations.FetchHostedNumbersHostedNumberOrderRequest, security operations.FetchHostedNumbersHostedNumberOrderSecurity, opts ...operations.Option) (*operations.FetchHostedNumbersHostedNumberOrderResponse, error) {
	o := operations.Options{}
	supportedOptions := []string{
		operations.SupportedOptionServerURL,
	}

	for _, opt := range opts {
		if err := opt(&o, supportedOptions...); err != nil {
			return nil, fmt.Errorf("error applying option: %w", err)
		}
	}
	baseURL := operations.FetchHostedNumbersHostedNumberOrderServerList[0]
	if o.ServerURL != nil {
		baseURL = *o.ServerURL
	}

	url, err := utils.GenerateURL(ctx, baseURL, "/HostedNumbers/HostedNumberOrders/{Sid}", request, nil)
	if err != nil {
		return nil, fmt.Errorf("error generating URL: %w", err)
	}

	req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	client := utils.ConfigureSecurityClient(s._defaultClient, security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.FetchHostedNumbersHostedNumberOrderResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *shared.PreviewHostedNumbersHostedNumberOrder
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.PreviewHostedNumbersHostedNumberOrder = out
		}
	}

	return res, nil
}

// FetchMarketplaceAvailableAddOn - Fetch an instance of an Add-on currently available to be installed.
func (s *SDK) FetchMarketplaceAvailableAddOn(ctx context.Context, request operations.FetchMarketplaceAvailableAddOnRequest, security operations.FetchMarketplaceAvailableAddOnSecurity, opts ...operations.Option) (*operations.FetchMarketplaceAvailableAddOnResponse, error) {
	o := operations.Options{}
	supportedOptions := []string{
		operations.SupportedOptionServerURL,
	}

	for _, opt := range opts {
		if err := opt(&o, supportedOptions...); err != nil {
			return nil, fmt.Errorf("error applying option: %w", err)
		}
	}
	baseURL := operations.FetchMarketplaceAvailableAddOnServerList[0]
	if o.ServerURL != nil {
		baseURL = *o.ServerURL
	}

	url, err := utils.GenerateURL(ctx, baseURL, "/marketplace/AvailableAddOns/{Sid}", request, nil)
	if err != nil {
		return nil, fmt.Errorf("error generating URL: %w", err)
	}

	req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	client := utils.ConfigureSecurityClient(s._defaultClient, security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.FetchMarketplaceAvailableAddOnResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *shared.PreviewMarketplaceAvailableAddOn
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.PreviewMarketplaceAvailableAddOn = out
		}
	}

	return res, nil
}

// FetchMarketplaceAvailableAddOnExtension - Fetch an instance of an Extension for the Available Add-on.
func (s *SDK) FetchMarketplaceAvailableAddOnExtension(ctx context.Context, request operations.FetchMarketplaceAvailableAddOnExtensionRequest, security operations.FetchMarketplaceAvailableAddOnExtensionSecurity, opts ...operations.Option) (*operations.FetchMarketplaceAvailableAddOnExtensionResponse, error) {
	o := operations.Options{}
	supportedOptions := []string{
		operations.SupportedOptionServerURL,
	}

	for _, opt := range opts {
		if err := opt(&o, supportedOptions...); err != nil {
			return nil, fmt.Errorf("error applying option: %w", err)
		}
	}
	baseURL := operations.FetchMarketplaceAvailableAddOnExtensionServerList[0]
	if o.ServerURL != nil {
		baseURL = *o.ServerURL
	}

	url, err := utils.GenerateURL(ctx, baseURL, "/marketplace/AvailableAddOns/{AvailableAddOnSid}/Extensions/{Sid}", request, nil)
	if err != nil {
		return nil, fmt.Errorf("error generating URL: %w", err)
	}

	req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	client := utils.ConfigureSecurityClient(s._defaultClient, security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.FetchMarketplaceAvailableAddOnExtensionResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *shared.PreviewMarketplaceAvailableAddOnAvailableAddOnExtension
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.PreviewMarketplaceAvailableAddOnAvailableAddOnExtension = out
		}
	}

	return res, nil
}

// FetchMarketplaceInstalledAddOn - Fetch an instance of an Add-on currently installed on this Account.
func (s *SDK) FetchMarketplaceInstalledAddOn(ctx context.Context, request operations.FetchMarketplaceInstalledAddOnRequest, security operations.FetchMarketplaceInstalledAddOnSecurity, opts ...operations.Option) (*operations.FetchMarketplaceInstalledAddOnResponse, error) {
	o := operations.Options{}
	supportedOptions := []string{
		operations.SupportedOptionServerURL,
	}

	for _, opt := range opts {
		if err := opt(&o, supportedOptions...); err != nil {
			return nil, fmt.Errorf("error applying option: %w", err)
		}
	}
	baseURL := operations.FetchMarketplaceInstalledAddOnServerList[0]
	if o.ServerURL != nil {
		baseURL = *o.ServerURL
	}

	url, err := utils.GenerateURL(ctx, baseURL, "/marketplace/InstalledAddOns/{Sid}", request, nil)
	if err != nil {
		return nil, fmt.Errorf("error generating URL: %w", err)
	}

	req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	client := utils.ConfigureSecurityClient(s._defaultClient, security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.FetchMarketplaceInstalledAddOnResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *shared.PreviewMarketplaceInstalledAddOn
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.PreviewMarketplaceInstalledAddOn = out
		}
	}

	return res, nil
}

// FetchMarketplaceInstalledAddOnExtension - Fetch an instance of an Extension for the Installed Add-on.
func (s *SDK) FetchMarketplaceInstalledAddOnExtension(ctx context.Context, request operations.FetchMarketplaceInstalledAddOnExtensionRequest, security operations.FetchMarketplaceInstalledAddOnExtensionSecurity, opts ...operations.Option) (*operations.FetchMarketplaceInstalledAddOnExtensionResponse, error) {
	o := operations.Options{}
	supportedOptions := []string{
		operations.SupportedOptionServerURL,
	}

	for _, opt := range opts {
		if err := opt(&o, supportedOptions...); err != nil {
			return nil, fmt.Errorf("error applying option: %w", err)
		}
	}
	baseURL := operations.FetchMarketplaceInstalledAddOnExtensionServerList[0]
	if o.ServerURL != nil {
		baseURL = *o.ServerURL
	}

	url, err := utils.GenerateURL(ctx, baseURL, "/marketplace/InstalledAddOns/{InstalledAddOnSid}/Extensions/{Sid}", request, nil)
	if err != nil {
		return nil, fmt.Errorf("error generating URL: %w", err)
	}

	req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	client := utils.ConfigureSecurityClient(s._defaultClient, security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.FetchMarketplaceInstalledAddOnExtensionResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *shared.PreviewMarketplaceInstalledAddOnInstalledAddOnExtension
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.PreviewMarketplaceInstalledAddOnInstalledAddOnExtension = out
		}
	}

	return res, nil
}

func (s *SDK) FetchSyncDocument(ctx context.Context, request operations.FetchSyncDocumentRequest, security operations.FetchSyncDocumentSecurity, opts ...operations.Option) (*operations.FetchSyncDocumentResponse, error) {
	o := operations.Options{}
	supportedOptions := []string{
		operations.SupportedOptionServerURL,
	}

	for _, opt := range opts {
		if err := opt(&o, supportedOptions...); err != nil {
			return nil, fmt.Errorf("error applying option: %w", err)
		}
	}
	baseURL := operations.FetchSyncDocumentServerList[0]
	if o.ServerURL != nil {
		baseURL = *o.ServerURL
	}

	url, err := utils.GenerateURL(ctx, baseURL, "/Sync/Services/{ServiceSid}/Documents/{Sid}", request, nil)
	if err != nil {
		return nil, fmt.Errorf("error generating URL: %w", err)
	}

	req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	client := utils.ConfigureSecurityClient(s._defaultClient, security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.FetchSyncDocumentResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *shared.PreviewSyncServiceDocument
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.PreviewSyncServiceDocument = out
		}
	}

	return res, nil
}

// FetchSyncDocumentPermission - Fetch a specific Sync Document Permission.
func (s *SDK) FetchSyncDocumentPermission(ctx context.Context, request operations.FetchSyncDocumentPermissionRequest, security operations.FetchSyncDocumentPermissionSecurity, opts ...operations.Option) (*operations.FetchSyncDocumentPermissionResponse, error) {
	o := operations.Options{}
	supportedOptions := []string{
		operations.SupportedOptionServerURL,
	}

	for _, opt := range opts {
		if err := opt(&o, supportedOptions...); err != nil {
			return nil, fmt.Errorf("error applying option: %w", err)
		}
	}
	baseURL := operations.FetchSyncDocumentPermissionServerList[0]
	if o.ServerURL != nil {
		baseURL = *o.ServerURL
	}

	url, err := utils.GenerateURL(ctx, baseURL, "/Sync/Services/{ServiceSid}/Documents/{DocumentSid}/Permissions/{Identity}", request, nil)
	if err != nil {
		return nil, fmt.Errorf("error generating URL: %w", err)
	}

	req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	client := utils.ConfigureSecurityClient(s._defaultClient, security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.FetchSyncDocumentPermissionResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *shared.PreviewSyncServiceDocumentDocumentPermission
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.PreviewSyncServiceDocumentDocumentPermission = out
		}
	}

	return res, nil
}

func (s *SDK) FetchSyncService(ctx context.Context, request operations.FetchSyncServiceRequest, security operations.FetchSyncServiceSecurity, opts ...operations.Option) (*operations.FetchSyncServiceResponse, error) {
	o := operations.Options{}
	supportedOptions := []string{
		operations.SupportedOptionServerURL,
	}

	for _, opt := range opts {
		if err := opt(&o, supportedOptions...); err != nil {
			return nil, fmt.Errorf("error applying option: %w", err)
		}
	}
	baseURL := operations.FetchSyncServiceServerList[0]
	if o.ServerURL != nil {
		baseURL = *o.ServerURL
	}

	url, err := utils.GenerateURL(ctx, baseURL, "/Sync/Services/{Sid}", request, nil)
	if err != nil {
		return nil, fmt.Errorf("error generating URL: %w", err)
	}

	req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	client := utils.ConfigureSecurityClient(s._defaultClient, security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.FetchSyncServiceResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *shared.PreviewSyncService
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.PreviewSyncService = out
		}
	}

	return res, nil
}

func (s *SDK) FetchSyncSyncList(ctx context.Context, request operations.FetchSyncSyncListRequest, security operations.FetchSyncSyncListSecurity, opts ...operations.Option) (*operations.FetchSyncSyncListResponse, error) {
	o := operations.Options{}
	supportedOptions := []string{
		operations.SupportedOptionServerURL,
	}

	for _, opt := range opts {
		if err := opt(&o, supportedOptions...); err != nil {
			return nil, fmt.Errorf("error applying option: %w", err)
		}
	}
	baseURL := operations.FetchSyncSyncListServerList[0]
	if o.ServerURL != nil {
		baseURL = *o.ServerURL
	}

	url, err := utils.GenerateURL(ctx, baseURL, "/Sync/Services/{ServiceSid}/Lists/{Sid}", request, nil)
	if err != nil {
		return nil, fmt.Errorf("error generating URL: %w", err)
	}

	req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	client := utils.ConfigureSecurityClient(s._defaultClient, security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.FetchSyncSyncListResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *shared.PreviewSyncServiceSyncList
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.PreviewSyncServiceSyncList = out
		}
	}

	return res, nil
}

func (s *SDK) FetchSyncSyncListItem(ctx context.Context, request operations.FetchSyncSyncListItemRequest, security operations.FetchSyncSyncListItemSecurity, opts ...operations.Option) (*operations.FetchSyncSyncListItemResponse, error) {
	o := operations.Options{}
	supportedOptions := []string{
		operations.SupportedOptionServerURL,
	}

	for _, opt := range opts {
		if err := opt(&o, supportedOptions...); err != nil {
			return nil, fmt.Errorf("error applying option: %w", err)
		}
	}
	baseURL := operations.FetchSyncSyncListItemServerList[0]
	if o.ServerURL != nil {
		baseURL = *o.ServerURL
	}

	url, err := utils.GenerateURL(ctx, baseURL, "/Sync/Services/{ServiceSid}/Lists/{ListSid}/Items/{Index}", request, nil)
	if err != nil {
		return nil, fmt.Errorf("error generating URL: %w", err)
	}

	req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	client := utils.ConfigureSecurityClient(s._defaultClient, security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.FetchSyncSyncListItemResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *shared.PreviewSyncServiceSyncListSyncListItem
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.PreviewSyncServiceSyncListSyncListItem = out
		}
	}

	return res, nil
}

// FetchSyncSyncListPermission - Fetch a specific Sync List Permission.
func (s *SDK) FetchSyncSyncListPermission(ctx context.Context, request operations.FetchSyncSyncListPermissionRequest, security operations.FetchSyncSyncListPermissionSecurity, opts ...operations.Option) (*operations.FetchSyncSyncListPermissionResponse, error) {
	o := operations.Options{}
	supportedOptions := []string{
		operations.SupportedOptionServerURL,
	}

	for _, opt := range opts {
		if err := opt(&o, supportedOptions...); err != nil {
			return nil, fmt.Errorf("error applying option: %w", err)
		}
	}
	baseURL := operations.FetchSyncSyncListPermissionServerList[0]
	if o.ServerURL != nil {
		baseURL = *o.ServerURL
	}

	url, err := utils.GenerateURL(ctx, baseURL, "/Sync/Services/{ServiceSid}/Lists/{ListSid}/Permissions/{Identity}", request, nil)
	if err != nil {
		return nil, fmt.Errorf("error generating URL: %w", err)
	}

	req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	client := utils.ConfigureSecurityClient(s._defaultClient, security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.FetchSyncSyncListPermissionResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *shared.PreviewSyncServiceSyncListSyncListPermission
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.PreviewSyncServiceSyncListSyncListPermission = out
		}
	}

	return res, nil
}

func (s *SDK) FetchSyncSyncMap(ctx context.Context, request operations.FetchSyncSyncMapRequest, security operations.FetchSyncSyncMapSecurity, opts ...operations.Option) (*operations.FetchSyncSyncMapResponse, error) {
	o := operations.Options{}
	supportedOptions := []string{
		operations.SupportedOptionServerURL,
	}

	for _, opt := range opts {
		if err := opt(&o, supportedOptions...); err != nil {
			return nil, fmt.Errorf("error applying option: %w", err)
		}
	}
	baseURL := operations.FetchSyncSyncMapServerList[0]
	if o.ServerURL != nil {
		baseURL = *o.ServerURL
	}

	url, err := utils.GenerateURL(ctx, baseURL, "/Sync/Services/{ServiceSid}/Maps/{Sid}", request, nil)
	if err != nil {
		return nil, fmt.Errorf("error generating URL: %w", err)
	}

	req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	client := utils.ConfigureSecurityClient(s._defaultClient, security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.FetchSyncSyncMapResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *shared.PreviewSyncServiceSyncMap
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.PreviewSyncServiceSyncMap = out
		}
	}

	return res, nil
}

func (s *SDK) FetchSyncSyncMapItem(ctx context.Context, request operations.FetchSyncSyncMapItemRequest, security operations.FetchSyncSyncMapItemSecurity, opts ...operations.Option) (*operations.FetchSyncSyncMapItemResponse, error) {
	o := operations.Options{}
	supportedOptions := []string{
		operations.SupportedOptionServerURL,
	}

	for _, opt := range opts {
		if err := opt(&o, supportedOptions...); err != nil {
			return nil, fmt.Errorf("error applying option: %w", err)
		}
	}
	baseURL := operations.FetchSyncSyncMapItemServerList[0]
	if o.ServerURL != nil {
		baseURL = *o.ServerURL
	}

	url, err := utils.GenerateURL(ctx, baseURL, "/Sync/Services/{ServiceSid}/Maps/{MapSid}/Items/{Key}", request, nil)
	if err != nil {
		return nil, fmt.Errorf("error generating URL: %w", err)
	}

	req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	client := utils.ConfigureSecurityClient(s._defaultClient, security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.FetchSyncSyncMapItemResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *shared.PreviewSyncServiceSyncMapSyncMapItem
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.PreviewSyncServiceSyncMapSyncMapItem = out
		}
	}

	return res, nil
}

// FetchSyncSyncMapPermission - Fetch a specific Sync Map Permission.
func (s *SDK) FetchSyncSyncMapPermission(ctx context.Context, request operations.FetchSyncSyncMapPermissionRequest, security operations.FetchSyncSyncMapPermissionSecurity, opts ...operations.Option) (*operations.FetchSyncSyncMapPermissionResponse, error) {
	o := operations.Options{}
	supportedOptions := []string{
		operations.SupportedOptionServerURL,
	}

	for _, opt := range opts {
		if err := opt(&o, supportedOptions...); err != nil {
			return nil, fmt.Errorf("error applying option: %w", err)
		}
	}
	baseURL := operations.FetchSyncSyncMapPermissionServerList[0]
	if o.ServerURL != nil {
		baseURL = *o.ServerURL
	}

	url, err := utils.GenerateURL(ctx, baseURL, "/Sync/Services/{ServiceSid}/Maps/{MapSid}/Permissions/{Identity}", request, nil)
	if err != nil {
		return nil, fmt.Errorf("error generating URL: %w", err)
	}

	req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	client := utils.ConfigureSecurityClient(s._defaultClient, security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.FetchSyncSyncMapPermissionResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *shared.PreviewSyncServiceSyncMapSyncMapPermission
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.PreviewSyncServiceSyncMapSyncMapPermission = out
		}
	}

	return res, nil
}

func (s *SDK) FetchUnderstandAssistant(ctx context.Context, request operations.FetchUnderstandAssistantRequest, security operations.FetchUnderstandAssistantSecurity, opts ...operations.Option) (*operations.FetchUnderstandAssistantResponse, error) {
	o := operations.Options{}
	supportedOptions := []string{
		operations.SupportedOptionServerURL,
	}

	for _, opt := range opts {
		if err := opt(&o, supportedOptions...); err != nil {
			return nil, fmt.Errorf("error applying option: %w", err)
		}
	}
	baseURL := operations.FetchUnderstandAssistantServerList[0]
	if o.ServerURL != nil {
		baseURL = *o.ServerURL
	}

	url, err := utils.GenerateURL(ctx, baseURL, "/understand/Assistants/{Sid}", request, nil)
	if err != nil {
		return nil, fmt.Errorf("error generating URL: %w", err)
	}

	req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	client := utils.ConfigureSecurityClient(s._defaultClient, security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.FetchUnderstandAssistantResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *shared.PreviewUnderstandAssistant
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.PreviewUnderstandAssistant = out
		}
	}

	return res, nil
}

func (s *SDK) FetchUnderstandAssistantFallbackActions(ctx context.Context, request operations.FetchUnderstandAssistantFallbackActionsRequest, security operations.FetchUnderstandAssistantFallbackActionsSecurity, opts ...operations.Option) (*operations.FetchUnderstandAssistantFallbackActionsResponse, error) {
	o := operations.Options{}
	supportedOptions := []string{
		operations.SupportedOptionServerURL,
	}

	for _, opt := range opts {
		if err := opt(&o, supportedOptions...); err != nil {
			return nil, fmt.Errorf("error applying option: %w", err)
		}
	}
	baseURL := operations.FetchUnderstandAssistantFallbackActionsServerList[0]
	if o.ServerURL != nil {
		baseURL = *o.ServerURL
	}

	url, err := utils.GenerateURL(ctx, baseURL, "/understand/Assistants/{AssistantSid}/FallbackActions", request, nil)
	if err != nil {
		return nil, fmt.Errorf("error generating URL: %w", err)
	}

	req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	client := utils.ConfigureSecurityClient(s._defaultClient, security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.FetchUnderstandAssistantFallbackActionsResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *shared.PreviewUnderstandAssistantAssistantFallbackActions
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.PreviewUnderstandAssistantAssistantFallbackActions = out
		}
	}

	return res, nil
}

func (s *SDK) FetchUnderstandAssistantInitiationActions(ctx context.Context, request operations.FetchUnderstandAssistantInitiationActionsRequest, security operations.FetchUnderstandAssistantInitiationActionsSecurity, opts ...operations.Option) (*operations.FetchUnderstandAssistantInitiationActionsResponse, error) {
	o := operations.Options{}
	supportedOptions := []string{
		operations.SupportedOptionServerURL,
	}

	for _, opt := range opts {
		if err := opt(&o, supportedOptions...); err != nil {
			return nil, fmt.Errorf("error applying option: %w", err)
		}
	}
	baseURL := operations.FetchUnderstandAssistantInitiationActionsServerList[0]
	if o.ServerURL != nil {
		baseURL = *o.ServerURL
	}

	url, err := utils.GenerateURL(ctx, baseURL, "/understand/Assistants/{AssistantSid}/InitiationActions", request, nil)
	if err != nil {
		return nil, fmt.Errorf("error generating URL: %w", err)
	}

	req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	client := utils.ConfigureSecurityClient(s._defaultClient, security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.FetchUnderstandAssistantInitiationActionsResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *shared.PreviewUnderstandAssistantAssistantInitiationActions
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.PreviewUnderstandAssistantAssistantInitiationActions = out
		}
	}

	return res, nil
}

func (s *SDK) FetchUnderstandDialogue(ctx context.Context, request operations.FetchUnderstandDialogueRequest, security operations.FetchUnderstandDialogueSecurity, opts ...operations.Option) (*operations.FetchUnderstandDialogueResponse, error) {
	o := operations.Options{}
	supportedOptions := []string{
		operations.SupportedOptionServerURL,
	}

	for _, opt := range opts {
		if err := opt(&o, supportedOptions...); err != nil {
			return nil, fmt.Errorf("error applying option: %w", err)
		}
	}
	baseURL := operations.FetchUnderstandDialogueServerList[0]
	if o.ServerURL != nil {
		baseURL = *o.ServerURL
	}

	url, err := utils.GenerateURL(ctx, baseURL, "/understand/Assistants/{AssistantSid}/Dialogues/{Sid}", request, nil)
	if err != nil {
		return nil, fmt.Errorf("error generating URL: %w", err)
	}

	req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	client := utils.ConfigureSecurityClient(s._defaultClient, security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.FetchUnderstandDialogueResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *shared.PreviewUnderstandAssistantDialogue
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.PreviewUnderstandAssistantDialogue = out
		}
	}

	return res, nil
}

func (s *SDK) FetchUnderstandField(ctx context.Context, request operations.FetchUnderstandFieldRequest, security operations.FetchUnderstandFieldSecurity, opts ...operations.Option) (*operations.FetchUnderstandFieldResponse, error) {
	o := operations.Options{}
	supportedOptions := []string{
		operations.SupportedOptionServerURL,
	}

	for _, opt := range opts {
		if err := opt(&o, supportedOptions...); err != nil {
			return nil, fmt.Errorf("error applying option: %w", err)
		}
	}
	baseURL := operations.FetchUnderstandFieldServerList[0]
	if o.ServerURL != nil {
		baseURL = *o.ServerURL
	}

	url, err := utils.GenerateURL(ctx, baseURL, "/understand/Assistants/{AssistantSid}/Tasks/{TaskSid}/Fields/{Sid}", request, nil)
	if err != nil {
		return nil, fmt.Errorf("error generating URL: %w", err)
	}

	req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	client := utils.ConfigureSecurityClient(s._defaultClient, security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.FetchUnderstandFieldResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *shared.PreviewUnderstandAssistantTaskField
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.PreviewUnderstandAssistantTaskField = out
		}
	}

	return res, nil
}

func (s *SDK) FetchUnderstandFieldType(ctx context.Context, request operations.FetchUnderstandFieldTypeRequest, security operations.FetchUnderstandFieldTypeSecurity, opts ...operations.Option) (*operations.FetchUnderstandFieldTypeResponse, error) {
	o := operations.Options{}
	supportedOptions := []string{
		operations.SupportedOptionServerURL,
	}

	for _, opt := range opts {
		if err := opt(&o, supportedOptions...); err != nil {
			return nil, fmt.Errorf("error applying option: %w", err)
		}
	}
	baseURL := operations.FetchUnderstandFieldTypeServerList[0]
	if o.ServerURL != nil {
		baseURL = *o.ServerURL
	}

	url, err := utils.GenerateURL(ctx, baseURL, "/understand/Assistants/{AssistantSid}/FieldTypes/{Sid}", request, nil)
	if err != nil {
		return nil, fmt.Errorf("error generating URL: %w", err)
	}

	req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	client := utils.ConfigureSecurityClient(s._defaultClient, security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.FetchUnderstandFieldTypeResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *shared.PreviewUnderstandAssistantFieldType
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.PreviewUnderstandAssistantFieldType = out
		}
	}

	return res, nil
}

func (s *SDK) FetchUnderstandFieldValue(ctx context.Context, request operations.FetchUnderstandFieldValueRequest, security operations.FetchUnderstandFieldValueSecurity, opts ...operations.Option) (*operations.FetchUnderstandFieldValueResponse, error) {
	o := operations.Options{}
	supportedOptions := []string{
		operations.SupportedOptionServerURL,
	}

	for _, opt := range opts {
		if err := opt(&o, supportedOptions...); err != nil {
			return nil, fmt.Errorf("error applying option: %w", err)
		}
	}
	baseURL := operations.FetchUnderstandFieldValueServerList[0]
	if o.ServerURL != nil {
		baseURL = *o.ServerURL
	}

	url, err := utils.GenerateURL(ctx, baseURL, "/understand/Assistants/{AssistantSid}/FieldTypes/{FieldTypeSid}/FieldValues/{Sid}", request, nil)
	if err != nil {
		return nil, fmt.Errorf("error generating URL: %w", err)
	}

	req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	client := utils.ConfigureSecurityClient(s._defaultClient, security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.FetchUnderstandFieldValueResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *shared.PreviewUnderstandAssistantFieldTypeFieldValue
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.PreviewUnderstandAssistantFieldTypeFieldValue = out
		}
	}

	return res, nil
}

func (s *SDK) FetchUnderstandModelBuild(ctx context.Context, request operations.FetchUnderstandModelBuildRequest, security operations.FetchUnderstandModelBuildSecurity, opts ...operations.Option) (*operations.FetchUnderstandModelBuildResponse, error) {
	o := operations.Options{}
	supportedOptions := []string{
		operations.SupportedOptionServerURL,
	}

	for _, opt := range opts {
		if err := opt(&o, supportedOptions...); err != nil {
			return nil, fmt.Errorf("error applying option: %w", err)
		}
	}
	baseURL := operations.FetchUnderstandModelBuildServerList[0]
	if o.ServerURL != nil {
		baseURL = *o.ServerURL
	}

	url, err := utils.GenerateURL(ctx, baseURL, "/understand/Assistants/{AssistantSid}/ModelBuilds/{Sid}", request, nil)
	if err != nil {
		return nil, fmt.Errorf("error generating URL: %w", err)
	}

	req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	client := utils.ConfigureSecurityClient(s._defaultClient, security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.FetchUnderstandModelBuildResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *shared.PreviewUnderstandAssistantModelBuild
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.PreviewUnderstandAssistantModelBuild = out
		}
	}

	return res, nil
}

func (s *SDK) FetchUnderstandQuery(ctx context.Context, request operations.FetchUnderstandQueryRequest, security operations.FetchUnderstandQuerySecurity, opts ...operations.Option) (*operations.FetchUnderstandQueryResponse, error) {
	o := operations.Options{}
	supportedOptions := []string{
		operations.SupportedOptionServerURL,
	}

	for _, opt := range opts {
		if err := opt(&o, supportedOptions...); err != nil {
			return nil, fmt.Errorf("error applying option: %w", err)
		}
	}
	baseURL := operations.FetchUnderstandQueryServerList[0]
	if o.ServerURL != nil {
		baseURL = *o.ServerURL
	}

	url, err := utils.GenerateURL(ctx, baseURL, "/understand/Assistants/{AssistantSid}/Queries/{Sid}", request, nil)
	if err != nil {
		return nil, fmt.Errorf("error generating URL: %w", err)
	}

	req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	client := utils.ConfigureSecurityClient(s._defaultClient, security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.FetchUnderstandQueryResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *shared.PreviewUnderstandAssistantQuery
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.PreviewUnderstandAssistantQuery = out
		}
	}

	return res, nil
}

func (s *SDK) FetchUnderstandSample(ctx context.Context, request operations.FetchUnderstandSampleRequest, security operations.FetchUnderstandSampleSecurity, opts ...operations.Option) (*operations.FetchUnderstandSampleResponse, error) {
	o := operations.Options{}
	supportedOptions := []string{
		operations.SupportedOptionServerURL,
	}

	for _, opt := range opts {
		if err := opt(&o, supportedOptions...); err != nil {
			return nil, fmt.Errorf("error applying option: %w", err)
		}
	}
	baseURL := operations.FetchUnderstandSampleServerList[0]
	if o.ServerURL != nil {
		baseURL = *o.ServerURL
	}

	url, err := utils.GenerateURL(ctx, baseURL, "/understand/Assistants/{AssistantSid}/Tasks/{TaskSid}/Samples/{Sid}", request, nil)
	if err != nil {
		return nil, fmt.Errorf("error generating URL: %w", err)
	}

	req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	client := utils.ConfigureSecurityClient(s._defaultClient, security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.FetchUnderstandSampleResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *shared.PreviewUnderstandAssistantTaskSample
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.PreviewUnderstandAssistantTaskSample = out
		}
	}

	return res, nil
}

// FetchUnderstandStyleSheet - Returns Style sheet JSON object for this Assistant
func (s *SDK) FetchUnderstandStyleSheet(ctx context.Context, request operations.FetchUnderstandStyleSheetRequest, security operations.FetchUnderstandStyleSheetSecurity, opts ...operations.Option) (*operations.FetchUnderstandStyleSheetResponse, error) {
	o := operations.Options{}
	supportedOptions := []string{
		operations.SupportedOptionServerURL,
	}

	for _, opt := range opts {
		if err := opt(&o, supportedOptions...); err != nil {
			return nil, fmt.Errorf("error applying option: %w", err)
		}
	}
	baseURL := operations.FetchUnderstandStyleSheetServerList[0]
	if o.ServerURL != nil {
		baseURL = *o.ServerURL
	}

	url, err := utils.GenerateURL(ctx, baseURL, "/understand/Assistants/{AssistantSid}/StyleSheet", request, nil)
	if err != nil {
		return nil, fmt.Errorf("error generating URL: %w", err)
	}

	req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	client := utils.ConfigureSecurityClient(s._defaultClient, security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.FetchUnderstandStyleSheetResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *shared.PreviewUnderstandAssistantStyleSheet
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.PreviewUnderstandAssistantStyleSheet = out
		}
	}

	return res, nil
}

func (s *SDK) FetchUnderstandTask(ctx context.Context, request operations.FetchUnderstandTaskRequest, security operations.FetchUnderstandTaskSecurity, opts ...operations.Option) (*operations.FetchUnderstandTaskResponse, error) {
	o := operations.Options{}
	supportedOptions := []string{
		operations.SupportedOptionServerURL,
	}

	for _, opt := range opts {
		if err := opt(&o, supportedOptions...); err != nil {
			return nil, fmt.Errorf("error applying option: %w", err)
		}
	}
	baseURL := operations.FetchUnderstandTaskServerList[0]
	if o.ServerURL != nil {
		baseURL = *o.ServerURL
	}

	url, err := utils.GenerateURL(ctx, baseURL, "/understand/Assistants/{AssistantSid}/Tasks/{Sid}", request, nil)
	if err != nil {
		return nil, fmt.Errorf("error generating URL: %w", err)
	}

	req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	client := utils.ConfigureSecurityClient(s._defaultClient, security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.FetchUnderstandTaskResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *shared.PreviewUnderstandAssistantTask
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.PreviewUnderstandAssistantTask = out
		}
	}

	return res, nil
}

// FetchUnderstandTaskActions - Returns JSON actions for this Task.
func (s *SDK) FetchUnderstandTaskActions(ctx context.Context, request operations.FetchUnderstandTaskActionsRequest, security operations.FetchUnderstandTaskActionsSecurity, opts ...operations.Option) (*operations.FetchUnderstandTaskActionsResponse, error) {
	o := operations.Options{}
	supportedOptions := []string{
		operations.SupportedOptionServerURL,
	}

	for _, opt := range opts {
		if err := opt(&o, supportedOptions...); err != nil {
			return nil, fmt.Errorf("error applying option: %w", err)
		}
	}
	baseURL := operations.FetchUnderstandTaskActionsServerList[0]
	if o.ServerURL != nil {
		baseURL = *o.ServerURL
	}

	url, err := utils.GenerateURL(ctx, baseURL, "/understand/Assistants/{AssistantSid}/Tasks/{TaskSid}/Actions", request, nil)
	if err != nil {
		return nil, fmt.Errorf("error generating URL: %w", err)
	}

	req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	client := utils.ConfigureSecurityClient(s._defaultClient, security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.FetchUnderstandTaskActionsResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *shared.PreviewUnderstandAssistantTaskTaskActions
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.PreviewUnderstandAssistantTaskTaskActions = out
		}
	}

	return res, nil
}

func (s *SDK) FetchUnderstandTaskStatistics(ctx context.Context, request operations.FetchUnderstandTaskStatisticsRequest, security operations.FetchUnderstandTaskStatisticsSecurity, opts ...operations.Option) (*operations.FetchUnderstandTaskStatisticsResponse, error) {
	o := operations.Options{}
	supportedOptions := []string{
		operations.SupportedOptionServerURL,
	}

	for _, opt := range opts {
		if err := opt(&o, supportedOptions...); err != nil {
			return nil, fmt.Errorf("error applying option: %w", err)
		}
	}
	baseURL := operations.FetchUnderstandTaskStatisticsServerList[0]
	if o.ServerURL != nil {
		baseURL = *o.ServerURL
	}

	url, err := utils.GenerateURL(ctx, baseURL, "/understand/Assistants/{AssistantSid}/Tasks/{TaskSid}/Statistics", request, nil)
	if err != nil {
		return nil, fmt.Errorf("error generating URL: %w", err)
	}

	req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	client := utils.ConfigureSecurityClient(s._defaultClient, security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.FetchUnderstandTaskStatisticsResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *shared.PreviewUnderstandAssistantTaskTaskStatistics
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.PreviewUnderstandAssistantTaskTaskStatistics = out
		}
	}

	return res, nil
}

func (s *SDK) FetchWirelessCommand(ctx context.Context, request operations.FetchWirelessCommandRequest, security operations.FetchWirelessCommandSecurity, opts ...operations.Option) (*operations.FetchWirelessCommandResponse, error) {
	o := operations.Options{}
	supportedOptions := []string{
		operations.SupportedOptionServerURL,
	}

	for _, opt := range opts {
		if err := opt(&o, supportedOptions...); err != nil {
			return nil, fmt.Errorf("error applying option: %w", err)
		}
	}
	baseURL := operations.FetchWirelessCommandServerList[0]
	if o.ServerURL != nil {
		baseURL = *o.ServerURL
	}

	url, err := utils.GenerateURL(ctx, baseURL, "/wireless/Commands/{Sid}", request, nil)
	if err != nil {
		return nil, fmt.Errorf("error generating URL: %w", err)
	}

	req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	client := utils.ConfigureSecurityClient(s._defaultClient, security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.FetchWirelessCommandResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *shared.PreviewWirelessCommand
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.PreviewWirelessCommand = out
		}
	}

	return res, nil
}

func (s *SDK) FetchWirelessRatePlan(ctx context.Context, request operations.FetchWirelessRatePlanRequest, security operations.FetchWirelessRatePlanSecurity, opts ...operations.Option) (*operations.FetchWirelessRatePlanResponse, error) {
	o := operations.Options{}
	supportedOptions := []string{
		operations.SupportedOptionServerURL,
	}

	for _, opt := range opts {
		if err := opt(&o, supportedOptions...); err != nil {
			return nil, fmt.Errorf("error applying option: %w", err)
		}
	}
	baseURL := operations.FetchWirelessRatePlanServerList[0]
	if o.ServerURL != nil {
		baseURL = *o.ServerURL
	}

	url, err := utils.GenerateURL(ctx, baseURL, "/wireless/RatePlans/{Sid}", request, nil)
	if err != nil {
		return nil, fmt.Errorf("error generating URL: %w", err)
	}

	req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	client := utils.ConfigureSecurityClient(s._defaultClient, security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.FetchWirelessRatePlanResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *shared.PreviewWirelessRatePlan
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.PreviewWirelessRatePlan = out
		}
	}

	return res, nil
}

func (s *SDK) FetchWirelessSim(ctx context.Context, request operations.FetchWirelessSimRequest, security operations.FetchWirelessSimSecurity, opts ...operations.Option) (*operations.FetchWirelessSimResponse, error) {
	o := operations.Options{}
	supportedOptions := []string{
		operations.SupportedOptionServerURL,
	}

	for _, opt := range opts {
		if err := opt(&o, supportedOptions...); err != nil {
			return nil, fmt.Errorf("error applying option: %w", err)
		}
	}
	baseURL := operations.FetchWirelessSimServerList[0]
	if o.ServerURL != nil {
		baseURL = *o.ServerURL
	}

	url, err := utils.GenerateURL(ctx, baseURL, "/wireless/Sims/{Sid}", request, nil)
	if err != nil {
		return nil, fmt.Errorf("error generating URL: %w", err)
	}

	req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	client := utils.ConfigureSecurityClient(s._defaultClient, security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.FetchWirelessSimResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *shared.PreviewWirelessSim
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.PreviewWirelessSim = out
		}
	}

	return res, nil
}

func (s *SDK) FetchWirelessUsage(ctx context.Context, request operations.FetchWirelessUsageRequest, security operations.FetchWirelessUsageSecurity, opts ...operations.Option) (*operations.FetchWirelessUsageResponse, error) {
	o := operations.Options{}
	supportedOptions := []string{
		operations.SupportedOptionServerURL,
	}

	for _, opt := range opts {
		if err := opt(&o, supportedOptions...); err != nil {
			return nil, fmt.Errorf("error applying option: %w", err)
		}
	}
	baseURL := operations.FetchWirelessUsageServerList[0]
	if o.ServerURL != nil {
		baseURL = *o.ServerURL
	}

	url, err := utils.GenerateURL(ctx, baseURL, "/wireless/Sims/{SimSid}/Usage", request, nil)
	if err != nil {
		return nil, fmt.Errorf("error generating URL: %w", err)
	}

	req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	if err := utils.PopulateQueryParams(ctx, req, request, nil); err != nil {
		return nil, fmt.Errorf("error populating query params: %w", err)
	}

	client := utils.ConfigureSecurityClient(s._defaultClient, security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.FetchWirelessUsageResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *shared.PreviewWirelessSimUsage
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.PreviewWirelessSimUsage = out
		}
	}

	return res, nil
}

// ListDeployedDevicesCertificate - Retrieve a list of all Certificate credentials belonging to the Fleet.
func (s *SDK) ListDeployedDevicesCertificate(ctx context.Context, request operations.ListDeployedDevicesCertificateRequest, security operations.ListDeployedDevicesCertificateSecurity, opts ...operations.Option) (*operations.ListDeployedDevicesCertificateResponse, error) {
	o := operations.Options{}
	supportedOptions := []string{
		operations.SupportedOptionServerURL,
	}

	for _, opt := range opts {
		if err := opt(&o, supportedOptions...); err != nil {
			return nil, fmt.Errorf("error applying option: %w", err)
		}
	}
	baseURL := operations.ListDeployedDevicesCertificateServerList[0]
	if o.ServerURL != nil {
		baseURL = *o.ServerURL
	}

	url, err := utils.GenerateURL(ctx, baseURL, "/DeployedDevices/Fleets/{FleetSid}/Certificates", request, nil)
	if err != nil {
		return nil, fmt.Errorf("error generating URL: %w", err)
	}

	req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	if err := utils.PopulateQueryParams(ctx, req, request, nil); err != nil {
		return nil, fmt.Errorf("error populating query params: %w", err)
	}

	client := utils.ConfigureSecurityClient(s._defaultClient, security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.ListDeployedDevicesCertificateResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *operations.ListDeployedDevicesCertificateListDeployedDevicesCertificateResponse
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.ListDeployedDevicesCertificateResponse = out
		}
	}

	return res, nil
}

// ListDeployedDevicesDeployment - Retrieve a list of all Deployments belonging to the Fleet.
func (s *SDK) ListDeployedDevicesDeployment(ctx context.Context, request operations.ListDeployedDevicesDeploymentRequest, security operations.ListDeployedDevicesDeploymentSecurity, opts ...operations.Option) (*operations.ListDeployedDevicesDeploymentResponse, error) {
	o := operations.Options{}
	supportedOptions := []string{
		operations.SupportedOptionServerURL,
	}

	for _, opt := range opts {
		if err := opt(&o, supportedOptions...); err != nil {
			return nil, fmt.Errorf("error applying option: %w", err)
		}
	}
	baseURL := operations.ListDeployedDevicesDeploymentServerList[0]
	if o.ServerURL != nil {
		baseURL = *o.ServerURL
	}

	url, err := utils.GenerateURL(ctx, baseURL, "/DeployedDevices/Fleets/{FleetSid}/Deployments", request, nil)
	if err != nil {
		return nil, fmt.Errorf("error generating URL: %w", err)
	}

	req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	if err := utils.PopulateQueryParams(ctx, req, request, nil); err != nil {
		return nil, fmt.Errorf("error populating query params: %w", err)
	}

	client := utils.ConfigureSecurityClient(s._defaultClient, security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.ListDeployedDevicesDeploymentResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *operations.ListDeployedDevicesDeploymentListDeployedDevicesDeploymentResponse
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.ListDeployedDevicesDeploymentResponse = out
		}
	}

	return res, nil
}

// ListDeployedDevicesDevice - Retrieve a list of all Devices belonging to the Fleet.
func (s *SDK) ListDeployedDevicesDevice(ctx context.Context, request operations.ListDeployedDevicesDeviceRequest, security operations.ListDeployedDevicesDeviceSecurity, opts ...operations.Option) (*operations.ListDeployedDevicesDeviceResponse, error) {
	o := operations.Options{}
	supportedOptions := []string{
		operations.SupportedOptionServerURL,
	}

	for _, opt := range opts {
		if err := opt(&o, supportedOptions...); err != nil {
			return nil, fmt.Errorf("error applying option: %w", err)
		}
	}
	baseURL := operations.ListDeployedDevicesDeviceServerList[0]
	if o.ServerURL != nil {
		baseURL = *o.ServerURL
	}

	url, err := utils.GenerateURL(ctx, baseURL, "/DeployedDevices/Fleets/{FleetSid}/Devices", request, nil)
	if err != nil {
		return nil, fmt.Errorf("error generating URL: %w", err)
	}

	req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	if err := utils.PopulateQueryParams(ctx, req, request, nil); err != nil {
		return nil, fmt.Errorf("error populating query params: %w", err)
	}

	client := utils.ConfigureSecurityClient(s._defaultClient, security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.ListDeployedDevicesDeviceResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *operations.ListDeployedDevicesDeviceListDeployedDevicesDeviceResponse
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.ListDeployedDevicesDeviceResponse = out
		}
	}

	return res, nil
}

// ListDeployedDevicesFleet - Retrieve a list of all Fleets belonging to your account.
func (s *SDK) ListDeployedDevicesFleet(ctx context.Context, request operations.ListDeployedDevicesFleetRequest, security operations.ListDeployedDevicesFleetSecurity, opts ...operations.Option) (*operations.ListDeployedDevicesFleetResponse, error) {
	o := operations.Options{}
	supportedOptions := []string{
		operations.SupportedOptionServerURL,
	}

	for _, opt := range opts {
		if err := opt(&o, supportedOptions...); err != nil {
			return nil, fmt.Errorf("error applying option: %w", err)
		}
	}
	baseURL := operations.ListDeployedDevicesFleetServerList[0]
	if o.ServerURL != nil {
		baseURL = *o.ServerURL
	}

	url := strings.TrimSuffix(baseURL, "/") + "/DeployedDevices/Fleets"

	req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	if err := utils.PopulateQueryParams(ctx, req, request, nil); err != nil {
		return nil, fmt.Errorf("error populating query params: %w", err)
	}

	client := utils.ConfigureSecurityClient(s._defaultClient, security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.ListDeployedDevicesFleetResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *operations.ListDeployedDevicesFleetListDeployedDevicesFleetResponse
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.ListDeployedDevicesFleetResponse = out
		}
	}

	return res, nil
}

// ListDeployedDevicesKey - Retrieve a list of all Keys credentials belonging to the Fleet.
func (s *SDK) ListDeployedDevicesKey(ctx context.Context, request operations.ListDeployedDevicesKeyRequest, security operations.ListDeployedDevicesKeySecurity, opts ...operations.Option) (*operations.ListDeployedDevicesKeyResponse, error) {
	o := operations.Options{}
	supportedOptions := []string{
		operations.SupportedOptionServerURL,
	}

	for _, opt := range opts {
		if err := opt(&o, supportedOptions...); err != nil {
			return nil, fmt.Errorf("error applying option: %w", err)
		}
	}
	baseURL := operations.ListDeployedDevicesKeyServerList[0]
	if o.ServerURL != nil {
		baseURL = *o.ServerURL
	}

	url, err := utils.GenerateURL(ctx, baseURL, "/DeployedDevices/Fleets/{FleetSid}/Keys", request, nil)
	if err != nil {
		return nil, fmt.Errorf("error generating URL: %w", err)
	}

	req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	if err := utils.PopulateQueryParams(ctx, req, request, nil); err != nil {
		return nil, fmt.Errorf("error populating query params: %w", err)
	}

	client := utils.ConfigureSecurityClient(s._defaultClient, security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.ListDeployedDevicesKeyResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *operations.ListDeployedDevicesKeyListDeployedDevicesKeyResponse
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.ListDeployedDevicesKeyResponse = out
		}
	}

	return res, nil
}

// ListHostedNumbersAuthorizationDocument - Retrieve a list of AuthorizationDocuments belonging to the account initiating the request.
func (s *SDK) ListHostedNumbersAuthorizationDocument(ctx context.Context, request operations.ListHostedNumbersAuthorizationDocumentRequest, security operations.ListHostedNumbersAuthorizationDocumentSecurity, opts ...operations.Option) (*operations.ListHostedNumbersAuthorizationDocumentResponse, error) {
	o := operations.Options{}
	supportedOptions := []string{
		operations.SupportedOptionServerURL,
	}

	for _, opt := range opts {
		if err := opt(&o, supportedOptions...); err != nil {
			return nil, fmt.Errorf("error applying option: %w", err)
		}
	}
	baseURL := operations.ListHostedNumbersAuthorizationDocumentServerList[0]
	if o.ServerURL != nil {
		baseURL = *o.ServerURL
	}

	url := strings.TrimSuffix(baseURL, "/") + "/HostedNumbers/AuthorizationDocuments"

	req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	if err := utils.PopulateQueryParams(ctx, req, request, nil); err != nil {
		return nil, fmt.Errorf("error populating query params: %w", err)
	}

	client := utils.ConfigureSecurityClient(s._defaultClient, security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.ListHostedNumbersAuthorizationDocumentResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *operations.ListHostedNumbersAuthorizationDocumentListHostedNumbersAuthorizationDocumentResponse
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.ListHostedNumbersAuthorizationDocumentResponse = out
		}
	}

	return res, nil
}

// ListHostedNumbersDependentHostedNumberOrder - Retrieve a list of dependent HostedNumberOrders belonging to the AuthorizationDocument.
func (s *SDK) ListHostedNumbersDependentHostedNumberOrder(ctx context.Context, request operations.ListHostedNumbersDependentHostedNumberOrderRequest, security operations.ListHostedNumbersDependentHostedNumberOrderSecurity, opts ...operations.Option) (*operations.ListHostedNumbersDependentHostedNumberOrderResponse, error) {
	o := operations.Options{}
	supportedOptions := []string{
		operations.SupportedOptionServerURL,
	}

	for _, opt := range opts {
		if err := opt(&o, supportedOptions...); err != nil {
			return nil, fmt.Errorf("error applying option: %w", err)
		}
	}
	baseURL := operations.ListHostedNumbersDependentHostedNumberOrderServerList[0]
	if o.ServerURL != nil {
		baseURL = *o.ServerURL
	}

	url, err := utils.GenerateURL(ctx, baseURL, "/HostedNumbers/AuthorizationDocuments/{SigningDocumentSid}/DependentHostedNumberOrders", request, nil)
	if err != nil {
		return nil, fmt.Errorf("error generating URL: %w", err)
	}

	req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	if err := utils.PopulateQueryParams(ctx, req, request, nil); err != nil {
		return nil, fmt.Errorf("error populating query params: %w", err)
	}

	client := utils.ConfigureSecurityClient(s._defaultClient, security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.ListHostedNumbersDependentHostedNumberOrderResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *operations.ListHostedNumbersDependentHostedNumberOrderListHostedNumbersDependentHostedNumberOrderResponse
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.ListHostedNumbersDependentHostedNumberOrderResponse = out
		}
	}

	return res, nil
}

// ListHostedNumbersHostedNumberOrder - Retrieve a list of HostedNumberOrders belonging to the account initiating the request.
func (s *SDK) ListHostedNumbersHostedNumberOrder(ctx context.Context, request operations.ListHostedNumbersHostedNumberOrderRequest, security operations.ListHostedNumbersHostedNumberOrderSecurity, opts ...operations.Option) (*operations.ListHostedNumbersHostedNumberOrderResponse, error) {
	o := operations.Options{}
	supportedOptions := []string{
		operations.SupportedOptionServerURL,
	}

	for _, opt := range opts {
		if err := opt(&o, supportedOptions...); err != nil {
			return nil, fmt.Errorf("error applying option: %w", err)
		}
	}
	baseURL := operations.ListHostedNumbersHostedNumberOrderServerList[0]
	if o.ServerURL != nil {
		baseURL = *o.ServerURL
	}

	url := strings.TrimSuffix(baseURL, "/") + "/HostedNumbers/HostedNumberOrders"

	req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	if err := utils.PopulateQueryParams(ctx, req, request, nil); err != nil {
		return nil, fmt.Errorf("error populating query params: %w", err)
	}

	client := utils.ConfigureSecurityClient(s._defaultClient, security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.ListHostedNumbersHostedNumberOrderResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *operations.ListHostedNumbersHostedNumberOrderListHostedNumbersHostedNumberOrderResponse
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.ListHostedNumbersHostedNumberOrderResponse = out
		}
	}

	return res, nil
}

// ListMarketplaceAvailableAddOn - Retrieve a list of Add-ons currently available to be installed.
func (s *SDK) ListMarketplaceAvailableAddOn(ctx context.Context, request operations.ListMarketplaceAvailableAddOnRequest, security operations.ListMarketplaceAvailableAddOnSecurity, opts ...operations.Option) (*operations.ListMarketplaceAvailableAddOnResponse, error) {
	o := operations.Options{}
	supportedOptions := []string{
		operations.SupportedOptionServerURL,
	}

	for _, opt := range opts {
		if err := opt(&o, supportedOptions...); err != nil {
			return nil, fmt.Errorf("error applying option: %w", err)
		}
	}
	baseURL := operations.ListMarketplaceAvailableAddOnServerList[0]
	if o.ServerURL != nil {
		baseURL = *o.ServerURL
	}

	url := strings.TrimSuffix(baseURL, "/") + "/marketplace/AvailableAddOns"

	req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	if err := utils.PopulateQueryParams(ctx, req, request, nil); err != nil {
		return nil, fmt.Errorf("error populating query params: %w", err)
	}

	client := utils.ConfigureSecurityClient(s._defaultClient, security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.ListMarketplaceAvailableAddOnResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *operations.ListMarketplaceAvailableAddOnListMarketplaceAvailableAddOnResponse
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.ListMarketplaceAvailableAddOnResponse = out
		}
	}

	return res, nil
}

// ListMarketplaceAvailableAddOnExtension - Retrieve a list of Extensions for the Available Add-on.
func (s *SDK) ListMarketplaceAvailableAddOnExtension(ctx context.Context, request operations.ListMarketplaceAvailableAddOnExtensionRequest, security operations.ListMarketplaceAvailableAddOnExtensionSecurity, opts ...operations.Option) (*operations.ListMarketplaceAvailableAddOnExtensionResponse, error) {
	o := operations.Options{}
	supportedOptions := []string{
		operations.SupportedOptionServerURL,
	}

	for _, opt := range opts {
		if err := opt(&o, supportedOptions...); err != nil {
			return nil, fmt.Errorf("error applying option: %w", err)
		}
	}
	baseURL := operations.ListMarketplaceAvailableAddOnExtensionServerList[0]
	if o.ServerURL != nil {
		baseURL = *o.ServerURL
	}

	url, err := utils.GenerateURL(ctx, baseURL, "/marketplace/AvailableAddOns/{AvailableAddOnSid}/Extensions", request, nil)
	if err != nil {
		return nil, fmt.Errorf("error generating URL: %w", err)
	}

	req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	if err := utils.PopulateQueryParams(ctx, req, request, nil); err != nil {
		return nil, fmt.Errorf("error populating query params: %w", err)
	}

	client := utils.ConfigureSecurityClient(s._defaultClient, security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.ListMarketplaceAvailableAddOnExtensionResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *operations.ListMarketplaceAvailableAddOnExtensionListMarketplaceAvailableAddOnExtensionResponse
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.ListMarketplaceAvailableAddOnExtensionResponse = out
		}
	}

	return res, nil
}

// ListMarketplaceInstalledAddOn - Retrieve a list of Add-ons currently installed on this Account.
func (s *SDK) ListMarketplaceInstalledAddOn(ctx context.Context, request operations.ListMarketplaceInstalledAddOnRequest, security operations.ListMarketplaceInstalledAddOnSecurity, opts ...operations.Option) (*operations.ListMarketplaceInstalledAddOnResponse, error) {
	o := operations.Options{}
	supportedOptions := []string{
		operations.SupportedOptionServerURL,
	}

	for _, opt := range opts {
		if err := opt(&o, supportedOptions...); err != nil {
			return nil, fmt.Errorf("error applying option: %w", err)
		}
	}
	baseURL := operations.ListMarketplaceInstalledAddOnServerList[0]
	if o.ServerURL != nil {
		baseURL = *o.ServerURL
	}

	url := strings.TrimSuffix(baseURL, "/") + "/marketplace/InstalledAddOns"

	req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	if err := utils.PopulateQueryParams(ctx, req, request, nil); err != nil {
		return nil, fmt.Errorf("error populating query params: %w", err)
	}

	client := utils.ConfigureSecurityClient(s._defaultClient, security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.ListMarketplaceInstalledAddOnResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *operations.ListMarketplaceInstalledAddOnListMarketplaceInstalledAddOnResponse
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.ListMarketplaceInstalledAddOnResponse = out
		}
	}

	return res, nil
}

// ListMarketplaceInstalledAddOnExtension - Retrieve a list of Extensions for the Installed Add-on.
func (s *SDK) ListMarketplaceInstalledAddOnExtension(ctx context.Context, request operations.ListMarketplaceInstalledAddOnExtensionRequest, security operations.ListMarketplaceInstalledAddOnExtensionSecurity, opts ...operations.Option) (*operations.ListMarketplaceInstalledAddOnExtensionResponse, error) {
	o := operations.Options{}
	supportedOptions := []string{
		operations.SupportedOptionServerURL,
	}

	for _, opt := range opts {
		if err := opt(&o, supportedOptions...); err != nil {
			return nil, fmt.Errorf("error applying option: %w", err)
		}
	}
	baseURL := operations.ListMarketplaceInstalledAddOnExtensionServerList[0]
	if o.ServerURL != nil {
		baseURL = *o.ServerURL
	}

	url, err := utils.GenerateURL(ctx, baseURL, "/marketplace/InstalledAddOns/{InstalledAddOnSid}/Extensions", request, nil)
	if err != nil {
		return nil, fmt.Errorf("error generating URL: %w", err)
	}

	req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	if err := utils.PopulateQueryParams(ctx, req, request, nil); err != nil {
		return nil, fmt.Errorf("error populating query params: %w", err)
	}

	client := utils.ConfigureSecurityClient(s._defaultClient, security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.ListMarketplaceInstalledAddOnExtensionResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *operations.ListMarketplaceInstalledAddOnExtensionListMarketplaceInstalledAddOnExtensionResponse
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.ListMarketplaceInstalledAddOnExtensionResponse = out
		}
	}

	return res, nil
}

func (s *SDK) ListSyncDocument(ctx context.Context, request operations.ListSyncDocumentRequest, security operations.ListSyncDocumentSecurity, opts ...operations.Option) (*operations.ListSyncDocumentResponse, error) {
	o := operations.Options{}
	supportedOptions := []string{
		operations.SupportedOptionServerURL,
	}

	for _, opt := range opts {
		if err := opt(&o, supportedOptions...); err != nil {
			return nil, fmt.Errorf("error applying option: %w", err)
		}
	}
	baseURL := operations.ListSyncDocumentServerList[0]
	if o.ServerURL != nil {
		baseURL = *o.ServerURL
	}

	url, err := utils.GenerateURL(ctx, baseURL, "/Sync/Services/{ServiceSid}/Documents", request, nil)
	if err != nil {
		return nil, fmt.Errorf("error generating URL: %w", err)
	}

	req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	if err := utils.PopulateQueryParams(ctx, req, request, nil); err != nil {
		return nil, fmt.Errorf("error populating query params: %w", err)
	}

	client := utils.ConfigureSecurityClient(s._defaultClient, security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.ListSyncDocumentResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *operations.ListSyncDocumentListSyncDocumentResponse
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.ListSyncDocumentResponse = out
		}
	}

	return res, nil
}

// ListSyncDocumentPermission - Retrieve a list of all Permissions applying to a Sync Document.
func (s *SDK) ListSyncDocumentPermission(ctx context.Context, request operations.ListSyncDocumentPermissionRequest, security operations.ListSyncDocumentPermissionSecurity, opts ...operations.Option) (*operations.ListSyncDocumentPermissionResponse, error) {
	o := operations.Options{}
	supportedOptions := []string{
		operations.SupportedOptionServerURL,
	}

	for _, opt := range opts {
		if err := opt(&o, supportedOptions...); err != nil {
			return nil, fmt.Errorf("error applying option: %w", err)
		}
	}
	baseURL := operations.ListSyncDocumentPermissionServerList[0]
	if o.ServerURL != nil {
		baseURL = *o.ServerURL
	}

	url, err := utils.GenerateURL(ctx, baseURL, "/Sync/Services/{ServiceSid}/Documents/{DocumentSid}/Permissions", request, nil)
	if err != nil {
		return nil, fmt.Errorf("error generating URL: %w", err)
	}

	req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	if err := utils.PopulateQueryParams(ctx, req, request, nil); err != nil {
		return nil, fmt.Errorf("error populating query params: %w", err)
	}

	client := utils.ConfigureSecurityClient(s._defaultClient, security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.ListSyncDocumentPermissionResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *operations.ListSyncDocumentPermissionListSyncDocumentPermissionResponse
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.ListSyncDocumentPermissionResponse = out
		}
	}

	return res, nil
}

func (s *SDK) ListSyncService(ctx context.Context, request operations.ListSyncServiceRequest, security operations.ListSyncServiceSecurity, opts ...operations.Option) (*operations.ListSyncServiceResponse, error) {
	o := operations.Options{}
	supportedOptions := []string{
		operations.SupportedOptionServerURL,
	}

	for _, opt := range opts {
		if err := opt(&o, supportedOptions...); err != nil {
			return nil, fmt.Errorf("error applying option: %w", err)
		}
	}
	baseURL := operations.ListSyncServiceServerList[0]
	if o.ServerURL != nil {
		baseURL = *o.ServerURL
	}

	url := strings.TrimSuffix(baseURL, "/") + "/Sync/Services"

	req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	if err := utils.PopulateQueryParams(ctx, req, request, nil); err != nil {
		return nil, fmt.Errorf("error populating query params: %w", err)
	}

	client := utils.ConfigureSecurityClient(s._defaultClient, security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.ListSyncServiceResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *operations.ListSyncServiceListSyncServiceResponse
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.ListSyncServiceResponse = out
		}
	}

	return res, nil
}

func (s *SDK) ListSyncSyncList(ctx context.Context, request operations.ListSyncSyncListRequest, security operations.ListSyncSyncListSecurity, opts ...operations.Option) (*operations.ListSyncSyncListResponse, error) {
	o := operations.Options{}
	supportedOptions := []string{
		operations.SupportedOptionServerURL,
	}

	for _, opt := range opts {
		if err := opt(&o, supportedOptions...); err != nil {
			return nil, fmt.Errorf("error applying option: %w", err)
		}
	}
	baseURL := operations.ListSyncSyncListServerList[0]
	if o.ServerURL != nil {
		baseURL = *o.ServerURL
	}

	url, err := utils.GenerateURL(ctx, baseURL, "/Sync/Services/{ServiceSid}/Lists", request, nil)
	if err != nil {
		return nil, fmt.Errorf("error generating URL: %w", err)
	}

	req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	if err := utils.PopulateQueryParams(ctx, req, request, nil); err != nil {
		return nil, fmt.Errorf("error populating query params: %w", err)
	}

	client := utils.ConfigureSecurityClient(s._defaultClient, security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.ListSyncSyncListResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *operations.ListSyncSyncListListSyncSyncListResponse
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.ListSyncSyncListResponse = out
		}
	}

	return res, nil
}

func (s *SDK) ListSyncSyncListItem(ctx context.Context, request operations.ListSyncSyncListItemRequest, security operations.ListSyncSyncListItemSecurity, opts ...operations.Option) (*operations.ListSyncSyncListItemResponse, error) {
	o := operations.Options{}
	supportedOptions := []string{
		operations.SupportedOptionServerURL,
	}

	for _, opt := range opts {
		if err := opt(&o, supportedOptions...); err != nil {
			return nil, fmt.Errorf("error applying option: %w", err)
		}
	}
	baseURL := operations.ListSyncSyncListItemServerList[0]
	if o.ServerURL != nil {
		baseURL = *o.ServerURL
	}

	url, err := utils.GenerateURL(ctx, baseURL, "/Sync/Services/{ServiceSid}/Lists/{ListSid}/Items", request, nil)
	if err != nil {
		return nil, fmt.Errorf("error generating URL: %w", err)
	}

	req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	if err := utils.PopulateQueryParams(ctx, req, request, nil); err != nil {
		return nil, fmt.Errorf("error populating query params: %w", err)
	}

	client := utils.ConfigureSecurityClient(s._defaultClient, security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.ListSyncSyncListItemResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *operations.ListSyncSyncListItemListSyncSyncListItemResponse
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.ListSyncSyncListItemResponse = out
		}
	}

	return res, nil
}

// ListSyncSyncListPermission - Retrieve a list of all Permissions applying to a Sync List.
func (s *SDK) ListSyncSyncListPermission(ctx context.Context, request operations.ListSyncSyncListPermissionRequest, security operations.ListSyncSyncListPermissionSecurity, opts ...operations.Option) (*operations.ListSyncSyncListPermissionResponse, error) {
	o := operations.Options{}
	supportedOptions := []string{
		operations.SupportedOptionServerURL,
	}

	for _, opt := range opts {
		if err := opt(&o, supportedOptions...); err != nil {
			return nil, fmt.Errorf("error applying option: %w", err)
		}
	}
	baseURL := operations.ListSyncSyncListPermissionServerList[0]
	if o.ServerURL != nil {
		baseURL = *o.ServerURL
	}

	url, err := utils.GenerateURL(ctx, baseURL, "/Sync/Services/{ServiceSid}/Lists/{ListSid}/Permissions", request, nil)
	if err != nil {
		return nil, fmt.Errorf("error generating URL: %w", err)
	}

	req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	if err := utils.PopulateQueryParams(ctx, req, request, nil); err != nil {
		return nil, fmt.Errorf("error populating query params: %w", err)
	}

	client := utils.ConfigureSecurityClient(s._defaultClient, security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.ListSyncSyncListPermissionResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *operations.ListSyncSyncListPermissionListSyncSyncListPermissionResponse
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.ListSyncSyncListPermissionResponse = out
		}
	}

	return res, nil
}

func (s *SDK) ListSyncSyncMap(ctx context.Context, request operations.ListSyncSyncMapRequest, security operations.ListSyncSyncMapSecurity, opts ...operations.Option) (*operations.ListSyncSyncMapResponse, error) {
	o := operations.Options{}
	supportedOptions := []string{
		operations.SupportedOptionServerURL,
	}

	for _, opt := range opts {
		if err := opt(&o, supportedOptions...); err != nil {
			return nil, fmt.Errorf("error applying option: %w", err)
		}
	}
	baseURL := operations.ListSyncSyncMapServerList[0]
	if o.ServerURL != nil {
		baseURL = *o.ServerURL
	}

	url, err := utils.GenerateURL(ctx, baseURL, "/Sync/Services/{ServiceSid}/Maps", request, nil)
	if err != nil {
		return nil, fmt.Errorf("error generating URL: %w", err)
	}

	req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	if err := utils.PopulateQueryParams(ctx, req, request, nil); err != nil {
		return nil, fmt.Errorf("error populating query params: %w", err)
	}

	client := utils.ConfigureSecurityClient(s._defaultClient, security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.ListSyncSyncMapResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *operations.ListSyncSyncMapListSyncSyncMapResponse
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.ListSyncSyncMapResponse = out
		}
	}

	return res, nil
}

func (s *SDK) ListSyncSyncMapItem(ctx context.Context, request operations.ListSyncSyncMapItemRequest, security operations.ListSyncSyncMapItemSecurity, opts ...operations.Option) (*operations.ListSyncSyncMapItemResponse, error) {
	o := operations.Options{}
	supportedOptions := []string{
		operations.SupportedOptionServerURL,
	}

	for _, opt := range opts {
		if err := opt(&o, supportedOptions...); err != nil {
			return nil, fmt.Errorf("error applying option: %w", err)
		}
	}
	baseURL := operations.ListSyncSyncMapItemServerList[0]
	if o.ServerURL != nil {
		baseURL = *o.ServerURL
	}

	url, err := utils.GenerateURL(ctx, baseURL, "/Sync/Services/{ServiceSid}/Maps/{MapSid}/Items", request, nil)
	if err != nil {
		return nil, fmt.Errorf("error generating URL: %w", err)
	}

	req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	if err := utils.PopulateQueryParams(ctx, req, request, nil); err != nil {
		return nil, fmt.Errorf("error populating query params: %w", err)
	}

	client := utils.ConfigureSecurityClient(s._defaultClient, security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.ListSyncSyncMapItemResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *operations.ListSyncSyncMapItemListSyncSyncMapItemResponse
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.ListSyncSyncMapItemResponse = out
		}
	}

	return res, nil
}

// ListSyncSyncMapPermission - Retrieve a list of all Permissions applying to a Sync Map.
func (s *SDK) ListSyncSyncMapPermission(ctx context.Context, request operations.ListSyncSyncMapPermissionRequest, security operations.ListSyncSyncMapPermissionSecurity, opts ...operations.Option) (*operations.ListSyncSyncMapPermissionResponse, error) {
	o := operations.Options{}
	supportedOptions := []string{
		operations.SupportedOptionServerURL,
	}

	for _, opt := range opts {
		if err := opt(&o, supportedOptions...); err != nil {
			return nil, fmt.Errorf("error applying option: %w", err)
		}
	}
	baseURL := operations.ListSyncSyncMapPermissionServerList[0]
	if o.ServerURL != nil {
		baseURL = *o.ServerURL
	}

	url, err := utils.GenerateURL(ctx, baseURL, "/Sync/Services/{ServiceSid}/Maps/{MapSid}/Permissions", request, nil)
	if err != nil {
		return nil, fmt.Errorf("error generating URL: %w", err)
	}

	req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	if err := utils.PopulateQueryParams(ctx, req, request, nil); err != nil {
		return nil, fmt.Errorf("error populating query params: %w", err)
	}

	client := utils.ConfigureSecurityClient(s._defaultClient, security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.ListSyncSyncMapPermissionResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *operations.ListSyncSyncMapPermissionListSyncSyncMapPermissionResponse
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.ListSyncSyncMapPermissionResponse = out
		}
	}

	return res, nil
}

func (s *SDK) ListUnderstandAssistant(ctx context.Context, request operations.ListUnderstandAssistantRequest, security operations.ListUnderstandAssistantSecurity, opts ...operations.Option) (*operations.ListUnderstandAssistantResponse, error) {
	o := operations.Options{}
	supportedOptions := []string{
		operations.SupportedOptionServerURL,
	}

	for _, opt := range opts {
		if err := opt(&o, supportedOptions...); err != nil {
			return nil, fmt.Errorf("error applying option: %w", err)
		}
	}
	baseURL := operations.ListUnderstandAssistantServerList[0]
	if o.ServerURL != nil {
		baseURL = *o.ServerURL
	}

	url := strings.TrimSuffix(baseURL, "/") + "/understand/Assistants"

	req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	if err := utils.PopulateQueryParams(ctx, req, request, nil); err != nil {
		return nil, fmt.Errorf("error populating query params: %w", err)
	}

	client := utils.ConfigureSecurityClient(s._defaultClient, security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.ListUnderstandAssistantResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *operations.ListUnderstandAssistantListUnderstandAssistantResponse
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.ListUnderstandAssistantResponse = out
		}
	}

	return res, nil
}

func (s *SDK) ListUnderstandField(ctx context.Context, request operations.ListUnderstandFieldRequest, security operations.ListUnderstandFieldSecurity, opts ...operations.Option) (*operations.ListUnderstandFieldResponse, error) {
	o := operations.Options{}
	supportedOptions := []string{
		operations.SupportedOptionServerURL,
	}

	for _, opt := range opts {
		if err := opt(&o, supportedOptions...); err != nil {
			return nil, fmt.Errorf("error applying option: %w", err)
		}
	}
	baseURL := operations.ListUnderstandFieldServerList[0]
	if o.ServerURL != nil {
		baseURL = *o.ServerURL
	}

	url, err := utils.GenerateURL(ctx, baseURL, "/understand/Assistants/{AssistantSid}/Tasks/{TaskSid}/Fields", request, nil)
	if err != nil {
		return nil, fmt.Errorf("error generating URL: %w", err)
	}

	req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	if err := utils.PopulateQueryParams(ctx, req, request, nil); err != nil {
		return nil, fmt.Errorf("error populating query params: %w", err)
	}

	client := utils.ConfigureSecurityClient(s._defaultClient, security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.ListUnderstandFieldResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *operations.ListUnderstandFieldListUnderstandFieldResponse
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.ListUnderstandFieldResponse = out
		}
	}

	return res, nil
}

func (s *SDK) ListUnderstandFieldType(ctx context.Context, request operations.ListUnderstandFieldTypeRequest, security operations.ListUnderstandFieldTypeSecurity, opts ...operations.Option) (*operations.ListUnderstandFieldTypeResponse, error) {
	o := operations.Options{}
	supportedOptions := []string{
		operations.SupportedOptionServerURL,
	}

	for _, opt := range opts {
		if err := opt(&o, supportedOptions...); err != nil {
			return nil, fmt.Errorf("error applying option: %w", err)
		}
	}
	baseURL := operations.ListUnderstandFieldTypeServerList[0]
	if o.ServerURL != nil {
		baseURL = *o.ServerURL
	}

	url, err := utils.GenerateURL(ctx, baseURL, "/understand/Assistants/{AssistantSid}/FieldTypes", request, nil)
	if err != nil {
		return nil, fmt.Errorf("error generating URL: %w", err)
	}

	req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	if err := utils.PopulateQueryParams(ctx, req, request, nil); err != nil {
		return nil, fmt.Errorf("error populating query params: %w", err)
	}

	client := utils.ConfigureSecurityClient(s._defaultClient, security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.ListUnderstandFieldTypeResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *operations.ListUnderstandFieldTypeListUnderstandFieldTypeResponse
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.ListUnderstandFieldTypeResponse = out
		}
	}

	return res, nil
}

func (s *SDK) ListUnderstandFieldValue(ctx context.Context, request operations.ListUnderstandFieldValueRequest, security operations.ListUnderstandFieldValueSecurity, opts ...operations.Option) (*operations.ListUnderstandFieldValueResponse, error) {
	o := operations.Options{}
	supportedOptions := []string{
		operations.SupportedOptionServerURL,
	}

	for _, opt := range opts {
		if err := opt(&o, supportedOptions...); err != nil {
			return nil, fmt.Errorf("error applying option: %w", err)
		}
	}
	baseURL := operations.ListUnderstandFieldValueServerList[0]
	if o.ServerURL != nil {
		baseURL = *o.ServerURL
	}

	url, err := utils.GenerateURL(ctx, baseURL, "/understand/Assistants/{AssistantSid}/FieldTypes/{FieldTypeSid}/FieldValues", request, nil)
	if err != nil {
		return nil, fmt.Errorf("error generating URL: %w", err)
	}

	req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	if err := utils.PopulateQueryParams(ctx, req, request, nil); err != nil {
		return nil, fmt.Errorf("error populating query params: %w", err)
	}

	client := utils.ConfigureSecurityClient(s._defaultClient, security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.ListUnderstandFieldValueResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *operations.ListUnderstandFieldValueListUnderstandFieldValueResponse
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.ListUnderstandFieldValueResponse = out
		}
	}

	return res, nil
}

func (s *SDK) ListUnderstandModelBuild(ctx context.Context, request operations.ListUnderstandModelBuildRequest, security operations.ListUnderstandModelBuildSecurity, opts ...operations.Option) (*operations.ListUnderstandModelBuildResponse, error) {
	o := operations.Options{}
	supportedOptions := []string{
		operations.SupportedOptionServerURL,
	}

	for _, opt := range opts {
		if err := opt(&o, supportedOptions...); err != nil {
			return nil, fmt.Errorf("error applying option: %w", err)
		}
	}
	baseURL := operations.ListUnderstandModelBuildServerList[0]
	if o.ServerURL != nil {
		baseURL = *o.ServerURL
	}

	url, err := utils.GenerateURL(ctx, baseURL, "/understand/Assistants/{AssistantSid}/ModelBuilds", request, nil)
	if err != nil {
		return nil, fmt.Errorf("error generating URL: %w", err)
	}

	req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	if err := utils.PopulateQueryParams(ctx, req, request, nil); err != nil {
		return nil, fmt.Errorf("error populating query params: %w", err)
	}

	client := utils.ConfigureSecurityClient(s._defaultClient, security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.ListUnderstandModelBuildResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *operations.ListUnderstandModelBuildListUnderstandModelBuildResponse
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.ListUnderstandModelBuildResponse = out
		}
	}

	return res, nil
}

func (s *SDK) ListUnderstandQuery(ctx context.Context, request operations.ListUnderstandQueryRequest, security operations.ListUnderstandQuerySecurity, opts ...operations.Option) (*operations.ListUnderstandQueryResponse, error) {
	o := operations.Options{}
	supportedOptions := []string{
		operations.SupportedOptionServerURL,
	}

	for _, opt := range opts {
		if err := opt(&o, supportedOptions...); err != nil {
			return nil, fmt.Errorf("error applying option: %w", err)
		}
	}
	baseURL := operations.ListUnderstandQueryServerList[0]
	if o.ServerURL != nil {
		baseURL = *o.ServerURL
	}

	url, err := utils.GenerateURL(ctx, baseURL, "/understand/Assistants/{AssistantSid}/Queries", request, nil)
	if err != nil {
		return nil, fmt.Errorf("error generating URL: %w", err)
	}

	req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	if err := utils.PopulateQueryParams(ctx, req, request, nil); err != nil {
		return nil, fmt.Errorf("error populating query params: %w", err)
	}

	client := utils.ConfigureSecurityClient(s._defaultClient, security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.ListUnderstandQueryResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *operations.ListUnderstandQueryListUnderstandQueryResponse
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.ListUnderstandQueryResponse = out
		}
	}

	return res, nil
}

func (s *SDK) ListUnderstandSample(ctx context.Context, request operations.ListUnderstandSampleRequest, security operations.ListUnderstandSampleSecurity, opts ...operations.Option) (*operations.ListUnderstandSampleResponse, error) {
	o := operations.Options{}
	supportedOptions := []string{
		operations.SupportedOptionServerURL,
	}

	for _, opt := range opts {
		if err := opt(&o, supportedOptions...); err != nil {
			return nil, fmt.Errorf("error applying option: %w", err)
		}
	}
	baseURL := operations.ListUnderstandSampleServerList[0]
	if o.ServerURL != nil {
		baseURL = *o.ServerURL
	}

	url, err := utils.GenerateURL(ctx, baseURL, "/understand/Assistants/{AssistantSid}/Tasks/{TaskSid}/Samples", request, nil)
	if err != nil {
		return nil, fmt.Errorf("error generating URL: %w", err)
	}

	req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	if err := utils.PopulateQueryParams(ctx, req, request, nil); err != nil {
		return nil, fmt.Errorf("error populating query params: %w", err)
	}

	client := utils.ConfigureSecurityClient(s._defaultClient, security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.ListUnderstandSampleResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *operations.ListUnderstandSampleListUnderstandSampleResponse
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.ListUnderstandSampleResponse = out
		}
	}

	return res, nil
}

func (s *SDK) ListUnderstandTask(ctx context.Context, request operations.ListUnderstandTaskRequest, security operations.ListUnderstandTaskSecurity, opts ...operations.Option) (*operations.ListUnderstandTaskResponse, error) {
	o := operations.Options{}
	supportedOptions := []string{
		operations.SupportedOptionServerURL,
	}

	for _, opt := range opts {
		if err := opt(&o, supportedOptions...); err != nil {
			return nil, fmt.Errorf("error applying option: %w", err)
		}
	}
	baseURL := operations.ListUnderstandTaskServerList[0]
	if o.ServerURL != nil {
		baseURL = *o.ServerURL
	}

	url, err := utils.GenerateURL(ctx, baseURL, "/understand/Assistants/{AssistantSid}/Tasks", request, nil)
	if err != nil {
		return nil, fmt.Errorf("error generating URL: %w", err)
	}

	req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	if err := utils.PopulateQueryParams(ctx, req, request, nil); err != nil {
		return nil, fmt.Errorf("error populating query params: %w", err)
	}

	client := utils.ConfigureSecurityClient(s._defaultClient, security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.ListUnderstandTaskResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *operations.ListUnderstandTaskListUnderstandTaskResponse
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.ListUnderstandTaskResponse = out
		}
	}

	return res, nil
}

func (s *SDK) ListWirelessCommand(ctx context.Context, request operations.ListWirelessCommandRequest, security operations.ListWirelessCommandSecurity, opts ...operations.Option) (*operations.ListWirelessCommandResponse, error) {
	o := operations.Options{}
	supportedOptions := []string{
		operations.SupportedOptionServerURL,
	}

	for _, opt := range opts {
		if err := opt(&o, supportedOptions...); err != nil {
			return nil, fmt.Errorf("error applying option: %w", err)
		}
	}
	baseURL := operations.ListWirelessCommandServerList[0]
	if o.ServerURL != nil {
		baseURL = *o.ServerURL
	}

	url := strings.TrimSuffix(baseURL, "/") + "/wireless/Commands"

	req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	if err := utils.PopulateQueryParams(ctx, req, request, nil); err != nil {
		return nil, fmt.Errorf("error populating query params: %w", err)
	}

	client := utils.ConfigureSecurityClient(s._defaultClient, security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.ListWirelessCommandResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *operations.ListWirelessCommandListWirelessCommandResponse
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.ListWirelessCommandResponse = out
		}
	}

	return res, nil
}

func (s *SDK) ListWirelessRatePlan(ctx context.Context, request operations.ListWirelessRatePlanRequest, security operations.ListWirelessRatePlanSecurity, opts ...operations.Option) (*operations.ListWirelessRatePlanResponse, error) {
	o := operations.Options{}
	supportedOptions := []string{
		operations.SupportedOptionServerURL,
	}

	for _, opt := range opts {
		if err := opt(&o, supportedOptions...); err != nil {
			return nil, fmt.Errorf("error applying option: %w", err)
		}
	}
	baseURL := operations.ListWirelessRatePlanServerList[0]
	if o.ServerURL != nil {
		baseURL = *o.ServerURL
	}

	url := strings.TrimSuffix(baseURL, "/") + "/wireless/RatePlans"

	req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	if err := utils.PopulateQueryParams(ctx, req, request, nil); err != nil {
		return nil, fmt.Errorf("error populating query params: %w", err)
	}

	client := utils.ConfigureSecurityClient(s._defaultClient, security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.ListWirelessRatePlanResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *operations.ListWirelessRatePlanListWirelessRatePlanResponse
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.ListWirelessRatePlanResponse = out
		}
	}

	return res, nil
}

func (s *SDK) ListWirelessSim(ctx context.Context, request operations.ListWirelessSimRequest, security operations.ListWirelessSimSecurity, opts ...operations.Option) (*operations.ListWirelessSimResponse, error) {
	o := operations.Options{}
	supportedOptions := []string{
		operations.SupportedOptionServerURL,
	}

	for _, opt := range opts {
		if err := opt(&o, supportedOptions...); err != nil {
			return nil, fmt.Errorf("error applying option: %w", err)
		}
	}
	baseURL := operations.ListWirelessSimServerList[0]
	if o.ServerURL != nil {
		baseURL = *o.ServerURL
	}

	url := strings.TrimSuffix(baseURL, "/") + "/wireless/Sims"

	req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	if err := utils.PopulateQueryParams(ctx, req, request, nil); err != nil {
		return nil, fmt.Errorf("error populating query params: %w", err)
	}

	client := utils.ConfigureSecurityClient(s._defaultClient, security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.ListWirelessSimResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *operations.ListWirelessSimListWirelessSimResponse
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.ListWirelessSimResponse = out
		}
	}

	return res, nil
}

// UpdateDeployedDevicesCertificate - Update the given properties of a specific Certificate credential in the Fleet, giving it a friendly name or assigning to a Device.
func (s *SDK) UpdateDeployedDevicesCertificate(ctx context.Context, request operations.UpdateDeployedDevicesCertificateRequest, security operations.UpdateDeployedDevicesCertificateSecurity, opts ...operations.Option) (*operations.UpdateDeployedDevicesCertificateResponse, error) {
	o := operations.Options{}
	supportedOptions := []string{
		operations.SupportedOptionServerURL,
	}

	for _, opt := range opts {
		if err := opt(&o, supportedOptions...); err != nil {
			return nil, fmt.Errorf("error applying option: %w", err)
		}
	}
	baseURL := operations.UpdateDeployedDevicesCertificateServerList[0]
	if o.ServerURL != nil {
		baseURL = *o.ServerURL
	}

	url, err := utils.GenerateURL(ctx, baseURL, "/DeployedDevices/Fleets/{FleetSid}/Certificates/{Sid}", request, nil)
	if err != nil {
		return nil, fmt.Errorf("error generating URL: %w", err)
	}

	bodyReader, reqContentType, err := utils.SerializeRequestBody(ctx, request, "RequestBody", "form")
	if err != nil {
		return nil, fmt.Errorf("error serializing request body: %w", err)
	}

	req, err := http.NewRequestWithContext(ctx, "POST", url, bodyReader)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	req.Header.Set("Content-Type", reqContentType)

	client := utils.ConfigureSecurityClient(s._defaultClient, security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.UpdateDeployedDevicesCertificateResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *shared.PreviewDeployedDevicesFleetCertificate
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.PreviewDeployedDevicesFleetCertificate = out
		}
	}

	return res, nil
}

// UpdateDeployedDevicesDeployment - Update the given properties of a specific Deployment credential in the Fleet, giving it a friendly name or linking to a specific Twilio Sync service instance.
func (s *SDK) UpdateDeployedDevicesDeployment(ctx context.Context, request operations.UpdateDeployedDevicesDeploymentRequest, security operations.UpdateDeployedDevicesDeploymentSecurity, opts ...operations.Option) (*operations.UpdateDeployedDevicesDeploymentResponse, error) {
	o := operations.Options{}
	supportedOptions := []string{
		operations.SupportedOptionServerURL,
	}

	for _, opt := range opts {
		if err := opt(&o, supportedOptions...); err != nil {
			return nil, fmt.Errorf("error applying option: %w", err)
		}
	}
	baseURL := operations.UpdateDeployedDevicesDeploymentServerList[0]
	if o.ServerURL != nil {
		baseURL = *o.ServerURL
	}

	url, err := utils.GenerateURL(ctx, baseURL, "/DeployedDevices/Fleets/{FleetSid}/Deployments/{Sid}", request, nil)
	if err != nil {
		return nil, fmt.Errorf("error generating URL: %w", err)
	}

	bodyReader, reqContentType, err := utils.SerializeRequestBody(ctx, request, "RequestBody", "form")
	if err != nil {
		return nil, fmt.Errorf("error serializing request body: %w", err)
	}

	req, err := http.NewRequestWithContext(ctx, "POST", url, bodyReader)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	req.Header.Set("Content-Type", reqContentType)

	client := utils.ConfigureSecurityClient(s._defaultClient, security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.UpdateDeployedDevicesDeploymentResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *shared.PreviewDeployedDevicesFleetDeployment
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.PreviewDeployedDevicesFleetDeployment = out
		}
	}

	return res, nil
}

// UpdateDeployedDevicesDevice - Update the given properties of a specific Device in the Fleet, giving it a friendly name, assigning to a Deployment, or a human identity.
func (s *SDK) UpdateDeployedDevicesDevice(ctx context.Context, request operations.UpdateDeployedDevicesDeviceRequest, security operations.UpdateDeployedDevicesDeviceSecurity, opts ...operations.Option) (*operations.UpdateDeployedDevicesDeviceResponse, error) {
	o := operations.Options{}
	supportedOptions := []string{
		operations.SupportedOptionServerURL,
	}

	for _, opt := range opts {
		if err := opt(&o, supportedOptions...); err != nil {
			return nil, fmt.Errorf("error applying option: %w", err)
		}
	}
	baseURL := operations.UpdateDeployedDevicesDeviceServerList[0]
	if o.ServerURL != nil {
		baseURL = *o.ServerURL
	}

	url, err := utils.GenerateURL(ctx, baseURL, "/DeployedDevices/Fleets/{FleetSid}/Devices/{Sid}", request, nil)
	if err != nil {
		return nil, fmt.Errorf("error generating URL: %w", err)
	}

	bodyReader, reqContentType, err := utils.SerializeRequestBody(ctx, request, "RequestBody", "form")
	if err != nil {
		return nil, fmt.Errorf("error serializing request body: %w", err)
	}

	req, err := http.NewRequestWithContext(ctx, "POST", url, bodyReader)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	req.Header.Set("Content-Type", reqContentType)

	client := utils.ConfigureSecurityClient(s._defaultClient, security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.UpdateDeployedDevicesDeviceResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *shared.PreviewDeployedDevicesFleetDevice
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.PreviewDeployedDevicesFleetDevice = out
		}
	}

	return res, nil
}

// UpdateDeployedDevicesFleet - Update the friendly name property of a specific Fleet in your account.
func (s *SDK) UpdateDeployedDevicesFleet(ctx context.Context, request operations.UpdateDeployedDevicesFleetRequest, security operations.UpdateDeployedDevicesFleetSecurity, opts ...operations.Option) (*operations.UpdateDeployedDevicesFleetResponse, error) {
	o := operations.Options{}
	supportedOptions := []string{
		operations.SupportedOptionServerURL,
	}

	for _, opt := range opts {
		if err := opt(&o, supportedOptions...); err != nil {
			return nil, fmt.Errorf("error applying option: %w", err)
		}
	}
	baseURL := operations.UpdateDeployedDevicesFleetServerList[0]
	if o.ServerURL != nil {
		baseURL = *o.ServerURL
	}

	url, err := utils.GenerateURL(ctx, baseURL, "/DeployedDevices/Fleets/{Sid}", request, nil)
	if err != nil {
		return nil, fmt.Errorf("error generating URL: %w", err)
	}

	bodyReader, reqContentType, err := utils.SerializeRequestBody(ctx, request, "RequestBody", "form")
	if err != nil {
		return nil, fmt.Errorf("error serializing request body: %w", err)
	}

	req, err := http.NewRequestWithContext(ctx, "POST", url, bodyReader)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	req.Header.Set("Content-Type", reqContentType)

	client := utils.ConfigureSecurityClient(s._defaultClient, security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.UpdateDeployedDevicesFleetResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *shared.PreviewDeployedDevicesFleet
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.PreviewDeployedDevicesFleet = out
		}
	}

	return res, nil
}

// UpdateDeployedDevicesKey - Update the given properties of a specific Key credential in the Fleet, giving it a friendly name or assigning to a Device.
func (s *SDK) UpdateDeployedDevicesKey(ctx context.Context, request operations.UpdateDeployedDevicesKeyRequest, security operations.UpdateDeployedDevicesKeySecurity, opts ...operations.Option) (*operations.UpdateDeployedDevicesKeyResponse, error) {
	o := operations.Options{}
	supportedOptions := []string{
		operations.SupportedOptionServerURL,
	}

	for _, opt := range opts {
		if err := opt(&o, supportedOptions...); err != nil {
			return nil, fmt.Errorf("error applying option: %w", err)
		}
	}
	baseURL := operations.UpdateDeployedDevicesKeyServerList[0]
	if o.ServerURL != nil {
		baseURL = *o.ServerURL
	}

	url, err := utils.GenerateURL(ctx, baseURL, "/DeployedDevices/Fleets/{FleetSid}/Keys/{Sid}", request, nil)
	if err != nil {
		return nil, fmt.Errorf("error generating URL: %w", err)
	}

	bodyReader, reqContentType, err := utils.SerializeRequestBody(ctx, request, "RequestBody", "form")
	if err != nil {
		return nil, fmt.Errorf("error serializing request body: %w", err)
	}

	req, err := http.NewRequestWithContext(ctx, "POST", url, bodyReader)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	req.Header.Set("Content-Type", reqContentType)

	client := utils.ConfigureSecurityClient(s._defaultClient, security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.UpdateDeployedDevicesKeyResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *shared.PreviewDeployedDevicesFleetKey
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.PreviewDeployedDevicesFleetKey = out
		}
	}

	return res, nil
}

// UpdateHostedNumbersAuthorizationDocument - Updates a specific AuthorizationDocument.
func (s *SDK) UpdateHostedNumbersAuthorizationDocument(ctx context.Context, request operations.UpdateHostedNumbersAuthorizationDocumentRequest, security operations.UpdateHostedNumbersAuthorizationDocumentSecurity, opts ...operations.Option) (*operations.UpdateHostedNumbersAuthorizationDocumentResponse, error) {
	o := operations.Options{}
	supportedOptions := []string{
		operations.SupportedOptionServerURL,
	}

	for _, opt := range opts {
		if err := opt(&o, supportedOptions...); err != nil {
			return nil, fmt.Errorf("error applying option: %w", err)
		}
	}
	baseURL := operations.UpdateHostedNumbersAuthorizationDocumentServerList[0]
	if o.ServerURL != nil {
		baseURL = *o.ServerURL
	}

	url, err := utils.GenerateURL(ctx, baseURL, "/HostedNumbers/AuthorizationDocuments/{Sid}", request, nil)
	if err != nil {
		return nil, fmt.Errorf("error generating URL: %w", err)
	}

	bodyReader, reqContentType, err := utils.SerializeRequestBody(ctx, request, "RequestBody", "form")
	if err != nil {
		return nil, fmt.Errorf("error serializing request body: %w", err)
	}

	req, err := http.NewRequestWithContext(ctx, "POST", url, bodyReader)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	req.Header.Set("Content-Type", reqContentType)

	client := utils.ConfigureSecurityClient(s._defaultClient, security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.UpdateHostedNumbersAuthorizationDocumentResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *shared.PreviewHostedNumbersAuthorizationDocument
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.PreviewHostedNumbersAuthorizationDocument = out
		}
	}

	return res, nil
}

// UpdateHostedNumbersHostedNumberOrder - Updates a specific HostedNumberOrder.
func (s *SDK) UpdateHostedNumbersHostedNumberOrder(ctx context.Context, request operations.UpdateHostedNumbersHostedNumberOrderRequest, security operations.UpdateHostedNumbersHostedNumberOrderSecurity, opts ...operations.Option) (*operations.UpdateHostedNumbersHostedNumberOrderResponse, error) {
	o := operations.Options{}
	supportedOptions := []string{
		operations.SupportedOptionServerURL,
	}

	for _, opt := range opts {
		if err := opt(&o, supportedOptions...); err != nil {
			return nil, fmt.Errorf("error applying option: %w", err)
		}
	}
	baseURL := operations.UpdateHostedNumbersHostedNumberOrderServerList[0]
	if o.ServerURL != nil {
		baseURL = *o.ServerURL
	}

	url, err := utils.GenerateURL(ctx, baseURL, "/HostedNumbers/HostedNumberOrders/{Sid}", request, nil)
	if err != nil {
		return nil, fmt.Errorf("error generating URL: %w", err)
	}

	bodyReader, reqContentType, err := utils.SerializeRequestBody(ctx, request, "RequestBody", "form")
	if err != nil {
		return nil, fmt.Errorf("error serializing request body: %w", err)
	}

	req, err := http.NewRequestWithContext(ctx, "POST", url, bodyReader)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	req.Header.Set("Content-Type", reqContentType)

	client := utils.ConfigureSecurityClient(s._defaultClient, security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.UpdateHostedNumbersHostedNumberOrderResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *shared.PreviewHostedNumbersHostedNumberOrder
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.PreviewHostedNumbersHostedNumberOrder = out
		}
	}

	return res, nil
}

// UpdateMarketplaceInstalledAddOn - Update an Add-on installation for the Account specified.
func (s *SDK) UpdateMarketplaceInstalledAddOn(ctx context.Context, request operations.UpdateMarketplaceInstalledAddOnRequest, security operations.UpdateMarketplaceInstalledAddOnSecurity, opts ...operations.Option) (*operations.UpdateMarketplaceInstalledAddOnResponse, error) {
	o := operations.Options{}
	supportedOptions := []string{
		operations.SupportedOptionServerURL,
	}

	for _, opt := range opts {
		if err := opt(&o, supportedOptions...); err != nil {
			return nil, fmt.Errorf("error applying option: %w", err)
		}
	}
	baseURL := operations.UpdateMarketplaceInstalledAddOnServerList[0]
	if o.ServerURL != nil {
		baseURL = *o.ServerURL
	}

	url, err := utils.GenerateURL(ctx, baseURL, "/marketplace/InstalledAddOns/{Sid}", request, nil)
	if err != nil {
		return nil, fmt.Errorf("error generating URL: %w", err)
	}

	bodyReader, reqContentType, err := utils.SerializeRequestBody(ctx, request, "RequestBody", "form")
	if err != nil {
		return nil, fmt.Errorf("error serializing request body: %w", err)
	}

	req, err := http.NewRequestWithContext(ctx, "POST", url, bodyReader)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	req.Header.Set("Content-Type", reqContentType)

	client := utils.ConfigureSecurityClient(s._defaultClient, security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.UpdateMarketplaceInstalledAddOnResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *shared.PreviewMarketplaceInstalledAddOn
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.PreviewMarketplaceInstalledAddOn = out
		}
	}

	return res, nil
}

// UpdateMarketplaceInstalledAddOnExtension - Update an Extension for an Add-on installation.
func (s *SDK) UpdateMarketplaceInstalledAddOnExtension(ctx context.Context, request operations.UpdateMarketplaceInstalledAddOnExtensionRequest, security operations.UpdateMarketplaceInstalledAddOnExtensionSecurity, opts ...operations.Option) (*operations.UpdateMarketplaceInstalledAddOnExtensionResponse, error) {
	o := operations.Options{}
	supportedOptions := []string{
		operations.SupportedOptionServerURL,
	}

	for _, opt := range opts {
		if err := opt(&o, supportedOptions...); err != nil {
			return nil, fmt.Errorf("error applying option: %w", err)
		}
	}
	baseURL := operations.UpdateMarketplaceInstalledAddOnExtensionServerList[0]
	if o.ServerURL != nil {
		baseURL = *o.ServerURL
	}

	url, err := utils.GenerateURL(ctx, baseURL, "/marketplace/InstalledAddOns/{InstalledAddOnSid}/Extensions/{Sid}", request, nil)
	if err != nil {
		return nil, fmt.Errorf("error generating URL: %w", err)
	}

	bodyReader, reqContentType, err := utils.SerializeRequestBody(ctx, request, "RequestBody", "form")
	if err != nil {
		return nil, fmt.Errorf("error serializing request body: %w", err)
	}

	req, err := http.NewRequestWithContext(ctx, "POST", url, bodyReader)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	req.Header.Set("Content-Type", reqContentType)

	client := utils.ConfigureSecurityClient(s._defaultClient, security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.UpdateMarketplaceInstalledAddOnExtensionResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *shared.PreviewMarketplaceInstalledAddOnInstalledAddOnExtension
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.PreviewMarketplaceInstalledAddOnInstalledAddOnExtension = out
		}
	}

	return res, nil
}

func (s *SDK) UpdateSyncDocument(ctx context.Context, request operations.UpdateSyncDocumentRequest, security operations.UpdateSyncDocumentSecurity, opts ...operations.Option) (*operations.UpdateSyncDocumentResponse, error) {
	o := operations.Options{}
	supportedOptions := []string{
		operations.SupportedOptionServerURL,
	}

	for _, opt := range opts {
		if err := opt(&o, supportedOptions...); err != nil {
			return nil, fmt.Errorf("error applying option: %w", err)
		}
	}
	baseURL := operations.UpdateSyncDocumentServerList[0]
	if o.ServerURL != nil {
		baseURL = *o.ServerURL
	}

	url, err := utils.GenerateURL(ctx, baseURL, "/Sync/Services/{ServiceSid}/Documents/{Sid}", request, nil)
	if err != nil {
		return nil, fmt.Errorf("error generating URL: %w", err)
	}

	bodyReader, reqContentType, err := utils.SerializeRequestBody(ctx, request, "RequestBody", "form")
	if err != nil {
		return nil, fmt.Errorf("error serializing request body: %w", err)
	}

	req, err := http.NewRequestWithContext(ctx, "POST", url, bodyReader)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	req.Header.Set("Content-Type", reqContentType)

	utils.PopulateHeaders(ctx, req, request)

	client := utils.ConfigureSecurityClient(s._defaultClient, security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.UpdateSyncDocumentResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *shared.PreviewSyncServiceDocument
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.PreviewSyncServiceDocument = out
		}
	}

	return res, nil
}

// UpdateSyncDocumentPermission - Update an identity's access to a specific Sync Document.
func (s *SDK) UpdateSyncDocumentPermission(ctx context.Context, request operations.UpdateSyncDocumentPermissionRequest, security operations.UpdateSyncDocumentPermissionSecurity, opts ...operations.Option) (*operations.UpdateSyncDocumentPermissionResponse, error) {
	o := operations.Options{}
	supportedOptions := []string{
		operations.SupportedOptionServerURL,
	}

	for _, opt := range opts {
		if err := opt(&o, supportedOptions...); err != nil {
			return nil, fmt.Errorf("error applying option: %w", err)
		}
	}
	baseURL := operations.UpdateSyncDocumentPermissionServerList[0]
	if o.ServerURL != nil {
		baseURL = *o.ServerURL
	}

	url, err := utils.GenerateURL(ctx, baseURL, "/Sync/Services/{ServiceSid}/Documents/{DocumentSid}/Permissions/{Identity}", request, nil)
	if err != nil {
		return nil, fmt.Errorf("error generating URL: %w", err)
	}

	bodyReader, reqContentType, err := utils.SerializeRequestBody(ctx, request, "RequestBody", "form")
	if err != nil {
		return nil, fmt.Errorf("error serializing request body: %w", err)
	}

	req, err := http.NewRequestWithContext(ctx, "POST", url, bodyReader)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	req.Header.Set("Content-Type", reqContentType)

	client := utils.ConfigureSecurityClient(s._defaultClient, security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.UpdateSyncDocumentPermissionResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *shared.PreviewSyncServiceDocumentDocumentPermission
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.PreviewSyncServiceDocumentDocumentPermission = out
		}
	}

	return res, nil
}

func (s *SDK) UpdateSyncService(ctx context.Context, request operations.UpdateSyncServiceRequest, security operations.UpdateSyncServiceSecurity, opts ...operations.Option) (*operations.UpdateSyncServiceResponse, error) {
	o := operations.Options{}
	supportedOptions := []string{
		operations.SupportedOptionServerURL,
	}

	for _, opt := range opts {
		if err := opt(&o, supportedOptions...); err != nil {
			return nil, fmt.Errorf("error applying option: %w", err)
		}
	}
	baseURL := operations.UpdateSyncServiceServerList[0]
	if o.ServerURL != nil {
		baseURL = *o.ServerURL
	}

	url, err := utils.GenerateURL(ctx, baseURL, "/Sync/Services/{Sid}", request, nil)
	if err != nil {
		return nil, fmt.Errorf("error generating URL: %w", err)
	}

	bodyReader, reqContentType, err := utils.SerializeRequestBody(ctx, request, "RequestBody", "form")
	if err != nil {
		return nil, fmt.Errorf("error serializing request body: %w", err)
	}

	req, err := http.NewRequestWithContext(ctx, "POST", url, bodyReader)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	req.Header.Set("Content-Type", reqContentType)

	client := utils.ConfigureSecurityClient(s._defaultClient, security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.UpdateSyncServiceResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *shared.PreviewSyncService
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.PreviewSyncService = out
		}
	}

	return res, nil
}

func (s *SDK) UpdateSyncSyncListItem(ctx context.Context, request operations.UpdateSyncSyncListItemRequest, security operations.UpdateSyncSyncListItemSecurity, opts ...operations.Option) (*operations.UpdateSyncSyncListItemResponse, error) {
	o := operations.Options{}
	supportedOptions := []string{
		operations.SupportedOptionServerURL,
	}

	for _, opt := range opts {
		if err := opt(&o, supportedOptions...); err != nil {
			return nil, fmt.Errorf("error applying option: %w", err)
		}
	}
	baseURL := operations.UpdateSyncSyncListItemServerList[0]
	if o.ServerURL != nil {
		baseURL = *o.ServerURL
	}

	url, err := utils.GenerateURL(ctx, baseURL, "/Sync/Services/{ServiceSid}/Lists/{ListSid}/Items/{Index}", request, nil)
	if err != nil {
		return nil, fmt.Errorf("error generating URL: %w", err)
	}

	bodyReader, reqContentType, err := utils.SerializeRequestBody(ctx, request, "RequestBody", "form")
	if err != nil {
		return nil, fmt.Errorf("error serializing request body: %w", err)
	}

	req, err := http.NewRequestWithContext(ctx, "POST", url, bodyReader)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	req.Header.Set("Content-Type", reqContentType)

	utils.PopulateHeaders(ctx, req, request)

	client := utils.ConfigureSecurityClient(s._defaultClient, security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.UpdateSyncSyncListItemResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *shared.PreviewSyncServiceSyncListSyncListItem
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.PreviewSyncServiceSyncListSyncListItem = out
		}
	}

	return res, nil
}

// UpdateSyncSyncListPermission - Update an identity's access to a specific Sync List.
func (s *SDK) UpdateSyncSyncListPermission(ctx context.Context, request operations.UpdateSyncSyncListPermissionRequest, security operations.UpdateSyncSyncListPermissionSecurity, opts ...operations.Option) (*operations.UpdateSyncSyncListPermissionResponse, error) {
	o := operations.Options{}
	supportedOptions := []string{
		operations.SupportedOptionServerURL,
	}

	for _, opt := range opts {
		if err := opt(&o, supportedOptions...); err != nil {
			return nil, fmt.Errorf("error applying option: %w", err)
		}
	}
	baseURL := operations.UpdateSyncSyncListPermissionServerList[0]
	if o.ServerURL != nil {
		baseURL = *o.ServerURL
	}

	url, err := utils.GenerateURL(ctx, baseURL, "/Sync/Services/{ServiceSid}/Lists/{ListSid}/Permissions/{Identity}", request, nil)
	if err != nil {
		return nil, fmt.Errorf("error generating URL: %w", err)
	}

	bodyReader, reqContentType, err := utils.SerializeRequestBody(ctx, request, "RequestBody", "form")
	if err != nil {
		return nil, fmt.Errorf("error serializing request body: %w", err)
	}

	req, err := http.NewRequestWithContext(ctx, "POST", url, bodyReader)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	req.Header.Set("Content-Type", reqContentType)

	client := utils.ConfigureSecurityClient(s._defaultClient, security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.UpdateSyncSyncListPermissionResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *shared.PreviewSyncServiceSyncListSyncListPermission
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.PreviewSyncServiceSyncListSyncListPermission = out
		}
	}

	return res, nil
}

func (s *SDK) UpdateSyncSyncMapItem(ctx context.Context, request operations.UpdateSyncSyncMapItemRequest, security operations.UpdateSyncSyncMapItemSecurity, opts ...operations.Option) (*operations.UpdateSyncSyncMapItemResponse, error) {
	o := operations.Options{}
	supportedOptions := []string{
		operations.SupportedOptionServerURL,
	}

	for _, opt := range opts {
		if err := opt(&o, supportedOptions...); err != nil {
			return nil, fmt.Errorf("error applying option: %w", err)
		}
	}
	baseURL := operations.UpdateSyncSyncMapItemServerList[0]
	if o.ServerURL != nil {
		baseURL = *o.ServerURL
	}

	url, err := utils.GenerateURL(ctx, baseURL, "/Sync/Services/{ServiceSid}/Maps/{MapSid}/Items/{Key}", request, nil)
	if err != nil {
		return nil, fmt.Errorf("error generating URL: %w", err)
	}

	bodyReader, reqContentType, err := utils.SerializeRequestBody(ctx, request, "RequestBody", "form")
	if err != nil {
		return nil, fmt.Errorf("error serializing request body: %w", err)
	}

	req, err := http.NewRequestWithContext(ctx, "POST", url, bodyReader)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	req.Header.Set("Content-Type", reqContentType)

	utils.PopulateHeaders(ctx, req, request)

	client := utils.ConfigureSecurityClient(s._defaultClient, security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.UpdateSyncSyncMapItemResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *shared.PreviewSyncServiceSyncMapSyncMapItem
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.PreviewSyncServiceSyncMapSyncMapItem = out
		}
	}

	return res, nil
}

// UpdateSyncSyncMapPermission - Update an identity's access to a specific Sync Map.
func (s *SDK) UpdateSyncSyncMapPermission(ctx context.Context, request operations.UpdateSyncSyncMapPermissionRequest, security operations.UpdateSyncSyncMapPermissionSecurity, opts ...operations.Option) (*operations.UpdateSyncSyncMapPermissionResponse, error) {
	o := operations.Options{}
	supportedOptions := []string{
		operations.SupportedOptionServerURL,
	}

	for _, opt := range opts {
		if err := opt(&o, supportedOptions...); err != nil {
			return nil, fmt.Errorf("error applying option: %w", err)
		}
	}
	baseURL := operations.UpdateSyncSyncMapPermissionServerList[0]
	if o.ServerURL != nil {
		baseURL = *o.ServerURL
	}

	url, err := utils.GenerateURL(ctx, baseURL, "/Sync/Services/{ServiceSid}/Maps/{MapSid}/Permissions/{Identity}", request, nil)
	if err != nil {
		return nil, fmt.Errorf("error generating URL: %w", err)
	}

	bodyReader, reqContentType, err := utils.SerializeRequestBody(ctx, request, "RequestBody", "form")
	if err != nil {
		return nil, fmt.Errorf("error serializing request body: %w", err)
	}

	req, err := http.NewRequestWithContext(ctx, "POST", url, bodyReader)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	req.Header.Set("Content-Type", reqContentType)

	client := utils.ConfigureSecurityClient(s._defaultClient, security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.UpdateSyncSyncMapPermissionResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *shared.PreviewSyncServiceSyncMapSyncMapPermission
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.PreviewSyncServiceSyncMapSyncMapPermission = out
		}
	}

	return res, nil
}

func (s *SDK) UpdateUnderstandAssistant(ctx context.Context, request operations.UpdateUnderstandAssistantRequest, security operations.UpdateUnderstandAssistantSecurity, opts ...operations.Option) (*operations.UpdateUnderstandAssistantResponse, error) {
	o := operations.Options{}
	supportedOptions := []string{
		operations.SupportedOptionServerURL,
	}

	for _, opt := range opts {
		if err := opt(&o, supportedOptions...); err != nil {
			return nil, fmt.Errorf("error applying option: %w", err)
		}
	}
	baseURL := operations.UpdateUnderstandAssistantServerList[0]
	if o.ServerURL != nil {
		baseURL = *o.ServerURL
	}

	url, err := utils.GenerateURL(ctx, baseURL, "/understand/Assistants/{Sid}", request, nil)
	if err != nil {
		return nil, fmt.Errorf("error generating URL: %w", err)
	}

	bodyReader, reqContentType, err := utils.SerializeRequestBody(ctx, request, "RequestBody", "form")
	if err != nil {
		return nil, fmt.Errorf("error serializing request body: %w", err)
	}

	req, err := http.NewRequestWithContext(ctx, "POST", url, bodyReader)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	req.Header.Set("Content-Type", reqContentType)

	client := utils.ConfigureSecurityClient(s._defaultClient, security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.UpdateUnderstandAssistantResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *shared.PreviewUnderstandAssistant
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.PreviewUnderstandAssistant = out
		}
	}

	return res, nil
}

func (s *SDK) UpdateUnderstandAssistantFallbackActions(ctx context.Context, request operations.UpdateUnderstandAssistantFallbackActionsRequest, security operations.UpdateUnderstandAssistantFallbackActionsSecurity, opts ...operations.Option) (*operations.UpdateUnderstandAssistantFallbackActionsResponse, error) {
	o := operations.Options{}
	supportedOptions := []string{
		operations.SupportedOptionServerURL,
	}

	for _, opt := range opts {
		if err := opt(&o, supportedOptions...); err != nil {
			return nil, fmt.Errorf("error applying option: %w", err)
		}
	}
	baseURL := operations.UpdateUnderstandAssistantFallbackActionsServerList[0]
	if o.ServerURL != nil {
		baseURL = *o.ServerURL
	}

	url, err := utils.GenerateURL(ctx, baseURL, "/understand/Assistants/{AssistantSid}/FallbackActions", request, nil)
	if err != nil {
		return nil, fmt.Errorf("error generating URL: %w", err)
	}

	bodyReader, reqContentType, err := utils.SerializeRequestBody(ctx, request, "RequestBody", "form")
	if err != nil {
		return nil, fmt.Errorf("error serializing request body: %w", err)
	}

	req, err := http.NewRequestWithContext(ctx, "POST", url, bodyReader)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	req.Header.Set("Content-Type", reqContentType)

	client := utils.ConfigureSecurityClient(s._defaultClient, security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.UpdateUnderstandAssistantFallbackActionsResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *shared.PreviewUnderstandAssistantAssistantFallbackActions
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.PreviewUnderstandAssistantAssistantFallbackActions = out
		}
	}

	return res, nil
}

func (s *SDK) UpdateUnderstandAssistantInitiationActions(ctx context.Context, request operations.UpdateUnderstandAssistantInitiationActionsRequest, security operations.UpdateUnderstandAssistantInitiationActionsSecurity, opts ...operations.Option) (*operations.UpdateUnderstandAssistantInitiationActionsResponse, error) {
	o := operations.Options{}
	supportedOptions := []string{
		operations.SupportedOptionServerURL,
	}

	for _, opt := range opts {
		if err := opt(&o, supportedOptions...); err != nil {
			return nil, fmt.Errorf("error applying option: %w", err)
		}
	}
	baseURL := operations.UpdateUnderstandAssistantInitiationActionsServerList[0]
	if o.ServerURL != nil {
		baseURL = *o.ServerURL
	}

	url, err := utils.GenerateURL(ctx, baseURL, "/understand/Assistants/{AssistantSid}/InitiationActions", request, nil)
	if err != nil {
		return nil, fmt.Errorf("error generating URL: %w", err)
	}

	bodyReader, reqContentType, err := utils.SerializeRequestBody(ctx, request, "RequestBody", "form")
	if err != nil {
		return nil, fmt.Errorf("error serializing request body: %w", err)
	}

	req, err := http.NewRequestWithContext(ctx, "POST", url, bodyReader)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	req.Header.Set("Content-Type", reqContentType)

	client := utils.ConfigureSecurityClient(s._defaultClient, security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.UpdateUnderstandAssistantInitiationActionsResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *shared.PreviewUnderstandAssistantAssistantInitiationActions
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.PreviewUnderstandAssistantAssistantInitiationActions = out
		}
	}

	return res, nil
}

func (s *SDK) UpdateUnderstandFieldType(ctx context.Context, request operations.UpdateUnderstandFieldTypeRequest, security operations.UpdateUnderstandFieldTypeSecurity, opts ...operations.Option) (*operations.UpdateUnderstandFieldTypeResponse, error) {
	o := operations.Options{}
	supportedOptions := []string{
		operations.SupportedOptionServerURL,
	}

	for _, opt := range opts {
		if err := opt(&o, supportedOptions...); err != nil {
			return nil, fmt.Errorf("error applying option: %w", err)
		}
	}
	baseURL := operations.UpdateUnderstandFieldTypeServerList[0]
	if o.ServerURL != nil {
		baseURL = *o.ServerURL
	}

	url, err := utils.GenerateURL(ctx, baseURL, "/understand/Assistants/{AssistantSid}/FieldTypes/{Sid}", request, nil)
	if err != nil {
		return nil, fmt.Errorf("error generating URL: %w", err)
	}

	bodyReader, reqContentType, err := utils.SerializeRequestBody(ctx, request, "RequestBody", "form")
	if err != nil {
		return nil, fmt.Errorf("error serializing request body: %w", err)
	}

	req, err := http.NewRequestWithContext(ctx, "POST", url, bodyReader)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	req.Header.Set("Content-Type", reqContentType)

	client := utils.ConfigureSecurityClient(s._defaultClient, security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.UpdateUnderstandFieldTypeResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *shared.PreviewUnderstandAssistantFieldType
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.PreviewUnderstandAssistantFieldType = out
		}
	}

	return res, nil
}

func (s *SDK) UpdateUnderstandModelBuild(ctx context.Context, request operations.UpdateUnderstandModelBuildRequest, security operations.UpdateUnderstandModelBuildSecurity, opts ...operations.Option) (*operations.UpdateUnderstandModelBuildResponse, error) {
	o := operations.Options{}
	supportedOptions := []string{
		operations.SupportedOptionServerURL,
	}

	for _, opt := range opts {
		if err := opt(&o, supportedOptions...); err != nil {
			return nil, fmt.Errorf("error applying option: %w", err)
		}
	}
	baseURL := operations.UpdateUnderstandModelBuildServerList[0]
	if o.ServerURL != nil {
		baseURL = *o.ServerURL
	}

	url, err := utils.GenerateURL(ctx, baseURL, "/understand/Assistants/{AssistantSid}/ModelBuilds/{Sid}", request, nil)
	if err != nil {
		return nil, fmt.Errorf("error generating URL: %w", err)
	}

	bodyReader, reqContentType, err := utils.SerializeRequestBody(ctx, request, "RequestBody", "form")
	if err != nil {
		return nil, fmt.Errorf("error serializing request body: %w", err)
	}

	req, err := http.NewRequestWithContext(ctx, "POST", url, bodyReader)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	req.Header.Set("Content-Type", reqContentType)

	client := utils.ConfigureSecurityClient(s._defaultClient, security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.UpdateUnderstandModelBuildResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *shared.PreviewUnderstandAssistantModelBuild
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.PreviewUnderstandAssistantModelBuild = out
		}
	}

	return res, nil
}

func (s *SDK) UpdateUnderstandQuery(ctx context.Context, request operations.UpdateUnderstandQueryRequest, security operations.UpdateUnderstandQuerySecurity, opts ...operations.Option) (*operations.UpdateUnderstandQueryResponse, error) {
	o := operations.Options{}
	supportedOptions := []string{
		operations.SupportedOptionServerURL,
	}

	for _, opt := range opts {
		if err := opt(&o, supportedOptions...); err != nil {
			return nil, fmt.Errorf("error applying option: %w", err)
		}
	}
	baseURL := operations.UpdateUnderstandQueryServerList[0]
	if o.ServerURL != nil {
		baseURL = *o.ServerURL
	}

	url, err := utils.GenerateURL(ctx, baseURL, "/understand/Assistants/{AssistantSid}/Queries/{Sid}", request, nil)
	if err != nil {
		return nil, fmt.Errorf("error generating URL: %w", err)
	}

	bodyReader, reqContentType, err := utils.SerializeRequestBody(ctx, request, "RequestBody", "form")
	if err != nil {
		return nil, fmt.Errorf("error serializing request body: %w", err)
	}

	req, err := http.NewRequestWithContext(ctx, "POST", url, bodyReader)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	req.Header.Set("Content-Type", reqContentType)

	client := utils.ConfigureSecurityClient(s._defaultClient, security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.UpdateUnderstandQueryResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *shared.PreviewUnderstandAssistantQuery
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.PreviewUnderstandAssistantQuery = out
		}
	}

	return res, nil
}

func (s *SDK) UpdateUnderstandSample(ctx context.Context, request operations.UpdateUnderstandSampleRequest, security operations.UpdateUnderstandSampleSecurity, opts ...operations.Option) (*operations.UpdateUnderstandSampleResponse, error) {
	o := operations.Options{}
	supportedOptions := []string{
		operations.SupportedOptionServerURL,
	}

	for _, opt := range opts {
		if err := opt(&o, supportedOptions...); err != nil {
			return nil, fmt.Errorf("error applying option: %w", err)
		}
	}
	baseURL := operations.UpdateUnderstandSampleServerList[0]
	if o.ServerURL != nil {
		baseURL = *o.ServerURL
	}

	url, err := utils.GenerateURL(ctx, baseURL, "/understand/Assistants/{AssistantSid}/Tasks/{TaskSid}/Samples/{Sid}", request, nil)
	if err != nil {
		return nil, fmt.Errorf("error generating URL: %w", err)
	}

	bodyReader, reqContentType, err := utils.SerializeRequestBody(ctx, request, "RequestBody", "form")
	if err != nil {
		return nil, fmt.Errorf("error serializing request body: %w", err)
	}

	req, err := http.NewRequestWithContext(ctx, "POST", url, bodyReader)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	req.Header.Set("Content-Type", reqContentType)

	client := utils.ConfigureSecurityClient(s._defaultClient, security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.UpdateUnderstandSampleResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *shared.PreviewUnderstandAssistantTaskSample
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.PreviewUnderstandAssistantTaskSample = out
		}
	}

	return res, nil
}

// UpdateUnderstandStyleSheet - Updates the style sheet for an assistant identified by {AssistantSid} or {AssistantUniqueName}.
func (s *SDK) UpdateUnderstandStyleSheet(ctx context.Context, request operations.UpdateUnderstandStyleSheetRequest, security operations.UpdateUnderstandStyleSheetSecurity, opts ...operations.Option) (*operations.UpdateUnderstandStyleSheetResponse, error) {
	o := operations.Options{}
	supportedOptions := []string{
		operations.SupportedOptionServerURL,
	}

	for _, opt := range opts {
		if err := opt(&o, supportedOptions...); err != nil {
			return nil, fmt.Errorf("error applying option: %w", err)
		}
	}
	baseURL := operations.UpdateUnderstandStyleSheetServerList[0]
	if o.ServerURL != nil {
		baseURL = *o.ServerURL
	}

	url, err := utils.GenerateURL(ctx, baseURL, "/understand/Assistants/{AssistantSid}/StyleSheet", request, nil)
	if err != nil {
		return nil, fmt.Errorf("error generating URL: %w", err)
	}

	bodyReader, reqContentType, err := utils.SerializeRequestBody(ctx, request, "RequestBody", "form")
	if err != nil {
		return nil, fmt.Errorf("error serializing request body: %w", err)
	}

	req, err := http.NewRequestWithContext(ctx, "POST", url, bodyReader)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	req.Header.Set("Content-Type", reqContentType)

	client := utils.ConfigureSecurityClient(s._defaultClient, security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.UpdateUnderstandStyleSheetResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *shared.PreviewUnderstandAssistantStyleSheet
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.PreviewUnderstandAssistantStyleSheet = out
		}
	}

	return res, nil
}

func (s *SDK) UpdateUnderstandTask(ctx context.Context, request operations.UpdateUnderstandTaskRequest, security operations.UpdateUnderstandTaskSecurity, opts ...operations.Option) (*operations.UpdateUnderstandTaskResponse, error) {
	o := operations.Options{}
	supportedOptions := []string{
		operations.SupportedOptionServerURL,
	}

	for _, opt := range opts {
		if err := opt(&o, supportedOptions...); err != nil {
			return nil, fmt.Errorf("error applying option: %w", err)
		}
	}
	baseURL := operations.UpdateUnderstandTaskServerList[0]
	if o.ServerURL != nil {
		baseURL = *o.ServerURL
	}

	url, err := utils.GenerateURL(ctx, baseURL, "/understand/Assistants/{AssistantSid}/Tasks/{Sid}", request, nil)
	if err != nil {
		return nil, fmt.Errorf("error generating URL: %w", err)
	}

	bodyReader, reqContentType, err := utils.SerializeRequestBody(ctx, request, "RequestBody", "form")
	if err != nil {
		return nil, fmt.Errorf("error serializing request body: %w", err)
	}

	req, err := http.NewRequestWithContext(ctx, "POST", url, bodyReader)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	req.Header.Set("Content-Type", reqContentType)

	client := utils.ConfigureSecurityClient(s._defaultClient, security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.UpdateUnderstandTaskResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *shared.PreviewUnderstandAssistantTask
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.PreviewUnderstandAssistantTask = out
		}
	}

	return res, nil
}

// UpdateUnderstandTaskActions - Updates the actions of an Task identified by {TaskSid} or {TaskUniqueName}.
func (s *SDK) UpdateUnderstandTaskActions(ctx context.Context, request operations.UpdateUnderstandTaskActionsRequest, security operations.UpdateUnderstandTaskActionsSecurity, opts ...operations.Option) (*operations.UpdateUnderstandTaskActionsResponse, error) {
	o := operations.Options{}
	supportedOptions := []string{
		operations.SupportedOptionServerURL,
	}

	for _, opt := range opts {
		if err := opt(&o, supportedOptions...); err != nil {
			return nil, fmt.Errorf("error applying option: %w", err)
		}
	}
	baseURL := operations.UpdateUnderstandTaskActionsServerList[0]
	if o.ServerURL != nil {
		baseURL = *o.ServerURL
	}

	url, err := utils.GenerateURL(ctx, baseURL, "/understand/Assistants/{AssistantSid}/Tasks/{TaskSid}/Actions", request, nil)
	if err != nil {
		return nil, fmt.Errorf("error generating URL: %w", err)
	}

	bodyReader, reqContentType, err := utils.SerializeRequestBody(ctx, request, "RequestBody", "form")
	if err != nil {
		return nil, fmt.Errorf("error serializing request body: %w", err)
	}

	req, err := http.NewRequestWithContext(ctx, "POST", url, bodyReader)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	req.Header.Set("Content-Type", reqContentType)

	client := utils.ConfigureSecurityClient(s._defaultClient, security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.UpdateUnderstandTaskActionsResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *shared.PreviewUnderstandAssistantTaskTaskActions
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.PreviewUnderstandAssistantTaskTaskActions = out
		}
	}

	return res, nil
}

func (s *SDK) UpdateWirelessRatePlan(ctx context.Context, request operations.UpdateWirelessRatePlanRequest, security operations.UpdateWirelessRatePlanSecurity, opts ...operations.Option) (*operations.UpdateWirelessRatePlanResponse, error) {
	o := operations.Options{}
	supportedOptions := []string{
		operations.SupportedOptionServerURL,
	}

	for _, opt := range opts {
		if err := opt(&o, supportedOptions...); err != nil {
			return nil, fmt.Errorf("error applying option: %w", err)
		}
	}
	baseURL := operations.UpdateWirelessRatePlanServerList[0]
	if o.ServerURL != nil {
		baseURL = *o.ServerURL
	}

	url, err := utils.GenerateURL(ctx, baseURL, "/wireless/RatePlans/{Sid}", request, nil)
	if err != nil {
		return nil, fmt.Errorf("error generating URL: %w", err)
	}

	bodyReader, reqContentType, err := utils.SerializeRequestBody(ctx, request, "RequestBody", "form")
	if err != nil {
		return nil, fmt.Errorf("error serializing request body: %w", err)
	}

	req, err := http.NewRequestWithContext(ctx, "POST", url, bodyReader)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	req.Header.Set("Content-Type", reqContentType)

	client := utils.ConfigureSecurityClient(s._defaultClient, security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.UpdateWirelessRatePlanResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *shared.PreviewWirelessRatePlan
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.PreviewWirelessRatePlan = out
		}
	}

	return res, nil
}

func (s *SDK) UpdateWirelessSim(ctx context.Context, request operations.UpdateWirelessSimRequest, security operations.UpdateWirelessSimSecurity, opts ...operations.Option) (*operations.UpdateWirelessSimResponse, error) {
	o := operations.Options{}
	supportedOptions := []string{
		operations.SupportedOptionServerURL,
	}

	for _, opt := range opts {
		if err := opt(&o, supportedOptions...); err != nil {
			return nil, fmt.Errorf("error applying option: %w", err)
		}
	}
	baseURL := operations.UpdateWirelessSimServerList[0]
	if o.ServerURL != nil {
		baseURL = *o.ServerURL
	}

	url, err := utils.GenerateURL(ctx, baseURL, "/wireless/Sims/{Sid}", request, nil)
	if err != nil {
		return nil, fmt.Errorf("error generating URL: %w", err)
	}

	bodyReader, reqContentType, err := utils.SerializeRequestBody(ctx, request, "RequestBody", "form")
	if err != nil {
		return nil, fmt.Errorf("error serializing request body: %w", err)
	}

	req, err := http.NewRequestWithContext(ctx, "POST", url, bodyReader)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	req.Header.Set("Content-Type", reqContentType)

	client := utils.ConfigureSecurityClient(s._defaultClient, security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.UpdateWirelessSimResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *shared.PreviewWirelessSim
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.PreviewWirelessSim = out
		}
	}

	return res, nil
}
