/* 
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

package org.openapis.openapi;

import org.openapis.openapi.utils.HTTPClient;
import org.openapis.openapi.utils.SpeakeasyHTTPClient;

/**
 * Code against the Bitbucket API to automate simple tasks, embed Bitbucket data into your own site, build mobile or desktop apps, or even add custom UI add-ons into Bitbucket itself using the Connect framework.
 * https://bitbucket.org/api
 */
public class SDK {
	/**
	 * SERVERS contains the list of server urls available to the SDK.
	 */
	public static final String[] SERVERS = {
        "https://api.bitbucket.org/2.0",
	};
  	
    /**
     * The addon resource is intended to use used by Bitbucket Cloud Connect
     * Apps, and only supports JWT authentication.
     * 
     */
    public Addon addon;
    /**
     * Repository owners and administrators can set branch management
     * rules on a repository that control what can be pushed by whom.
     * Through these rules, you can enforce a project or team
     * workflow. For example, owners or administrators can:
     * 
     * * Limit push powers
     * * Prevent branch deletion
     * * Prevent history re-writes (Git only)
     * 
     */
    public BranchRestrictions branchRestrictions;
    /**
     * The branching model resource is used to modify the branching model
     * for a repository.
     * 
     * You can use the branching model to define a branch based workflow
     * for your repositories. When you map your workflow to branch types,
     * you can ensure that branches are named consistently by configuring
     * which branch types to make available.
     * 
     */
    public BranchingModel branchingModel;
    /**
     * Commit statuses provide a way to tag commits with meta data,
     * like automated build results.
     * 
     */
    public CommitStatuses commitStatuses;
    /**
     * These are the repository's commits. They are paginated and returned in
     * reverse chronological order, similar to the output of git log.
     * 
     */
    public Commits commits;
    /**
     * Teams are deploying code faster than ever, thanks to continuous
     * delivery practices and tools like Bitbucket Pipelines. Bitbucket
     * Deployments gives teams visibility into their deployment
     * environments and helps teams to track how far changes have
     * progressed in their deployment pipeline.
     * 
     */
    public Deployments deployments;
    /**
     * Access the list of download links associated with the repository.
     */
    public Downloads downloads;
    /**
     * The issue resources provide functionality for getting information on
     * issues in an issue tracker, creating new issues, updating them and deleting
     * them.
     * 
     * You can access public issues without authentication, but you can't gain access
     * to private repositories' issues. By authenticating, you will get the ability
     * to create issues, as well as access to updating data or deleting issues you
     * have access to.
     * 
     */
    public IssueTracker issueTracker;
    /**
     * Bitbucket Pipelines brings continuous delivery to Bitbucket
     * Cloud, empowering teams with full branching to deployment
     * visibility and faster feedback loops.
     * 
     */
    public Pipelines pipelines;
    /**
     * Bitbucket Cloud projects make it easier for teams to focus on
     * a goal, product, or process by organizing their repositories.
     * 
     */
    public Projects projects;
    /**
     * Pull requests are a feature that makes it easier for developers
     * to collaborate using Bitbucket. They provide a user-friendly web
     * interface for discussing proposed changes before integrating them
     * into the official project.
     * 
     */
    public Pullrequests pullrequests;
    /**
     * The refs resource allows you access branches and tags in a repository.
     * By default, results will be in the order the underlying source control
     * system returns them and identical to the ordering one sees when running
     * "$ git show-ref". Note that this follows simple lexical ordering of the
     *  ref names.
     * 
     */
    public Refs refs;
    /**
     * Code insights provides reports, annotations, and metrics to help you
     * and your team improve code quality in pull requests throughout the code
     * review process. Some of the available code insights are static analysis
     * reports, security scan results, artifact links, unit tests, and build
     * status.
     * 
     */
    public Reports reports;
    /**
     * A Git repository is a virtual storage of your project. It
     * allows you to save versions of your code, which you can access
     * when needed. The repo resource allows you to access public repos,
     * or repos that belong to a specific workspace.
     * 
     */
    public Repositories repositories;
    public Search search;
    /**
     * Snippets allow you share code segments or files with yourself, members of
     * your workspace, or the world.
     * 
     * Like pull requests, repositories and workspaces, the full set of snippets
     * is defined by what the current user has access to. This includes all
     * snippets owned by any of the workspaces the user is a member of, or
     * snippets by other users that the current user is either watching or has
     *  collaborated on (for instance by commenting on it).
     * 
     */
    public Snippets snippets;
    /**
     * Browse the source code in the repository and
     *                               create new commits by uploading.
     */
    public Source source;
    /**
     * The SSH resource allows you to manage SSH keys.
     * 
     */
    public Ssh ssh;
    /**
     * The users resource allows you to access public information
     * associated with a user account. Most resources in the users
     * endpoint have been deprecated in favor of workspaces.
     * 
     */
    public Users users;
    /**
     * Webhooks provide a way to configure Bitbucket Cloud to make requests to
     * your server (or another external service) whenever certain events occur in
     * Bitbucket Cloud.
     * 
     * A webhook consists of:
     * 
     * * A subject -- The resource that generates the events. Currently, this resource
     * is the repository, user account, or team where you create the webhook.
     * * One or more event -- The default event is a repository push, but you can
     * select multiple events that can trigger the webhook.
     * * A URL -- The endpoint where you want Bitbucket to send the event payloads
     * when a matching event happens.
     * 
     * There are two parts to getting a webhook to work: creating the webhook and
     * triggering the webhook. After you create a webhook for an event, every time
     * that event occurs, Bitbucket sends a payload request that describes the event
     * to the specified URL. Thus, you can think of webhooks as a kind of
     * notification system.
     * 
     * Use webhooks to integrate applications with Bitbucket Cloud. The following
     * use cases provides examples of when you would want to use webhooks:
     * 
     * * Every time a user pushes commits in a repository, you may want to notify
     * your CI server to start a build.
     * * Every time a user pushes commits or creates a pull request, you may want to
     * display a notification in your application.
     * 
     */
    public Webhooks webhooks;
    /**
     * A workspace is where you create repositories, collaborate on
     * your code, and organize different streams of work in your Bitbucket
     * Cloud account. Workspaces replace the use of teams and users in API
     * calls.
     * 
     */
    public Workspaces workspaces;
    public Properties properties;	

	private HTTPClient _defaultClient;
	private HTTPClient _securityClient;
	
	private String _serverUrl;
	private String _language = "java";
	private String _sdkVersion = "0.0.1";
	private String _genVersion = "internal";
	/**
	 * The Builder class allows the configuration of a new instance of the SDK.
	 */
	public static class Builder {
		private HTTPClient client;
		
		private String serverUrl;
		private java.util.Map<String, String> params = new java.util.HashMap<String, String>();

		private Builder() {
		}

		/**
		 * Allows the default HTTP client to be overridden with a custom implementation.
		 * @param client The HTTP client to use for all requests.
		 * @return The builder instance.
		 */
		public Builder setClient(HTTPClient client) {
			this.client = client;
			return this;
		}
		
		/**
		 * Allows the overriding of the default server URL.
		 * @param serverUrl The server URL to use for all requests.
		 * @return The builder instance.
		 */
		public Builder setServerURL(String serverUrl) {
			this.serverUrl = serverUrl;
			return this;
		}
		
		/**
		 * Allows the overriding of the default server URL  with a templated URL populated with the provided parameters.
		 * @param serverUrl The server URL to use for all requests.
		 * @param params The parameters to use when templating the URL.
		 * @return The builder instance.
		 */
		public Builder setServerURL(String serverUrl, java.util.Map<String, String> params) {
			this.serverUrl = serverUrl;
			this.params = params;
			return this;
		}
		
		/**
		 * Builds a new instance of the SDK.
		 * @return The SDK instance.
		 * @throws Exception Thrown if the SDK could not be built.
		 */
		public SDK build() throws Exception {
			return new SDK(this.client, this.serverUrl, this.params);
		}
	}

	/**
	 * Get a new instance of the SDK builder to configure a new instance of the SDK.
	 * @return The SDK builder instance.
	 */
	public static Builder builder() {
		return new Builder();
	}

	private SDK(HTTPClient client, String serverUrl, java.util.Map<String, String> params) throws Exception {
		this._defaultClient = client;
		
		if (this._defaultClient == null) {
			this._defaultClient = new SpeakeasyHTTPClient();
		}
		
		if (this._securityClient == null) {
			this._securityClient = this._defaultClient;
		}

		if (serverUrl != null && !serverUrl.isBlank()) {
			this._serverUrl = org.openapis.openapi.utils.Utils.templateUrl(serverUrl, params);
		}
		
		if (this._serverUrl == null) {
			this._serverUrl = SERVERS[0];
		}

		if (this._serverUrl.endsWith("/")) {
            this._serverUrl = this._serverUrl.substring(0, this._serverUrl.length() - 1);
        }

		
		
		this.addon = new Addon(
			this._defaultClient,
			this._securityClient,
			this._serverUrl,
			this._language,
			this._sdkVersion,
			this._genVersion
		);
		
		this.branchRestrictions = new BranchRestrictions(
			this._defaultClient,
			this._securityClient,
			this._serverUrl,
			this._language,
			this._sdkVersion,
			this._genVersion
		);
		
		this.branchingModel = new BranchingModel(
			this._defaultClient,
			this._securityClient,
			this._serverUrl,
			this._language,
			this._sdkVersion,
			this._genVersion
		);
		
		this.commitStatuses = new CommitStatuses(
			this._defaultClient,
			this._securityClient,
			this._serverUrl,
			this._language,
			this._sdkVersion,
			this._genVersion
		);
		
		this.commits = new Commits(
			this._defaultClient,
			this._securityClient,
			this._serverUrl,
			this._language,
			this._sdkVersion,
			this._genVersion
		);
		
		this.deployments = new Deployments(
			this._defaultClient,
			this._securityClient,
			this._serverUrl,
			this._language,
			this._sdkVersion,
			this._genVersion
		);
		
		this.downloads = new Downloads(
			this._defaultClient,
			this._securityClient,
			this._serverUrl,
			this._language,
			this._sdkVersion,
			this._genVersion
		);
		
		this.issueTracker = new IssueTracker(
			this._defaultClient,
			this._securityClient,
			this._serverUrl,
			this._language,
			this._sdkVersion,
			this._genVersion
		);
		
		this.pipelines = new Pipelines(
			this._defaultClient,
			this._securityClient,
			this._serverUrl,
			this._language,
			this._sdkVersion,
			this._genVersion
		);
		
		this.projects = new Projects(
			this._defaultClient,
			this._securityClient,
			this._serverUrl,
			this._language,
			this._sdkVersion,
			this._genVersion
		);
		
		this.pullrequests = new Pullrequests(
			this._defaultClient,
			this._securityClient,
			this._serverUrl,
			this._language,
			this._sdkVersion,
			this._genVersion
		);
		
		this.refs = new Refs(
			this._defaultClient,
			this._securityClient,
			this._serverUrl,
			this._language,
			this._sdkVersion,
			this._genVersion
		);
		
		this.reports = new Reports(
			this._defaultClient,
			this._securityClient,
			this._serverUrl,
			this._language,
			this._sdkVersion,
			this._genVersion
		);
		
		this.repositories = new Repositories(
			this._defaultClient,
			this._securityClient,
			this._serverUrl,
			this._language,
			this._sdkVersion,
			this._genVersion
		);
		
		this.search = new Search(
			this._defaultClient,
			this._securityClient,
			this._serverUrl,
			this._language,
			this._sdkVersion,
			this._genVersion
		);
		
		this.snippets = new Snippets(
			this._defaultClient,
			this._securityClient,
			this._serverUrl,
			this._language,
			this._sdkVersion,
			this._genVersion
		);
		
		this.source = new Source(
			this._defaultClient,
			this._securityClient,
			this._serverUrl,
			this._language,
			this._sdkVersion,
			this._genVersion
		);
		
		this.ssh = new Ssh(
			this._defaultClient,
			this._securityClient,
			this._serverUrl,
			this._language,
			this._sdkVersion,
			this._genVersion
		);
		
		this.users = new Users(
			this._defaultClient,
			this._securityClient,
			this._serverUrl,
			this._language,
			this._sdkVersion,
			this._genVersion
		);
		
		this.webhooks = new Webhooks(
			this._defaultClient,
			this._securityClient,
			this._serverUrl,
			this._language,
			this._sdkVersion,
			this._genVersion
		);
		
		this.workspaces = new Workspaces(
			this._defaultClient,
			this._securityClient,
			this._serverUrl,
			this._language,
			this._sdkVersion,
			this._genVersion
		);
		
		this.properties = new Properties(
			this._defaultClient,
			this._securityClient,
			this._serverUrl,
			this._language,
			this._sdkVersion,
			this._genVersion
		);
	}
}