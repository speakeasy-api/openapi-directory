// Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.

package operations

import (
	"encoding/json"
	"fmt"
	"net/http"
)

type PostServersCreateServerRequestFirewalls struct {
	// ID of the Firewall
	Firewall *int64 `json:"firewall,omitempty"`
}

// PostServersCreateServerRequestPublicNet - Public Network options
type PostServersCreateServerRequestPublicNet struct {
	// Attach an IPv4 on the public NIC. If false, no IPv4 address will be attached. Defaults to true.
	EnableIpv4 *bool `json:"enable_ipv4,omitempty"`
	// Attach an IPv6 on the public NIC. If false, no IPv6 address will be attached. Defaults to true.
	EnableIpv6 *bool `json:"enable_ipv6,omitempty"`
	// ID of the ipv4 Primary IP to use. If omitted and enable_ipv4 is true, a new ipv4 Primary IP will automatically be created.
	Ipv4 *int64 `json:"ipv4,omitempty"`
	// ID of the ipv6 Primary IP to use. If omitted and enable_ipv6 is true, a new ipv6 Primary IP will automatically be created.
	Ipv6 *int64 `json:"ipv6,omitempty"`
}

// PostServersCreateServerRequest - Please note that Server names must be unique per Project and valid hostnames as per RFC 1123 (i.e. may only contain letters, digits, periods, and dashes).
//
// For `server_type` you can either use the ID as listed in `/server_types` or its name.
//
// For `image` you can either use the ID as listed in `/images` or its name.
//
// If you want to create the Server in a Location, you must set `location` to the ID or name as listed in `/locations`. This is the recommended way. You can be even more specific by setting `datacenter` to the ID or name as listed in `/datacenters`. However we only recommend this if you want to assign a specific Primary IP to the Server which is located in the specified Datacenter.
//
// Some properties like `start_after_create` or `automount` will trigger Actions after the Server is created. Those Actions are listed in the `next_actions` field in the response.
//
// For accessing your Server we strongly recommend to use SSH keys by passing the respective key IDs in `ssh_keys`. If you do not specify any `ssh_keys` we will generate a root password for you and return it in the response.
//
// Please note that provided user-data is stored in our systems. While we take measures to protect it we highly recommend that you don’t use it to store passwords or other sensitive information.
//
// #### Call specific error codes
//
// | Code                             | Description                                                |
// |----------------------------------|------------------------------------------------------------|
// | `placement_error`                | An error during the placement occurred                     |
// | `primary_ip_assigned`            | The specified Primary IP is already assigned to a server   |
// | `primary_ip_datacenter_mismatch` | The specified Primary IP is in a different datacenter      |
// | `primary_ip_version_mismatch`    | The specified Primary IP has the wrong IP Version          |
type PostServersCreateServerRequest struct {
	// Auto-mount Volumes after attach
	Automount *bool `json:"automount,omitempty"`
	// ID or name of Datacenter to create Server in (must not be used together with location)
	Datacenter *string `json:"datacenter,omitempty"`
	// Firewalls which should be applied on the Server's public network interface at creation time
	Firewalls []PostServersCreateServerRequestFirewalls `json:"firewalls,omitempty"`
	// ID or name of the Image the Server is created from
	Image string `json:"image"`
	// User-defined labels (key-value pairs)
	Labels map[string]interface{} `json:"labels,omitempty"`
	// ID or name of Location to create Server in (must not be used together with datacenter)
	Location *string `json:"location,omitempty"`
	// Name of the Server to create (must be unique per Project and a valid hostname as per RFC 1123)
	Name string `json:"name"`
	// Network IDs which should be attached to the Server private network interface at the creation time
	Networks []int64 `json:"networks,omitempty"`
	// ID of the Placement Group the server should be in
	PlacementGroup *int64 `json:"placement_group,omitempty"`
	// Public Network options
	PublicNet *PostServersCreateServerRequestPublicNet `json:"public_net,omitempty"`
	// ID or name of the Server type this Server should be created with
	ServerType string `json:"server_type"`
	// SSH key IDs (`integer`) or names (`string`) which should be injected into the Server at creation time
	SSHKeys []string `json:"ssh_keys,omitempty"`
	// Start Server right after creation. Defaults to true.
	StartAfterCreate *bool `json:"start_after_create,omitempty"`
	// Cloud-Init user data to use during Server creation. This field is limited to 32KiB.
	UserData *string `json:"user_data,omitempty"`
	// Volume IDs which should be attached to the Server at the creation time. Volumes must be in the same Location.
	Volumes []int64 `json:"volumes,omitempty"`
}

type PostServersRequest struct {
	// Please note that Server names must be unique per Project and valid hostnames as per RFC 1123 (i.e. may only contain letters, digits, periods, and dashes).
	//
	// For `server_type` you can either use the ID as listed in `/server_types` or its name.
	//
	// For `image` you can either use the ID as listed in `/images` or its name.
	//
	// If you want to create the Server in a Location, you must set `location` to the ID or name as listed in `/locations`. This is the recommended way. You can be even more specific by setting `datacenter` to the ID or name as listed in `/datacenters`. However we only recommend this if you want to assign a specific Primary IP to the Server which is located in the specified Datacenter.
	//
	// Some properties like `start_after_create` or `automount` will trigger Actions after the Server is created. Those Actions are listed in the `next_actions` field in the response.
	//
	// For accessing your Server we strongly recommend to use SSH keys by passing the respective key IDs in `ssh_keys`. If you do not specify any `ssh_keys` we will generate a root password for you and return it in the response.
	//
	// Please note that provided user-data is stored in our systems. While we take measures to protect it we highly recommend that you don’t use it to store passwords or other sensitive information.
	//
	// #### Call specific error codes
	//
	// | Code                             | Description                                                |
	// |----------------------------------|------------------------------------------------------------|
	// | `placement_error`                | An error during the placement occurred                     |
	// | `primary_ip_assigned`            | The specified Primary IP is already assigned to a server   |
	// | `primary_ip_datacenter_mismatch` | The specified Primary IP is in a different datacenter      |
	// | `primary_ip_version_mismatch`    | The specified Primary IP has the wrong IP Version          |
	//
	Request *PostServersCreateServerRequest `request:"mediaType=application/json"`
}

// PostServersCreateServerResponseActionError - Error message for the Action if error occurred, otherwise null
type PostServersCreateServerResponseActionError struct {
	// Fixed machine readable code
	Code string `json:"code"`
	// Humanized error message
	Message string `json:"message"`
}

type PostServersCreateServerResponseActionResources struct {
	// ID of the Resource
	ID int64 `json:"id"`
	// Type of resource referenced
	Type string `json:"type"`
}

// PostServersCreateServerResponseActionStatusEnum - Status of the Action
type PostServersCreateServerResponseActionStatusEnum string

const (
	PostServersCreateServerResponseActionStatusEnumSuccess PostServersCreateServerResponseActionStatusEnum = "success"
	PostServersCreateServerResponseActionStatusEnumRunning PostServersCreateServerResponseActionStatusEnum = "running"
	PostServersCreateServerResponseActionStatusEnumError   PostServersCreateServerResponseActionStatusEnum = "error"
)

func (e *PostServersCreateServerResponseActionStatusEnum) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return err
	}
	switch s {
	case "success":
		fallthrough
	case "running":
		fallthrough
	case "error":
		*e = PostServersCreateServerResponseActionStatusEnum(s)
		return nil
	default:
		return fmt.Errorf("invalid value for PostServersCreateServerResponseActionStatusEnum: %s", s)
	}
}

type PostServersCreateServerResponseAction struct {
	// Command executed in the Action
	Command string `json:"command"`
	// Error message for the Action if error occurred, otherwise null
	Error PostServersCreateServerResponseActionError `json:"error"`
	// Point in time when the Action was finished (in ISO-8601 format). Only set if the Action is finished otherwise null.
	Finished string `json:"finished"`
	// ID of the Resource
	ID int64 `json:"id"`
	// Progress of Action in percent
	Progress float64 `json:"progress"`
	// Resources the Action relates to
	Resources []PostServersCreateServerResponseActionResources `json:"resources"`
	// Point in time when the Action was started (in ISO-8601 format)
	Started string `json:"started"`
	// Status of the Action
	Status PostServersCreateServerResponseActionStatusEnum `json:"status"`
}

type PostServersCreateServerResponseServerDatacenterLocation struct {
	// City the Location is closest to
	City string `json:"city"`
	// ISO 3166-1 alpha-2 code of the country the Location resides in
	Country string `json:"country"`
	// Description of the Location
	Description string `json:"description"`
	// ID of the Location
	ID float64 `json:"id"`
	// Latitude of the city closest to the Location
	Latitude float64 `json:"latitude"`
	// Longitude of the city closest to the Location
	Longitude float64 `json:"longitude"`
	// Unique identifier of the Location
	Name string `json:"name"`
	// Name of network zone this Location resides in
	NetworkZone string `json:"network_zone"`
}

// PostServersCreateServerResponseServerDatacenterServerTypes - The Server types the Datacenter can handle
type PostServersCreateServerResponseServerDatacenterServerTypes struct {
	// IDs of Server types that are supported and for which the Datacenter has enough resources left
	Available []float64 `json:"available"`
	// IDs of Server types that are supported and for which the Datacenter has enough resources left
	AvailableForMigration []float64 `json:"available_for_migration"`
	// IDs of Server types that are supported in the Datacenter
	Supported []float64 `json:"supported"`
}

// PostServersCreateServerResponseServerDatacenter - Datacenter this Resource is located at
type PostServersCreateServerResponseServerDatacenter struct {
	// Description of the Datacenter
	Description string `json:"description"`
	// ID of the Resource
	ID       int64                                                   `json:"id"`
	Location PostServersCreateServerResponseServerDatacenterLocation `json:"location"`
	// Unique identifier of the Datacenter
	Name string `json:"name"`
	// The Server types the Datacenter can handle
	ServerTypes PostServersCreateServerResponseServerDatacenterServerTypes `json:"server_types"`
}

// PostServersCreateServerResponseServerImageCreatedFrom - Information about the Server the Image was created from
type PostServersCreateServerResponseServerImageCreatedFrom struct {
	// ID of the Server the Image was created from
	ID int64 `json:"id"`
	// Server name at the time the Image was created
	Name string `json:"name"`
}

// PostServersCreateServerResponseServerImageOsFlavorEnum - Flavor of operating system contained in the Image
type PostServersCreateServerResponseServerImageOsFlavorEnum string

const (
	PostServersCreateServerResponseServerImageOsFlavorEnumUbuntu  PostServersCreateServerResponseServerImageOsFlavorEnum = "ubuntu"
	PostServersCreateServerResponseServerImageOsFlavorEnumCentos  PostServersCreateServerResponseServerImageOsFlavorEnum = "centos"
	PostServersCreateServerResponseServerImageOsFlavorEnumDebian  PostServersCreateServerResponseServerImageOsFlavorEnum = "debian"
	PostServersCreateServerResponseServerImageOsFlavorEnumFedora  PostServersCreateServerResponseServerImageOsFlavorEnum = "fedora"
	PostServersCreateServerResponseServerImageOsFlavorEnumUnknown PostServersCreateServerResponseServerImageOsFlavorEnum = "unknown"
)

func (e *PostServersCreateServerResponseServerImageOsFlavorEnum) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return err
	}
	switch s {
	case "ubuntu":
		fallthrough
	case "centos":
		fallthrough
	case "debian":
		fallthrough
	case "fedora":
		fallthrough
	case "unknown":
		*e = PostServersCreateServerResponseServerImageOsFlavorEnum(s)
		return nil
	default:
		return fmt.Errorf("invalid value for PostServersCreateServerResponseServerImageOsFlavorEnum: %s", s)
	}
}

// PostServersCreateServerResponseServerImageProtection - Protection configuration for the Resource
type PostServersCreateServerResponseServerImageProtection struct {
	// If true, prevents the Resource from being deleted
	Delete bool `json:"delete"`
}

// PostServersCreateServerResponseServerImageStatusEnum - Whether the Image can be used or if it's still being created or unavailable
type PostServersCreateServerResponseServerImageStatusEnum string

const (
	PostServersCreateServerResponseServerImageStatusEnumAvailable   PostServersCreateServerResponseServerImageStatusEnum = "available"
	PostServersCreateServerResponseServerImageStatusEnumCreating    PostServersCreateServerResponseServerImageStatusEnum = "creating"
	PostServersCreateServerResponseServerImageStatusEnumUnavailable PostServersCreateServerResponseServerImageStatusEnum = "unavailable"
)

func (e *PostServersCreateServerResponseServerImageStatusEnum) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return err
	}
	switch s {
	case "available":
		fallthrough
	case "creating":
		fallthrough
	case "unavailable":
		*e = PostServersCreateServerResponseServerImageStatusEnum(s)
		return nil
	default:
		return fmt.Errorf("invalid value for PostServersCreateServerResponseServerImageStatusEnum: %s", s)
	}
}

// PostServersCreateServerResponseServerImageTypeEnum - Type of the Image
type PostServersCreateServerResponseServerImageTypeEnum string

const (
	PostServersCreateServerResponseServerImageTypeEnumSystem    PostServersCreateServerResponseServerImageTypeEnum = "system"
	PostServersCreateServerResponseServerImageTypeEnumApp       PostServersCreateServerResponseServerImageTypeEnum = "app"
	PostServersCreateServerResponseServerImageTypeEnumSnapshot  PostServersCreateServerResponseServerImageTypeEnum = "snapshot"
	PostServersCreateServerResponseServerImageTypeEnumBackup    PostServersCreateServerResponseServerImageTypeEnum = "backup"
	PostServersCreateServerResponseServerImageTypeEnumTemporary PostServersCreateServerResponseServerImageTypeEnum = "temporary"
)

func (e *PostServersCreateServerResponseServerImageTypeEnum) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return err
	}
	switch s {
	case "system":
		fallthrough
	case "app":
		fallthrough
	case "snapshot":
		fallthrough
	case "backup":
		fallthrough
	case "temporary":
		*e = PostServersCreateServerResponseServerImageTypeEnum(s)
		return nil
	default:
		return fmt.Errorf("invalid value for PostServersCreateServerResponseServerImageTypeEnum: %s", s)
	}
}

type PostServersCreateServerResponseServerImage struct {
	// ID of Server the Image is bound to. Only set for Images of type `backup`.
	BoundTo int64 `json:"bound_to"`
	// Point in time when the Resource was created (in ISO-8601 format)
	Created string `json:"created"`
	// Information about the Server the Image was created from
	CreatedFrom PostServersCreateServerResponseServerImageCreatedFrom `json:"created_from"`
	// Point in time where the Image was deleted (in ISO-8601 format)
	Deleted string `json:"deleted"`
	// Point in time when the Image is considered to be deprecated (in ISO-8601 format)
	Deprecated string `json:"deprecated"`
	// Description of the Image
	Description string `json:"description"`
	// Size of the disk contained in the Image in GB
	DiskSize float64 `json:"disk_size"`
	// ID of the Resource
	ID int64 `json:"id"`
	// Size of the Image file in our storage in GB. For snapshot Images this is the value relevant for calculating costs for the Image.
	ImageSize float64 `json:"image_size"`
	// User-defined labels (key-value pairs)
	Labels map[string]string `json:"labels"`
	// Unique identifier of the Image. This value is only set for system Images.
	Name string `json:"name"`
	// Flavor of operating system contained in the Image
	OsFlavor PostServersCreateServerResponseServerImageOsFlavorEnum `json:"os_flavor"`
	// Operating system version
	OsVersion string `json:"os_version"`
	// Protection configuration for the Resource
	Protection PostServersCreateServerResponseServerImageProtection `json:"protection"`
	// Indicates that rapid deploy of the Image is available
	RapidDeploy *bool `json:"rapid_deploy,omitempty"`
	// Whether the Image can be used or if it's still being created or unavailable
	Status PostServersCreateServerResponseServerImageStatusEnum `json:"status"`
	// Type of the Image
	Type PostServersCreateServerResponseServerImageTypeEnum `json:"type"`
}

// PostServersCreateServerResponseServerIsoTypeEnum - Type of the ISO
type PostServersCreateServerResponseServerIsoTypeEnum string

const (
	PostServersCreateServerResponseServerIsoTypeEnumPublic  PostServersCreateServerResponseServerIsoTypeEnum = "public"
	PostServersCreateServerResponseServerIsoTypeEnumPrivate PostServersCreateServerResponseServerIsoTypeEnum = "private"
)

func (e *PostServersCreateServerResponseServerIsoTypeEnum) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return err
	}
	switch s {
	case "public":
		fallthrough
	case "private":
		*e = PostServersCreateServerResponseServerIsoTypeEnum(s)
		return nil
	default:
		return fmt.Errorf("invalid value for PostServersCreateServerResponseServerIsoTypeEnum: %s", s)
	}
}

// PostServersCreateServerResponseServerIso - ISO Image that is attached to this Server. Null if no ISO is attached.
type PostServersCreateServerResponseServerIso struct {
	// ISO 8601 timestamp of deprecation, null if ISO is still available. After the deprecation time it will no longer be possible to attach the ISO to Servers.
	Deprecated string `json:"deprecated"`
	// Description of the ISO
	Description string `json:"description"`
	// ID of the Resource
	ID int64 `json:"id"`
	// Unique identifier of the ISO. Only set for public ISOs
	Name string `json:"name"`
	// Type of the ISO
	Type PostServersCreateServerResponseServerIsoTypeEnum `json:"type"`
}

// PostServersCreateServerResponseServerPlacementGroupNullableTypeEnum - Type of the Placement Group
type PostServersCreateServerResponseServerPlacementGroupNullableTypeEnum string

const (
	PostServersCreateServerResponseServerPlacementGroupNullableTypeEnumSpread PostServersCreateServerResponseServerPlacementGroupNullableTypeEnum = "spread"
)

func (e *PostServersCreateServerResponseServerPlacementGroupNullableTypeEnum) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return err
	}
	switch s {
	case "spread":
		*e = PostServersCreateServerResponseServerPlacementGroupNullableTypeEnum(s)
		return nil
	default:
		return fmt.Errorf("invalid value for PostServersCreateServerResponseServerPlacementGroupNullableTypeEnum: %s", s)
	}
}

type PostServersCreateServerResponseServerPlacementGroupNullable struct {
	// Point in time when the Resource was created (in ISO-8601 format)
	Created string `json:"created"`
	// ID of the Resource
	ID int64 `json:"id"`
	// User-defined labels (key-value pairs)
	Labels map[string]string `json:"labels"`
	// Name of the Resource. Must be unique per Project.
	Name string `json:"name"`
	// Array of IDs of Servers that are part of this Placement Group
	Servers []int64 `json:"servers"`
	// Type of the Placement Group
	Type PostServersCreateServerResponseServerPlacementGroupNullableTypeEnum `json:"type"`
}

type PostServersCreateServerResponseServerPrivateNet struct {
	AliasIps   []string `json:"alias_ips,omitempty"`
	IP         *string  `json:"ip,omitempty"`
	MacAddress *string  `json:"mac_address,omitempty"`
	Network    *int64   `json:"network,omitempty"`
}

// PostServersCreateServerResponseServerProtection - Protection configuration for the Server
type PostServersCreateServerResponseServerProtection struct {
	// If true, prevents the Server from being deleted
	Delete bool `json:"delete"`
	// If true, prevents the Server from being rebuilt
	Rebuild bool `json:"rebuild"`
}

// PostServersCreateServerResponseServerPublicNetServerPublicNetFirewallStatusEnum - Status of the Firewall on the Server
type PostServersCreateServerResponseServerPublicNetServerPublicNetFirewallStatusEnum string

const (
	PostServersCreateServerResponseServerPublicNetServerPublicNetFirewallStatusEnumApplied PostServersCreateServerResponseServerPublicNetServerPublicNetFirewallStatusEnum = "applied"
	PostServersCreateServerResponseServerPublicNetServerPublicNetFirewallStatusEnumPending PostServersCreateServerResponseServerPublicNetServerPublicNetFirewallStatusEnum = "pending"
)

func (e *PostServersCreateServerResponseServerPublicNetServerPublicNetFirewallStatusEnum) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return err
	}
	switch s {
	case "applied":
		fallthrough
	case "pending":
		*e = PostServersCreateServerResponseServerPublicNetServerPublicNetFirewallStatusEnum(s)
		return nil
	default:
		return fmt.Errorf("invalid value for PostServersCreateServerResponseServerPublicNetServerPublicNetFirewallStatusEnum: %s", s)
	}
}

type PostServersCreateServerResponseServerPublicNetServerPublicNetFirewall struct {
	// ID of the Resource
	ID *int64 `json:"id,omitempty"`
	// Status of the Firewall on the Server
	Status *PostServersCreateServerResponseServerPublicNetServerPublicNetFirewallStatusEnum `json:"status,omitempty"`
}

// PostServersCreateServerResponseServerPublicNetIpv4 - IP address (v4) and its reverse DNS entry of this Server
type PostServersCreateServerResponseServerPublicNetIpv4 struct {
	// If the IP is blocked by our anti abuse dept
	Blocked bool `json:"blocked"`
	// Reverse DNS PTR entry for the IPv4 addresses of this Server
	DNSPtr string `json:"dns_ptr"`
	// ID of the Resource
	ID *int64 `json:"id,omitempty"`
	// IP address (v4) of this Server
	IP string `json:"ip"`
}

type PostServersCreateServerResponseServerPublicNetIpv6DNSPtr struct {
	// DNS pointer for the specific IP address
	DNSPtr string `json:"dns_ptr"`
	// Single IPv6 address of this Server for which the reverse DNS entry has been set up
	IP string `json:"ip"`
}

// PostServersCreateServerResponseServerPublicNetIpv6 - IPv6 network assigned to this Server and its reverse DNS entry
type PostServersCreateServerResponseServerPublicNetIpv6 struct {
	// If the IP is blocked by our anti abuse dept
	Blocked bool `json:"blocked"`
	// Reverse DNS PTR entries for the IPv6 addresses of this Server, `null` by default
	DNSPtr []PostServersCreateServerResponseServerPublicNetIpv6DNSPtr `json:"dns_ptr"`
	// ID of the Resource
	ID *int64 `json:"id,omitempty"`
	// IP address (v6) of this Server
	IP string `json:"ip"`
}

// PostServersCreateServerResponseServerPublicNet - Public network information. The Server's IPv4 address can be found in `public_net->ipv4->ip`
type PostServersCreateServerResponseServerPublicNet struct {
	// Firewalls applied to the public network interface of this Server
	Firewalls []PostServersCreateServerResponseServerPublicNetServerPublicNetFirewall `json:"firewalls,omitempty"`
	// IDs of Floating IPs assigned to this Server
	FloatingIps []int64 `json:"floating_ips"`
	// IP address (v4) and its reverse DNS entry of this Server
	Ipv4 PostServersCreateServerResponseServerPublicNetIpv4 `json:"ipv4"`
	// IPv6 network assigned to this Server and its reverse DNS entry
	Ipv6 PostServersCreateServerResponseServerPublicNetIpv6 `json:"ipv6"`
}

// PostServersCreateServerResponseServerServerTypeCPUTypeEnum - Type of cpu
type PostServersCreateServerResponseServerServerTypeCPUTypeEnum string

const (
	PostServersCreateServerResponseServerServerTypeCPUTypeEnumShared    PostServersCreateServerResponseServerServerTypeCPUTypeEnum = "shared"
	PostServersCreateServerResponseServerServerTypeCPUTypeEnumDedicated PostServersCreateServerResponseServerServerTypeCPUTypeEnum = "dedicated"
)

func (e *PostServersCreateServerResponseServerServerTypeCPUTypeEnum) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return err
	}
	switch s {
	case "shared":
		fallthrough
	case "dedicated":
		*e = PostServersCreateServerResponseServerServerTypeCPUTypeEnum(s)
		return nil
	default:
		return fmt.Errorf("invalid value for PostServersCreateServerResponseServerServerTypeCPUTypeEnum: %s", s)
	}
}

// PostServersCreateServerResponseServerServerTypePricesPriceHourly - Hourly costs for a Server type in this Location
type PostServersCreateServerResponseServerServerTypePricesPriceHourly struct {
	// Price with VAT added
	Gross string `json:"gross"`
	// Price without VAT
	Net string `json:"net"`
}

// PostServersCreateServerResponseServerServerTypePricesPriceMonthly - Monthly costs for a Server type in this Location
type PostServersCreateServerResponseServerServerTypePricesPriceMonthly struct {
	// Price with VAT added
	Gross string `json:"gross"`
	// Price without VAT
	Net string `json:"net"`
}

type PostServersCreateServerResponseServerServerTypePrices struct {
	// Name of the Location the price is for
	Location string `json:"location"`
	// Hourly costs for a Server type in this Location
	PriceHourly PostServersCreateServerResponseServerServerTypePricesPriceHourly `json:"price_hourly"`
	// Monthly costs for a Server type in this Location
	PriceMonthly PostServersCreateServerResponseServerServerTypePricesPriceMonthly `json:"price_monthly"`
}

// PostServersCreateServerResponseServerServerTypeStorageTypeEnum - Type of Server boot drive. Local has higher speed. Network has better availability.
type PostServersCreateServerResponseServerServerTypeStorageTypeEnum string

const (
	PostServersCreateServerResponseServerServerTypeStorageTypeEnumLocal   PostServersCreateServerResponseServerServerTypeStorageTypeEnum = "local"
	PostServersCreateServerResponseServerServerTypeStorageTypeEnumNetwork PostServersCreateServerResponseServerServerTypeStorageTypeEnum = "network"
)

func (e *PostServersCreateServerResponseServerServerTypeStorageTypeEnum) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return err
	}
	switch s {
	case "local":
		fallthrough
	case "network":
		*e = PostServersCreateServerResponseServerServerTypeStorageTypeEnum(s)
		return nil
	default:
		return fmt.Errorf("invalid value for PostServersCreateServerResponseServerServerTypeStorageTypeEnum: %s", s)
	}
}

// PostServersCreateServerResponseServerServerType - Type of Server - determines how much ram, disk and cpu a Server has
type PostServersCreateServerResponseServerServerType struct {
	// Number of cpu cores a Server of this type will have
	Cores float64 `json:"cores"`
	// Type of cpu
	CPUType PostServersCreateServerResponseServerServerTypeCPUTypeEnum `json:"cpu_type"`
	// True if Server type is deprecated
	Deprecated bool `json:"deprecated"`
	// Description of the Server type
	Description string `json:"description"`
	// Disk size a Server of this type will have in GB
	Disk float64 `json:"disk"`
	// ID of the Server type
	ID int64 `json:"id"`
	// Memory a Server of this type will have in GB
	Memory float64 `json:"memory"`
	// Unique identifier of the Server type
	Name string `json:"name"`
	// Prices in different Locations
	Prices []PostServersCreateServerResponseServerServerTypePrices `json:"prices"`
	// Type of Server boot drive. Local has higher speed. Network has better availability.
	StorageType PostServersCreateServerResponseServerServerTypeStorageTypeEnum `json:"storage_type"`
}

// PostServersCreateServerResponseServerStatusEnum - Status of the Server
type PostServersCreateServerResponseServerStatusEnum string

const (
	PostServersCreateServerResponseServerStatusEnumRunning      PostServersCreateServerResponseServerStatusEnum = "running"
	PostServersCreateServerResponseServerStatusEnumInitializing PostServersCreateServerResponseServerStatusEnum = "initializing"
	PostServersCreateServerResponseServerStatusEnumStarting     PostServersCreateServerResponseServerStatusEnum = "starting"
	PostServersCreateServerResponseServerStatusEnumStopping     PostServersCreateServerResponseServerStatusEnum = "stopping"
	PostServersCreateServerResponseServerStatusEnumOff          PostServersCreateServerResponseServerStatusEnum = "off"
	PostServersCreateServerResponseServerStatusEnumDeleting     PostServersCreateServerResponseServerStatusEnum = "deleting"
	PostServersCreateServerResponseServerStatusEnumMigrating    PostServersCreateServerResponseServerStatusEnum = "migrating"
	PostServersCreateServerResponseServerStatusEnumRebuilding   PostServersCreateServerResponseServerStatusEnum = "rebuilding"
	PostServersCreateServerResponseServerStatusEnumUnknown      PostServersCreateServerResponseServerStatusEnum = "unknown"
)

func (e *PostServersCreateServerResponseServerStatusEnum) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return err
	}
	switch s {
	case "running":
		fallthrough
	case "initializing":
		fallthrough
	case "starting":
		fallthrough
	case "stopping":
		fallthrough
	case "off":
		fallthrough
	case "deleting":
		fallthrough
	case "migrating":
		fallthrough
	case "rebuilding":
		fallthrough
	case "unknown":
		*e = PostServersCreateServerResponseServerStatusEnum(s)
		return nil
	default:
		return fmt.Errorf("invalid value for PostServersCreateServerResponseServerStatusEnum: %s", s)
	}
}

type PostServersCreateServerResponseServer struct {
	// Time window (UTC) in which the backup will run, or null if the backups are not enabled
	BackupWindow string `json:"backup_window"`
	// Point in time when the Resource was created (in ISO-8601 format)
	Created string `json:"created"`
	// Datacenter this Resource is located at
	Datacenter PostServersCreateServerResponseServerDatacenter `json:"datacenter"`
	// ID of the Resource
	ID    int64                                      `json:"id"`
	Image PostServersCreateServerResponseServerImage `json:"image"`
	// Free Traffic for the current billing period in bytes
	IncludedTraffic float64 `json:"included_traffic"`
	// Inbound Traffic for the current billing period in bytes
	IngoingTraffic float64 `json:"ingoing_traffic"`
	// ISO Image that is attached to this Server. Null if no ISO is attached.
	Iso PostServersCreateServerResponseServerIso `json:"iso"`
	// User-defined labels (key-value pairs)
	Labels        map[string]string `json:"labels"`
	LoadBalancers []int64           `json:"load_balancers,omitempty"`
	// True if Server has been locked and is not available to user
	Locked bool `json:"locked"`
	// Name of the Server (must be unique per Project and a valid hostname as per RFC 1123)
	Name string `json:"name"`
	// Outbound Traffic for the current billing period in bytes
	OutgoingTraffic float64                                                      `json:"outgoing_traffic"`
	PlacementGroup  *PostServersCreateServerResponseServerPlacementGroupNullable `json:"placement_group,omitempty"`
	// Size of the primary Disk
	PrimaryDiskSize float64 `json:"primary_disk_size"`
	// Private networks information
	PrivateNet []PostServersCreateServerResponseServerPrivateNet `json:"private_net"`
	// Protection configuration for the Server
	Protection PostServersCreateServerResponseServerProtection `json:"protection"`
	// Public network information. The Server's IPv4 address can be found in `public_net->ipv4->ip`
	PublicNet PostServersCreateServerResponseServerPublicNet `json:"public_net"`
	// True if rescue mode is enabled. Server will then boot into rescue system on next reboot
	RescueEnabled bool `json:"rescue_enabled"`
	// Type of Server - determines how much ram, disk and cpu a Server has
	ServerType PostServersCreateServerResponseServerServerType `json:"server_type"`
	// Status of the Server
	Status PostServersCreateServerResponseServerStatusEnum `json:"status"`
	// IDs of Volumes assigned to this Server
	Volumes []int64 `json:"volumes,omitempty"`
}

// PostServersCreateServerResponse - The `server` key in the reply contains a Server object with this structure
type PostServersCreateServerResponse struct {
	Action      PostServersCreateServerResponseAction   `json:"action"`
	NextActions []PostServersCreateServerResponseAction `json:"next_actions"`
	// Root password when no SSH keys have been specified
	RootPassword string                                `json:"root_password"`
	Server       PostServersCreateServerResponseServer `json:"server"`
}

type PostServersResponse struct {
	ContentType string
	// The `server` key in the reply contains a Server object with this structure
	CreateServerResponse *PostServersCreateServerResponse
	StatusCode           int
	RawResponse          *http.Response
}
