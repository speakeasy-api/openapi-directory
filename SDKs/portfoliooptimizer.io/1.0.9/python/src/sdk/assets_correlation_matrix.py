"""Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT."""

import requests as requests_http
from . import utils
from sdk.models import operations
from typing import Any, Optional

class AssetsCorrelationMatrix:
    _client: requests_http.Session
    _security_client: requests_http.Session
    _server_url: str
    _language: str
    _sdk_version: str
    _gen_version: str

    def __init__(self, client: requests_http.Session, security_client: requests_http.Session, server_url: str, language: str, sdk_version: str, gen_version: str) -> None:
        self._client = client
        self._security_client = security_client
        self._server_url = server_url
        self._language = language
        self._sdk_version = sdk_version
        self._gen_version = gen_version
        
    def post_assets_correlation_matrix(self, request: Any) -> operations.PostAssetsCorrelationMatrixResponse:
        r"""Correlation Matrix
        Compute the Pearson asset correlation matrix from either:  
        * The asset returns
        * The asset covariance matrix
        
        References
        * [Wikipedia, Correlation and Dependence](https://en.wikipedia.org/wiki/Correlation_and_dependence#Correlation_matrices)
        """
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/assets/correlation/matrix'
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = self._security_client
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.PostAssetsCorrelationMatrixResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.PostAssetsCorrelationMatrix200ApplicationJSON])
                res.post_assets_correlation_matrix_200_application_json_object = out

        return res

    def post_assets_correlation_matrix_bounds(self, request: operations.PostAssetsCorrelationMatrixBoundsRequestBody) -> operations.PostAssetsCorrelationMatrixBoundsResponse:
        r"""Correlation Matrix Bounds
        Compute the lower bounds and the upper bounds of an asset correlation matrix associated to a given group of assets.
         
         References
         * [Kawee Numpacharoen & Kornkanok Bunwong (2013) Boundaries of Correlation Adjustment with Applications to Financial Risk Management, Applied Mathematical Finance, 20:4, 403-414](http://dx.doi.org/10.1080/1350486X.2012.723517).
        """
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/assets/correlation/matrix/bounds'
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = self._security_client
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.PostAssetsCorrelationMatrixBoundsResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.PostAssetsCorrelationMatrixBounds200ApplicationJSON])
                res.post_assets_correlation_matrix_bounds_200_application_json_object = out

        return res

    def post_assets_correlation_matrix_denoised(self, request: operations.PostAssetsCorrelationMatrixDenoisedRequestBody) -> operations.PostAssetsCorrelationMatrixDenoisedResponse:
        r"""Denoised Correlation Matrix
        Compute a denoised asset correlation matrix, using one of the following methods:
         * The eigenvalues clipping method, described in the first reference, which is based on random matrix theory
         
         References
         * [Laurent Laloux, Pierre Cizeau, Jean-Philippe Bouchaud, and Marc Potters, Noise Dressing of Financial Correlation Matrices, Phys. Rev. Lett. 83, 1467](https://journals.aps.org/prl/abstract/10.1103/PhysRevLett.83.1467)
        """
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/assets/correlation/matrix/denoised'
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = self._security_client
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.PostAssetsCorrelationMatrixDenoisedResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.PostAssetsCorrelationMatrixDenoised200ApplicationJSON])
                res.post_assets_correlation_matrix_denoised_200_application_json_object = out

        return res

    def post_assets_correlation_matrix_distance(self, request: operations.PostAssetsCorrelationMatrixDistanceRequestBody) -> operations.PostAssetsCorrelationMatrixDistanceResponse:
        r"""Correlation Matrix Distance
        Compute the distance between an asset correlation matrix and a reference correlation matrix, using one of the following distance metrics:
        * Euclidean distance (default), which is the distance induced by [the Frobenius norm](https://en.wikipedia.org/wiki/Matrix_norm#Frobenius_norm)
        * Correlation matrix distance, defined in the first reference, which corresponds to [the cosine distance](https://en.wikipedia.org/wiki/Cosine_similarity) between the two vectorized asset correlation matrices
        * Bures distance, defined in the second reference
        
         References
         * [M. Herdin, N. Czink, H. Ozcelik and E. Bonek, Correlation matrix distance, a meaningful measure for evaluation of non-stationary MIMO channels, 2005 IEEE 61st Vehicular Technology Conference, 2005, pp. 136-140 Vol. 1](https://ieeexplore.ieee.org/document/1543265)
         * [Rajendra Bhatia, Tanvi Jain, Yongdo Lim, On the Bures–Wasserstein distance between positive definite matrices, Expositiones Mathematicae, Volume 37, Issue 2, 2019](https://www.sciencedirect.com/science/article/pii/S0723086918300021)
        """
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/assets/correlation/matrix/distance'
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = self._security_client
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.PostAssetsCorrelationMatrixDistanceResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.PostAssetsCorrelationMatrixDistance200ApplicationJSON])
                res.post_assets_correlation_matrix_distance_200_application_json_object = out

        return res

    def post_assets_correlation_matrix_effective_rank(self, request: operations.PostAssetsCorrelationMatrixEffectiveRankRequestBody) -> operations.PostAssetsCorrelationMatrixEffectiveRankResponse:
        r"""Correlation Matrix Effective Rank
        Compute the effective rank of an asset correlation matrix.
        
        References
        * [Olivier Roy and Martin Vetterli, The effective rank: A measure of effective dimensionality, 15th European Signal Processing Conference, 2007](https://ieeexplore.ieee.org/document/7098875)
        """
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/assets/correlation/matrix/effective-rank'
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = self._security_client
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.PostAssetsCorrelationMatrixEffectiveRankResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.PostAssetsCorrelationMatrixEffectiveRank200ApplicationJSON])
                res.post_assets_correlation_matrix_effective_rank_200_application_json_object = out

        return res

    def post_assets_correlation_matrix_informativeness(self, request: operations.PostAssetsCorrelationMatrixInformativenessRequestBody) -> operations.PostAssetsCorrelationMatrixInformativenessResponse:
        r"""Correlation Matrix Informativeness
        Compute the informativeness of an asset correlation matrix, using one of the following distance metrics:
        * Euclidean distance (default), which is the distance induced by [the Frobenius norm](https://en.wikipedia.org/wiki/Matrix_norm#Frobenius_norm)
        * Correlation matrix distance, defined in the second reference, which corresponds to [the cosine distance](https://en.wikipedia.org/wiki/Cosine_similarity) between the two vectorized asset correlation matrices
        * Bures distance, defined in the third reference
        
         References
         * [Austin J. Brockmeier and Tingting Mu and Sophia Ananiadou and John Y. Goulermas, Quantifying the Informativeness of Similarity Measurements, Journal of Machine Learning Research, 2017](http://jmlr.org/papers/v18/16-296.html)
         * [M. Herdin, N. Czink, H. Ozcelik and E. Bonek, Correlation matrix distance, a meaningful measure for evaluation of non-stationary MIMO channels, 2005 IEEE 61st Vehicular Technology Conference, 2005, pp. 136-140 Vol. 1](https://ieeexplore.ieee.org/document/1543265)
         * [Rajendra Bhatia, Tanvi Jain, Yongdo Lim, On the Bures–Wasserstein distance between positive definite matrices, Expositiones Mathematicae, Volume 37, Issue 2, 2019](https://www.sciencedirect.com/science/article/pii/S0723086918300021)
        """
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/assets/correlation/matrix/informativeness'
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = self._security_client
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.PostAssetsCorrelationMatrixInformativenessResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.PostAssetsCorrelationMatrixInformativeness200ApplicationJSON])
                res.post_assets_correlation_matrix_informativeness_200_application_json_object = out

        return res

    def post_assets_correlation_matrix_nearest(self, request: operations.PostAssetsCorrelationMatrixNearestRequestBody) -> operations.PostAssetsCorrelationMatrixNearestResponse:
        r"""Nearest Correlation Matrix
        Compute the _closest_ - in terms of [the Frobenius norm](https://en.wikipedia.org/wiki/Matrix_norm#Frobenius_norm) - asset correlation matrix to an approximate asset correlation matrix, optionally keeping a selected number of correlations fixed.
        
        References
        * [Nicholas J. Higham, Computing the Nearest Correlation Matrix—A Problem from Finance, IMA J. Numer. Anal. 22, 329–343, 2002.](http://www.maths.manchester.ac.uk/~higham/narep/narep369.pdf)
        """
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/assets/correlation/matrix/nearest'
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = self._security_client
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.PostAssetsCorrelationMatrixNearestResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.PostAssetsCorrelationMatrixNearest200ApplicationJSON])
                res.post_assets_correlation_matrix_nearest_200_application_json_object = out

        return res

    def post_assets_correlation_matrix_random(self, request: operations.PostAssetsCorrelationMatrixRandomRequestBody) -> operations.PostAssetsCorrelationMatrixRandomResponse:
        r"""Random Correlation Matrix
        Generate an asset correlation matrix uniformly at random over the space of positive definite correlation matrices.
        
        References
        * [Joe, H., Generating random correlation matrices based on partial correlations. Journal of Multivariate Analysis, 2006, 97, 2177-2189](https://www.sciencedirect.com/science/article/pii/S0047259X05000886)
        """
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/assets/correlation/matrix/random'
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = self._security_client
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.PostAssetsCorrelationMatrixRandomResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.PostAssetsCorrelationMatrixRandom200ApplicationJSON])
                res.post_assets_correlation_matrix_random_200_application_json_object = out

        return res

    def post_assets_correlation_matrix_shrinkage(self, request: Any) -> operations.PostAssetsCorrelationMatrixShrinkageResponse:
        r"""Correlation Matrix Shrinkage
        Compute an asset correlation matrix as a convex linear combination of an asset correlation matrix and a target correlation matrix, the target correlation matrix being either:  
         * An equicorrelation matrix made of 1
         * An equicorrelation matrix made of 0
         * An equicorrelation matrix made of -1/(n-1), with n the number of assets
         * A provided correlation matrix
         
         References
         * [Steiner, Andreas, Manipulating Valid Correlation Matrices](https://papers.ssrn.com/sol3/papers.cfm?abstract_id=1878165)
        """
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/assets/correlation/matrix/shrinkage'
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = self._security_client
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.PostAssetsCorrelationMatrixShrinkageResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.PostAssetsCorrelationMatrixShrinkage200ApplicationJSON])
                res.post_assets_correlation_matrix_shrinkage_200_application_json_object = out

        return res

    def post_assets_correlation_matrix_theory_implied(self, request: operations.PostAssetsCorrelationMatrixTheoryImpliedRequestBody) -> operations.PostAssetsCorrelationMatrixTheoryImpliedResponse:
        r"""Theory-Implied Correlation Matrix
        Compute the theory-implied asset correlation matrix associated with:
        * A hierarchical classification of a universe of assets
        * An asset correlation matrix
        
        References
        * [Lopez de Prado, Marcos Estimation of Theory-Implied Correlation Matrices (November 9, 2019)](https://papers.ssrn.com/sol3/papers.cfm?abstract_id=3484152)
        """
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/assets/correlation/matrix/theory-implied'
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = self._security_client
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.PostAssetsCorrelationMatrixTheoryImpliedResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.PostAssetsCorrelationMatrixTheoryImplied200ApplicationJSON])
                res.post_assets_correlation_matrix_theory_implied_200_application_json_object = out

        return res

    def post_assets_correlation_matrix_validation(self, request: operations.PostAssetsCorrelationMatrixValidationRequestBody) -> operations.PostAssetsCorrelationMatrixValidationResponse:
        r"""Correlation Matrix Validation
        Validate whether a matrix is an asset correlation matrix.
        
        References
        * [Wikipedia, Correlation and Dependence](https://en.wikipedia.org/wiki/Correlation_and_dependence#Correlation_matrices)
        """
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/assets/correlation/matrix/validation'
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = self._security_client
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.PostAssetsCorrelationMatrixValidationResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.PostAssetsCorrelationMatrixValidation200ApplicationJSON])
                res.post_assets_correlation_matrix_validation_200_application_json_object = out

        return res

    