"""Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT."""

from __future__ import annotations
import dataclasses
from ..shared import doublematcher as shared_doublematcher
from ..shared import listmatcher as shared_listmatcher
from ..shared import stringmatcher as shared_stringmatcher
from dataclasses_json import Undefined, dataclass_json
from sdk import utils
from typing import Any, Optional


@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class ValueMatcher:
    r"""Specifies the way to match a ProtobufWkt::Value. Primitive values and ListValue are supported. StructValue is not supported and is always not matched. [#next-free-field: 7]"""
    
    bool_match: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('boolMatch'), 'exclude': lambda f: f is None }})
    r"""If specified, a match occurs if and only if the target value is a bool value and is equal to this field."""  
    double_match: Optional[shared_doublematcher.DoubleMatcher] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('doubleMatch'), 'exclude': lambda f: f is None }})
    r"""Specifies the way to match a double value."""  
    list_match: Optional[shared_listmatcher.ListMatcher] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('listMatch'), 'exclude': lambda f: f is None }})
    r"""Specifies the way to match a list value."""  
    null_match: Optional[dict[str, Any]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('nullMatch'), 'exclude': lambda f: f is None }})
    r"""NullMatch is an empty message to specify a null value."""  
    present_match: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('presentMatch'), 'exclude': lambda f: f is None }})
    r"""If specified, value match will be performed based on whether the path is referring to a valid primitive value in the metadata. If the path is referring to a non-primitive value, the result is always not matched."""  
    string_match: Optional[shared_stringmatcher.StringMatcher] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('stringMatch'), 'exclude': lambda f: f is None }})
    r"""Specifies the way to match a string. [#next-free-field: 7]"""  
    