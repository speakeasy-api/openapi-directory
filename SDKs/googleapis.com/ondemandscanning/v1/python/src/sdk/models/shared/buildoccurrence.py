"""Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT."""

from __future__ import annotations
import dataclasses
from ..shared import buildprovenance as shared_buildprovenance
from ..shared import intotoprovenance as shared_intotoprovenance
from ..shared import intotostatement as shared_intotostatement
from dataclasses_json import Undefined, dataclass_json
from sdk import utils
from typing import Optional


@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class BuildOccurrence:
    r"""Details of a build occurrence."""
    
    intoto_provenance: Optional[shared_intotoprovenance.InTotoProvenance] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('intotoProvenance'), 'exclude': lambda f: f is None }})  
    intoto_statement: Optional[shared_intotostatement.InTotoStatement] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('intotoStatement'), 'exclude': lambda f: f is None }})
    r"""Spec defined at https://github.com/in-toto/attestation/tree/main/spec#statement The serialized InTotoStatement will be stored as Envelope.payload. Envelope.payloadType is always \\"application/vnd.in-toto+json\\"."""  
    provenance: Optional[shared_buildprovenance.BuildProvenance] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('provenance'), 'exclude': lambda f: f is None }})
    r"""Provenance of a build. Contains all information needed to verify the full details about the build from source to completion."""  
    provenance_bytes: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('provenanceBytes'), 'exclude': lambda f: f is None }})
    r"""Serialized JSON representation of the provenance, used in generating the build signature in the corresponding build note. After verifying the signature, `provenance_bytes` can be unmarshalled and compared to the provenance to confirm that it is unchanged. A base64-encoded string representation of the provenance bytes is used for the signature in order to interoperate with openssl which expects this format for signature verification. The serialized form is captured both to avoid ambiguity in how the provenance is marshalled to json as well to prevent incompatibilities with future changes."""  
    