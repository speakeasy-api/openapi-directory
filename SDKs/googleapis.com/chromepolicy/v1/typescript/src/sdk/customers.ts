/*
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

import * as utils from "../internal/utils";
import * as operations from "./models/operations";
import * as shared from "./models/shared";
import { AxiosInstance, AxiosRequestConfig, AxiosResponse } from "axios";

export class Customers {
  _defaultClient: AxiosInstance;
  _securityClient: AxiosInstance;
  _serverURL: string;
  _language: string;
  _sdkVersion: string;
  _genVersion: string;

  constructor(
    defaultClient: AxiosInstance,
    securityClient: AxiosInstance,
    serverURL: string,
    language: string,
    sdkVersion: string,
    genVersion: string
  ) {
    this._defaultClient = defaultClient;
    this._securityClient = securityClient;
    this._serverURL = serverURL;
    this._language = language;
    this._sdkVersion = sdkVersion;
    this._genVersion = genVersion;
  }

  /**
   * Delete multiple policy values that are applied to a specific group. All targets must have the same target format. That is to say that they must point to the same target resource and must have the same keys specified in `additionalTargetKeyNames`, though the values for those keys may be different. On failure the request will return the error details as part of the google.rpc.Status.
   */
  chromepolicyCustomersPoliciesGroupsBatchDelete(
    req: operations.ChromepolicyCustomersPoliciesGroupsBatchDeleteRequest,
    security: operations.ChromepolicyCustomersPoliciesGroupsBatchDeleteSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.ChromepolicyCustomersPoliciesGroupsBatchDeleteResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.ChromepolicyCustomersPoliciesGroupsBatchDeleteRequest(
          req
        );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v1/{customer}/policies/groups:batchDelete",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "googleChromePolicyVersionsV1BatchDeleteGroupPoliciesRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.ChromepolicyCustomersPoliciesGroupsBatchDeleteSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ChromepolicyCustomersPoliciesGroupsBatchDeleteResponse =
        new operations.ChromepolicyCustomersPoliciesGroupsBatchDeleteResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.googleProtobufEmpty = utils.objectToClass(httpRes?.data);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Modify multiple policy values that are applied to a specific group. All targets must have the same target format. That is to say that they must point to the same target resource and must have the same keys specified in `additionalTargetKeyNames`, though the values for those keys may be different. On failure the request will return the error details as part of the google.rpc.Status.
   */
  chromepolicyCustomersPoliciesGroupsBatchModify(
    req: operations.ChromepolicyCustomersPoliciesGroupsBatchModifyRequest,
    security: operations.ChromepolicyCustomersPoliciesGroupsBatchModifySecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.ChromepolicyCustomersPoliciesGroupsBatchModifyResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.ChromepolicyCustomersPoliciesGroupsBatchModifyRequest(
          req
        );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v1/{customer}/policies/groups:batchModify",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "googleChromePolicyVersionsV1BatchModifyGroupPoliciesRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.ChromepolicyCustomersPoliciesGroupsBatchModifySecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ChromepolicyCustomersPoliciesGroupsBatchModifyResponse =
        new operations.ChromepolicyCustomersPoliciesGroupsBatchModifyResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.googleProtobufEmpty = utils.objectToClass(httpRes?.data);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Retrieve a group priority ordering for an app. The target app must be supplied in `additionalTargetKeyNames` in the PolicyTargetKey. On failure the request will return the error details as part of the google.rpc.Status.
   */
  chromepolicyCustomersPoliciesGroupsListGroupPriorityOrdering(
    req: operations.ChromepolicyCustomersPoliciesGroupsListGroupPriorityOrderingRequest,
    security: operations.ChromepolicyCustomersPoliciesGroupsListGroupPriorityOrderingSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.ChromepolicyCustomersPoliciesGroupsListGroupPriorityOrderingResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.ChromepolicyCustomersPoliciesGroupsListGroupPriorityOrderingRequest(
          req
        );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v1/{customer}/policies/groups:listGroupPriorityOrdering",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "googleChromePolicyVersionsV1ListGroupPriorityOrderingRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.ChromepolicyCustomersPoliciesGroupsListGroupPriorityOrderingSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ChromepolicyCustomersPoliciesGroupsListGroupPriorityOrderingResponse =
        new operations.ChromepolicyCustomersPoliciesGroupsListGroupPriorityOrderingResponse(
          {
            statusCode: httpRes.status,
            contentType: contentType,
            rawResponse: httpRes,
          }
        );
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.googleChromePolicyVersionsV1ListGroupPriorityOrderingResponse =
              utils.objectToClass(
                httpRes?.data,
                shared.GoogleChromePolicyVersionsV1ListGroupPriorityOrderingResponse
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Update a group priority ordering for an app. The target app must be supplied in `additionalTargetKeyNames` in the PolicyTargetKey. On failure the request will return the error details as part of the google.rpc.Status.
   */
  chromepolicyCustomersPoliciesGroupsUpdateGroupPriorityOrdering(
    req: operations.ChromepolicyCustomersPoliciesGroupsUpdateGroupPriorityOrderingRequest,
    security: operations.ChromepolicyCustomersPoliciesGroupsUpdateGroupPriorityOrderingSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.ChromepolicyCustomersPoliciesGroupsUpdateGroupPriorityOrderingResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.ChromepolicyCustomersPoliciesGroupsUpdateGroupPriorityOrderingRequest(
          req
        );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v1/{customer}/policies/groups:updateGroupPriorityOrdering",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "googleChromePolicyVersionsV1UpdateGroupPriorityOrderingRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.ChromepolicyCustomersPoliciesGroupsUpdateGroupPriorityOrderingSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ChromepolicyCustomersPoliciesGroupsUpdateGroupPriorityOrderingResponse =
        new operations.ChromepolicyCustomersPoliciesGroupsUpdateGroupPriorityOrderingResponse(
          {
            statusCode: httpRes.status,
            contentType: contentType,
            rawResponse: httpRes,
          }
        );
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.googleProtobufEmpty = utils.objectToClass(httpRes?.data);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Creates a certificate at a specified OU for a customer.
   */
  chromepolicyCustomersPoliciesNetworksDefineCertificate(
    req: operations.ChromepolicyCustomersPoliciesNetworksDefineCertificateRequest,
    security: operations.ChromepolicyCustomersPoliciesNetworksDefineCertificateSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.ChromepolicyCustomersPoliciesNetworksDefineCertificateResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.ChromepolicyCustomersPoliciesNetworksDefineCertificateRequest(
          req
        );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v1/{customer}/policies/networks:defineCertificate",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "googleChromePolicyVersionsV1DefineCertificateRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.ChromepolicyCustomersPoliciesNetworksDefineCertificateSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ChromepolicyCustomersPoliciesNetworksDefineCertificateResponse =
        new operations.ChromepolicyCustomersPoliciesNetworksDefineCertificateResponse(
          {
            statusCode: httpRes.status,
            contentType: contentType,
            rawResponse: httpRes,
          }
        );
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.googleChromePolicyVersionsV1DefineCertificateResponse =
              utils.objectToClass(
                httpRes?.data,
                shared.GoogleChromePolicyVersionsV1DefineCertificateResponse
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Define a new network.
   */
  chromepolicyCustomersPoliciesNetworksDefineNetwork(
    req: operations.ChromepolicyCustomersPoliciesNetworksDefineNetworkRequest,
    security: operations.ChromepolicyCustomersPoliciesNetworksDefineNetworkSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.ChromepolicyCustomersPoliciesNetworksDefineNetworkResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.ChromepolicyCustomersPoliciesNetworksDefineNetworkRequest(
          req
        );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v1/{customer}/policies/networks:defineNetwork",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "googleChromePolicyVersionsV1DefineNetworkRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.ChromepolicyCustomersPoliciesNetworksDefineNetworkSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ChromepolicyCustomersPoliciesNetworksDefineNetworkResponse =
        new operations.ChromepolicyCustomersPoliciesNetworksDefineNetworkResponse(
          {
            statusCode: httpRes.status,
            contentType: contentType,
            rawResponse: httpRes,
          }
        );
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.googleChromePolicyVersionsV1DefineNetworkResponse =
              utils.objectToClass(
                httpRes?.data,
                shared.GoogleChromePolicyVersionsV1DefineNetworkResponse
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Remove an existing certificate by guid.
   */
  chromepolicyCustomersPoliciesNetworksRemoveCertificate(
    req: operations.ChromepolicyCustomersPoliciesNetworksRemoveCertificateRequest,
    security: operations.ChromepolicyCustomersPoliciesNetworksRemoveCertificateSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.ChromepolicyCustomersPoliciesNetworksRemoveCertificateResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.ChromepolicyCustomersPoliciesNetworksRemoveCertificateRequest(
          req
        );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v1/{customer}/policies/networks:removeCertificate",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "googleChromePolicyVersionsV1RemoveCertificateRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.ChromepolicyCustomersPoliciesNetworksRemoveCertificateSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ChromepolicyCustomersPoliciesNetworksRemoveCertificateResponse =
        new operations.ChromepolicyCustomersPoliciesNetworksRemoveCertificateResponse(
          {
            statusCode: httpRes.status,
            contentType: contentType,
            rawResponse: httpRes,
          }
        );
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.googleChromePolicyVersionsV1RemoveCertificateResponse =
              utils.objectToClass(httpRes?.data);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Remove an existing network by guid.
   */
  chromepolicyCustomersPoliciesNetworksRemoveNetwork(
    req: operations.ChromepolicyCustomersPoliciesNetworksRemoveNetworkRequest,
    security: operations.ChromepolicyCustomersPoliciesNetworksRemoveNetworkSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.ChromepolicyCustomersPoliciesNetworksRemoveNetworkResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.ChromepolicyCustomersPoliciesNetworksRemoveNetworkRequest(
          req
        );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v1/{customer}/policies/networks:removeNetwork",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "googleChromePolicyVersionsV1RemoveNetworkRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.ChromepolicyCustomersPoliciesNetworksRemoveNetworkSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ChromepolicyCustomersPoliciesNetworksRemoveNetworkResponse =
        new operations.ChromepolicyCustomersPoliciesNetworksRemoveNetworkResponse(
          {
            statusCode: httpRes.status,
            contentType: contentType,
            rawResponse: httpRes,
          }
        );
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.googleChromePolicyVersionsV1RemoveNetworkResponse =
              utils.objectToClass(httpRes?.data);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Modify multiple policy values that are applied to a specific org unit so that they now inherit the value from a parent (if applicable). All targets must have the same target format. That is to say that they must point to the same target resource and must have the same keys specified in `additionalTargetKeyNames`, though the values for those keys may be different. On failure the request will return the error details as part of the google.rpc.Status.
   */
  chromepolicyCustomersPoliciesOrgunitsBatchInherit(
    req: operations.ChromepolicyCustomersPoliciesOrgunitsBatchInheritRequest,
    security: operations.ChromepolicyCustomersPoliciesOrgunitsBatchInheritSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.ChromepolicyCustomersPoliciesOrgunitsBatchInheritResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.ChromepolicyCustomersPoliciesOrgunitsBatchInheritRequest(
          req
        );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v1/{customer}/policies/orgunits:batchInherit",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "googleChromePolicyVersionsV1BatchInheritOrgUnitPoliciesRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.ChromepolicyCustomersPoliciesOrgunitsBatchInheritSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ChromepolicyCustomersPoliciesOrgunitsBatchInheritResponse =
        new operations.ChromepolicyCustomersPoliciesOrgunitsBatchInheritResponse(
          {
            statusCode: httpRes.status,
            contentType: contentType,
            rawResponse: httpRes,
          }
        );
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.googleProtobufEmpty = utils.objectToClass(httpRes?.data);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Modify multiple policy values that are applied to a specific org unit. All targets must have the same target format. That is to say that they must point to the same target resource and must have the same keys specified in `additionalTargetKeyNames`, though the values for those keys may be different. On failure the request will return the error details as part of the google.rpc.Status.
   */
  chromepolicyCustomersPoliciesOrgunitsBatchModify(
    req: operations.ChromepolicyCustomersPoliciesOrgunitsBatchModifyRequest,
    security: operations.ChromepolicyCustomersPoliciesOrgunitsBatchModifySecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.ChromepolicyCustomersPoliciesOrgunitsBatchModifyResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.ChromepolicyCustomersPoliciesOrgunitsBatchModifyRequest(
          req
        );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v1/{customer}/policies/orgunits:batchModify",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "googleChromePolicyVersionsV1BatchModifyOrgUnitPoliciesRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.ChromepolicyCustomersPoliciesOrgunitsBatchModifySecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ChromepolicyCustomersPoliciesOrgunitsBatchModifyResponse =
        new operations.ChromepolicyCustomersPoliciesOrgunitsBatchModifyResponse(
          {
            statusCode: httpRes.status,
            contentType: contentType,
            rawResponse: httpRes,
          }
        );
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.googleProtobufEmpty = utils.objectToClass(httpRes?.data);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Gets the resolved policy values for a list of policies that match a search query.
   */
  chromepolicyCustomersPoliciesResolve(
    req: operations.ChromepolicyCustomersPoliciesResolveRequest,
    security: operations.ChromepolicyCustomersPoliciesResolveSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.ChromepolicyCustomersPoliciesResolveResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ChromepolicyCustomersPoliciesResolveRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v1/{customer}/policies:resolve",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "googleChromePolicyVersionsV1ResolveRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ChromepolicyCustomersPoliciesResolveSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ChromepolicyCustomersPoliciesResolveResponse =
        new operations.ChromepolicyCustomersPoliciesResolveResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.googleChromePolicyVersionsV1ResolveResponse =
              utils.objectToClass(
                httpRes?.data,
                shared.GoogleChromePolicyVersionsV1ResolveResponse
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Get a specific policy schema for a customer by its resource name.
   */
  chromepolicyCustomersPolicySchemasGet(
    req: operations.ChromepolicyCustomersPolicySchemasGetRequest,
    security: operations.ChromepolicyCustomersPolicySchemasGetSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.ChromepolicyCustomersPolicySchemasGetResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ChromepolicyCustomersPolicySchemasGetRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(baseURL, "/v1/{name}", req);
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ChromepolicyCustomersPolicySchemasGetSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ChromepolicyCustomersPolicySchemasGetResponse =
        new operations.ChromepolicyCustomersPolicySchemasGetResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.googleChromePolicyVersionsV1PolicySchema = utils.objectToClass(
              httpRes?.data,
              shared.GoogleChromePolicyVersionsV1PolicySchema
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Gets a list of policy schemas that match a specified filter value for a given customer.
   */
  chromepolicyCustomersPolicySchemasList(
    req: operations.ChromepolicyCustomersPolicySchemasListRequest,
    security: operations.ChromepolicyCustomersPolicySchemasListSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.ChromepolicyCustomersPolicySchemasListResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ChromepolicyCustomersPolicySchemasListRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v1/{parent}/policySchemas",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ChromepolicyCustomersPolicySchemasListSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ChromepolicyCustomersPolicySchemasListResponse =
        new operations.ChromepolicyCustomersPolicySchemasListResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.googleChromePolicyVersionsV1ListPolicySchemasResponse =
              utils.objectToClass(
                httpRes?.data,
                shared.GoogleChromePolicyVersionsV1ListPolicySchemasResponse
              );
          }
          break;
      }

      return res;
    });
  }
}
