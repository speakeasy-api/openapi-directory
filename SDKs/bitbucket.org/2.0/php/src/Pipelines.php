<?php

/**
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

declare(strict_types=1);

namespace OpenAPI\OpenAPI;

class Pipelines 
{

	// SDK private variables namespaced with _ to avoid conflicts with API models
	private \GuzzleHttp\ClientInterface $_defaultClient;
	private \GuzzleHttp\ClientInterface $_securityClient;
	private string $_serverUrl;
	private string $_language;
	private string $_sdkVersion;
	private string $_genVersion;	

	/**
	 * @param \GuzzleHttp\ClientInterface $defaultClient
	 * @param \GuzzleHttp\ClientInterface $securityClient
	 * @param string $serverUrl
	 * @param string $language
	 * @param string $sdkVersion
	 * @param string $genVersion
	 */
	public function __construct(\GuzzleHttp\ClientInterface $defaultClient, \GuzzleHttp\ClientInterface $securityClient, string $serverUrl, string $language, string $sdkVersion, string $genVersion)
	{
		$this->_defaultClient = $defaultClient;
		$this->_securityClient = $securityClient;
		$this->_serverUrl = $serverUrl;
		$this->_language = $language;
		$this->_sdkVersion = $sdkVersion;
		$this->_genVersion = $genVersion;
	}
	
    /**
     * Create a variable for an environment
     * 
     * Create a deployment environment level variable.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\CreateDeploymentVariableRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\CreateDeploymentVariableResponse
     */
	public function createDeploymentVariable(
        \OpenAPI\OpenAPI\Models\Operations\CreateDeploymentVariableRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\CreateDeploymentVariableResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/repositories/{workspace}/{repo_slug}/deployments_config/environments/{environment_uuid}/variables', \OpenAPI\OpenAPI\Models\Operations\CreateDeploymentVariableRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "requestBody", "json");
        if ($body === null) {
            throw new \Exception('Request body is required');
        }
        $options = array_merge_recursive($options, $body);
        
        $httpResponse = $this->_defaultClient->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\CreateDeploymentVariableResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 201) {
            $response->headers = $httpResponse->getHeaders();
            
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->deploymentVariable = $serializer->deserialize((string)$httpResponse->getBody(), 'array<string, mixed>', 'json');
            }
        }
        else if ($httpResponse->getStatusCode() === 404 or $httpResponse->getStatusCode() === 409) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->error = $serializer->deserialize((string)$httpResponse->getBody(), 'array<string, mixed>', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Run a pipeline
     * 
     * Endpoint to create and initiate a pipeline.
     * There are a couple of different options to initiate a pipeline, where the payload of the request will determine which type of pipeline will be instantiated.
     * # Trigger a Pipeline for a branch
     * One way to trigger pipelines is by specifying the branch for which you want to trigger a pipeline.
     * The specified branch will be used to determine which pipeline definition from the `bitbucket-pipelines.yml` file will be applied to initiate the pipeline. The pipeline will then do a clone of the repository and checkout the latest revision of the specified branch.
     * 
     * ### Example
     * 
     * ```
     * $ curl -X POST -is -u username:password \
     *   -H 'Content-Type: application/json' \
     *  https://api.bitbucket.org/2.0/repositories/jeroendr/meat-demo2/pipelines/ \
     *   -d '
     *   {
     *     "target": {
     *       "ref_type": "branch",
     *       "type": "pipeline_ref_target",
     *       "ref_name": "master"
     *     }
     *   }'
     * ```
     * # Trigger a Pipeline for a commit on a branch or tag
     * You can initiate a pipeline for a specific commit and in the context of a specified reference (e.g. a branch, tag or bookmark).
     * The specified reference will be used to determine which pipeline definition from the bitbucket-pipelines.yml file will be applied to initiate the pipeline. The pipeline will clone the repository and then do a checkout the specified reference.
     * 
     * The following reference types are supported:
     * 
     * * `branch`
     * * `named_branch`
     * * `bookmark`
     *  * `tag`
     * 
     * ### Example
     * 
     * ```
     * $ curl -X POST -is -u username:password \
     *   -H 'Content-Type: application/json' \
     *   https://api.bitbucket.org/2.0/repositories/jeroendr/meat-demo2/pipelines/ \
     *   -d '
     *   {
     *     "target": {
     *       "commit": {
     *         "type": "commit",
     *         "hash": "ce5b7431602f7cbba007062eeb55225c6e18e956"
     *       },
     *       "ref_type": "branch",
     *       "type": "pipeline_ref_target",
     *       "ref_name": "master"
     *     }
     *   }'
     * ```
     * # Trigger a specific pipeline definition for a commit
     * You can trigger a specific pipeline that is defined in your `bitbucket-pipelines.yml` file for a specific commit.
     * In addition to the commit revision, you specify the type and pattern of the selector that identifies the pipeline definition. The resulting pipeline will then clone the repository and checkout the specified revision.
     * 
     * ### Example
     * 
     * ```
     * $ curl -X POST -is -u username:password \
     *   -H 'Content-Type: application/json' \
     *  https://api.bitbucket.org/2.0/repositories/jeroendr/meat-demo2/pipelines/ \
     *  -d '
     *   {
     *      "target": {
     *       "commit": {
     *          "hash":"a3c4e02c9a3755eccdc3764e6ea13facdf30f923",
     *          "type":"commit"
     *        },
     *         "selector": {
     *            "type":"custom",
     *               "pattern":"Deploy to production"
     *           },
     *         "type":"pipeline_commit_target"
     *    }
     *   }'
     * ```
     * # Trigger a specific pipeline definition for a commit on a branch or tag
     * You can trigger a specific pipeline that is defined in your `bitbucket-pipelines.yml` file for a specific commit in the context of a specified reference.
     * In addition to the commit revision, you specify the type and pattern of the selector that identifies the pipeline definition, as well as the reference information. The resulting pipeline will then clone the repository a checkout the specified reference.
     * 
     * ### Example
     * 
     * ```
     * $ curl -X POST -is -u username:password \
     *   -H 'Content-Type: application/json' \
     *  https://api.bitbucket.org/2.0/repositories/jeroendr/meat-demo2/pipelines/ \
     *  -d '
     *   {
     *      "target": {
     *       "commit": {
     *          "hash":"a3c4e02c9a3755eccdc3764e6ea13facdf30f923",
     *          "type":"commit"
     *        },
     *        "selector": {
     *           "type": "custom",
     *           "pattern": "Deploy to production"
     *        },
     *        "type": "pipeline_ref_target",
     *        "ref_name": "master",
     *        "ref_type": "branch"
     *      }
     *   }'
     * ```
     * 
     * 
     * # Trigger a custom pipeline with variables
     * In addition to triggering a custom pipeline that is defined in your `bitbucket-pipelines.yml` file as shown in the examples above, you can specify variables that will be available for your build. In the request, provide a list of variables, specifying the following for each variable: key, value, and whether it should be secured or not (this field is optional and defaults to not secured).
     * 
     * ### Example
     * 
     * ```
     * $ curl -X POST -is -u username:password \
     *   -H 'Content-Type: application/json' \
     *  https://api.bitbucket.org/2.0/repositories/{workspace}/{repo_slug}/pipelines/ \
     *  -d '
     *   {
     *     "target": {
     *       "type": "pipeline_ref_target",
     *       "ref_type": "branch",
     *       "ref_name": "master",
     *       "selector": {
     *         "type": "custom",
     *         "pattern": "Deploy to production"
     *       }
     *     },
     *     "variables": [
     *       {
     *         "key": "var1key",
     *         "value": "var1value",
     *         "secured": true
     *       },
     *       {
     *         "key": "var2key",
     *         "value": "var2value"
     *       }
     *     ]
     *   }'
     * ```
     * 
     * # Trigger a pull request pipeline
     * 
     * You can also initiate a pipeline for a specific pull request.
     * 
     * ### Example
     * 
     * ```
     * $ curl -X POST -is -u username:password \
     *   -H 'Content-Type: application/json' \
     *  https://api.bitbucket.org/2.0/repositories/{workspace}/{repo_slug}/pipelines/ \
     *  -d '
     *   {
     * 	"target": {
     *       "type": "pipeline_pullrequest_target",
     * 	  "source": "pull-request-branch",
     *       "destination": "master",
     *       "destination_commit": {
     *       	 "hash" : "9f848b7"
     *       },
     *       "commit": {
     *       	"hash" : "1a372fc"
     *       },
     *       "pullrequest" : {
     *       	"id" : "3"
     *       },
     * 	  "selector": {
     *         "type": "pull-requests",
     *         "pattern": "**"
     *       }
     *     }
     *   }'
     * ```
     * 
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\CreatePipelineForRepositoryRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\CreatePipelineForRepositoryResponse
     */
	public function createPipelineForRepository(
        \OpenAPI\OpenAPI\Models\Operations\CreatePipelineForRepositoryRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\CreatePipelineForRepositoryResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/repositories/{workspace}/{repo_slug}/pipelines', \OpenAPI\OpenAPI\Models\Operations\CreatePipelineForRepositoryRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "requestBody", "json");
        if ($body === null) {
            throw new \Exception('Request body is required');
        }
        $options = array_merge_recursive($options, $body);
        
        $httpResponse = $this->_defaultClient->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\CreatePipelineForRepositoryResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 201) {
            $response->headers = $httpResponse->getHeaders();
            
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->pipeline = $serializer->deserialize((string)$httpResponse->getBody(), 'array<string, mixed>', 'json');
            }
        }
        else if ($httpResponse->getStatusCode() === 400 or $httpResponse->getStatusCode() === 404) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->error = $serializer->deserialize((string)$httpResponse->getBody(), 'array<string, mixed>', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Create a variable for a user
     * 
     * Create an account level variable.
     * This endpoint has been deprecated, and you should use the new workspaces endpoint. For more information, see [the announcement](https://developer.atlassian.com/cloud/bitbucket/bitbucket-api-teams-deprecation/).
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\CreatePipelineVariableForTeamRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\CreatePipelineVariableForTeamResponse
     * @deprecated this method will be removed in a future release, please migrate away from it as soon as possible
     */
	public function createPipelineVariableForTeam(
        \OpenAPI\OpenAPI\Models\Operations\CreatePipelineVariableForTeamRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\CreatePipelineVariableForTeamResponse
    {
        trigger_error('Method ' . __METHOD__ . ' is deprecated', E_USER_DEPRECATED);
        
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/teams/{username}/pipelines_config/variables', \OpenAPI\OpenAPI\Models\Operations\CreatePipelineVariableForTeamRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "requestBody", "json");
        $options = array_merge_recursive($options, $body);
        
        $httpResponse = $this->_defaultClient->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\CreatePipelineVariableForTeamResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 201) {
            $response->headers = $httpResponse->getHeaders();
            
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->pipelineVariable = $serializer->deserialize((string)$httpResponse->getBody(), 'array<string, mixed>', 'json');
            }
        }
        else if ($httpResponse->getStatusCode() === 404 or $httpResponse->getStatusCode() === 409) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->error = $serializer->deserialize((string)$httpResponse->getBody(), 'array<string, mixed>', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Create a variable for a user
     * 
     * Create a user level variable.
     * This endpoint has been deprecated, and you should use the new workspaces endpoint. For more information, see [the announcement](https://developer.atlassian.com/cloud/bitbucket/bitbucket-api-teams-deprecation/).
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\CreatePipelineVariableForUserRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\CreatePipelineVariableForUserResponse
     * @deprecated this method will be removed in a future release, please migrate away from it as soon as possible
     */
	public function createPipelineVariableForUser(
        \OpenAPI\OpenAPI\Models\Operations\CreatePipelineVariableForUserRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\CreatePipelineVariableForUserResponse
    {
        trigger_error('Method ' . __METHOD__ . ' is deprecated', E_USER_DEPRECATED);
        
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/users/{selected_user}/pipelines_config/variables', \OpenAPI\OpenAPI\Models\Operations\CreatePipelineVariableForUserRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "requestBody", "json");
        $options = array_merge_recursive($options, $body);
        
        $httpResponse = $this->_defaultClient->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\CreatePipelineVariableForUserResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 201) {
            $response->headers = $httpResponse->getHeaders();
            
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->pipelineVariable = $serializer->deserialize((string)$httpResponse->getBody(), 'array<string, mixed>', 'json');
            }
        }
        else if ($httpResponse->getStatusCode() === 404 or $httpResponse->getStatusCode() === 409) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->error = $serializer->deserialize((string)$httpResponse->getBody(), 'array<string, mixed>', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Create a variable for a workspace
     * 
     * Create a workspace level variable.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\CreatePipelineVariableForWorkspaceRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\CreatePipelineVariableForWorkspaceResponse
     */
	public function createPipelineVariableForWorkspace(
        \OpenAPI\OpenAPI\Models\Operations\CreatePipelineVariableForWorkspaceRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\CreatePipelineVariableForWorkspaceResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/workspaces/{workspace}/pipelines-config/variables', \OpenAPI\OpenAPI\Models\Operations\CreatePipelineVariableForWorkspaceRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "requestBody", "json");
        $options = array_merge_recursive($options, $body);
        
        $httpResponse = $this->_defaultClient->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\CreatePipelineVariableForWorkspaceResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 201) {
            $response->headers = $httpResponse->getHeaders();
            
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->pipelineVariable = $serializer->deserialize((string)$httpResponse->getBody(), 'array<string, mixed>', 'json');
            }
        }
        else if ($httpResponse->getStatusCode() === 404 or $httpResponse->getStatusCode() === 409) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->error = $serializer->deserialize((string)$httpResponse->getBody(), 'array<string, mixed>', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Create a known host
     * 
     * Create a repository level known host.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\CreateRepositoryPipelineKnownHostRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\CreateRepositoryPipelineKnownHostResponse
     */
	public function createRepositoryPipelineKnownHost(
        \OpenAPI\OpenAPI\Models\Operations\CreateRepositoryPipelineKnownHostRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\CreateRepositoryPipelineKnownHostResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/repositories/{workspace}/{repo_slug}/pipelines_config/ssh/known_hosts', \OpenAPI\OpenAPI\Models\Operations\CreateRepositoryPipelineKnownHostRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "requestBody", "json");
        if ($body === null) {
            throw new \Exception('Request body is required');
        }
        $options = array_merge_recursive($options, $body);
        
        $httpResponse = $this->_defaultClient->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\CreateRepositoryPipelineKnownHostResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 201) {
            $response->headers = $httpResponse->getHeaders();
            
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->pipelineKnownHost = $serializer->deserialize((string)$httpResponse->getBody(), 'array<string, mixed>', 'json');
            }
        }
        else if ($httpResponse->getStatusCode() === 404 or $httpResponse->getStatusCode() === 409) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->error = $serializer->deserialize((string)$httpResponse->getBody(), 'array<string, mixed>', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Create a schedule
     * 
     * Create a schedule for the given repository.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\CreateRepositoryPipelineScheduleRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\CreateRepositoryPipelineScheduleResponse
     */
	public function createRepositoryPipelineSchedule(
        \OpenAPI\OpenAPI\Models\Operations\CreateRepositoryPipelineScheduleRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\CreateRepositoryPipelineScheduleResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/repositories/{workspace}/{repo_slug}/pipelines_config/schedules', \OpenAPI\OpenAPI\Models\Operations\CreateRepositoryPipelineScheduleRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "requestBody", "json");
        if ($body === null) {
            throw new \Exception('Request body is required');
        }
        $options = array_merge_recursive($options, $body);
        
        $httpResponse = $this->_defaultClient->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\CreateRepositoryPipelineScheduleResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 201) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->pipelineSchedule = $serializer->deserialize((string)$httpResponse->getBody(), 'array<string, mixed>', 'json');
            }
        }
        else if ($httpResponse->getStatusCode() === 400 or $httpResponse->getStatusCode() === 401 or $httpResponse->getStatusCode() === 404) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->error = $serializer->deserialize((string)$httpResponse->getBody(), 'array<string, mixed>', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Create a variable for a repository
     * 
     * Create a repository level variable.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\CreateRepositoryPipelineVariableRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\CreateRepositoryPipelineVariableResponse
     */
	public function createRepositoryPipelineVariable(
        \OpenAPI\OpenAPI\Models\Operations\CreateRepositoryPipelineVariableRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\CreateRepositoryPipelineVariableResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/repositories/{workspace}/{repo_slug}/pipelines_config/variables', \OpenAPI\OpenAPI\Models\Operations\CreateRepositoryPipelineVariableRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "requestBody", "json");
        if ($body === null) {
            throw new \Exception('Request body is required');
        }
        $options = array_merge_recursive($options, $body);
        
        $httpResponse = $this->_defaultClient->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\CreateRepositoryPipelineVariableResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 201) {
            $response->headers = $httpResponse->getHeaders();
            
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->pipelineVariable = $serializer->deserialize((string)$httpResponse->getBody(), 'array<string, mixed>', 'json');
            }
        }
        else if ($httpResponse->getStatusCode() === 404 or $httpResponse->getStatusCode() === 409) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->error = $serializer->deserialize((string)$httpResponse->getBody(), 'array<string, mixed>', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Delete a variable for an environment
     * 
     * Delete a deployment environment level variable.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\DeleteDeploymentVariableRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\DeleteDeploymentVariableResponse
     */
	public function deleteDeploymentVariable(
        \OpenAPI\OpenAPI\Models\Operations\DeleteDeploymentVariableRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\DeleteDeploymentVariableResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/repositories/{workspace}/{repo_slug}/deployments_config/environments/{environment_uuid}/variables/{variable_uuid}', \OpenAPI\OpenAPI\Models\Operations\DeleteDeploymentVariableRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_defaultClient->request('DELETE', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\DeleteDeploymentVariableResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 204) {
        }
        else if ($httpResponse->getStatusCode() === 404) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->error = $serializer->deserialize((string)$httpResponse->getBody(), 'array<string, mixed>', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Delete a variable for a team
     * 
     * Delete a team level variable.
     * This endpoint has been deprecated, and you should use the new workspaces endpoint. For more information, see [the announcement](https://developer.atlassian.com/cloud/bitbucket/bitbucket-api-teams-deprecation/).
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\DeletePipelineVariableForTeamRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\DeletePipelineVariableForTeamResponse
     * @deprecated this method will be removed in a future release, please migrate away from it as soon as possible
     */
	public function deletePipelineVariableForTeam(
        \OpenAPI\OpenAPI\Models\Operations\DeletePipelineVariableForTeamRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\DeletePipelineVariableForTeamResponse
    {
        trigger_error('Method ' . __METHOD__ . ' is deprecated', E_USER_DEPRECATED);
        
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/teams/{username}/pipelines_config/variables/{variable_uuid}', \OpenAPI\OpenAPI\Models\Operations\DeletePipelineVariableForTeamRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_defaultClient->request('DELETE', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\DeletePipelineVariableForTeamResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 204) {
        }
        else if ($httpResponse->getStatusCode() === 404) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->error = $serializer->deserialize((string)$httpResponse->getBody(), 'array<string, mixed>', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Delete a variable for a user
     * 
     * Delete an account level variable.
     * This endpoint has been deprecated, and you should use the new workspaces endpoint. For more information, see [the announcement](https://developer.atlassian.com/cloud/bitbucket/bitbucket-api-teams-deprecation/).
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\DeletePipelineVariableForUserRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\DeletePipelineVariableForUserResponse
     * @deprecated this method will be removed in a future release, please migrate away from it as soon as possible
     */
	public function deletePipelineVariableForUser(
        \OpenAPI\OpenAPI\Models\Operations\DeletePipelineVariableForUserRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\DeletePipelineVariableForUserResponse
    {
        trigger_error('Method ' . __METHOD__ . ' is deprecated', E_USER_DEPRECATED);
        
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/users/{selected_user}/pipelines_config/variables/{variable_uuid}', \OpenAPI\OpenAPI\Models\Operations\DeletePipelineVariableForUserRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_defaultClient->request('DELETE', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\DeletePipelineVariableForUserResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 204) {
        }
        else if ($httpResponse->getStatusCode() === 404) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->error = $serializer->deserialize((string)$httpResponse->getBody(), 'array<string, mixed>', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Delete a variable for a workspace
     * 
     * Delete a workspace level variable.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\DeletePipelineVariableForWorkspaceRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\DeletePipelineVariableForWorkspaceResponse
     */
	public function deletePipelineVariableForWorkspace(
        \OpenAPI\OpenAPI\Models\Operations\DeletePipelineVariableForWorkspaceRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\DeletePipelineVariableForWorkspaceResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/workspaces/{workspace}/pipelines-config/variables/{variable_uuid}', \OpenAPI\OpenAPI\Models\Operations\DeletePipelineVariableForWorkspaceRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_defaultClient->request('DELETE', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\DeletePipelineVariableForWorkspaceResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 204) {
        }
        else if ($httpResponse->getStatusCode() === 404) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->error = $serializer->deserialize((string)$httpResponse->getBody(), 'array<string, mixed>', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Delete a cache
     * 
     * Delete a repository cache.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\DeleteRepositoryPipelineCacheRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\DeleteRepositoryPipelineCacheResponse
     */
	public function deleteRepositoryPipelineCache(
        \OpenAPI\OpenAPI\Models\Operations\DeleteRepositoryPipelineCacheRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\DeleteRepositoryPipelineCacheResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/repositories/{workspace}/{repo_slug}/pipelines-config/caches/{cache_uuid}', \OpenAPI\OpenAPI\Models\Operations\DeleteRepositoryPipelineCacheRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_defaultClient->request('DELETE', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\DeleteRepositoryPipelineCacheResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 204) {
        }
        else if ($httpResponse->getStatusCode() === 404) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->error = $serializer->deserialize((string)$httpResponse->getBody(), 'array<string, mixed>', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Delete caches
     * 
     * Delete repository cache versions by name.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\DeleteRepositoryPipelineCachesRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\DeleteRepositoryPipelineCachesResponse
     */
	public function deleteRepositoryPipelineCaches(
        \OpenAPI\OpenAPI\Models\Operations\DeleteRepositoryPipelineCachesRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\DeleteRepositoryPipelineCachesResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/repositories/{workspace}/{repo_slug}/pipelines-config/caches', \OpenAPI\OpenAPI\Models\Operations\DeleteRepositoryPipelineCachesRequest::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\DeleteRepositoryPipelineCachesRequest::class, $request, null));
        
        $httpResponse = $this->_defaultClient->request('DELETE', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\DeleteRepositoryPipelineCachesResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 204) {
        }
        else if ($httpResponse->getStatusCode() === 404) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->error = $serializer->deserialize((string)$httpResponse->getBody(), 'array<string, mixed>', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Delete SSH key pair
     * 
     * Delete the repository SSH key pair.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\DeleteRepositoryPipelineKeyPairRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\DeleteRepositoryPipelineKeyPairResponse
     */
	public function deleteRepositoryPipelineKeyPair(
        \OpenAPI\OpenAPI\Models\Operations\DeleteRepositoryPipelineKeyPairRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\DeleteRepositoryPipelineKeyPairResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/repositories/{workspace}/{repo_slug}/pipelines_config/ssh/key_pair', \OpenAPI\OpenAPI\Models\Operations\DeleteRepositoryPipelineKeyPairRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_defaultClient->request('DELETE', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\DeleteRepositoryPipelineKeyPairResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 204) {
        }
        else if ($httpResponse->getStatusCode() === 404) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->error = $serializer->deserialize((string)$httpResponse->getBody(), 'array<string, mixed>', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Delete a known host
     * 
     * Delete a repository level known host.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\DeleteRepositoryPipelineKnownHostRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\DeleteRepositoryPipelineKnownHostResponse
     */
	public function deleteRepositoryPipelineKnownHost(
        \OpenAPI\OpenAPI\Models\Operations\DeleteRepositoryPipelineKnownHostRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\DeleteRepositoryPipelineKnownHostResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/repositories/{workspace}/{repo_slug}/pipelines_config/ssh/known_hosts/{known_host_uuid}', \OpenAPI\OpenAPI\Models\Operations\DeleteRepositoryPipelineKnownHostRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_defaultClient->request('DELETE', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\DeleteRepositoryPipelineKnownHostResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 204) {
        }
        else if ($httpResponse->getStatusCode() === 404) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->error = $serializer->deserialize((string)$httpResponse->getBody(), 'array<string, mixed>', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Delete a schedule
     * 
     * Delete a schedule.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\DeleteRepositoryPipelineScheduleRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\DeleteRepositoryPipelineScheduleResponse
     */
	public function deleteRepositoryPipelineSchedule(
        \OpenAPI\OpenAPI\Models\Operations\DeleteRepositoryPipelineScheduleRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\DeleteRepositoryPipelineScheduleResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/repositories/{workspace}/{repo_slug}/pipelines_config/schedules/{schedule_uuid}', \OpenAPI\OpenAPI\Models\Operations\DeleteRepositoryPipelineScheduleRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_defaultClient->request('DELETE', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\DeleteRepositoryPipelineScheduleResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 204) {
        }
        else if ($httpResponse->getStatusCode() === 404) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->error = $serializer->deserialize((string)$httpResponse->getBody(), 'array<string, mixed>', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Delete a variable for a repository
     * 
     * Delete a repository level variable.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\DeleteRepositoryPipelineVariableRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\DeleteRepositoryPipelineVariableResponse
     */
	public function deleteRepositoryPipelineVariable(
        \OpenAPI\OpenAPI\Models\Operations\DeleteRepositoryPipelineVariableRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\DeleteRepositoryPipelineVariableResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/repositories/{workspace}/{repo_slug}/pipelines_config/variables/{variable_uuid}', \OpenAPI\OpenAPI\Models\Operations\DeleteRepositoryPipelineVariableRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_defaultClient->request('DELETE', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\DeleteRepositoryPipelineVariableResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 204) {
        }
        else if ($httpResponse->getStatusCode() === 404) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->error = $serializer->deserialize((string)$httpResponse->getBody(), 'array<string, mixed>', 'json');
            }
        }

        return $response;
    }
	
    /**
     * List variables for an environment
     * 
     * Find deployment environment level variables.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetDeploymentVariablesRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\GetDeploymentVariablesResponse
     */
	public function getDeploymentVariables(
        \OpenAPI\OpenAPI\Models\Operations\GetDeploymentVariablesRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\GetDeploymentVariablesResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/repositories/{workspace}/{repo_slug}/deployments_config/environments/{environment_uuid}/variables', \OpenAPI\OpenAPI\Models\Operations\GetDeploymentVariablesRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_defaultClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetDeploymentVariablesResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->paginatedDeploymentVariable = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\PaginatedDeploymentVariable', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Get OpenID configuration for OIDC in Pipelines
     * 
     * This is part of OpenID Connect for Pipelines, see https://support.atlassian.com/bitbucket-cloud/docs/integrate-pipelines-with-resource-servers-using-oidc/
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetOIDCConfigurationRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\GetOIDCConfigurationResponse
     */
	public function getOIDCConfiguration(
        \OpenAPI\OpenAPI\Models\Operations\GetOIDCConfigurationRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\GetOIDCConfigurationResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/workspaces/{workspace}/pipelines-config/identity/oidc/.well-known/openid-configuration', \OpenAPI\OpenAPI\Models\Operations\GetOIDCConfigurationRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_defaultClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetOIDCConfigurationResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
        }
        else if ($httpResponse->getStatusCode() === 404) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->error = $serializer->deserialize((string)$httpResponse->getBody(), 'array<string, mixed>', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Get keys for OIDC in Pipelines
     * 
     * This is part of OpenID Connect for Pipelines, see https://support.atlassian.com/bitbucket-cloud/docs/integrate-pipelines-with-resource-servers-using-oidc/
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetOIDCKeysRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\GetOIDCKeysResponse
     */
	public function getOIDCKeys(
        \OpenAPI\OpenAPI\Models\Operations\GetOIDCKeysRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\GetOIDCKeysResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/workspaces/{workspace}/pipelines-config/identity/oidc/keys.json', \OpenAPI\OpenAPI\Models\Operations\GetOIDCKeysRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_defaultClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetOIDCKeysResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
        }
        else if ($httpResponse->getStatusCode() === 404) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->error = $serializer->deserialize((string)$httpResponse->getBody(), 'array<string, mixed>', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Get the logs for the build container or a service container for a given step of a pipeline.
     * 
     * Retrieve the log file for a build container or service container.
     * 
     * This endpoint supports (and encourages!) the use of [HTTP Range requests](https://tools.ietf.org/html/rfc7233) to deal with potentially very large log files.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetPipelineContainerLogRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\GetPipelineContainerLogResponse
     */
	public function getPipelineContainerLog(
        \OpenAPI\OpenAPI\Models\Operations\GetPipelineContainerLogRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\GetPipelineContainerLogResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/repositories/{workspace}/{repo_slug}/pipelines/{pipeline_uuid}/steps/{step_uuid}/logs/{log_uuid}', \OpenAPI\OpenAPI\Models\Operations\GetPipelineContainerLogRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_defaultClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetPipelineContainerLogResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
        }
        else if ($httpResponse->getStatusCode() === 404) {
            if (Utils\Utils::matchContentType($contentType, 'application/octet-stream')) {
                $response->body = $httpResponse->getBody()->getContents();
            }
        }

        return $response;
    }
	
    /**
     * Get a pipeline
     * 
     * Retrieve a specified pipeline
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetPipelineForRepositoryRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\GetPipelineForRepositoryResponse
     */
	public function getPipelineForRepository(
        \OpenAPI\OpenAPI\Models\Operations\GetPipelineForRepositoryRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\GetPipelineForRepositoryResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/repositories/{workspace}/{repo_slug}/pipelines/{pipeline_uuid}', \OpenAPI\OpenAPI\Models\Operations\GetPipelineForRepositoryRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_defaultClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetPipelineForRepositoryResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->pipeline = $serializer->deserialize((string)$httpResponse->getBody(), 'array<string, mixed>', 'json');
            }
        }
        else if ($httpResponse->getStatusCode() === 404) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->error = $serializer->deserialize((string)$httpResponse->getBody(), 'array<string, mixed>', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Get a step of a pipeline
     * 
     * Retrieve a given step of a pipeline.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetPipelineStepForRepositoryRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\GetPipelineStepForRepositoryResponse
     */
	public function getPipelineStepForRepository(
        \OpenAPI\OpenAPI\Models\Operations\GetPipelineStepForRepositoryRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\GetPipelineStepForRepositoryResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/repositories/{workspace}/{repo_slug}/pipelines/{pipeline_uuid}/steps/{step_uuid}', \OpenAPI\OpenAPI\Models\Operations\GetPipelineStepForRepositoryRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_defaultClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetPipelineStepForRepositoryResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->pipelineStep = $serializer->deserialize((string)$httpResponse->getBody(), 'array<string, mixed>', 'json');
            }
        }
        else if ($httpResponse->getStatusCode() === 404) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->error = $serializer->deserialize((string)$httpResponse->getBody(), 'array<string, mixed>', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Get log file for a step
     * 
     * Retrieve the log file for a given step of a pipeline.
     * 
     * This endpoint supports (and encourages!) the use of [HTTP Range requests](https://tools.ietf.org/html/rfc7233) to deal with potentially very large log files.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetPipelineStepLogForRepositoryRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\GetPipelineStepLogForRepositoryResponse
     */
	public function getPipelineStepLogForRepository(
        \OpenAPI\OpenAPI\Models\Operations\GetPipelineStepLogForRepositoryRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\GetPipelineStepLogForRepositoryResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/repositories/{workspace}/{repo_slug}/pipelines/{pipeline_uuid}/steps/{step_uuid}/log', \OpenAPI\OpenAPI\Models\Operations\GetPipelineStepLogForRepositoryRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_defaultClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetPipelineStepLogForRepositoryResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
        }
        else if ($httpResponse->getStatusCode() === 304 or $httpResponse->getStatusCode() === 404 or $httpResponse->getStatusCode() === 416) {
            if (Utils\Utils::matchContentType($contentType, 'application/octet-stream')) {
                $response->body = $httpResponse->getBody()->getContents();
            }
        }

        return $response;
    }
	
    /**
     * List steps for a pipeline
     * 
     * Find steps for the given pipeline.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetPipelineStepsForRepositoryRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\GetPipelineStepsForRepositoryResponse
     */
	public function getPipelineStepsForRepository(
        \OpenAPI\OpenAPI\Models\Operations\GetPipelineStepsForRepositoryRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\GetPipelineStepsForRepositoryResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/repositories/{workspace}/{repo_slug}/pipelines/{pipeline_uuid}/steps', \OpenAPI\OpenAPI\Models\Operations\GetPipelineStepsForRepositoryRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_defaultClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetPipelineStepsForRepositoryResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->paginatedPipelineSteps = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\PaginatedPipelineSteps', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Get test case reasons (output) for a given test case in a step of a pipeline.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetPipelineTestReportTestCaseReasonsRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\GetPipelineTestReportTestCaseReasonsResponse
     */
	public function getPipelineTestReportTestCaseReasons(
        \OpenAPI\OpenAPI\Models\Operations\GetPipelineTestReportTestCaseReasonsRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\GetPipelineTestReportTestCaseReasonsResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/repositories/{workspace}/{repo_slug}/pipelines/{pipeline_uuid}/steps/{step_uuid}/test_reports/test_cases/{test_case_uuid}/test_case_reasons', \OpenAPI\OpenAPI\Models\Operations\GetPipelineTestReportTestCaseReasonsRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_defaultClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetPipelineTestReportTestCaseReasonsResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
        }
        else if ($httpResponse->getStatusCode() === 404) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->error = $serializer->deserialize((string)$httpResponse->getBody(), 'array<string, mixed>', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Get test cases for a given step of a pipeline.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetPipelineTestReportTestCasesRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\GetPipelineTestReportTestCasesResponse
     */
	public function getPipelineTestReportTestCases(
        \OpenAPI\OpenAPI\Models\Operations\GetPipelineTestReportTestCasesRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\GetPipelineTestReportTestCasesResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/repositories/{workspace}/{repo_slug}/pipelines/{pipeline_uuid}/steps/{step_uuid}/test_reports/test_cases', \OpenAPI\OpenAPI\Models\Operations\GetPipelineTestReportTestCasesRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_defaultClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetPipelineTestReportTestCasesResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
        }
        else if ($httpResponse->getStatusCode() === 404) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->error = $serializer->deserialize((string)$httpResponse->getBody(), 'array<string, mixed>', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Get a summary of test reports for a given step of a pipeline.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetPipelineTestReportsRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\GetPipelineTestReportsResponse
     */
	public function getPipelineTestReports(
        \OpenAPI\OpenAPI\Models\Operations\GetPipelineTestReportsRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\GetPipelineTestReportsResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/repositories/{workspace}/{repo_slug}/pipelines/{pipeline_uuid}/steps/{step_uuid}/test_reports', \OpenAPI\OpenAPI\Models\Operations\GetPipelineTestReportsRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_defaultClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetPipelineTestReportsResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
        }
        else if ($httpResponse->getStatusCode() === 404) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->error = $serializer->deserialize((string)$httpResponse->getBody(), 'array<string, mixed>', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Get a variable for a team
     * 
     * Retrieve a team level variable.
     * This endpoint has been deprecated, and you should use the new workspaces endpoint. For more information, see [the announcement](https://developer.atlassian.com/cloud/bitbucket/bitbucket-api-teams-deprecation/).
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetPipelineVariableForTeamRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\GetPipelineVariableForTeamResponse
     * @deprecated this method will be removed in a future release, please migrate away from it as soon as possible
     */
	public function getPipelineVariableForTeam(
        \OpenAPI\OpenAPI\Models\Operations\GetPipelineVariableForTeamRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\GetPipelineVariableForTeamResponse
    {
        trigger_error('Method ' . __METHOD__ . ' is deprecated', E_USER_DEPRECATED);
        
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/teams/{username}/pipelines_config/variables/{variable_uuid}', \OpenAPI\OpenAPI\Models\Operations\GetPipelineVariableForTeamRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_defaultClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetPipelineVariableForTeamResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->pipelineVariable = $serializer->deserialize((string)$httpResponse->getBody(), 'array<string, mixed>', 'json');
            }
        }
        else if ($httpResponse->getStatusCode() === 404) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->error = $serializer->deserialize((string)$httpResponse->getBody(), 'array<string, mixed>', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Get a variable for a user
     * 
     * Retrieve a user level variable.
     * This endpoint has been deprecated, and you should use the new workspaces endpoint. For more information, see [the announcement](https://developer.atlassian.com/cloud/bitbucket/bitbucket-api-teams-deprecation/).
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetPipelineVariableForUserRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\GetPipelineVariableForUserResponse
     * @deprecated this method will be removed in a future release, please migrate away from it as soon as possible
     */
	public function getPipelineVariableForUser(
        \OpenAPI\OpenAPI\Models\Operations\GetPipelineVariableForUserRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\GetPipelineVariableForUserResponse
    {
        trigger_error('Method ' . __METHOD__ . ' is deprecated', E_USER_DEPRECATED);
        
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/users/{selected_user}/pipelines_config/variables/{variable_uuid}', \OpenAPI\OpenAPI\Models\Operations\GetPipelineVariableForUserRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_defaultClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetPipelineVariableForUserResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->pipelineVariable = $serializer->deserialize((string)$httpResponse->getBody(), 'array<string, mixed>', 'json');
            }
        }
        else if ($httpResponse->getStatusCode() === 404) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->error = $serializer->deserialize((string)$httpResponse->getBody(), 'array<string, mixed>', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Get variable for a workspace
     * 
     * Retrieve a workspace level variable.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetPipelineVariableForWorkspaceRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\GetPipelineVariableForWorkspaceResponse
     */
	public function getPipelineVariableForWorkspace(
        \OpenAPI\OpenAPI\Models\Operations\GetPipelineVariableForWorkspaceRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\GetPipelineVariableForWorkspaceResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/workspaces/{workspace}/pipelines-config/variables/{variable_uuid}', \OpenAPI\OpenAPI\Models\Operations\GetPipelineVariableForWorkspaceRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_defaultClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetPipelineVariableForWorkspaceResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->pipelineVariable = $serializer->deserialize((string)$httpResponse->getBody(), 'array<string, mixed>', 'json');
            }
        }
        else if ($httpResponse->getStatusCode() === 404) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->error = $serializer->deserialize((string)$httpResponse->getBody(), 'array<string, mixed>', 'json');
            }
        }

        return $response;
    }
	
    /**
     * List variables for an account
     * 
     * Find account level variables.
     * This endpoint has been deprecated, and you should use the new workspaces endpoint. For more information, see [the announcement](https://developer.atlassian.com/cloud/bitbucket/bitbucket-api-teams-deprecation/).
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetPipelineVariablesForTeamRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\GetPipelineVariablesForTeamResponse
     * @deprecated this method will be removed in a future release, please migrate away from it as soon as possible
     */
	public function getPipelineVariablesForTeam(
        \OpenAPI\OpenAPI\Models\Operations\GetPipelineVariablesForTeamRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\GetPipelineVariablesForTeamResponse
    {
        trigger_error('Method ' . __METHOD__ . ' is deprecated', E_USER_DEPRECATED);
        
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/teams/{username}/pipelines_config/variables', \OpenAPI\OpenAPI\Models\Operations\GetPipelineVariablesForTeamRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_defaultClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetPipelineVariablesForTeamResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->paginatedPipelineVariables = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\PaginatedPipelineVariables', 'json');
            }
        }

        return $response;
    }
	
    /**
     * List variables for a user
     * 
     * Find user level variables.
     * This endpoint has been deprecated, and you should use the new workspaces endpoint. For more information, see [the announcement](https://developer.atlassian.com/cloud/bitbucket/bitbucket-api-teams-deprecation/).
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetPipelineVariablesForUserRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\GetPipelineVariablesForUserResponse
     * @deprecated this method will be removed in a future release, please migrate away from it as soon as possible
     */
	public function getPipelineVariablesForUser(
        \OpenAPI\OpenAPI\Models\Operations\GetPipelineVariablesForUserRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\GetPipelineVariablesForUserResponse
    {
        trigger_error('Method ' . __METHOD__ . ' is deprecated', E_USER_DEPRECATED);
        
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/users/{selected_user}/pipelines_config/variables', \OpenAPI\OpenAPI\Models\Operations\GetPipelineVariablesForUserRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_defaultClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetPipelineVariablesForUserResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->paginatedPipelineVariables = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\PaginatedPipelineVariables', 'json');
            }
        }

        return $response;
    }
	
    /**
     * List variables for a workspace
     * 
     * Find workspace level variables.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetPipelineVariablesForWorkspaceRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\GetPipelineVariablesForWorkspaceResponse
     */
	public function getPipelineVariablesForWorkspace(
        \OpenAPI\OpenAPI\Models\Operations\GetPipelineVariablesForWorkspaceRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\GetPipelineVariablesForWorkspaceResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/workspaces/{workspace}/pipelines-config/variables', \OpenAPI\OpenAPI\Models\Operations\GetPipelineVariablesForWorkspaceRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_defaultClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetPipelineVariablesForWorkspaceResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->paginatedPipelineVariables = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\PaginatedPipelineVariables', 'json');
            }
        }

        return $response;
    }
	
    /**
     * List pipelines
     * 
     * Find pipelines
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetPipelinesForRepositoryRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\GetPipelinesForRepositoryResponse
     */
	public function getPipelinesForRepository(
        \OpenAPI\OpenAPI\Models\Operations\GetPipelinesForRepositoryRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\GetPipelinesForRepositoryResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/repositories/{workspace}/{repo_slug}/pipelines', \OpenAPI\OpenAPI\Models\Operations\GetPipelinesForRepositoryRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_defaultClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetPipelinesForRepositoryResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->paginatedPipelines = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\PaginatedPipelines', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Get cache content URI
     * 
     * Retrieve the URI of the content of the specified cache.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetRepositoryPipelineCacheContentURIRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\GetRepositoryPipelineCacheContentURIResponse
     */
	public function getRepositoryPipelineCacheContentURI(
        \OpenAPI\OpenAPI\Models\Operations\GetRepositoryPipelineCacheContentURIRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\GetRepositoryPipelineCacheContentURIResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/repositories/{workspace}/{repo_slug}/pipelines-config/caches/{cache_uuid}/content-uri', \OpenAPI\OpenAPI\Models\Operations\GetRepositoryPipelineCacheContentURIRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_defaultClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetRepositoryPipelineCacheContentURIResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->pipelineCacheContentUri = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\PipelineCacheContentUri', 'json');
            }
        }
        else if ($httpResponse->getStatusCode() === 404) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->error = $serializer->deserialize((string)$httpResponse->getBody(), 'array<string, mixed>', 'json');
            }
        }

        return $response;
    }
	
    /**
     * List caches
     * 
     * Retrieve the repository pipelines caches.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetRepositoryPipelineCachesRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\GetRepositoryPipelineCachesResponse
     */
	public function getRepositoryPipelineCaches(
        \OpenAPI\OpenAPI\Models\Operations\GetRepositoryPipelineCachesRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\GetRepositoryPipelineCachesResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/repositories/{workspace}/{repo_slug}/pipelines-config/caches', \OpenAPI\OpenAPI\Models\Operations\GetRepositoryPipelineCachesRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_defaultClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetRepositoryPipelineCachesResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->paginatedPipelineCaches = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\PaginatedPipelineCaches', 'json');
            }
        }
        else if ($httpResponse->getStatusCode() === 404) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->error = $serializer->deserialize((string)$httpResponse->getBody(), 'array<string, mixed>', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Get configuration
     * 
     * Retrieve the repository pipelines configuration.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetRepositoryPipelineConfigRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\GetRepositoryPipelineConfigResponse
     */
	public function getRepositoryPipelineConfig(
        \OpenAPI\OpenAPI\Models\Operations\GetRepositoryPipelineConfigRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\GetRepositoryPipelineConfigResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/repositories/{workspace}/{repo_slug}/pipelines_config', \OpenAPI\OpenAPI\Models\Operations\GetRepositoryPipelineConfigRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_defaultClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetRepositoryPipelineConfigResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->pipelinesConfig = $serializer->deserialize((string)$httpResponse->getBody(), 'array<string, mixed>', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Get a known host
     * 
     * Retrieve a repository level known host.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetRepositoryPipelineKnownHostRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\GetRepositoryPipelineKnownHostResponse
     */
	public function getRepositoryPipelineKnownHost(
        \OpenAPI\OpenAPI\Models\Operations\GetRepositoryPipelineKnownHostRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\GetRepositoryPipelineKnownHostResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/repositories/{workspace}/{repo_slug}/pipelines_config/ssh/known_hosts/{known_host_uuid}', \OpenAPI\OpenAPI\Models\Operations\GetRepositoryPipelineKnownHostRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_defaultClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetRepositoryPipelineKnownHostResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->pipelineKnownHost = $serializer->deserialize((string)$httpResponse->getBody(), 'array<string, mixed>', 'json');
            }
        }
        else if ($httpResponse->getStatusCode() === 404) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->error = $serializer->deserialize((string)$httpResponse->getBody(), 'array<string, mixed>', 'json');
            }
        }

        return $response;
    }
	
    /**
     * List known hosts
     * 
     * Find repository level known hosts.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetRepositoryPipelineKnownHostsRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\GetRepositoryPipelineKnownHostsResponse
     */
	public function getRepositoryPipelineKnownHosts(
        \OpenAPI\OpenAPI\Models\Operations\GetRepositoryPipelineKnownHostsRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\GetRepositoryPipelineKnownHostsResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/repositories/{workspace}/{repo_slug}/pipelines_config/ssh/known_hosts', \OpenAPI\OpenAPI\Models\Operations\GetRepositoryPipelineKnownHostsRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_defaultClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetRepositoryPipelineKnownHostsResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->paginatedPipelineKnownHosts = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\PaginatedPipelineKnownHosts', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Get a schedule
     * 
     * Retrieve a schedule by its UUID.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetRepositoryPipelineScheduleRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\GetRepositoryPipelineScheduleResponse
     */
	public function getRepositoryPipelineSchedule(
        \OpenAPI\OpenAPI\Models\Operations\GetRepositoryPipelineScheduleRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\GetRepositoryPipelineScheduleResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/repositories/{workspace}/{repo_slug}/pipelines_config/schedules/{schedule_uuid}', \OpenAPI\OpenAPI\Models\Operations\GetRepositoryPipelineScheduleRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_defaultClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetRepositoryPipelineScheduleResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->pipelineSchedule = $serializer->deserialize((string)$httpResponse->getBody(), 'array<string, mixed>', 'json');
            }
        }
        else if ($httpResponse->getStatusCode() === 404) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->error = $serializer->deserialize((string)$httpResponse->getBody(), 'array<string, mixed>', 'json');
            }
        }

        return $response;
    }
	
    /**
     * List executions of a schedule
     * 
     * Retrieve the executions of a given schedule.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetRepositoryPipelineScheduleExecutionsRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\GetRepositoryPipelineScheduleExecutionsResponse
     */
	public function getRepositoryPipelineScheduleExecutions(
        \OpenAPI\OpenAPI\Models\Operations\GetRepositoryPipelineScheduleExecutionsRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\GetRepositoryPipelineScheduleExecutionsResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/repositories/{workspace}/{repo_slug}/pipelines_config/schedules/{schedule_uuid}/executions', \OpenAPI\OpenAPI\Models\Operations\GetRepositoryPipelineScheduleExecutionsRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_defaultClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetRepositoryPipelineScheduleExecutionsResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->paginatedPipelineScheduleExecutions = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\PaginatedPipelineScheduleExecutions', 'json');
            }
        }
        else if ($httpResponse->getStatusCode() === 404) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->error = $serializer->deserialize((string)$httpResponse->getBody(), 'array<string, mixed>', 'json');
            }
        }

        return $response;
    }
	
    /**
     * List schedules
     * 
     * Retrieve the configured schedules for the given repository.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetRepositoryPipelineSchedulesRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\GetRepositoryPipelineSchedulesResponse
     */
	public function getRepositoryPipelineSchedules(
        \OpenAPI\OpenAPI\Models\Operations\GetRepositoryPipelineSchedulesRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\GetRepositoryPipelineSchedulesResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/repositories/{workspace}/{repo_slug}/pipelines_config/schedules', \OpenAPI\OpenAPI\Models\Operations\GetRepositoryPipelineSchedulesRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_defaultClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetRepositoryPipelineSchedulesResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->paginatedPipelineSchedules = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\PaginatedPipelineSchedules', 'json');
            }
        }
        else if ($httpResponse->getStatusCode() === 404) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->error = $serializer->deserialize((string)$httpResponse->getBody(), 'array<string, mixed>', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Get SSH key pair
     * 
     * Retrieve the repository SSH key pair excluding the SSH private key. The private key is a write only field and will never be exposed in the logs or the REST API.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetRepositoryPipelineSshKeyPairRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\GetRepositoryPipelineSshKeyPairResponse
     */
	public function getRepositoryPipelineSshKeyPair(
        \OpenAPI\OpenAPI\Models\Operations\GetRepositoryPipelineSshKeyPairRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\GetRepositoryPipelineSshKeyPairResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/repositories/{workspace}/{repo_slug}/pipelines_config/ssh/key_pair', \OpenAPI\OpenAPI\Models\Operations\GetRepositoryPipelineSshKeyPairRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_defaultClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetRepositoryPipelineSshKeyPairResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->pipelineSshKeyPair = $serializer->deserialize((string)$httpResponse->getBody(), 'array<string, mixed>', 'json');
            }
        }
        else if ($httpResponse->getStatusCode() === 404) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->error = $serializer->deserialize((string)$httpResponse->getBody(), 'array<string, mixed>', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Get a variable for a repository
     * 
     * Retrieve a repository level variable.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetRepositoryPipelineVariableRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\GetRepositoryPipelineVariableResponse
     */
	public function getRepositoryPipelineVariable(
        \OpenAPI\OpenAPI\Models\Operations\GetRepositoryPipelineVariableRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\GetRepositoryPipelineVariableResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/repositories/{workspace}/{repo_slug}/pipelines_config/variables/{variable_uuid}', \OpenAPI\OpenAPI\Models\Operations\GetRepositoryPipelineVariableRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_defaultClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetRepositoryPipelineVariableResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->pipelineVariable = $serializer->deserialize((string)$httpResponse->getBody(), 'array<string, mixed>', 'json');
            }
        }
        else if ($httpResponse->getStatusCode() === 404) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->error = $serializer->deserialize((string)$httpResponse->getBody(), 'array<string, mixed>', 'json');
            }
        }

        return $response;
    }
	
    /**
     * List variables for a repository
     * 
     * Find repository level variables.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetRepositoryPipelineVariablesRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\GetRepositoryPipelineVariablesResponse
     */
	public function getRepositoryPipelineVariables(
        \OpenAPI\OpenAPI\Models\Operations\GetRepositoryPipelineVariablesRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\GetRepositoryPipelineVariablesResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/repositories/{workspace}/{repo_slug}/pipelines_config/variables', \OpenAPI\OpenAPI\Models\Operations\GetRepositoryPipelineVariablesRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_defaultClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetRepositoryPipelineVariablesResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->paginatedPipelineVariables = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\PaginatedPipelineVariables', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Stop a pipeline
     * 
     * Signal the stop of a pipeline and all of its steps that not have completed yet.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\StopPipelineRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\StopPipelineResponse
     */
	public function stopPipeline(
        \OpenAPI\OpenAPI\Models\Operations\StopPipelineRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\StopPipelineResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/repositories/{workspace}/{repo_slug}/pipelines/{pipeline_uuid}/stopPipeline', \OpenAPI\OpenAPI\Models\Operations\StopPipelineRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_defaultClient->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\StopPipelineResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 204) {
        }
        else if ($httpResponse->getStatusCode() === 400 or $httpResponse->getStatusCode() === 404) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->error = $serializer->deserialize((string)$httpResponse->getBody(), 'array<string, mixed>', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Update a variable for an environment
     * 
     * Update a deployment environment level variable.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\UpdateDeploymentVariableRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\UpdateDeploymentVariableResponse
     */
	public function updateDeploymentVariable(
        \OpenAPI\OpenAPI\Models\Operations\UpdateDeploymentVariableRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\UpdateDeploymentVariableResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/repositories/{workspace}/{repo_slug}/deployments_config/environments/{environment_uuid}/variables/{variable_uuid}', \OpenAPI\OpenAPI\Models\Operations\UpdateDeploymentVariableRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "requestBody", "json");
        if ($body === null) {
            throw new \Exception('Request body is required');
        }
        $options = array_merge_recursive($options, $body);
        
        $httpResponse = $this->_defaultClient->request('PUT', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\UpdateDeploymentVariableResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->deploymentVariable = $serializer->deserialize((string)$httpResponse->getBody(), 'array<string, mixed>', 'json');
            }
        }
        else if ($httpResponse->getStatusCode() === 404) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->error = $serializer->deserialize((string)$httpResponse->getBody(), 'array<string, mixed>', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Update a variable for a team
     * 
     * Update a team level variable.
     * This endpoint has been deprecated, and you should use the new workspaces endpoint. For more information, see [the announcement](https://developer.atlassian.com/cloud/bitbucket/bitbucket-api-teams-deprecation/).
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\UpdatePipelineVariableForTeamRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\UpdatePipelineVariableForTeamResponse
     * @deprecated this method will be removed in a future release, please migrate away from it as soon as possible
     */
	public function updatePipelineVariableForTeam(
        \OpenAPI\OpenAPI\Models\Operations\UpdatePipelineVariableForTeamRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\UpdatePipelineVariableForTeamResponse
    {
        trigger_error('Method ' . __METHOD__ . ' is deprecated', E_USER_DEPRECATED);
        
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/teams/{username}/pipelines_config/variables/{variable_uuid}', \OpenAPI\OpenAPI\Models\Operations\UpdatePipelineVariableForTeamRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "requestBody", "json");
        if ($body === null) {
            throw new \Exception('Request body is required');
        }
        $options = array_merge_recursive($options, $body);
        
        $httpResponse = $this->_defaultClient->request('PUT', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\UpdatePipelineVariableForTeamResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->pipelineVariable = $serializer->deserialize((string)$httpResponse->getBody(), 'array<string, mixed>', 'json');
            }
        }
        else if ($httpResponse->getStatusCode() === 404) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->error = $serializer->deserialize((string)$httpResponse->getBody(), 'array<string, mixed>', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Update a variable for a user
     * 
     * Update a user level variable.
     * This endpoint has been deprecated, and you should use the new workspaces endpoint. For more information, see [the announcement](https://developer.atlassian.com/cloud/bitbucket/bitbucket-api-teams-deprecation/).
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\UpdatePipelineVariableForUserRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\UpdatePipelineVariableForUserResponse
     * @deprecated this method will be removed in a future release, please migrate away from it as soon as possible
     */
	public function updatePipelineVariableForUser(
        \OpenAPI\OpenAPI\Models\Operations\UpdatePipelineVariableForUserRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\UpdatePipelineVariableForUserResponse
    {
        trigger_error('Method ' . __METHOD__ . ' is deprecated', E_USER_DEPRECATED);
        
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/users/{selected_user}/pipelines_config/variables/{variable_uuid}', \OpenAPI\OpenAPI\Models\Operations\UpdatePipelineVariableForUserRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "requestBody", "json");
        if ($body === null) {
            throw new \Exception('Request body is required');
        }
        $options = array_merge_recursive($options, $body);
        
        $httpResponse = $this->_defaultClient->request('PUT', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\UpdatePipelineVariableForUserResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->pipelineVariable = $serializer->deserialize((string)$httpResponse->getBody(), 'array<string, mixed>', 'json');
            }
        }
        else if ($httpResponse->getStatusCode() === 404) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->error = $serializer->deserialize((string)$httpResponse->getBody(), 'array<string, mixed>', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Update variable for a workspace
     * 
     * Update a workspace level variable.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\UpdatePipelineVariableForWorkspaceRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\UpdatePipelineVariableForWorkspaceResponse
     */
	public function updatePipelineVariableForWorkspace(
        \OpenAPI\OpenAPI\Models\Operations\UpdatePipelineVariableForWorkspaceRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\UpdatePipelineVariableForWorkspaceResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/workspaces/{workspace}/pipelines-config/variables/{variable_uuid}', \OpenAPI\OpenAPI\Models\Operations\UpdatePipelineVariableForWorkspaceRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "requestBody", "json");
        if ($body === null) {
            throw new \Exception('Request body is required');
        }
        $options = array_merge_recursive($options, $body);
        
        $httpResponse = $this->_defaultClient->request('PUT', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\UpdatePipelineVariableForWorkspaceResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->pipelineVariable = $serializer->deserialize((string)$httpResponse->getBody(), 'array<string, mixed>', 'json');
            }
        }
        else if ($httpResponse->getStatusCode() === 404) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->error = $serializer->deserialize((string)$httpResponse->getBody(), 'array<string, mixed>', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Update the next build number
     * 
     * Update the next build number that should be assigned to a pipeline. The next build number that will be configured has to be strictly higher than the current latest build number for this repository.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\UpdateRepositoryBuildNumberRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\UpdateRepositoryBuildNumberResponse
     */
	public function updateRepositoryBuildNumber(
        \OpenAPI\OpenAPI\Models\Operations\UpdateRepositoryBuildNumberRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\UpdateRepositoryBuildNumberResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/repositories/{workspace}/{repo_slug}/pipelines_config/build_number', \OpenAPI\OpenAPI\Models\Operations\UpdateRepositoryBuildNumberRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "requestBody", "json");
        if ($body === null) {
            throw new \Exception('Request body is required');
        }
        $options = array_merge_recursive($options, $body);
        
        $httpResponse = $this->_defaultClient->request('PUT', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\UpdateRepositoryBuildNumberResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->pipelineBuildNumber = $serializer->deserialize((string)$httpResponse->getBody(), 'array<string, mixed>', 'json');
            }
        }
        else if ($httpResponse->getStatusCode() === 400 or $httpResponse->getStatusCode() === 404) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->error = $serializer->deserialize((string)$httpResponse->getBody(), 'array<string, mixed>', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Update configuration
     * 
     * Update the pipelines configuration for a repository.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\UpdateRepositoryPipelineConfigRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\UpdateRepositoryPipelineConfigResponse
     */
	public function updateRepositoryPipelineConfig(
        \OpenAPI\OpenAPI\Models\Operations\UpdateRepositoryPipelineConfigRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\UpdateRepositoryPipelineConfigResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/repositories/{workspace}/{repo_slug}/pipelines_config', \OpenAPI\OpenAPI\Models\Operations\UpdateRepositoryPipelineConfigRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "requestBody", "json");
        if ($body === null) {
            throw new \Exception('Request body is required');
        }
        $options = array_merge_recursive($options, $body);
        
        $httpResponse = $this->_defaultClient->request('PUT', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\UpdateRepositoryPipelineConfigResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->pipelinesConfig = $serializer->deserialize((string)$httpResponse->getBody(), 'array<string, mixed>', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Update SSH key pair
     * 
     * Create or update the repository SSH key pair. The private key will be set as a default SSH identity in your build container.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\UpdateRepositoryPipelineKeyPairRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\UpdateRepositoryPipelineKeyPairResponse
     */
	public function updateRepositoryPipelineKeyPair(
        \OpenAPI\OpenAPI\Models\Operations\UpdateRepositoryPipelineKeyPairRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\UpdateRepositoryPipelineKeyPairResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/repositories/{workspace}/{repo_slug}/pipelines_config/ssh/key_pair', \OpenAPI\OpenAPI\Models\Operations\UpdateRepositoryPipelineKeyPairRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "requestBody", "json");
        if ($body === null) {
            throw new \Exception('Request body is required');
        }
        $options = array_merge_recursive($options, $body);
        
        $httpResponse = $this->_defaultClient->request('PUT', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\UpdateRepositoryPipelineKeyPairResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->pipelineSshKeyPair = $serializer->deserialize((string)$httpResponse->getBody(), 'array<string, mixed>', 'json');
            }
        }
        else if ($httpResponse->getStatusCode() === 404) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->error = $serializer->deserialize((string)$httpResponse->getBody(), 'array<string, mixed>', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Update a known host
     * 
     * Update a repository level known host.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\UpdateRepositoryPipelineKnownHostRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\UpdateRepositoryPipelineKnownHostResponse
     */
	public function updateRepositoryPipelineKnownHost(
        \OpenAPI\OpenAPI\Models\Operations\UpdateRepositoryPipelineKnownHostRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\UpdateRepositoryPipelineKnownHostResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/repositories/{workspace}/{repo_slug}/pipelines_config/ssh/known_hosts/{known_host_uuid}', \OpenAPI\OpenAPI\Models\Operations\UpdateRepositoryPipelineKnownHostRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "requestBody", "json");
        if ($body === null) {
            throw new \Exception('Request body is required');
        }
        $options = array_merge_recursive($options, $body);
        
        $httpResponse = $this->_defaultClient->request('PUT', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\UpdateRepositoryPipelineKnownHostResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->pipelineKnownHost = $serializer->deserialize((string)$httpResponse->getBody(), 'array<string, mixed>', 'json');
            }
        }
        else if ($httpResponse->getStatusCode() === 404) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->error = $serializer->deserialize((string)$httpResponse->getBody(), 'array<string, mixed>', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Update a schedule
     * 
     * Update a schedule.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\UpdateRepositoryPipelineScheduleRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\UpdateRepositoryPipelineScheduleResponse
     */
	public function updateRepositoryPipelineSchedule(
        \OpenAPI\OpenAPI\Models\Operations\UpdateRepositoryPipelineScheduleRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\UpdateRepositoryPipelineScheduleResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/repositories/{workspace}/{repo_slug}/pipelines_config/schedules/{schedule_uuid}', \OpenAPI\OpenAPI\Models\Operations\UpdateRepositoryPipelineScheduleRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "requestBody", "json");
        if ($body === null) {
            throw new \Exception('Request body is required');
        }
        $options = array_merge_recursive($options, $body);
        
        $httpResponse = $this->_defaultClient->request('PUT', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\UpdateRepositoryPipelineScheduleResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->pipelineSchedule = $serializer->deserialize((string)$httpResponse->getBody(), 'array<string, mixed>', 'json');
            }
        }
        else if ($httpResponse->getStatusCode() === 404) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->error = $serializer->deserialize((string)$httpResponse->getBody(), 'array<string, mixed>', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Update a variable for a repository
     * 
     * Update a repository level variable.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\UpdateRepositoryPipelineVariableRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\UpdateRepositoryPipelineVariableResponse
     */
	public function updateRepositoryPipelineVariable(
        \OpenAPI\OpenAPI\Models\Operations\UpdateRepositoryPipelineVariableRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\UpdateRepositoryPipelineVariableResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/repositories/{workspace}/{repo_slug}/pipelines_config/variables/{variable_uuid}', \OpenAPI\OpenAPI\Models\Operations\UpdateRepositoryPipelineVariableRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "requestBody", "json");
        if ($body === null) {
            throw new \Exception('Request body is required');
        }
        $options = array_merge_recursive($options, $body);
        
        $httpResponse = $this->_defaultClient->request('PUT', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\UpdateRepositoryPipelineVariableResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->pipelineVariable = $serializer->deserialize((string)$httpResponse->getBody(), 'array<string, mixed>', 'json');
            }
        }
        else if ($httpResponse->getStatusCode() === 404) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->error = $serializer->deserialize((string)$httpResponse->getBody(), 'array<string, mixed>', 'json');
            }
        }

        return $response;
    }
}