// Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.

package shared

import (
	"encoding/json"
	"fmt"
)

// UpdateIntegrationResultConnectionTypeEnum - The type of the network connection to the integration endpoint. Specify INTERNET for connections through the public routable internet or VPC_LINK for private connections between API Gateway and resources in a VPC. The default value is INTERNET.
type UpdateIntegrationResultConnectionTypeEnum string

const (
	UpdateIntegrationResultConnectionTypeEnumInternet UpdateIntegrationResultConnectionTypeEnum = "INTERNET"
	UpdateIntegrationResultConnectionTypeEnumVpcLink  UpdateIntegrationResultConnectionTypeEnum = "VPC_LINK"
)

func (e UpdateIntegrationResultConnectionTypeEnum) ToPointer() *UpdateIntegrationResultConnectionTypeEnum {
	return &e
}

func (e *UpdateIntegrationResultConnectionTypeEnum) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "INTERNET":
		fallthrough
	case "VPC_LINK":
		*e = UpdateIntegrationResultConnectionTypeEnum(v)
		return nil
	default:
		return fmt.Errorf("invalid value for UpdateIntegrationResultConnectionTypeEnum: %v", v)
	}
}

// UpdateIntegrationResultContentHandlingStrategyEnum - <p>Supported only for WebSocket APIs. Specifies how to handle response payload content type conversions. Supported values are CONVERT_TO_BINARY and CONVERT_TO_TEXT, with the following behaviors:</p> <p>CONVERT_TO_BINARY: Converts a response payload from a Base64-encoded string to the corresponding binary blob.</p> <p>CONVERT_TO_TEXT: Converts a response payload from a binary blob to a Base64-encoded string.</p> <p>If this property is not defined, the response payload will be passed through from the integration response to the route response or method response without modification.</p>
type UpdateIntegrationResultContentHandlingStrategyEnum string

const (
	UpdateIntegrationResultContentHandlingStrategyEnumConvertToBinary UpdateIntegrationResultContentHandlingStrategyEnum = "CONVERT_TO_BINARY"
	UpdateIntegrationResultContentHandlingStrategyEnumConvertToText   UpdateIntegrationResultContentHandlingStrategyEnum = "CONVERT_TO_TEXT"
)

func (e UpdateIntegrationResultContentHandlingStrategyEnum) ToPointer() *UpdateIntegrationResultContentHandlingStrategyEnum {
	return &e
}

func (e *UpdateIntegrationResultContentHandlingStrategyEnum) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "CONVERT_TO_BINARY":
		fallthrough
	case "CONVERT_TO_TEXT":
		*e = UpdateIntegrationResultContentHandlingStrategyEnum(v)
		return nil
	default:
		return fmt.Errorf("invalid value for UpdateIntegrationResultContentHandlingStrategyEnum: %v", v)
	}
}

// UpdateIntegrationResultIntegrationTypeEnum - <p>The integration type of an integration. One of the following:</p> <p>AWS: for integrating the route or method request with an AWS service action, including the Lambda function-invoking action. With the Lambda function-invoking action, this is referred to as the Lambda custom integration. With any other AWS service action, this is known as AWS integration. Supported only for WebSocket APIs.</p> <p>AWS_PROXY: for integrating the route or method request with a Lambda function or other AWS service action. This integration is also referred to as a Lambda proxy integration.</p> <p>HTTP: for integrating the route or method request with an HTTP endpoint. This integration is also referred to as the HTTP custom integration. Supported only for WebSocket APIs.</p> <p>HTTP_PROXY: for integrating the route or method request with an HTTP endpoint, with the client request passed through as-is. This is also referred to as HTTP proxy integration.</p> <p>MOCK: for integrating the route or method request with API Gateway as a "loopback" endpoint without invoking any backend. Supported only for WebSocket APIs.</p>
type UpdateIntegrationResultIntegrationTypeEnum string

const (
	UpdateIntegrationResultIntegrationTypeEnumAws       UpdateIntegrationResultIntegrationTypeEnum = "AWS"
	UpdateIntegrationResultIntegrationTypeEnumHTTP      UpdateIntegrationResultIntegrationTypeEnum = "HTTP"
	UpdateIntegrationResultIntegrationTypeEnumMock      UpdateIntegrationResultIntegrationTypeEnum = "MOCK"
	UpdateIntegrationResultIntegrationTypeEnumHTTPProxy UpdateIntegrationResultIntegrationTypeEnum = "HTTP_PROXY"
	UpdateIntegrationResultIntegrationTypeEnumAwsProxy  UpdateIntegrationResultIntegrationTypeEnum = "AWS_PROXY"
)

func (e UpdateIntegrationResultIntegrationTypeEnum) ToPointer() *UpdateIntegrationResultIntegrationTypeEnum {
	return &e
}

func (e *UpdateIntegrationResultIntegrationTypeEnum) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "AWS":
		fallthrough
	case "HTTP":
		fallthrough
	case "MOCK":
		fallthrough
	case "HTTP_PROXY":
		fallthrough
	case "AWS_PROXY":
		*e = UpdateIntegrationResultIntegrationTypeEnum(v)
		return nil
	default:
		return fmt.Errorf("invalid value for UpdateIntegrationResultIntegrationTypeEnum: %v", v)
	}
}

// UpdateIntegrationResultPassthroughBehaviorEnum - <p>Specifies the pass-through behavior for incoming requests based on the Content-Type header in the request, and the available mapping templates specified as the requestTemplates property on the Integration resource. There are three valid values: WHEN_NO_MATCH, WHEN_NO_TEMPLATES, and NEVER. Supported only for WebSocket APIs.</p> <p>WHEN_NO_MATCH passes the request body for unmapped content types through to the integration backend without transformation.</p> <p>NEVER rejects unmapped content types with an HTTP 415 Unsupported Media Type response.</p> <p>WHEN_NO_TEMPLATES allows pass-through when the integration has no content types mapped to templates. However, if there is at least one content type defined, unmapped content types will be rejected with the same HTTP 415 Unsupported Media Type response.</p>
type UpdateIntegrationResultPassthroughBehaviorEnum string

const (
	UpdateIntegrationResultPassthroughBehaviorEnumWhenNoMatch     UpdateIntegrationResultPassthroughBehaviorEnum = "WHEN_NO_MATCH"
	UpdateIntegrationResultPassthroughBehaviorEnumNever           UpdateIntegrationResultPassthroughBehaviorEnum = "NEVER"
	UpdateIntegrationResultPassthroughBehaviorEnumWhenNoTemplates UpdateIntegrationResultPassthroughBehaviorEnum = "WHEN_NO_TEMPLATES"
)

func (e UpdateIntegrationResultPassthroughBehaviorEnum) ToPointer() *UpdateIntegrationResultPassthroughBehaviorEnum {
	return &e
}

func (e *UpdateIntegrationResultPassthroughBehaviorEnum) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "WHEN_NO_MATCH":
		fallthrough
	case "NEVER":
		fallthrough
	case "WHEN_NO_TEMPLATES":
		*e = UpdateIntegrationResultPassthroughBehaviorEnum(v)
		return nil
	default:
		return fmt.Errorf("invalid value for UpdateIntegrationResultPassthroughBehaviorEnum: %v", v)
	}
}

// UpdateIntegrationResultTLSConfig - The TLS configuration for a private integration. If you specify a TLS configuration, private integration traffic uses the HTTPS protocol. Supported only for HTTP APIs.
type UpdateIntegrationResultTLSConfig struct {
	ServerNameToVerify *string `json:"ServerNameToVerify,omitempty"`
}

// UpdateIntegrationResult - Success
type UpdateIntegrationResult struct {
	APIGatewayManaged                      *bool                                               `json:"ApiGatewayManaged,omitempty"`
	ConnectionID                           *string                                             `json:"ConnectionId,omitempty"`
	ConnectionType                         *UpdateIntegrationResultConnectionTypeEnum          `json:"ConnectionType,omitempty"`
	ContentHandlingStrategy                *UpdateIntegrationResultContentHandlingStrategyEnum `json:"ContentHandlingStrategy,omitempty"`
	CredentialsArn                         *string                                             `json:"CredentialsArn,omitempty"`
	Description                            *string                                             `json:"Description,omitempty"`
	IntegrationID                          *string                                             `json:"IntegrationId,omitempty"`
	IntegrationMethod                      *string                                             `json:"IntegrationMethod,omitempty"`
	IntegrationResponseSelectionExpression *string                                             `json:"IntegrationResponseSelectionExpression,omitempty"`
	IntegrationSubtype                     *string                                             `json:"IntegrationSubtype,omitempty"`
	IntegrationType                        *UpdateIntegrationResultIntegrationTypeEnum         `json:"IntegrationType,omitempty"`
	IntegrationURI                         *string                                             `json:"IntegrationUri,omitempty"`
	PassthroughBehavior                    *UpdateIntegrationResultPassthroughBehaviorEnum     `json:"PassthroughBehavior,omitempty"`
	PayloadFormatVersion                   *string                                             `json:"PayloadFormatVersion,omitempty"`
	RequestParameters                      map[string]string                                   `json:"RequestParameters,omitempty"`
	RequestTemplates                       map[string]string                                   `json:"RequestTemplates,omitempty"`
	ResponseParameters                     map[string]map[string]string                        `json:"ResponseParameters,omitempty"`
	TemplateSelectionExpression            *string                                             `json:"TemplateSelectionExpression,omitempty"`
	TimeoutInMillis                        *int64                                              `json:"TimeoutInMillis,omitempty"`
	TLSConfig                              *UpdateIntegrationResultTLSConfig                   `json:"TlsConfig,omitempty"`
}
