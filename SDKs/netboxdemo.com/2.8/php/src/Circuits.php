<?php

/**
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

declare(strict_types=1);

namespace OpenAPI\OpenAPI;

class Circuits 
{

	// SDK private variables namespaced with _ to avoid conflicts with API models
	private \GuzzleHttp\ClientInterface $_defaultClient;
	private \GuzzleHttp\ClientInterface $_securityClient;
	private string $_serverUrl;
	private string $_language;
	private string $_sdkVersion;
	private string $_genVersion;	

	/**
	 * @param \GuzzleHttp\ClientInterface $defaultClient
	 * @param \GuzzleHttp\ClientInterface $securityClient
	 * @param string $serverUrl
	 * @param string $language
	 * @param string $sdkVersion
	 * @param string $genVersion
	 */
	public function __construct(\GuzzleHttp\ClientInterface $defaultClient, \GuzzleHttp\ClientInterface $securityClient, string $serverUrl, string $language, string $sdkVersion, string $genVersion)
	{
		$this->_defaultClient = $defaultClient;
		$this->_securityClient = $securityClient;
		$this->_serverUrl = $serverUrl;
		$this->_language = $language;
		$this->_sdkVersion = $sdkVersion;
		$this->_genVersion = $genVersion;
	}
	
    /**
     * circuitsCircuitTerminationsCreate
     * 
     * @param \OpenAPI\OpenAPI\Models\Shared\WritableCircuitTerminationInput $request
     * @return \OpenAPI\OpenAPI\Models\Operations\CircuitsCircuitTerminationsCreateResponse
     */
	public function circuitsCircuitTerminationsCreate(
        \OpenAPI\OpenAPI\Models\Shared\WritableCircuitTerminationInput $request,
    ): \OpenAPI\OpenAPI\Models\Operations\CircuitsCircuitTerminationsCreateResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/circuits/circuit-terminations/');
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "request", "json");
        if ($body === null) {
            throw new \Exception('Request body is required');
        }
        $options = array_merge_recursive($options, $body);
        
        $httpResponse = $this->_securityClient->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\CircuitsCircuitTerminationsCreateResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 201) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->circuitTermination = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\CircuitTermination', 'json');
            }
        }

        return $response;
    }
	
    /**
     * circuitsCircuitTerminationsDelete
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\CircuitsCircuitTerminationsDeleteRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\CircuitsCircuitTerminationsDeleteResponse
     */
	public function circuitsCircuitTerminationsDelete(
        \OpenAPI\OpenAPI\Models\Operations\CircuitsCircuitTerminationsDeleteRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\CircuitsCircuitTerminationsDeleteResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/circuits/circuit-terminations/{id}/', \OpenAPI\OpenAPI\Models\Operations\CircuitsCircuitTerminationsDeleteRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_securityClient->request('DELETE', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\CircuitsCircuitTerminationsDeleteResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 204) {
        }

        return $response;
    }
	
    /**
     * Call to super to allow for caching
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\CircuitsCircuitTerminationsListRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\CircuitsCircuitTerminationsListResponse
     */
	public function circuitsCircuitTerminationsList(
        \OpenAPI\OpenAPI\Models\Operations\CircuitsCircuitTerminationsListRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\CircuitsCircuitTerminationsListResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/circuits/circuit-terminations/');
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\CircuitsCircuitTerminationsListRequest::class, $request, null));
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\CircuitsCircuitTerminationsListResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->circuitsCircuitTerminationsList200ApplicationJSONObject = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Operations\CircuitsCircuitTerminationsList200ApplicationJSON', 'json');
            }
        }

        return $response;
    }
	
    /**
     * circuitsCircuitTerminationsPartialUpdate
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\CircuitsCircuitTerminationsPartialUpdateRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\CircuitsCircuitTerminationsPartialUpdateResponse
     */
	public function circuitsCircuitTerminationsPartialUpdate(
        \OpenAPI\OpenAPI\Models\Operations\CircuitsCircuitTerminationsPartialUpdateRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\CircuitsCircuitTerminationsPartialUpdateResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/circuits/circuit-terminations/{id}/', \OpenAPI\OpenAPI\Models\Operations\CircuitsCircuitTerminationsPartialUpdateRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "writableCircuitTerminationInput", "json");
        if ($body === null) {
            throw new \Exception('Request body is required');
        }
        $options = array_merge_recursive($options, $body);
        
        $httpResponse = $this->_securityClient->request('PATCH', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\CircuitsCircuitTerminationsPartialUpdateResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->circuitTermination = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\CircuitTermination', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Call to super to allow for caching
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\CircuitsCircuitTerminationsReadRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\CircuitsCircuitTerminationsReadResponse
     */
	public function circuitsCircuitTerminationsRead(
        \OpenAPI\OpenAPI\Models\Operations\CircuitsCircuitTerminationsReadRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\CircuitsCircuitTerminationsReadResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/circuits/circuit-terminations/{id}/', \OpenAPI\OpenAPI\Models\Operations\CircuitsCircuitTerminationsReadRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\CircuitsCircuitTerminationsReadResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->circuitTermination = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\CircuitTermination', 'json');
            }
        }

        return $response;
    }
	
    /**
     * circuitsCircuitTerminationsUpdate
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\CircuitsCircuitTerminationsUpdateRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\CircuitsCircuitTerminationsUpdateResponse
     */
	public function circuitsCircuitTerminationsUpdate(
        \OpenAPI\OpenAPI\Models\Operations\CircuitsCircuitTerminationsUpdateRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\CircuitsCircuitTerminationsUpdateResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/circuits/circuit-terminations/{id}/', \OpenAPI\OpenAPI\Models\Operations\CircuitsCircuitTerminationsUpdateRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "writableCircuitTerminationInput", "json");
        if ($body === null) {
            throw new \Exception('Request body is required');
        }
        $options = array_merge_recursive($options, $body);
        
        $httpResponse = $this->_securityClient->request('PUT', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\CircuitsCircuitTerminationsUpdateResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->circuitTermination = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\CircuitTermination', 'json');
            }
        }

        return $response;
    }
	
    /**
     * circuitsCircuitTypesCreate
     * 
     * @param \OpenAPI\OpenAPI\Models\Shared\CircuitTypeInput $request
     * @return \OpenAPI\OpenAPI\Models\Operations\CircuitsCircuitTypesCreateResponse
     */
	public function circuitsCircuitTypesCreate(
        \OpenAPI\OpenAPI\Models\Shared\CircuitTypeInput $request,
    ): \OpenAPI\OpenAPI\Models\Operations\CircuitsCircuitTypesCreateResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/circuits/circuit-types/');
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "request", "json");
        if ($body === null) {
            throw new \Exception('Request body is required');
        }
        $options = array_merge_recursive($options, $body);
        
        $httpResponse = $this->_securityClient->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\CircuitsCircuitTypesCreateResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 201) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->circuitType = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\CircuitType', 'json');
            }
        }

        return $response;
    }
	
    /**
     * circuitsCircuitTypesDelete
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\CircuitsCircuitTypesDeleteRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\CircuitsCircuitTypesDeleteResponse
     */
	public function circuitsCircuitTypesDelete(
        \OpenAPI\OpenAPI\Models\Operations\CircuitsCircuitTypesDeleteRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\CircuitsCircuitTypesDeleteResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/circuits/circuit-types/{id}/', \OpenAPI\OpenAPI\Models\Operations\CircuitsCircuitTypesDeleteRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_securityClient->request('DELETE', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\CircuitsCircuitTypesDeleteResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 204) {
        }

        return $response;
    }
	
    /**
     * Call to super to allow for caching
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\CircuitsCircuitTypesListRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\CircuitsCircuitTypesListResponse
     */
	public function circuitsCircuitTypesList(
        \OpenAPI\OpenAPI\Models\Operations\CircuitsCircuitTypesListRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\CircuitsCircuitTypesListResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/circuits/circuit-types/');
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\CircuitsCircuitTypesListRequest::class, $request, null));
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\CircuitsCircuitTypesListResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->circuitsCircuitTypesList200ApplicationJSONObject = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Operations\CircuitsCircuitTypesList200ApplicationJSON', 'json');
            }
        }

        return $response;
    }
	
    /**
     * circuitsCircuitTypesPartialUpdate
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\CircuitsCircuitTypesPartialUpdateRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\CircuitsCircuitTypesPartialUpdateResponse
     */
	public function circuitsCircuitTypesPartialUpdate(
        \OpenAPI\OpenAPI\Models\Operations\CircuitsCircuitTypesPartialUpdateRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\CircuitsCircuitTypesPartialUpdateResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/circuits/circuit-types/{id}/', \OpenAPI\OpenAPI\Models\Operations\CircuitsCircuitTypesPartialUpdateRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "circuitTypeInput", "json");
        if ($body === null) {
            throw new \Exception('Request body is required');
        }
        $options = array_merge_recursive($options, $body);
        
        $httpResponse = $this->_securityClient->request('PATCH', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\CircuitsCircuitTypesPartialUpdateResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->circuitType = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\CircuitType', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Call to super to allow for caching
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\CircuitsCircuitTypesReadRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\CircuitsCircuitTypesReadResponse
     */
	public function circuitsCircuitTypesRead(
        \OpenAPI\OpenAPI\Models\Operations\CircuitsCircuitTypesReadRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\CircuitsCircuitTypesReadResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/circuits/circuit-types/{id}/', \OpenAPI\OpenAPI\Models\Operations\CircuitsCircuitTypesReadRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\CircuitsCircuitTypesReadResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->circuitType = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\CircuitType', 'json');
            }
        }

        return $response;
    }
	
    /**
     * circuitsCircuitTypesUpdate
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\CircuitsCircuitTypesUpdateRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\CircuitsCircuitTypesUpdateResponse
     */
	public function circuitsCircuitTypesUpdate(
        \OpenAPI\OpenAPI\Models\Operations\CircuitsCircuitTypesUpdateRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\CircuitsCircuitTypesUpdateResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/circuits/circuit-types/{id}/', \OpenAPI\OpenAPI\Models\Operations\CircuitsCircuitTypesUpdateRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "circuitTypeInput", "json");
        if ($body === null) {
            throw new \Exception('Request body is required');
        }
        $options = array_merge_recursive($options, $body);
        
        $httpResponse = $this->_securityClient->request('PUT', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\CircuitsCircuitTypesUpdateResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->circuitType = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\CircuitType', 'json');
            }
        }

        return $response;
    }
	
    /**
     * circuitsCircuitsCreate
     * 
     * @param \OpenAPI\OpenAPI\Models\Shared\WritableCircuitInput $request
     * @return \OpenAPI\OpenAPI\Models\Operations\CircuitsCircuitsCreateResponse
     */
	public function circuitsCircuitsCreate(
        \OpenAPI\OpenAPI\Models\Shared\WritableCircuitInput $request,
    ): \OpenAPI\OpenAPI\Models\Operations\CircuitsCircuitsCreateResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/circuits/circuits/');
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "request", "json");
        if ($body === null) {
            throw new \Exception('Request body is required');
        }
        $options = array_merge_recursive($options, $body);
        
        $httpResponse = $this->_securityClient->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\CircuitsCircuitsCreateResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 201) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->circuit = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\Circuit', 'json');
            }
        }

        return $response;
    }
	
    /**
     * circuitsCircuitsDelete
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\CircuitsCircuitsDeleteRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\CircuitsCircuitsDeleteResponse
     */
	public function circuitsCircuitsDelete(
        \OpenAPI\OpenAPI\Models\Operations\CircuitsCircuitsDeleteRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\CircuitsCircuitsDeleteResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/circuits/circuits/{id}/', \OpenAPI\OpenAPI\Models\Operations\CircuitsCircuitsDeleteRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_securityClient->request('DELETE', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\CircuitsCircuitsDeleteResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 204) {
        }

        return $response;
    }
	
    /**
     * Call to super to allow for caching
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\CircuitsCircuitsListRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\CircuitsCircuitsListResponse
     */
	public function circuitsCircuitsList(
        \OpenAPI\OpenAPI\Models\Operations\CircuitsCircuitsListRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\CircuitsCircuitsListResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/circuits/circuits/');
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\CircuitsCircuitsListRequest::class, $request, null));
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\CircuitsCircuitsListResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->circuitsCircuitsList200ApplicationJSONObject = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Operations\CircuitsCircuitsList200ApplicationJSON', 'json');
            }
        }

        return $response;
    }
	
    /**
     * circuitsCircuitsPartialUpdate
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\CircuitsCircuitsPartialUpdateRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\CircuitsCircuitsPartialUpdateResponse
     */
	public function circuitsCircuitsPartialUpdate(
        \OpenAPI\OpenAPI\Models\Operations\CircuitsCircuitsPartialUpdateRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\CircuitsCircuitsPartialUpdateResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/circuits/circuits/{id}/', \OpenAPI\OpenAPI\Models\Operations\CircuitsCircuitsPartialUpdateRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "writableCircuitInput", "json");
        if ($body === null) {
            throw new \Exception('Request body is required');
        }
        $options = array_merge_recursive($options, $body);
        
        $httpResponse = $this->_securityClient->request('PATCH', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\CircuitsCircuitsPartialUpdateResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->circuit = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\Circuit', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Call to super to allow for caching
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\CircuitsCircuitsReadRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\CircuitsCircuitsReadResponse
     */
	public function circuitsCircuitsRead(
        \OpenAPI\OpenAPI\Models\Operations\CircuitsCircuitsReadRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\CircuitsCircuitsReadResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/circuits/circuits/{id}/', \OpenAPI\OpenAPI\Models\Operations\CircuitsCircuitsReadRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\CircuitsCircuitsReadResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->circuit = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\Circuit', 'json');
            }
        }

        return $response;
    }
	
    /**
     * circuitsCircuitsUpdate
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\CircuitsCircuitsUpdateRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\CircuitsCircuitsUpdateResponse
     */
	public function circuitsCircuitsUpdate(
        \OpenAPI\OpenAPI\Models\Operations\CircuitsCircuitsUpdateRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\CircuitsCircuitsUpdateResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/circuits/circuits/{id}/', \OpenAPI\OpenAPI\Models\Operations\CircuitsCircuitsUpdateRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "writableCircuitInput", "json");
        if ($body === null) {
            throw new \Exception('Request body is required');
        }
        $options = array_merge_recursive($options, $body);
        
        $httpResponse = $this->_securityClient->request('PUT', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\CircuitsCircuitsUpdateResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->circuit = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\Circuit', 'json');
            }
        }

        return $response;
    }
	
    /**
     * circuitsProvidersCreate
     * 
     * @param \OpenAPI\OpenAPI\Models\Shared\ProviderInput $request
     * @return \OpenAPI\OpenAPI\Models\Operations\CircuitsProvidersCreateResponse
     */
	public function circuitsProvidersCreate(
        \OpenAPI\OpenAPI\Models\Shared\ProviderInput $request,
    ): \OpenAPI\OpenAPI\Models\Operations\CircuitsProvidersCreateResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/circuits/providers/');
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "request", "json");
        if ($body === null) {
            throw new \Exception('Request body is required');
        }
        $options = array_merge_recursive($options, $body);
        
        $httpResponse = $this->_securityClient->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\CircuitsProvidersCreateResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 201) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->provider = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\Provider', 'json');
            }
        }

        return $response;
    }
	
    /**
     * circuitsProvidersDelete
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\CircuitsProvidersDeleteRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\CircuitsProvidersDeleteResponse
     */
	public function circuitsProvidersDelete(
        \OpenAPI\OpenAPI\Models\Operations\CircuitsProvidersDeleteRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\CircuitsProvidersDeleteResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/circuits/providers/{id}/', \OpenAPI\OpenAPI\Models\Operations\CircuitsProvidersDeleteRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_securityClient->request('DELETE', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\CircuitsProvidersDeleteResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 204) {
        }

        return $response;
    }
	
    /**
     * A convenience method for rendering graphs for a particular provider.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\CircuitsProvidersGraphsRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\CircuitsProvidersGraphsResponse
     */
	public function circuitsProvidersGraphs(
        \OpenAPI\OpenAPI\Models\Operations\CircuitsProvidersGraphsRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\CircuitsProvidersGraphsResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/circuits/providers/{id}/graphs/', \OpenAPI\OpenAPI\Models\Operations\CircuitsProvidersGraphsRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\CircuitsProvidersGraphsResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->provider = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\Provider', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Call to super to allow for caching
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\CircuitsProvidersListRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\CircuitsProvidersListResponse
     */
	public function circuitsProvidersList(
        \OpenAPI\OpenAPI\Models\Operations\CircuitsProvidersListRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\CircuitsProvidersListResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/circuits/providers/');
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\CircuitsProvidersListRequest::class, $request, null));
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\CircuitsProvidersListResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->circuitsProvidersList200ApplicationJSONObject = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Operations\CircuitsProvidersList200ApplicationJSON', 'json');
            }
        }

        return $response;
    }
	
    /**
     * circuitsProvidersPartialUpdate
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\CircuitsProvidersPartialUpdateRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\CircuitsProvidersPartialUpdateResponse
     */
	public function circuitsProvidersPartialUpdate(
        \OpenAPI\OpenAPI\Models\Operations\CircuitsProvidersPartialUpdateRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\CircuitsProvidersPartialUpdateResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/circuits/providers/{id}/', \OpenAPI\OpenAPI\Models\Operations\CircuitsProvidersPartialUpdateRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "providerInput", "json");
        if ($body === null) {
            throw new \Exception('Request body is required');
        }
        $options = array_merge_recursive($options, $body);
        
        $httpResponse = $this->_securityClient->request('PATCH', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\CircuitsProvidersPartialUpdateResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->provider = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\Provider', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Call to super to allow for caching
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\CircuitsProvidersReadRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\CircuitsProvidersReadResponse
     */
	public function circuitsProvidersRead(
        \OpenAPI\OpenAPI\Models\Operations\CircuitsProvidersReadRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\CircuitsProvidersReadResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/circuits/providers/{id}/', \OpenAPI\OpenAPI\Models\Operations\CircuitsProvidersReadRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\CircuitsProvidersReadResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->provider = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\Provider', 'json');
            }
        }

        return $response;
    }
	
    /**
     * circuitsProvidersUpdate
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\CircuitsProvidersUpdateRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\CircuitsProvidersUpdateResponse
     */
	public function circuitsProvidersUpdate(
        \OpenAPI\OpenAPI\Models\Operations\CircuitsProvidersUpdateRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\CircuitsProvidersUpdateResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/circuits/providers/{id}/', \OpenAPI\OpenAPI\Models\Operations\CircuitsProvidersUpdateRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "providerInput", "json");
        if ($body === null) {
            throw new \Exception('Request body is required');
        }
        $options = array_merge_recursive($options, $body);
        
        $httpResponse = $this->_securityClient->request('PUT', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\CircuitsProvidersUpdateResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->provider = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\Provider', 'json');
            }
        }

        return $response;
    }
}