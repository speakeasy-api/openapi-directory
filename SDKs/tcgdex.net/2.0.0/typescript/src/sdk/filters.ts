/*
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

import * as utils from "../internal/utils";
import * as operations from "./models/operations";
import * as shared from "./models/shared";
import { AxiosInstance, AxiosRequestConfig, AxiosResponse } from "axios";

/**
 * differents requests to filter cards
 */
export class Filters {
  _defaultClient: AxiosInstance;
  _securityClient: AxiosInstance;
  _serverURL: string;
  _language: string;
  _sdkVersion: string;
  _genVersion: string;

  constructor(
    defaultClient: AxiosInstance,
    securityClient: AxiosInstance,
    serverURL: string,
    language: string,
    sdkVersion: string,
    genVersion: string
  ) {
    this._defaultClient = defaultClient;
    this._securityClient = securityClient;
    this._serverURL = serverURL;
    this._language = language;
    this._sdkVersion = sdkVersion;
    this._genVersion = genVersion;
  }

  getCategories(
    config?: AxiosRequestConfig
  ): Promise<operations.GetCategoriesResponse> {
    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/categories";

    const client: AxiosInstance = this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetCategoriesResponse =
        new operations.GetCategoriesResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getCategories200ApplicationJSONStrings = utils.objectToClass(
              httpRes?.data
            );
          }
          break;
      }

      return res;
    });
  }

  getCategoriesCategory(
    req: operations.GetCategoriesCategoryRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetCategoriesCategoryResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetCategoriesCategoryRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/categories/{category}",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetCategoriesCategoryResponse =
        new operations.GetCategoriesCategoryResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.stringEndpoint = utils.objectToClass(
              httpRes?.data,
              shared.StringEndpoint
            );
          }
          break;
        case httpRes?.status == 404:
          break;
      }

      return res;
    });
  }

  getDexIds(
    config?: AxiosRequestConfig
  ): Promise<operations.GetDexIdsResponse> {
    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/dex-ids";

    const client: AxiosInstance = this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetDexIdsResponse =
        new operations.GetDexIdsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getDexIds200ApplicationJSONStrings = utils.objectToClass(
              httpRes?.data
            );
          }
          break;
      }

      return res;
    });
  }

  getDexIdsDexId(
    req: operations.GetDexIdsDexIdRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetDexIdsDexIdResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetDexIdsDexIdRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(baseURL, "/dex-ids/{dexId}", req);

    const client: AxiosInstance = this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetDexIdsDexIdResponse =
        new operations.GetDexIdsDexIdResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.cardResumes = [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.cardResumes = utils.objectToClass(
              httpRes?.data,
              shared.CardResume,
              resFieldDepth
            );
          }
          break;
        case httpRes?.status == 404:
          break;
      }

      return res;
    });
  }

  getEnergyTypes(
    config?: AxiosRequestConfig
  ): Promise<operations.GetEnergyTypesResponse> {
    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/energy-types";

    const client: AxiosInstance = this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetEnergyTypesResponse =
        new operations.GetEnergyTypesResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getEnergyTypes200ApplicationJSONStrings = utils.objectToClass(
              httpRes?.data
            );
          }
          break;
      }

      return res;
    });
  }

  getEnergyTypesEnergyType(
    req: operations.GetEnergyTypesEnergyTypeRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetEnergyTypesEnergyTypeResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetEnergyTypesEnergyTypeRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/energy-types/{energy-type}",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetEnergyTypesEnergyTypeResponse =
        new operations.GetEnergyTypesEnergyTypeResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.cardResumes = [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.cardResumes = utils.objectToClass(
              httpRes?.data,
              shared.CardResume,
              resFieldDepth
            );
          }
          break;
        case httpRes?.status == 404:
          break;
      }

      return res;
    });
  }

  getHp(config?: AxiosRequestConfig): Promise<operations.GetHpResponse> {
    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/hp";

    const client: AxiosInstance = this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetHpResponse = new operations.GetHpResponse({
        statusCode: httpRes.status,
        contentType: contentType,
        rawResponse: httpRes,
      });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getHp200ApplicationJSONStrings = utils.objectToClass(
              httpRes?.data
            );
          }
          break;
      }

      return res;
    });
  }

  getHpHp(
    req: operations.GetHpHpRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetHpHpResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetHpHpRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(baseURL, "/hp/{hp}", req);

    const client: AxiosInstance = this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetHpHpResponse = new operations.GetHpHpResponse({
        statusCode: httpRes.status,
        contentType: contentType,
        rawResponse: httpRes,
      });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.stringEndpoint = utils.objectToClass(
              httpRes?.data,
              shared.StringEndpoint
            );
          }
          break;
        case httpRes?.status == 404:
          break;
      }

      return res;
    });
  }

  getIllustrators(
    config?: AxiosRequestConfig
  ): Promise<operations.GetIllustratorsResponse> {
    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/illustrators";

    const client: AxiosInstance = this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetIllustratorsResponse =
        new operations.GetIllustratorsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getIllustrators200ApplicationJSONStrings = utils.objectToClass(
              httpRes?.data
            );
          }
          break;
      }

      return res;
    });
  }

  getIllustratorsIllustrator(
    req: operations.GetIllustratorsIllustratorRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetIllustratorsIllustratorResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetIllustratorsIllustratorRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/illustrators/{illustrator}",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetIllustratorsIllustratorResponse =
        new operations.GetIllustratorsIllustratorResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.stringEndpoint = utils.objectToClass(
              httpRes?.data,
              shared.StringEndpoint
            );
          }
          break;
        case httpRes?.status == 404:
          break;
      }

      return res;
    });
  }

  getRarities(
    config?: AxiosRequestConfig
  ): Promise<operations.GetRaritiesResponse> {
    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/rarities";

    const client: AxiosInstance = this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetRaritiesResponse =
        new operations.GetRaritiesResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getRarities200ApplicationJSONStrings = utils.objectToClass(
              httpRes?.data
            );
          }
          break;
      }

      return res;
    });
  }

  getRaritiesRarity(
    req: operations.GetRaritiesRarityRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetRaritiesRarityResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetRaritiesRarityRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(baseURL, "/rarities/{rarity}", req);

    const client: AxiosInstance = this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetRaritiesRarityResponse =
        new operations.GetRaritiesRarityResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.stringEndpoint = utils.objectToClass(
              httpRes?.data,
              shared.StringEndpoint
            );
          }
          break;
        case httpRes?.status == 404:
          break;
      }

      return res;
    });
  }

  getRegulationMarks(
    config?: AxiosRequestConfig
  ): Promise<operations.GetRegulationMarksResponse> {
    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/regulation-marks";

    const client: AxiosInstance = this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetRegulationMarksResponse =
        new operations.GetRegulationMarksResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getRegulationMarks200ApplicationJSONStrings =
              utils.objectToClass(httpRes?.data);
          }
          break;
      }

      return res;
    });
  }

  getRegulationMarksRegulationMark(
    req: operations.GetRegulationMarksRegulationMarkRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetRegulationMarksRegulationMarkResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetRegulationMarksRegulationMarkRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/regulation-marks/{regulation-mark}",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetRegulationMarksRegulationMarkResponse =
        new operations.GetRegulationMarksRegulationMarkResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.cardResumes = [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.cardResumes = utils.objectToClass(
              httpRes?.data,
              shared.CardResume,
              resFieldDepth
            );
          }
          break;
        case httpRes?.status == 404:
          break;
      }

      return res;
    });
  }

  getRetreats(
    config?: AxiosRequestConfig
  ): Promise<operations.GetRetreatsResponse> {
    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/retreats";

    const client: AxiosInstance = this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetRetreatsResponse =
        new operations.GetRetreatsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getRetreats200ApplicationJSONStrings = utils.objectToClass(
              httpRes?.data
            );
          }
          break;
      }

      return res;
    });
  }

  getRetreatsRetreat(
    req: operations.GetRetreatsRetreatRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetRetreatsRetreatResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetRetreatsRetreatRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(baseURL, "/retreats/{retreat}", req);

    const client: AxiosInstance = this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetRetreatsRetreatResponse =
        new operations.GetRetreatsRetreatResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.stringEndpoint = utils.objectToClass(
              httpRes?.data,
              shared.StringEndpoint
            );
          }
          break;
        case httpRes?.status == 404:
          break;
      }

      return res;
    });
  }

  getSeries(
    config?: AxiosRequestConfig
  ): Promise<operations.GetSeriesResponse> {
    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/series";

    const client: AxiosInstance = this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetSeriesResponse =
        new operations.GetSeriesResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.serieResumes = [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.serieResumes = utils.objectToClass(
              httpRes?.data,
              shared.SerieResume,
              resFieldDepth
            );
          }
          break;
      }

      return res;
    });
  }

  getSeriesSerie(
    req: operations.GetSeriesSerieRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetSeriesSerieResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetSeriesSerieRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(baseURL, "/series/{serie}", req);

    const client: AxiosInstance = this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetSeriesSerieResponse =
        new operations.GetSeriesSerieResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.serie = utils.objectToClass(httpRes?.data, shared.Serie);
          }
          break;
        case httpRes?.status == 404:
          break;
      }

      return res;
    });
  }

  getSets(config?: AxiosRequestConfig): Promise<operations.GetSetsResponse> {
    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/sets";

    const client: AxiosInstance = this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetSetsResponse = new operations.GetSetsResponse({
        statusCode: httpRes.status,
        contentType: contentType,
        rawResponse: httpRes,
      });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.setResumes = [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.setResumes = utils.objectToClass(
              httpRes?.data,
              shared.SetResume,
              resFieldDepth
            );
          }
          break;
      }

      return res;
    });
  }

  getSetsSet(
    req: operations.GetSetsSetRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetSetsSetResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetSetsSetRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(baseURL, "/sets/{set}", req);

    const client: AxiosInstance = this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetSetsSetResponse =
        new operations.GetSetsSetResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.set = utils.objectToClass(httpRes?.data, shared.Set);
          }
          break;
        case httpRes?.status == 404:
          break;
      }

      return res;
    });
  }

  getStages(
    config?: AxiosRequestConfig
  ): Promise<operations.GetStagesResponse> {
    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/stages";

    const client: AxiosInstance = this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetStagesResponse =
        new operations.GetStagesResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getStages200ApplicationJSONStrings = utils.objectToClass(
              httpRes?.data
            );
          }
          break;
      }

      return res;
    });
  }

  getStagesStage(
    req: operations.GetStagesStageRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetStagesStageResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetStagesStageRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(baseURL, "/stages/{stage}", req);

    const client: AxiosInstance = this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetStagesStageResponse =
        new operations.GetStagesStageResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.cardResumes = [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.cardResumes = utils.objectToClass(
              httpRes?.data,
              shared.CardResume,
              resFieldDepth
            );
          }
          break;
        case httpRes?.status == 404:
          break;
      }

      return res;
    });
  }

  getSuffixes(
    config?: AxiosRequestConfig
  ): Promise<operations.GetSuffixesResponse> {
    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/suffixes";

    const client: AxiosInstance = this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetSuffixesResponse =
        new operations.GetSuffixesResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getSuffixes200ApplicationJSONStrings = utils.objectToClass(
              httpRes?.data
            );
          }
          break;
      }

      return res;
    });
  }

  getSuffixesSuffix(
    req: operations.GetSuffixesSuffixRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetSuffixesSuffixResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetSuffixesSuffixRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(baseURL, "/suffixes/{suffix}", req);

    const client: AxiosInstance = this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetSuffixesSuffixResponse =
        new operations.GetSuffixesSuffixResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.cardResumes = [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.cardResumes = utils.objectToClass(
              httpRes?.data,
              shared.CardResume,
              resFieldDepth
            );
          }
          break;
        case httpRes?.status == 404:
          break;
      }

      return res;
    });
  }

  getTrainerTypes(
    config?: AxiosRequestConfig
  ): Promise<operations.GetTrainerTypesResponse> {
    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/trainer-types";

    const client: AxiosInstance = this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetTrainerTypesResponse =
        new operations.GetTrainerTypesResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getTrainerTypes200ApplicationJSONStrings = utils.objectToClass(
              httpRes?.data
            );
          }
          break;
      }

      return res;
    });
  }

  getTrainerTypesTrainerType(
    req: operations.GetTrainerTypesTrainerTypeRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetTrainerTypesTrainerTypeResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetTrainerTypesTrainerTypeRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/trainer-types/{trainer-type}",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetTrainerTypesTrainerTypeResponse =
        new operations.GetTrainerTypesTrainerTypeResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.cardResumes = [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.cardResumes = utils.objectToClass(
              httpRes?.data,
              shared.CardResume,
              resFieldDepth
            );
          }
          break;
        case httpRes?.status == 404:
          break;
      }

      return res;
    });
  }

  getTypes(config?: AxiosRequestConfig): Promise<operations.GetTypesResponse> {
    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/types";

    const client: AxiosInstance = this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetTypesResponse = new operations.GetTypesResponse({
        statusCode: httpRes.status,
        contentType: contentType,
        rawResponse: httpRes,
      });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getTypes200ApplicationJSONStrings = utils.objectToClass(
              httpRes?.data
            );
          }
          break;
      }

      return res;
    });
  }

  getTypesType(
    req: operations.GetTypesTypeRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetTypesTypeResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetTypesTypeRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(baseURL, "/types/{type}", req);

    const client: AxiosInstance = this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetTypesTypeResponse =
        new operations.GetTypesTypeResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.cardResumes = [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.cardResumes = utils.objectToClass(
              httpRes?.data,
              shared.CardResume,
              resFieldDepth
            );
          }
          break;
        case httpRes?.status == 404:
          break;
      }

      return res;
    });
  }

  getVariants(
    config?: AxiosRequestConfig
  ): Promise<operations.GetVariantsResponse> {
    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/variants";

    const client: AxiosInstance = this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetVariantsResponse =
        new operations.GetVariantsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getVariants200ApplicationJSONStrings = utils.objectToClass(
              httpRes?.data
            );
          }
          break;
      }

      return res;
    });
  }

  getVariantsVariant(
    req: operations.GetVariantsVariantRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetVariantsVariantResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetVariantsVariantRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(baseURL, "/variants/{variant}", req);

    const client: AxiosInstance = this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetVariantsVariantResponse =
        new operations.GetVariantsVariantResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.cardResumes = [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.cardResumes = utils.objectToClass(
              httpRes?.data,
              shared.CardResume,
              resFieldDepth
            );
          }
          break;
        case httpRes?.status == 404:
          break;
      }

      return res;
    });
  }
}
