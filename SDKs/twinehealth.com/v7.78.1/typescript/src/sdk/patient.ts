/*
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

import * as utils from "../internal/utils";
import * as operations from "./models/operations";
import * as shared from "./models/shared";
import { AxiosInstance, AxiosRequestConfig, AxiosResponse } from "axios";

/**
 * A patient is the core user of Fitbit Plus.
 */
export class Patient {
  _defaultClient: AxiosInstance;
  _securityClient: AxiosInstance;
  _serverURL: string;
  _language: string;
  _sdkVersion: string;
  _genVersion: string;

  constructor(
    defaultClient: AxiosInstance,
    securityClient: AxiosInstance,
    serverURL: string,
    language: string,
    sdkVersion: string,
    genVersion: string
  ) {
    this._defaultClient = defaultClient;
    this._securityClient = securityClient;
    this._serverURL = serverURL;
    this._language = language;
    this._sdkVersion = sdkVersion;
    this._genVersion = genVersion;
  }

  /**
   * Create a patient
   *
   * @remarks
   * Create a patient record.
   *
   * Example for creating a patient with a group specified using `meta.query` instead of `id`:
   *
   * ```JSON
   * {
   *   "data": {
   *     "type": "patient",
   *     "attributes": {
   *       "first_name": "Andrew",
   *       "last_name": "Smith"
   *     },
   *     "relationships": {
   *       "groups": {
   *         "data": [
   *           {
   *             "type": "group",
   *             "meta": {
   *               "query": {
   *                 "organization": "58c88de7c93eb96357a87033",
   *                 "name": "Patients Lead"
   *               }
   *             }
   *           }
   *         ]
   *       }
   *     }
   *   }
   * }
   * ```
   *
   */
  createPatient(
    req: shared.CreatePatientRequestInput,
    config?: AxiosRequestConfig
  ): Promise<operations.CreatePatientResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new shared.CreatePatientRequestInput(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/patient";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "request",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CreatePatientResponse =
        new operations.CreatePatientResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/vnd.api+json`)) {
            res.createPatientResponse = utils.objectToClass(
              httpRes?.data,
              shared.CreatePatientResponse
            );
          }
          break;
        case [401, 403, 409].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/vnd.api+json`)) {
            res.createOrUpdateErrorResponse = utils.objectToClass(
              httpRes?.data,
              shared.CreateOrUpdateErrorResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Get a patient
   *
   * @remarks
   * Gets a patient record by id.
   */
  fetchPatient(
    req: operations.FetchPatientRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.FetchPatientResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.FetchPatientRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(baseURL, "/patient/{id}", req);

    const client: AxiosInstance = this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.FetchPatientResponse =
        new operations.FetchPatientResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/vnd.api+json`)) {
            res.fetchPatientResponse = utils.objectToClass(
              httpRes?.data,
              shared.FetchPatientResponse
            );
          }
          break;
        case [401, 403].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/vnd.api+json`)) {
            res.fetchErrorResponse = utils.objectToClass(
              httpRes?.data,
              shared.FetchErrorResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * List coaches for a patient
   *
   * @remarks
   * Get the list of coaches for a patient.
   */
  fetchPatientCoaches(
    req: operations.FetchPatientCoachesRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.FetchPatientCoachesResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.FetchPatientCoachesRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/patient/{id}/coaches",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.FetchPatientCoachesResponse =
        new operations.FetchPatientCoachesResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/vnd.api+json`)) {
            res.fetchCoachesResponse = utils.objectToClass(
              httpRes?.data,
              shared.FetchCoachesResponse
            );
          }
          break;
        case [401, 403].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/vnd.api+json`)) {
            res.fetchErrorResponse = utils.objectToClass(
              httpRes?.data,
              shared.FetchErrorResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * List groups for a patient
   *
   * @remarks
   * Get the list of groups for a patient.
   */
  fetchPatientGroups(
    req: operations.FetchPatientGroupsRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.FetchPatientGroupsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.FetchPatientGroupsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(baseURL, "/patient/{id}/groups", req);

    const client: AxiosInstance = this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.FetchPatientGroupsResponse =
        new operations.FetchPatientGroupsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/vnd.api+json`)) {
            res.fetchGroupsResponse = utils.objectToClass(
              httpRes?.data,
              shared.FetchGroupsResponse
            );
          }
          break;
        case [401, 403].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/vnd.api+json`)) {
            res.fetchErrorResponse = utils.objectToClass(
              httpRes?.data,
              shared.FetchErrorResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * List patients
   *
   * @remarks
   * Get a list of patients.
   */
  fetchPatients(
    req: operations.FetchPatientsRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.FetchPatientsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.FetchPatientsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/patient";

    const client: AxiosInstance = this._defaultClient;

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.FetchPatientsResponse =
        new operations.FetchPatientsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/vnd.api+json`)) {
            res.fetchPatientsResponse = utils.objectToClass(
              httpRes?.data,
              shared.FetchPatientsResponse
            );
          }
          break;
        case [401, 403, 409].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/vnd.api+json`)) {
            res.fetchErrorResponse = utils.objectToClass(
              httpRes?.data,
              shared.FetchErrorResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Update a patient
   *
   * @remarks
   * Update a patient record.
   */
  updatePatient(
    req: operations.UpdatePatientRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.UpdatePatientResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.UpdatePatientRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(baseURL, "/patient/{id}", req);

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "updatePatientRequestInput",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "patch",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UpdatePatientResponse =
        new operations.UpdatePatientResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/vnd.api+json`)) {
            res.updatePatientResponse = utils.objectToClass(
              httpRes?.data,
              shared.UpdatePatientResponse
            );
          }
          break;
        case [401, 403, 409].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/vnd.api+json`)) {
            res.createOrUpdateErrorResponse = utils.objectToClass(
              httpRes?.data,
              shared.CreateOrUpdateErrorResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Upsert patient
   *
   * @remarks
   * Create a new patient or update an existing patient
   */
  upsertPatient(
    req: shared.UpsertPatientRequestInput,
    config?: AxiosRequestConfig
  ): Promise<operations.UpsertPatientResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new shared.UpsertPatientRequestInput(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/patient";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "request",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "put",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UpsertPatientResponse =
        new operations.UpsertPatientResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/vnd.api+json`)) {
            res.createPatientResponse = utils.objectToClass(
              httpRes?.data,
              shared.CreatePatientResponse
            );
          }
          break;
        case [401, 403, 409].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/vnd.api+json`)) {
            res.createOrUpdateErrorResponse = utils.objectToClass(
              httpRes?.data,
              shared.CreateOrUpdateErrorResponse
            );
          }
          break;
      }

      return res;
    });
  }
}
