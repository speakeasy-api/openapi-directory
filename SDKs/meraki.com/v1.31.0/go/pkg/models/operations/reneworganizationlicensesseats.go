// Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.

package operations

import (
	"encoding/json"
	"fmt"
	"net/http"
)

type RenewOrganizationLicensesSeatsRequestBody struct {
	// The ID of the SM license to renew. This license must already be assigned to an SM network
	LicenseIDToRenew string `json:"licenseIdToRenew"`
	// The SM license to use to renew the seats on 'licenseIdToRenew'. This license must have at least as many seats available as there are seats on 'licenseIdToRenew'
	UnusedLicenseID string `json:"unusedLicenseId"`
}

type RenewOrganizationLicensesSeatsRequest struct {
	RequestBody    RenewOrganizationLicensesSeatsRequestBody `request:"mediaType=application/json"`
	OrganizationID string                                    `pathParam:"style=simple,explode=false,name=organizationId"`
}

type RenewOrganizationLicensesSeats200ApplicationJSONResultingLicensesPermanentlyQueuedLicenses struct {
	// The duration of the individual license
	DurationInDays *int64 `json:"durationInDays,omitempty"`
	// Permanently queued license ID
	ID *string `json:"id,omitempty"`
	// License key
	LicenseKey *string `json:"licenseKey,omitempty"`
	// License type
	LicenseType *string `json:"licenseType,omitempty"`
	// Order number
	OrderNumber *string `json:"orderNumber,omitempty"`
}

// RenewOrganizationLicensesSeats200ApplicationJSONResultingLicensesStateEnum - The state of the license. All queued licenses have a status of `recentlyQueued`.
type RenewOrganizationLicensesSeats200ApplicationJSONResultingLicensesStateEnum string

const (
	RenewOrganizationLicensesSeats200ApplicationJSONResultingLicensesStateEnumActive         RenewOrganizationLicensesSeats200ApplicationJSONResultingLicensesStateEnum = "active"
	RenewOrganizationLicensesSeats200ApplicationJSONResultingLicensesStateEnumExpired        RenewOrganizationLicensesSeats200ApplicationJSONResultingLicensesStateEnum = "expired"
	RenewOrganizationLicensesSeats200ApplicationJSONResultingLicensesStateEnumExpiring       RenewOrganizationLicensesSeats200ApplicationJSONResultingLicensesStateEnum = "expiring"
	RenewOrganizationLicensesSeats200ApplicationJSONResultingLicensesStateEnumRecentlyQueued RenewOrganizationLicensesSeats200ApplicationJSONResultingLicensesStateEnum = "recentlyQueued"
	RenewOrganizationLicensesSeats200ApplicationJSONResultingLicensesStateEnumUnused         RenewOrganizationLicensesSeats200ApplicationJSONResultingLicensesStateEnum = "unused"
	RenewOrganizationLicensesSeats200ApplicationJSONResultingLicensesStateEnumUnusedActive   RenewOrganizationLicensesSeats200ApplicationJSONResultingLicensesStateEnum = "unusedActive"
)

func (e *RenewOrganizationLicensesSeats200ApplicationJSONResultingLicensesStateEnum) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return err
	}
	switch s {
	case "active":
		fallthrough
	case "expired":
		fallthrough
	case "expiring":
		fallthrough
	case "recentlyQueued":
		fallthrough
	case "unused":
		fallthrough
	case "unusedActive":
		*e = RenewOrganizationLicensesSeats200ApplicationJSONResultingLicensesStateEnum(s)
		return nil
	default:
		return fmt.Errorf("invalid value for RenewOrganizationLicensesSeats200ApplicationJSONResultingLicensesStateEnum: %s", s)
	}
}

type RenewOrganizationLicensesSeats200ApplicationJSONResultingLicenses struct {
	// The date the license started burning
	ActivationDate *string `json:"activationDate,omitempty"`
	// The date the license was claimed into the organization
	ClaimDate *string `json:"claimDate,omitempty"`
	// Serial number of the device the license is assigned to
	DeviceSerial *string `json:"deviceSerial,omitempty"`
	// The duration of the individual license
	DurationInDays *int64 `json:"durationInDays,omitempty"`
	// The date the license will expire
	ExpirationDate *string `json:"expirationDate,omitempty"`
	// The id of the head license this license is queued behind. If there is no head license, it returns nil.
	HeadLicenseID *string `json:"headLicenseId,omitempty"`
	// License ID
	ID *string `json:"id,omitempty"`
	// License key
	LicenseKey *string `json:"licenseKey,omitempty"`
	// License type
	LicenseType *string `json:"licenseType,omitempty"`
	// ID of the network the license is assigned to
	NetworkID *string `json:"networkId,omitempty"`
	// Order number
	OrderNumber *string `json:"orderNumber,omitempty"`
	// DEPRECATED List of permanently queued licenses attached to the license. Instead, use /organizations/{organizationId}/licenses?deviceSerial= to retrieved queued licenses for a given device.
	PermanentlyQueuedLicenses []RenewOrganizationLicensesSeats200ApplicationJSONResultingLicensesPermanentlyQueuedLicenses `json:"permanentlyQueuedLicenses,omitempty"`
	// The number of seats of the license. Only applicable to SM licenses.
	SeatCount *int64 `json:"seatCount,omitempty"`
	// The state of the license. All queued licenses have a status of `recentlyQueued`.
	State *RenewOrganizationLicensesSeats200ApplicationJSONResultingLicensesStateEnum `json:"state,omitempty"`
	// The duration of the license plus all permanently queued licenses associated with it
	TotalDurationInDays *int64 `json:"totalDurationInDays,omitempty"`
}

// RenewOrganizationLicensesSeats200ApplicationJSON - Successful operation
type RenewOrganizationLicensesSeats200ApplicationJSON struct {
	// Resulting licenses from the move
	ResultingLicenses []RenewOrganizationLicensesSeats200ApplicationJSONResultingLicenses `json:"resultingLicenses,omitempty"`
}

type RenewOrganizationLicensesSeatsResponse struct {
	ContentType string
	StatusCode  int
	RawResponse *http.Response
	// Successful operation
	RenewOrganizationLicensesSeats200ApplicationJSONObject *RenewOrganizationLicensesSeats200ApplicationJSON
}
