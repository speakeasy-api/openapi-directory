// Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.

package operations

import (
	"encoding/json"
	"fmt"
	"net/http"
)

// UpdateNetworkApplianceFirewallOneToOneNatRulesRequestBodyRulesAllowedInboundProtocolEnum - Either of the following: 'tcp', 'udp', 'icmp-ping' or 'any'
type UpdateNetworkApplianceFirewallOneToOneNatRulesRequestBodyRulesAllowedInboundProtocolEnum string

const (
	UpdateNetworkApplianceFirewallOneToOneNatRulesRequestBodyRulesAllowedInboundProtocolEnumAny      UpdateNetworkApplianceFirewallOneToOneNatRulesRequestBodyRulesAllowedInboundProtocolEnum = "any"
	UpdateNetworkApplianceFirewallOneToOneNatRulesRequestBodyRulesAllowedInboundProtocolEnumIcmpPing UpdateNetworkApplianceFirewallOneToOneNatRulesRequestBodyRulesAllowedInboundProtocolEnum = "icmp-ping"
	UpdateNetworkApplianceFirewallOneToOneNatRulesRequestBodyRulesAllowedInboundProtocolEnumTCP      UpdateNetworkApplianceFirewallOneToOneNatRulesRequestBodyRulesAllowedInboundProtocolEnum = "tcp"
	UpdateNetworkApplianceFirewallOneToOneNatRulesRequestBodyRulesAllowedInboundProtocolEnumUDP      UpdateNetworkApplianceFirewallOneToOneNatRulesRequestBodyRulesAllowedInboundProtocolEnum = "udp"
)

func (e UpdateNetworkApplianceFirewallOneToOneNatRulesRequestBodyRulesAllowedInboundProtocolEnum) ToPointer() *UpdateNetworkApplianceFirewallOneToOneNatRulesRequestBodyRulesAllowedInboundProtocolEnum {
	return &e
}

func (e *UpdateNetworkApplianceFirewallOneToOneNatRulesRequestBodyRulesAllowedInboundProtocolEnum) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "any":
		fallthrough
	case "icmp-ping":
		fallthrough
	case "tcp":
		fallthrough
	case "udp":
		*e = UpdateNetworkApplianceFirewallOneToOneNatRulesRequestBodyRulesAllowedInboundProtocolEnum(v)
		return nil
	default:
		return fmt.Errorf("invalid value for UpdateNetworkApplianceFirewallOneToOneNatRulesRequestBodyRulesAllowedInboundProtocolEnum: %v", v)
	}
}

type UpdateNetworkApplianceFirewallOneToOneNatRulesRequestBodyRulesAllowedInbound struct {
	// An array of ranges of WAN IP addresses that are allowed to make inbound connections on the specified ports or port ranges, or 'any'
	AllowedIps []string `json:"allowedIps,omitempty"`
	// An array of ports or port ranges that will be forwarded to the host on the LAN
	DestinationPorts []string `json:"destinationPorts,omitempty"`
	// Either of the following: 'tcp', 'udp', 'icmp-ping' or 'any'
	Protocol *UpdateNetworkApplianceFirewallOneToOneNatRulesRequestBodyRulesAllowedInboundProtocolEnum `json:"protocol,omitempty"`
}

// UpdateNetworkApplianceFirewallOneToOneNatRulesRequestBodyRulesUplinkEnum - The physical WAN interface on which the traffic will arrive ('internet1' or, if available, 'internet2')
type UpdateNetworkApplianceFirewallOneToOneNatRulesRequestBodyRulesUplinkEnum string

const (
	UpdateNetworkApplianceFirewallOneToOneNatRulesRequestBodyRulesUplinkEnumInternet1 UpdateNetworkApplianceFirewallOneToOneNatRulesRequestBodyRulesUplinkEnum = "internet1"
	UpdateNetworkApplianceFirewallOneToOneNatRulesRequestBodyRulesUplinkEnumInternet2 UpdateNetworkApplianceFirewallOneToOneNatRulesRequestBodyRulesUplinkEnum = "internet2"
)

func (e UpdateNetworkApplianceFirewallOneToOneNatRulesRequestBodyRulesUplinkEnum) ToPointer() *UpdateNetworkApplianceFirewallOneToOneNatRulesRequestBodyRulesUplinkEnum {
	return &e
}

func (e *UpdateNetworkApplianceFirewallOneToOneNatRulesRequestBodyRulesUplinkEnum) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "internet1":
		fallthrough
	case "internet2":
		*e = UpdateNetworkApplianceFirewallOneToOneNatRulesRequestBodyRulesUplinkEnum(v)
		return nil
	default:
		return fmt.Errorf("invalid value for UpdateNetworkApplianceFirewallOneToOneNatRulesRequestBodyRulesUplinkEnum: %v", v)
	}
}

type UpdateNetworkApplianceFirewallOneToOneNatRulesRequestBodyRules struct {
	// The ports this mapping will provide access on, and the remote IPs that will be allowed access to the resource
	AllowedInbound []UpdateNetworkApplianceFirewallOneToOneNatRulesRequestBodyRulesAllowedInbound `json:"allowedInbound,omitempty"`
	// The IP address of the server or device that hosts the internal resource that you wish to make available on the WAN
	LanIP string `json:"lanIp"`
	// A descriptive name for the rule
	Name *string `json:"name,omitempty"`
	// The IP address that will be used to access the internal resource from the WAN
	PublicIP *string `json:"publicIp,omitempty"`
	// The physical WAN interface on which the traffic will arrive ('internet1' or, if available, 'internet2')
	Uplink *UpdateNetworkApplianceFirewallOneToOneNatRulesRequestBodyRulesUplinkEnum `json:"uplink,omitempty"`
}

type UpdateNetworkApplianceFirewallOneToOneNatRulesRequestBody struct {
	// An array of 1:1 nat rules
	Rules []UpdateNetworkApplianceFirewallOneToOneNatRulesRequestBodyRules `json:"rules"`
}

type UpdateNetworkApplianceFirewallOneToOneNatRulesRequest struct {
	RequestBody UpdateNetworkApplianceFirewallOneToOneNatRulesRequestBody `request:"mediaType=application/json"`
	NetworkID   string                                                    `pathParam:"style=simple,explode=false,name=networkId"`
}

type UpdateNetworkApplianceFirewallOneToOneNatRulesResponse struct {
	ContentType string
	StatusCode  int
	RawResponse *http.Response
	// Successful operation
	UpdateNetworkApplianceFirewallOneToOneNatRules200ApplicationJSONObject map[string]interface{}
}
