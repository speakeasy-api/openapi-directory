"""Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT."""

from __future__ import annotations
import dataclasses
import requests as requests_http
from dataclasses_json import Undefined, dataclass_json
from sdk import utils
from typing import Any, Optional


@dataclasses.dataclass
class GetcampaignconfigurationRequest:
    
    accept: str = dataclasses.field(metadata={'header': { 'field_name': 'Accept', 'style': 'simple', 'explode': False }})
    r"""HTTP Client Negotiation Accept Header. Indicates the types of responses the client can understand."""  
    campaign_id: str = dataclasses.field(metadata={'path_param': { 'field_name': 'campaignId', 'style': 'simple', 'explode': False }})
    r"""Campaign audience unique identifier."""  
    content_type: str = dataclasses.field(metadata={'header': { 'field_name': 'Content-Type', 'style': 'simple', 'explode': False }})
    r"""Describes the type of the content being sent."""  
    

@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class Getcampaignconfiguration200ApplicationJSONLastModified:
    r"""Object with information about the most recent update of the campaign audience."""
    
    date_utc: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('dateUtc'), 'exclude': lambda f: f is None }})
    r"""Date of the most recent update in UTC format."""  
    user: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('user'), 'exclude': lambda f: f is None }})
    r"""Email of the user who updated the campaign audience for the latest time."""  
    

@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class Getcampaignconfiguration200ApplicationJSONTargetConfigurationsAffiliates:
    r"""Object with information of the affiliate."""
    
    id: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('id'), 'exclude': lambda f: f is None }})
    r"""Affiliate ID."""  
    name: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('name'), 'exclude': lambda f: f is None }})
    r"""Affiliate Name."""  
    

@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class Getcampaignconfiguration200ApplicationJSONTargetConfigurationsBrands:
    r"""Object with information of the brand."""
    
    id: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('id'), 'exclude': lambda f: f is None }})
    r"""Brand ID."""  
    name: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('name'), 'exclude': lambda f: f is None }})
    r"""Brand Name."""  
    

@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class Getcampaignconfiguration200ApplicationJSONTargetConfigurationsCategories:
    r"""Object with information of the category."""
    
    id: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('id'), 'exclude': lambda f: f is None }})
    r"""Category ID."""  
    name: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('name'), 'exclude': lambda f: f is None }})
    r"""Category Name."""  
    

@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class Getcampaignconfiguration200ApplicationJSONTargetConfigurationsCollections:
    r"""Object with information of the collection."""
    
    id: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('id'), 'exclude': lambda f: f is None }})
    r"""Collection ID."""  
    name: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('name'), 'exclude': lambda f: f is None }})
    r"""Collection Name."""  
    

@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class Getcampaignconfiguration200ApplicationJSONTargetConfigurationsPaymentsMethods:
    r"""Object with information of the Payment Method."""
    
    id: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('id'), 'exclude': lambda f: f is None }})
    r"""Payment Method ID."""  
    name: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('name'), 'exclude': lambda f: f is None }})
    r"""Payment Method Name."""  
    

@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class Getcampaignconfiguration200ApplicationJSONTargetConfigurationsProducts:
    r"""Object with information of the product."""
    
    id: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('id'), 'exclude': lambda f: f is None }})
    r"""Product ID."""  
    name: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('name'), 'exclude': lambda f: f is None }})
    r"""Product Name."""  
    

@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class Getcampaignconfiguration200ApplicationJSONTargetConfigurationsSkus:
    r"""Object with information of the SKU."""
    
    id: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('id'), 'exclude': lambda f: f is None }})
    r"""SKU ID."""  
    name: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('name'), 'exclude': lambda f: f is None }})
    r"""SKU Name."""  
    

@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class Getcampaignconfiguration200ApplicationJSONTargetConfigurationsZipCodeRanges:
    r"""Zip code that applies the campaign audience."""
    
    inclusive: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('inclusive'), 'exclude': lambda f: f is None }})
    r"""Defines if the zip code applies the campaign audience."""  
    

@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class Getcampaignconfiguration200ApplicationJSONTargetConfigurations:
    r"""Object with information about the target audience."""
    
    affiliates: Optional[list[Getcampaignconfiguration200ApplicationJSONTargetConfigurationsAffiliates]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('affiliates'), 'exclude': lambda f: f is None }})
    r"""Marketplace order identifier. The discount will apply to selected affiliates."""  
    are_sales_channel_ids_exclusive: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('areSalesChannelIdsExclusive'), 'exclude': lambda f: f is None }})
    r"""Defines if the trade policy IDs are exclusive."""  
    brands: Optional[list[Getcampaignconfiguration200ApplicationJSONTargetConfigurationsBrands]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('brands'), 'exclude': lambda f: f is None }})
    r"""Object composed by the brands that will activate or deactivate the campaign audience."""  
    brands_are_inclusive: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('brandsAreInclusive'), 'exclude': lambda f: f is None }})
    r"""If set to `true`, this campaign audience will be applied to any brand present on the `brands` field. If set to `false`, brands present on that field will make this campaign audience not to be applied."""  
    campaigns: Optional[list[Any]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('campaigns'), 'exclude': lambda f: f is None }})
    r"""Campaign Audiences that activate this promotion."""  
    card_issuers: Optional[list[Any]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('cardIssuers'), 'exclude': lambda f: f is None }})  
    categories: Optional[list[Getcampaignconfiguration200ApplicationJSONTargetConfigurationsCategories]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('categories'), 'exclude': lambda f: f is None }})
    r"""Object composed by the categories that will activate or deactivate the campaign audience."""  
    categories_are_inclusive: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('categoriesAreInclusive'), 'exclude': lambda f: f is None }})
    r"""If set to `true`, this campaign audience will be applied to any category present on the `categories` field. If set to `false`, categories present on that field will make this campaign audience not to be applied."""  
    cluster_expressions: Optional[list[str]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('clusterExpressions'), 'exclude': lambda f: f is None }})
    r"""An expression to use with clusters."""  
    collections: Optional[list[Getcampaignconfiguration200ApplicationJSONTargetConfigurationsCollections]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('collections'), 'exclude': lambda f: f is None }})
    r"""Object composed by the collections that will activate or deactivate the campaign audience."""  
    collections1_buy_together: Optional[list[str]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('collections1BuyTogether'), 'exclude': lambda f: f is None }})
    r"""Collections that will generate the promotion, type **Buy Together**, **More for less**, **Progressive Discount**, **Buy One Get One**."""  
    collections2_buy_together: Optional[list[Any]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('collections2BuyTogether'), 'exclude': lambda f: f is None }})  
    collections_is_inclusive: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('collectionsIsInclusive'), 'exclude': lambda f: f is None }})
    r"""If set to `true`, this campaign audience will be applied to any collection present on the `collections` field. If set to `false`, collections present on that field will make this campaign audience not to be applied."""  
    compare_list_price_and_price: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('compareListPriceAndPrice'), 'exclude': lambda f: f is None }})
    r"""If the **List Price** and **Price** are the same."""  
    coupon: Optional[list[Any]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('coupon'), 'exclude': lambda f: f is None }})  
    days_ago_of_purchases: Optional[int] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('daysAgoOfPurchases'), 'exclude': lambda f: f is None }})
    r"""Number of days that are considered to add the purchase history."""  
    enable_buy_together_per_sku: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('enableBuyTogetherPerSku'), 'exclude': lambda f: f is None }})
    r"""Enable **Buy Together** per SKU."""  
    featured: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('featured'), 'exclude': lambda f: f is None }})
    r"""Defines if the target audience is featured (`true`) or not (`false`)."""  
    first_buy_is_profile_optimistic: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('firstBuyIsProfileOptimistic'), 'exclude': lambda f: f is None }})
    r"""Applies the discount even if the user is not logged."""  
    gift_list_types: Optional[list[str]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('giftListTypes'), 'exclude': lambda f: f is None }})
    r"""Gifts List Type."""  
    id: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('id'), 'exclude': lambda f: f is None }})
    r"""Target audience ID."""  
    id_seller_is_inclusive: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('idSellerIsInclusive'), 'exclude': lambda f: f is None }})
    r"""Defines if at least one of the sellers must be valid to active the campaign audience."""  
    ids_sales_channel: Optional[list[str]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('idsSalesChannel'), 'exclude': lambda f: f is None }})
    r"""Array with all the trade policies that activate the campaign audience."""  
    installment: Optional[int] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('installment'), 'exclude': lambda f: f is None }})  
    is_different_list_price_and_price: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('isDifferentListPriceAndPrice'), 'exclude': lambda f: f is None }})
    r"""Applies the campaign audience only if the list price and price is different."""  
    is_first_buy: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('isFirstBuy'), 'exclude': lambda f: f is None }})
    r"""Applies the discount only if it's a first buy."""  
    is_min_max_installments: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('isMinMaxInstallments'), 'exclude': lambda f: f is None }})
    r"""Set if the campaign audience will be applied considering a minimum and maximum values for installments."""  
    is_sla_selected: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('isSlaSelected'), 'exclude': lambda f: f is None }})
    r"""Applies selected discount only when one of the defined shipping method is selected by the customer."""  
    item_max_price: Optional[float] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('itemMaxPrice'), 'exclude': lambda f: f is None }})
    r"""Maximum price of the item."""  
    item_min_price: Optional[float] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('itemMinPrice'), 'exclude': lambda f: f is None }})
    r"""Minimum price of the item."""  
    list_brand1_buy_together: Optional[list[Any]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('listBrand1BuyTogether'), 'exclude': lambda f: f is None }})
    r"""Brand first list for the promotion **Buy Together."""  
    list_category1_buy_together: Optional[list[Any]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('listCategory1BuyTogether'), 'exclude': lambda f: f is None }})
    r"""Category first list for the promotion **Buy Together**."""  
    list_sku1_buy_together: Optional[list[Any]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('listSku1BuyTogether'), 'exclude': lambda f: f is None }})
    r"""SKU first list for the promotion **Buy Together**."""  
    list_sku2_buy_together: Optional[list[Any]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('listSku2BuyTogether'), 'exclude': lambda f: f is None }})
    r"""SKU second list for the promotion **Buy Together**."""  
    marketing_tags: Optional[list[str]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('marketingTags'), 'exclude': lambda f: f is None }})
    r"""Array with all the campaign audience's marketing tags."""  
    marketing_tags_are_not_inclusive: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('marketingTagsAreNotInclusive'), 'exclude': lambda f: f is None }})
    r"""Defines if marketing tags are not inclusive."""  
    max_installment: Optional[int] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('maxInstallment'), 'exclude': lambda f: f is None }})
    r"""Maximum value for installment."""  
    max_usage: Optional[int] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('maxUsage'), 'exclude': lambda f: f is None }})
    r"""Defines how many times the campaign audience can be used."""  
    max_usage_per_client: Optional[int] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('maxUsagePerClient'), 'exclude': lambda f: f is None }})
    r"""Defines if the campaign audience can be used multiple times per client."""  
    merchants: Optional[list[Any]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('merchants'), 'exclude': lambda f: f is None }})  
    minimum_quantity_buy_together: Optional[int] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('minimumQuantityBuyTogether'), 'exclude': lambda f: f is None }})
    r"""Minimum quantity for **Buy Together** promotion."""  
    min_installment: Optional[int] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('minInstallment'), 'exclude': lambda f: f is None }})
    r"""Minimum value for installment."""  
    multiple_use_per_client: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('multipleUsePerClient'), 'exclude': lambda f: f is None }})
    r"""Defines if the campaign audience can be used multiple times per client."""  
    name: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('name'), 'exclude': lambda f: f is None }})
    r"""Target audience name."""  
    origin: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('origin'), 'exclude': lambda f: f is None }})
    r"""Shows the campaign audience origin, `Marketplace` or `Fulfillment`.  Read [Difference between orders with marketplace and fulfillment sources](https://help.vtex.com/en/tutorial/what-are-orders-with-marketplace-source-and-orders-with-fulfillment-source--6eVYrmUAwMOeKICU2KuG06) for more information."""  
    payments_methods: Optional[list[Getcampaignconfiguration200ApplicationJSONTargetConfigurationsPaymentsMethods]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('paymentsMethods'), 'exclude': lambda f: f is None }})
    r"""Array composed by all the Payments Methods."""  
    payments_rules: Optional[list[Any]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('paymentsRules'), 'exclude': lambda f: f is None }})  
    percentual_discount_value_list: Optional[list[float]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('percentualDiscountValueList'), 'exclude': lambda f: f is None }})
    r"""Percentual discount value list."""  
    products: Optional[list[Getcampaignconfiguration200ApplicationJSONTargetConfigurationsProducts]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('products'), 'exclude': lambda f: f is None }})
    r"""Object composed by the products that will activate or deactivate the campaign audience."""  
    products_are_inclusive: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('productsAreInclusive'), 'exclude': lambda f: f is None }})
    r"""If set to `true`, this campaign audience will be applied to any product present on the `products` field. If set to `false`, products present on that field will make this campaign audience not to be applied."""  
    products_specifications: Optional[list[Any]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('productsSpecifications'), 'exclude': lambda f: f is None }})  
    quantity_to_affect_buy_together: Optional[int] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('quantityToAffectBuyTogether'), 'exclude': lambda f: f is None }})
    r"""Quantity to affect **Buy Together** promotion."""  
    restrictions_bins: Optional[list[str]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('restrictionsBins'), 'exclude': lambda f: f is None }})
    r"""The discount will be granted if the card's BIN is given."""  
    should_distribute_discount_among_matched_items: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('shouldDistributeDiscountAmongMatchedItems'), 'exclude': lambda f: f is None }})
    r"""Should distribute discount among matched items."""  
    skus: Optional[list[Getcampaignconfiguration200ApplicationJSONTargetConfigurationsSkus]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('skus'), 'exclude': lambda f: f is None }})
    r"""Object composed by the SKUs that will activate or deactivate the campaign audience."""  
    skus_are_inclusive: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('skusAreInclusive'), 'exclude': lambda f: f is None }})
    r"""If set to `true`, this campaign audience will be applied to any SKU present on the `skus` field. If set to `false`, SKUs present on that field will make this campaign audience not to be applied."""  
    slas_ids: Optional[list[str]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('slasIds'), 'exclude': lambda f: f is None }})
    r"""The discount will be granted if the shipping method is the same as the one given."""  
    stores: Optional[list[Any]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('stores'), 'exclude': lambda f: f is None }})  
    stores_are_inclusive: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('storesAreInclusive'), 'exclude': lambda f: f is None }})  
    total_value_celing: Optional[float] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('totalValueCeling'), 'exclude': lambda f: f is None }})
    r"""Maximum chart value to active the campaign audience."""  
    total_value_floor: Optional[float] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('totalValueFloor'), 'exclude': lambda f: f is None }})
    r"""Minimum chart value to active the campaign audience."""  
    total_value_include_all_items: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('totalValueIncludeAllItems'), 'exclude': lambda f: f is None }})  
    total_value_mode: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('totalValueMode'), 'exclude': lambda f: f is None }})
    r"""Total chart value to active the campaign audience."""  
    total_value_purchase: Optional[float] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('totalValuePurchase'), 'exclude': lambda f: f is None }})
    r"""Total value a client must have in past orders to active the campaign audience."""  
    use_new_progressive_algorithm: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('useNewProgressiveAlgorithm'), 'exclude': lambda f: f is None }})
    r"""Use new progressive algorithm."""  
    zip_code_ranges: Optional[list[Getcampaignconfiguration200ApplicationJSONTargetConfigurationsZipCodeRanges]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('zipCodeRanges'), 'exclude': lambda f: f is None }})
    r"""Range of the zip code that applies the campaign audience."""  
    

@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class Getcampaignconfiguration200ApplicationJSON:
    r"""OK"""
    
    begin_date_utc: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('beginDateUtc'), 'exclude': lambda f: f is None }})
    r"""Start date of the campaign audience in UTC format."""  
    end_date_utc: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('endDateUtc'), 'exclude': lambda f: f is None }})
    r"""End date of the campaign audience in UTC format."""  
    id: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('id'), 'exclude': lambda f: f is None }})
    r"""Campaign audience ID."""  
    is_active: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('isActive'), 'exclude': lambda f: f is None }})
    r"""Defines if the campaign audience is active (`true`) or not (`false`)."""  
    is_and_operator: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('isAndOperator'), 'exclude': lambda f: f is None }})
    r"""When `true`, determines that all the `targetConfigurations` need to be valid for the campaign audience to be active. When `false`, determines that if at least one of the `targetConfigurations` is valid, the campaign audience will be active."""  
    is_archived: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('isArchived'), 'exclude': lambda f: f is None }})
    r"""Defines if the campaign audience is archived (`true`) or not (`false`)."""  
    last_modified: Optional[Getcampaignconfiguration200ApplicationJSONLastModified] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('lastModified'), 'exclude': lambda f: f is None }})
    r"""Object with information about the most recent update of the campaign audience."""  
    name: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('name'), 'exclude': lambda f: f is None }})
    r"""Campaign audience name."""  
    target_configurations: Optional[list[Getcampaignconfiguration200ApplicationJSONTargetConfigurations]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('targetConfigurations'), 'exclude': lambda f: f is None }})
    r"""Array that contains all target audience that the campaign audience will be valid."""  
    

@dataclasses.dataclass
class GetcampaignconfigurationResponse:
    
    content_type: str = dataclasses.field()  
    status_code: int = dataclasses.field()  
    getcampaignconfiguration_200_application_json_object: Optional[Getcampaignconfiguration200ApplicationJSON] = dataclasses.field(default=None)
    r"""OK"""  
    raw_response: Optional[requests_http.Response] = dataclasses.field(default=None)  
    