// Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.

package shared

import (
	"encoding/json"
	"fmt"
)

// BestSellersPreviousRelativeDemandEnum - Estimated demand in relation to the item with the highest popularity rank in the same category and country in the previous week or month.
type BestSellersPreviousRelativeDemandEnum string

const (
	BestSellersPreviousRelativeDemandEnumRelativeDemandUnspecified BestSellersPreviousRelativeDemandEnum = "RELATIVE_DEMAND_UNSPECIFIED"
	BestSellersPreviousRelativeDemandEnumVeryLow                   BestSellersPreviousRelativeDemandEnum = "VERY_LOW"
	BestSellersPreviousRelativeDemandEnumLow                       BestSellersPreviousRelativeDemandEnum = "LOW"
	BestSellersPreviousRelativeDemandEnumMedium                    BestSellersPreviousRelativeDemandEnum = "MEDIUM"
	BestSellersPreviousRelativeDemandEnumHigh                      BestSellersPreviousRelativeDemandEnum = "HIGH"
	BestSellersPreviousRelativeDemandEnumVeryHigh                  BestSellersPreviousRelativeDemandEnum = "VERY_HIGH"
)

func (e *BestSellersPreviousRelativeDemandEnum) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return err
	}
	switch s {
	case "RELATIVE_DEMAND_UNSPECIFIED":
		fallthrough
	case "VERY_LOW":
		fallthrough
	case "LOW":
		fallthrough
	case "MEDIUM":
		fallthrough
	case "HIGH":
		fallthrough
	case "VERY_HIGH":
		*e = BestSellersPreviousRelativeDemandEnum(s)
		return nil
	default:
		return fmt.Errorf("invalid value for BestSellersPreviousRelativeDemandEnum: %s", s)
	}
}

// BestSellersRelativeDemandEnum - Estimated demand in relation to the item with the highest popularity rank in the same category and country.
type BestSellersRelativeDemandEnum string

const (
	BestSellersRelativeDemandEnumRelativeDemandUnspecified BestSellersRelativeDemandEnum = "RELATIVE_DEMAND_UNSPECIFIED"
	BestSellersRelativeDemandEnumVeryLow                   BestSellersRelativeDemandEnum = "VERY_LOW"
	BestSellersRelativeDemandEnumLow                       BestSellersRelativeDemandEnum = "LOW"
	BestSellersRelativeDemandEnumMedium                    BestSellersRelativeDemandEnum = "MEDIUM"
	BestSellersRelativeDemandEnumHigh                      BestSellersRelativeDemandEnum = "HIGH"
	BestSellersRelativeDemandEnumVeryHigh                  BestSellersRelativeDemandEnum = "VERY_HIGH"
)

func (e *BestSellersRelativeDemandEnum) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return err
	}
	switch s {
	case "RELATIVE_DEMAND_UNSPECIFIED":
		fallthrough
	case "VERY_LOW":
		fallthrough
	case "LOW":
		fallthrough
	case "MEDIUM":
		fallthrough
	case "HIGH":
		fallthrough
	case "VERY_HIGH":
		*e = BestSellersRelativeDemandEnum(s)
		return nil
	default:
		return fmt.Errorf("invalid value for BestSellersRelativeDemandEnum: %s", s)
	}
}

// BestSellersRelativeDemandChangeEnum - Change in the estimated demand. Whether it rose, sank or remained flat.
type BestSellersRelativeDemandChangeEnum string

const (
	BestSellersRelativeDemandChangeEnumRelativeDemandChangeTypeUnspecified BestSellersRelativeDemandChangeEnum = "RELATIVE_DEMAND_CHANGE_TYPE_UNSPECIFIED"
	BestSellersRelativeDemandChangeEnumSinker                              BestSellersRelativeDemandChangeEnum = "SINKER"
	BestSellersRelativeDemandChangeEnumFlat                                BestSellersRelativeDemandChangeEnum = "FLAT"
	BestSellersRelativeDemandChangeEnumRiser                               BestSellersRelativeDemandChangeEnum = "RISER"
)

func (e *BestSellersRelativeDemandChangeEnum) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return err
	}
	switch s {
	case "RELATIVE_DEMAND_CHANGE_TYPE_UNSPECIFIED":
		fallthrough
	case "SINKER":
		fallthrough
	case "FLAT":
		fallthrough
	case "RISER":
		*e = BestSellersRelativeDemandChangeEnum(s)
		return nil
	default:
		return fmt.Errorf("invalid value for BestSellersRelativeDemandChangeEnum: %s", s)
	}
}

// BestSellersReportGranularityEnum - Granularity of the report. The ranking can be done over a week or a month timeframe. A `WHERE` condition on `best_sellers.report_granularity` is required in the query.
type BestSellersReportGranularityEnum string

const (
	BestSellersReportGranularityEnumReportGranularityUnspecified BestSellersReportGranularityEnum = "REPORT_GRANULARITY_UNSPECIFIED"
	BestSellersReportGranularityEnumWeekly                       BestSellersReportGranularityEnum = "WEEKLY"
	BestSellersReportGranularityEnumMonthly                      BestSellersReportGranularityEnum = "MONTHLY"
)

func (e *BestSellersReportGranularityEnum) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return err
	}
	switch s {
	case "REPORT_GRANULARITY_UNSPECIFIED":
		fallthrough
	case "WEEKLY":
		fallthrough
	case "MONTHLY":
		*e = BestSellersReportGranularityEnum(s)
		return nil
	default:
		return fmt.Errorf("invalid value for BestSellersReportGranularityEnum: %s", s)
	}
}

// BestSellers - Fields related to the [Best sellers reports](https://support.google.com/merchants/answer/9488679).
type BestSellers struct {
	// Google product category ID to calculate the ranking for, represented in [Google's product taxonomy](https://support.google.com/merchants/answer/6324436). If a `WHERE` condition on `best_sellers.category_id` is not specified in the query, rankings for all top-level categories are returned.
	CategoryID *string `json:"categoryId,omitempty"`
	// Country where the ranking is calculated. A `WHERE` condition on `best_sellers.country_code` is required in the query.
	CountryCode *string `json:"countryCode,omitempty"`
	// Popularity rank in the previous week or month.
	PreviousRank *string `json:"previousRank,omitempty"`
	// Estimated demand in relation to the item with the highest popularity rank in the same category and country in the previous week or month.
	PreviousRelativeDemand *BestSellersPreviousRelativeDemandEnum `json:"previousRelativeDemand,omitempty"`
	// Popularity on Shopping ads and free listings, in the selected category and country, based on the estimated number of units sold.
	Rank *string `json:"rank,omitempty"`
	// Estimated demand in relation to the item with the highest popularity rank in the same category and country.
	RelativeDemand *BestSellersRelativeDemandEnum `json:"relativeDemand,omitempty"`
	// Change in the estimated demand. Whether it rose, sank or remained flat.
	RelativeDemandChange *BestSellersRelativeDemandChangeEnum `json:"relativeDemandChange,omitempty"`
	// Represents a whole or partial calendar date, such as a birthday. The time of day and time zone are either specified elsewhere or are insignificant. The date is relative to the Gregorian Calendar. This can represent one of the following: * A full date, with non-zero year, month, and day values. * A month and day, with a zero year (for example, an anniversary). * A year on its own, with a zero month and a zero day. * A year and month, with a zero day (for example, a credit card expiration date). Related types: * google.type.TimeOfDay * google.type.DateTime * google.protobuf.Timestamp
	ReportDate *Date `json:"reportDate,omitempty"`
	// Granularity of the report. The ranking can be done over a week or a month timeframe. A `WHERE` condition on `best_sellers.report_granularity` is required in the query.
	ReportGranularity *BestSellersReportGranularityEnum `json:"reportGranularity,omitempty"`
}
