"""Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT."""

import requests as requests_http
from . import utils
from sdk.models import operations

class Preprints:
    _client: requests_http.Session
    _security_client: requests_http.Session
    _server_url: str
    _language: str
    _sdk_version: str
    _gen_version: str

    def __init__(self, client: requests_http.Session, security_client: requests_http.Session, server_url: str, language: str, sdk_version: str, gen_version: str) -> None:
        self._client = client
        self._security_client = security_client
        self._server_url = server_url
        self._language = language
        self._sdk_version = sdk_version
        self._gen_version = gen_version
        
    def preprints_bibliographic_contributors_list(self, request: operations.PreprintsBibliographicContributorsListRequest) -> operations.PreprintsBibliographicContributorsListResponse:
        r"""List all Bibliographic Contributors
        A paginated list of the Preprint's Bibliographic Contributors, sorted by their index.
        Contributors are users who can make changes to the Preprint. Contributors with WRITE permissions may edit preprint details, and ADMIN Contributors may add or remove other Contributors.
        
        Contributors are categorized as either \"bibliographic\" or \"non-bibliographic\". From a permissions standpoint, both are the same, but bibliographic contributors are included in citations and are listed on the project overview page on the OSF, while non-bibliographic contributors are not.
        
        Note that if an anonymous view_only key is being used to view the list of contributors, the user relationship will not be exposed and the contributor ID will be an empty string.
        
        #### Returns
        Returns a JSON object containing `data` and `links` keys.
        
        The `data` key contains an array of 10 contributors. Each resource in the array contains the full representation of the contributor, meaning additional requests to a contributor's detail view are not necessary. Additionally, the full representation of the user this contributor represents is automatically embedded within the `data` key of the response.
        
        The `links` key contains a dictionary of links that can be used for [pagination](#tag/Pagination).
        #### Filtering
        You can optionally request that the response only include contributors that match your filters by utilizing the `filter` query parameter, e.g. https://api.osf.io/v2/preprints/y9jdt/contributors/?filter[bibliographic]=true.
        
        Contributors may be filtered by their `bibliographic` and `permission` attributes.
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.PreprintsBibliographicContributorsListRequest, base_url, '/preprints/{preprint_id}/bibliographic_contributors/', request)
        
        
        client = self._client
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.PreprintsBibliographicContributorsListResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, '*/*'):
                res.body = http_res.content

        return res

    def preprints_citation_list(self, request: operations.PreprintsCitationListRequest) -> operations.PreprintsCitationListResponse:
        r"""Retrieve citation details
        The citation details for a preprint, in CSL format.
        #### Returns
        Returns a JSON object with a `data` key that contains the representation of the details necessary for the preprint citation.
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.PreprintsCitationListRequest, base_url, '/preprints/{preprint_id}/citation/', request)
        
        
        client = self._client
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.PreprintsCitationListResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, '*/*'):
                res.body = http_res.content

        return res

    def preprints_citation_read(self, request: operations.PreprintsCitationReadRequest) -> operations.PreprintsCitationReadResponse:
        r"""Retrieve a styled citation
        The citation for a preprint in a specific style.
        #### Returns
        Returns a JSON object with a `data` key that contains the representation of the preprint citation, in the requested style.
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.PreprintsCitationReadRequest, base_url, '/preprints/{preprint_id}/citation/{style_id}/', request)
        
        
        client = self._client
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.PreprintsCitationReadResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, '*/*'):
                res.body = http_res.content

        return res

    def preprints_contributor_read(self, request: operations.PreprintsContributorReadRequest) -> operations.PreprintsContributorReadResponse:
        r"""Retrieve a contributor
        Retrieves the details of a contributor on this Preprint.
        Contributors are categorized as either \"bibliographic\" or \"non-bibliographic\". From a permissions standpoint, both are the same, but bibliographic contributors are included in citations and are listed on the project overview page on the OSF, while non-bibliographic contributors are not.
        
        Note that if an anonymous view_only key is being used to view the list of contributors, the user relationship will not be exposed and the contributor ID will be an empty string.
        #### Returns
        Returns a JSON object with a `data` key containing the representation of the requested contributor, if the request is successful.
        
        If the request is unsuccessful, an `errors` key containing information about the failure will be returned. Refer to the [list of error codes](#tag/Errors-and-Error-Codes) to understand why this request may have failed.
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.PreprintsContributorReadRequest, base_url, '/preprints/{preprint_id}/contributors/{user_id}/', request)
        
        
        client = self._client
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.PreprintsContributorReadResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        

        return res

    def preprints_contributors_create(self, request: operations.PreprintsContributorsCreateRequest) -> operations.PreprintsContributorsCreateResponse:
        r"""Create a Contributor
        Adds a contributor to a Preprint, effectively creating a relationship between the Preprint and a user.
        
        Contributors are users who can make changes to the Preprint. Contributors with WRITE permissions may edit preprint details, and ADMIN Contributors may add or remove other Contributors.
        
        Contributors are categorized as either \"bibliographic\" or \"non-bibliographic\" contributors. From a permissions standpoint, both are the same, but bibliographic contributors are included in citations and are listed on the project overview page on the OSF, while non-bibliographic contributors are not.
        #### Permissions
        Only project administrators can add contributors to a Preprint.
        #### Required
        A relationship object with a `data` key, containing the `users` type and valid user ID is required.
        
        All attributes describing the relationship between the Preprint and the user are optional.
        #### Returns
        Returns a JSON object with a `data` key containing the representation of the new contributor, if the request is successful.
        
        If the request is unsuccessful, an `errors` key containing information about the failure will be returned. Refer to the [list of error codes](#tag/Errors-and-Error-Codes) to understand why this request may have failed.
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.PreprintsContributorsCreateRequest, base_url, '/preprints/{preprint_id}/contributors/', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = self._client
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.PreprintsContributorsCreateResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        

        return res

    def preprints_contributors_list(self, request: operations.PreprintsContributorsListRequest) -> operations.PreprintsContributorsListResponse:
        r"""List all Contributors for a Preprint
        A paginated list of the Preprint's Contributors, sorted by their index.
        
        Contributors are users who can make changes to the Preprint. Contributors with WRITE permissions may edit preprint details, and ADMIN Contributors may add or remove other Contributors.
        
        Contributors are categorized as either \"bibliographic\" or \"non-bibliographic\". From a permissions standpoint, both are the same, but bibliographic contributors are included in citations and are listed on the project overview page on the OSF, while non-bibliographic contributors are not.
        
        Note that if an anonymous view_only key is being used to view the list of Contributors, the user relationship will not be exposed and the Contributor ID will be an empty string.
        
        #### Returns
        Returns a JSON object containing `data` and `links` keys.
        
        The `data` key contains an array of 10 contributors. Each resource in the array contains the full representation of the contributor, meaning additional requests to a contributor's detail view are not necessary. Additionally, the full representation of the user this contributor represents is automatically embedded within the `data` key of the response.
        
        The `links` key contains a dictionary of links that can be used for [pagination](#tag/Pagination).
        #### Filtering
        You can optionally request that the response only include contributors that match your filters by utilizing the `filter` query parameter, e.g. https://api.osf.io/v2/preprints/y9jdt/contributors/?filter[bibliographic]=true.
        
        Contributors may be filtered by their `bibliographic` and `permission` attributes.
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.PreprintsContributorsListRequest, base_url, '/preprints/{preprint_id}/contributors/', request)
        
        
        client = self._client
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.PreprintsContributorsListResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, '*/*'):
                res.body = http_res.content

        return res

    def preprints_create(self, request: operations.PreprintsCreatePreprintInput) -> operations.PreprintsCreateResponse:
        r"""Create a preprint
        Creates a new preprint.
        #### Returns
        Returns a JSON object with a `data` key containing the representation of the created preprint, if the request is successful.
        
        If the request is unsuccessful, an `errors` key containing information about the failure will be returned. Refer to the [list of error codes]() to understand why this request may have failed.
        """
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/preprints/'
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = self._client
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.PreprintsCreateResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        

        return res

    def preprints_list(self) -> operations.PreprintsListResponse:
        r"""List all preprints
        A paginated list of preprints from all preprint providers. The returned preprints are sorted by their creation date, with the most recent preprints appearing first.
        #### Returns
        Returns a JSON object containing `data` and `links` keys.
        
        The `data` key contains an array of 10 preprints. Each resource in the array is a separate preprint object.
        
        The `links` key contains a dictionary of links that can be used for [pagination](#tag/Pagination).
        
        This request should never return an error.
        #### Filtering
        You can optionally request that the response only include preprints that match your filters by utilizing the `filter` query parameter, e.g. https://api.osf.io/v2/preprints/?filter[provider]=socarxiv.
        
        Preprints may be filtered by their `id`, `is_published`, `date_created`, `date_modified`, and `provider`.
        """
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/preprints/'
        
        
        client = self._client
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.PreprintsListResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, '*/*'):
                res.body = http_res.content

        return res

    def preprints_partial_update(self, request: operations.PreprintsPartialUpdateRequest) -> operations.PreprintsPartialUpdateResponse:
        r"""Update a preprint
        Updates the specified preprint by setting the values of the parameters passed. Any parameters not provided will be left unchanged.
        #### Returns
        Returns a JSON object with a `data` key containing the new representation of the updated preprint, if the request is successful.
        
        If the request is unsuccessful, an `errors` key containing information about the failure will be returned. Refer to the [list of error codes]() to understand why this request may have failed.
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.PreprintsPartialUpdateRequest, base_url, '/preprints/{preprint_id}/', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = self._client
        
        http_res = client.request('PATCH', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.PreprintsPartialUpdateResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        

        return res

    def preprints_read(self, request: operations.PreprintsReadRequest) -> operations.PreprintsReadResponse:
        r"""Retrieve a preprint
        Retrieves the details of a preprint.
        #### Returns
        Returns a JSON object with a `data` key containing the representation of the requested preprint, if the request is successful.
        
        If the request is unsuccessful, an `errors` key containing information about the failure will be returned. Refer to the [list of error codes](#tag/Errors-and-Error-Codes) to understand why this request may have failed.
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.PreprintsReadRequest, base_url, '/preprints/{preprint_id}/', request)
        
        
        client = self._client
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.PreprintsReadResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, '*/*'):
                res.body = http_res.content

        return res

    