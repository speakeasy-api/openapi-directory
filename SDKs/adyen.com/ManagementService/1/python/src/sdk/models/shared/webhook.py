"""Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT."""

from __future__ import annotations
import dataclasses
from ..shared import additionalsettingsresponse as shared_additionalsettingsresponse
from ..shared import webhooklinks as shared_webhooklinks
from dataclasses_json import Undefined, dataclass_json
from enum import Enum
from sdk import utils
from typing import Optional

class WebhookCommunicationFormatEnum(str, Enum):
    r"""Format or protocol for receiving webhooks. Possible values:
    * **soap**
    * **http**
    * **json**
    """
    HTTP = 'http'
    JSON = 'json'
    SOAP = 'soap'

class WebhookFilterMerchantAccountTypeEnum(str, Enum):
    r"""Shows how merchant accounts are included in company-level webhooks. Possible values:
    * **includeAccounts**
    * **excludeAccounts**
    * **allAccounts**: Includes all merchant accounts, and does not require specifying `filterMerchantAccounts`.
    """
    ALL_ACCOUNTS = 'allAccounts'
    EXCLUDE_ACCOUNTS = 'excludeAccounts'
    INCLUDE_ACCOUNTS = 'includeAccounts'

class WebhookNetworkTypeEnum(str, Enum):
    r"""Network type for Terminal API details webhooks."""
    LOCAL = 'LOCAL'
    PUBLIC = 'PUBLIC'

class WebhookSslVersionEnum(str, Enum):
    r"""SSL version to access the public webhook URL specified in the `url` field. Possible values:
    * **TLSv1.3**
    * **TLSv1.2**
    * **HTTP** - Only allowed on Test environment.
    
    If not specified, the webhook will use `sslVersion`: **TLSv1.2**.
    """
    HTTP = 'HTTP'
    SSL = 'SSL'
    SS_LV3 = 'SSLv3'
    TLS = 'TLS'
    TL_SV1 = 'TLSv1'
    TL_SV1_1 = 'TLSv1.1'
    TL_SV1_2 = 'TLSv1.2'
    TL_SV1_3 = 'TLSv1.3'


@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class Webhook:
    r"""OK - the request has succeeded."""
    
    active: bool = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('active') }})
    r"""Indicates if the webhook configuration is active. The field must be **true** for you to receive webhooks about events related an account."""  
    communication_format: WebhookCommunicationFormatEnum = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('communicationFormat') }})
    r"""Format or protocol for receiving webhooks. Possible values:
    * **soap**
    * **http**
    * **json**
    """  
    type: str = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('type') }})
    r"""The type of webhook. Possible values are:
    
    - **standard**
    - **account-settings-notification**
    - **banktransfer-notification**
    - **boletobancario-notification**
    - **directdebit-notification**
    - **pending-notification**
    - **ideal-notification**
    - **ideal-pending-notification**
    - **report-notification**
    - **terminal-api-notification**
    
    Find out more about [standard notification webhooks](https://docs.adyen.com/development-resources/webhooks/understand-notifications#event-codes) and [other types of notifications](https://docs.adyen.com/development-resources/webhooks/understand-notifications#other-notifications).
    """  
    url: str = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('url') }})
    r"""Public URL where webhooks will be sent, for example **https://www.domain.com/webhook-endpoint**."""  
    links: Optional[shared_webhooklinks.WebhookLinks] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('_links'), 'exclude': lambda f: f is None }})  
    accepts_expired_certificate: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('acceptsExpiredCertificate'), 'exclude': lambda f: f is None }})
    r"""Indicates if expired SSL certificates are accepted. Default value: **false**."""  
    accepts_self_signed_certificate: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('acceptsSelfSignedCertificate'), 'exclude': lambda f: f is None }})
    r"""Indicates if self-signed SSL certificates are accepted. Default value: **false**."""  
    accepts_untrusted_root_certificate: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('acceptsUntrustedRootCertificate'), 'exclude': lambda f: f is None }})
    r"""Indicates if untrusted SSL certificates are accepted. Default value: **false**."""  
    account_reference: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('accountReference'), 'exclude': lambda f: f is None }})
    r"""Reference to the account the webook is set on."""  
    additional_settings: Optional[shared_additionalsettingsresponse.AdditionalSettingsResponse] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('additionalSettings'), 'exclude': lambda f: f is None }})  
    certificate_alias: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('certificateAlias'), 'exclude': lambda f: f is None }})
    r"""The alias of our SSL certificate. When you receive a notification from us, the alias from the HMAC signature will match this alias."""  
    description: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('description'), 'exclude': lambda f: f is None }})
    r"""Your description for this webhook configuration."""  
    filter_merchant_accounts: Optional[list[str]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('filterMerchantAccounts'), 'exclude': lambda f: f is None }})
    r"""A list of merchant account names that are included or excluded from receiving the webhook. Inclusion or exclusion is based on the value defined for `filterMerchantAccountType`.
    
    Required if `filterMerchantAccountType` is either:
    * **includeAccounts**
    * **excludeAccounts**
    
    Not needed for `filterMerchantAccountType`: **allAccounts**.
    """  
    filter_merchant_account_type: Optional[WebhookFilterMerchantAccountTypeEnum] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('filterMerchantAccountType'), 'exclude': lambda f: f is None }})
    r"""Shows how merchant accounts are included in company-level webhooks. Possible values:
    * **includeAccounts**
    * **excludeAccounts**
    * **allAccounts**: Includes all merchant accounts, and does not require specifying `filterMerchantAccounts`.
    """  
    has_error: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('hasError'), 'exclude': lambda f: f is None }})
    r"""Indicates if the webhook configuration has errors that need troubleshooting. If the value is **true**, troubleshoot the configuration using the [testing endpoint](https://docs.adyen.com/api-explorer/#/ManagementService/v1/post/companies/{companyId}/webhooks/{webhookid}/test)."""  
    has_password: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('hasPassword'), 'exclude': lambda f: f is None }})
    r"""Indicates if the webhook is password protected."""  
    hmac_key_check_value: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('hmacKeyCheckValue'), 'exclude': lambda f: f is None }})
    r"""The [checksum](https://en.wikipedia.org/wiki/Key_checksum_value) of the HMAC key generated for this webhook. You can use this value to uniquely identify the HMAC key configured for this webhook."""  
    id: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('id'), 'exclude': lambda f: f is None }})
    r"""Unique identifier for this webhook."""  
    network_type: Optional[WebhookNetworkTypeEnum] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('networkType'), 'exclude': lambda f: f is None }})
    r"""Network type for Terminal API details webhooks."""  
    populate_soap_action_header: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('populateSoapActionHeader'), 'exclude': lambda f: f is None }})
    r"""Indicates if the SOAP action header needs to be populated. Default value: **false**.
    
    Only applies if `communicationFormat`: **soap**.
    """  
    ssl_version: Optional[WebhookSslVersionEnum] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('sslVersion'), 'exclude': lambda f: f is None }})
    r"""SSL version to access the public webhook URL specified in the `url` field. Possible values:
    * **TLSv1.3**
    * **TLSv1.2**
    * **HTTP** - Only allowed on Test environment.
    
    If not specified, the webhook will use `sslVersion`: **TLSv1.2**.
    """  
    username: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('username'), 'exclude': lambda f: f is None }})
    r"""Username to access the webhook URL."""  
    