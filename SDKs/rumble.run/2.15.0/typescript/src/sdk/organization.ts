/*
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

import * as utils from "../internal/utils";
import * as operations from "./models/operations";
import * as shared from "./models/shared";
import { AxiosInstance, AxiosRequestConfig, AxiosResponse } from "axios";

/**
 * Requires Organization Key
 */
export class Organization {
  _defaultClient: AxiosInstance;
  _securityClient: AxiosInstance;
  _serverURL: string;
  _language: string;
  _sdkVersion: string;
  _genVersion: string;

  constructor(
    defaultClient: AxiosInstance,
    securityClient: AxiosInstance,
    serverURL: string,
    language: string,
    sdkVersion: string,
    genVersion: string
  ) {
    this._defaultClient = defaultClient;
    this._securityClient = securityClient;
    this._serverURL = serverURL;
    this._language = language;
    this._sdkVersion = sdkVersion;
    this._genVersion = genVersion;
  }

  /**
   * Clear all tags across multiple assets based on a search query
   */
  clearBulkAssetTags(
    req: shared.Search,
    security: operations.ClearBulkAssetTagsSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.ClearBulkAssetTagsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new shared.Search(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/org/assets/bulk/clearTags";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "request",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ClearBulkAssetTagsSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ClearBulkAssetTagsResponse =
        new operations.ClearBulkAssetTagsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.statusMessage = httpRes?.data;
          }
          break;
        case [401, 404].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Create a scan task for a given site
   */
  createScan(
    req: operations.CreateScanRequest,
    security: operations.CreateScanSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.CreateScanResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CreateScanRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/org/sites/{site_id}/scan",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "scanOptions",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.CreateScanSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "put",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CreateScanResponse =
        new operations.CreateScanResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.task = utils.objectToClass(httpRes?.data, shared.Task);
          }
          break;
        case [401, 403, 404, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Create a new site
   */
  createSite(
    req: shared.SiteOptions,
    security: operations.CreateSiteSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.CreateSiteResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new shared.SiteOptions(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/org/sites";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "request",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.CreateSiteSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "put",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CreateSiteResponse =
        new operations.CreateSiteResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.site = utils.objectToClass(httpRes?.data, shared.Site);
          }
          break;
        case [401, 404].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Get details for a single agent
   */
  getAgent(
    req: operations.GetAgentRequest,
    security: operations.GetAgentSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.GetAgentResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetAgentRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/org/agents/{agent_id}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.GetAgentSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetAgentResponse = new operations.GetAgentResponse({
        statusCode: httpRes.status,
        contentType: contentType,
        rawResponse: httpRes,
      });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.agent = utils.objectToClass(httpRes?.data, shared.Agent);
          }
          break;
        case [401, 404].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Get all agents
   */
  getAgents(
    config?: AxiosRequestConfig
  ): Promise<operations.GetAgentsResponse> {
    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/org/agents";

    const client: AxiosInstance = this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetAgentsResponse =
        new operations.GetAgentsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.agents = [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.agents = utils.objectToClass(
              httpRes?.data,
              shared.Agent,
              resFieldDepth
            );
          }
          break;
        case httpRes?.status == 401:
          break;
      }

      return res;
    });
  }

  /**
   * Get asset details
   */
  getAsset(
    req: operations.GetAssetRequest,
    security: operations.GetAssetSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.GetAssetResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetAssetRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/org/assets/{asset_id}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.GetAssetSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetAssetResponse = new operations.GetAssetResponse({
        statusCode: httpRes.status,
        contentType: contentType,
        rawResponse: httpRes,
      });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.asset = utils.objectToClass(httpRes?.data, shared.Asset);
          }
          break;
        case [401, 404].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Get all assets
   */
  getAssets(
    req: operations.GetAssetsRequest,
    security: operations.GetAssetsSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.GetAssetsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetAssetsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/org/assets";
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.GetAssetsSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetAssetsResponse =
        new operations.GetAssetsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.assets = [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.assets = utils.objectToClass(
              httpRes?.data,
              shared.Asset,
              resFieldDepth
            );
          }
          break;
        case httpRes?.status == 401:
          break;
      }

      return res;
    });
  }

  /**
   * Get API key details
   */
  getKey(config?: AxiosRequestConfig): Promise<operations.GetKeyResponse> {
    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/org/key";

    const client: AxiosInstance = this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetKeyResponse = new operations.GetKeyResponse({
        statusCode: httpRes.status,
        contentType: contentType,
        rawResponse: httpRes,
      });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.apiKey = utils.objectToClass(httpRes?.data, shared.APIKey);
          }
          break;
        case httpRes?.status == 401:
          break;
      }

      return res;
    });
  }

  /**
   * Get organization details
   */
  getOrganization(
    config?: AxiosRequestConfig
  ): Promise<operations.GetOrganizationResponse> {
    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/org";

    const client: AxiosInstance = this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetOrganizationResponse =
        new operations.GetOrganizationResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.organization = utils.objectToClass(
              httpRes?.data,
              shared.Organization
            );
          }
          break;
        case httpRes?.status == 401:
          break;
      }

      return res;
    });
  }

  /**
   * Get service details
   */
  getService(
    req: operations.GetServiceRequest,
    security: operations.GetServiceSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.GetServiceResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetServiceRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/org/services/{service_id}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.GetServiceSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetServiceResponse =
        new operations.GetServiceResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.service = utils.objectToClass(httpRes?.data, shared.Service);
          }
          break;
        case [401, 404].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Get all services
   */
  getServices(
    req: operations.GetServicesRequest,
    security: operations.GetServicesSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.GetServicesResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetServicesRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/org/services";
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.GetServicesSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetServicesResponse =
        new operations.GetServicesResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.services = [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.services = utils.objectToClass(
              httpRes?.data,
              shared.Service,
              resFieldDepth
            );
          }
          break;
        case httpRes?.status == 401:
          break;
      }

      return res;
    });
  }

  /**
   * Get site details
   */
  getSite(
    req: operations.GetSiteRequest,
    security: operations.GetSiteSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.GetSiteResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetSiteRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(baseURL, "/org/sites/{site_id}", req);
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.GetSiteSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetSiteResponse = new operations.GetSiteResponse({
        statusCode: httpRes.status,
        contentType: contentType,
        rawResponse: httpRes,
      });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.site = utils.objectToClass(httpRes?.data, shared.Site);
          }
          break;
        case [401, 404].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Get all sites
   */
  getSites(config?: AxiosRequestConfig): Promise<operations.GetSitesResponse> {
    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/org/sites";

    const client: AxiosInstance = this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetSitesResponse = new operations.GetSitesResponse({
        statusCode: httpRes.status,
        contentType: contentType,
        rawResponse: httpRes,
      });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.sites = [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.sites = utils.objectToClass(
              httpRes?.data,
              shared.Site,
              resFieldDepth
            );
          }
          break;
        case httpRes?.status == 401:
          break;
      }

      return res;
    });
  }

  /**
   * Get task details
   */
  getTask(
    req: operations.GetTaskRequest,
    security: operations.GetTaskSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.GetTaskResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetTaskRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(baseURL, "/org/tasks/{task_id}", req);
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.GetTaskSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetTaskResponse = new operations.GetTaskResponse({
        statusCode: httpRes.status,
        contentType: contentType,
        rawResponse: httpRes,
      });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.task = utils.objectToClass(httpRes?.data, shared.Task);
          }
          break;
        case httpRes?.status == 401:
          break;
      }

      return res;
    });
  }

  /**
   * Returns a temporary task change report data url
   */
  getTaskChangeReport(
    req: operations.GetTaskChangeReportRequest,
    security: operations.GetTaskChangeReportSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.GetTaskChangeReportResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetTaskChangeReportRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/org/tasks/{task_id}/changes",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.GetTaskChangeReportSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetTaskChangeReportResponse =
        new operations.GetTaskChangeReportResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `*/*`)) {
            const resBody: string = JSON.stringify(httpRes?.data, null, 0);
            const out: Uint8Array = new Uint8Array(resBody.length);
            for (let i = 0; i < resBody.length; i++)
              out[i] = resBody.charCodeAt(i);
            res.body = out;
          }
          break;
        case [401, 404].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Returns a temporary task log data url
   */
  getTaskLog(
    req: operations.GetTaskLogRequest,
    security: operations.GetTaskLogSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.GetTaskLogResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetTaskLogRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/org/tasks/{task_id}/log",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.GetTaskLogSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetTaskLogResponse =
        new operations.GetTaskLogResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `*/*`)) {
            const resBody: string = JSON.stringify(httpRes?.data, null, 0);
            const out: Uint8Array = new Uint8Array(resBody.length);
            for (let i = 0; i < resBody.length; i++)
              out[i] = resBody.charCodeAt(i);
            res.body = out;
          }
          break;
        case [401, 404].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Returns a temporary task scan data url
   */
  getTaskScanData(
    req: operations.GetTaskScanDataRequest,
    security: operations.GetTaskScanDataSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.GetTaskScanDataResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetTaskScanDataRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/org/tasks/{task_id}/data",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.GetTaskScanDataSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetTaskScanDataResponse =
        new operations.GetTaskScanDataResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `*/*`)) {
            const resBody: string = JSON.stringify(httpRes?.data, null, 0);
            const out: Uint8Array = new Uint8Array(resBody.length);
            for (let i = 0; i < resBody.length; i++)
              out[i] = resBody.charCodeAt(i);
            res.body = out;
          }
          break;
        case [401, 404].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Get all tasks (last 1000)
   */
  getTasks(
    req: operations.GetTasksRequest,
    security: operations.GetTasksSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.GetTasksResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetTasksRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/org/tasks";
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.GetTasksSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetTasksResponse = new operations.GetTasksResponse({
        statusCode: httpRes.status,
        contentType: contentType,
        rawResponse: httpRes,
      });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.tasks = [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.tasks = utils.objectToClass(
              httpRes?.data,
              shared.Task,
              resFieldDepth
            );
          }
          break;
        case httpRes?.status == 401:
          break;
      }

      return res;
    });
  }

  /**
   * Get wireless LAN details
   */
  getWirelessLAN(
    req: operations.GetWirelessLANRequest,
    security: operations.GetWirelessLANSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.GetWirelessLANResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetWirelessLANRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/org/wireless/{wireless_id}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.GetWirelessLANSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetWirelessLANResponse =
        new operations.GetWirelessLANResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.wireless = utils.objectToClass(httpRes?.data, shared.Wireless);
          }
          break;
        case httpRes?.status == 401:
          break;
      }

      return res;
    });
  }

  /**
   * Get all wireless LANs
   */
  getWirelessLANs(
    req: operations.GetWirelessLANsRequest,
    security: operations.GetWirelessLANsSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.GetWirelessLANsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetWirelessLANsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/org/wireless";
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.GetWirelessLANsSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetWirelessLANsResponse =
        new operations.GetWirelessLANsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.wirelesses = [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.wirelesses = utils.objectToClass(
              httpRes?.data,
              shared.Wireless,
              resFieldDepth
            );
          }
          break;
        case httpRes?.status == 401:
          break;
      }

      return res;
    });
  }

  /**
   * Signal that a completed task should be hidden
   */
  hideTask(
    req: operations.HideTaskRequest,
    security: operations.HideTaskSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.HideTaskResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.HideTaskRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/org/tasks/{task_id}/hide",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.HideTaskSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "post",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.HideTaskResponse = new operations.HideTaskResponse({
        statusCode: httpRes.status,
        contentType: contentType,
        rawResponse: httpRes,
      });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `*/*`)) {
            const resBody: string = JSON.stringify(httpRes?.data, null, 0);
            const out: Uint8Array = new Uint8Array(resBody.length);
            for (let i = 0; i < resBody.length; i++)
              out[i] = resBody.charCodeAt(i);
            res.body = out;
          }
          break;
        case [401, 404].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Import a Nessus scan data file into a site
   */
  importNessusScanData(
    req: operations.ImportNessusScanDataRequest,
    security: operations.ImportNessusScanDataSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.ImportNessusScanDataResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ImportNessusScanDataRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/org/sites/{site_id}/import/nessus",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "raw"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ImportNessusScanDataSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "put",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ImportNessusScanDataResponse =
        new operations.ImportNessusScanDataResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.task = utils.objectToClass(httpRes?.data, shared.Task);
          }
          break;
        case [401, 403, 404, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Import a scan data file into a site
   */
  importScanData(
    req: operations.ImportScanDataRequest,
    security: operations.ImportScanDataSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.ImportScanDataResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ImportScanDataRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/org/sites/{site_id}/import",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "raw"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ImportScanDataSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "put",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ImportScanDataResponse =
        new operations.ImportScanDataResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.task = utils.objectToClass(httpRes?.data, shared.Task);
          }
          break;
        case [401, 403, 404, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Remove and uninstall an agent
   */
  removeAgent(
    req: operations.RemoveAgentRequest,
    security: operations.RemoveAgentSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.RemoveAgentResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.RemoveAgentRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/org/agents/{agent_id}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.RemoveAgentSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.RemoveAgentResponse =
        new operations.RemoveAgentResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case [204, 401, 404].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Remove an asset
   */
  removeAsset(
    req: operations.RemoveAssetRequest,
    security: operations.RemoveAssetSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.RemoveAssetResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.RemoveAssetRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/org/assets/{asset_id}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.RemoveAssetSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.RemoveAssetResponse =
        new operations.RemoveAssetResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case [204, 401, 404].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Remove the current API key
   */
  removeKey(
    config?: AxiosRequestConfig
  ): Promise<operations.RemoveKeyResponse> {
    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/org/key";

    const client: AxiosInstance = this._defaultClient;

    const r = client.request({
      url: url,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.RemoveKeyResponse =
        new operations.RemoveKeyResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case [204, 401].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Remove a service
   */
  removeService(
    req: operations.RemoveServiceRequest,
    security: operations.RemoveServiceSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.RemoveServiceResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.RemoveServiceRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/org/services/{service_id}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.RemoveServiceSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.RemoveServiceResponse =
        new operations.RemoveServiceResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case [204, 401, 404].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Remove a site and associated assets
   */
  removeSite(
    req: operations.RemoveSiteRequest,
    security: operations.RemoveSiteSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.RemoveSiteResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.RemoveSiteRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(baseURL, "/org/sites/{site_id}", req);
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.RemoveSiteSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.RemoveSiteResponse =
        new operations.RemoveSiteResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case [204, 401, 404].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Remove a wireless LAN
   */
  removeWirelessLAN(
    req: operations.RemoveWirelessLANRequest,
    security: operations.RemoveWirelessLANSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.RemoveWirelessLANResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.RemoveWirelessLANRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/org/wireless/{wireless_id}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.RemoveWirelessLANSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.RemoveWirelessLANResponse =
        new operations.RemoveWirelessLANResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case [204, 401, 404].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Rotate the API key secret and return the updated key
   */
  rotateKey(
    config?: AxiosRequestConfig
  ): Promise<operations.RotateKeyResponse> {
    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/org/key/rotate";

    const client: AxiosInstance = this._defaultClient;

    const r = client.request({
      url: url,
      method: "patch",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.RotateKeyResponse =
        new operations.RotateKeyResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.apiKey = utils.objectToClass(httpRes?.data, shared.APIKey);
          }
          break;
        case httpRes?.status == 401:
          break;
      }

      return res;
    });
  }

  /**
   * Signal that a task should be stopped or canceledThis will also remove recurring and scheduled tasks
   */
  stopTask(
    req: operations.StopTaskRequest,
    security: operations.StopTaskSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.StopTaskResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.StopTaskRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/org/tasks/{task_id}/stop",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.StopTaskSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "post",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.StopTaskResponse = new operations.StopTaskResponse({
        statusCode: httpRes.status,
        contentType: contentType,
        rawResponse: httpRes,
      });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `*/*`)) {
            const resBody: string = JSON.stringify(httpRes?.data, null, 0);
            const out: Uint8Array = new Uint8Array(resBody.length);
            for (let i = 0; i < resBody.length; i++)
              out[i] = resBody.charCodeAt(i);
            res.body = out;
          }
          break;
        case [401, 404].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Update the site associated with agent
   */
  updateAgentSite(
    req: operations.UpdateAgentSiteRequest,
    security: operations.UpdateAgentSiteSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.UpdateAgentSiteResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.UpdateAgentSiteRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/org/agents/{agent_id}",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "agentSiteID",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.UpdateAgentSiteSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "patch",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UpdateAgentSiteResponse =
        new operations.UpdateAgentSiteResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.agent = utils.objectToClass(httpRes?.data, shared.Agent);
          }
          break;
        case [401, 404].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Update asset comments
   */
  updateAssetComments(
    req: operations.UpdateAssetCommentsRequest,
    security: operations.UpdateAssetCommentsSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.UpdateAssetCommentsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.UpdateAssetCommentsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/org/assets/{asset_id}/comments",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "assetComments",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.UpdateAssetCommentsSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "patch",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UpdateAssetCommentsResponse =
        new operations.UpdateAssetCommentsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.asset = utils.objectToClass(httpRes?.data, shared.Asset);
          }
          break;
        case [401, 404].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Update asset tags
   */
  updateAssetTags(
    req: operations.UpdateAssetTagsRequest,
    security: operations.UpdateAssetTagsSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.UpdateAssetTagsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.UpdateAssetTagsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/org/assets/{asset_id}/tags",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "assetTags",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.UpdateAssetTagsSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "patch",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UpdateAssetTagsResponse =
        new operations.UpdateAssetTagsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.asset = utils.objectToClass(httpRes?.data, shared.Asset);
          }
          break;
        case [401, 404].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Update tags across multiple assets based on a search query
   */
  updateBulkAssetTags(
    req: shared.AssetTagsWithSearch,
    security: operations.UpdateBulkAssetTagsSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.UpdateBulkAssetTagsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new shared.AssetTagsWithSearch(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/org/assets/bulk/tags";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "request",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.UpdateBulkAssetTagsSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "patch",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UpdateBulkAssetTagsResponse =
        new operations.UpdateBulkAssetTagsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.statusMessage = httpRes?.data;
          }
          break;
        case [401, 404].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Update organization details
   */
  updateOrganization(
    req: shared.OrgOptions,
    security: operations.UpdateOrganizationSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.UpdateOrganizationResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new shared.OrgOptions(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/org";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "request",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.UpdateOrganizationSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "patch",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UpdateOrganizationResponse =
        new operations.UpdateOrganizationResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.organization = utils.objectToClass(
              httpRes?.data,
              shared.Organization
            );
          }
          break;
        case httpRes?.status == 401:
          break;
      }

      return res;
    });
  }

  /**
   * Update a site definition
   */
  updateSite(
    req: operations.UpdateSiteRequest,
    security: operations.UpdateSiteSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.UpdateSiteResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.UpdateSiteRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(baseURL, "/org/sites/{site_id}", req);

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "siteOptions",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.UpdateSiteSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "patch",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UpdateSiteResponse =
        new operations.UpdateSiteResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.site = utils.objectToClass(httpRes?.data, shared.Site);
          }
          break;
        case [401, 404].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Update task parameters
   */
  updateTask(
    req: operations.UpdateTaskRequest,
    security: operations.UpdateTaskSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.UpdateTaskResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.UpdateTaskRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(baseURL, "/org/tasks/{task_id}", req);

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "task",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.UpdateTaskSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "patch",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UpdateTaskResponse =
        new operations.UpdateTaskResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.task = utils.objectToClass(httpRes?.data, shared.Task);
          }
          break;
        case [401, 404].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Force an agent to update and restart
   */
  upgradeAgent(
    req: operations.UpgradeAgentRequest,
    security: operations.UpgradeAgentSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.UpgradeAgentResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.UpgradeAgentRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/org/agents/{agent_id}/update",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.UpgradeAgentSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "post",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UpgradeAgentResponse =
        new operations.UpgradeAgentResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case [204, 401, 404].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }
}
