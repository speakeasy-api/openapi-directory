/*
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

import * as utils from "../internal/utils";
import * as operations from "./models/operations";
import { AxiosInstance, AxiosRequestConfig, AxiosResponse } from "axios";

export class Codepush {
  _defaultClient: AxiosInstance;
  _securityClient: AxiosInstance;
  _serverURL: string;
  _language: string;
  _sdkVersion: string;
  _genVersion: string;

  constructor(
    defaultClient: AxiosInstance,
    securityClient: AxiosInstance,
    serverURL: string,
    language: string,
    sdkVersion: string,
    genVersion: string
  ) {
    this._defaultClient = defaultClient;
    this._securityClient = securityClient;
    this._serverURL = serverURL;
    this._language = language;
    this._sdkVersion = sdkVersion;
    this._genVersion = genVersion;
  }

  /**
   * Returns the acquisition service status to the caller
   */
  codePushAcquisitionGetAcquisitionStatus(
    config?: AxiosRequestConfig
  ): Promise<operations.CodePushAcquisitionGetAcquisitionStatusResponse> {
    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/v0.1/public/codepush/status";

    const client: AxiosInstance = this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CodePushAcquisitionGetAcquisitionStatusResponse =
        new operations.CodePushAcquisitionGetAcquisitionStatusResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.codePushAcquisitionGetAcquisitionStatus200ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.CodePushAcquisitionGetAcquisitionStatus200ApplicationJSON
              );
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.codePushAcquisitionGetAcquisitionStatusDefaultApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.CodePushAcquisitionGetAcquisitionStatusDefaultApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Check for updates
   */
  codePushAcquisitionUpdateCheck(
    req: operations.CodePushAcquisitionUpdateCheckRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.CodePushAcquisitionUpdateCheckResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CodePushAcquisitionUpdateCheckRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/v0.1/public/codepush/update_check";

    const client: AxiosInstance = this._defaultClient;

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CodePushAcquisitionUpdateCheckResponse =
        new operations.CodePushAcquisitionUpdateCheckResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.codePushAcquisitionUpdateCheck200ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.CodePushAcquisitionUpdateCheck200ApplicationJSON
              );
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.codePushAcquisitionUpdateCheckDefaultApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.CodePushAcquisitionUpdateCheckDefaultApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Report Deployment status metric
   */
  codePushAcquisitionUpdateDeployStatus(
    req: operations.CodePushAcquisitionUpdateDeployStatusRequestBody,
    config?: AxiosRequestConfig
  ): Promise<operations.CodePushAcquisitionUpdateDeployStatusResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CodePushAcquisitionUpdateDeployStatusRequestBody(
        req
      );
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/v0.1/public/codepush/report_status/deploy";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "request",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CodePushAcquisitionUpdateDeployStatusResponse =
        new operations.CodePushAcquisitionUpdateDeployStatusResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.codePushAcquisitionUpdateDeployStatusDefaultApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.CodePushAcquisitionUpdateDeployStatusDefaultApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Report download of specified release
   */
  codePushAcquisitionUpdateDownloadStatus(
    req: operations.CodePushAcquisitionUpdateDownloadStatusRequestBody,
    config?: AxiosRequestConfig
  ): Promise<operations.CodePushAcquisitionUpdateDownloadStatusResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CodePushAcquisitionUpdateDownloadStatusRequestBody(
        req
      );
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") +
      "/v0.1/public/codepush/report_status/download";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "request",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CodePushAcquisitionUpdateDownloadStatusResponse =
        new operations.CodePushAcquisitionUpdateDownloadStatusResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.codePushAcquisitionUpdateDownloadStatusDefaultApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.CodePushAcquisitionUpdateDownloadStatusDefaultApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Gets all releases metrics for specified Deployment
   */
  codePushDeploymentMetricsGet(
    req: operations.CodePushDeploymentMetricsGetRequest,
    security: operations.CodePushDeploymentMetricsGetSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.CodePushDeploymentMetricsGetResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CodePushDeploymentMetricsGetRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v0.1/apps/{owner_name}/{app_name}/deployments/{deployment_name}/metrics",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.CodePushDeploymentMetricsGetSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CodePushDeploymentMetricsGetResponse =
        new operations.CodePushDeploymentMetricsGetResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.codePushDeploymentMetricsGet200ApplicationJSONObjects = [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.codePushDeploymentMetricsGet200ApplicationJSONObjects =
              utils.objectToClass(
                httpRes?.data,
                operations.CodePushDeploymentMetricsGet200ApplicationJSON,
                resFieldDepth
              );
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.codePushDeploymentMetricsGetDefaultApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.CodePushDeploymentMetricsGetDefaultApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Rollback the latest or a specific release for an app deployment
   */
  codePushDeploymentReleaseRollback(
    req: operations.CodePushDeploymentReleaseRollbackRequest,
    security: operations.CodePushDeploymentReleaseRollbackSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.CodePushDeploymentReleaseRollbackResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CodePushDeploymentReleaseRollbackRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v0.1/apps/{owner_name}/{app_name}/deployments/{deployment_name}/rollback_release",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.CodePushDeploymentReleaseRollbackSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CodePushDeploymentReleaseRollbackResponse =
        new operations.CodePushDeploymentReleaseRollbackResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.codePushDeploymentReleaseRollback201ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.CodePushDeploymentReleaseRollback201ApplicationJSON
              );
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.codePushDeploymentReleaseRollbackDefaultApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.CodePushDeploymentReleaseRollbackDefaultApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Create a new CodePush release for the specified deployment
   */
  codePushDeploymentReleasesCreate(
    req: operations.CodePushDeploymentReleasesCreateRequest,
    security: operations.CodePushDeploymentReleasesCreateSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.CodePushDeploymentReleasesCreateResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CodePushDeploymentReleasesCreateRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v0.1/apps/{owner_name}/{app_name}/deployments/{deployment_name}/releases",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.CodePushDeploymentReleasesCreateSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CodePushDeploymentReleasesCreateResponse =
        new operations.CodePushDeploymentReleasesCreateResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.codePushDeploymentReleasesCreate201ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.CodePushDeploymentReleasesCreate201ApplicationJSON
              );
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.codePushDeploymentReleasesCreateDefaultApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.CodePushDeploymentReleasesCreateDefaultApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Clears a Deployment of releases
   */
  codePushDeploymentReleasesDelete(
    req: operations.CodePushDeploymentReleasesDeleteRequest,
    security: operations.CodePushDeploymentReleasesDeleteSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.CodePushDeploymentReleasesDeleteResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CodePushDeploymentReleasesDeleteRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v0.1/apps/{owner_name}/{app_name}/deployments/{deployment_name}/releases",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.CodePushDeploymentReleasesDeleteSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CodePushDeploymentReleasesDeleteResponse =
        new operations.CodePushDeploymentReleasesDeleteResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.codePushDeploymentReleasesDeleteDefaultApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.CodePushDeploymentReleasesDeleteDefaultApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Gets the history of releases on a Deployment
   */
  codePushDeploymentReleasesGet(
    req: operations.CodePushDeploymentReleasesGetRequest,
    security: operations.CodePushDeploymentReleasesGetSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.CodePushDeploymentReleasesGetResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CodePushDeploymentReleasesGetRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v0.1/apps/{owner_name}/{app_name}/deployments/{deployment_name}/releases",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.CodePushDeploymentReleasesGetSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CodePushDeploymentReleasesGetResponse =
        new operations.CodePushDeploymentReleasesGetResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.codePushDeploymentReleasesGet200ApplicationJSONAnies = [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.codePushDeploymentReleasesGet200ApplicationJSONAnies =
              utils.objectToClass(
                httpRes?.data,
                operations.CodePushDeploymentReleasesGet200ApplicationJSON,
                resFieldDepth
              );
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.codePushDeploymentReleasesGetDefaultApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.CodePushDeploymentReleasesGetDefaultApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Create a new CodePush release upload for the specified deployment
   */
  codePushDeploymentUploadCreate(
    req: operations.CodePushDeploymentUploadCreateRequest,
    security: operations.CodePushDeploymentUploadCreateSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.CodePushDeploymentUploadCreateResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CodePushDeploymentUploadCreateRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v0.1/apps/{owner_name}/{app_name}/deployments/{deployment_name}/uploads",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.CodePushDeploymentUploadCreateSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "post",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CodePushDeploymentUploadCreateResponse =
        new operations.CodePushDeploymentUploadCreateResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.codePushDeploymentUploadCreate200ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.CodePushDeploymentUploadCreate200ApplicationJSON
              );
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.codePushDeploymentUploadCreateDefaultApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.CodePushDeploymentUploadCreateDefaultApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Creates a CodePush Deployment for the given app
   */
  codePushDeploymentsCreate(
    req: operations.CodePushDeploymentsCreateRequest,
    security: operations.CodePushDeploymentsCreateSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.CodePushDeploymentsCreateResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CodePushDeploymentsCreateRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v0.1/apps/{owner_name}/{app_name}/deployments",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.CodePushDeploymentsCreateSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CodePushDeploymentsCreateResponse =
        new operations.CodePushDeploymentsCreateResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.codePushDeploymentsCreate201ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.CodePushDeploymentsCreate201ApplicationJSON
              );
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.codePushDeploymentsCreateDefaultApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.CodePushDeploymentsCreateDefaultApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Deletes a CodePush Deployment for the given app
   */
  codePushDeploymentsDelete(
    req: operations.CodePushDeploymentsDeleteRequest,
    security: operations.CodePushDeploymentsDeleteSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.CodePushDeploymentsDeleteResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CodePushDeploymentsDeleteRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v0.1/apps/{owner_name}/{app_name}/deployments/{deployment_name}",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.CodePushDeploymentsDeleteSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "delete",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CodePushDeploymentsDeleteResponse =
        new operations.CodePushDeploymentsDeleteResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.codePushDeploymentsDeleteDefaultApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.CodePushDeploymentsDeleteDefaultApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Gets a CodePush Deployment for the given app
   */
  codePushDeploymentsGet(
    req: operations.CodePushDeploymentsGetRequest,
    security: operations.CodePushDeploymentsGetSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.CodePushDeploymentsGetResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CodePushDeploymentsGetRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v0.1/apps/{owner_name}/{app_name}/deployments/{deployment_name}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.CodePushDeploymentsGetSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CodePushDeploymentsGetResponse =
        new operations.CodePushDeploymentsGetResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.codePushDeploymentsGet200ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.CodePushDeploymentsGet200ApplicationJSON
              );
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.codePushDeploymentsGetDefaultApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.CodePushDeploymentsGetDefaultApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Gets a list of CodePush deployments for the given app
   */
  codePushDeploymentsList(
    req: operations.CodePushDeploymentsListRequest,
    security: operations.CodePushDeploymentsListSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.CodePushDeploymentsListResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CodePushDeploymentsListRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v0.1/apps/{owner_name}/{app_name}/deployments",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.CodePushDeploymentsListSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CodePushDeploymentsListResponse =
        new operations.CodePushDeploymentsListResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.codePushDeploymentsList200ApplicationJSONObjects = [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.codePushDeploymentsList200ApplicationJSONObjects =
              utils.objectToClass(
                httpRes?.data,
                operations.CodePushDeploymentsList200ApplicationJSON,
                resFieldDepth
              );
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.codePushDeploymentsListDefaultApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.CodePushDeploymentsListDefaultApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Promote one release (default latest one) from one deployment to another
   */
  codePushDeploymentsPromote(
    req: operations.CodePushDeploymentsPromoteRequest,
    security: operations.CodePushDeploymentsPromoteSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.CodePushDeploymentsPromoteResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CodePushDeploymentsPromoteRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v0.1/apps/{owner_name}/{app_name}/deployments/{deployment_name}/promote_release/{promote_deployment_name}",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.CodePushDeploymentsPromoteSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CodePushDeploymentsPromoteResponse =
        new operations.CodePushDeploymentsPromoteResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.codePushDeploymentsPromote200ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.CodePushDeploymentsPromote200ApplicationJSON
              );
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.codePushDeploymentsPromoteDefaultApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.CodePushDeploymentsPromoteDefaultApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Modifies a CodePush Deployment for the given app
   */
  codePushDeploymentsUpdate(
    req: operations.CodePushDeploymentsUpdateRequest,
    security: operations.CodePushDeploymentsUpdateSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.CodePushDeploymentsUpdateResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CodePushDeploymentsUpdateRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v0.1/apps/{owner_name}/{app_name}/deployments/{deployment_name}",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.CodePushDeploymentsUpdateSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "patch",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CodePushDeploymentsUpdateResponse =
        new operations.CodePushDeploymentsUpdateResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.codePushDeploymentsUpdateDefaultApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.CodePushDeploymentsUpdateDefaultApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Modifies a CodePush release metadata under the given Deployment
   */
  deploymentReleasesUpdate(
    req: operations.DeploymentReleasesUpdateRequest,
    security: operations.DeploymentReleasesUpdateSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.DeploymentReleasesUpdateResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DeploymentReleasesUpdateRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v0.1/apps/{owner_name}/{app_name}/deployments/{deployment_name}/releases/{release_label}",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.DeploymentReleasesUpdateSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "patch",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DeploymentReleasesUpdateResponse =
        new operations.DeploymentReleasesUpdateResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.deploymentReleasesUpdate200ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.DeploymentReleasesUpdate200ApplicationJSON
              );
          }
          break;
        case httpRes?.status == 204:
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.deploymentReleasesUpdateDefaultApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.DeploymentReleasesUpdateDefaultApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Check for updates
   */
  legacyCodePushAcquisitionUpdateCheck(
    req: operations.LegacyCodePushAcquisitionUpdateCheckRequest,
    security: operations.LegacyCodePushAcquisitionUpdateCheckSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.LegacyCodePushAcquisitionUpdateCheckResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.LegacyCodePushAcquisitionUpdateCheckRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/v0.1/legacy/updateCheck";
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.LegacyCodePushAcquisitionUpdateCheckSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.LegacyCodePushAcquisitionUpdateCheckResponse =
        new operations.LegacyCodePushAcquisitionUpdateCheckResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.legacyCodePushAcquisitionUpdateCheck200ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.LegacyCodePushAcquisitionUpdateCheck200ApplicationJSON
              );
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.legacyCodePushAcquisitionUpdateCheckDefaultApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.LegacyCodePushAcquisitionUpdateCheckDefaultApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Report download of specified release
   */
  legacyCodePushAcquisitionUpdateDownloadStatus(
    req: operations.LegacyCodePushAcquisitionUpdateDownloadStatusRequestBody,
    security: operations.LegacyCodePushAcquisitionUpdateDownloadStatusSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.LegacyCodePushAcquisitionUpdateDownloadStatusResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.LegacyCodePushAcquisitionUpdateDownloadStatusRequestBody(
          req
        );
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/v0.1/legacy/reportStatus/download";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "request",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.LegacyCodePushAcquisitionUpdateDownloadStatusSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.LegacyCodePushAcquisitionUpdateDownloadStatusResponse =
        new operations.LegacyCodePushAcquisitionUpdateDownloadStatusResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.legacyCodePushAcquisitionUpdateDownloadStatusDefaultApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.LegacyCodePushAcquisitionUpdateDownloadStatusDefaultApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Report deploy of specified release
   */
  legacyCodePushAcquisitionUpdateInstallsStatus(
    req: operations.LegacyCodePushAcquisitionUpdateInstallsStatusRequestBody,
    security: operations.LegacyCodePushAcquisitionUpdateInstallsStatusSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.LegacyCodePushAcquisitionUpdateInstallsStatusResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.LegacyCodePushAcquisitionUpdateInstallsStatusRequestBody(
          req
        );
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/v0.1/legacy/reportStatus/deploy";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "request",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.LegacyCodePushAcquisitionUpdateInstallsStatusSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.LegacyCodePushAcquisitionUpdateInstallsStatusResponse =
        new operations.LegacyCodePushAcquisitionUpdateInstallsStatusResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.legacyCodePushAcquisitionUpdateInstallsStatusDefaultApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.LegacyCodePushAcquisitionUpdateInstallsStatusDefaultApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }
}
