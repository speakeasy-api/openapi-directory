// Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.

package shared

import (
	"encoding/json"
	"fmt"
)

// CounterStructuredNameOriginEnum - One of the standard Origins defined above.
type CounterStructuredNameOriginEnum string

const (
	CounterStructuredNameOriginEnumSystem CounterStructuredNameOriginEnum = "SYSTEM"
	CounterStructuredNameOriginEnumUser   CounterStructuredNameOriginEnum = "USER"
)

func (e *CounterStructuredNameOriginEnum) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return err
	}
	switch s {
	case "SYSTEM":
		fallthrough
	case "USER":
		*e = CounterStructuredNameOriginEnum(s)
		return nil
	default:
		return fmt.Errorf("invalid value for CounterStructuredNameOriginEnum: %s", s)
	}
}

// CounterStructuredNamePortionEnum - Portion of this counter, either key or value.
type CounterStructuredNamePortionEnum string

const (
	CounterStructuredNamePortionEnumAll   CounterStructuredNamePortionEnum = "ALL"
	CounterStructuredNamePortionEnumKey   CounterStructuredNamePortionEnum = "KEY"
	CounterStructuredNamePortionEnumValue CounterStructuredNamePortionEnum = "VALUE"
)

func (e *CounterStructuredNamePortionEnum) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return err
	}
	switch s {
	case "ALL":
		fallthrough
	case "KEY":
		fallthrough
	case "VALUE":
		*e = CounterStructuredNamePortionEnum(s)
		return nil
	default:
		return fmt.Errorf("invalid value for CounterStructuredNamePortionEnum: %s", s)
	}
}

// CounterStructuredName - Identifies a counter within a per-job namespace. Counters whose structured names are the same get merged into a single value for the job.
type CounterStructuredName struct {
	// Name of the optimized step being executed by the workers.
	ComponentStepName *string `json:"componentStepName,omitempty"`
	// Name of the stage. An execution step contains multiple component steps.
	ExecutionStepName *string `json:"executionStepName,omitempty"`
	// Index of an input collection that's being read from/written to as a side input. The index identifies a step's side inputs starting by 1 (e.g. the first side input has input_index 1, the third has input_index 3). Side inputs are identified by a pair of (original_step_name, input_index). This field helps uniquely identify them.
	InputIndex *int `json:"inputIndex,omitempty"`
	// Counter name. Not necessarily globally-unique, but unique within the context of the other fields. Required.
	Name *string `json:"name,omitempty"`
	// One of the standard Origins defined above.
	Origin *CounterStructuredNameOriginEnum `json:"origin,omitempty"`
	// A string containing a more specific namespace of the counter's origin.
	OriginNamespace *string `json:"originNamespace,omitempty"`
	// The step name requesting an operation, such as GBK. I.e. the ParDo causing a read/write from shuffle to occur, or a read from side inputs.
	OriginalRequestingStepName *string `json:"originalRequestingStepName,omitempty"`
	// System generated name of the original step in the user's graph, before optimization.
	OriginalStepName *string `json:"originalStepName,omitempty"`
	// Portion of this counter, either key or value.
	Portion *CounterStructuredNamePortionEnum `json:"portion,omitempty"`
	// ID of a particular worker.
	WorkerID *string `json:"workerId,omitempty"`
}
