"""Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT."""

from __future__ import annotations
import dataclasses
import requests as requests_http
from dataclasses_json import Undefined, dataclass_json
from enum import Enum
from sdk import utils
from typing import Optional


@dataclasses.dataclass
class GetNetworkApplianceTrafficShapingUplinkSelectionRequest:
    
    network_id: str = dataclasses.field(metadata={'path_param': { 'field_name': 'networkId', 'style': 'simple', 'explode': False }})  
    
class GetNetworkApplianceTrafficShapingUplinkSelection200ApplicationJSONDefaultUplinkEnum(str, Enum):
    r"""The default uplink. Must be one of: 'wan1' or 'wan2'"""
    WAN1 = 'wan1'
    WAN2 = 'wan2'


@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class GetNetworkApplianceTrafficShapingUplinkSelection200ApplicationJSONFailoverAndFailbackImmediate:
    r"""Immediate WAN failover and failback"""
    
    enabled: bool = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('enabled') }})
    r"""Whether immediate WAN failover and failback is enabled"""  
    

@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class GetNetworkApplianceTrafficShapingUplinkSelection200ApplicationJSONFailoverAndFailback:
    r"""WAN failover and failback"""
    
    immediate: Optional[GetNetworkApplianceTrafficShapingUplinkSelection200ApplicationJSONFailoverAndFailbackImmediate] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('immediate'), 'exclude': lambda f: f is None }})
    r"""Immediate WAN failover and failback"""  
    
class GetNetworkApplianceTrafficShapingUplinkSelection200ApplicationJSONVpnTrafficUplinkPreferencesFailOverCriterionEnum(str, Enum):
    r"""Fail over criterion for uplink preference rule. Must be one of: 'poorPerformance' or 'uplinkDown'"""
    POOR_PERFORMANCE = 'poorPerformance'
    UPLINK_DOWN = 'uplinkDown'

class GetNetworkApplianceTrafficShapingUplinkSelection200ApplicationJSONVpnTrafficUplinkPreferencesPerformanceClassBuiltinPerformanceClassNameEnum(str, Enum):
    r"""Name of builtin performance class. Must be present when performanceClass type is 'builtin' and value must be one of: 'VoIP'"""
    VO_IP = 'VoIP'

class GetNetworkApplianceTrafficShapingUplinkSelection200ApplicationJSONVpnTrafficUplinkPreferencesPerformanceClassTypeEnum(str, Enum):
    r"""Type of this performance class. Must be one of: 'builtin' or 'custom'"""
    BUILTIN = 'builtin'
    CUSTOM = 'custom'


@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class GetNetworkApplianceTrafficShapingUplinkSelection200ApplicationJSONVpnTrafficUplinkPreferencesPerformanceClass:
    r"""Performance class setting for uplink preference rule"""
    
    type: GetNetworkApplianceTrafficShapingUplinkSelection200ApplicationJSONVpnTrafficUplinkPreferencesPerformanceClassTypeEnum = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('type') }})
    r"""Type of this performance class. Must be one of: 'builtin' or 'custom'"""  
    builtin_performance_class_name: Optional[GetNetworkApplianceTrafficShapingUplinkSelection200ApplicationJSONVpnTrafficUplinkPreferencesPerformanceClassBuiltinPerformanceClassNameEnum] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('builtinPerformanceClassName'), 'exclude': lambda f: f is None }})
    r"""Name of builtin performance class. Must be present when performanceClass type is 'builtin' and value must be one of: 'VoIP'"""  
    custom_performance_class_id: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('customPerformanceClassId'), 'exclude': lambda f: f is None }})
    r"""ID of created custom performance class, must be present when performanceClass type is \\"custom\\" """  
    
class GetNetworkApplianceTrafficShapingUplinkSelection200ApplicationJSONVpnTrafficUplinkPreferencesPreferredUplinkEnum(str, Enum):
    r"""Preferred uplink for uplink preference rule. Must be one of: 'wan1', 'wan2', 'bestForVoIP', 'loadBalancing' or 'defaultUplink'"""
    BEST_FOR_VO_IP = 'bestForVoIP'
    DEFAULT_UPLINK = 'defaultUplink'
    LOAD_BALANCING = 'loadBalancing'
    WAN1 = 'wan1'
    WAN2 = 'wan2'

class GetNetworkApplianceTrafficShapingUplinkSelection200ApplicationJSONVpnTrafficUplinkPreferencesTrafficFiltersTypeEnum(str, Enum):
    r"""Traffic filter type. Must be one of: 'applicationCategory', 'application' or 'custom'"""
    APPLICATION = 'application'
    APPLICATION_CATEGORY = 'applicationCategory'
    CUSTOM = 'custom'


@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class GetNetworkApplianceTrafficShapingUplinkSelection200ApplicationJSONVpnTrafficUplinkPreferencesTrafficFiltersValueDestination:
    r"""Destination of 'custom' type traffic filter"""
    
    cidr: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('cidr'), 'exclude': lambda f: f is None }})
    r"""CIDR format address (e.g.\\"192.168.10.1\\", which is the same as \\"192.168.10.1/32\\"), or \\"any\\". Cannot be used in combination with the \\"vlan\\" or \\"fqdn\\" property"""  
    fqdn: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('fqdn'), 'exclude': lambda f: f is None }})
    r"""FQDN format address. Cannot be used in combination with the \\"cidr\\" or \\"fqdn\\" property and is currently only available in the \\"destination\\" object of the \\"vpnTrafficUplinkPreference\\" object. E.g.: \\"www.google.com\\" """  
    host: Optional[int] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('host'), 'exclude': lambda f: f is None }})
    r"""Host ID in the VLAN. Should not exceed the VLAN subnet capacity. Must be used along with the \\"vlan\\" property and is currently only available under a template network."""  
    network: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('network'), 'exclude': lambda f: f is None }})
    r"""Meraki network ID. Currently only available under a template network, and the value should be ID of either same template network, or another template network currently. E.g.: \\"L_12345678\\"."""  
    port: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('port'), 'exclude': lambda f: f is None }})
    r"""E.g.: \\"any\\", \\"0\\" (also means \\"any\\"), \\"8080\\", \\"1-1024\\" """  
    vlan: Optional[int] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('vlan'), 'exclude': lambda f: f is None }})
    r"""VLAN ID of the configured VLAN in the Meraki network. Cannot be used in combination with the \\"cidr\\" or \\"fqdn\\" property and is currently only available under a template network."""  
    
class GetNetworkApplianceTrafficShapingUplinkSelection200ApplicationJSONVpnTrafficUplinkPreferencesTrafficFiltersValueProtocolEnum(str, Enum):
    r"""Protocol of 'custom' type traffic filter. Must be one of: 'tcp', 'udp', 'icmp', 'icmp6' or 'any'"""
    ANY = 'any'
    ICMP = 'icmp'
    ICMP6 = 'icmp6'
    TCP = 'tcp'
    UDP = 'udp'


@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class GetNetworkApplianceTrafficShapingUplinkSelection200ApplicationJSONVpnTrafficUplinkPreferencesTrafficFiltersValueSource:
    r"""Source of 'custom' type traffic filter"""
    
    cidr: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('cidr'), 'exclude': lambda f: f is None }})
    r"""CIDR format address (e.g.\\"192.168.10.1\\", which is the same as \\"192.168.10.1/32\\"), or \\"any\\". Cannot be used in combination with the \\"vlan\\" property"""  
    host: Optional[int] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('host'), 'exclude': lambda f: f is None }})
    r"""Host ID in the VLAN. Should not exceed the VLAN subnet capacity. Must be used along with the \\"vlan\\" property and is currently only available under a template network."""  
    network: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('network'), 'exclude': lambda f: f is None }})
    r"""Meraki network ID. Currently only available under a template network, and the value should be ID of either same template network, or another template network currently. E.g.: \\"L_12345678\\"."""  
    port: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('port'), 'exclude': lambda f: f is None }})
    r"""E.g.: \\"any\\", \\"0\\" (also means \\"any\\"), \\"8080\\", \\"1-1024\\" """  
    vlan: Optional[int] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('vlan'), 'exclude': lambda f: f is None }})
    r"""VLAN ID of the configured VLAN in the Meraki network. Cannot be used in combination with the \\"cidr\\" property and is currently only available under a template network."""  
    

@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class GetNetworkApplianceTrafficShapingUplinkSelection200ApplicationJSONVpnTrafficUplinkPreferencesTrafficFiltersValue:
    r"""Value of traffic filter"""
    
    destination: Optional[GetNetworkApplianceTrafficShapingUplinkSelection200ApplicationJSONVpnTrafficUplinkPreferencesTrafficFiltersValueDestination] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('destination'), 'exclude': lambda f: f is None }})
    r"""Destination of 'custom' type traffic filter"""  
    id: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('id'), 'exclude': lambda f: f is None }})
    r"""ID of 'applicationCategory' or 'application' type traffic filter"""  
    protocol: Optional[GetNetworkApplianceTrafficShapingUplinkSelection200ApplicationJSONVpnTrafficUplinkPreferencesTrafficFiltersValueProtocolEnum] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('protocol'), 'exclude': lambda f: f is None }})
    r"""Protocol of 'custom' type traffic filter. Must be one of: 'tcp', 'udp', 'icmp', 'icmp6' or 'any'"""  
    source: Optional[GetNetworkApplianceTrafficShapingUplinkSelection200ApplicationJSONVpnTrafficUplinkPreferencesTrafficFiltersValueSource] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('source'), 'exclude': lambda f: f is None }})
    r"""Source of 'custom' type traffic filter"""  
    

@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class GetNetworkApplianceTrafficShapingUplinkSelection200ApplicationJSONVpnTrafficUplinkPreferencesTrafficFilters:
    
    type: GetNetworkApplianceTrafficShapingUplinkSelection200ApplicationJSONVpnTrafficUplinkPreferencesTrafficFiltersTypeEnum = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('type') }})
    r"""Traffic filter type. Must be one of: 'applicationCategory', 'application' or 'custom'"""  
    value: GetNetworkApplianceTrafficShapingUplinkSelection200ApplicationJSONVpnTrafficUplinkPreferencesTrafficFiltersValue = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('value') }})
    r"""Value of traffic filter"""  
    

@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class GetNetworkApplianceTrafficShapingUplinkSelection200ApplicationJSONVpnTrafficUplinkPreferences:
    
    preferred_uplink: GetNetworkApplianceTrafficShapingUplinkSelection200ApplicationJSONVpnTrafficUplinkPreferencesPreferredUplinkEnum = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('preferredUplink') }})
    r"""Preferred uplink for uplink preference rule. Must be one of: 'wan1', 'wan2', 'bestForVoIP', 'loadBalancing' or 'defaultUplink'"""  
    traffic_filters: list[GetNetworkApplianceTrafficShapingUplinkSelection200ApplicationJSONVpnTrafficUplinkPreferencesTrafficFilters] = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('trafficFilters') }})
    r"""Traffic filters"""  
    fail_over_criterion: Optional[GetNetworkApplianceTrafficShapingUplinkSelection200ApplicationJSONVpnTrafficUplinkPreferencesFailOverCriterionEnum] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('failOverCriterion'), 'exclude': lambda f: f is None }})
    r"""Fail over criterion for uplink preference rule. Must be one of: 'poorPerformance' or 'uplinkDown'"""  
    performance_class: Optional[GetNetworkApplianceTrafficShapingUplinkSelection200ApplicationJSONVpnTrafficUplinkPreferencesPerformanceClass] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('performanceClass'), 'exclude': lambda f: f is None }})
    r"""Performance class setting for uplink preference rule"""  
    
class GetNetworkApplianceTrafficShapingUplinkSelection200ApplicationJSONWanTrafficUplinkPreferencesPreferredUplinkEnum(str, Enum):
    r"""Preferred uplink for uplink preference rule. Must be one of: 'wan1' or 'wan2'"""
    WAN1 = 'wan1'
    WAN2 = 'wan2'

class GetNetworkApplianceTrafficShapingUplinkSelection200ApplicationJSONWanTrafficUplinkPreferencesTrafficFiltersTypeEnum(str, Enum):
    r"""Traffic filter type. Must be \\"custom\\" """
    CUSTOM = 'custom'


@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class GetNetworkApplianceTrafficShapingUplinkSelection200ApplicationJSONWanTrafficUplinkPreferencesTrafficFiltersValueDestination:
    r"""Destination of 'custom' type traffic filter"""
    
    cidr: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('cidr'), 'exclude': lambda f: f is None }})
    r"""CIDR format address (e.g.\\"192.168.10.1\\", which is the same as \\"192.168.10.1/32\\"), or \\"any\\" """  
    port: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('port'), 'exclude': lambda f: f is None }})
    r"""E.g.: \\"any\\", \\"0\\" (also means \\"any\\"), \\"8080\\", \\"1-1024\\" """  
    
class GetNetworkApplianceTrafficShapingUplinkSelection200ApplicationJSONWanTrafficUplinkPreferencesTrafficFiltersValueProtocolEnum(str, Enum):
    r"""Protocol of 'custom' type traffic filter. Must be one of: 'tcp', 'udp', 'icmp6' or 'any'"""
    ANY = 'any'
    ICMP6 = 'icmp6'
    TCP = 'tcp'
    UDP = 'udp'


@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class GetNetworkApplianceTrafficShapingUplinkSelection200ApplicationJSONWanTrafficUplinkPreferencesTrafficFiltersValueSource:
    r"""Source of 'custom' type traffic filter"""
    
    cidr: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('cidr'), 'exclude': lambda f: f is None }})
    r"""CIDR format address (e.g.\\"192.168.10.1\\", which is the same as \\"192.168.10.1/32\\"), or \\"any\\". Cannot be used in combination with the \\"vlan\\" property"""  
    host: Optional[int] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('host'), 'exclude': lambda f: f is None }})
    r"""Host ID in the VLAN. Should not exceed the VLAN subnet capacity. Must be used along with the \\"vlan\\" property and is currently only available under a template network."""  
    port: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('port'), 'exclude': lambda f: f is None }})
    r"""E.g.: \\"any\\", \\"0\\" (also means \\"any\\"), \\"8080\\", \\"1-1024\\" """  
    vlan: Optional[int] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('vlan'), 'exclude': lambda f: f is None }})
    r"""VLAN ID of the configured VLAN in the Meraki network. Cannot be used in combination with the \\"cidr\\" property and is currently only available under a template network."""  
    

@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class GetNetworkApplianceTrafficShapingUplinkSelection200ApplicationJSONWanTrafficUplinkPreferencesTrafficFiltersValue:
    r"""Value of traffic filter"""
    
    destination: GetNetworkApplianceTrafficShapingUplinkSelection200ApplicationJSONWanTrafficUplinkPreferencesTrafficFiltersValueDestination = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('destination') }})
    r"""Destination of 'custom' type traffic filter"""  
    source: GetNetworkApplianceTrafficShapingUplinkSelection200ApplicationJSONWanTrafficUplinkPreferencesTrafficFiltersValueSource = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('source') }})
    r"""Source of 'custom' type traffic filter"""  
    protocol: Optional[GetNetworkApplianceTrafficShapingUplinkSelection200ApplicationJSONWanTrafficUplinkPreferencesTrafficFiltersValueProtocolEnum] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('protocol'), 'exclude': lambda f: f is None }})
    r"""Protocol of 'custom' type traffic filter. Must be one of: 'tcp', 'udp', 'icmp6' or 'any'"""  
    

@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class GetNetworkApplianceTrafficShapingUplinkSelection200ApplicationJSONWanTrafficUplinkPreferencesTrafficFilters:
    
    type: GetNetworkApplianceTrafficShapingUplinkSelection200ApplicationJSONWanTrafficUplinkPreferencesTrafficFiltersTypeEnum = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('type') }})
    r"""Traffic filter type. Must be \\"custom\\" """  
    value: GetNetworkApplianceTrafficShapingUplinkSelection200ApplicationJSONWanTrafficUplinkPreferencesTrafficFiltersValue = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('value') }})
    r"""Value of traffic filter"""  
    

@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class GetNetworkApplianceTrafficShapingUplinkSelection200ApplicationJSONWanTrafficUplinkPreferences:
    
    preferred_uplink: GetNetworkApplianceTrafficShapingUplinkSelection200ApplicationJSONWanTrafficUplinkPreferencesPreferredUplinkEnum = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('preferredUplink') }})
    r"""Preferred uplink for uplink preference rule. Must be one of: 'wan1' or 'wan2'"""  
    traffic_filters: list[GetNetworkApplianceTrafficShapingUplinkSelection200ApplicationJSONWanTrafficUplinkPreferencesTrafficFilters] = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('trafficFilters') }})
    r"""Traffic filters"""  
    

@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class GetNetworkApplianceTrafficShapingUplinkSelection200ApplicationJSON:
    r"""Successful operation"""
    
    active_active_auto_vpn_enabled: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('activeActiveAutoVpnEnabled'), 'exclude': lambda f: f is None }})
    r"""Whether active-active AutoVPN is enabled"""  
    default_uplink: Optional[GetNetworkApplianceTrafficShapingUplinkSelection200ApplicationJSONDefaultUplinkEnum] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('defaultUplink'), 'exclude': lambda f: f is None }})
    r"""The default uplink. Must be one of: 'wan1' or 'wan2'"""  
    failover_and_failback: Optional[GetNetworkApplianceTrafficShapingUplinkSelection200ApplicationJSONFailoverAndFailback] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('failoverAndFailback'), 'exclude': lambda f: f is None }})
    r"""WAN failover and failback"""  
    load_balancing_enabled: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('loadBalancingEnabled'), 'exclude': lambda f: f is None }})
    r"""Whether load balancing is enabled"""  
    vpn_traffic_uplink_preferences: Optional[list[GetNetworkApplianceTrafficShapingUplinkSelection200ApplicationJSONVpnTrafficUplinkPreferences]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('vpnTrafficUplinkPreferences'), 'exclude': lambda f: f is None }})
    r"""Uplink preference rules for VPN traffic"""  
    wan_traffic_uplink_preferences: Optional[list[GetNetworkApplianceTrafficShapingUplinkSelection200ApplicationJSONWanTrafficUplinkPreferences]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('wanTrafficUplinkPreferences'), 'exclude': lambda f: f is None }})
    r"""Uplink preference rules for WAN traffic"""  
    

@dataclasses.dataclass
class GetNetworkApplianceTrafficShapingUplinkSelectionResponse:
    
    content_type: str = dataclasses.field()  
    status_code: int = dataclasses.field()  
    get_network_appliance_traffic_shaping_uplink_selection_200_application_json_object: Optional[GetNetworkApplianceTrafficShapingUplinkSelection200ApplicationJSON] = dataclasses.field(default=None)
    r"""Successful operation"""  
    raw_response: Optional[requests_http.Response] = dataclasses.field(default=None)  
    