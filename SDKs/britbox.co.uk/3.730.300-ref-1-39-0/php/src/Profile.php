<?php

/**
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

declare(strict_types=1);

namespace OpenAPI\OpenAPI;

class Profile 
{

	// SDK private variables namespaced with _ to avoid conflicts with API models
	private \GuzzleHttp\ClientInterface $_defaultClient;
	private \GuzzleHttp\ClientInterface $_securityClient;
	private string $_serverUrl;
	private string $_language;
	private string $_sdkVersion;
	private string $_genVersion;	

	/**
	 * @param \GuzzleHttp\ClientInterface $defaultClient
	 * @param \GuzzleHttp\ClientInterface $securityClient
	 * @param string $serverUrl
	 * @param string $language
	 * @param string $sdkVersion
	 * @param string $genVersion
	 */
	public function __construct(\GuzzleHttp\ClientInterface $defaultClient, \GuzzleHttp\ClientInterface $securityClient, string $serverUrl, string $language, string $sdkVersion, string $genVersion)
	{
		$this->_defaultClient = $defaultClient;
		$this->_securityClient = $securityClient;
		$this->_serverUrl = $serverUrl;
		$this->_language = $language;
		$this->_sdkVersion = $sdkVersion;
		$this->_genVersion = $genVersion;
	}
	
    /**
     * Bookmark an item under the active profile.
     * 
     * Creates one if it doesn't exist, overwrites one if it does.
     * 
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\BookmarkItemRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\BookmarkItemSecurity $security
     * @return \OpenAPI\OpenAPI\Models\Operations\BookmarkItemResponse
     */
	public function bookmarkItem(
        \OpenAPI\OpenAPI\Models\Operations\BookmarkItemRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\BookmarkItemSecurity $security,
    ): \OpenAPI\OpenAPI\Models\Operations\BookmarkItemResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/account/profile/bookmarks/{itemId}', \OpenAPI\OpenAPI\Models\Operations\BookmarkItemRequest::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\BookmarkItemRequest::class, $request, null));
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('PUT', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\BookmarkItemResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->bookmark = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\Bookmark', 'json');
            }
        }
        else {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->serviceError = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\ServiceError', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Unbookmark an item under the active profile.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\DeleteItemBookmarkRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\DeleteItemBookmarkSecurity $security
     * @return \OpenAPI\OpenAPI\Models\Operations\DeleteItemBookmarkResponse
     */
	public function deleteItemBookmark(
        \OpenAPI\OpenAPI\Models\Operations\DeleteItemBookmarkRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\DeleteItemBookmarkSecurity $security,
    ): \OpenAPI\OpenAPI\Models\Operations\DeleteItemBookmarkResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/account/profile/bookmarks/{itemId}', \OpenAPI\OpenAPI\Models\Operations\DeleteItemBookmarkRequest::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\DeleteItemBookmarkRequest::class, $request, null));
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('DELETE', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\DeleteItemBookmarkResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 204) {
        }
        else {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->serviceError = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\ServiceError', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Remove the watched status of items under the active profile. Passing in
     * specific `itemId`s to the `item_ids` query parameter will cause only these
     * items to be removed. **If this list is missing all watched items will be
     * removed**
     * 
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\DeleteWatchedRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\DeleteWatchedSecurity $security
     * @return \OpenAPI\OpenAPI\Models\Operations\DeleteWatchedResponse
     */
	public function deleteWatched(
        \OpenAPI\OpenAPI\Models\Operations\DeleteWatchedRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\DeleteWatchedSecurity $security,
    ): \OpenAPI\OpenAPI\Models\Operations\DeleteWatchedResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/account/profile/watched');
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\DeleteWatchedRequest::class, $request, null));
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('DELETE', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\DeleteWatchedResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 204) {
        }
        else {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->serviceError = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\ServiceError', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Returns the list of bookmarked items under the active profile.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetBookmarkListRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\GetBookmarkListSecurity $security
     * @return \OpenAPI\OpenAPI\Models\Operations\GetBookmarkListResponse
     */
	public function getBookmarkList(
        \OpenAPI\OpenAPI\Models\Operations\GetBookmarkListRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\GetBookmarkListSecurity $security,
    ): \OpenAPI\OpenAPI\Models\Operations\GetBookmarkListResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/account/profile/bookmarks/list');
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\GetBookmarkListRequest::class, $request, null));
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetBookmarkListResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->itemList = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\ItemList', 'json');
            }
        }
        else {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->serviceError = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\ServiceError', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Get the map of bookmarked item ids (itemId => creationDate) under the active profile.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetBookmarksRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\GetBookmarksSecurity $security
     * @return \OpenAPI\OpenAPI\Models\Operations\GetBookmarksResponse
     */
	public function getBookmarks(
        \OpenAPI\OpenAPI\Models\Operations\GetBookmarksRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\GetBookmarksSecurity $security,
    ): \OpenAPI\OpenAPI\Models\Operations\GetBookmarksResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/account/profile/bookmarks');
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\GetBookmarksRequest::class, $request, null));
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetBookmarksResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->getBookmarks200ApplicationJSONObject = $serializer->deserialize((string)$httpResponse->getBody(), 'array<string, DateTime>', 'json');
            }
        }
        else {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->serviceError = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\ServiceError', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Returns a list of items which have been watched but not completed under the active
     * profile.
     * 
     * Multiple episodes under the same show may be watched or in progress, however only a
     * single item belonging to a particular show will be included in the returned list.
     * 
     * The next episode to continue watching for a particular show will be the most recent
     * incompletely watched episode, or the next episode following the most recently
     * completely watched episode. Based on the specified `show_item_type` type, either the next
     * episode, the season of the next episode, or the show will be included in the list.
     * 
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetContinueWatchingListRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\GetContinueWatchingListSecurity $security
     * @return \OpenAPI\OpenAPI\Models\Operations\GetContinueWatchingListResponse
     */
	public function getContinueWatchingList(
        \OpenAPI\OpenAPI\Models\Operations\GetContinueWatchingListRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\GetContinueWatchingListSecurity $security,
    ): \OpenAPI\OpenAPI\Models\Operations\GetContinueWatchingListResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/account/profile/continue-watching/list');
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\GetContinueWatchingListRequest::class, $request, null));
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetContinueWatchingListResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->itemList = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\ItemList', 'json');
            }
        }
        else {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->serviceError = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\ServiceError', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Get the bookmark for an item under the active profile.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetItemBookmarkRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\GetItemBookmarkSecurity $security
     * @return \OpenAPI\OpenAPI\Models\Operations\GetItemBookmarkResponse
     */
	public function getItemBookmark(
        \OpenAPI\OpenAPI\Models\Operations\GetItemBookmarkRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\GetItemBookmarkSecurity $security,
    ): \OpenAPI\OpenAPI\Models\Operations\GetItemBookmarkResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/account/profile/bookmarks/{itemId}', \OpenAPI\OpenAPI\Models\Operations\GetItemBookmarkRequest::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\GetItemBookmarkRequest::class, $request, null));
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetItemBookmarkResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->bookmark = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\Bookmark', 'json');
            }
        }
        else {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->serviceError = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\ServiceError', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Get the rating info for an item under the active profile.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetItemRatingRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\GetItemRatingSecurity $security
     * @return \OpenAPI\OpenAPI\Models\Operations\GetItemRatingResponse
     */
	public function getItemRating(
        \OpenAPI\OpenAPI\Models\Operations\GetItemRatingRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\GetItemRatingSecurity $security,
    ): \OpenAPI\OpenAPI\Models\Operations\GetItemRatingResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/account/profile/ratings/{itemId}', \OpenAPI\OpenAPI\Models\Operations\GetItemRatingRequest::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\GetItemRatingRequest::class, $request, null));
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetItemRatingResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->userRating = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\UserRating', 'json');
            }
        }
        else {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->serviceError = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\ServiceError', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Get the watched status info for an item under the active profile.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetItemWatchedStatusRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\GetItemWatchedStatusSecurity $security
     * @return \OpenAPI\OpenAPI\Models\Operations\GetItemWatchedStatusResponse
     */
	public function getItemWatchedStatus(
        \OpenAPI\OpenAPI\Models\Operations\GetItemWatchedStatusRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\GetItemWatchedStatusSecurity $security,
    ): \OpenAPI\OpenAPI\Models\Operations\GetItemWatchedStatusResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/account/profile/watched/{itemId}', \OpenAPI\OpenAPI\Models\Operations\GetItemWatchedStatusRequest::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\GetItemWatchedStatusRequest::class, $request, null));
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetItemWatchedStatusResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->watched = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\Watched', 'json');
            }
        }
        else {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->serviceError = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\ServiceError', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Returns the next item to play given a source item id.
     * 
     * For an unwatched show it returns the first episode available to the account.
     * 
     * For a watched show it returns the last incompletely watched episode by the profile,
     * or the episode that immediately follows the last completely watched episode 
     * or nothing.
     * 
     * For an episode it always returns the immediately following episode, if available to
     * the account, or nothing.
     * 
     * If the response does not contain a `next` property then no item was found.
     * 
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetNextPlaybackItemRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\GetNextPlaybackItemSecurity $security
     * @return \OpenAPI\OpenAPI\Models\Operations\GetNextPlaybackItemResponse
     */
	public function getNextPlaybackItem(
        \OpenAPI\OpenAPI\Models\Operations\GetNextPlaybackItemRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\GetNextPlaybackItemSecurity $security,
    ): \OpenAPI\OpenAPI\Models\Operations\GetNextPlaybackItemResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/account/profile/items/{itemId}/next', \OpenAPI\OpenAPI\Models\Operations\GetNextPlaybackItemRequest::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\GetNextPlaybackItemRequest::class, $request, null));
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetNextPlaybackItemResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->nextPlaybackItem = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\NextPlaybackItem', 'json');
            }
        }
        else {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->serviceError = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\ServiceError', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Get the details of the active profile, including watched, bookmarked and rated items.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetProfileRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\GetProfileSecurity $security
     * @return \OpenAPI\OpenAPI\Models\Operations\GetProfileResponse
     */
	public function getProfile(
        \OpenAPI\OpenAPI\Models\Operations\GetProfileRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\GetProfileSecurity $security,
    ): \OpenAPI\OpenAPI\Models\Operations\GetProfileResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/account/profile');
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\GetProfileRequest::class, $request, null));
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetProfileResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->profileDetail = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\ProfileDetail', 'json');
            }
        }
        else {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->serviceError = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\ServiceError', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Get the map of rated item ids (itemId => rating out of 10) under the active profile.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetRatingsRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\GetRatingsSecurity $security
     * @return \OpenAPI\OpenAPI\Models\Operations\GetRatingsResponse
     */
	public function getRatings(
        \OpenAPI\OpenAPI\Models\Operations\GetRatingsRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\GetRatingsSecurity $security,
    ): \OpenAPI\OpenAPI\Models\Operations\GetRatingsResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/account/profile/ratings');
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\GetRatingsRequest::class, $request, null));
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetRatingsResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->getRatings200ApplicationJSONObject = $serializer->deserialize((string)$httpResponse->getBody(), 'array<string, int>', 'json');
            }
        }
        else {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->serviceError = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\ServiceError', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Returns the list of rated items under the active profile.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetRatingsListRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\GetRatingsListSecurity $security
     * @return \OpenAPI\OpenAPI\Models\Operations\GetRatingsListResponse
     */
	public function getRatingsList(
        \OpenAPI\OpenAPI\Models\Operations\GetRatingsListRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\GetRatingsListSecurity $security,
    ): \OpenAPI\OpenAPI\Models\Operations\GetRatingsListResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/account/profile/ratings/list');
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\GetRatingsListRequest::class, $request, null));
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetRatingsListResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->itemList = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\ItemList', 'json');
            }
        }
        else {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->serviceError = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\ServiceError', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Get the map of watched item ids (itemId => last playhead position) under the active profile.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetWatchedRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\GetWatchedSecurity $security
     * @return \OpenAPI\OpenAPI\Models\Operations\GetWatchedResponse
     */
	public function getWatched(
        \OpenAPI\OpenAPI\Models\Operations\GetWatchedRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\GetWatchedSecurity $security,
    ): \OpenAPI\OpenAPI\Models\Operations\GetWatchedResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/account/profile/watched');
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\GetWatchedRequest::class, $request, null));
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetWatchedResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->getWatched200ApplicationJSONObject = $serializer->deserialize((string)$httpResponse->getBody(), 'array<string, OpenAPI\OpenAPI\Models\Shared\Watched>', 'json');
            }
        }
        else {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->serviceError = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\ServiceError', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Returns the list of watched items under the active profile.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetWatchedListRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\GetWatchedListSecurity $security
     * @return \OpenAPI\OpenAPI\Models\Operations\GetWatchedListResponse
     */
	public function getWatchedList(
        \OpenAPI\OpenAPI\Models\Operations\GetWatchedListRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\GetWatchedListSecurity $security,
    ): \OpenAPI\OpenAPI\Models\Operations\GetWatchedListResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/account/profile/watched/list');
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\GetWatchedListRequest::class, $request, null));
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetWatchedListResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->itemList = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\ItemList', 'json');
            }
        }
        else {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->serviceError = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\ServiceError', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Rate an item under the active profile.
     * 
     * Creates one if it doesn't exist, overwrites one if it does.
     * 
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\RateItemRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\RateItemSecurity $security
     * @return \OpenAPI\OpenAPI\Models\Operations\RateItemResponse
     */
	public function rateItem(
        \OpenAPI\OpenAPI\Models\Operations\RateItemRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\RateItemSecurity $security,
    ): \OpenAPI\OpenAPI\Models\Operations\RateItemResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/account/profile/ratings/{itemId}', \OpenAPI\OpenAPI\Models\Operations\RateItemRequest::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\RateItemRequest::class, $request, null));
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('PUT', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\RateItemResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->userRating = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\UserRating', 'json');
            }
        }
        else {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->serviceError = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\ServiceError', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Record the watched playhead position of a video under the active profile.
     * 
     * Can be used later to resume a video from where it was last watched.
     * 
     * Creates one if it doesn't exist, overwrites one if it does.
     * 
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\SetItemWatchedStatusRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\SetItemWatchedStatusSecurity $security
     * @return \OpenAPI\OpenAPI\Models\Operations\SetItemWatchedStatusResponse
     */
	public function setItemWatchedStatus(
        \OpenAPI\OpenAPI\Models\Operations\SetItemWatchedStatusRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\SetItemWatchedStatusSecurity $security,
    ): \OpenAPI\OpenAPI\Models\Operations\SetItemWatchedStatusResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/account/profile/watched/{itemId}', \OpenAPI\OpenAPI\Models\Operations\SetItemWatchedStatusRequest::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\SetItemWatchedStatusRequest::class, $request, null));
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('PUT', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\SetItemWatchedStatusResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->watched = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\Watched', 'json');
            }
        }
        else if ($httpResponse->getStatusCode() === 204) {
        }
        else {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->serviceError = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\ServiceError', 'json');
            }
        }

        return $response;
    }
}