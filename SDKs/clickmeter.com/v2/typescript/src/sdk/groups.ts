/*
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

import * as utils from "../internal/utils";
import * as operations from "./models/operations";
import * as shared from "./models/shared";
import { AxiosInstance, AxiosRequestConfig, AxiosResponse } from "axios";

export class Groups {
  _defaultClient: AxiosInstance;
  _securityClient: AxiosInstance;
  _serverURL: string;
  _language: string;
  _sdkVersion: string;
  _genVersion: string;

  constructor(
    defaultClient: AxiosInstance,
    securityClient: AxiosInstance,
    serverURL: string,
    language: string,
    sdkVersion: string,
    genVersion: string
  ) {
    this._defaultClient = defaultClient;
    this._securityClient = securityClient;
    this._serverURL = serverURL;
    this._language = language;
    this._sdkVersion = sdkVersion;
    this._genVersion = genVersion;
  }

  /**
   * Count the groups associated to the user.
   */
  groupsCount(
    req: operations.GroupsCountRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GroupsCountResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GroupsCountRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/groups/count";

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GroupsCountResponse =
        new operations.GroupsCountResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.apiCoreResponsesCountResponce = utils.objectToClass(
              httpRes?.data,
              shared.ApiCoreResponsesCountResponce
            );
          }
          if (utils.matchContentType(contentType, `text/json`)) {
            res.apiCoreResponsesCountResponce = utils.objectToClass(
              httpRes?.data,
              shared.ApiCoreResponsesCountResponce
            );
          }
          if (utils.matchContentType(contentType, `application/xml`)) {
            const resBody: string = JSON.stringify(httpRes?.data, null, 0);
            const out: Uint8Array = new Uint8Array(resBody.length);
            for (let i = 0; i < resBody.length; i++)
              out[i] = resBody.charCodeAt(i);
            res.body = out;
          }
          if (utils.matchContentType(contentType, `text/xml`)) {
            const resBody: string = JSON.stringify(httpRes?.data, null, 0);
            const out: Uint8Array = new Uint8Array(resBody.length);
            for (let i = 0; i < resBody.length; i++)
              out[i] = resBody.charCodeAt(i);
            res.body = out;
          }
          break;
        case [401, 404, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Delete group specified by id
   */
  groupsDelete(
    req: operations.GroupsDeleteRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GroupsDeleteResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GroupsDeleteRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(baseURL, "/groups/{id}", req);

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GroupsDeleteResponse =
        new operations.GroupsDeleteResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.apiCoreResponsesEntityUriSystemInt64 = utils.objectToClass(
              httpRes?.data,
              shared.ApiCoreResponsesEntityUriSystemInt64
            );
          }
          if (utils.matchContentType(contentType, `text/json`)) {
            res.apiCoreResponsesEntityUriSystemInt64 = utils.objectToClass(
              httpRes?.data,
              shared.ApiCoreResponsesEntityUriSystemInt64
            );
          }
          if (utils.matchContentType(contentType, `application/xml`)) {
            const resBody: string = JSON.stringify(httpRes?.data, null, 0);
            const out: Uint8Array = new Uint8Array(resBody.length);
            for (let i = 0; i < resBody.length; i++)
              out[i] = resBody.charCodeAt(i);
            res.body = out;
          }
          if (utils.matchContentType(contentType, `text/xml`)) {
            const resBody: string = JSON.stringify(httpRes?.data, null, 0);
            const out: Uint8Array = new Uint8Array(resBody.length);
            for (let i = 0; i < resBody.length; i++)
              out[i] = resBody.charCodeAt(i);
            res.body = out;
          }
          break;
        case [401, 404, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * List of all the groups associated to the user.
   */
  groupsGet(
    req: operations.GroupsGetRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GroupsGetResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GroupsGetRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/groups";

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GroupsGetResponse =
        new operations.GroupsGetResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.apiCoreResponsesEntitiesResponseApiCoreResponsesEntityUriSystemInt64 =
              utils.objectToClass(
                httpRes?.data,
                shared.ApiCoreResponsesEntitiesResponseApiCoreResponsesEntityUriSystemInt64
              );
          }
          if (utils.matchContentType(contentType, `text/json`)) {
            res.apiCoreResponsesEntitiesResponseApiCoreResponsesEntityUriSystemInt64 =
              utils.objectToClass(
                httpRes?.data,
                shared.ApiCoreResponsesEntitiesResponseApiCoreResponsesEntityUriSystemInt64
              );
          }
          break;
        case [401, 404, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * List of all the datapoints associated to the user in this group.
   */
  groupsGetDatapoints(
    req: operations.GroupsGetDatapointsRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GroupsGetDatapointsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GroupsGetDatapointsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/groups/{id}/datapoints",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GroupsGetDatapointsResponse =
        new operations.GroupsGetDatapointsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.apiCoreResponsesEntitiesResponseApiCoreResponsesEntityUriSystemInt64 =
              utils.objectToClass(
                httpRes?.data,
                shared.ApiCoreResponsesEntitiesResponseApiCoreResponsesEntityUriSystemInt64
              );
          }
          if (utils.matchContentType(contentType, `text/json`)) {
            res.apiCoreResponsesEntitiesResponseApiCoreResponsesEntityUriSystemInt64 =
              utils.objectToClass(
                httpRes?.data,
                shared.ApiCoreResponsesEntitiesResponseApiCoreResponsesEntityUriSystemInt64
              );
          }
          break;
        case [401, 404, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Count the datapoints associated to the user in this group.
   */
  groupsGetDatapointsCount(
    req: operations.GroupsGetDatapointsCountRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GroupsGetDatapointsCountResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GroupsGetDatapointsCountRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/groups/{id}/datapoints/count",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GroupsGetDatapointsCountResponse =
        new operations.GroupsGetDatapointsCountResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.apiCoreResponsesCountResponce = utils.objectToClass(
              httpRes?.data,
              shared.ApiCoreResponsesCountResponce
            );
          }
          if (utils.matchContentType(contentType, `text/json`)) {
            res.apiCoreResponsesCountResponce = utils.objectToClass(
              httpRes?.data,
              shared.ApiCoreResponsesCountResponce
            );
          }
          if (utils.matchContentType(contentType, `application/xml`)) {
            const resBody: string = JSON.stringify(httpRes?.data, null, 0);
            const out: Uint8Array = new Uint8Array(resBody.length);
            for (let i = 0; i < resBody.length; i++)
              out[i] = resBody.charCodeAt(i);
            res.body = out;
          }
          if (utils.matchContentType(contentType, `text/xml`)) {
            const resBody: string = JSON.stringify(httpRes?.data, null, 0);
            const out: Uint8Array = new Uint8Array(resBody.length);
            for (let i = 0; i < resBody.length; i++)
              out[i] = resBody.charCodeAt(i);
            res.body = out;
          }
          break;
        case [401, 404, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Retrieve statistics about a subset of datapoints for a timeframe with datapoints data
   */
  groupsGetDatapointsSummary(
    req: operations.GroupsGetDatapointsSummaryRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GroupsGetDatapointsSummaryResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GroupsGetDatapointsSummaryRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/groups/{id}/aggregated/summary",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GroupsGetDatapointsSummaryResponse =
        new operations.GroupsGetDatapointsSummaryResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.apiCoreDtoAggregatedAggregatedSummaryResult =
              utils.objectToClass(
                httpRes?.data,
                shared.ApiCoreDtoAggregatedAggregatedSummaryResult
              );
          }
          if (utils.matchContentType(contentType, `text/json`)) {
            res.apiCoreDtoAggregatedAggregatedSummaryResult =
              utils.objectToClass(
                httpRes?.data,
                shared.ApiCoreDtoAggregatedAggregatedSummaryResult
              );
          }
          break;
        case [401, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Retrieve the list of events related to this group.
   */
  groupsGetHits(
    req: operations.GroupsGetHitsRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GroupsGetHitsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GroupsGetHitsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(baseURL, "/groups/{id}/hits", req);

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GroupsGetHitsResponse =
        new operations.GroupsGetHitsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.apiCoreDtoClickStreamHitListPage = utils.objectToClass(
              httpRes?.data,
              shared.ApiCoreDtoClickStreamHitListPage
            );
          }
          if (utils.matchContentType(contentType, `text/json`)) {
            res.apiCoreDtoClickStreamHitListPage = utils.objectToClass(
              httpRes?.data,
              shared.ApiCoreDtoClickStreamHitListPage
            );
          }
          break;
        case [401, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Retrieve statistics about this customer for a timeframe by groups
   */
  groupsGetStatisticsAggregatedSingle(
    req: operations.GroupsGetStatisticsAggregatedSingleRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GroupsGetStatisticsAggregatedSingleResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GroupsGetStatisticsAggregatedSingleRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/groups/aggregated";

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GroupsGetStatisticsAggregatedSingleResponse =
        new operations.GroupsGetStatisticsAggregatedSingleResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.apiCoreDtoAggregatedAggregatedResult = utils.objectToClass(
              httpRes?.data,
              shared.ApiCoreDtoAggregatedAggregatedResult
            );
          }
          if (utils.matchContentType(contentType, `text/json`)) {
            res.apiCoreDtoAggregatedAggregatedResult = utils.objectToClass(
              httpRes?.data,
              shared.ApiCoreDtoAggregatedAggregatedResult
            );
          }
          break;
        case [401, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Retrieve statistics about all groups of this customer for a timeframe grouped by some temporal entity (day/week/month)
   */
  groupsGetStatisticsAllList(
    req: operations.GroupsGetStatisticsAllListRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GroupsGetStatisticsAllListResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GroupsGetStatisticsAllListRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/groups/aggregated/list";

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GroupsGetStatisticsAllListResponse =
        new operations.GroupsGetStatisticsAllListResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.apiCoreResponsesEntitiesResponseApiCoreDtoAggregatedAggregatedResult =
              utils.objectToClass(
                httpRes?.data,
                shared.ApiCoreResponsesEntitiesResponseApiCoreDtoAggregatedAggregatedResult
              );
          }
          if (utils.matchContentType(contentType, `text/json`)) {
            res.apiCoreResponsesEntitiesResponseApiCoreDtoAggregatedAggregatedResult =
              utils.objectToClass(
                httpRes?.data,
                shared.ApiCoreResponsesEntitiesResponseApiCoreDtoAggregatedAggregatedResult
              );
          }
          break;
        case [401, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Retrieve statistics about this group for a timeframe grouped by some temporal entity (day/week/month)
   */
  groupsGetStatisticsList(
    req: operations.GroupsGetStatisticsListRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GroupsGetStatisticsListResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GroupsGetStatisticsListRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/groups/{id}/aggregated/list",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GroupsGetStatisticsListResponse =
        new operations.GroupsGetStatisticsListResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.apiCoreResponsesEntitiesResponseApiCoreDtoAggregatedAggregatedResult =
              utils.objectToClass(
                httpRes?.data,
                shared.ApiCoreResponsesEntitiesResponseApiCoreDtoAggregatedAggregatedResult
              );
          }
          if (utils.matchContentType(contentType, `text/json`)) {
            res.apiCoreResponsesEntitiesResponseApiCoreDtoAggregatedAggregatedResult =
              utils.objectToClass(
                httpRes?.data,
                shared.ApiCoreResponsesEntitiesResponseApiCoreDtoAggregatedAggregatedResult
              );
          }
          break;
        case [401, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Retrieve statistics about this group for a timeframe
   */
  groupsGetStatisticsSingle(
    req: operations.GroupsGetStatisticsSingleRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GroupsGetStatisticsSingleResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GroupsGetStatisticsSingleRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/groups/{id}/aggregated",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GroupsGetStatisticsSingleResponse =
        new operations.GroupsGetStatisticsSingleResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.apiCoreDtoAggregatedAggregatedResult = utils.objectToClass(
              httpRes?.data,
              shared.ApiCoreDtoAggregatedAggregatedResult
            );
          }
          if (utils.matchContentType(contentType, `text/json`)) {
            res.apiCoreDtoAggregatedAggregatedResult = utils.objectToClass(
              httpRes?.data,
              shared.ApiCoreDtoAggregatedAggregatedResult
            );
          }
          break;
        case [401, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Fast switch the "favourite" field of a group
   */
  groupsPatchFavourite(
    req: operations.GroupsPatchFavouriteRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GroupsPatchFavouriteResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GroupsPatchFavouriteRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/groups/{id}/favourite",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "put",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GroupsPatchFavouriteResponse =
        new operations.GroupsPatchFavouriteResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.apiCoreResponsesEntityUriSystemInt64 = utils.objectToClass(
              httpRes?.data,
              shared.ApiCoreResponsesEntityUriSystemInt64
            );
          }
          if (utils.matchContentType(contentType, `text/json`)) {
            res.apiCoreResponsesEntityUriSystemInt64 = utils.objectToClass(
              httpRes?.data,
              shared.ApiCoreResponsesEntityUriSystemInt64
            );
          }
          if (utils.matchContentType(contentType, `application/xml`)) {
            const resBody: string = JSON.stringify(httpRes?.data, null, 0);
            const out: Uint8Array = new Uint8Array(resBody.length);
            for (let i = 0; i < resBody.length; i++)
              out[i] = resBody.charCodeAt(i);
            res.body = out;
          }
          if (utils.matchContentType(contentType, `text/xml`)) {
            const resBody: string = JSON.stringify(httpRes?.data, null, 0);
            const out: Uint8Array = new Uint8Array(resBody.length);
            for (let i = 0; i < resBody.length; i++)
              out[i] = resBody.charCodeAt(i);
            res.body = out;
          }
          break;
        case [401, 403, 404, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Fast patch the "notes" field of a group
   */
  groupsPatchNotesForm(
    req: operations.GroupsPatchNotesFormRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GroupsPatchNotesFormResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GroupsPatchNotesFormRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(baseURL, "/groups/{id}/notes", req);

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "apiCoreRequestsGenericTextPatch",
        "form"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "put",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GroupsPatchNotesFormResponse =
        new operations.GroupsPatchNotesFormResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.apiCoreResponsesEntityUriSystemInt64 = utils.objectToClass(
              httpRes?.data,
              shared.ApiCoreResponsesEntityUriSystemInt64
            );
          }
          if (utils.matchContentType(contentType, `text/json`)) {
            res.apiCoreResponsesEntityUriSystemInt64 = utils.objectToClass(
              httpRes?.data,
              shared.ApiCoreResponsesEntityUriSystemInt64
            );
          }
          if (utils.matchContentType(contentType, `application/xml`)) {
            const resBody: string = JSON.stringify(httpRes?.data, null, 0);
            const out: Uint8Array = new Uint8Array(resBody.length);
            for (let i = 0; i < resBody.length; i++)
              out[i] = resBody.charCodeAt(i);
            res.body = out;
          }
          if (utils.matchContentType(contentType, `text/xml`)) {
            const resBody: string = JSON.stringify(httpRes?.data, null, 0);
            const out: Uint8Array = new Uint8Array(resBody.length);
            for (let i = 0; i < resBody.length; i++)
              out[i] = resBody.charCodeAt(i);
            res.body = out;
          }
          break;
        case [401, 403, 404, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Fast patch the "notes" field of a group
   */
  groupsPatchNotesJson(
    req: operations.GroupsPatchNotesJsonRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GroupsPatchNotesJsonResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GroupsPatchNotesJsonRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(baseURL, "/groups/{id}/notes", req);

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "apiCoreRequestsGenericTextPatch",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "put",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GroupsPatchNotesJsonResponse =
        new operations.GroupsPatchNotesJsonResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.apiCoreResponsesEntityUriSystemInt64 = utils.objectToClass(
              httpRes?.data,
              shared.ApiCoreResponsesEntityUriSystemInt64
            );
          }
          if (utils.matchContentType(contentType, `text/json`)) {
            res.apiCoreResponsesEntityUriSystemInt64 = utils.objectToClass(
              httpRes?.data,
              shared.ApiCoreResponsesEntityUriSystemInt64
            );
          }
          if (utils.matchContentType(contentType, `application/xml`)) {
            const resBody: string = JSON.stringify(httpRes?.data, null, 0);
            const out: Uint8Array = new Uint8Array(resBody.length);
            for (let i = 0; i < resBody.length; i++)
              out[i] = resBody.charCodeAt(i);
            res.body = out;
          }
          if (utils.matchContentType(contentType, `text/xml`)) {
            const resBody: string = JSON.stringify(httpRes?.data, null, 0);
            const out: Uint8Array = new Uint8Array(resBody.length);
            for (let i = 0; i < resBody.length; i++)
              out[i] = resBody.charCodeAt(i);
            res.body = out;
          }
          break;
        case [401, 403, 404, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Fast patch the "notes" field of a group
   */
  groupsPatchNotesRaw(
    req: operations.GroupsPatchNotesRawRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GroupsPatchNotesRawResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GroupsPatchNotesRawRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(baseURL, "/groups/{id}/notes", req);

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "raw"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "put",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GroupsPatchNotesRawResponse =
        new operations.GroupsPatchNotesRawResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.apiCoreResponsesEntityUriSystemInt64 = utils.objectToClass(
              httpRes?.data,
              shared.ApiCoreResponsesEntityUriSystemInt64
            );
          }
          if (utils.matchContentType(contentType, `text/json`)) {
            res.apiCoreResponsesEntityUriSystemInt64 = utils.objectToClass(
              httpRes?.data,
              shared.ApiCoreResponsesEntityUriSystemInt64
            );
          }
          if (utils.matchContentType(contentType, `application/xml`)) {
            const resBody: string = JSON.stringify(httpRes?.data, null, 0);
            const out: Uint8Array = new Uint8Array(resBody.length);
            for (let i = 0; i < resBody.length; i++)
              out[i] = resBody.charCodeAt(i);
            res.body = out;
          }
          if (utils.matchContentType(contentType, `text/xml`)) {
            const resBody: string = JSON.stringify(httpRes?.data, null, 0);
            const out: Uint8Array = new Uint8Array(resBody.length);
            for (let i = 0; i < resBody.length; i++)
              out[i] = resBody.charCodeAt(i);
            res.body = out;
          }
          break;
        case [401, 403, 404, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Update a group
   */
  groupsPost(
    req: operations.GroupsPostRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GroupsPostResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GroupsPostRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(baseURL, "/groups/{id}", req);

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "apiCoreDtoGroupsGroup",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GroupsPostResponse =
        new operations.GroupsPostResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.apiCoreResponsesEntityUriSystemInt64 = utils.objectToClass(
              httpRes?.data,
              shared.ApiCoreResponsesEntityUriSystemInt64
            );
          }
          if (utils.matchContentType(contentType, `text/json`)) {
            res.apiCoreResponsesEntityUriSystemInt64 = utils.objectToClass(
              httpRes?.data,
              shared.ApiCoreResponsesEntityUriSystemInt64
            );
          }
          if (utils.matchContentType(contentType, `application/xml`)) {
            const resBody: string = JSON.stringify(httpRes?.data, null, 0);
            const out: Uint8Array = new Uint8Array(resBody.length);
            for (let i = 0; i < resBody.length; i++)
              out[i] = resBody.charCodeAt(i);
            res.body = out;
          }
          if (utils.matchContentType(contentType, `text/xml`)) {
            const resBody: string = JSON.stringify(httpRes?.data, null, 0);
            const out: Uint8Array = new Uint8Array(resBody.length);
            for (let i = 0; i < resBody.length; i++)
              out[i] = resBody.charCodeAt(i);
            res.body = out;
          }
          break;
        case [401, 404, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Create a group
   */
  groupsPut(
    req: shared.ApiCoreDtoGroupsGroup,
    config?: AxiosRequestConfig
  ): Promise<operations.GroupsPutResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new shared.ApiCoreDtoGroupsGroup(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/groups";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "request",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GroupsPutResponse =
        new operations.GroupsPutResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.apiCoreResponsesEntityUriSystemInt64 = utils.objectToClass(
              httpRes?.data,
              shared.ApiCoreResponsesEntityUriSystemInt64
            );
          }
          if (utils.matchContentType(contentType, `text/json`)) {
            res.apiCoreResponsesEntityUriSystemInt64 = utils.objectToClass(
              httpRes?.data,
              shared.ApiCoreResponsesEntityUriSystemInt64
            );
          }
          if (utils.matchContentType(contentType, `application/xml`)) {
            const resBody: string = JSON.stringify(httpRes?.data, null, 0);
            const out: Uint8Array = new Uint8Array(resBody.length);
            for (let i = 0; i < resBody.length; i++)
              out[i] = resBody.charCodeAt(i);
            res.body = out;
          }
          if (utils.matchContentType(contentType, `text/xml`)) {
            const resBody: string = JSON.stringify(httpRes?.data, null, 0);
            const out: Uint8Array = new Uint8Array(resBody.length);
            for (let i = 0; i < resBody.length; i++)
              out[i] = resBody.charCodeAt(i);
            res.body = out;
          }
          break;
        case [401, 404, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Create a datapoint in this group
   */
  groupsPutDatapoint(
    req: operations.GroupsPutDatapointRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GroupsPutDatapointResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GroupsPutDatapointRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/groups/{id}/datapoints",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "apiCoreDtoDatapointsDatapoint",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GroupsPutDatapointResponse =
        new operations.GroupsPutDatapointResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.apiCoreResponsesEntityUriSystemInt64 = utils.objectToClass(
              httpRes?.data,
              shared.ApiCoreResponsesEntityUriSystemInt64
            );
          }
          if (utils.matchContentType(contentType, `text/json`)) {
            res.apiCoreResponsesEntityUriSystemInt64 = utils.objectToClass(
              httpRes?.data,
              shared.ApiCoreResponsesEntityUriSystemInt64
            );
          }
          if (utils.matchContentType(contentType, `application/xml`)) {
            const resBody: string = JSON.stringify(httpRes?.data, null, 0);
            const out: Uint8Array = new Uint8Array(resBody.length);
            for (let i = 0; i < resBody.length; i++)
              out[i] = resBody.charCodeAt(i);
            res.body = out;
          }
          if (utils.matchContentType(contentType, `text/xml`)) {
            const resBody: string = JSON.stringify(httpRes?.data, null, 0);
            const out: Uint8Array = new Uint8Array(resBody.length);
            for (let i = 0; i < resBody.length; i++)
              out[i] = resBody.charCodeAt(i);
            res.body = out;
          }
          break;
        case [401, 404, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Get a group
   */
  getGroupsId(
    req: operations.GetGroupsIdRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetGroupsIdResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetGroupsIdRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(baseURL, "/groups/{id}", req);

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetGroupsIdResponse =
        new operations.GetGroupsIdResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.apiCoreDtoGroupsGroup = utils.objectToClass(
              httpRes?.data,
              shared.ApiCoreDtoGroupsGroup
            );
          }
          if (utils.matchContentType(contentType, `text/json`)) {
            res.apiCoreDtoGroupsGroup = utils.objectToClass(
              httpRes?.data,
              shared.ApiCoreDtoGroupsGroup
            );
          }
          break;
        case [401, 404, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }
}
