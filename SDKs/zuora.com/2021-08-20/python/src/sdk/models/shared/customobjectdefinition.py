"""Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT."""

from __future__ import annotations
import dataclasses
import dateutil.parser
from ..shared import customobjectcustomfielddefinition as shared_customobjectcustomfielddefinition
from dataclasses_json import Undefined, dataclass_json
from datetime import datetime
from enum import Enum
from marshmallow import fields
from sdk import utils
from typing import Optional

class CustomObjectDefinitionSchemaRelationshipsCardinalityEnum(str, Enum):
    r"""The cardinality of the relationship from this object to another object.
    
    A `manyToOne` relationship means this object is the child object (the \"many\" side), and the referenced object (the \"one\" side) is the parent.
    
    A `oneToMany` relationship means this object is the parent object (the \"one\" side), and the referenced object (the \"many\" side) is the child.
    """
    MANY_TO_ONE = 'manyToOne'
    ONE_TO_MANY = 'oneToMany'


@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class CustomObjectDefinitionSchemaRelationshipsRecordConstraintsCreate:
    
    enforce_valid_mapping: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('enforceValidMapping'), 'exclude': lambda f: f is None }})
    r"""Specifies whether Zuora validates the values of mapped fields
    in custom object records.
    """  
    

@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class CustomObjectDefinitionSchemaRelationshipsRecordConstraints:
    r"""Specifies contraints to apply to custom object records."""
    
    create: Optional[CustomObjectDefinitionSchemaRelationshipsRecordConstraintsCreate] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('create'), 'exclude': lambda f: f is None }})  
    

@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class CustomObjectDefinitionSchemaRelationships:
    
    cardinality: Optional[CustomObjectDefinitionSchemaRelationshipsCardinalityEnum] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('cardinality'), 'exclude': lambda f: f is None }})
    r"""The cardinality of the relationship from this object to another object.
    
    A `manyToOne` relationship means this object is the child object (the \"many\" side), and the referenced object (the \"one\" side) is the parent.
    
    A `oneToMany` relationship means this object is the parent object (the \"one\" side), and the referenced object (the \"many\" side) is the child.
    """  
    fields_: Optional[dict[str, str]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('fields'), 'exclude': lambda f: f is None }})
    r"""Field mappings in the form of `<this-object-field-name>`: `<other-object-field-name>`."""  
    namespace: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('namespace'), 'exclude': lambda f: f is None }})
    r"""The namespace where the related object is located"""  
    object: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('object'), 'exclude': lambda f: f is None }})
    r"""The API name of the related object"""  
    record_constraints: Optional[CustomObjectDefinitionSchemaRelationshipsRecordConstraints] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('recordConstraints'), 'exclude': lambda f: f is None }})
    r"""Specifies contraints to apply to custom object records."""  
    
class CustomObjectDefinitionSchemaTypeEnum(str, Enum):
    r"""The custom object definition type. Can only be `object` currently."""
    OBJECT = 'object'


@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class CustomObjectDefinitionSchema:
    r"""The schema of the custom object definition"""
    
    filterable: Optional[list[str]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('filterable'), 'exclude': lambda f: f is None }})
    r"""The set of fields that are allowed to be queried on. Queries on non-filterable fields will be rejected. You can not change a non-filterable field to filterable."""  
    label: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('label'), 'exclude': lambda f: f is None }})
    r"""A label for the custom object"""  
    object: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('object'), 'exclude': lambda f: f is None }})
    r"""The API name of the custom object"""  
    properties: Optional[dict[str, shared_customobjectcustomfielddefinition.CustomObjectCustomFieldDefinition]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('properties'), 'exclude': lambda f: f is None }})
    r"""The definitions of all the fields in the custom object definition"""  
    relationships: Optional[list[CustomObjectDefinitionSchemaRelationships]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('relationships'), 'exclude': lambda f: f is None }})
    r"""An array of relationships with Zuora objects or other custom objects"""  
    required: Optional[list[str]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('required'), 'exclude': lambda f: f is None }})
    r"""The required fields of the custom object definition. You can change required fields to optional. However, you can only change optional fields to required on the custom objects with no records."""  
    type: Optional[CustomObjectDefinitionSchemaTypeEnum] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('type'), 'exclude': lambda f: f is None }})
    r"""The custom object definition type. Can only be `object` currently."""  
    

@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class CustomObjectDefinition:
    r"""OK"""
    
    created_by_id: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('CreatedById'), 'exclude': lambda f: f is None }})
    r"""The creator's Id"""  
    created_date: Optional[datetime] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('CreatedDate'), 'encoder': utils.datetimeisoformat(True), 'decoder': dateutil.parser.isoparse, 'mm_field': fields.DateTime(format='iso'), 'exclude': lambda f: f is None }})
    r"""The creation time of the custom object definition in date-time format."""  
    id: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('Id'), 'exclude': lambda f: f is None }})
    r"""The unique Id of the custom object definition"""  
    schema: Optional[CustomObjectDefinitionSchema] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('schema'), 'exclude': lambda f: f is None }})
    r"""The schema of the custom object definition"""  
    type: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('type'), 'exclude': lambda f: f is None }})
    r"""The API name of the custom object"""  
    updated_by_id: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('UpdatedById'), 'exclude': lambda f: f is None }})
    r"""The modifier's Id"""  
    updated_date: Optional[datetime] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('UpdatedDate'), 'encoder': utils.datetimeisoformat(True), 'decoder': dateutil.parser.isoparse, 'mm_field': fields.DateTime(format='iso'), 'exclude': lambda f: f is None }})
    r"""The update time of the custom object definition in date-time format."""  
    