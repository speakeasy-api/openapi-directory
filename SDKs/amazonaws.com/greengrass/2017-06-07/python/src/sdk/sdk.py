"""Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT."""

import requests as requests_http
from . import utils
from sdk.models import operations, shared
from typing import Any, Optional

SERVERS = [
    "http://greengrass.{region}.amazonaws.com",
    r"""The AWS Greengrass multi-region endpoint"""
    "https://greengrass.{region}.amazonaws.com",
    r"""The AWS Greengrass multi-region endpoint"""
    "http://greengrass.{region}.amazonaws.com.cn",
    r"""The AWS Greengrass endpoint for China (Beijing) and China (Ningxia)"""
    "https://greengrass.{region}.amazonaws.com.cn",
    r"""The AWS Greengrass endpoint for China (Beijing) and China (Ningxia)"""
]
"""Contains the list of servers available to the SDK"""

class SDK:
    r"""AWS IoT Greengrass seamlessly extends AWS onto physical devices so they can act locally on the data they generate, while still using the cloud for management, analytics, and durable storage. AWS IoT Greengrass ensures your devices can respond quickly to local events and operate with intermittent connectivity. AWS IoT Greengrass minimizes the cost of transmitting data to the cloud by allowing you to author AWS Lambda functions that execute locally.
    https://docs.aws.amazon.com/greengrass/ - Amazon Web Services documentation
    """

    _client: requests_http.Session
    _security_client: requests_http.Session
    _server_url: str = SERVERS[0]
    _language: str = "python"
    _sdk_version: str = "0.0.1"
    _gen_version: str = "internal"

    def __init__(self,
                 security: shared.Security = None,
                 server_url: str = None,
                 url_params: dict[str, str] = None,
                 client: requests_http.Session = None
                 ) -> None:
        """Instantiates the SDK configuring it with the provided parameters.
        
        :param security: The security details required for authentication
        :type security: shared.Security
        :param server_url: The server URL to use for all operations
        :type server_url: str
        :param url_params: Parameters to optionally template the server URL with
        :type url_params: dict[str, str]
        :param client: The requests.Session HTTP client to use for all operations
        :type client: requests_http.Session        
        """
        self._client = requests_http.Session()
        
        
        if server_url is not None:
            if url_params is not None:
                self._server_url = utils.template_url(server_url, url_params)
            else:
                self._server_url = server_url

        if client is not None:
            self._client = client
        
        self._security_client = utils.configure_security_client(self._client, security)
        

        
    
    
    def associate_role_to_group(self, request: operations.AssociateRoleToGroupRequest) -> operations.AssociateRoleToGroupResponse:
        r"""Associates a role with a group. Your Greengrass core will use the role to access AWS cloud services. The role's permissions should allow Greengrass core Lambda functions to perform actions against the cloud."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.AssociateRoleToGroupRequest, base_url, '/greengrass/groups/{GroupId}/role', request)
        
        headers = utils.get_headers(request)
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = self._security_client
        
        http_res = client.request('PUT', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.AssociateRoleToGroupResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.AssociateRoleToGroupResponse])
                res.associate_role_to_group_response = out
        elif http_res.status_code == 480:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.bad_request_exception = out
        elif http_res.status_code == 481:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.internal_server_error_exception = out

        return res

    def associate_service_role_to_account(self, request: operations.AssociateServiceRoleToAccountRequest) -> operations.AssociateServiceRoleToAccountResponse:
        r"""Associates a role with your account. AWS IoT Greengrass will use the role to access your Lambda functions and AWS IoT resources. This is necessary for deployments to succeed. The role must have at least minimum permissions in the policy ''AWSGreengrassResourceAccessRolePolicy''."""
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/greengrass/servicerole'
        
        headers = utils.get_headers(request)
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = self._security_client
        
        http_res = client.request('PUT', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.AssociateServiceRoleToAccountResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.AssociateServiceRoleToAccountResponse])
                res.associate_service_role_to_account_response = out
        elif http_res.status_code == 480:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.bad_request_exception = out
        elif http_res.status_code == 481:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.internal_server_error_exception = out

        return res

    def create_connector_definition(self, request: operations.CreateConnectorDefinitionRequest) -> operations.CreateConnectorDefinitionResponse:
        r"""Creates a connector definition. You may provide the initial version of the connector definition now or use ''CreateConnectorDefinitionVersion'' at a later time."""
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/greengrass/definition/connectors'
        
        headers = utils.get_headers(request)
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = self._security_client
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.CreateConnectorDefinitionResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.CreateConnectorDefinitionResponse])
                res.create_connector_definition_response = out
        elif http_res.status_code == 480:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.bad_request_exception = out

        return res

    def create_connector_definition_version(self, request: operations.CreateConnectorDefinitionVersionRequest) -> operations.CreateConnectorDefinitionVersionResponse:
        r"""Creates a version of a connector definition which has already been defined."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.CreateConnectorDefinitionVersionRequest, base_url, '/greengrass/definition/connectors/{ConnectorDefinitionId}/versions', request)
        
        headers = utils.get_headers(request)
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = self._security_client
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.CreateConnectorDefinitionVersionResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.CreateConnectorDefinitionVersionResponse])
                res.create_connector_definition_version_response = out
        elif http_res.status_code == 480:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.bad_request_exception = out

        return res

    def create_core_definition(self, request: operations.CreateCoreDefinitionRequest) -> operations.CreateCoreDefinitionResponse:
        r"""Creates a core definition. You may provide the initial version of the core definition now or use ''CreateCoreDefinitionVersion'' at a later time. Greengrass groups must each contain exactly one Greengrass core."""
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/greengrass/definition/cores'
        
        headers = utils.get_headers(request)
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = self._security_client
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.CreateCoreDefinitionResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.CreateCoreDefinitionResponse])
                res.create_core_definition_response = out
        elif http_res.status_code == 480:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.bad_request_exception = out

        return res

    def create_core_definition_version(self, request: operations.CreateCoreDefinitionVersionRequest) -> operations.CreateCoreDefinitionVersionResponse:
        r"""Creates a version of a core definition that has already been defined. Greengrass groups must each contain exactly one Greengrass core."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.CreateCoreDefinitionVersionRequest, base_url, '/greengrass/definition/cores/{CoreDefinitionId}/versions', request)
        
        headers = utils.get_headers(request)
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = self._security_client
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.CreateCoreDefinitionVersionResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.CreateCoreDefinitionVersionResponse])
                res.create_core_definition_version_response = out
        elif http_res.status_code == 480:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.bad_request_exception = out

        return res

    def create_deployment(self, request: operations.CreateDeploymentRequest) -> operations.CreateDeploymentResponse:
        r"""Creates a deployment. ''CreateDeployment'' requests are idempotent with respect to the ''X-Amzn-Client-Token'' token and the request parameters."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.CreateDeploymentRequest, base_url, '/greengrass/groups/{GroupId}/deployments', request)
        
        headers = utils.get_headers(request)
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = self._security_client
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.CreateDeploymentResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.CreateDeploymentResponse])
                res.create_deployment_response = out
        elif http_res.status_code == 480:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.bad_request_exception = out

        return res

    def create_device_definition(self, request: operations.CreateDeviceDefinitionRequest) -> operations.CreateDeviceDefinitionResponse:
        r"""Creates a device definition. You may provide the initial version of the device definition now or use ''CreateDeviceDefinitionVersion'' at a later time."""
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/greengrass/definition/devices'
        
        headers = utils.get_headers(request)
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = self._security_client
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.CreateDeviceDefinitionResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.CreateDeviceDefinitionResponse])
                res.create_device_definition_response = out
        elif http_res.status_code == 480:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.bad_request_exception = out

        return res

    def create_device_definition_version(self, request: operations.CreateDeviceDefinitionVersionRequest) -> operations.CreateDeviceDefinitionVersionResponse:
        r"""Creates a version of a device definition that has already been defined."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.CreateDeviceDefinitionVersionRequest, base_url, '/greengrass/definition/devices/{DeviceDefinitionId}/versions', request)
        
        headers = utils.get_headers(request)
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = self._security_client
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.CreateDeviceDefinitionVersionResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.CreateDeviceDefinitionVersionResponse])
                res.create_device_definition_version_response = out
        elif http_res.status_code == 480:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.bad_request_exception = out

        return res

    def create_function_definition(self, request: operations.CreateFunctionDefinitionRequest) -> operations.CreateFunctionDefinitionResponse:
        r"""Creates a Lambda function definition which contains a list of Lambda functions and their configurations to be used in a group. You can create an initial version of the definition by providing a list of Lambda functions and their configurations now, or use ''CreateFunctionDefinitionVersion'' later."""
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/greengrass/definition/functions'
        
        headers = utils.get_headers(request)
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = self._security_client
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.CreateFunctionDefinitionResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.CreateFunctionDefinitionResponse])
                res.create_function_definition_response = out
        elif http_res.status_code == 480:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.bad_request_exception = out

        return res

    def create_function_definition_version(self, request: operations.CreateFunctionDefinitionVersionRequest) -> operations.CreateFunctionDefinitionVersionResponse:
        r"""Creates a version of a Lambda function definition that has already been defined."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.CreateFunctionDefinitionVersionRequest, base_url, '/greengrass/definition/functions/{FunctionDefinitionId}/versions', request)
        
        headers = utils.get_headers(request)
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = self._security_client
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.CreateFunctionDefinitionVersionResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.CreateFunctionDefinitionVersionResponse])
                res.create_function_definition_version_response = out
        elif http_res.status_code == 480:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.bad_request_exception = out

        return res

    def create_group(self, request: operations.CreateGroupRequest) -> operations.CreateGroupResponse:
        r"""Creates a group. You may provide the initial version of the group or use ''CreateGroupVersion'' at a later time. Tip: You can use the ''gg_group_setup'' package (https://github.com/awslabs/aws-greengrass-group-setup) as a library or command-line application to create and deploy Greengrass groups."""
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/greengrass/groups'
        
        headers = utils.get_headers(request)
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = self._security_client
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.CreateGroupResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.CreateGroupResponse])
                res.create_group_response = out
        elif http_res.status_code == 480:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.bad_request_exception = out

        return res

    def create_group_certificate_authority(self, request: operations.CreateGroupCertificateAuthorityRequest) -> operations.CreateGroupCertificateAuthorityResponse:
        r"""Creates a CA for the group. If a CA already exists, it will rotate the existing CA."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.CreateGroupCertificateAuthorityRequest, base_url, '/greengrass/groups/{GroupId}/certificateauthorities', request)
        
        headers = utils.get_headers(request)
        
        client = self._security_client
        
        http_res = client.request('POST', url, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.CreateGroupCertificateAuthorityResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.CreateGroupCertificateAuthorityResponse])
                res.create_group_certificate_authority_response = out
        elif http_res.status_code == 480:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.bad_request_exception = out
        elif http_res.status_code == 481:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.internal_server_error_exception = out

        return res

    def create_group_version(self, request: operations.CreateGroupVersionRequest) -> operations.CreateGroupVersionResponse:
        r"""Creates a version of a group which has already been defined."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.CreateGroupVersionRequest, base_url, '/greengrass/groups/{GroupId}/versions', request)
        
        headers = utils.get_headers(request)
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = self._security_client
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.CreateGroupVersionResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.CreateGroupVersionResponse])
                res.create_group_version_response = out
        elif http_res.status_code == 480:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.bad_request_exception = out

        return res

    def create_logger_definition(self, request: operations.CreateLoggerDefinitionRequest) -> operations.CreateLoggerDefinitionResponse:
        r"""Creates a logger definition. You may provide the initial version of the logger definition now or use ''CreateLoggerDefinitionVersion'' at a later time."""
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/greengrass/definition/loggers'
        
        headers = utils.get_headers(request)
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = self._security_client
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.CreateLoggerDefinitionResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.CreateLoggerDefinitionResponse])
                res.create_logger_definition_response = out
        elif http_res.status_code == 480:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.bad_request_exception = out

        return res

    def create_logger_definition_version(self, request: operations.CreateLoggerDefinitionVersionRequest) -> operations.CreateLoggerDefinitionVersionResponse:
        r"""Creates a version of a logger definition that has already been defined."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.CreateLoggerDefinitionVersionRequest, base_url, '/greengrass/definition/loggers/{LoggerDefinitionId}/versions', request)
        
        headers = utils.get_headers(request)
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = self._security_client
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.CreateLoggerDefinitionVersionResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.CreateLoggerDefinitionVersionResponse])
                res.create_logger_definition_version_response = out
        elif http_res.status_code == 480:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.bad_request_exception = out

        return res

    def create_resource_definition(self, request: operations.CreateResourceDefinitionRequest) -> operations.CreateResourceDefinitionResponse:
        r"""Creates a resource definition which contains a list of resources to be used in a group. You can create an initial version of the definition by providing a list of resources now, or use ''CreateResourceDefinitionVersion'' later."""
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/greengrass/definition/resources'
        
        headers = utils.get_headers(request)
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = self._security_client
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.CreateResourceDefinitionResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.CreateResourceDefinitionResponse])
                res.create_resource_definition_response = out
        elif http_res.status_code == 480:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.bad_request_exception = out

        return res

    def create_resource_definition_version(self, request: operations.CreateResourceDefinitionVersionRequest) -> operations.CreateResourceDefinitionVersionResponse:
        r"""Creates a version of a resource definition that has already been defined."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.CreateResourceDefinitionVersionRequest, base_url, '/greengrass/definition/resources/{ResourceDefinitionId}/versions', request)
        
        headers = utils.get_headers(request)
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = self._security_client
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.CreateResourceDefinitionVersionResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.CreateResourceDefinitionVersionResponse])
                res.create_resource_definition_version_response = out
        elif http_res.status_code == 480:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.bad_request_exception = out

        return res

    def create_software_update_job(self, request: operations.CreateSoftwareUpdateJobRequest) -> operations.CreateSoftwareUpdateJobResponse:
        r"""Creates a software update for a core or group of cores (specified as an IoT thing group.) Use this to update the OTA Agent as well as the Greengrass core software. It makes use of the IoT Jobs feature which provides additional commands to manage a Greengrass core software update job."""
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/greengrass/updates'
        
        headers = utils.get_headers(request)
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = self._security_client
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.CreateSoftwareUpdateJobResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.CreateSoftwareUpdateJobResponse])
                res.create_software_update_job_response = out
        elif http_res.status_code == 480:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.bad_request_exception = out
        elif http_res.status_code == 481:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.internal_server_error_exception = out

        return res

    def create_subscription_definition(self, request: operations.CreateSubscriptionDefinitionRequest) -> operations.CreateSubscriptionDefinitionResponse:
        r"""Creates a subscription definition. You may provide the initial version of the subscription definition now or use ''CreateSubscriptionDefinitionVersion'' at a later time."""
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/greengrass/definition/subscriptions'
        
        headers = utils.get_headers(request)
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = self._security_client
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.CreateSubscriptionDefinitionResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.CreateSubscriptionDefinitionResponse])
                res.create_subscription_definition_response = out
        elif http_res.status_code == 480:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.bad_request_exception = out

        return res

    def create_subscription_definition_version(self, request: operations.CreateSubscriptionDefinitionVersionRequest) -> operations.CreateSubscriptionDefinitionVersionResponse:
        r"""Creates a version of a subscription definition which has already been defined."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.CreateSubscriptionDefinitionVersionRequest, base_url, '/greengrass/definition/subscriptions/{SubscriptionDefinitionId}/versions', request)
        
        headers = utils.get_headers(request)
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = self._security_client
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.CreateSubscriptionDefinitionVersionResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.CreateSubscriptionDefinitionVersionResponse])
                res.create_subscription_definition_version_response = out
        elif http_res.status_code == 480:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.bad_request_exception = out

        return res

    def delete_connector_definition(self, request: operations.DeleteConnectorDefinitionRequest) -> operations.DeleteConnectorDefinitionResponse:
        r"""Deletes a connector definition."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.DeleteConnectorDefinitionRequest, base_url, '/greengrass/definition/connectors/{ConnectorDefinitionId}', request)
        
        headers = utils.get_headers(request)
        
        client = self._security_client
        
        http_res = client.request('DELETE', url, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DeleteConnectorDefinitionResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[dict[str, Any]])
                res.delete_connector_definition_response = out
        elif http_res.status_code == 480:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.bad_request_exception = out

        return res

    def delete_core_definition(self, request: operations.DeleteCoreDefinitionRequest) -> operations.DeleteCoreDefinitionResponse:
        r"""Deletes a core definition."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.DeleteCoreDefinitionRequest, base_url, '/greengrass/definition/cores/{CoreDefinitionId}', request)
        
        headers = utils.get_headers(request)
        
        client = self._security_client
        
        http_res = client.request('DELETE', url, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DeleteCoreDefinitionResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[dict[str, Any]])
                res.delete_core_definition_response = out
        elif http_res.status_code == 480:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.bad_request_exception = out

        return res

    def delete_device_definition(self, request: operations.DeleteDeviceDefinitionRequest) -> operations.DeleteDeviceDefinitionResponse:
        r"""Deletes a device definition."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.DeleteDeviceDefinitionRequest, base_url, '/greengrass/definition/devices/{DeviceDefinitionId}', request)
        
        headers = utils.get_headers(request)
        
        client = self._security_client
        
        http_res = client.request('DELETE', url, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DeleteDeviceDefinitionResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[dict[str, Any]])
                res.delete_device_definition_response = out
        elif http_res.status_code == 480:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.bad_request_exception = out

        return res

    def delete_function_definition(self, request: operations.DeleteFunctionDefinitionRequest) -> operations.DeleteFunctionDefinitionResponse:
        r"""Deletes a Lambda function definition."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.DeleteFunctionDefinitionRequest, base_url, '/greengrass/definition/functions/{FunctionDefinitionId}', request)
        
        headers = utils.get_headers(request)
        
        client = self._security_client
        
        http_res = client.request('DELETE', url, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DeleteFunctionDefinitionResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[dict[str, Any]])
                res.delete_function_definition_response = out
        elif http_res.status_code == 480:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.bad_request_exception = out

        return res

    def delete_group(self, request: operations.DeleteGroupRequest) -> operations.DeleteGroupResponse:
        r"""Deletes a group."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.DeleteGroupRequest, base_url, '/greengrass/groups/{GroupId}', request)
        
        headers = utils.get_headers(request)
        
        client = self._security_client
        
        http_res = client.request('DELETE', url, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DeleteGroupResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[dict[str, Any]])
                res.delete_group_response = out
        elif http_res.status_code == 480:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.bad_request_exception = out

        return res

    def delete_logger_definition(self, request: operations.DeleteLoggerDefinitionRequest) -> operations.DeleteLoggerDefinitionResponse:
        r"""Deletes a logger definition."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.DeleteLoggerDefinitionRequest, base_url, '/greengrass/definition/loggers/{LoggerDefinitionId}', request)
        
        headers = utils.get_headers(request)
        
        client = self._security_client
        
        http_res = client.request('DELETE', url, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DeleteLoggerDefinitionResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[dict[str, Any]])
                res.delete_logger_definition_response = out
        elif http_res.status_code == 480:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.bad_request_exception = out

        return res

    def delete_resource_definition(self, request: operations.DeleteResourceDefinitionRequest) -> operations.DeleteResourceDefinitionResponse:
        r"""Deletes a resource definition."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.DeleteResourceDefinitionRequest, base_url, '/greengrass/definition/resources/{ResourceDefinitionId}', request)
        
        headers = utils.get_headers(request)
        
        client = self._security_client
        
        http_res = client.request('DELETE', url, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DeleteResourceDefinitionResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[dict[str, Any]])
                res.delete_resource_definition_response = out
        elif http_res.status_code == 480:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.bad_request_exception = out

        return res

    def delete_subscription_definition(self, request: operations.DeleteSubscriptionDefinitionRequest) -> operations.DeleteSubscriptionDefinitionResponse:
        r"""Deletes a subscription definition."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.DeleteSubscriptionDefinitionRequest, base_url, '/greengrass/definition/subscriptions/{SubscriptionDefinitionId}', request)
        
        headers = utils.get_headers(request)
        
        client = self._security_client
        
        http_res = client.request('DELETE', url, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DeleteSubscriptionDefinitionResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[dict[str, Any]])
                res.delete_subscription_definition_response = out
        elif http_res.status_code == 480:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.bad_request_exception = out

        return res

    def disassociate_role_from_group(self, request: operations.DisassociateRoleFromGroupRequest) -> operations.DisassociateRoleFromGroupResponse:
        r"""Disassociates the role from a group."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.DisassociateRoleFromGroupRequest, base_url, '/greengrass/groups/{GroupId}/role', request)
        
        headers = utils.get_headers(request)
        
        client = self._security_client
        
        http_res = client.request('DELETE', url, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DisassociateRoleFromGroupResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.DisassociateRoleFromGroupResponse])
                res.disassociate_role_from_group_response = out
        elif http_res.status_code == 480:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.bad_request_exception = out
        elif http_res.status_code == 481:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.internal_server_error_exception = out

        return res

    def disassociate_service_role_from_account(self, request: operations.DisassociateServiceRoleFromAccountRequest) -> operations.DisassociateServiceRoleFromAccountResponse:
        r"""Disassociates the service role from your account. Without a service role, deployments will not work."""
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/greengrass/servicerole'
        
        headers = utils.get_headers(request)
        
        client = self._security_client
        
        http_res = client.request('DELETE', url, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DisassociateServiceRoleFromAccountResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.DisassociateServiceRoleFromAccountResponse])
                res.disassociate_service_role_from_account_response = out
        elif http_res.status_code == 480:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.internal_server_error_exception = out

        return res

    def get_associated_role(self, request: operations.GetAssociatedRoleRequest) -> operations.GetAssociatedRoleResponse:
        r"""Retrieves the role associated with a particular group."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.GetAssociatedRoleRequest, base_url, '/greengrass/groups/{GroupId}/role', request)
        
        headers = utils.get_headers(request)
        
        client = self._security_client
        
        http_res = client.request('GET', url, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetAssociatedRoleResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.GetAssociatedRoleResponse])
                res.get_associated_role_response = out
        elif http_res.status_code == 480:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.bad_request_exception = out
        elif http_res.status_code == 481:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.internal_server_error_exception = out

        return res

    def get_bulk_deployment_status(self, request: operations.GetBulkDeploymentStatusRequest) -> operations.GetBulkDeploymentStatusResponse:
        r"""Returns the status of a bulk deployment."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.GetBulkDeploymentStatusRequest, base_url, '/greengrass/bulk/deployments/{BulkDeploymentId}/status', request)
        
        headers = utils.get_headers(request)
        
        client = self._security_client
        
        http_res = client.request('GET', url, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetBulkDeploymentStatusResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.GetBulkDeploymentStatusResponse])
                res.get_bulk_deployment_status_response = out
        elif http_res.status_code == 480:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.bad_request_exception = out

        return res

    def get_connectivity_info(self, request: operations.GetConnectivityInfoRequest) -> operations.GetConnectivityInfoResponse:
        r"""Retrieves the connectivity information for a core."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.GetConnectivityInfoRequest, base_url, '/greengrass/things/{ThingName}/connectivityInfo', request)
        
        headers = utils.get_headers(request)
        
        client = self._security_client
        
        http_res = client.request('GET', url, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetConnectivityInfoResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.GetConnectivityInfoResponse])
                res.get_connectivity_info_response = out
        elif http_res.status_code == 480:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.bad_request_exception = out
        elif http_res.status_code == 481:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.internal_server_error_exception = out

        return res

    def get_connector_definition(self, request: operations.GetConnectorDefinitionRequest) -> operations.GetConnectorDefinitionResponse:
        r"""Retrieves information about a connector definition."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.GetConnectorDefinitionRequest, base_url, '/greengrass/definition/connectors/{ConnectorDefinitionId}', request)
        
        headers = utils.get_headers(request)
        
        client = self._security_client
        
        http_res = client.request('GET', url, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetConnectorDefinitionResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.GetConnectorDefinitionResponse])
                res.get_connector_definition_response = out
        elif http_res.status_code == 480:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.bad_request_exception = out

        return res

    def get_connector_definition_version(self, request: operations.GetConnectorDefinitionVersionRequest) -> operations.GetConnectorDefinitionVersionResponse:
        r"""Retrieves information about a connector definition version, including the connectors that the version contains. Connectors are prebuilt modules that interact with local infrastructure, device protocols, AWS, and other cloud services."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.GetConnectorDefinitionVersionRequest, base_url, '/greengrass/definition/connectors/{ConnectorDefinitionId}/versions/{ConnectorDefinitionVersionId}', request)
        
        headers = utils.get_headers(request)
        query_params = utils.get_query_params(operations.GetConnectorDefinitionVersionRequest, request)
        
        client = self._security_client
        
        http_res = client.request('GET', url, params=query_params, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetConnectorDefinitionVersionResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.GetConnectorDefinitionVersionResponse])
                res.get_connector_definition_version_response = out
        elif http_res.status_code == 480:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.bad_request_exception = out

        return res

    def get_core_definition(self, request: operations.GetCoreDefinitionRequest) -> operations.GetCoreDefinitionResponse:
        r"""Retrieves information about a core definition version."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.GetCoreDefinitionRequest, base_url, '/greengrass/definition/cores/{CoreDefinitionId}', request)
        
        headers = utils.get_headers(request)
        
        client = self._security_client
        
        http_res = client.request('GET', url, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetCoreDefinitionResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.GetCoreDefinitionResponse])
                res.get_core_definition_response = out
        elif http_res.status_code == 480:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.bad_request_exception = out

        return res

    def get_core_definition_version(self, request: operations.GetCoreDefinitionVersionRequest) -> operations.GetCoreDefinitionVersionResponse:
        r"""Retrieves information about a core definition version."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.GetCoreDefinitionVersionRequest, base_url, '/greengrass/definition/cores/{CoreDefinitionId}/versions/{CoreDefinitionVersionId}', request)
        
        headers = utils.get_headers(request)
        
        client = self._security_client
        
        http_res = client.request('GET', url, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetCoreDefinitionVersionResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.GetCoreDefinitionVersionResponse])
                res.get_core_definition_version_response = out
        elif http_res.status_code == 480:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.bad_request_exception = out

        return res

    def get_deployment_status(self, request: operations.GetDeploymentStatusRequest) -> operations.GetDeploymentStatusResponse:
        r"""Returns the status of a deployment."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.GetDeploymentStatusRequest, base_url, '/greengrass/groups/{GroupId}/deployments/{DeploymentId}/status', request)
        
        headers = utils.get_headers(request)
        
        client = self._security_client
        
        http_res = client.request('GET', url, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetDeploymentStatusResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.GetDeploymentStatusResponse])
                res.get_deployment_status_response = out
        elif http_res.status_code == 480:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.bad_request_exception = out

        return res

    def get_device_definition(self, request: operations.GetDeviceDefinitionRequest) -> operations.GetDeviceDefinitionResponse:
        r"""Retrieves information about a device definition."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.GetDeviceDefinitionRequest, base_url, '/greengrass/definition/devices/{DeviceDefinitionId}', request)
        
        headers = utils.get_headers(request)
        
        client = self._security_client
        
        http_res = client.request('GET', url, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetDeviceDefinitionResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.GetDeviceDefinitionResponse])
                res.get_device_definition_response = out
        elif http_res.status_code == 480:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.bad_request_exception = out

        return res

    def get_device_definition_version(self, request: operations.GetDeviceDefinitionVersionRequest) -> operations.GetDeviceDefinitionVersionResponse:
        r"""Retrieves information about a device definition version."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.GetDeviceDefinitionVersionRequest, base_url, '/greengrass/definition/devices/{DeviceDefinitionId}/versions/{DeviceDefinitionVersionId}', request)
        
        headers = utils.get_headers(request)
        query_params = utils.get_query_params(operations.GetDeviceDefinitionVersionRequest, request)
        
        client = self._security_client
        
        http_res = client.request('GET', url, params=query_params, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetDeviceDefinitionVersionResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.GetDeviceDefinitionVersionResponse])
                res.get_device_definition_version_response = out
        elif http_res.status_code == 480:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.bad_request_exception = out

        return res

    def get_function_definition(self, request: operations.GetFunctionDefinitionRequest) -> operations.GetFunctionDefinitionResponse:
        r"""Retrieves information about a Lambda function definition, including its creation time and latest version."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.GetFunctionDefinitionRequest, base_url, '/greengrass/definition/functions/{FunctionDefinitionId}', request)
        
        headers = utils.get_headers(request)
        
        client = self._security_client
        
        http_res = client.request('GET', url, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetFunctionDefinitionResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.GetFunctionDefinitionResponse])
                res.get_function_definition_response = out
        elif http_res.status_code == 480:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.bad_request_exception = out

        return res

    def get_function_definition_version(self, request: operations.GetFunctionDefinitionVersionRequest) -> operations.GetFunctionDefinitionVersionResponse:
        r"""Retrieves information about a Lambda function definition version, including which Lambda functions are included in the version and their configurations."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.GetFunctionDefinitionVersionRequest, base_url, '/greengrass/definition/functions/{FunctionDefinitionId}/versions/{FunctionDefinitionVersionId}', request)
        
        headers = utils.get_headers(request)
        query_params = utils.get_query_params(operations.GetFunctionDefinitionVersionRequest, request)
        
        client = self._security_client
        
        http_res = client.request('GET', url, params=query_params, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetFunctionDefinitionVersionResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.GetFunctionDefinitionVersionResponse])
                res.get_function_definition_version_response = out
        elif http_res.status_code == 480:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.bad_request_exception = out

        return res

    def get_group(self, request: operations.GetGroupRequest) -> operations.GetGroupResponse:
        r"""Retrieves information about a group."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.GetGroupRequest, base_url, '/greengrass/groups/{GroupId}', request)
        
        headers = utils.get_headers(request)
        
        client = self._security_client
        
        http_res = client.request('GET', url, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetGroupResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.GetGroupResponse])
                res.get_group_response = out
        elif http_res.status_code == 480:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.bad_request_exception = out

        return res

    def get_group_certificate_authority(self, request: operations.GetGroupCertificateAuthorityRequest) -> operations.GetGroupCertificateAuthorityResponse:
        r"""Retreives the CA associated with a group. Returns the public key of the CA."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.GetGroupCertificateAuthorityRequest, base_url, '/greengrass/groups/{GroupId}/certificateauthorities/{CertificateAuthorityId}', request)
        
        headers = utils.get_headers(request)
        
        client = self._security_client
        
        http_res = client.request('GET', url, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetGroupCertificateAuthorityResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.GetGroupCertificateAuthorityResponse])
                res.get_group_certificate_authority_response = out
        elif http_res.status_code == 480:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.bad_request_exception = out
        elif http_res.status_code == 481:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.internal_server_error_exception = out

        return res

    def get_group_certificate_configuration(self, request: operations.GetGroupCertificateConfigurationRequest) -> operations.GetGroupCertificateConfigurationResponse:
        r"""Retrieves the current configuration for the CA used by the group."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.GetGroupCertificateConfigurationRequest, base_url, '/greengrass/groups/{GroupId}/certificateauthorities/configuration/expiry', request)
        
        headers = utils.get_headers(request)
        
        client = self._security_client
        
        http_res = client.request('GET', url, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetGroupCertificateConfigurationResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.GetGroupCertificateConfigurationResponse])
                res.get_group_certificate_configuration_response = out
        elif http_res.status_code == 480:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.bad_request_exception = out
        elif http_res.status_code == 481:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.internal_server_error_exception = out

        return res

    def get_group_version(self, request: operations.GetGroupVersionRequest) -> operations.GetGroupVersionResponse:
        r"""Retrieves information about a group version."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.GetGroupVersionRequest, base_url, '/greengrass/groups/{GroupId}/versions/{GroupVersionId}', request)
        
        headers = utils.get_headers(request)
        
        client = self._security_client
        
        http_res = client.request('GET', url, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetGroupVersionResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.GetGroupVersionResponse])
                res.get_group_version_response = out
        elif http_res.status_code == 480:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.bad_request_exception = out

        return res

    def get_logger_definition(self, request: operations.GetLoggerDefinitionRequest) -> operations.GetLoggerDefinitionResponse:
        r"""Retrieves information about a logger definition."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.GetLoggerDefinitionRequest, base_url, '/greengrass/definition/loggers/{LoggerDefinitionId}', request)
        
        headers = utils.get_headers(request)
        
        client = self._security_client
        
        http_res = client.request('GET', url, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetLoggerDefinitionResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.GetLoggerDefinitionResponse])
                res.get_logger_definition_response = out
        elif http_res.status_code == 480:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.bad_request_exception = out

        return res

    def get_logger_definition_version(self, request: operations.GetLoggerDefinitionVersionRequest) -> operations.GetLoggerDefinitionVersionResponse:
        r"""Retrieves information about a logger definition version."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.GetLoggerDefinitionVersionRequest, base_url, '/greengrass/definition/loggers/{LoggerDefinitionId}/versions/{LoggerDefinitionVersionId}', request)
        
        headers = utils.get_headers(request)
        query_params = utils.get_query_params(operations.GetLoggerDefinitionVersionRequest, request)
        
        client = self._security_client
        
        http_res = client.request('GET', url, params=query_params, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetLoggerDefinitionVersionResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.GetLoggerDefinitionVersionResponse])
                res.get_logger_definition_version_response = out
        elif http_res.status_code == 480:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.bad_request_exception = out

        return res

    def get_resource_definition(self, request: operations.GetResourceDefinitionRequest) -> operations.GetResourceDefinitionResponse:
        r"""Retrieves information about a resource definition, including its creation time and latest version."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.GetResourceDefinitionRequest, base_url, '/greengrass/definition/resources/{ResourceDefinitionId}', request)
        
        headers = utils.get_headers(request)
        
        client = self._security_client
        
        http_res = client.request('GET', url, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetResourceDefinitionResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.GetResourceDefinitionResponse])
                res.get_resource_definition_response = out
        elif http_res.status_code == 480:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.bad_request_exception = out

        return res

    def get_resource_definition_version(self, request: operations.GetResourceDefinitionVersionRequest) -> operations.GetResourceDefinitionVersionResponse:
        r"""Retrieves information about a resource definition version, including which resources are included in the version."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.GetResourceDefinitionVersionRequest, base_url, '/greengrass/definition/resources/{ResourceDefinitionId}/versions/{ResourceDefinitionVersionId}', request)
        
        headers = utils.get_headers(request)
        
        client = self._security_client
        
        http_res = client.request('GET', url, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetResourceDefinitionVersionResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.GetResourceDefinitionVersionResponse])
                res.get_resource_definition_version_response = out
        elif http_res.status_code == 480:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.bad_request_exception = out

        return res

    def get_service_role_for_account(self, request: operations.GetServiceRoleForAccountRequest) -> operations.GetServiceRoleForAccountResponse:
        r"""Retrieves the service role that is attached to your account."""
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/greengrass/servicerole'
        
        headers = utils.get_headers(request)
        
        client = self._security_client
        
        http_res = client.request('GET', url, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetServiceRoleForAccountResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.GetServiceRoleForAccountResponse])
                res.get_service_role_for_account_response = out
        elif http_res.status_code == 480:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.internal_server_error_exception = out

        return res

    def get_subscription_definition(self, request: operations.GetSubscriptionDefinitionRequest) -> operations.GetSubscriptionDefinitionResponse:
        r"""Retrieves information about a subscription definition."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.GetSubscriptionDefinitionRequest, base_url, '/greengrass/definition/subscriptions/{SubscriptionDefinitionId}', request)
        
        headers = utils.get_headers(request)
        
        client = self._security_client
        
        http_res = client.request('GET', url, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetSubscriptionDefinitionResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.GetSubscriptionDefinitionResponse])
                res.get_subscription_definition_response = out
        elif http_res.status_code == 480:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.bad_request_exception = out

        return res

    def get_subscription_definition_version(self, request: operations.GetSubscriptionDefinitionVersionRequest) -> operations.GetSubscriptionDefinitionVersionResponse:
        r"""Retrieves information about a subscription definition version."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.GetSubscriptionDefinitionVersionRequest, base_url, '/greengrass/definition/subscriptions/{SubscriptionDefinitionId}/versions/{SubscriptionDefinitionVersionId}', request)
        
        headers = utils.get_headers(request)
        query_params = utils.get_query_params(operations.GetSubscriptionDefinitionVersionRequest, request)
        
        client = self._security_client
        
        http_res = client.request('GET', url, params=query_params, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetSubscriptionDefinitionVersionResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.GetSubscriptionDefinitionVersionResponse])
                res.get_subscription_definition_version_response = out
        elif http_res.status_code == 480:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.bad_request_exception = out

        return res

    def get_thing_runtime_configuration(self, request: operations.GetThingRuntimeConfigurationRequest) -> operations.GetThingRuntimeConfigurationResponse:
        r"""Get the runtime configuration of a thing."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.GetThingRuntimeConfigurationRequest, base_url, '/greengrass/things/{ThingName}/runtimeconfig', request)
        
        headers = utils.get_headers(request)
        
        client = self._security_client
        
        http_res = client.request('GET', url, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetThingRuntimeConfigurationResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.GetThingRuntimeConfigurationResponse])
                res.get_thing_runtime_configuration_response = out
        elif http_res.status_code == 480:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.bad_request_exception = out
        elif http_res.status_code == 481:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.internal_server_error_exception = out

        return res

    def list_bulk_deployment_detailed_reports(self, request: operations.ListBulkDeploymentDetailedReportsRequest) -> operations.ListBulkDeploymentDetailedReportsResponse:
        r"""Gets a paginated list of the deployments that have been started in a bulk deployment operation, and their current deployment status."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.ListBulkDeploymentDetailedReportsRequest, base_url, '/greengrass/bulk/deployments/{BulkDeploymentId}/detailed-reports', request)
        
        headers = utils.get_headers(request)
        query_params = utils.get_query_params(operations.ListBulkDeploymentDetailedReportsRequest, request)
        
        client = self._security_client
        
        http_res = client.request('GET', url, params=query_params, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ListBulkDeploymentDetailedReportsResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ListBulkDeploymentDetailedReportsResponse])
                res.list_bulk_deployment_detailed_reports_response = out
        elif http_res.status_code == 480:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.bad_request_exception = out

        return res

    def list_bulk_deployments(self, request: operations.ListBulkDeploymentsRequest) -> operations.ListBulkDeploymentsResponse:
        r"""Returns a list of bulk deployments."""
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/greengrass/bulk/deployments'
        
        headers = utils.get_headers(request)
        query_params = utils.get_query_params(operations.ListBulkDeploymentsRequest, request)
        
        client = self._security_client
        
        http_res = client.request('GET', url, params=query_params, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ListBulkDeploymentsResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ListBulkDeploymentsResponse])
                res.list_bulk_deployments_response = out
        elif http_res.status_code == 480:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.bad_request_exception = out

        return res

    def list_connector_definition_versions(self, request: operations.ListConnectorDefinitionVersionsRequest) -> operations.ListConnectorDefinitionVersionsResponse:
        r"""Lists the versions of a connector definition, which are containers for connectors. Connectors run on the Greengrass core and contain built-in integration with local infrastructure, device protocols, AWS, and other cloud services."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.ListConnectorDefinitionVersionsRequest, base_url, '/greengrass/definition/connectors/{ConnectorDefinitionId}/versions', request)
        
        headers = utils.get_headers(request)
        query_params = utils.get_query_params(operations.ListConnectorDefinitionVersionsRequest, request)
        
        client = self._security_client
        
        http_res = client.request('GET', url, params=query_params, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ListConnectorDefinitionVersionsResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ListConnectorDefinitionVersionsResponse])
                res.list_connector_definition_versions_response = out
        elif http_res.status_code == 480:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.bad_request_exception = out

        return res

    def list_connector_definitions(self, request: operations.ListConnectorDefinitionsRequest) -> operations.ListConnectorDefinitionsResponse:
        r"""Retrieves a list of connector definitions."""
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/greengrass/definition/connectors'
        
        headers = utils.get_headers(request)
        query_params = utils.get_query_params(operations.ListConnectorDefinitionsRequest, request)
        
        client = self._security_client
        
        http_res = client.request('GET', url, params=query_params, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ListConnectorDefinitionsResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ListConnectorDefinitionsResponse])
                res.list_connector_definitions_response = out

        return res

    def list_core_definition_versions(self, request: operations.ListCoreDefinitionVersionsRequest) -> operations.ListCoreDefinitionVersionsResponse:
        r"""Lists the versions of a core definition."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.ListCoreDefinitionVersionsRequest, base_url, '/greengrass/definition/cores/{CoreDefinitionId}/versions', request)
        
        headers = utils.get_headers(request)
        query_params = utils.get_query_params(operations.ListCoreDefinitionVersionsRequest, request)
        
        client = self._security_client
        
        http_res = client.request('GET', url, params=query_params, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ListCoreDefinitionVersionsResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ListCoreDefinitionVersionsResponse])
                res.list_core_definition_versions_response = out
        elif http_res.status_code == 480:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.bad_request_exception = out

        return res

    def list_core_definitions(self, request: operations.ListCoreDefinitionsRequest) -> operations.ListCoreDefinitionsResponse:
        r"""Retrieves a list of core definitions."""
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/greengrass/definition/cores'
        
        headers = utils.get_headers(request)
        query_params = utils.get_query_params(operations.ListCoreDefinitionsRequest, request)
        
        client = self._security_client
        
        http_res = client.request('GET', url, params=query_params, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ListCoreDefinitionsResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ListCoreDefinitionsResponse])
                res.list_core_definitions_response = out

        return res

    def list_deployments(self, request: operations.ListDeploymentsRequest) -> operations.ListDeploymentsResponse:
        r"""Returns a history of deployments for the group."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.ListDeploymentsRequest, base_url, '/greengrass/groups/{GroupId}/deployments', request)
        
        headers = utils.get_headers(request)
        query_params = utils.get_query_params(operations.ListDeploymentsRequest, request)
        
        client = self._security_client
        
        http_res = client.request('GET', url, params=query_params, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ListDeploymentsResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ListDeploymentsResponse])
                res.list_deployments_response = out
        elif http_res.status_code == 480:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.bad_request_exception = out

        return res

    def list_device_definition_versions(self, request: operations.ListDeviceDefinitionVersionsRequest) -> operations.ListDeviceDefinitionVersionsResponse:
        r"""Lists the versions of a device definition."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.ListDeviceDefinitionVersionsRequest, base_url, '/greengrass/definition/devices/{DeviceDefinitionId}/versions', request)
        
        headers = utils.get_headers(request)
        query_params = utils.get_query_params(operations.ListDeviceDefinitionVersionsRequest, request)
        
        client = self._security_client
        
        http_res = client.request('GET', url, params=query_params, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ListDeviceDefinitionVersionsResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ListDeviceDefinitionVersionsResponse])
                res.list_device_definition_versions_response = out
        elif http_res.status_code == 480:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.bad_request_exception = out

        return res

    def list_device_definitions(self, request: operations.ListDeviceDefinitionsRequest) -> operations.ListDeviceDefinitionsResponse:
        r"""Retrieves a list of device definitions."""
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/greengrass/definition/devices'
        
        headers = utils.get_headers(request)
        query_params = utils.get_query_params(operations.ListDeviceDefinitionsRequest, request)
        
        client = self._security_client
        
        http_res = client.request('GET', url, params=query_params, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ListDeviceDefinitionsResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ListDeviceDefinitionsResponse])
                res.list_device_definitions_response = out

        return res

    def list_function_definition_versions(self, request: operations.ListFunctionDefinitionVersionsRequest) -> operations.ListFunctionDefinitionVersionsResponse:
        r"""Lists the versions of a Lambda function definition."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.ListFunctionDefinitionVersionsRequest, base_url, '/greengrass/definition/functions/{FunctionDefinitionId}/versions', request)
        
        headers = utils.get_headers(request)
        query_params = utils.get_query_params(operations.ListFunctionDefinitionVersionsRequest, request)
        
        client = self._security_client
        
        http_res = client.request('GET', url, params=query_params, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ListFunctionDefinitionVersionsResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ListFunctionDefinitionVersionsResponse])
                res.list_function_definition_versions_response = out
        elif http_res.status_code == 480:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.bad_request_exception = out

        return res

    def list_function_definitions(self, request: operations.ListFunctionDefinitionsRequest) -> operations.ListFunctionDefinitionsResponse:
        r"""Retrieves a list of Lambda function definitions."""
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/greengrass/definition/functions'
        
        headers = utils.get_headers(request)
        query_params = utils.get_query_params(operations.ListFunctionDefinitionsRequest, request)
        
        client = self._security_client
        
        http_res = client.request('GET', url, params=query_params, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ListFunctionDefinitionsResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ListFunctionDefinitionsResponse])
                res.list_function_definitions_response = out

        return res

    def list_group_certificate_authorities(self, request: operations.ListGroupCertificateAuthoritiesRequest) -> operations.ListGroupCertificateAuthoritiesResponse:
        r"""Retrieves the current CAs for a group."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.ListGroupCertificateAuthoritiesRequest, base_url, '/greengrass/groups/{GroupId}/certificateauthorities', request)
        
        headers = utils.get_headers(request)
        
        client = self._security_client
        
        http_res = client.request('GET', url, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ListGroupCertificateAuthoritiesResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ListGroupCertificateAuthoritiesResponse])
                res.list_group_certificate_authorities_response = out
        elif http_res.status_code == 480:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.bad_request_exception = out
        elif http_res.status_code == 481:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.internal_server_error_exception = out

        return res

    def list_group_versions(self, request: operations.ListGroupVersionsRequest) -> operations.ListGroupVersionsResponse:
        r"""Lists the versions of a group."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.ListGroupVersionsRequest, base_url, '/greengrass/groups/{GroupId}/versions', request)
        
        headers = utils.get_headers(request)
        query_params = utils.get_query_params(operations.ListGroupVersionsRequest, request)
        
        client = self._security_client
        
        http_res = client.request('GET', url, params=query_params, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ListGroupVersionsResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ListGroupVersionsResponse])
                res.list_group_versions_response = out
        elif http_res.status_code == 480:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.bad_request_exception = out

        return res

    def list_groups(self, request: operations.ListGroupsRequest) -> operations.ListGroupsResponse:
        r"""Retrieves a list of groups."""
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/greengrass/groups'
        
        headers = utils.get_headers(request)
        query_params = utils.get_query_params(operations.ListGroupsRequest, request)
        
        client = self._security_client
        
        http_res = client.request('GET', url, params=query_params, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ListGroupsResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ListGroupsResponse])
                res.list_groups_response = out

        return res

    def list_logger_definition_versions(self, request: operations.ListLoggerDefinitionVersionsRequest) -> operations.ListLoggerDefinitionVersionsResponse:
        r"""Lists the versions of a logger definition."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.ListLoggerDefinitionVersionsRequest, base_url, '/greengrass/definition/loggers/{LoggerDefinitionId}/versions', request)
        
        headers = utils.get_headers(request)
        query_params = utils.get_query_params(operations.ListLoggerDefinitionVersionsRequest, request)
        
        client = self._security_client
        
        http_res = client.request('GET', url, params=query_params, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ListLoggerDefinitionVersionsResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ListLoggerDefinitionVersionsResponse])
                res.list_logger_definition_versions_response = out
        elif http_res.status_code == 480:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.bad_request_exception = out

        return res

    def list_logger_definitions(self, request: operations.ListLoggerDefinitionsRequest) -> operations.ListLoggerDefinitionsResponse:
        r"""Retrieves a list of logger definitions."""
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/greengrass/definition/loggers'
        
        headers = utils.get_headers(request)
        query_params = utils.get_query_params(operations.ListLoggerDefinitionsRequest, request)
        
        client = self._security_client
        
        http_res = client.request('GET', url, params=query_params, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ListLoggerDefinitionsResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ListLoggerDefinitionsResponse])
                res.list_logger_definitions_response = out

        return res

    def list_resource_definition_versions(self, request: operations.ListResourceDefinitionVersionsRequest) -> operations.ListResourceDefinitionVersionsResponse:
        r"""Lists the versions of a resource definition."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.ListResourceDefinitionVersionsRequest, base_url, '/greengrass/definition/resources/{ResourceDefinitionId}/versions', request)
        
        headers = utils.get_headers(request)
        query_params = utils.get_query_params(operations.ListResourceDefinitionVersionsRequest, request)
        
        client = self._security_client
        
        http_res = client.request('GET', url, params=query_params, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ListResourceDefinitionVersionsResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ListResourceDefinitionVersionsResponse])
                res.list_resource_definition_versions_response = out
        elif http_res.status_code == 480:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.bad_request_exception = out

        return res

    def list_resource_definitions(self, request: operations.ListResourceDefinitionsRequest) -> operations.ListResourceDefinitionsResponse:
        r"""Retrieves a list of resource definitions."""
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/greengrass/definition/resources'
        
        headers = utils.get_headers(request)
        query_params = utils.get_query_params(operations.ListResourceDefinitionsRequest, request)
        
        client = self._security_client
        
        http_res = client.request('GET', url, params=query_params, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ListResourceDefinitionsResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ListResourceDefinitionsResponse])
                res.list_resource_definitions_response = out

        return res

    def list_subscription_definition_versions(self, request: operations.ListSubscriptionDefinitionVersionsRequest) -> operations.ListSubscriptionDefinitionVersionsResponse:
        r"""Lists the versions of a subscription definition."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.ListSubscriptionDefinitionVersionsRequest, base_url, '/greengrass/definition/subscriptions/{SubscriptionDefinitionId}/versions', request)
        
        headers = utils.get_headers(request)
        query_params = utils.get_query_params(operations.ListSubscriptionDefinitionVersionsRequest, request)
        
        client = self._security_client
        
        http_res = client.request('GET', url, params=query_params, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ListSubscriptionDefinitionVersionsResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ListSubscriptionDefinitionVersionsResponse])
                res.list_subscription_definition_versions_response = out
        elif http_res.status_code == 480:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.bad_request_exception = out

        return res

    def list_subscription_definitions(self, request: operations.ListSubscriptionDefinitionsRequest) -> operations.ListSubscriptionDefinitionsResponse:
        r"""Retrieves a list of subscription definitions."""
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/greengrass/definition/subscriptions'
        
        headers = utils.get_headers(request)
        query_params = utils.get_query_params(operations.ListSubscriptionDefinitionsRequest, request)
        
        client = self._security_client
        
        http_res = client.request('GET', url, params=query_params, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ListSubscriptionDefinitionsResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ListSubscriptionDefinitionsResponse])
                res.list_subscription_definitions_response = out

        return res

    def list_tags_for_resource(self, request: operations.ListTagsForResourceRequest) -> operations.ListTagsForResourceResponse:
        r"""Retrieves a list of resource tags for a resource arn."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.ListTagsForResourceRequest, base_url, '/tags/{resource-arn}', request)
        
        headers = utils.get_headers(request)
        
        client = self._security_client
        
        http_res = client.request('GET', url, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ListTagsForResourceResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ListTagsForResourceResponse])
                res.list_tags_for_resource_response = out
        elif http_res.status_code == 480:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.bad_request_exception = out

        return res

    def reset_deployments(self, request: operations.ResetDeploymentsRequest) -> operations.ResetDeploymentsResponse:
        r"""Resets a group's deployments."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.ResetDeploymentsRequest, base_url, '/greengrass/groups/{GroupId}/deployments/$reset', request)
        
        headers = utils.get_headers(request)
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = self._security_client
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ResetDeploymentsResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ResetDeploymentsResponse])
                res.reset_deployments_response = out
        elif http_res.status_code == 480:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.bad_request_exception = out

        return res

    def start_bulk_deployment(self, request: operations.StartBulkDeploymentRequest) -> operations.StartBulkDeploymentResponse:
        r"""Deploys multiple groups in one operation. This action starts the bulk deployment of a specified set of group versions. Each group version deployment will be triggered with an adaptive rate that has a fixed upper limit. We recommend that you include an ''X-Amzn-Client-Token'' token in every ''StartBulkDeployment'' request. These requests are idempotent with respect to the token and the request parameters."""
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/greengrass/bulk/deployments'
        
        headers = utils.get_headers(request)
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = self._security_client
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.StartBulkDeploymentResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.StartBulkDeploymentResponse])
                res.start_bulk_deployment_response = out
        elif http_res.status_code == 480:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.bad_request_exception = out

        return res

    def stop_bulk_deployment(self, request: operations.StopBulkDeploymentRequest) -> operations.StopBulkDeploymentResponse:
        r"""Stops the execution of a bulk deployment. This action returns a status of ''Stopping'' until the deployment is stopped. You cannot start a new bulk deployment while a previous deployment is in the ''Stopping'' state. This action doesn't rollback completed deployments or cancel pending deployments."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.StopBulkDeploymentRequest, base_url, '/greengrass/bulk/deployments/{BulkDeploymentId}/$stop', request)
        
        headers = utils.get_headers(request)
        
        client = self._security_client
        
        http_res = client.request('PUT', url, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.StopBulkDeploymentResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[dict[str, Any]])
                res.stop_bulk_deployment_response = out
        elif http_res.status_code == 480:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.bad_request_exception = out

        return res

    def tag_resource(self, request: operations.TagResourceRequest) -> operations.TagResourceResponse:
        r"""Adds tags to a Greengrass resource. Valid resources are 'Group', 'ConnectorDefinition', 'CoreDefinition', 'DeviceDefinition', 'FunctionDefinition', 'LoggerDefinition', 'SubscriptionDefinition', 'ResourceDefinition', and 'BulkDeployment'."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.TagResourceRequest, base_url, '/tags/{resource-arn}', request)
        
        headers = utils.get_headers(request)
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = self._security_client
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.TagResourceResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 204:
            pass
        elif http_res.status_code == 480:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.bad_request_exception = out

        return res

    def untag_resource(self, request: operations.UntagResourceRequest) -> operations.UntagResourceResponse:
        r"""Remove resource tags from a Greengrass Resource."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.UntagResourceRequest, base_url, '/tags/{resource-arn}#tagKeys', request)
        
        headers = utils.get_headers(request)
        query_params = utils.get_query_params(operations.UntagResourceRequest, request)
        
        client = self._security_client
        
        http_res = client.request('DELETE', url, params=query_params, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.UntagResourceResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 204:
            pass
        elif http_res.status_code == 480:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.bad_request_exception = out

        return res

    def update_connectivity_info(self, request: operations.UpdateConnectivityInfoRequest) -> operations.UpdateConnectivityInfoResponse:
        r"""Updates the connectivity information for the core. Any devices that belong to the group which has this core will receive this information in order to find the location of the core and connect to it."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.UpdateConnectivityInfoRequest, base_url, '/greengrass/things/{ThingName}/connectivityInfo', request)
        
        headers = utils.get_headers(request)
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = self._security_client
        
        http_res = client.request('PUT', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.UpdateConnectivityInfoResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.UpdateConnectivityInfoResponse])
                res.update_connectivity_info_response = out
        elif http_res.status_code == 480:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.bad_request_exception = out
        elif http_res.status_code == 481:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.internal_server_error_exception = out

        return res

    def update_connector_definition(self, request: operations.UpdateConnectorDefinitionRequest) -> operations.UpdateConnectorDefinitionResponse:
        r"""Updates a connector definition."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.UpdateConnectorDefinitionRequest, base_url, '/greengrass/definition/connectors/{ConnectorDefinitionId}', request)
        
        headers = utils.get_headers(request)
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = self._security_client
        
        http_res = client.request('PUT', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.UpdateConnectorDefinitionResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[dict[str, Any]])
                res.update_connector_definition_response = out
        elif http_res.status_code == 480:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.bad_request_exception = out

        return res

    def update_core_definition(self, request: operations.UpdateCoreDefinitionRequest) -> operations.UpdateCoreDefinitionResponse:
        r"""Updates a core definition."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.UpdateCoreDefinitionRequest, base_url, '/greengrass/definition/cores/{CoreDefinitionId}', request)
        
        headers = utils.get_headers(request)
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = self._security_client
        
        http_res = client.request('PUT', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.UpdateCoreDefinitionResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[dict[str, Any]])
                res.update_core_definition_response = out
        elif http_res.status_code == 480:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.bad_request_exception = out

        return res

    def update_device_definition(self, request: operations.UpdateDeviceDefinitionRequest) -> operations.UpdateDeviceDefinitionResponse:
        r"""Updates a device definition."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.UpdateDeviceDefinitionRequest, base_url, '/greengrass/definition/devices/{DeviceDefinitionId}', request)
        
        headers = utils.get_headers(request)
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = self._security_client
        
        http_res = client.request('PUT', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.UpdateDeviceDefinitionResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[dict[str, Any]])
                res.update_device_definition_response = out
        elif http_res.status_code == 480:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.bad_request_exception = out

        return res

    def update_function_definition(self, request: operations.UpdateFunctionDefinitionRequest) -> operations.UpdateFunctionDefinitionResponse:
        r"""Updates a Lambda function definition."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.UpdateFunctionDefinitionRequest, base_url, '/greengrass/definition/functions/{FunctionDefinitionId}', request)
        
        headers = utils.get_headers(request)
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = self._security_client
        
        http_res = client.request('PUT', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.UpdateFunctionDefinitionResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[dict[str, Any]])
                res.update_function_definition_response = out
        elif http_res.status_code == 480:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.bad_request_exception = out

        return res

    def update_group(self, request: operations.UpdateGroupRequest) -> operations.UpdateGroupResponse:
        r"""Updates a group."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.UpdateGroupRequest, base_url, '/greengrass/groups/{GroupId}', request)
        
        headers = utils.get_headers(request)
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = self._security_client
        
        http_res = client.request('PUT', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.UpdateGroupResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[dict[str, Any]])
                res.update_group_response = out
        elif http_res.status_code == 480:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.bad_request_exception = out

        return res

    def update_group_certificate_configuration(self, request: operations.UpdateGroupCertificateConfigurationRequest) -> operations.UpdateGroupCertificateConfigurationResponse:
        r"""Updates the Certificate expiry time for a group."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.UpdateGroupCertificateConfigurationRequest, base_url, '/greengrass/groups/{GroupId}/certificateauthorities/configuration/expiry', request)
        
        headers = utils.get_headers(request)
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = self._security_client
        
        http_res = client.request('PUT', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.UpdateGroupCertificateConfigurationResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.UpdateGroupCertificateConfigurationResponse])
                res.update_group_certificate_configuration_response = out
        elif http_res.status_code == 480:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.bad_request_exception = out
        elif http_res.status_code == 481:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.internal_server_error_exception = out

        return res

    def update_logger_definition(self, request: operations.UpdateLoggerDefinitionRequest) -> operations.UpdateLoggerDefinitionResponse:
        r"""Updates a logger definition."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.UpdateLoggerDefinitionRequest, base_url, '/greengrass/definition/loggers/{LoggerDefinitionId}', request)
        
        headers = utils.get_headers(request)
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = self._security_client
        
        http_res = client.request('PUT', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.UpdateLoggerDefinitionResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[dict[str, Any]])
                res.update_logger_definition_response = out
        elif http_res.status_code == 480:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.bad_request_exception = out

        return res

    def update_resource_definition(self, request: operations.UpdateResourceDefinitionRequest) -> operations.UpdateResourceDefinitionResponse:
        r"""Updates a resource definition."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.UpdateResourceDefinitionRequest, base_url, '/greengrass/definition/resources/{ResourceDefinitionId}', request)
        
        headers = utils.get_headers(request)
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = self._security_client
        
        http_res = client.request('PUT', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.UpdateResourceDefinitionResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[dict[str, Any]])
                res.update_resource_definition_response = out
        elif http_res.status_code == 480:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.bad_request_exception = out

        return res

    def update_subscription_definition(self, request: operations.UpdateSubscriptionDefinitionRequest) -> operations.UpdateSubscriptionDefinitionResponse:
        r"""Updates a subscription definition."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.UpdateSubscriptionDefinitionRequest, base_url, '/greengrass/definition/subscriptions/{SubscriptionDefinitionId}', request)
        
        headers = utils.get_headers(request)
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = self._security_client
        
        http_res = client.request('PUT', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.UpdateSubscriptionDefinitionResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[dict[str, Any]])
                res.update_subscription_definition_response = out
        elif http_res.status_code == 480:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.bad_request_exception = out

        return res

    def update_thing_runtime_configuration(self, request: operations.UpdateThingRuntimeConfigurationRequest) -> operations.UpdateThingRuntimeConfigurationResponse:
        r"""Updates the runtime configuration of a thing."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.UpdateThingRuntimeConfigurationRequest, base_url, '/greengrass/things/{ThingName}/runtimeconfig', request)
        
        headers = utils.get_headers(request)
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = self._security_client
        
        http_res = client.request('PUT', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.UpdateThingRuntimeConfigurationResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[dict[str, Any]])
                res.update_thing_runtime_configuration_response = out
        elif http_res.status_code == 480:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.bad_request_exception = out
        elif http_res.status_code == 481:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.internal_server_error_exception = out

        return res

    