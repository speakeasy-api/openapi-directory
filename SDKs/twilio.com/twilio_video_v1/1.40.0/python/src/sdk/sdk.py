"""Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT."""

import requests as requests_http
from . import utils
from sdk.models import operations, shared
from typing import Optional

SERVERS = [
    "https://video.twilio.com",
]
"""Contains the list of servers available to the SDK"""

class SDK:
    r"""This is the public Twilio REST API."""

    _client: requests_http.Session
    _security_client: requests_http.Session
    _server_url: str = SERVERS[0]
    _language: str = "python"
    _sdk_version: str = "0.0.1"
    _gen_version: str = "internal"

    def __init__(self,
                 server_url: str = None,
                 url_params: dict[str, str] = None,
                 client: requests_http.Session = None
                 ) -> None:
        """Instantiates the SDK configuring it with the provided parameters.
        
        :param server_url: The server URL to use for all operations
        :type server_url: str
        :param url_params: Parameters to optionally template the server URL with
        :type url_params: dict[str, str]
        :param client: The requests.Session HTTP client to use for all operations
        :type client: requests_http.Session        
        """
        self._client = requests_http.Session()
        
        
        if server_url is not None:
            if url_params is not None:
                self._server_url = utils.template_url(server_url, url_params)
            else:
                self._server_url = server_url

        if client is not None:
            self._client = client
        
        self._security_client = self._client
        

        
    
    
    def create_composition(self, request: operations.CreateCompositionCreateCompositionRequest, security: operations.CreateCompositionSecurity, server_url: Optional[str] = None) -> operations.CreateCompositionResponse:
        base_url = operations.CREATE_COMPOSITION_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = base_url.removesuffix('/') + '/v1/Compositions'
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request", 'form')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.CreateCompositionResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 201:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.VideoV1Composition])
                res.video_v1_composition = out

        return res

    def create_composition_hook(self, request: operations.CreateCompositionHookCreateCompositionHookRequest, security: operations.CreateCompositionHookSecurity, server_url: Optional[str] = None) -> operations.CreateCompositionHookResponse:
        base_url = operations.CREATE_COMPOSITION_HOOK_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = base_url.removesuffix('/') + '/v1/CompositionHooks'
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request", 'form')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.CreateCompositionHookResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 201:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.VideoV1CompositionHook])
                res.video_v1_composition_hook = out

        return res

    def create_composition_settings(self, request: operations.CreateCompositionSettingsCreateCompositionSettingsRequest, security: operations.CreateCompositionSettingsSecurity, server_url: Optional[str] = None) -> operations.CreateCompositionSettingsResponse:
        base_url = operations.CREATE_COMPOSITION_SETTINGS_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = base_url.removesuffix('/') + '/v1/CompositionSettings/Default'
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request", 'form')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.CreateCompositionSettingsResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 201:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.VideoV1CompositionSettings])
                res.video_v1_composition_settings = out

        return res

    def create_recording_settings(self, request: operations.CreateRecordingSettingsCreateRecordingSettingsRequest, security: operations.CreateRecordingSettingsSecurity, server_url: Optional[str] = None) -> operations.CreateRecordingSettingsResponse:
        base_url = operations.CREATE_RECORDING_SETTINGS_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = base_url.removesuffix('/') + '/v1/RecordingSettings/Default'
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request", 'form')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.CreateRecordingSettingsResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 201:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.VideoV1RecordingSettings])
                res.video_v1_recording_settings = out

        return res

    def create_room(self, request: operations.CreateRoomCreateRoomRequest, security: operations.CreateRoomSecurity, server_url: Optional[str] = None) -> operations.CreateRoomResponse:
        base_url = operations.CREATE_ROOM_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = base_url.removesuffix('/') + '/v1/Rooms'
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request", 'form')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.CreateRoomResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 201:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.VideoV1Room])
                res.video_v1_room = out

        return res

    def delete_composition(self, request: operations.DeleteCompositionRequest, security: operations.DeleteCompositionSecurity, server_url: Optional[str] = None) -> operations.DeleteCompositionResponse:
        r"""Delete a Recording Composition resource identified by a Composition SID."""
        base_url = operations.DELETE_COMPOSITION_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.DeleteCompositionRequest, base_url, '/v1/Compositions/{Sid}', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('DELETE', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DeleteCompositionResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        

        return res

    def delete_composition_hook(self, request: operations.DeleteCompositionHookRequest, security: operations.DeleteCompositionHookSecurity, server_url: Optional[str] = None) -> operations.DeleteCompositionHookResponse:
        r"""Delete a Recording CompositionHook resource identified by a `CompositionHook SID`."""
        base_url = operations.DELETE_COMPOSITION_HOOK_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.DeleteCompositionHookRequest, base_url, '/v1/CompositionHooks/{Sid}', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('DELETE', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DeleteCompositionHookResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        

        return res

    def delete_recording(self, request: operations.DeleteRecordingRequest, security: operations.DeleteRecordingSecurity, server_url: Optional[str] = None) -> operations.DeleteRecordingResponse:
        r"""Delete a Recording resource identified by a Recording SID."""
        base_url = operations.DELETE_RECORDING_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.DeleteRecordingRequest, base_url, '/v1/Recordings/{Sid}', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('DELETE', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DeleteRecordingResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        

        return res

    def delete_room_recording(self, request: operations.DeleteRoomRecordingRequest, security: operations.DeleteRoomRecordingSecurity, server_url: Optional[str] = None) -> operations.DeleteRoomRecordingResponse:
        base_url = operations.DELETE_ROOM_RECORDING_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.DeleteRoomRecordingRequest, base_url, '/v1/Rooms/{RoomSid}/Recordings/{Sid}', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('DELETE', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DeleteRoomRecordingResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        

        return res

    def fetch_composition(self, request: operations.FetchCompositionRequest, security: operations.FetchCompositionSecurity, server_url: Optional[str] = None) -> operations.FetchCompositionResponse:
        r"""Returns a single Composition resource identified by a Composition SID."""
        base_url = operations.FETCH_COMPOSITION_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.FetchCompositionRequest, base_url, '/v1/Compositions/{Sid}', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.FetchCompositionResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.VideoV1Composition])
                res.video_v1_composition = out

        return res

    def fetch_composition_hook(self, request: operations.FetchCompositionHookRequest, security: operations.FetchCompositionHookSecurity, server_url: Optional[str] = None) -> operations.FetchCompositionHookResponse:
        r"""Returns a single CompositionHook resource identified by a CompositionHook SID."""
        base_url = operations.FETCH_COMPOSITION_HOOK_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.FetchCompositionHookRequest, base_url, '/v1/CompositionHooks/{Sid}', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.FetchCompositionHookResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.VideoV1CompositionHook])
                res.video_v1_composition_hook = out

        return res

    def fetch_composition_settings(self, server_url: Optional[str] = None) -> operations.FetchCompositionSettingsResponse:
        base_url = operations.FETCH_COMPOSITION_SETTINGS_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = base_url.removesuffix('/') + '/v1/CompositionSettings/Default'
        
        
        client = self._client
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.FetchCompositionSettingsResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.VideoV1CompositionSettings])
                res.video_v1_composition_settings = out

        return res

    def fetch_recording(self, request: operations.FetchRecordingRequest, security: operations.FetchRecordingSecurity, server_url: Optional[str] = None) -> operations.FetchRecordingResponse:
        r"""Returns a single Recording resource identified by a Recording SID."""
        base_url = operations.FETCH_RECORDING_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.FetchRecordingRequest, base_url, '/v1/Recordings/{Sid}', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.FetchRecordingResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.VideoV1Recording])
                res.video_v1_recording = out

        return res

    def fetch_recording_settings(self, server_url: Optional[str] = None) -> operations.FetchRecordingSettingsResponse:
        base_url = operations.FETCH_RECORDING_SETTINGS_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = base_url.removesuffix('/') + '/v1/RecordingSettings/Default'
        
        
        client = self._client
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.FetchRecordingSettingsResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.VideoV1RecordingSettings])
                res.video_v1_recording_settings = out

        return res

    def fetch_room(self, request: operations.FetchRoomRequest, security: operations.FetchRoomSecurity, server_url: Optional[str] = None) -> operations.FetchRoomResponse:
        base_url = operations.FETCH_ROOM_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.FetchRoomRequest, base_url, '/v1/Rooms/{Sid}', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.FetchRoomResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.VideoV1Room])
                res.video_v1_room = out

        return res

    def fetch_room_participant(self, request: operations.FetchRoomParticipantRequest, security: operations.FetchRoomParticipantSecurity, server_url: Optional[str] = None) -> operations.FetchRoomParticipantResponse:
        base_url = operations.FETCH_ROOM_PARTICIPANT_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.FetchRoomParticipantRequest, base_url, '/v1/Rooms/{RoomSid}/Participants/{Sid}', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.FetchRoomParticipantResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.VideoV1RoomRoomParticipant])
                res.video_v1_room_room_participant = out

        return res

    def fetch_room_participant_published_track(self, request: operations.FetchRoomParticipantPublishedTrackRequest, security: operations.FetchRoomParticipantPublishedTrackSecurity, server_url: Optional[str] = None) -> operations.FetchRoomParticipantPublishedTrackResponse:
        r"""Returns a single Track resource represented by TrackName or SID."""
        base_url = operations.FETCH_ROOM_PARTICIPANT_PUBLISHED_TRACK_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.FetchRoomParticipantPublishedTrackRequest, base_url, '/v1/Rooms/{RoomSid}/Participants/{ParticipantSid}/PublishedTracks/{Sid}', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.FetchRoomParticipantPublishedTrackResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.VideoV1RoomRoomParticipantRoomParticipantPublishedTrack])
                res.video_v1_room_room_participant_room_participant_published_track = out

        return res

    def fetch_room_participant_subscribe_rule(self, request: operations.FetchRoomParticipantSubscribeRuleRequest, security: operations.FetchRoomParticipantSubscribeRuleSecurity, server_url: Optional[str] = None) -> operations.FetchRoomParticipantSubscribeRuleResponse:
        r"""Returns a list of Subscribe Rules for the Participant."""
        base_url = operations.FETCH_ROOM_PARTICIPANT_SUBSCRIBE_RULE_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.FetchRoomParticipantSubscribeRuleRequest, base_url, '/v1/Rooms/{RoomSid}/Participants/{ParticipantSid}/SubscribeRules', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.FetchRoomParticipantSubscribeRuleResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.VideoV1RoomRoomParticipantRoomParticipantSubscribeRule])
                res.video_v1_room_room_participant_room_participant_subscribe_rule = out

        return res

    def fetch_room_participant_subscribed_track(self, request: operations.FetchRoomParticipantSubscribedTrackRequest, security: operations.FetchRoomParticipantSubscribedTrackSecurity, server_url: Optional[str] = None) -> operations.FetchRoomParticipantSubscribedTrackResponse:
        r"""Returns a single Track resource represented by `track_sid`.  Note: This is one resource with the Video API that requires a SID, be Track Name on the subscriber side is not guaranteed to be unique."""
        base_url = operations.FETCH_ROOM_PARTICIPANT_SUBSCRIBED_TRACK_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.FetchRoomParticipantSubscribedTrackRequest, base_url, '/v1/Rooms/{RoomSid}/Participants/{ParticipantSid}/SubscribedTracks/{Sid}', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.FetchRoomParticipantSubscribedTrackResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.VideoV1RoomRoomParticipantRoomParticipantSubscribedTrack])
                res.video_v1_room_room_participant_room_participant_subscribed_track = out

        return res

    def fetch_room_recording(self, request: operations.FetchRoomRecordingRequest, security: operations.FetchRoomRecordingSecurity, server_url: Optional[str] = None) -> operations.FetchRoomRecordingResponse:
        base_url = operations.FETCH_ROOM_RECORDING_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.FetchRoomRecordingRequest, base_url, '/v1/Rooms/{RoomSid}/Recordings/{Sid}', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.FetchRoomRecordingResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.VideoV1RoomRoomRecording])
                res.video_v1_room_room_recording = out

        return res

    def fetch_room_recording_rule(self, request: operations.FetchRoomRecordingRuleRequest, security: operations.FetchRoomRecordingRuleSecurity, server_url: Optional[str] = None) -> operations.FetchRoomRecordingRuleResponse:
        r"""Returns a list of Recording Rules for the Room."""
        base_url = operations.FETCH_ROOM_RECORDING_RULE_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.FetchRoomRecordingRuleRequest, base_url, '/v1/Rooms/{RoomSid}/RecordingRules', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.FetchRoomRecordingRuleResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.VideoV1RoomRoomRecordingRule])
                res.video_v1_room_room_recording_rule = out

        return res

    def list_composition(self, request: operations.ListCompositionRequest, security: operations.ListCompositionSecurity, server_url: Optional[str] = None) -> operations.ListCompositionResponse:
        r"""List of all Recording compositions."""
        base_url = operations.LIST_COMPOSITION_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = base_url.removesuffix('/') + '/v1/Compositions'
        
        query_params = utils.get_query_params(operations.ListCompositionRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ListCompositionResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.ListCompositionListCompositionResponse])
                res.list_composition_response = out

        return res

    def list_composition_hook(self, request: operations.ListCompositionHookRequest, security: operations.ListCompositionHookSecurity, server_url: Optional[str] = None) -> operations.ListCompositionHookResponse:
        r"""List of all Recording CompositionHook resources."""
        base_url = operations.LIST_COMPOSITION_HOOK_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = base_url.removesuffix('/') + '/v1/CompositionHooks'
        
        query_params = utils.get_query_params(operations.ListCompositionHookRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ListCompositionHookResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.ListCompositionHookListCompositionHookResponse])
                res.list_composition_hook_response = out

        return res

    def list_recording(self, request: operations.ListRecordingRequest, security: operations.ListRecordingSecurity, server_url: Optional[str] = None) -> operations.ListRecordingResponse:
        r"""List of all Track recordings."""
        base_url = operations.LIST_RECORDING_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = base_url.removesuffix('/') + '/v1/Recordings'
        
        query_params = utils.get_query_params(operations.ListRecordingRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ListRecordingResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.ListRecordingListRecordingResponse])
                res.list_recording_response = out

        return res

    def list_room(self, request: operations.ListRoomRequest, security: operations.ListRoomSecurity, server_url: Optional[str] = None) -> operations.ListRoomResponse:
        base_url = operations.LIST_ROOM_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = base_url.removesuffix('/') + '/v1/Rooms'
        
        query_params = utils.get_query_params(operations.ListRoomRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ListRoomResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.ListRoomListRoomResponse])
                res.list_room_response = out

        return res

    def list_room_participant(self, request: operations.ListRoomParticipantRequest, security: operations.ListRoomParticipantSecurity, server_url: Optional[str] = None) -> operations.ListRoomParticipantResponse:
        base_url = operations.LIST_ROOM_PARTICIPANT_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.ListRoomParticipantRequest, base_url, '/v1/Rooms/{RoomSid}/Participants', request)
        
        query_params = utils.get_query_params(operations.ListRoomParticipantRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ListRoomParticipantResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.ListRoomParticipantListRoomParticipantResponse])
                res.list_room_participant_response = out

        return res

    def list_room_participant_published_track(self, request: operations.ListRoomParticipantPublishedTrackRequest, security: operations.ListRoomParticipantPublishedTrackSecurity, server_url: Optional[str] = None) -> operations.ListRoomParticipantPublishedTrackResponse:
        r"""Returns a list of tracks associated with a given Participant. Only `currently` Published Tracks are in the list resource."""
        base_url = operations.LIST_ROOM_PARTICIPANT_PUBLISHED_TRACK_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.ListRoomParticipantPublishedTrackRequest, base_url, '/v1/Rooms/{RoomSid}/Participants/{ParticipantSid}/PublishedTracks', request)
        
        query_params = utils.get_query_params(operations.ListRoomParticipantPublishedTrackRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ListRoomParticipantPublishedTrackResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.ListRoomParticipantPublishedTrackListRoomParticipantPublishedTrackResponse])
                res.list_room_participant_published_track_response = out

        return res

    def list_room_participant_subscribed_track(self, request: operations.ListRoomParticipantSubscribedTrackRequest, security: operations.ListRoomParticipantSubscribedTrackSecurity, server_url: Optional[str] = None) -> operations.ListRoomParticipantSubscribedTrackResponse:
        r"""Returns a list of tracks that are subscribed for the participant."""
        base_url = operations.LIST_ROOM_PARTICIPANT_SUBSCRIBED_TRACK_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.ListRoomParticipantSubscribedTrackRequest, base_url, '/v1/Rooms/{RoomSid}/Participants/{ParticipantSid}/SubscribedTracks', request)
        
        query_params = utils.get_query_params(operations.ListRoomParticipantSubscribedTrackRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ListRoomParticipantSubscribedTrackResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.ListRoomParticipantSubscribedTrackListRoomParticipantSubscribedTrackResponse])
                res.list_room_participant_subscribed_track_response = out

        return res

    def list_room_recording(self, request: operations.ListRoomRecordingRequest, security: operations.ListRoomRecordingSecurity, server_url: Optional[str] = None) -> operations.ListRoomRecordingResponse:
        base_url = operations.LIST_ROOM_RECORDING_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.ListRoomRecordingRequest, base_url, '/v1/Rooms/{RoomSid}/Recordings', request)
        
        query_params = utils.get_query_params(operations.ListRoomRecordingRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ListRoomRecordingResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.ListRoomRecordingListRoomRecordingResponse])
                res.list_room_recording_response = out

        return res

    def update_composition_hook(self, request: operations.UpdateCompositionHookRequest, security: operations.UpdateCompositionHookSecurity, server_url: Optional[str] = None) -> operations.UpdateCompositionHookResponse:
        base_url = operations.UPDATE_COMPOSITION_HOOK_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.UpdateCompositionHookRequest, base_url, '/v1/CompositionHooks/{Sid}', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'form')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.UpdateCompositionHookResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.VideoV1CompositionHook])
                res.video_v1_composition_hook = out

        return res

    def update_room(self, request: operations.UpdateRoomRequest, security: operations.UpdateRoomSecurity, server_url: Optional[str] = None) -> operations.UpdateRoomResponse:
        base_url = operations.UPDATE_ROOM_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.UpdateRoomRequest, base_url, '/v1/Rooms/{Sid}', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'form')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.UpdateRoomResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.VideoV1Room])
                res.video_v1_room = out

        return res

    def update_room_participant(self, request: operations.UpdateRoomParticipantRequest, security: operations.UpdateRoomParticipantSecurity, server_url: Optional[str] = None) -> operations.UpdateRoomParticipantResponse:
        base_url = operations.UPDATE_ROOM_PARTICIPANT_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.UpdateRoomParticipantRequest, base_url, '/v1/Rooms/{RoomSid}/Participants/{Sid}', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'form')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.UpdateRoomParticipantResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.VideoV1RoomRoomParticipant])
                res.video_v1_room_room_participant = out

        return res

    def update_room_participant_anonymize(self, request: operations.UpdateRoomParticipantAnonymizeRequest, security: operations.UpdateRoomParticipantAnonymizeSecurity, server_url: Optional[str] = None) -> operations.UpdateRoomParticipantAnonymizeResponse:
        base_url = operations.UPDATE_ROOM_PARTICIPANT_ANONYMIZE_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.UpdateRoomParticipantAnonymizeRequest, base_url, '/v1/Rooms/{RoomSid}/Participants/{Sid}/Anonymize', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.UpdateRoomParticipantAnonymizeResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.VideoV1RoomRoomParticipantRoomParticipantAnonymize])
                res.video_v1_room_room_participant_room_participant_anonymize = out

        return res

    def update_room_participant_subscribe_rule(self, request: operations.UpdateRoomParticipantSubscribeRuleRequest, security: operations.UpdateRoomParticipantSubscribeRuleSecurity, server_url: Optional[str] = None) -> operations.UpdateRoomParticipantSubscribeRuleResponse:
        r"""Update the Subscribe Rules for the Participant"""
        base_url = operations.UPDATE_ROOM_PARTICIPANT_SUBSCRIBE_RULE_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.UpdateRoomParticipantSubscribeRuleRequest, base_url, '/v1/Rooms/{RoomSid}/Participants/{ParticipantSid}/SubscribeRules', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'form')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.UpdateRoomParticipantSubscribeRuleResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 202:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.VideoV1RoomRoomParticipantRoomParticipantSubscribeRule])
                res.video_v1_room_room_participant_room_participant_subscribe_rule = out

        return res

    def update_room_recording_rule(self, request: operations.UpdateRoomRecordingRuleRequest, security: operations.UpdateRoomRecordingRuleSecurity, server_url: Optional[str] = None) -> operations.UpdateRoomRecordingRuleResponse:
        r"""Update the Recording Rules for the Room"""
        base_url = operations.UPDATE_ROOM_RECORDING_RULE_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.UpdateRoomRecordingRuleRequest, base_url, '/v1/Rooms/{RoomSid}/RecordingRules', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'form')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.UpdateRoomRecordingRuleResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 202:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.VideoV1RoomRoomRecordingRule])
                res.video_v1_room_room_recording_rule = out

        return res

    