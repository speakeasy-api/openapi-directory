// Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.

package sdk

import (
	"context"
	"fmt"
	"io"
	"net/http"
	"openapi/pkg/models/operations"
	"openapi/pkg/models/shared"
	"openapi/pkg/utils"
	"strings"
	"time"
)

// ServerList contains the list of servers available to the SDK
var ServerList = []string{
	// Sandbox server for integrators
	"https://sandbox.gerermesaffaires.com/api/v1/",
}

// HTTPClient provides an interface for suplying the SDK with a custom HTTP client
type HTTPClient interface {
	Do(req *http.Request) (*http.Response, error)
}

// String provides a helper function to return a pointer to a string
func String(s string) *string { return &s }

// SDK - Sécurisez vos données en interfaçant votre logiciel métier avec le service en ligne GererMesAffaires
// https://api.gerermesaffaires.com/ - Documentation fonctionnelle des API GererMesAffaires
type SDK struct {

	// Non-idiomatic field names below are to namespace fields from the fields names above to avoid name conflicts
	_defaultClient  HTTPClient
	_securityClient HTTPClient
	_security       *shared.Security
	_serverURL      string
	_language       string
	_sdkVersion     string
	_genVersion     string
}

type SDKOption func(*SDK)

// WithServerURL allows the overriding of the default server URL
func WithServerURL(serverURL string) SDKOption {
	return func(sdk *SDK) {
		sdk._serverURL = serverURL
	}
}

// WithTemplatedServerURL allows the overriding of the default server URL with a templated URL populated with the provided parameters
func WithTemplatedServerURL(serverURL string, params map[string]string) SDKOption {
	return func(sdk *SDK) {
		if params != nil {
			serverURL = utils.ReplaceParameters(serverURL, params)
		}

		sdk._serverURL = serverURL
	}
}

// WithClient allows the overriding of the default HTTP client used by the SDK
func WithClient(client HTTPClient) SDKOption {
	return func(sdk *SDK) {
		sdk._defaultClient = client
	}
}

// WithSecurity configures the SDK to use the provided security details
func WithSecurity(security shared.Security) SDKOption {
	return func(sdk *SDK) {
		sdk._security = &security
	}
}

// New creates a new instance of the SDK with the provided options
func New(opts ...SDKOption) *SDK {
	sdk := &SDK{
		_language:   "go",
		_sdkVersion: "0.0.1",
		_genVersion: "internal",
	}
	for _, opt := range opts {
		opt(sdk)
	}

	// Use WithClient to override the default client if you would like to customize the timeout
	if sdk._defaultClient == nil {
		sdk._defaultClient = &http.Client{Timeout: 60 * time.Second}
	}
	if sdk._securityClient == nil {
		if sdk._security != nil {
			sdk._securityClient = utils.ConfigureSecurityClient(sdk._defaultClient, sdk._security)
		} else {
			sdk._securityClient = sdk._defaultClient
		}
	}

	if sdk._serverURL == "" {
		sdk._serverURL = ServerList[0]
	}

	return sdk
}

// DeleteBusinessGroupsIDSpacesSpaceID - Remove a customer space from partner
func (s *SDK) DeleteBusinessGroupsIDSpacesSpaceID(ctx context.Context, request operations.DeleteBusinessGroupsIDSpacesSpaceIDRequest, security operations.DeleteBusinessGroupsIDSpacesSpaceIDSecurity) (*operations.DeleteBusinessGroupsIDSpacesSpaceIDResponse, error) {
	baseURL := s._serverURL
	url := utils.GenerateURL(ctx, baseURL, "/business-groups/{id}/spaces/{spaceId}", request, nil)

	req, err := http.NewRequestWithContext(ctx, "DELETE", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	client := utils.ConfigureSecurityClient(s._defaultClient, security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.DeleteBusinessGroupsIDSpacesSpaceIDResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 204:
	}

	return res, nil
}

// DeleteSpacesID - Delete a Space (only space not delivered to customer)
func (s *SDK) DeleteSpacesID(ctx context.Context, request operations.DeleteSpacesIDRequest) (*operations.DeleteSpacesIDResponse, error) {
	baseURL := s._serverURL
	url := utils.GenerateURL(ctx, baseURL, "/spaces/{id}", request, nil)

	req, err := http.NewRequestWithContext(ctx, "DELETE", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	client := s._securityClient

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.DeleteSpacesIDResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 204:
	}

	return res, nil
}

// DeleteSpacesIDCompanyEntitiesPersonIDDetailsDesignation - delete a contact detail for a company entity
func (s *SDK) DeleteSpacesIDCompanyEntitiesPersonIDDetailsDesignation(ctx context.Context, request operations.DeleteSpacesIDCompanyEntitiesPersonIDDetailsDesignationRequest) (*operations.DeleteSpacesIDCompanyEntitiesPersonIDDetailsDesignationResponse, error) {
	baseURL := s._serverURL
	url := utils.GenerateURL(ctx, baseURL, "/spaces/{id}/company-entities/{personId}/details/{designation}", request, nil)

	req, err := http.NewRequestWithContext(ctx, "DELETE", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	client := s._securityClient

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.DeleteSpacesIDCompanyEntitiesPersonIDDetailsDesignationResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 204:
	}

	return res, nil
}

// DeleteSpacesIDGroupsGroupIDFoldersFolderID - delete access to a folder for a group
func (s *SDK) DeleteSpacesIDGroupsGroupIDFoldersFolderID(ctx context.Context, request operations.DeleteSpacesIDGroupsGroupIDFoldersFolderIDRequest) (*operations.DeleteSpacesIDGroupsGroupIDFoldersFolderIDResponse, error) {
	baseURL := s._serverURL
	url := utils.GenerateURL(ctx, baseURL, "/spaces/{id}/groups/{groupId}/folders/{folderId}", request, nil)

	req, err := http.NewRequestWithContext(ctx, "DELETE", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	client := s._securityClient

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.DeleteSpacesIDGroupsGroupIDFoldersFolderIDResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 204:
	}

	return res, nil
}

// DeleteSpacesIDGroupsGroupIDPersonsMemberID - Delete a person of a group
func (s *SDK) DeleteSpacesIDGroupsGroupIDPersonsMemberID(ctx context.Context, request operations.DeleteSpacesIDGroupsGroupIDPersonsMemberIDRequest) (*operations.DeleteSpacesIDGroupsGroupIDPersonsMemberIDResponse, error) {
	baseURL := s._serverURL
	url := utils.GenerateURL(ctx, baseURL, "/spaces/{id}/groups/{groupId}/persons/{memberId}", request, nil)

	req, err := http.NewRequestWithContext(ctx, "DELETE", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	client := s._securityClient

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.DeleteSpacesIDGroupsGroupIDPersonsMemberIDResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 204:
	}

	return res, nil
}

// DeleteSpacesIDPersonsPersonID - delete a person
func (s *SDK) DeleteSpacesIDPersonsPersonID(ctx context.Context, request operations.DeleteSpacesIDPersonsPersonIDRequest) (*operations.DeleteSpacesIDPersonsPersonIDResponse, error) {
	baseURL := s._serverURL
	url := utils.GenerateURL(ctx, baseURL, "/spaces/{id}/persons/{personId}", request, nil)

	req, err := http.NewRequestWithContext(ctx, "DELETE", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	client := s._securityClient

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.DeleteSpacesIDPersonsPersonIDResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 204:
	}

	return res, nil
}

// DeleteSpacesIDPersonsPersonIDDetailsDesignation - delete a contact detail for a person
func (s *SDK) DeleteSpacesIDPersonsPersonIDDetailsDesignation(ctx context.Context, request operations.DeleteSpacesIDPersonsPersonIDDetailsDesignationRequest) (*operations.DeleteSpacesIDPersonsPersonIDDetailsDesignationResponse, error) {
	baseURL := s._serverURL
	url := utils.GenerateURL(ctx, baseURL, "/spaces/{id}/persons/{personId}/details/{designation}", request, nil)

	req, err := http.NewRequestWithContext(ctx, "DELETE", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	client := s._securityClient

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.DeleteSpacesIDPersonsPersonIDDetailsDesignationResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 204:
	}

	return res, nil
}

// DeleteSpacesIDStatusCode - delete a status of the space
func (s *SDK) DeleteSpacesIDStatusCode(ctx context.Context, request operations.DeleteSpacesIDStatusCodeRequest) (*operations.DeleteSpacesIDStatusCodeResponse, error) {
	baseURL := s._serverURL
	url := utils.GenerateURL(ctx, baseURL, "/spaces/{id}/status/{code}", request, nil)

	req, err := http.NewRequestWithContext(ctx, "DELETE", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	client := s._securityClient

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.DeleteSpacesIDStatusCodeResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 204:
	}

	return res, nil
}

// DeleteSpacesIDTriggersName - Deletes a trigger for the space id
func (s *SDK) DeleteSpacesIDTriggersName(ctx context.Context, request operations.DeleteSpacesIDTriggersNameRequest, security operations.DeleteSpacesIDTriggersNameSecurity) (*operations.DeleteSpacesIDTriggersNameResponse, error) {
	baseURL := s._serverURL
	url := utils.GenerateURL(ctx, baseURL, "/spaces/{id}/triggers/{name}", request, nil)

	req, err := http.NewRequestWithContext(ctx, "DELETE", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	client := utils.ConfigureSecurityClient(s._defaultClient, security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.DeleteSpacesIDTriggersNameResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 204:
	}

	return res, nil
}

// DeleteSpacesSpaceIDCommonFoldersID - Delete a common folder
func (s *SDK) DeleteSpacesSpaceIDCommonFoldersID(ctx context.Context, request operations.DeleteSpacesSpaceIDCommonFoldersIDRequest) (*operations.DeleteSpacesSpaceIDCommonFoldersIDResponse, error) {
	baseURL := s._serverURL
	url := utils.GenerateURL(ctx, baseURL, "/spaces/{spaceId}/common-folders/{id}", request, nil)

	req, err := http.NewRequestWithContext(ctx, "DELETE", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	client := s._securityClient

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.DeleteSpacesSpaceIDCommonFoldersIDResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 204:
	}

	return res, nil
}

// DeleteSpacesSpaceIDFoldersFolderIDBankStatementsDocumentID - delete a bank statement
func (s *SDK) DeleteSpacesSpaceIDFoldersFolderIDBankStatementsDocumentID(ctx context.Context, request operations.DeleteSpacesSpaceIDFoldersFolderIDBankStatementsDocumentIDRequest) (*operations.DeleteSpacesSpaceIDFoldersFolderIDBankStatementsDocumentIDResponse, error) {
	baseURL := s._serverURL
	url := utils.GenerateURL(ctx, baseURL, "/spaces/{spaceId}/folders/{folderId}/bank-statements/{documentId}", request, nil)

	req, err := http.NewRequestWithContext(ctx, "DELETE", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	client := s._securityClient

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.DeleteSpacesSpaceIDFoldersFolderIDBankStatementsDocumentIDResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 204:
	}

	return res, nil
}

// DeleteSpacesSpaceIDFoldersFolderIDContractualDocumentsDocumentID - delete a contractual document
func (s *SDK) DeleteSpacesSpaceIDFoldersFolderIDContractualDocumentsDocumentID(ctx context.Context, request operations.DeleteSpacesSpaceIDFoldersFolderIDContractualDocumentsDocumentIDRequest) (*operations.DeleteSpacesSpaceIDFoldersFolderIDContractualDocumentsDocumentIDResponse, error) {
	baseURL := s._serverURL
	url := utils.GenerateURL(ctx, baseURL, "/spaces/{spaceId}/folders/{folderId}/contractual-documents/{documentId}", request, nil)

	req, err := http.NewRequestWithContext(ctx, "DELETE", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	client := s._securityClient

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.DeleteSpacesSpaceIDFoldersFolderIDContractualDocumentsDocumentIDResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 204:
	}

	return res, nil
}

// DeleteSpacesSpaceIDFoldersFolderIDCorporateTaxDeclarationsDocumentID - delete a corporate tax declaration
func (s *SDK) DeleteSpacesSpaceIDFoldersFolderIDCorporateTaxDeclarationsDocumentID(ctx context.Context, request operations.DeleteSpacesSpaceIDFoldersFolderIDCorporateTaxDeclarationsDocumentIDRequest) (*operations.DeleteSpacesSpaceIDFoldersFolderIDCorporateTaxDeclarationsDocumentIDResponse, error) {
	baseURL := s._serverURL
	url := utils.GenerateURL(ctx, baseURL, "/spaces/{spaceId}/folders/{folderId}/corporate-tax-declarations/{documentId}", request, nil)

	req, err := http.NewRequestWithContext(ctx, "DELETE", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	client := s._securityClient

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.DeleteSpacesSpaceIDFoldersFolderIDCorporateTaxDeclarationsDocumentIDResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 204:
	}

	return res, nil
}

// DeleteSpacesSpaceIDFoldersFolderIDExpenseProofsDocumentID - delete an expense proof
func (s *SDK) DeleteSpacesSpaceIDFoldersFolderIDExpenseProofsDocumentID(ctx context.Context, request operations.DeleteSpacesSpaceIDFoldersFolderIDExpenseProofsDocumentIDRequest) (*operations.DeleteSpacesSpaceIDFoldersFolderIDExpenseProofsDocumentIDResponse, error) {
	baseURL := s._serverURL
	url := utils.GenerateURL(ctx, baseURL, "/spaces/{spaceId}/folders/{folderId}/expense-proofs/{documentId}", request, nil)

	req, err := http.NewRequestWithContext(ctx, "DELETE", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	client := s._securityClient

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.DeleteSpacesSpaceIDFoldersFolderIDExpenseProofsDocumentIDResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 204:
	}

	return res, nil
}

// DeleteSpacesSpaceIDFoldersFolderIDExpenseReportsDocumentID - delete an expense report
func (s *SDK) DeleteSpacesSpaceIDFoldersFolderIDExpenseReportsDocumentID(ctx context.Context, request operations.DeleteSpacesSpaceIDFoldersFolderIDExpenseReportsDocumentIDRequest) (*operations.DeleteSpacesSpaceIDFoldersFolderIDExpenseReportsDocumentIDResponse, error) {
	baseURL := s._serverURL
	url := utils.GenerateURL(ctx, baseURL, "/spaces/{spaceId}/folders/{folderId}/expense-reports/{documentId}", request, nil)

	req, err := http.NewRequestWithContext(ctx, "DELETE", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	client := s._securityClient

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.DeleteSpacesSpaceIDFoldersFolderIDExpenseReportsDocumentIDResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 204:
	}

	return res, nil
}

// DeleteSpacesSpaceIDFoldersFolderIDInvoicesDocumentID - delete an invoice document
func (s *SDK) DeleteSpacesSpaceIDFoldersFolderIDInvoicesDocumentID(ctx context.Context, request operations.DeleteSpacesSpaceIDFoldersFolderIDInvoicesDocumentIDRequest) (*operations.DeleteSpacesSpaceIDFoldersFolderIDInvoicesDocumentIDResponse, error) {
	baseURL := s._serverURL
	url := utils.GenerateURL(ctx, baseURL, "/spaces/{spaceId}/folders/{folderId}/invoices/{documentId}", request, nil)

	req, err := http.NewRequestWithContext(ctx, "DELETE", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	client := s._securityClient

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.DeleteSpacesSpaceIDFoldersFolderIDInvoicesDocumentIDResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 204:
	}

	return res, nil
}

// DeleteSpacesSpaceIDFoldersFolderIDOtherTaxesDocumentID - delete a tax declaration
func (s *SDK) DeleteSpacesSpaceIDFoldersFolderIDOtherTaxesDocumentID(ctx context.Context, request operations.DeleteSpacesSpaceIDFoldersFolderIDOtherTaxesDocumentIDRequest) (*operations.DeleteSpacesSpaceIDFoldersFolderIDOtherTaxesDocumentIDResponse, error) {
	baseURL := s._serverURL
	url := utils.GenerateURL(ctx, baseURL, "/spaces/{spaceId}/folders/{folderId}/other-taxes/{documentId}", request, nil)

	req, err := http.NewRequestWithContext(ctx, "DELETE", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	client := s._securityClient

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.DeleteSpacesSpaceIDFoldersFolderIDOtherTaxesDocumentIDResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 204:
	}

	return res, nil
}

// DeleteSpacesSpaceIDFoldersFolderIDPayrollsDocumentID - delete a payroll
func (s *SDK) DeleteSpacesSpaceIDFoldersFolderIDPayrollsDocumentID(ctx context.Context, request operations.DeleteSpacesSpaceIDFoldersFolderIDPayrollsDocumentIDRequest) (*operations.DeleteSpacesSpaceIDFoldersFolderIDPayrollsDocumentIDResponse, error) {
	baseURL := s._serverURL
	url := utils.GenerateURL(ctx, baseURL, "/spaces/{spaceId}/folders/{folderId}/payrolls/{documentId}", request, nil)

	req, err := http.NewRequestWithContext(ctx, "DELETE", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	client := s._securityClient

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.DeleteSpacesSpaceIDFoldersFolderIDPayrollsDocumentIDResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 204:
	}

	return res, nil
}

// DeleteSpacesSpaceIDFoldersFolderIDPayslipsDocumentID - delete a payslip
func (s *SDK) DeleteSpacesSpaceIDFoldersFolderIDPayslipsDocumentID(ctx context.Context, request operations.DeleteSpacesSpaceIDFoldersFolderIDPayslipsDocumentIDRequest) (*operations.DeleteSpacesSpaceIDFoldersFolderIDPayslipsDocumentIDResponse, error) {
	baseURL := s._serverURL
	url := utils.GenerateURL(ctx, baseURL, "/spaces/{spaceId}/folders/{folderId}/payslips/{documentId}", request, nil)

	req, err := http.NewRequestWithContext(ctx, "DELETE", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	client := s._securityClient

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.DeleteSpacesSpaceIDFoldersFolderIDPayslipsDocumentIDResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 204:
	}

	return res, nil
}

// DeleteSpacesSpaceIDFoldersFolderIDSocialContractsDocumentID - delete a social contract
func (s *SDK) DeleteSpacesSpaceIDFoldersFolderIDSocialContractsDocumentID(ctx context.Context, request operations.DeleteSpacesSpaceIDFoldersFolderIDSocialContractsDocumentIDRequest) (*operations.DeleteSpacesSpaceIDFoldersFolderIDSocialContractsDocumentIDResponse, error) {
	baseURL := s._serverURL
	url := utils.GenerateURL(ctx, baseURL, "/spaces/{spaceId}/folders/{folderId}/social-contracts/{documentId}", request, nil)

	req, err := http.NewRequestWithContext(ctx, "DELETE", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	client := s._securityClient

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.DeleteSpacesSpaceIDFoldersFolderIDSocialContractsDocumentIDResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 204:
	}

	return res, nil
}

// DeleteSpacesSpaceIDFoldersFolderIDSocialDeclarationsDocumentID - delete a social declaration
func (s *SDK) DeleteSpacesSpaceIDFoldersFolderIDSocialDeclarationsDocumentID(ctx context.Context, request operations.DeleteSpacesSpaceIDFoldersFolderIDSocialDeclarationsDocumentIDRequest) (*operations.DeleteSpacesSpaceIDFoldersFolderIDSocialDeclarationsDocumentIDResponse, error) {
	baseURL := s._serverURL
	url := utils.GenerateURL(ctx, baseURL, "/spaces/{spaceId}/folders/{folderId}/social-declarations/{documentId}", request, nil)

	req, err := http.NewRequestWithContext(ctx, "DELETE", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	client := s._securityClient

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.DeleteSpacesSpaceIDFoldersFolderIDSocialDeclarationsDocumentIDResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 204:
	}

	return res, nil
}

// DeleteSpacesSpaceIDFoldersFolderIDVatDeclarationsDocumentID - delete a VAT declaration
func (s *SDK) DeleteSpacesSpaceIDFoldersFolderIDVatDeclarationsDocumentID(ctx context.Context, request operations.DeleteSpacesSpaceIDFoldersFolderIDVatDeclarationsDocumentIDRequest) (*operations.DeleteSpacesSpaceIDFoldersFolderIDVatDeclarationsDocumentIDResponse, error) {
	baseURL := s._serverURL
	url := utils.GenerateURL(ctx, baseURL, "/spaces/{spaceId}/folders/{folderId}/vat-declarations/{documentId}", request, nil)

	req, err := http.NewRequestWithContext(ctx, "DELETE", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	client := s._securityClient

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.DeleteSpacesSpaceIDFoldersFolderIDVatDeclarationsDocumentIDResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 204:
	}

	return res, nil
}

// DeleteSpacesSpaceIDFoldersIDAccountingYear - delete an AccountingYear
func (s *SDK) DeleteSpacesSpaceIDFoldersIDAccountingYear(ctx context.Context, request operations.DeleteSpacesSpaceIDFoldersIDAccountingYearRequest) (*operations.DeleteSpacesSpaceIDFoldersIDAccountingYearResponse, error) {
	baseURL := s._serverURL
	url := utils.GenerateURL(ctx, baseURL, "/spaces/{spaceId}/folders/{id}/accounting-year", request, nil)

	req, err := http.NewRequestWithContext(ctx, "DELETE", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	client := s._securityClient

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.DeleteSpacesSpaceIDFoldersIDAccountingYearResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 204:
	}

	return res, nil
}

// DeleteSpacesSpaceIDFoldersIDBank - Delete a Folder (except Name, Class, ModificationDate and ArchivalDate) and Bank data
func (s *SDK) DeleteSpacesSpaceIDFoldersIDBank(ctx context.Context, request operations.DeleteSpacesSpaceIDFoldersIDBankRequest) (*operations.DeleteSpacesSpaceIDFoldersIDBankResponse, error) {
	baseURL := s._serverURL
	url := utils.GenerateURL(ctx, baseURL, "/spaces/{spaceId}/folders/{id}/bank", request, nil)

	req, err := http.NewRequestWithContext(ctx, "DELETE", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	client := s._securityClient

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.DeleteSpacesSpaceIDFoldersIDBankResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 204:
	}

	return res, nil
}

// DeleteSpacesSpaceIDFoldersIDCustomer - delete a customer
func (s *SDK) DeleteSpacesSpaceIDFoldersIDCustomer(ctx context.Context, request operations.DeleteSpacesSpaceIDFoldersIDCustomerRequest) (*operations.DeleteSpacesSpaceIDFoldersIDCustomerResponse, error) {
	baseURL := s._serverURL
	url := utils.GenerateURL(ctx, baseURL, "/spaces/{spaceId}/folders/{id}/customer", request, nil)

	req, err := http.NewRequestWithContext(ctx, "DELETE", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	client := s._securityClient

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.DeleteSpacesSpaceIDFoldersIDCustomerResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 204:
	}

	return res, nil
}

// DeleteSpacesSpaceIDFoldersIDEmployee - Delete a Folder (except Name, Class, ModificationDate and ArchivalDate) and Employee data
func (s *SDK) DeleteSpacesSpaceIDFoldersIDEmployee(ctx context.Context, request operations.DeleteSpacesSpaceIDFoldersIDEmployeeRequest) (*operations.DeleteSpacesSpaceIDFoldersIDEmployeeResponse, error) {
	baseURL := s._serverURL
	url := utils.GenerateURL(ctx, baseURL, "/spaces/{spaceId}/folders/{id}/employee", request, nil)

	req, err := http.NewRequestWithContext(ctx, "DELETE", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	client := s._securityClient

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.DeleteSpacesSpaceIDFoldersIDEmployeeResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 204:
	}

	return res, nil
}

// DeleteSpacesSpaceIDFoldersIDInsurance - Delete a Folder (except Name, Class, ModificationDate and ArchivalDate) and Insurance data
func (s *SDK) DeleteSpacesSpaceIDFoldersIDInsurance(ctx context.Context, request operations.DeleteSpacesSpaceIDFoldersIDInsuranceRequest) (*operations.DeleteSpacesSpaceIDFoldersIDInsuranceResponse, error) {
	baseURL := s._serverURL
	url := utils.GenerateURL(ctx, baseURL, "/spaces/{spaceId}/folders/{id}/insurance", request, nil)

	req, err := http.NewRequestWithContext(ctx, "DELETE", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	client := s._securityClient

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.DeleteSpacesSpaceIDFoldersIDInsuranceResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 204:
	}

	return res, nil
}

// DeleteSpacesSpaceIDFoldersIDLoan - Delete a Folder (except Name, Class, ModificationDate and ArchivalDate) and Loan data
func (s *SDK) DeleteSpacesSpaceIDFoldersIDLoan(ctx context.Context, request operations.DeleteSpacesSpaceIDFoldersIDLoanRequest) (*operations.DeleteSpacesSpaceIDFoldersIDLoanResponse, error) {
	baseURL := s._serverURL
	url := utils.GenerateURL(ctx, baseURL, "/spaces/{spaceId}/folders/{id}/loan", request, nil)

	req, err := http.NewRequestWithContext(ctx, "DELETE", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	client := s._securityClient

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.DeleteSpacesSpaceIDFoldersIDLoanResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 204:
	}

	return res, nil
}

// DeleteSpacesSpaceIDFoldersIDPasswordsPasswordID - delete a password
func (s *SDK) DeleteSpacesSpaceIDFoldersIDPasswordsPasswordID(ctx context.Context, request operations.DeleteSpacesSpaceIDFoldersIDPasswordsPasswordIDRequest) (*operations.DeleteSpacesSpaceIDFoldersIDPasswordsPasswordIDResponse, error) {
	baseURL := s._serverURL
	url := utils.GenerateURL(ctx, baseURL, "/spaces/{spaceId}/folders/{id}/passwords/{passwordId}", request, nil)

	req, err := http.NewRequestWithContext(ctx, "DELETE", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	client := s._securityClient

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.DeleteSpacesSpaceIDFoldersIDPasswordsPasswordIDResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 204:
	}

	return res, nil
}

// DeleteSpacesSpaceIDFoldersIDPayrollsPayrollIDNominativeSocialDeclaration - delete a nominative social declaration in a folder social
func (s *SDK) DeleteSpacesSpaceIDFoldersIDPayrollsPayrollIDNominativeSocialDeclaration(ctx context.Context, request operations.DeleteSpacesSpaceIDFoldersIDPayrollsPayrollIDNominativeSocialDeclarationRequest, security operations.DeleteSpacesSpaceIDFoldersIDPayrollsPayrollIDNominativeSocialDeclarationSecurity) (*operations.DeleteSpacesSpaceIDFoldersIDPayrollsPayrollIDNominativeSocialDeclarationResponse, error) {
	baseURL := s._serverURL
	url := utils.GenerateURL(ctx, baseURL, "/spaces/{spaceId}/folders/{id}/payrolls/{payrollId}/nominative-social-declaration", request, nil)

	req, err := http.NewRequestWithContext(ctx, "DELETE", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	client := utils.ConfigureSecurityClient(s._defaultClient, security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.DeleteSpacesSpaceIDFoldersIDPayrollsPayrollIDNominativeSocialDeclarationResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 204:
	}

	return res, nil
}

// DeleteSpacesSpaceIDFoldersIDPortfolioPortfolioID - delete a secondary portfolio of a customer contract
func (s *SDK) DeleteSpacesSpaceIDFoldersIDPortfolioPortfolioID(ctx context.Context, request operations.DeleteSpacesSpaceIDFoldersIDPortfolioPortfolioIDRequest) (*operations.DeleteSpacesSpaceIDFoldersIDPortfolioPortfolioIDResponse, error) {
	baseURL := s._serverURL
	url := utils.GenerateURL(ctx, baseURL, "/spaces/{spaceId}/folders/{id}/portfolio/{portfolioId}", request, nil)

	req, err := http.NewRequestWithContext(ctx, "DELETE", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	client := s._securityClient

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.DeleteSpacesSpaceIDFoldersIDPortfolioPortfolioIDResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 204:
	}

	return res, nil
}

// DeleteSpacesSpaceIDFoldersIDProfessionalVehicle - delete a Professional Vehicle
func (s *SDK) DeleteSpacesSpaceIDFoldersIDProfessionalVehicle(ctx context.Context, request operations.DeleteSpacesSpaceIDFoldersIDProfessionalVehicleRequest) (*operations.DeleteSpacesSpaceIDFoldersIDProfessionalVehicleResponse, error) {
	baseURL := s._serverURL
	url := utils.GenerateURL(ctx, baseURL, "/spaces/{spaceId}/folders/{id}/professional-vehicle", request, nil)

	req, err := http.NewRequestWithContext(ctx, "DELETE", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	client := s._securityClient

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.DeleteSpacesSpaceIDFoldersIDProfessionalVehicleResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 204:
	}

	return res, nil
}

// DeleteSpacesSpaceIDFoldersIDProvider - delete a provider
func (s *SDK) DeleteSpacesSpaceIDFoldersIDProvider(ctx context.Context, request operations.DeleteSpacesSpaceIDFoldersIDProviderRequest) (*operations.DeleteSpacesSpaceIDFoldersIDProviderResponse, error) {
	baseURL := s._serverURL
	url := utils.GenerateURL(ctx, baseURL, "/spaces/{spaceId}/folders/{id}/provider", request, nil)

	req, err := http.NewRequestWithContext(ctx, "DELETE", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	client := s._securityClient

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.DeleteSpacesSpaceIDFoldersIDProviderResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 204:
	}

	return res, nil
}

// DeleteSpacesSpaceIDFoldersIDRequiredDocumentsRequireddocumentidDocumentsDocumentID - delete a document from a required document
func (s *SDK) DeleteSpacesSpaceIDFoldersIDRequiredDocumentsRequireddocumentidDocumentsDocumentID(ctx context.Context, request operations.DeleteSpacesSpaceIDFoldersIDRequiredDocumentsRequireddocumentidDocumentsDocumentIDRequest, security operations.DeleteSpacesSpaceIDFoldersIDRequiredDocumentsRequireddocumentidDocumentsDocumentIDSecurity) (*operations.DeleteSpacesSpaceIDFoldersIDRequiredDocumentsRequireddocumentidDocumentsDocumentIDResponse, error) {
	baseURL := s._serverURL
	url := utils.GenerateURL(ctx, baseURL, "/spaces/{spaceId}/folders/{id}/required-documents/{requireddocumentid}/documents/{documentId}", request, nil)

	req, err := http.NewRequestWithContext(ctx, "DELETE", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	client := utils.ConfigureSecurityClient(s._defaultClient, security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.DeleteSpacesSpaceIDFoldersIDRequiredDocumentsRequireddocumentidDocumentsDocumentIDResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 204:
	}

	return res, nil
}

// DeleteSpacesSpaceIDFoldersIDSocialRegimes - delete a social regime
func (s *SDK) DeleteSpacesSpaceIDFoldersIDSocialRegimes(ctx context.Context, request operations.DeleteSpacesSpaceIDFoldersIDSocialRegimesRequest) (*operations.DeleteSpacesSpaceIDFoldersIDSocialRegimesResponse, error) {
	baseURL := s._serverURL
	url := utils.GenerateURL(ctx, baseURL, "/spaces/{spaceId}/folders/{id}/social-regimes", request, nil)

	req, err := http.NewRequestWithContext(ctx, "DELETE", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	client := s._securityClient

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.DeleteSpacesSpaceIDFoldersIDSocialRegimesResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 204:
	}

	return res, nil
}

// DeleteSpacesSpaceIDFoldersIDTaxContract - Delete a Folder (except Name, Class, ModificationDate and ArchivalDate) and tax contract data
func (s *SDK) DeleteSpacesSpaceIDFoldersIDTaxContract(ctx context.Context, request operations.DeleteSpacesSpaceIDFoldersIDTaxContractRequest) (*operations.DeleteSpacesSpaceIDFoldersIDTaxContractResponse, error) {
	baseURL := s._serverURL
	url := utils.GenerateURL(ctx, baseURL, "/spaces/{spaceId}/folders/{id}/tax-contract", request, nil)

	req, err := http.NewRequestWithContext(ctx, "DELETE", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	client := s._securityClient

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.DeleteSpacesSpaceIDFoldersIDTaxContractResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 204:
	}

	return res, nil
}

// DeleteSpacesSpaceIDFoldersIDDocumentClass - delete a class document
func (s *SDK) DeleteSpacesSpaceIDFoldersIDDocumentClass(ctx context.Context, request operations.DeleteSpacesSpaceIDFoldersIDDocumentClassRequest) (*operations.DeleteSpacesSpaceIDFoldersIDDocumentClassResponse, error) {
	baseURL := s._serverURL
	url := utils.GenerateURL(ctx, baseURL, "/spaces/{spaceId}/folders/{id}/{documentClass}", request, nil)

	req, err := http.NewRequestWithContext(ctx, "DELETE", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	client := s._securityClient

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.DeleteSpacesSpaceIDFoldersIDDocumentClassResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 204:
	}

	return res, nil
}

// DeleteSpacesSpaceIDPersonsIDGuestInSpace - delete the invitation of a person in a space
func (s *SDK) DeleteSpacesSpaceIDPersonsIDGuestInSpace(ctx context.Context, request operations.DeleteSpacesSpaceIDPersonsIDGuestInSpaceRequest, security operations.DeleteSpacesSpaceIDPersonsIDGuestInSpaceSecurity) (*operations.DeleteSpacesSpaceIDPersonsIDGuestInSpaceResponse, error) {
	baseURL := s._serverURL
	url := utils.GenerateURL(ctx, baseURL, "/spaces/{spaceId}/persons/{id}/guest-in-space", request, nil)

	req, err := http.NewRequestWithContext(ctx, "DELETE", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	client := utils.ConfigureSecurityClient(s._defaultClient, security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.DeleteSpacesSpaceIDPersonsIDGuestInSpaceResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 204:
	}

	return res, nil
}

// DeleteSpacesSpaceIDPersonsIDInvitation - delete the invitation of a person in a space
func (s *SDK) DeleteSpacesSpaceIDPersonsIDInvitation(ctx context.Context, request operations.DeleteSpacesSpaceIDPersonsIDInvitationRequest, security operations.DeleteSpacesSpaceIDPersonsIDInvitationSecurity) (*operations.DeleteSpacesSpaceIDPersonsIDInvitationResponse, error) {
	baseURL := s._serverURL
	url := utils.GenerateURL(ctx, baseURL, "/spaces/{spaceId}/persons/{id}/invitation", request, nil)

	req, err := http.NewRequestWithContext(ctx, "DELETE", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	client := utils.ConfigureSecurityClient(s._defaultClient, security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.DeleteSpacesSpaceIDPersonsIDInvitationResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 204:
	}

	return res, nil
}

// GetBoxMenus - Returns predefined folders and workbooks of the Box for all the spaces
func (s *SDK) GetBoxMenus(ctx context.Context) (*operations.GetBoxMenusResponse, error) {
	baseURL := s._serverURL
	url := strings.TrimSuffix(baseURL, "/") + "/box/menus"

	req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	client := s._securityClient

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.GetBoxMenusResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *operations.GetBoxMenus200ApplicationJSON
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.GetBoxMenus200ApplicationJSONObject = out
		}
	}

	return res, nil
}

// GetBusinessGroups - Returns a list of groups custom ordered by name
func (s *SDK) GetBusinessGroups(ctx context.Context, request operations.GetBusinessGroupsRequest, security operations.GetBusinessGroupsSecurity) (*operations.GetBusinessGroupsResponse, error) {
	baseURL := s._serverURL
	url := strings.TrimSuffix(baseURL, "/") + "/business-groups"

	req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	if err := utils.PopulateQueryParams(ctx, req, request, nil); err != nil {
		return nil, fmt.Errorf("error populating query params: %w", err)
	}

	client := utils.ConfigureSecurityClient(s._defaultClient, security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.GetBusinessGroupsResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out []shared.BusinessGroup
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.GetBusinessGroups200ApplicationJSONAllOfs = out
		}
	}

	return res, nil
}

// GetBusinessGroupsAll - Returns list of groups custom for managers
func (s *SDK) GetBusinessGroupsAll(ctx context.Context, request operations.GetBusinessGroupsAllRequest, security operations.GetBusinessGroupsAllSecurity) (*operations.GetBusinessGroupsAllResponse, error) {
	baseURL := s._serverURL
	url := strings.TrimSuffix(baseURL, "/") + "/business-groups/all"

	req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	if err := utils.PopulateQueryParams(ctx, req, request, nil); err != nil {
		return nil, fmt.Errorf("error populating query params: %w", err)
	}

	client := utils.ConfigureSecurityClient(s._defaultClient, security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.GetBusinessGroupsAllResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out []shared.BusinessGroup
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.GetBusinessGroupsAll200ApplicationJSONAllOfs = out
		}
	}

	return res, nil
}

// GetBusinessGroupsID - Returns a group
func (s *SDK) GetBusinessGroupsID(ctx context.Context, request operations.GetBusinessGroupsIDRequest, security operations.GetBusinessGroupsIDSecurity) (*operations.GetBusinessGroupsIDResponse, error) {
	baseURL := s._serverURL
	url := utils.GenerateURL(ctx, baseURL, "/business-groups/{id}", request, nil)

	req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	client := utils.ConfigureSecurityClient(s._defaultClient, security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.GetBusinessGroupsIDResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *operations.GetBusinessGroupsID200ApplicationJSON
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.GetBusinessGroupsID200ApplicationJSONObject = out
		}
	}

	return res, nil
}

// GetBusinessGroupsIDSpaces - Returns spaces of the business group with id
func (s *SDK) GetBusinessGroupsIDSpaces(ctx context.Context, request operations.GetBusinessGroupsIDSpacesRequest, security operations.GetBusinessGroupsIDSpacesSecurity) (*operations.GetBusinessGroupsIDSpacesResponse, error) {
	baseURL := s._serverURL
	url := utils.GenerateURL(ctx, baseURL, "/business-groups/{id}/spaces", request, nil)

	req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	if err := utils.PopulateQueryParams(ctx, req, request, nil); err != nil {
		return nil, fmt.Errorf("error populating query params: %w", err)
	}

	client := utils.ConfigureSecurityClient(s._defaultClient, security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.GetBusinessGroupsIDSpacesResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out []operations.GetBusinessGroupsIDSpaces200ApplicationJSON
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.GetBusinessGroupsIDSpaces200ApplicationJSONObjects = out
		}
	}

	return res, nil
}

// GetHubBusinessGroupsIDMenus - Returns predefined folders and workbooks of the Hub for all the spaces of the business group
func (s *SDK) GetHubBusinessGroupsIDMenus(ctx context.Context, request operations.GetHubBusinessGroupsIDMenusRequest, security operations.GetHubBusinessGroupsIDMenusSecurity) (*operations.GetHubBusinessGroupsIDMenusResponse, error) {
	baseURL := s._serverURL
	url := utils.GenerateURL(ctx, baseURL, "/hub/business-groups/{Id}/menus", request, nil)

	req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	client := utils.ConfigureSecurityClient(s._defaultClient, security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.GetHubBusinessGroupsIDMenusResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *operations.GetHubBusinessGroupsIDMenus200ApplicationJSON
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.GetHubBusinessGroupsIDMenus200ApplicationJSONObject = out
		}
	}

	return res, nil
}

// GetHubMenus - Returns predefined folders and workbooks of the Hub for all the spaces
func (s *SDK) GetHubMenus(ctx context.Context) (*operations.GetHubMenusResponse, error) {
	baseURL := s._serverURL
	url := strings.TrimSuffix(baseURL, "/") + "/hub/menus"

	req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	client := s._securityClient

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.GetHubMenusResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *operations.GetHubMenus200ApplicationJSON
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.GetHubMenus200ApplicationJSONObject = out
		}
	}

	return res, nil
}

// GetHubMenusAll - Returns predefined folders and workbooks of the Hub for all the spaces and customer spaces
func (s *SDK) GetHubMenusAll(ctx context.Context) (*operations.GetHubMenusAllResponse, error) {
	baseURL := s._serverURL
	url := strings.TrimSuffix(baseURL, "/") + "/hub/menus/all"

	req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	client := s._securityClient

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.GetHubMenusAllResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *operations.GetHubMenusAll200ApplicationJSON
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.GetHubMenusAll200ApplicationJSONObject = out
		}
	}

	return res, nil
}

// GetHubSpacesSpaceIDMenus - Returns predefined folders and workbooks of the Hub for the space
func (s *SDK) GetHubSpacesSpaceIDMenus(ctx context.Context, request operations.GetHubSpacesSpaceIDMenusRequest) (*operations.GetHubSpacesSpaceIDMenusResponse, error) {
	baseURL := s._serverURL
	url := utils.GenerateURL(ctx, baseURL, "/hub/spaces/{spaceId}/menus", request, nil)

	req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	client := s._securityClient

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.GetHubSpacesSpaceIDMenusResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *operations.GetHubSpacesSpaceIDMenus200ApplicationJSON
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.GetHubSpacesSpaceIDMenus200ApplicationJSONObject = out
		}
	}

	return res, nil
}

// GetMenus - Returns predefined entries
func (s *SDK) GetMenus(ctx context.Context) (*operations.GetMenusResponse, error) {
	baseURL := s._serverURL
	url := strings.TrimSuffix(baseURL, "/") + "/menus"

	req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	client := s._securityClient

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.GetMenusResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *operations.GetMenus200ApplicationJSON
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.GetMenus200ApplicationJSONObject = out
		}
	}

	return res, nil
}

// GetProfile - Returns status of member
func (s *SDK) GetProfile(ctx context.Context, request operations.GetProfileRequest, security operations.GetProfileSecurity) (*operations.GetProfileResponse, error) {
	baseURL := s._serverURL
	url := strings.TrimSuffix(baseURL, "/") + "/profile"

	req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	if err := utils.PopulateQueryParams(ctx, req, request, nil); err != nil {
		return nil, fmt.Errorf("error populating query params: %w", err)
	}

	client := utils.ConfigureSecurityClient(s._defaultClient, security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.GetProfileResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *operations.GetProfile200ApplicationJSON
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.GetProfile200ApplicationJSONObject = out
		}
	}

	return res, nil
}

// GetProfileIDFile - Returns status of member
func (s *SDK) GetProfileIDFile(ctx context.Context, request operations.GetProfileIDFileRequest) (*operations.GetProfileIDFileResponse, error) {
	baseURL := s._serverURL
	url := strings.TrimSuffix(baseURL, "/") + "/profile/id-file"

	req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	if err := utils.PopulateQueryParams(ctx, req, request, nil); err != nil {
		return nil, fmt.Errorf("error populating query params: %w", err)
	}

	client := s._securityClient

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.GetProfileIDFileResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *operations.GetProfileIDFile200ApplicationJSON
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.GetProfileIDFile200ApplicationJSONObject = out
		case utils.MatchContentType(contentType, `multipart/form-data`):
			out, err := io.ReadAll(httpRes.Body)
			if err != nil {
				return nil, fmt.Errorf("error reading response body: %w", err)
			}

			res.Body = out
		}
	}

	return res, nil
}

// GetRegistration - Returns the method to get the validation code or the link to register after invitation
func (s *SDK) GetRegistration(ctx context.Context, request operations.GetRegistrationRequest, security operations.GetRegistrationSecurity) (*operations.GetRegistrationResponse, error) {
	baseURL := s._serverURL
	url := strings.TrimSuffix(baseURL, "/") + "/registration"

	req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	if err := utils.PopulateQueryParams(ctx, req, request, nil); err != nil {
		return nil, fmt.Errorf("error populating query params: %w", err)
	}

	client := utils.ConfigureSecurityClient(s._defaultClient, security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.GetRegistrationResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *operations.GetRegistration200ApplicationJSON
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.GetRegistration200ApplicationJSONOneOf = out
		}
	}

	return res, nil
}

// GetSession - Returns member id of user logged
func (s *SDK) GetSession(ctx context.Context) (*operations.GetSessionResponse, error) {
	baseURL := s._serverURL
	url := strings.TrimSuffix(baseURL, "/") + "/session"

	req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	client := s._securityClient

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.GetSessionResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *shared.Session
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.Session = out
		}
	}

	return res, nil
}

// GetSpaces - Returns spaces of my group
func (s *SDK) GetSpaces(ctx context.Context, request operations.GetSpacesRequest) (*operations.GetSpacesResponse, error) {
	baseURL := s._serverURL
	url := strings.TrimSuffix(baseURL, "/") + "/spaces"

	req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	if err := utils.PopulateQueryParams(ctx, req, request, nil); err != nil {
		return nil, fmt.Errorf("error populating query params: %w", err)
	}

	client := s._securityClient

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.GetSpacesResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out []operations.GetSpaces200ApplicationJSON
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.GetSpaces200ApplicationJSONObjects = out
		}
	}

	return res, nil
}

// GetSpacesAll - Returns all spaces
func (s *SDK) GetSpacesAll(ctx context.Context, request operations.GetSpacesAllRequest) (*operations.GetSpacesAllResponse, error) {
	baseURL := s._serverURL
	url := strings.TrimSuffix(baseURL, "/") + "/spaces/all"

	req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	if err := utils.PopulateQueryParams(ctx, req, request, nil); err != nil {
		return nil, fmt.Errorf("error populating query params: %w", err)
	}

	client := s._securityClient

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.GetSpacesAllResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out []operations.GetSpacesAll200ApplicationJSON
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.GetSpacesAll200ApplicationJSONObjects = out
		}
	}

	return res, nil
}

// GetSpacesID - Returns a space
func (s *SDK) GetSpacesID(ctx context.Context, request operations.GetSpacesIDRequest) (*operations.GetSpacesIDResponse, error) {
	baseURL := s._serverURL
	url := utils.GenerateURL(ctx, baseURL, "/spaces/{id}", request, nil)

	req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	client := s._securityClient

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.GetSpacesIDResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *operations.GetSpacesID200ApplicationJSON
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.GetSpacesID200ApplicationJSONObject = out
		}
	}

	return res, nil
}

// GetSpacesIDAccountingYear - Returns list of accounting years for the space {id}
func (s *SDK) GetSpacesIDAccountingYear(ctx context.Context, request operations.GetSpacesIDAccountingYearRequest) (*operations.GetSpacesIDAccountingYearResponse, error) {
	baseURL := s._serverURL
	url := utils.GenerateURL(ctx, baseURL, "/spaces/{id}/accounting-year", request, nil)

	req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	if err := utils.PopulateQueryParams(ctx, req, request, nil); err != nil {
		return nil, fmt.Errorf("error populating query params: %w", err)
	}

	client := s._securityClient

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.GetSpacesIDAccountingYearResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out []operations.GetSpacesIDAccountingYear200ApplicationJSON
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.GetSpacesIDAccountingYear200ApplicationJSONAnies = out
		}
	}

	return res, nil
}

// GetSpacesIDCollectiveDecision - Returns list of collective decisions for the space {id}
func (s *SDK) GetSpacesIDCollectiveDecision(ctx context.Context, request operations.GetSpacesIDCollectiveDecisionRequest) (*operations.GetSpacesIDCollectiveDecisionResponse, error) {
	baseURL := s._serverURL
	url := utils.GenerateURL(ctx, baseURL, "/spaces/{id}/collective-decision", request, nil)

	req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	if err := utils.PopulateQueryParams(ctx, req, request, nil); err != nil {
		return nil, fmt.Errorf("error populating query params: %w", err)
	}

	client := s._securityClient

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.GetSpacesIDCollectiveDecisionResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out []operations.GetSpacesIDCollectiveDecision200ApplicationJSON
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.GetSpacesIDCollectiveDecision200ApplicationJSONAnies = out
		}
	}

	return res, nil
}

// GetSpacesIDCompanyEntities - Returns list of company entities
func (s *SDK) GetSpacesIDCompanyEntities(ctx context.Context, request operations.GetSpacesIDCompanyEntitiesRequest) (*operations.GetSpacesIDCompanyEntitiesResponse, error) {
	baseURL := s._serverURL
	url := utils.GenerateURL(ctx, baseURL, "/spaces/{id}/company-entities", request, nil)

	req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	if err := utils.PopulateQueryParams(ctx, req, request, nil); err != nil {
		return nil, fmt.Errorf("error populating query params: %w", err)
	}

	client := s._securityClient

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.GetSpacesIDCompanyEntitiesResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out []shared.CompanyEntity
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.GetSpacesIDCompanyEntities200ApplicationJSONAllOfs = out
		}
	}

	return res, nil
}

// GetSpacesIDCompanyEntitiesAll - Returns list of company entities even company entities archived
func (s *SDK) GetSpacesIDCompanyEntitiesAll(ctx context.Context, request operations.GetSpacesIDCompanyEntitiesAllRequest) (*operations.GetSpacesIDCompanyEntitiesAllResponse, error) {
	baseURL := s._serverURL
	url := utils.GenerateURL(ctx, baseURL, "/spaces/{id}/company-entities/all", request, nil)

	req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	if err := utils.PopulateQueryParams(ctx, req, request, nil); err != nil {
		return nil, fmt.Errorf("error populating query params: %w", err)
	}

	client := s._securityClient

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.GetSpacesIDCompanyEntitiesAllResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out []shared.CompanyEntity
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.GetSpacesIDCompanyEntitiesAll200ApplicationJSONAllOfs = out
		}
	}

	return res, nil
}

// GetSpacesIDCompanyEntitiesCompanyID - Returns a compay entity
func (s *SDK) GetSpacesIDCompanyEntitiesCompanyID(ctx context.Context, request operations.GetSpacesIDCompanyEntitiesCompanyIDRequest) (*operations.GetSpacesIDCompanyEntitiesCompanyIDResponse, error) {
	baseURL := s._serverURL
	url := utils.GenerateURL(ctx, baseURL, "/spaces/{id}/company-entities/{companyId}", request, nil)

	req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	client := s._securityClient

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.GetSpacesIDCompanyEntitiesCompanyIDResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *shared.CompanyEntity
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.CompanyEntity = out
		}
	}

	return res, nil
}

// GetSpacesIDCompanyEntitiesPersonIDDetails - Returns all details of a company entity
func (s *SDK) GetSpacesIDCompanyEntitiesPersonIDDetails(ctx context.Context, request operations.GetSpacesIDCompanyEntitiesPersonIDDetailsRequest) (*operations.GetSpacesIDCompanyEntitiesPersonIDDetailsResponse, error) {
	baseURL := s._serverURL
	url := utils.GenerateURL(ctx, baseURL, "/spaces/{id}/company-entities/{personId}/details", request, nil)

	req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	client := s._securityClient

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.GetSpacesIDCompanyEntitiesPersonIDDetailsResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out []operations.GetSpacesIDCompanyEntitiesPersonIDDetails200ApplicationJSON
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.GetSpacesIDCompanyEntitiesPersonIDDetails200ApplicationJSONAllOfs = out
		}
	}

	return res, nil
}

// GetSpacesIDFoldersFolderIDPersonsMemberID - return the access of a person in a customer contract
func (s *SDK) GetSpacesIDFoldersFolderIDPersonsMemberID(ctx context.Context, request operations.GetSpacesIDFoldersFolderIDPersonsMemberIDRequest) (*operations.GetSpacesIDFoldersFolderIDPersonsMemberIDResponse, error) {
	baseURL := s._serverURL
	url := utils.GenerateURL(ctx, baseURL, "/spaces/{id}/folders/{folderId}/persons/{memberId}", request, nil)

	req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	client := s._securityClient

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.GetSpacesIDFoldersFolderIDPersonsMemberIDResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out []operations.GetSpacesIDFoldersFolderIDPersonsMemberID200ApplicationJSON
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.GetSpacesIDFoldersFolderIDPersonsMemberID200ApplicationJSONObjects = out
		}
	}

	return res, nil
}

// GetSpacesIDGroups - Returns list of groups
func (s *SDK) GetSpacesIDGroups(ctx context.Context, request operations.GetSpacesIDGroupsRequest) (*operations.GetSpacesIDGroupsResponse, error) {
	baseURL := s._serverURL
	url := utils.GenerateURL(ctx, baseURL, "/spaces/{id}/groups", request, nil)

	req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	if err := utils.PopulateQueryParams(ctx, req, request, nil); err != nil {
		return nil, fmt.Errorf("error populating query params: %w", err)
	}

	client := s._securityClient

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.GetSpacesIDGroupsResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out []shared.Group
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.GetSpacesIDGroups200ApplicationJSONAllOfs = out
		}
	}

	return res, nil
}

// GetSpacesIDGroupsAll - Returns list of groups even archived of the space
func (s *SDK) GetSpacesIDGroupsAll(ctx context.Context, request operations.GetSpacesIDGroupsAllRequest) (*operations.GetSpacesIDGroupsAllResponse, error) {
	baseURL := s._serverURL
	url := utils.GenerateURL(ctx, baseURL, "/spaces/{id}/groups/all", request, nil)

	req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	if err := utils.PopulateQueryParams(ctx, req, request, nil); err != nil {
		return nil, fmt.Errorf("error populating query params: %w", err)
	}

	client := s._securityClient

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.GetSpacesIDGroupsAllResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out []shared.Group
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.GetSpacesIDGroupsAll200ApplicationJSONAllOfs = out
		}
	}

	return res, nil
}

// GetSpacesIDGroupsGroupID - Returns a group
func (s *SDK) GetSpacesIDGroupsGroupID(ctx context.Context, request operations.GetSpacesIDGroupsGroupIDRequest) (*operations.GetSpacesIDGroupsGroupIDResponse, error) {
	baseURL := s._serverURL
	url := utils.GenerateURL(ctx, baseURL, "/spaces/{id}/groups/{groupId}", request, nil)

	req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	client := s._securityClient

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.GetSpacesIDGroupsGroupIDResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *operations.GetSpacesIDGroupsGroupID200ApplicationJSON
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.GetSpacesIDGroupsGroupID200ApplicationJSONObject = out
		}
	}

	return res, nil
}

// GetSpacesIDLegal - Returns legal information of a space (except private)
func (s *SDK) GetSpacesIDLegal(ctx context.Context, request operations.GetSpacesIDLegalRequest) (*operations.GetSpacesIDLegalResponse, error) {
	baseURL := s._serverURL
	url := utils.GenerateURL(ctx, baseURL, "/spaces/{id}/legal", request, nil)

	req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	client := s._securityClient

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.GetSpacesIDLegalResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *shared.Legal
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.Legal = out
		}
	}

	return res, nil
}

// GetSpacesIDLogo - Returns a space with the logo
func (s *SDK) GetSpacesIDLogo(ctx context.Context, request operations.GetSpacesIDLogoRequest) (*operations.GetSpacesIDLogoResponse, error) {
	baseURL := s._serverURL
	url := utils.GenerateURL(ctx, baseURL, "/spaces/{id}/logo", request, nil)

	req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	client := s._securityClient

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.GetSpacesIDLogoResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *shared.Space
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.Space = out
		case utils.MatchContentType(contentType, `multipart/form-data`):
			out, err := io.ReadAll(httpRes.Body)
			if err != nil {
				return nil, fmt.Errorf("error reading response body: %w", err)
			}

			res.Body = out
		}
	}

	return res, nil
}

// GetSpacesIDPersons - Returns list of persons
func (s *SDK) GetSpacesIDPersons(ctx context.Context, request operations.GetSpacesIDPersonsRequest) (*operations.GetSpacesIDPersonsResponse, error) {
	baseURL := s._serverURL
	url := utils.GenerateURL(ctx, baseURL, "/spaces/{id}/persons", request, nil)

	req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	if err := utils.PopulateQueryParams(ctx, req, request, nil); err != nil {
		return nil, fmt.Errorf("error populating query params: %w", err)
	}

	client := s._securityClient

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.GetSpacesIDPersonsResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out []shared.Person
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.GetSpacesIDPersons200ApplicationJSONAllOfs = out
		}
	}

	return res, nil
}

// GetSpacesIDPersonsAll - Returns list of persons even persons archived
func (s *SDK) GetSpacesIDPersonsAll(ctx context.Context, request operations.GetSpacesIDPersonsAllRequest) (*operations.GetSpacesIDPersonsAllResponse, error) {
	baseURL := s._serverURL
	url := utils.GenerateURL(ctx, baseURL, "/spaces/{id}/persons/all", request, nil)

	req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	if err := utils.PopulateQueryParams(ctx, req, request, nil); err != nil {
		return nil, fmt.Errorf("error populating query params: %w", err)
	}

	client := s._securityClient

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.GetSpacesIDPersonsAllResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out []shared.Person
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.GetSpacesIDPersonsAll200ApplicationJSONAllOfs = out
		}
	}

	return res, nil
}

// GetSpacesIDPersonsPersonID - Returns a person
func (s *SDK) GetSpacesIDPersonsPersonID(ctx context.Context, request operations.GetSpacesIDPersonsPersonIDRequest) (*operations.GetSpacesIDPersonsPersonIDResponse, error) {
	baseURL := s._serverURL
	url := utils.GenerateURL(ctx, baseURL, "/spaces/{id}/persons/{personId}", request, nil)

	req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	client := s._securityClient

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.GetSpacesIDPersonsPersonIDResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *operations.GetSpacesIDPersonsPersonID200ApplicationJSON
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.GetSpacesIDPersonsPersonID200ApplicationJSONObject = out
		}
	}

	return res, nil
}

// GetSpacesIDPersonsPersonIDDetails - Returns all details of a person
func (s *SDK) GetSpacesIDPersonsPersonIDDetails(ctx context.Context, request operations.GetSpacesIDPersonsPersonIDDetailsRequest) (*operations.GetSpacesIDPersonsPersonIDDetailsResponse, error) {
	baseURL := s._serverURL
	url := utils.GenerateURL(ctx, baseURL, "/spaces/{id}/persons/{personId}/details", request, nil)

	req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	client := s._securityClient

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.GetSpacesIDPersonsPersonIDDetailsResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out []operations.GetSpacesIDPersonsPersonIDDetails200ApplicationJSON
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.GetSpacesIDPersonsPersonIDDetails200ApplicationJSONAllOfs = out
		}
	}

	return res, nil
}

// GetSpacesIDPersonsPersonIDFolders - Returns list of folders with exceptionnal access of the person personId
func (s *SDK) GetSpacesIDPersonsPersonIDFolders(ctx context.Context, request operations.GetSpacesIDPersonsPersonIDFoldersRequest) (*operations.GetSpacesIDPersonsPersonIDFoldersResponse, error) {
	baseURL := s._serverURL
	url := utils.GenerateURL(ctx, baseURL, "/spaces/{id}/persons/{personId}/folders", request, nil)

	req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	if err := utils.PopulateQueryParams(ctx, req, request, nil); err != nil {
		return nil, fmt.Errorf("error populating query params: %w", err)
	}

	client := s._securityClient

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.GetSpacesIDPersonsPersonIDFoldersResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out []shared.Folder
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.GetSpacesIDPersonsPersonIDFolders200ApplicationJSONAllOfs = out
		}
	}

	return res, nil
}

// GetSpacesIDPersonsPersonIDGroups - Returns list of groups of the person personId
func (s *SDK) GetSpacesIDPersonsPersonIDGroups(ctx context.Context, request operations.GetSpacesIDPersonsPersonIDGroupsRequest) (*operations.GetSpacesIDPersonsPersonIDGroupsResponse, error) {
	baseURL := s._serverURL
	url := utils.GenerateURL(ctx, baseURL, "/spaces/{id}/persons/{personId}/groups", request, nil)

	req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	client := s._securityClient

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.GetSpacesIDPersonsPersonIDGroupsResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out []shared.Group
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.GetSpacesIDPersonsPersonIDGroups200ApplicationJSONAllOfs = out
		}
	}

	return res, nil
}

// GetSpacesIDPersonsPersonIDPortfolios - Returns list of portfolios of the person personId
func (s *SDK) GetSpacesIDPersonsPersonIDPortfolios(ctx context.Context, request operations.GetSpacesIDPersonsPersonIDPortfoliosRequest) (*operations.GetSpacesIDPersonsPersonIDPortfoliosResponse, error) {
	baseURL := s._serverURL
	url := utils.GenerateURL(ctx, baseURL, "/spaces/{id}/persons/{personId}/portfolios", request, nil)

	req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	client := s._securityClient

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.GetSpacesIDPersonsPersonIDPortfoliosResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out []operations.GetSpacesIDPersonsPersonIDPortfolios200ApplicationJSON
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.GetSpacesIDPersonsPersonIDPortfolios200ApplicationJSONAnies = out
		}
	}

	return res, nil
}

// GetSpacesIDProfessionalVehicles - Returns list of professionalvehicles for the space {id}
func (s *SDK) GetSpacesIDProfessionalVehicles(ctx context.Context, request operations.GetSpacesIDProfessionalVehiclesRequest) (*operations.GetSpacesIDProfessionalVehiclesResponse, error) {
	baseURL := s._serverURL
	url := utils.GenerateURL(ctx, baseURL, "/spaces/{id}/professional-vehicles", request, nil)

	req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	if err := utils.PopulateQueryParams(ctx, req, request, nil); err != nil {
		return nil, fmt.Errorf("error populating query params: %w", err)
	}

	client := s._securityClient

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.GetSpacesIDProfessionalVehiclesResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out []operations.GetSpacesIDProfessionalVehicles200ApplicationJSON
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.GetSpacesIDProfessionalVehicles200ApplicationJSONAnies = out
		}
	}

	return res, nil
}

// GetSpacesIDSettingsNf203Logs - Returns state of activation of logs
func (s *SDK) GetSpacesIDSettingsNf203Logs(ctx context.Context, request operations.GetSpacesIDSettingsNf203LogsRequest, security operations.GetSpacesIDSettingsNf203LogsSecurity) (*operations.GetSpacesIDSettingsNf203LogsResponse, error) {
	baseURL := s._serverURL
	url := utils.GenerateURL(ctx, baseURL, "/spaces/{id}/settings/nf203/logs", request, nil)

	req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	client := utils.ConfigureSecurityClient(s._defaultClient, security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.GetSpacesIDSettingsNf203LogsResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *operations.GetSpacesIDSettingsNf203Logs200ApplicationJSON
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.GetSpacesIDSettingsNf203Logs200ApplicationJSONObject = out
		}
	}

	return res, nil
}

// GetSpacesIDStatus - Returns all status of the space
func (s *SDK) GetSpacesIDStatus(ctx context.Context, request operations.GetSpacesIDStatusRequest) (*operations.GetSpacesIDStatusResponse, error) {
	baseURL := s._serverURL
	url := utils.GenerateURL(ctx, baseURL, "/spaces/{id}/status", request, nil)

	req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	client := s._securityClient

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.GetSpacesIDStatusResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out []operations.GetSpacesIDStatus200ApplicationJSON
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.GetSpacesIDStatus200ApplicationJSONAllOfs = out
		}
	}

	return res, nil
}

// GetSpacesIDTaxContracts - Returns list of tax contracts for the space {id}
func (s *SDK) GetSpacesIDTaxContracts(ctx context.Context, request operations.GetSpacesIDTaxContractsRequest) (*operations.GetSpacesIDTaxContractsResponse, error) {
	baseURL := s._serverURL
	url := utils.GenerateURL(ctx, baseURL, "/spaces/{id}/tax-contracts", request, nil)

	req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	client := s._securityClient

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.GetSpacesIDTaxContractsResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out []operations.GetSpacesIDTaxContracts200ApplicationJSON
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.GetSpacesIDTaxContracts200ApplicationJSONAnies = out
		}
	}

	return res, nil
}

// GetSpacesIDTriggers - Returns list of triggers for the space {id}
func (s *SDK) GetSpacesIDTriggers(ctx context.Context, request operations.GetSpacesIDTriggersRequest, security operations.GetSpacesIDTriggersSecurity) (*operations.GetSpacesIDTriggersResponse, error) {
	baseURL := s._serverURL
	url := utils.GenerateURL(ctx, baseURL, "/spaces/{id}/triggers", request, nil)

	req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	client := utils.ConfigureSecurityClient(s._defaultClient, security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.GetSpacesIDTriggersResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out []shared.Trigger
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.GetSpacesIDTriggers200ApplicationJSONAllOfs = out
		}
	}

	return res, nil
}

// GetSpacesSpaceIDCompanyEntitiesIDFollowUps - Returns folder of the company entity
func (s *SDK) GetSpacesSpaceIDCompanyEntitiesIDFollowUps(ctx context.Context, request operations.GetSpacesSpaceIDCompanyEntitiesIDFollowUpsRequest) (*operations.GetSpacesSpaceIDCompanyEntitiesIDFollowUpsResponse, error) {
	baseURL := s._serverURL
	url := utils.GenerateURL(ctx, baseURL, "/spaces/{spaceId}/company-entities/{id}/follow-ups", request, nil)

	req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	client := s._securityClient

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.GetSpacesSpaceIDCompanyEntitiesIDFollowUpsResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out []shared.Folder
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.GetSpacesSpaceIDCompanyEntitiesIDFollowUps200ApplicationJSONAllOfs = out
		}
	}

	return res, nil
}

// GetSpacesSpaceIDCustomers - Returns folder with Id and customer data
func (s *SDK) GetSpacesSpaceIDCustomers(ctx context.Context, request operations.GetSpacesSpaceIDCustomersRequest) (*operations.GetSpacesSpaceIDCustomersResponse, error) {
	baseURL := s._serverURL
	url := utils.GenerateURL(ctx, baseURL, "/spaces/{spaceId}/customers", request, nil)

	req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	if err := utils.PopulateQueryParams(ctx, req, request, nil); err != nil {
		return nil, fmt.Errorf("error populating query params: %w", err)
	}

	client := s._securityClient

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.GetSpacesSpaceIDCustomersResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out []shared.Customer
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.GetSpacesSpaceIDCustomers200ApplicationJSONAllOfs = out
		}
	}

	return res, nil
}

// GetSpacesSpaceIDCustomersAll - Returns folder with Id and customer data (even archived)
func (s *SDK) GetSpacesSpaceIDCustomersAll(ctx context.Context, request operations.GetSpacesSpaceIDCustomersAllRequest) (*operations.GetSpacesSpaceIDCustomersAllResponse, error) {
	baseURL := s._serverURL
	url := utils.GenerateURL(ctx, baseURL, "/spaces/{spaceId}/customers/all", request, nil)

	req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	if err := utils.PopulateQueryParams(ctx, req, request, nil); err != nil {
		return nil, fmt.Errorf("error populating query params: %w", err)
	}

	client := s._securityClient

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.GetSpacesSpaceIDCustomersAllResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out []shared.Customer
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.GetSpacesSpaceIDCustomersAll200ApplicationJSONAllOfs = out
		}
	}

	return res, nil
}

// GetSpacesSpaceIDDocuments - Returns documents of the folder
func (s *SDK) GetSpacesSpaceIDDocuments(ctx context.Context, request operations.GetSpacesSpaceIDDocumentsRequest) (*operations.GetSpacesSpaceIDDocumentsResponse, error) {
	baseURL := s._serverURL
	url := utils.GenerateURL(ctx, baseURL, "/spaces/{spaceId}/documents", request, nil)

	req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	if err := utils.PopulateQueryParams(ctx, req, request, nil); err != nil {
		return nil, fmt.Errorf("error populating query params: %w", err)
	}

	client := s._securityClient

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.GetSpacesSpaceIDDocumentsResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out []operations.GetSpacesSpaceIDDocuments200ApplicationJSON
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.GetSpacesSpaceIDDocuments200ApplicationJSONObjects = out
		}
	}

	return res, nil
}

// GetSpacesSpaceIDDocumentsDocumentIDExtend - read the data of a document
func (s *SDK) GetSpacesSpaceIDDocumentsDocumentIDExtend(ctx context.Context, request operations.GetSpacesSpaceIDDocumentsDocumentIDExtendRequest) (*operations.GetSpacesSpaceIDDocumentsDocumentIDExtendResponse, error) {
	baseURL := s._serverURL
	url := utils.GenerateURL(ctx, baseURL, "/spaces/{spaceId}/documents/{documentId}/extend", request, nil)

	req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	client := s._securityClient

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.GetSpacesSpaceIDDocumentsDocumentIDExtendResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out []operations.GetSpacesSpaceIDDocumentsDocumentIDExtend200ApplicationJSON
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.GetSpacesSpaceIDDocumentsDocumentIDExtend200ApplicationJSONAnies = out
		}
	}

	return res, nil
}

// GetSpacesSpaceIDDocumentsDocumentIDFolders - Returns versions of the document
func (s *SDK) GetSpacesSpaceIDDocumentsDocumentIDFolders(ctx context.Context, request operations.GetSpacesSpaceIDDocumentsDocumentIDFoldersRequest) (*operations.GetSpacesSpaceIDDocumentsDocumentIDFoldersResponse, error) {
	baseURL := s._serverURL
	url := utils.GenerateURL(ctx, baseURL, "/spaces/{spaceId}/documents/{documentId}/folders", request, nil)

	req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	client := s._securityClient

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.GetSpacesSpaceIDDocumentsDocumentIDFoldersResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *operations.GetSpacesSpaceIDDocumentsDocumentIDFolders200ApplicationJSON
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.GetSpacesSpaceIDDocumentsDocumentIDFolders200ApplicationJSONObject = out
		}
	}

	return res, nil
}

// GetSpacesSpaceIDDocumentsDocumentIDMailingprice - returns the number of pages and the price of the pdf to send by mail
func (s *SDK) GetSpacesSpaceIDDocumentsDocumentIDMailingprice(ctx context.Context, request operations.GetSpacesSpaceIDDocumentsDocumentIDMailingpriceRequest, security operations.GetSpacesSpaceIDDocumentsDocumentIDMailingpriceSecurity) (*operations.GetSpacesSpaceIDDocumentsDocumentIDMailingpriceResponse, error) {
	baseURL := s._serverURL
	url := utils.GenerateURL(ctx, baseURL, "/spaces/{spaceId}/documents/{documentId}/mailingprice", request, nil)

	req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	client := utils.ConfigureSecurityClient(s._defaultClient, security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.GetSpacesSpaceIDDocumentsDocumentIDMailingpriceResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *operations.GetSpacesSpaceIDDocumentsDocumentIDMailingprice200ApplicationJSON
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.GetSpacesSpaceIDDocumentsDocumentIDMailingprice200ApplicationJSONObject = out
		}
	}

	return res, nil
}

// GetSpacesSpaceIDDocumentsDocumentIDVersions - Returns versions of the document
func (s *SDK) GetSpacesSpaceIDDocumentsDocumentIDVersions(ctx context.Context, request operations.GetSpacesSpaceIDDocumentsDocumentIDVersionsRequest) (*operations.GetSpacesSpaceIDDocumentsDocumentIDVersionsResponse, error) {
	baseURL := s._serverURL
	url := utils.GenerateURL(ctx, baseURL, "/spaces/{spaceId}/documents/{documentId}/versions", request, nil)

	req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	client := s._securityClient

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.GetSpacesSpaceIDDocumentsDocumentIDVersionsResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out []shared.Document
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.GetSpacesSpaceIDDocumentsDocumentIDVersions200ApplicationJSONAllOfs = out
		}
	}

	return res, nil
}

// GetSpacesSpaceIDDocumentsDocumentIDVersionsCurrent - Returns current version of the document
func (s *SDK) GetSpacesSpaceIDDocumentsDocumentIDVersionsCurrent(ctx context.Context, request operations.GetSpacesSpaceIDDocumentsDocumentIDVersionsCurrentRequest) (*operations.GetSpacesSpaceIDDocumentsDocumentIDVersionsCurrentResponse, error) {
	baseURL := s._serverURL
	url := utils.GenerateURL(ctx, baseURL, "/spaces/{spaceId}/documents/{documentId}/versions/current", request, nil)

	req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	client := s._securityClient

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.GetSpacesSpaceIDDocumentsDocumentIDVersionsCurrentResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *operations.GetSpacesSpaceIDDocumentsDocumentIDVersionsCurrent200ApplicationJSON
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.GetSpacesSpaceIDDocumentsDocumentIDVersionsCurrent200ApplicationJSONObject = out
		}
	}

	return res, nil
}

// GetSpacesSpaceIDDocumentsIDAccess - Returns accesses of one document
func (s *SDK) GetSpacesSpaceIDDocumentsIDAccess(ctx context.Context, request operations.GetSpacesSpaceIDDocumentsIDAccessRequest) (*operations.GetSpacesSpaceIDDocumentsIDAccessResponse, error) {
	baseURL := s._serverURL
	url := utils.GenerateURL(ctx, baseURL, "/spaces/{spaceId}/documents/{id}/access", request, nil)

	req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	client := s._securityClient

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.GetSpacesSpaceIDDocumentsIDAccessResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *operations.GetSpacesSpaceIDDocumentsIDAccess200ApplicationJSON
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.GetSpacesSpaceIDDocumentsIDAccess200ApplicationJSONObject = out
		}
	}

	return res, nil
}

// GetSpacesSpaceIDDocumentsIDAccounting - Returns the document with the accounting property
func (s *SDK) GetSpacesSpaceIDDocumentsIDAccounting(ctx context.Context, request operations.GetSpacesSpaceIDDocumentsIDAccountingRequest) (*operations.GetSpacesSpaceIDDocumentsIDAccountingResponse, error) {
	baseURL := s._serverURL
	url := utils.GenerateURL(ctx, baseURL, "/spaces/{spaceId}/documents/{id}/accounting", request, nil)

	req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	client := s._securityClient

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.GetSpacesSpaceIDDocumentsIDAccountingResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *operations.GetSpacesSpaceIDDocumentsIDAccounting200ApplicationJSON
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.GetSpacesSpaceIDDocumentsIDAccounting200ApplicationJSONObject = out
		}
	}

	return res, nil
}

// GetSpacesSpaceIDDocumentsIDDownload - Returns content of one document
func (s *SDK) GetSpacesSpaceIDDocumentsIDDownload(ctx context.Context, request operations.GetSpacesSpaceIDDocumentsIDDownloadRequest) (*operations.GetSpacesSpaceIDDocumentsIDDownloadResponse, error) {
	baseURL := s._serverURL
	url := utils.GenerateURL(ctx, baseURL, "/spaces/{spaceId}/documents/{id}/download", request, nil)

	req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	client := s._securityClient

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.GetSpacesSpaceIDDocumentsIDDownloadResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `*/*`):
			out, err := io.ReadAll(httpRes.Body)
			if err != nil {
				return nil, fmt.Errorf("error reading response body: %w", err)
			}

			res.Body = out
		case utils.MatchContentType(contentType, `multipart/form-data`):
			out, err := io.ReadAll(httpRes.Body)
			if err != nil {
				return nil, fmt.Errorf("error reading response body: %w", err)
			}

			res.Body = out
		case utils.MatchContentType(contentType, `application/json`):
			var out *operations.GetSpacesSpaceIDDocumentsIDDownload200ApplicationJSON
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.GetSpacesSpaceIDDocumentsIDDownload200ApplicationJSONObject = out
		}
	}

	return res, nil
}

// GetSpacesSpaceIDEmployees - Returns folders with Id and employee data
func (s *SDK) GetSpacesSpaceIDEmployees(ctx context.Context, request operations.GetSpacesSpaceIDEmployeesRequest) (*operations.GetSpacesSpaceIDEmployeesResponse, error) {
	baseURL := s._serverURL
	url := utils.GenerateURL(ctx, baseURL, "/spaces/{spaceId}/employees", request, nil)

	req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	if err := utils.PopulateQueryParams(ctx, req, request, nil); err != nil {
		return nil, fmt.Errorf("error populating query params: %w", err)
	}

	client := s._securityClient

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.GetSpacesSpaceIDEmployeesResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out []shared.Employee
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.GetSpacesSpaceIDEmployees200ApplicationJSONAllOfs = out
		}
	}

	return res, nil
}

// GetSpacesSpaceIDEmployeesAll - Returns folders with Id and employee data (even archived)
func (s *SDK) GetSpacesSpaceIDEmployeesAll(ctx context.Context, request operations.GetSpacesSpaceIDEmployeesAllRequest) (*operations.GetSpacesSpaceIDEmployeesAllResponse, error) {
	baseURL := s._serverURL
	url := utils.GenerateURL(ctx, baseURL, "/spaces/{spaceId}/employees/all", request, nil)

	req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	if err := utils.PopulateQueryParams(ctx, req, request, nil); err != nil {
		return nil, fmt.Errorf("error populating query params: %w", err)
	}

	client := s._securityClient

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.GetSpacesSpaceIDEmployeesAllResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out []shared.Employee
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.GetSpacesSpaceIDEmployeesAll200ApplicationJSONAllOfs = out
		}
	}

	return res, nil
}

// GetSpacesSpaceIDEmployers - Returns folders with Id and employer data
func (s *SDK) GetSpacesSpaceIDEmployers(ctx context.Context, request operations.GetSpacesSpaceIDEmployersRequest) (*operations.GetSpacesSpaceIDEmployersResponse, error) {
	baseURL := s._serverURL
	url := utils.GenerateURL(ctx, baseURL, "/spaces/{spaceId}/employers", request, nil)

	req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	if err := utils.PopulateQueryParams(ctx, req, request, nil); err != nil {
		return nil, fmt.Errorf("error populating query params: %w", err)
	}

	client := s._securityClient

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.GetSpacesSpaceIDEmployersResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out []shared.Employee
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.GetSpacesSpaceIDEmployers200ApplicationJSONAllOfs = out
		}
	}

	return res, nil
}

// GetSpacesSpaceIDEmployersAll - Returns folders with Id and employer data (even archived)
func (s *SDK) GetSpacesSpaceIDEmployersAll(ctx context.Context, request operations.GetSpacesSpaceIDEmployersAllRequest) (*operations.GetSpacesSpaceIDEmployersAllResponse, error) {
	baseURL := s._serverURL
	url := utils.GenerateURL(ctx, baseURL, "/spaces/{spaceId}/employers/all", request, nil)

	req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	if err := utils.PopulateQueryParams(ctx, req, request, nil); err != nil {
		return nil, fmt.Errorf("error populating query params: %w", err)
	}

	client := s._securityClient

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.GetSpacesSpaceIDEmployersAllResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out []shared.Employee
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.GetSpacesSpaceIDEmployersAll200ApplicationJSONAllOfs = out
		}
	}

	return res, nil
}

// GetSpacesSpaceIDExtend - read the data of a space
func (s *SDK) GetSpacesSpaceIDExtend(ctx context.Context, request operations.GetSpacesSpaceIDExtendRequest) (*operations.GetSpacesSpaceIDExtendResponse, error) {
	baseURL := s._serverURL
	url := utils.GenerateURL(ctx, baseURL, "/spaces/{spaceId}/extend", request, nil)

	req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	client := s._securityClient

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.GetSpacesSpaceIDExtendResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *operations.GetSpacesSpaceIDExtend200ApplicationJSON
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.GetSpacesSpaceIDExtend200ApplicationJSONObject = out
		}
	}

	return res, nil
}

// GetSpacesSpaceIDFolders - Returns folders of the space
func (s *SDK) GetSpacesSpaceIDFolders(ctx context.Context, request operations.GetSpacesSpaceIDFoldersRequest) (*operations.GetSpacesSpaceIDFoldersResponse, error) {
	baseURL := s._serverURL
	url := utils.GenerateURL(ctx, baseURL, "/spaces/{spaceId}/folders", request, nil)

	req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	if err := utils.PopulateQueryParams(ctx, req, request, nil); err != nil {
		return nil, fmt.Errorf("error populating query params: %w", err)
	}

	client := s._securityClient

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.GetSpacesSpaceIDFoldersResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out []shared.Folder
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.GetSpacesSpaceIDFolders200ApplicationJSONAllOfs = out
		}
	}

	return res, nil
}

// GetSpacesSpaceIDFoldersAll - Returns folders of the space (even archived)
func (s *SDK) GetSpacesSpaceIDFoldersAll(ctx context.Context, request operations.GetSpacesSpaceIDFoldersAllRequest) (*operations.GetSpacesSpaceIDFoldersAllResponse, error) {
	baseURL := s._serverURL
	url := utils.GenerateURL(ctx, baseURL, "/spaces/{spaceId}/folders/all", request, nil)

	req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	if err := utils.PopulateQueryParams(ctx, req, request, nil); err != nil {
		return nil, fmt.Errorf("error populating query params: %w", err)
	}

	client := s._securityClient

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.GetSpacesSpaceIDFoldersAllResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out []shared.Folder
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.GetSpacesSpaceIDFoldersAll200ApplicationJSONAllOfs = out
		}
	}

	return res, nil
}

// GetSpacesSpaceIDFoldersFolderIDNominativeSocialDeclarationsDocumentID - get a nominative social declaration
func (s *SDK) GetSpacesSpaceIDFoldersFolderIDNominativeSocialDeclarationsDocumentID(ctx context.Context, request operations.GetSpacesSpaceIDFoldersFolderIDNominativeSocialDeclarationsDocumentIDRequest) (*operations.GetSpacesSpaceIDFoldersFolderIDNominativeSocialDeclarationsDocumentIDResponse, error) {
	baseURL := s._serverURL
	url := utils.GenerateURL(ctx, baseURL, "/spaces/{spaceId}/folders/{folderId}/nominative-social-declarations/{documentId}", request, nil)

	req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	client := s._securityClient

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.GetSpacesSpaceIDFoldersFolderIDNominativeSocialDeclarationsDocumentIDResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *operations.GetSpacesSpaceIDFoldersFolderIDNominativeSocialDeclarationsDocumentID200ApplicationJSON
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.GetSpacesSpaceIDFoldersFolderIDNominativeSocialDeclarationsDocumentID200ApplicationJSONObject = out
		}
	}

	return res, nil
}

// GetSpacesSpaceIDFoldersID - Returns folder with Id
func (s *SDK) GetSpacesSpaceIDFoldersID(ctx context.Context, request operations.GetSpacesSpaceIDFoldersIDRequest) (*operations.GetSpacesSpaceIDFoldersIDResponse, error) {
	baseURL := s._serverURL
	url := utils.GenerateURL(ctx, baseURL, "/spaces/{spaceId}/folders/{id}", request, nil)

	req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	client := s._securityClient

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.GetSpacesSpaceIDFoldersIDResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *operations.GetSpacesSpaceIDFoldersID200ApplicationJSON
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.GetSpacesSpaceIDFoldersID200ApplicationJSONObject = out
		}
	}

	return res, nil
}

// GetSpacesSpaceIDFoldersIDAccountings - Returns accountings documents of the folder (results and taxation or accountingyear)
func (s *SDK) GetSpacesSpaceIDFoldersIDAccountings(ctx context.Context, request operations.GetSpacesSpaceIDFoldersIDAccountingsRequest) (*operations.GetSpacesSpaceIDFoldersIDAccountingsResponse, error) {
	baseURL := s._serverURL
	url := utils.GenerateURL(ctx, baseURL, "/spaces/{spaceId}/folders/{id}/accountings", request, nil)

	req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	if err := utils.PopulateQueryParams(ctx, req, request, nil); err != nil {
		return nil, fmt.Errorf("error populating query params: %w", err)
	}

	client := s._securityClient

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.GetSpacesSpaceIDFoldersIDAccountingsResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out []shared.Accounting
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.GetSpacesSpaceIDFoldersIDAccountings200ApplicationJSONAllOfs = out
		}
	}

	return res, nil
}

// GetSpacesSpaceIDFoldersIDAccountingsJournal - journal of accountings document delivered to a customer
func (s *SDK) GetSpacesSpaceIDFoldersIDAccountingsJournal(ctx context.Context, request operations.GetSpacesSpaceIDFoldersIDAccountingsJournalRequest) (*operations.GetSpacesSpaceIDFoldersIDAccountingsJournalResponse, error) {
	baseURL := s._serverURL
	url := utils.GenerateURL(ctx, baseURL, "/spaces/{spaceId}/folders/{id}/accountings-journal", request, nil)

	req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	if err := utils.PopulateQueryParams(ctx, req, request, nil); err != nil {
		return nil, fmt.Errorf("error populating query params: %w", err)
	}

	client := s._securityClient

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.GetSpacesSpaceIDFoldersIDAccountingsJournalResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out []operations.GetSpacesSpaceIDFoldersIDAccountingsJournal200ApplicationJSON
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.GetSpacesSpaceIDFoldersIDAccountingsJournal200ApplicationJSONObjects = out
		}
	}

	return res, nil
}

// GetSpacesSpaceIDFoldersIDBank - Returns folder with Id and bank data
func (s *SDK) GetSpacesSpaceIDFoldersIDBank(ctx context.Context, request operations.GetSpacesSpaceIDFoldersIDBankRequest) (*operations.GetSpacesSpaceIDFoldersIDBankResponse, error) {
	baseURL := s._serverURL
	url := utils.GenerateURL(ctx, baseURL, "/spaces/{spaceId}/folders/{id}/bank", request, nil)

	req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	client := s._securityClient

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.GetSpacesSpaceIDFoldersIDBankResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *shared.Bank
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.Bank = out
		}
	}

	return res, nil
}

// GetSpacesSpaceIDFoldersIDBankStatements - Returns bank statements of the folder bank
func (s *SDK) GetSpacesSpaceIDFoldersIDBankStatements(ctx context.Context, request operations.GetSpacesSpaceIDFoldersIDBankStatementsRequest) (*operations.GetSpacesSpaceIDFoldersIDBankStatementsResponse, error) {
	baseURL := s._serverURL
	url := utils.GenerateURL(ctx, baseURL, "/spaces/{spaceId}/folders/{id}/bank-statements", request, nil)

	req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	if err := utils.PopulateQueryParams(ctx, req, request, nil); err != nil {
		return nil, fmt.Errorf("error populating query params: %w", err)
	}

	client := s._securityClient

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.GetSpacesSpaceIDFoldersIDBankStatementsResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out []shared.BankStatement
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.GetSpacesSpaceIDFoldersIDBankStatements200ApplicationJSONAllOfs = out
		}
	}

	return res, nil
}

// GetSpacesSpaceIDFoldersIDCommonFolders - Returns common folders of a folder
func (s *SDK) GetSpacesSpaceIDFoldersIDCommonFolders(ctx context.Context, request operations.GetSpacesSpaceIDFoldersIDCommonFoldersRequest) (*operations.GetSpacesSpaceIDFoldersIDCommonFoldersResponse, error) {
	baseURL := s._serverURL
	url := utils.GenerateURL(ctx, baseURL, "/spaces/{spaceId}/folders/{id}/common-folders", request, nil)

	req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	if err := utils.PopulateQueryParams(ctx, req, request, nil); err != nil {
		return nil, fmt.Errorf("error populating query params: %w", err)
	}

	client := s._securityClient

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.GetSpacesSpaceIDFoldersIDCommonFoldersResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out []shared.Folder
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.GetSpacesSpaceIDFoldersIDCommonFolders200ApplicationJSONAllOfs = out
		}
	}

	return res, nil
}

// GetSpacesSpaceIDFoldersIDCommonFoldersAll - Returns common folders (even archived) of a folder
func (s *SDK) GetSpacesSpaceIDFoldersIDCommonFoldersAll(ctx context.Context, request operations.GetSpacesSpaceIDFoldersIDCommonFoldersAllRequest) (*operations.GetSpacesSpaceIDFoldersIDCommonFoldersAllResponse, error) {
	baseURL := s._serverURL
	url := utils.GenerateURL(ctx, baseURL, "/spaces/{spaceId}/folders/{id}/common-folders/all", request, nil)

	req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	if err := utils.PopulateQueryParams(ctx, req, request, nil); err != nil {
		return nil, fmt.Errorf("error populating query params: %w", err)
	}

	client := s._securityClient

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.GetSpacesSpaceIDFoldersIDCommonFoldersAllResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out []shared.Folder
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.GetSpacesSpaceIDFoldersIDCommonFoldersAll200ApplicationJSONAllOfs = out
		}
	}

	return res, nil
}

// GetSpacesSpaceIDFoldersIDContractingPartner - Returns all contracting partners of a contract
func (s *SDK) GetSpacesSpaceIDFoldersIDContractingPartner(ctx context.Context, request operations.GetSpacesSpaceIDFoldersIDContractingPartnerRequest) (*operations.GetSpacesSpaceIDFoldersIDContractingPartnerResponse, error) {
	baseURL := s._serverURL
	url := utils.GenerateURL(ctx, baseURL, "/spaces/{spaceId}/folders/{id}/contracting-partner", request, nil)

	req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	client := s._securityClient

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.GetSpacesSpaceIDFoldersIDContractingPartnerResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out []operations.GetSpacesSpaceIDFoldersIDContractingPartner200ApplicationJSON
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.GetSpacesSpaceIDFoldersIDContractingPartner200ApplicationJSONObjects = out
		}
	}

	return res, nil
}

// GetSpacesSpaceIDFoldersIDContractingPartnerSpace - Returns collector space of a contract
func (s *SDK) GetSpacesSpaceIDFoldersIDContractingPartnerSpace(ctx context.Context, request operations.GetSpacesSpaceIDFoldersIDContractingPartnerSpaceRequest) (*operations.GetSpacesSpaceIDFoldersIDContractingPartnerSpaceResponse, error) {
	baseURL := s._serverURL
	url := utils.GenerateURL(ctx, baseURL, "/spaces/{spaceId}/folders/{id}/contracting-partner/space", request, nil)

	req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	client := s._securityClient

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.GetSpacesSpaceIDFoldersIDContractingPartnerSpaceResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out []operations.GetSpacesSpaceIDFoldersIDContractingPartnerSpace200ApplicationJSON
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.GetSpacesSpaceIDFoldersIDContractingPartnerSpace200ApplicationJSONObjects = out
		}
	}

	return res, nil
}

// GetSpacesSpaceIDFoldersIDContractualDocuments - Returns documents of the folder
func (s *SDK) GetSpacesSpaceIDFoldersIDContractualDocuments(ctx context.Context, request operations.GetSpacesSpaceIDFoldersIDContractualDocumentsRequest) (*operations.GetSpacesSpaceIDFoldersIDContractualDocumentsResponse, error) {
	baseURL := s._serverURL
	url := utils.GenerateURL(ctx, baseURL, "/spaces/{spaceId}/folders/{id}/contractual-documents", request, nil)

	req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	if err := utils.PopulateQueryParams(ctx, req, request, nil); err != nil {
		return nil, fmt.Errorf("error populating query params: %w", err)
	}

	client := s._securityClient

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.GetSpacesSpaceIDFoldersIDContractualDocumentsResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out []shared.ContractualDocument
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.GetSpacesSpaceIDFoldersIDContractualDocuments200ApplicationJSONAllOfs = out
		}
	}

	return res, nil
}

// GetSpacesSpaceIDFoldersIDContractualRelationship - Returns folder with Id and contractual-relationship data
func (s *SDK) GetSpacesSpaceIDFoldersIDContractualRelationship(ctx context.Context, request operations.GetSpacesSpaceIDFoldersIDContractualRelationshipRequest) (*operations.GetSpacesSpaceIDFoldersIDContractualRelationshipResponse, error) {
	baseURL := s._serverURL
	url := utils.GenerateURL(ctx, baseURL, "/spaces/{spaceId}/folders/{id}/contractual-relationship", request, nil)

	req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	client := s._securityClient

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.GetSpacesSpaceIDFoldersIDContractualRelationshipResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *shared.ContractualRelationship
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.ContractualRelationship = out
		}
	}

	return res, nil
}

// GetSpacesSpaceIDFoldersIDCoporateTaxDeclarations - Returns corporate tax declarations
func (s *SDK) GetSpacesSpaceIDFoldersIDCoporateTaxDeclarations(ctx context.Context, request operations.GetSpacesSpaceIDFoldersIDCoporateTaxDeclarationsRequest) (*operations.GetSpacesSpaceIDFoldersIDCoporateTaxDeclarationsResponse, error) {
	baseURL := s._serverURL
	url := utils.GenerateURL(ctx, baseURL, "/spaces/{spaceId}/folders/{id}/coporate-tax-declarations", request, nil)

	req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	if err := utils.PopulateQueryParams(ctx, req, request, nil); err != nil {
		return nil, fmt.Errorf("error populating query params: %w", err)
	}

	client := s._securityClient

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.GetSpacesSpaceIDFoldersIDCoporateTaxDeclarationsResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out []shared.CorporateTaxDeclaration
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.GetSpacesSpaceIDFoldersIDCoporateTaxDeclarations200ApplicationJSONAllOfs = out
		}
	}

	return res, nil
}

// GetSpacesSpaceIDFoldersIDCustomer - Returns folder with Id and customer data
func (s *SDK) GetSpacesSpaceIDFoldersIDCustomer(ctx context.Context, request operations.GetSpacesSpaceIDFoldersIDCustomerRequest) (*operations.GetSpacesSpaceIDFoldersIDCustomerResponse, error) {
	baseURL := s._serverURL
	url := utils.GenerateURL(ctx, baseURL, "/spaces/{spaceId}/folders/{id}/customer", request, nil)

	req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	client := s._securityClient

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.GetSpacesSpaceIDFoldersIDCustomerResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *operations.GetSpacesSpaceIDFoldersIDCustomer200ApplicationJSON
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.GetSpacesSpaceIDFoldersIDCustomer200ApplicationJSONObject = out
		}
	}

	return res, nil
}

// GetSpacesSpaceIDFoldersIDDeliveriesJournal - journal of documents delivered to a customer
func (s *SDK) GetSpacesSpaceIDFoldersIDDeliveriesJournal(ctx context.Context, request operations.GetSpacesSpaceIDFoldersIDDeliveriesJournalRequest) (*operations.GetSpacesSpaceIDFoldersIDDeliveriesJournalResponse, error) {
	baseURL := s._serverURL
	url := utils.GenerateURL(ctx, baseURL, "/spaces/{spaceId}/folders/{id}/deliveries-journal", request, nil)

	req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	if err := utils.PopulateQueryParams(ctx, req, request, nil); err != nil {
		return nil, fmt.Errorf("error populating query params: %w", err)
	}

	client := s._securityClient

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.GetSpacesSpaceIDFoldersIDDeliveriesJournalResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out []operations.GetSpacesSpaceIDFoldersIDDeliveriesJournal200ApplicationJSON
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.GetSpacesSpaceIDFoldersIDDeliveriesJournal200ApplicationJSONObjects = out
		}
	}

	return res, nil
}

// GetSpacesSpaceIDFoldersIDDocuments - Returns documents of the folder
func (s *SDK) GetSpacesSpaceIDFoldersIDDocuments(ctx context.Context, request operations.GetSpacesSpaceIDFoldersIDDocumentsRequest) (*operations.GetSpacesSpaceIDFoldersIDDocumentsResponse, error) {
	baseURL := s._serverURL
	url := utils.GenerateURL(ctx, baseURL, "/spaces/{spaceId}/folders/{id}/documents", request, nil)

	req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	if err := utils.PopulateQueryParams(ctx, req, request, nil); err != nil {
		return nil, fmt.Errorf("error populating query params: %w", err)
	}

	client := s._securityClient

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.GetSpacesSpaceIDFoldersIDDocumentsResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out []shared.Document
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.GetSpacesSpaceIDFoldersIDDocuments200ApplicationJSONAllOfs = out
		}
	}

	return res, nil
}

// GetSpacesSpaceIDFoldersIDEmployee - Returns folder with Id and employee data
func (s *SDK) GetSpacesSpaceIDFoldersIDEmployee(ctx context.Context, request operations.GetSpacesSpaceIDFoldersIDEmployeeRequest) (*operations.GetSpacesSpaceIDFoldersIDEmployeeResponse, error) {
	baseURL := s._serverURL
	url := utils.GenerateURL(ctx, baseURL, "/spaces/{spaceId}/folders/{id}/employee", request, nil)

	req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	client := s._securityClient

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.GetSpacesSpaceIDFoldersIDEmployeeResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *shared.Employee
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.Employee = out
		}
	}

	return res, nil
}

// GetSpacesSpaceIDFoldersIDExpenseProofs - Returns expense proofs of the folder (social, followup or exchange)
func (s *SDK) GetSpacesSpaceIDFoldersIDExpenseProofs(ctx context.Context, request operations.GetSpacesSpaceIDFoldersIDExpenseProofsRequest) (*operations.GetSpacesSpaceIDFoldersIDExpenseProofsResponse, error) {
	baseURL := s._serverURL
	url := utils.GenerateURL(ctx, baseURL, "/spaces/{spaceId}/folders/{id}/expense-proofs", request, nil)

	req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	if err := utils.PopulateQueryParams(ctx, req, request, nil); err != nil {
		return nil, fmt.Errorf("error populating query params: %w", err)
	}

	client := s._securityClient

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.GetSpacesSpaceIDFoldersIDExpenseProofsResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out []shared.ExpenseProof
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.GetSpacesSpaceIDFoldersIDExpenseProofs200ApplicationJSONAllOfs = out
		}
	}

	return res, nil
}

// GetSpacesSpaceIDFoldersIDExpenseReports - Returns expense reports of the folder (social or followup)
func (s *SDK) GetSpacesSpaceIDFoldersIDExpenseReports(ctx context.Context, request operations.GetSpacesSpaceIDFoldersIDExpenseReportsRequest) (*operations.GetSpacesSpaceIDFoldersIDExpenseReportsResponse, error) {
	baseURL := s._serverURL
	url := utils.GenerateURL(ctx, baseURL, "/spaces/{spaceId}/folders/{id}/expense-reports", request, nil)

	req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	if err := utils.PopulateQueryParams(ctx, req, request, nil); err != nil {
		return nil, fmt.Errorf("error populating query params: %w", err)
	}

	client := s._securityClient

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.GetSpacesSpaceIDFoldersIDExpenseReportsResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out []shared.ExpenseReport
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.GetSpacesSpaceIDFoldersIDExpenseReports200ApplicationJSONAllOfs = out
		}
	}

	return res, nil
}

// GetSpacesSpaceIDFoldersIDExpenseReportsExpenseReportIDExpenseProofs - Returns expense proofs linked to the expenseReportId
func (s *SDK) GetSpacesSpaceIDFoldersIDExpenseReportsExpenseReportIDExpenseProofs(ctx context.Context, request operations.GetSpacesSpaceIDFoldersIDExpenseReportsExpenseReportIDExpenseProofsRequest) (*operations.GetSpacesSpaceIDFoldersIDExpenseReportsExpenseReportIDExpenseProofsResponse, error) {
	baseURL := s._serverURL
	url := utils.GenerateURL(ctx, baseURL, "/spaces/{spaceId}/folders/{id}/expense-reports/{expenseReportId}/expense-proofs", request, nil)

	req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	if err := utils.PopulateQueryParams(ctx, req, request, nil); err != nil {
		return nil, fmt.Errorf("error populating query params: %w", err)
	}

	client := s._securityClient

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.GetSpacesSpaceIDFoldersIDExpenseReportsExpenseReportIDExpenseProofsResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out []shared.ExpenseProof
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.GetSpacesSpaceIDFoldersIDExpenseReportsExpenseReportIDExpenseProofs200ApplicationJSONAllOfs = out
		}
	}

	return res, nil
}

// GetSpacesSpaceIDFoldersIDInsurance - Returns folder with Id and insurance data
func (s *SDK) GetSpacesSpaceIDFoldersIDInsurance(ctx context.Context, request operations.GetSpacesSpaceIDFoldersIDInsuranceRequest) (*operations.GetSpacesSpaceIDFoldersIDInsuranceResponse, error) {
	baseURL := s._serverURL
	url := utils.GenerateURL(ctx, baseURL, "/spaces/{spaceId}/folders/{id}/insurance", request, nil)

	req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	client := s._securityClient

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.GetSpacesSpaceIDFoldersIDInsuranceResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *shared.Insurance
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.Insurance = out
		}
	}

	return res, nil
}

// GetSpacesSpaceIDFoldersIDInvoices - Returns invoices of the folder (customer, provider, accountingyear or root folders customers or providers)
func (s *SDK) GetSpacesSpaceIDFoldersIDInvoices(ctx context.Context, request operations.GetSpacesSpaceIDFoldersIDInvoicesRequest) (*operations.GetSpacesSpaceIDFoldersIDInvoicesResponse, error) {
	baseURL := s._serverURL
	url := utils.GenerateURL(ctx, baseURL, "/spaces/{spaceId}/folders/{id}/invoices", request, nil)

	req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	if err := utils.PopulateQueryParams(ctx, req, request, nil); err != nil {
		return nil, fmt.Errorf("error populating query params: %w", err)
	}

	client := s._securityClient

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.GetSpacesSpaceIDFoldersIDInvoicesResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out []shared.Invoice
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.GetSpacesSpaceIDFoldersIDInvoices200ApplicationJSONAllOfs = out
		}
	}

	return res, nil
}

// GetSpacesSpaceIDFoldersIDLegalEntity - Returns legal entity of a follow up folder
func (s *SDK) GetSpacesSpaceIDFoldersIDLegalEntity(ctx context.Context, request operations.GetSpacesSpaceIDFoldersIDLegalEntityRequest) (*operations.GetSpacesSpaceIDFoldersIDLegalEntityResponse, error) {
	baseURL := s._serverURL
	url := utils.GenerateURL(ctx, baseURL, "/spaces/{spaceId}/folders/{id}/legal-entity", request, nil)

	req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	client := s._securityClient

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.GetSpacesSpaceIDFoldersIDLegalEntityResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *operations.GetSpacesSpaceIDFoldersIDLegalEntity200ApplicationJSON
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.GetSpacesSpaceIDFoldersIDLegalEntity200ApplicationJSONObject = out
		}
	}

	return res, nil
}

// GetSpacesSpaceIDFoldersIDLoan - Returns folder with Id and loan data
func (s *SDK) GetSpacesSpaceIDFoldersIDLoan(ctx context.Context, request operations.GetSpacesSpaceIDFoldersIDLoanRequest) (*operations.GetSpacesSpaceIDFoldersIDLoanResponse, error) {
	baseURL := s._serverURL
	url := utils.GenerateURL(ctx, baseURL, "/spaces/{spaceId}/folders/{id}/loan", request, nil)

	req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	client := s._securityClient

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.GetSpacesSpaceIDFoldersIDLoanResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *shared.Loan
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.Loan = out
		}
	}

	return res, nil
}

// GetSpacesSpaceIDFoldersIDMessages - Returns messages of the folder
func (s *SDK) GetSpacesSpaceIDFoldersIDMessages(ctx context.Context, request operations.GetSpacesSpaceIDFoldersIDMessagesRequest) (*operations.GetSpacesSpaceIDFoldersIDMessagesResponse, error) {
	baseURL := s._serverURL
	url := utils.GenerateURL(ctx, baseURL, "/spaces/{spaceId}/folders/{id}/messages", request, nil)

	req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	if err := utils.PopulateQueryParams(ctx, req, request, nil); err != nil {
		return nil, fmt.Errorf("error populating query params: %w", err)
	}

	client := s._securityClient

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.GetSpacesSpaceIDFoldersIDMessagesResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out []shared.Message
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.GetSpacesSpaceIDFoldersIDMessages200ApplicationJSONAllOfs = out
		}
	}

	return res, nil
}

// GetSpacesSpaceIDFoldersIDMessagesMessageID - Returns message with Id
func (s *SDK) GetSpacesSpaceIDFoldersIDMessagesMessageID(ctx context.Context, request operations.GetSpacesSpaceIDFoldersIDMessagesMessageIDRequest) (*operations.GetSpacesSpaceIDFoldersIDMessagesMessageIDResponse, error) {
	baseURL := s._serverURL
	url := utils.GenerateURL(ctx, baseURL, "/spaces/{spaceId}/folders/{id}/messages/{messageId}", request, nil)

	req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	client := s._securityClient

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.GetSpacesSpaceIDFoldersIDMessagesMessageIDResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *operations.GetSpacesSpaceIDFoldersIDMessagesMessageID200ApplicationJSON
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.GetSpacesSpaceIDFoldersIDMessagesMessageID200ApplicationJSONObject = out
		}
	}

	return res, nil
}

// GetSpacesSpaceIDFoldersIDNominativeSocialDeclarations - Returns nominative social declarations of the folder social
func (s *SDK) GetSpacesSpaceIDFoldersIDNominativeSocialDeclarations(ctx context.Context, request operations.GetSpacesSpaceIDFoldersIDNominativeSocialDeclarationsRequest) (*operations.GetSpacesSpaceIDFoldersIDNominativeSocialDeclarationsResponse, error) {
	baseURL := s._serverURL
	url := utils.GenerateURL(ctx, baseURL, "/spaces/{spaceId}/folders/{id}/nominative-social-declarations", request, nil)

	req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	if err := utils.PopulateQueryParams(ctx, req, request, nil); err != nil {
		return nil, fmt.Errorf("error populating query params: %w", err)
	}

	client := s._securityClient

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.GetSpacesSpaceIDFoldersIDNominativeSocialDeclarationsResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out []operations.GetSpacesSpaceIDFoldersIDNominativeSocialDeclarations200ApplicationJSON
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.GetSpacesSpaceIDFoldersIDNominativeSocialDeclarations200ApplicationJSONAnies = out
		}
	}

	return res, nil
}

// GetSpacesSpaceIDFoldersIDOtherTaxes - Returns other taxes declarations
func (s *SDK) GetSpacesSpaceIDFoldersIDOtherTaxes(ctx context.Context, request operations.GetSpacesSpaceIDFoldersIDOtherTaxesRequest) (*operations.GetSpacesSpaceIDFoldersIDOtherTaxesResponse, error) {
	baseURL := s._serverURL
	url := utils.GenerateURL(ctx, baseURL, "/spaces/{spaceId}/folders/{id}/other-taxes", request, nil)

	req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	if err := utils.PopulateQueryParams(ctx, req, request, nil); err != nil {
		return nil, fmt.Errorf("error populating query params: %w", err)
	}

	client := s._securityClient

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.GetSpacesSpaceIDFoldersIDOtherTaxesResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out []shared.OtherTax
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.GetSpacesSpaceIDFoldersIDOtherTaxes200ApplicationJSONAllOfs = out
		}
	}

	return res, nil
}

// GetSpacesSpaceIDFoldersIDPasswords - Returns identifiers/passwords of the folder
func (s *SDK) GetSpacesSpaceIDFoldersIDPasswords(ctx context.Context, request operations.GetSpacesSpaceIDFoldersIDPasswordsRequest) (*operations.GetSpacesSpaceIDFoldersIDPasswordsResponse, error) {
	baseURL := s._serverURL
	url := utils.GenerateURL(ctx, baseURL, "/spaces/{spaceId}/folders/{id}/passwords", request, nil)

	req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	client := s._securityClient

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.GetSpacesSpaceIDFoldersIDPasswordsResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out []operations.GetSpacesSpaceIDFoldersIDPasswords200ApplicationJSON
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.GetSpacesSpaceIDFoldersIDPasswords200ApplicationJSONAnies = out
		}
	}

	return res, nil
}

// GetSpacesSpaceIDFoldersIDPasswordsPasswordID - Returns password with Id
func (s *SDK) GetSpacesSpaceIDFoldersIDPasswordsPasswordID(ctx context.Context, request operations.GetSpacesSpaceIDFoldersIDPasswordsPasswordIDRequest) (*operations.GetSpacesSpaceIDFoldersIDPasswordsPasswordIDResponse, error) {
	baseURL := s._serverURL
	url := utils.GenerateURL(ctx, baseURL, "/spaces/{spaceId}/folders/{id}/passwords/{passwordId}", request, nil)

	req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	client := s._securityClient

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.GetSpacesSpaceIDFoldersIDPasswordsPasswordIDResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *operations.GetSpacesSpaceIDFoldersIDPasswordsPasswordID200ApplicationJSON
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.GetSpacesSpaceIDFoldersIDPasswordsPasswordID200ApplicationJSONObject = out
		}
	}

	return res, nil
}

// GetSpacesSpaceIDFoldersIDPayrolls - Returns payrolls of the folder social
func (s *SDK) GetSpacesSpaceIDFoldersIDPayrolls(ctx context.Context, request operations.GetSpacesSpaceIDFoldersIDPayrollsRequest) (*operations.GetSpacesSpaceIDFoldersIDPayrollsResponse, error) {
	baseURL := s._serverURL
	url := utils.GenerateURL(ctx, baseURL, "/spaces/{spaceId}/folders/{id}/payrolls", request, nil)

	req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	if err := utils.PopulateQueryParams(ctx, req, request, nil); err != nil {
		return nil, fmt.Errorf("error populating query params: %w", err)
	}

	client := s._securityClient

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.GetSpacesSpaceIDFoldersIDPayrollsResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out []shared.Payroll
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.GetSpacesSpaceIDFoldersIDPayrolls200ApplicationJSONAllOfs = out
		}
	}

	return res, nil
}

// GetSpacesSpaceIDFoldersIDPayslips - Returns payslips of the folder employee
func (s *SDK) GetSpacesSpaceIDFoldersIDPayslips(ctx context.Context, request operations.GetSpacesSpaceIDFoldersIDPayslipsRequest) (*operations.GetSpacesSpaceIDFoldersIDPayslipsResponse, error) {
	baseURL := s._serverURL
	url := utils.GenerateURL(ctx, baseURL, "/spaces/{spaceId}/folders/{id}/payslips", request, nil)

	req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	if err := utils.PopulateQueryParams(ctx, req, request, nil); err != nil {
		return nil, fmt.Errorf("error populating query params: %w", err)
	}

	client := s._securityClient

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.GetSpacesSpaceIDFoldersIDPayslipsResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out []shared.PaySlip
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.GetSpacesSpaceIDFoldersIDPayslips200ApplicationJSONAllOfs = out
		}
	}

	return res, nil
}

// GetSpacesSpaceIDFoldersIDProvider - Returns folder with Id and provider data
func (s *SDK) GetSpacesSpaceIDFoldersIDProvider(ctx context.Context, request operations.GetSpacesSpaceIDFoldersIDProviderRequest) (*operations.GetSpacesSpaceIDFoldersIDProviderResponse, error) {
	baseURL := s._serverURL
	url := utils.GenerateURL(ctx, baseURL, "/spaces/{spaceId}/folders/{id}/provider", request, nil)

	req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	client := s._securityClient

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.GetSpacesSpaceIDFoldersIDProviderResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *shared.Provider
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.Provider = out
		}
	}

	return res, nil
}

// GetSpacesSpaceIDFoldersIDRequiredDocuments - list of the required documents for a person
func (s *SDK) GetSpacesSpaceIDFoldersIDRequiredDocuments(ctx context.Context, request operations.GetSpacesSpaceIDFoldersIDRequiredDocumentsRequest) (*operations.GetSpacesSpaceIDFoldersIDRequiredDocumentsResponse, error) {
	baseURL := s._serverURL
	url := utils.GenerateURL(ctx, baseURL, "/spaces/{spaceId}/folders/{id}/required-documents", request, nil)

	req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	client := s._securityClient

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.GetSpacesSpaceIDFoldersIDRequiredDocumentsResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out []operations.GetSpacesSpaceIDFoldersIDRequiredDocuments200ApplicationJSON
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.GetSpacesSpaceIDFoldersIDRequiredDocuments200ApplicationJSONObjects = out
		}
	}

	return res, nil
}

// GetSpacesSpaceIDFoldersIDSections - Returns sections of the folder
func (s *SDK) GetSpacesSpaceIDFoldersIDSections(ctx context.Context, request operations.GetSpacesSpaceIDFoldersIDSectionsRequest) (*operations.GetSpacesSpaceIDFoldersIDSectionsResponse, error) {
	baseURL := s._serverURL
	url := utils.GenerateURL(ctx, baseURL, "/spaces/{spaceId}/folders/{id}/sections", request, nil)

	req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	client := s._securityClient

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.GetSpacesSpaceIDFoldersIDSectionsResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out []operations.GetSpacesSpaceIDFoldersIDSections200ApplicationJSON
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.GetSpacesSpaceIDFoldersIDSections200ApplicationJSONAnies = out
		}
	}

	return res, nil
}

// GetSpacesSpaceIDFoldersIDSocialContracts - Returns social contracts of the folder employee
func (s *SDK) GetSpacesSpaceIDFoldersIDSocialContracts(ctx context.Context, request operations.GetSpacesSpaceIDFoldersIDSocialContractsRequest) (*operations.GetSpacesSpaceIDFoldersIDSocialContractsResponse, error) {
	baseURL := s._serverURL
	url := utils.GenerateURL(ctx, baseURL, "/spaces/{spaceId}/folders/{id}/social-contracts", request, nil)

	req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	if err := utils.PopulateQueryParams(ctx, req, request, nil); err != nil {
		return nil, fmt.Errorf("error populating query params: %w", err)
	}

	client := s._securityClient

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.GetSpacesSpaceIDFoldersIDSocialContractsResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out []shared.SocialContract
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.GetSpacesSpaceIDFoldersIDSocialContracts200ApplicationJSONAllOfs = out
		}
	}

	return res, nil
}

// GetSpacesSpaceIDFoldersIDSocialDeclarations - Returns social declarations
func (s *SDK) GetSpacesSpaceIDFoldersIDSocialDeclarations(ctx context.Context, request operations.GetSpacesSpaceIDFoldersIDSocialDeclarationsRequest) (*operations.GetSpacesSpaceIDFoldersIDSocialDeclarationsResponse, error) {
	baseURL := s._serverURL
	url := utils.GenerateURL(ctx, baseURL, "/spaces/{spaceId}/folders/{id}/social-declarations", request, nil)

	req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	if err := utils.PopulateQueryParams(ctx, req, request, nil); err != nil {
		return nil, fmt.Errorf("error populating query params: %w", err)
	}

	client := s._securityClient

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.GetSpacesSpaceIDFoldersIDSocialDeclarationsResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out []shared.SocialDeclaration
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.GetSpacesSpaceIDFoldersIDSocialDeclarations200ApplicationJSONAllOfs = out
		}
	}

	return res, nil
}

// GetSpacesSpaceIDFoldersIDSocialRegimes - Returns folder with Id and social regime data
func (s *SDK) GetSpacesSpaceIDFoldersIDSocialRegimes(ctx context.Context, request operations.GetSpacesSpaceIDFoldersIDSocialRegimesRequest) (*operations.GetSpacesSpaceIDFoldersIDSocialRegimesResponse, error) {
	baseURL := s._serverURL
	url := utils.GenerateURL(ctx, baseURL, "/spaces/{spaceId}/folders/{id}/social-regimes", request, nil)

	req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	client := s._securityClient

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.GetSpacesSpaceIDFoldersIDSocialRegimesResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *shared.SocialRegime
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.SocialRegime = out
		}
	}

	return res, nil
}

// GetSpacesSpaceIDFoldersIDSumInvoices - Returns sum of invoices of the folder (customer, provider, accountingyear or root folders customers or providers)
func (s *SDK) GetSpacesSpaceIDFoldersIDSumInvoices(ctx context.Context, request operations.GetSpacesSpaceIDFoldersIDSumInvoicesRequest) (*operations.GetSpacesSpaceIDFoldersIDSumInvoicesResponse, error) {
	baseURL := s._serverURL
	url := utils.GenerateURL(ctx, baseURL, "/spaces/{spaceId}/folders/{id}/sum-invoices", request, nil)

	req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	if err := utils.PopulateQueryParams(ctx, req, request, nil); err != nil {
		return nil, fmt.Errorf("error populating query params: %w", err)
	}

	client := s._securityClient

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.GetSpacesSpaceIDFoldersIDSumInvoicesResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *operations.GetSpacesSpaceIDFoldersIDSumInvoices200ApplicationJSON
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.GetSpacesSpaceIDFoldersIDSumInvoices200ApplicationJSONObject = out
		}
	}

	return res, nil
}

// GetSpacesSpaceIDFoldersIDVatDeclarations - Returns vat declarations
func (s *SDK) GetSpacesSpaceIDFoldersIDVatDeclarations(ctx context.Context, request operations.GetSpacesSpaceIDFoldersIDVatDeclarationsRequest) (*operations.GetSpacesSpaceIDFoldersIDVatDeclarationsResponse, error) {
	baseURL := s._serverURL
	url := utils.GenerateURL(ctx, baseURL, "/spaces/{spaceId}/folders/{id}/vat-declarations", request, nil)

	req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	if err := utils.PopulateQueryParams(ctx, req, request, nil); err != nil {
		return nil, fmt.Errorf("error populating query params: %w", err)
	}

	client := s._securityClient

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.GetSpacesSpaceIDFoldersIDVatDeclarationsResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out []shared.VATDeclaration
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.GetSpacesSpaceIDFoldersIDVatDeclarations200ApplicationJSONAllOfs = out
		}
	}

	return res, nil
}

// GetSpacesSpaceIDFoldersIDDocumentClass - Returns document of documentClass (without specific data) of the folder
func (s *SDK) GetSpacesSpaceIDFoldersIDDocumentClass(ctx context.Context, request operations.GetSpacesSpaceIDFoldersIDDocumentClassRequest) (*operations.GetSpacesSpaceIDFoldersIDDocumentClassResponse, error) {
	baseURL := s._serverURL
	url := utils.GenerateURL(ctx, baseURL, "/spaces/{spaceId}/folders/{id}/{documentClass}", request, nil)

	req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	client := s._securityClient

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.GetSpacesSpaceIDFoldersIDDocumentClassResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out []shared.Document
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.GetSpacesSpaceIDFoldersIDDocumentClass200ApplicationJSONAllOfs = out
		}
	}

	return res, nil
}

// GetSpacesSpaceIDLegalEntitiesIDBanks - Returns list of bank folders for a legal-entity
func (s *SDK) GetSpacesSpaceIDLegalEntitiesIDBanks(ctx context.Context, request operations.GetSpacesSpaceIDLegalEntitiesIDBanksRequest) (*operations.GetSpacesSpaceIDLegalEntitiesIDBanksResponse, error) {
	baseURL := s._serverURL
	url := utils.GenerateURL(ctx, baseURL, "/spaces/{spaceId}/legal-entities/{id}/banks", request, nil)

	req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	client := s._securityClient

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.GetSpacesSpaceIDLegalEntitiesIDBanksResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out []shared.Bank
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.GetSpacesSpaceIDLegalEntitiesIDBanks200ApplicationJSONAllOfs = out
		}
	}

	return res, nil
}

// GetSpacesSpaceIDLegalEntitiesIDBanksAll - Returns folder of the banks even archived
func (s *SDK) GetSpacesSpaceIDLegalEntitiesIDBanksAll(ctx context.Context, request operations.GetSpacesSpaceIDLegalEntitiesIDBanksAllRequest) (*operations.GetSpacesSpaceIDLegalEntitiesIDBanksAllResponse, error) {
	baseURL := s._serverURL
	url := utils.GenerateURL(ctx, baseURL, "/spaces/{spaceId}/legal-entities/{id}/banks/all", request, nil)

	req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	client := s._securityClient

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.GetSpacesSpaceIDLegalEntitiesIDBanksAllResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out []shared.Bank
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.GetSpacesSpaceIDLegalEntitiesIDBanksAll200ApplicationJSONAllOfs = out
		}
	}

	return res, nil
}

// GetSpacesSpaceIDLegalEntitiesIDContracts - Returns all contract folders of the legal entity
func (s *SDK) GetSpacesSpaceIDLegalEntitiesIDContracts(ctx context.Context, request operations.GetSpacesSpaceIDLegalEntitiesIDContractsRequest) (*operations.GetSpacesSpaceIDLegalEntitiesIDContractsResponse, error) {
	baseURL := s._serverURL
	url := utils.GenerateURL(ctx, baseURL, "/spaces/{spaceId}/legal-entities/{id}/contracts", request, nil)

	req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	client := s._securityClient

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.GetSpacesSpaceIDLegalEntitiesIDContractsResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out []shared.Contract
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.GetSpacesSpaceIDLegalEntitiesIDContracts200ApplicationJSONAllOfs = out
		}
	}

	return res, nil
}

// GetSpacesSpaceIDLegalEntitiesIDContractualRelationships - Returns folder of the others contract with legal entity
func (s *SDK) GetSpacesSpaceIDLegalEntitiesIDContractualRelationships(ctx context.Context, request operations.GetSpacesSpaceIDLegalEntitiesIDContractualRelationshipsRequest) (*operations.GetSpacesSpaceIDLegalEntitiesIDContractualRelationshipsResponse, error) {
	baseURL := s._serverURL
	url := utils.GenerateURL(ctx, baseURL, "/spaces/{spaceId}/legal-entities/{id}/contractual-relationships", request, nil)

	req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	client := s._securityClient

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.GetSpacesSpaceIDLegalEntitiesIDContractualRelationshipsResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out []shared.ContractualRelationship
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.GetSpacesSpaceIDLegalEntitiesIDContractualRelationships200ApplicationJSONAllOfs = out
		}
	}

	return res, nil
}

// GetSpacesSpaceIDLegalEntitiesIDContractualRelationshipsAll - Returns folder of the others contract with legal entity (even archived)
func (s *SDK) GetSpacesSpaceIDLegalEntitiesIDContractualRelationshipsAll(ctx context.Context, request operations.GetSpacesSpaceIDLegalEntitiesIDContractualRelationshipsAllRequest) (*operations.GetSpacesSpaceIDLegalEntitiesIDContractualRelationshipsAllResponse, error) {
	baseURL := s._serverURL
	url := utils.GenerateURL(ctx, baseURL, "/spaces/{spaceId}/legal-entities/{id}/contractual-relationships/all", request, nil)

	req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	client := s._securityClient

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.GetSpacesSpaceIDLegalEntitiesIDContractualRelationshipsAllResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out []shared.ContractualRelationship
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.GetSpacesSpaceIDLegalEntitiesIDContractualRelationshipsAll200ApplicationJSONAllOfs = out
		}
	}

	return res, nil
}

// GetSpacesSpaceIDLegalEntitiesIDCustomers - Returns folder of the customer
func (s *SDK) GetSpacesSpaceIDLegalEntitiesIDCustomers(ctx context.Context, request operations.GetSpacesSpaceIDLegalEntitiesIDCustomersRequest) (*operations.GetSpacesSpaceIDLegalEntitiesIDCustomersResponse, error) {
	baseURL := s._serverURL
	url := utils.GenerateURL(ctx, baseURL, "/spaces/{spaceId}/legal-entities/{id}/customers", request, nil)

	req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	client := s._securityClient

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.GetSpacesSpaceIDLegalEntitiesIDCustomersResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out []shared.Customer
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.GetSpacesSpaceIDLegalEntitiesIDCustomers200ApplicationJSONAllOfs = out
		}
	}

	return res, nil
}

// GetSpacesSpaceIDLegalEntitiesIDCustomersAll - Returns folder of the customers (even archived)
func (s *SDK) GetSpacesSpaceIDLegalEntitiesIDCustomersAll(ctx context.Context, request operations.GetSpacesSpaceIDLegalEntitiesIDCustomersAllRequest) (*operations.GetSpacesSpaceIDLegalEntitiesIDCustomersAllResponse, error) {
	baseURL := s._serverURL
	url := utils.GenerateURL(ctx, baseURL, "/spaces/{spaceId}/legal-entities/{id}/customers/all", request, nil)

	req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	client := s._securityClient

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.GetSpacesSpaceIDLegalEntitiesIDCustomersAllResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out []shared.Customer
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.GetSpacesSpaceIDLegalEntitiesIDCustomersAll200ApplicationJSONAllOfs = out
		}
	}

	return res, nil
}

// GetSpacesSpaceIDLegalEntitiesIDInsurances - Returns list of insurance folders for a legal-entity
func (s *SDK) GetSpacesSpaceIDLegalEntitiesIDInsurances(ctx context.Context, request operations.GetSpacesSpaceIDLegalEntitiesIDInsurancesRequest) (*operations.GetSpacesSpaceIDLegalEntitiesIDInsurancesResponse, error) {
	baseURL := s._serverURL
	url := utils.GenerateURL(ctx, baseURL, "/spaces/{spaceId}/legal-entities/{id}/insurances", request, nil)

	req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	client := s._securityClient

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.GetSpacesSpaceIDLegalEntitiesIDInsurancesResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out []shared.Insurance
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.GetSpacesSpaceIDLegalEntitiesIDInsurances200ApplicationJSONAllOfs = out
		}
	}

	return res, nil
}

// GetSpacesSpaceIDLegalEntitiesIDInsurancesAll - Returns folder of the insurances even archived
func (s *SDK) GetSpacesSpaceIDLegalEntitiesIDInsurancesAll(ctx context.Context, request operations.GetSpacesSpaceIDLegalEntitiesIDInsurancesAllRequest) (*operations.GetSpacesSpaceIDLegalEntitiesIDInsurancesAllResponse, error) {
	baseURL := s._serverURL
	url := utils.GenerateURL(ctx, baseURL, "/spaces/{spaceId}/legal-entities/{id}/insurances/all", request, nil)

	req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	client := s._securityClient

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.GetSpacesSpaceIDLegalEntitiesIDInsurancesAllResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out []shared.Insurance
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.GetSpacesSpaceIDLegalEntitiesIDInsurancesAll200ApplicationJSONAllOfs = out
		}
	}

	return res, nil
}

// GetSpacesSpaceIDLegalEntitiesIDLoans - Returns folder of the loan
func (s *SDK) GetSpacesSpaceIDLegalEntitiesIDLoans(ctx context.Context, request operations.GetSpacesSpaceIDLegalEntitiesIDLoansRequest) (*operations.GetSpacesSpaceIDLegalEntitiesIDLoansResponse, error) {
	baseURL := s._serverURL
	url := utils.GenerateURL(ctx, baseURL, "/spaces/{spaceId}/legal-entities/{id}/loans", request, nil)

	req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	client := s._securityClient

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.GetSpacesSpaceIDLegalEntitiesIDLoansResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out []shared.Loan
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.GetSpacesSpaceIDLegalEntitiesIDLoans200ApplicationJSONAllOfs = out
		}
	}

	return res, nil
}

// GetSpacesSpaceIDLegalEntitiesIDLoansAll - Returns folder of the loans even archived
func (s *SDK) GetSpacesSpaceIDLegalEntitiesIDLoansAll(ctx context.Context, request operations.GetSpacesSpaceIDLegalEntitiesIDLoansAllRequest) (*operations.GetSpacesSpaceIDLegalEntitiesIDLoansAllResponse, error) {
	baseURL := s._serverURL
	url := utils.GenerateURL(ctx, baseURL, "/spaces/{spaceId}/legal-entities/{id}/loans/all", request, nil)

	req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	client := s._securityClient

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.GetSpacesSpaceIDLegalEntitiesIDLoansAllResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out []shared.Loan
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.GetSpacesSpaceIDLegalEntitiesIDLoansAll200ApplicationJSONAllOfs = out
		}
	}

	return res, nil
}

// GetSpacesSpaceIDLegalEntitiesIDProviders - Returns list of providers folders for a legal-entity
func (s *SDK) GetSpacesSpaceIDLegalEntitiesIDProviders(ctx context.Context, request operations.GetSpacesSpaceIDLegalEntitiesIDProvidersRequest) (*operations.GetSpacesSpaceIDLegalEntitiesIDProvidersResponse, error) {
	baseURL := s._serverURL
	url := utils.GenerateURL(ctx, baseURL, "/spaces/{spaceId}/legal-entities/{id}/providers", request, nil)

	req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	client := s._securityClient

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.GetSpacesSpaceIDLegalEntitiesIDProvidersResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out []shared.Provider
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.GetSpacesSpaceIDLegalEntitiesIDProviders200ApplicationJSONAllOfs = out
		}
	}

	return res, nil
}

// GetSpacesSpaceIDLegalEntitiesIDProvidersAll - Returns folder of the providers even archived
func (s *SDK) GetSpacesSpaceIDLegalEntitiesIDProvidersAll(ctx context.Context, request operations.GetSpacesSpaceIDLegalEntitiesIDProvidersAllRequest) (*operations.GetSpacesSpaceIDLegalEntitiesIDProvidersAllResponse, error) {
	baseURL := s._serverURL
	url := utils.GenerateURL(ctx, baseURL, "/spaces/{spaceId}/legal-entities/{id}/providers/all", request, nil)

	req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	client := s._securityClient

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.GetSpacesSpaceIDLegalEntitiesIDProvidersAllResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out []shared.Provider
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.GetSpacesSpaceIDLegalEntitiesIDProvidersAll200ApplicationJSONAllOfs = out
		}
	}

	return res, nil
}

// GetSpacesSpaceIDLegalEntitiesIDSocialRegimes - Returns list of social regimes folders for a legal-entity
func (s *SDK) GetSpacesSpaceIDLegalEntitiesIDSocialRegimes(ctx context.Context, request operations.GetSpacesSpaceIDLegalEntitiesIDSocialRegimesRequest) (*operations.GetSpacesSpaceIDLegalEntitiesIDSocialRegimesResponse, error) {
	baseURL := s._serverURL
	url := utils.GenerateURL(ctx, baseURL, "/spaces/{spaceId}/legal-entities/{id}/social-regimes", request, nil)

	req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	client := s._securityClient

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.GetSpacesSpaceIDLegalEntitiesIDSocialRegimesResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out []shared.SocialRegime
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.GetSpacesSpaceIDLegalEntitiesIDSocialRegimes200ApplicationJSONAllOfs = out
		}
	}

	return res, nil
}

// GetSpacesSpaceIDLegalEntitiesIDSocialRegimesAll - Returns folder of the social regimes even archived
func (s *SDK) GetSpacesSpaceIDLegalEntitiesIDSocialRegimesAll(ctx context.Context, request operations.GetSpacesSpaceIDLegalEntitiesIDSocialRegimesAllRequest) (*operations.GetSpacesSpaceIDLegalEntitiesIDSocialRegimesAllResponse, error) {
	baseURL := s._serverURL
	url := utils.GenerateURL(ctx, baseURL, "/spaces/{spaceId}/legal-entities/{id}/social-regimes/all", request, nil)

	req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	client := s._securityClient

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.GetSpacesSpaceIDLegalEntitiesIDSocialRegimesAllResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out []shared.SocialRegime
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.GetSpacesSpaceIDLegalEntitiesIDSocialRegimesAll200ApplicationJSONAllOfs = out
		}
	}

	return res, nil
}

// GetSpacesSpaceIDLoans - Returns list of all loan folders of the space
func (s *SDK) GetSpacesSpaceIDLoans(ctx context.Context, request operations.GetSpacesSpaceIDLoansRequest) (*operations.GetSpacesSpaceIDLoansResponse, error) {
	baseURL := s._serverURL
	url := utils.GenerateURL(ctx, baseURL, "/spaces/{spaceId}/loans", request, nil)

	req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	client := s._securityClient

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.GetSpacesSpaceIDLoansResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out []shared.Loan
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.GetSpacesSpaceIDLoans200ApplicationJSONAllOfs = out
		}
	}

	return res, nil
}

// GetSpacesSpaceIDLoansAll - Returns list of all loan folders even archived of the space
func (s *SDK) GetSpacesSpaceIDLoansAll(ctx context.Context, request operations.GetSpacesSpaceIDLoansAllRequest) (*operations.GetSpacesSpaceIDLoansAllResponse, error) {
	baseURL := s._serverURL
	url := utils.GenerateURL(ctx, baseURL, "/spaces/{spaceId}/loans/all", request, nil)

	req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	client := s._securityClient

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.GetSpacesSpaceIDLoansAllResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out []shared.Loan
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.GetSpacesSpaceIDLoansAll200ApplicationJSONAllOfs = out
		}
	}

	return res, nil
}

// GetSpacesSpaceIDPersonsIDEmployees - Returns folder of the employee
func (s *SDK) GetSpacesSpaceIDPersonsIDEmployees(ctx context.Context, request operations.GetSpacesSpaceIDPersonsIDEmployeesRequest) (*operations.GetSpacesSpaceIDPersonsIDEmployeesResponse, error) {
	baseURL := s._serverURL
	url := utils.GenerateURL(ctx, baseURL, "/spaces/{spaceId}/persons/{id}/employees", request, nil)

	req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	client := s._securityClient

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.GetSpacesSpaceIDPersonsIDEmployeesResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out []shared.Employee
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.GetSpacesSpaceIDPersonsIDEmployees200ApplicationJSONAllOfs = out
		}
	}

	return res, nil
}

// GetSpacesSpaceIDPersonsIDEmployeesAll - Returns folder of all employees (even archived)
func (s *SDK) GetSpacesSpaceIDPersonsIDEmployeesAll(ctx context.Context, request operations.GetSpacesSpaceIDPersonsIDEmployeesAllRequest) (*operations.GetSpacesSpaceIDPersonsIDEmployeesAllResponse, error) {
	baseURL := s._serverURL
	url := utils.GenerateURL(ctx, baseURL, "/spaces/{spaceId}/persons/{id}/employees/all", request, nil)

	req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	client := s._securityClient

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.GetSpacesSpaceIDPersonsIDEmployeesAllResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out []shared.Employee
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.GetSpacesSpaceIDPersonsIDEmployeesAll200ApplicationJSONAllOfs = out
		}
	}

	return res, nil
}

// GetSpacesSpaceIDPersonsIDExchange - Returns folder exchange of the person
func (s *SDK) GetSpacesSpaceIDPersonsIDExchange(ctx context.Context, request operations.GetSpacesSpaceIDPersonsIDExchangeRequest) (*operations.GetSpacesSpaceIDPersonsIDExchangeResponse, error) {
	baseURL := s._serverURL
	url := utils.GenerateURL(ctx, baseURL, "/spaces/{spaceId}/persons/{id}/exchange", request, nil)

	req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	client := s._securityClient

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.GetSpacesSpaceIDPersonsIDExchangeResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *operations.GetSpacesSpaceIDPersonsIDExchange200ApplicationJSON
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.GetSpacesSpaceIDPersonsIDExchange200ApplicationJSONObject = out
		}
	}

	return res, nil
}

// GetSpacesSpaceIDPersonsIDFollowUps - Returns folder of the person
func (s *SDK) GetSpacesSpaceIDPersonsIDFollowUps(ctx context.Context, request operations.GetSpacesSpaceIDPersonsIDFollowUpsRequest) (*operations.GetSpacesSpaceIDPersonsIDFollowUpsResponse, error) {
	baseURL := s._serverURL
	url := utils.GenerateURL(ctx, baseURL, "/spaces/{spaceId}/persons/{id}/follow-ups", request, nil)

	req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	client := s._securityClient

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.GetSpacesSpaceIDPersonsIDFollowUpsResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *shared.FollowUp
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.FollowUp = out
		}
	}

	return res, nil
}

// GetSpacesSpaceIDPersonsIDInvitation - Returns invitation of a person
func (s *SDK) GetSpacesSpaceIDPersonsIDInvitation(ctx context.Context, request operations.GetSpacesSpaceIDPersonsIDInvitationRequest) (*operations.GetSpacesSpaceIDPersonsIDInvitationResponse, error) {
	baseURL := s._serverURL
	url := utils.GenerateURL(ctx, baseURL, "/spaces/{spaceId}/persons/{id}/invitation", request, nil)

	req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	client := s._securityClient

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.GetSpacesSpaceIDPersonsIDInvitationResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `*/*`):
			out, err := io.ReadAll(httpRes.Body)
			if err != nil {
				return nil, fmt.Errorf("error reading response body: %w", err)
			}

			res.Body = out
		}
	}

	return res, nil
}

// GetSpacesSpaceIDPersonsMemberIDFoldersID - Returns folderId with the access of the person
func (s *SDK) GetSpacesSpaceIDPersonsMemberIDFoldersID(ctx context.Context, request operations.GetSpacesSpaceIDPersonsMemberIDFoldersIDRequest) (*operations.GetSpacesSpaceIDPersonsMemberIDFoldersIDResponse, error) {
	baseURL := s._serverURL
	url := utils.GenerateURL(ctx, baseURL, "/spaces/{spaceId}/persons/{memberId}/folders/{id}", request, nil)

	req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	client := s._securityClient

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.GetSpacesSpaceIDPersonsMemberIDFoldersIDResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *operations.GetSpacesSpaceIDPersonsMemberIDFoldersID200ApplicationJSON
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.GetSpacesSpaceIDPersonsMemberIDFoldersID200ApplicationJSONObject = out
		}
	}

	return res, nil
}

// GetSpacesSpaceIDProviders - Returns folder with Id and provider data
func (s *SDK) GetSpacesSpaceIDProviders(ctx context.Context, request operations.GetSpacesSpaceIDProvidersRequest) (*operations.GetSpacesSpaceIDProvidersResponse, error) {
	baseURL := s._serverURL
	url := utils.GenerateURL(ctx, baseURL, "/spaces/{spaceId}/providers", request, nil)

	req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	if err := utils.PopulateQueryParams(ctx, req, request, nil); err != nil {
		return nil, fmt.Errorf("error populating query params: %w", err)
	}

	client := s._securityClient

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.GetSpacesSpaceIDProvidersResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out []shared.Provider
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.GetSpacesSpaceIDProviders200ApplicationJSONAllOfs = out
		}
	}

	return res, nil
}

// GetSpacesSpaceIDProvidersAll - Returns folder with Id and provider data (even archived)
func (s *SDK) GetSpacesSpaceIDProvidersAll(ctx context.Context, request operations.GetSpacesSpaceIDProvidersAllRequest) (*operations.GetSpacesSpaceIDProvidersAllResponse, error) {
	baseURL := s._serverURL
	url := utils.GenerateURL(ctx, baseURL, "/spaces/{spaceId}/providers/all", request, nil)

	req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	if err := utils.PopulateQueryParams(ctx, req, request, nil); err != nil {
		return nil, fmt.Errorf("error populating query params: %w", err)
	}

	client := s._securityClient

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.GetSpacesSpaceIDProvidersAllResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out []shared.Provider
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.GetSpacesSpaceIDProvidersAll200ApplicationJSONAllOfs = out
		}
	}

	return res, nil
}

// GetSpacesSpaceIDSocialRegimes - Returns folder with Id and social regime data
func (s *SDK) GetSpacesSpaceIDSocialRegimes(ctx context.Context, request operations.GetSpacesSpaceIDSocialRegimesRequest) (*operations.GetSpacesSpaceIDSocialRegimesResponse, error) {
	baseURL := s._serverURL
	url := utils.GenerateURL(ctx, baseURL, "/spaces/{spaceId}/social-regimes", request, nil)

	req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	if err := utils.PopulateQueryParams(ctx, req, request, nil); err != nil {
		return nil, fmt.Errorf("error populating query params: %w", err)
	}

	client := s._securityClient

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.GetSpacesSpaceIDSocialRegimesResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out []shared.SocialRegime
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.GetSpacesSpaceIDSocialRegimes200ApplicationJSONAllOfs = out
		}
	}

	return res, nil
}

// GetSpacesSpaceIDSocialRegimesAll - Returns folder with Id and social regime data (even archived)
func (s *SDK) GetSpacesSpaceIDSocialRegimesAll(ctx context.Context, request operations.GetSpacesSpaceIDSocialRegimesAllRequest) (*operations.GetSpacesSpaceIDSocialRegimesAllResponse, error) {
	baseURL := s._serverURL
	url := utils.GenerateURL(ctx, baseURL, "/spaces/{spaceId}/social-regimes/all", request, nil)

	req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	if err := utils.PopulateQueryParams(ctx, req, request, nil); err != nil {
		return nil, fmt.Errorf("error populating query params: %w", err)
	}

	client := s._securityClient

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.GetSpacesSpaceIDSocialRegimesAllResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out []shared.SocialRegime
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.GetSpacesSpaceIDSocialRegimesAll200ApplicationJSONAllOfs = out
		}
	}

	return res, nil
}

// GetSpacesSpaceIDSpacesInvoicings - Returns CSV Invoicings of the spaces for the account of the spaceId
func (s *SDK) GetSpacesSpaceIDSpacesInvoicings(ctx context.Context, request operations.GetSpacesSpaceIDSpacesInvoicingsRequest) (*operations.GetSpacesSpaceIDSpacesInvoicingsResponse, error) {
	baseURL := s._serverURL
	url := utils.GenerateURL(ctx, baseURL, "/spaces/{spaceId}/spaces-invoicings", request, nil)

	req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	if err := utils.PopulateQueryParams(ctx, req, request, nil); err != nil {
		return nil, fmt.Errorf("error populating query params: %w", err)
	}

	client := s._securityClient

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.GetSpacesSpaceIDSpacesInvoicingsResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out []shared.SpacesInvoicing
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.GetSpacesSpaceIDSpacesInvoicings200ApplicationJSONAllOfs = out
		}
	}

	return res, nil
}

// PatchBusinessGroups - Modifies an object
func (s *SDK) PatchBusinessGroups(ctx context.Context, request operations.PatchBusinessGroupsRequestBody, security operations.PatchBusinessGroupsSecurity) (*operations.PatchBusinessGroupsResponse, error) {
	baseURL := s._serverURL
	url := strings.TrimSuffix(baseURL, "/") + "/business-groups"

	bodyReader, reqContentType, err := utils.SerializeRequestBody(ctx, request, "Request", "json")
	if err != nil {
		return nil, fmt.Errorf("error serializing request body: %w", err)
	}
	if bodyReader == nil {
		return nil, fmt.Errorf("request body is required")
	}

	req, err := http.NewRequestWithContext(ctx, "PATCH", url, bodyReader)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	req.Header.Set("Content-Type", reqContentType)

	client := utils.ConfigureSecurityClient(s._defaultClient, security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.PatchBusinessGroupsResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 204:
	}

	return res, nil
}

// PatchProfileEmail - modify email of profile
func (s *SDK) PatchProfileEmail(ctx context.Context, request operations.PatchProfileEmailRequestBody, security operations.PatchProfileEmailSecurity) (*operations.PatchProfileEmailResponse, error) {
	baseURL := s._serverURL
	url := strings.TrimSuffix(baseURL, "/") + "/profile/email"

	bodyReader, reqContentType, err := utils.SerializeRequestBody(ctx, request, "Request", "json")
	if err != nil {
		return nil, fmt.Errorf("error serializing request body: %w", err)
	}
	if bodyReader == nil {
		return nil, fmt.Errorf("request body is required")
	}

	req, err := http.NewRequestWithContext(ctx, "PATCH", url, bodyReader)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	req.Header.Set("Content-Type", reqContentType)

	client := utils.ConfigureSecurityClient(s._defaultClient, security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.PatchProfileEmailResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 204:
	}

	return res, nil
}

// PatchProfileMobile - modify mobile of profile
func (s *SDK) PatchProfileMobile(ctx context.Context, request operations.PatchProfileMobileRequestBody, security operations.PatchProfileMobileSecurity) (*operations.PatchProfileMobileResponse, error) {
	baseURL := s._serverURL
	url := strings.TrimSuffix(baseURL, "/") + "/profile/mobile"

	bodyReader, reqContentType, err := utils.SerializeRequestBody(ctx, request, "Request", "json")
	if err != nil {
		return nil, fmt.Errorf("error serializing request body: %w", err)
	}
	if bodyReader == nil {
		return nil, fmt.Errorf("request body is required")
	}

	req, err := http.NewRequestWithContext(ctx, "PATCH", url, bodyReader)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	req.Header.Set("Content-Type", reqContentType)

	client := utils.ConfigureSecurityClient(s._defaultClient, security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.PatchProfileMobileResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 204:
	}

	return res, nil
}

// PatchProfileJSON - modify infos of profile
func (s *SDK) PatchProfileJSON(ctx context.Context, request operations.PatchProfileApplicationJSON, security operations.PatchProfileJSONSecurity) (*operations.PatchProfileJSONResponse, error) {
	baseURL := s._serverURL
	url := strings.TrimSuffix(baseURL, "/") + "/profile"

	bodyReader, reqContentType, err := utils.SerializeRequestBody(ctx, request, "Request", "json")
	if err != nil {
		return nil, fmt.Errorf("error serializing request body: %w", err)
	}
	if bodyReader == nil {
		return nil, fmt.Errorf("request body is required")
	}

	req, err := http.NewRequestWithContext(ctx, "PATCH", url, bodyReader)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	req.Header.Set("Content-Type", reqContentType)

	client := utils.ConfigureSecurityClient(s._defaultClient, security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.PatchProfileJSONResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 204:
	}

	return res, nil
}

// PatchProfileMultipart - modify infos of profile
func (s *SDK) PatchProfileMultipart(ctx context.Context, request operations.PatchProfileMultipartFormData1, security operations.PatchProfileMultipartSecurity) (*operations.PatchProfileMultipartResponse, error) {
	baseURL := s._serverURL
	url := strings.TrimSuffix(baseURL, "/") + "/profile"

	bodyReader, reqContentType, err := utils.SerializeRequestBody(ctx, request, "Request", "multipart")
	if err != nil {
		return nil, fmt.Errorf("error serializing request body: %w", err)
	}
	if bodyReader == nil {
		return nil, fmt.Errorf("request body is required")
	}

	req, err := http.NewRequestWithContext(ctx, "PATCH", url, bodyReader)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	req.Header.Set("Content-Type", reqContentType)

	client := utils.ConfigureSecurityClient(s._defaultClient, security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.PatchProfileMultipartResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 204:
	}

	return res, nil
}

// PatchSpacesID - Modify a Space (except private)
func (s *SDK) PatchSpacesID(ctx context.Context, request operations.PatchSpacesIDRequest) (*operations.PatchSpacesIDResponse, error) {
	baseURL := s._serverURL
	url := utils.GenerateURL(ctx, baseURL, "/spaces/{id}", request, nil)

	bodyReader, reqContentType, err := utils.SerializeRequestBody(ctx, request, "RequestBody", "json")
	if err != nil {
		return nil, fmt.Errorf("error serializing request body: %w", err)
	}
	if bodyReader == nil {
		return nil, fmt.Errorf("request body is required")
	}

	req, err := http.NewRequestWithContext(ctx, "PATCH", url, bodyReader)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	req.Header.Set("Content-Type", reqContentType)

	client := s._securityClient

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.PatchSpacesIDResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 204:
	}

	return res, nil
}

// PatchSpacesIDCompanyEntitiesCompanyID - Modify a company entity
func (s *SDK) PatchSpacesIDCompanyEntitiesCompanyID(ctx context.Context, request operations.PatchSpacesIDCompanyEntitiesCompanyIDRequest) (*operations.PatchSpacesIDCompanyEntitiesCompanyIDResponse, error) {
	baseURL := s._serverURL
	url := utils.GenerateURL(ctx, baseURL, "/spaces/{id}/company-entities/{companyId}", request, nil)

	bodyReader, reqContentType, err := utils.SerializeRequestBody(ctx, request, "RequestBody", "json")
	if err != nil {
		return nil, fmt.Errorf("error serializing request body: %w", err)
	}
	if bodyReader == nil {
		return nil, fmt.Errorf("request body is required")
	}

	req, err := http.NewRequestWithContext(ctx, "PATCH", url, bodyReader)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	req.Header.Set("Content-Type", reqContentType)

	client := s._securityClient

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.PatchSpacesIDCompanyEntitiesCompanyIDResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 204:
	}

	return res, nil
}

// PatchSpacesIDFoldersFolderIDPersonsMemberID - Add/Modify/Delete a person in a customer contract (except manager)
func (s *SDK) PatchSpacesIDFoldersFolderIDPersonsMemberID(ctx context.Context, request operations.PatchSpacesIDFoldersFolderIDPersonsMemberIDRequest) (*operations.PatchSpacesIDFoldersFolderIDPersonsMemberIDResponse, error) {
	baseURL := s._serverURL
	url := utils.GenerateURL(ctx, baseURL, "/spaces/{id}/folders/{folderId}/persons/{memberId}", request, nil)

	bodyReader, reqContentType, err := utils.SerializeRequestBody(ctx, request, "RequestBody", "json")
	if err != nil {
		return nil, fmt.Errorf("error serializing request body: %w", err)
	}
	if bodyReader == nil {
		return nil, fmt.Errorf("request body is required")
	}

	req, err := http.NewRequestWithContext(ctx, "PATCH", url, bodyReader)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	req.Header.Set("Content-Type", reqContentType)

	client := s._securityClient

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.PatchSpacesIDFoldersFolderIDPersonsMemberIDResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 204:
	}

	return res, nil
}

// PatchSpacesIDFoldersFolderIDPersonsMemberIDActiveaccess - open an access
func (s *SDK) PatchSpacesIDFoldersFolderIDPersonsMemberIDActiveaccess(ctx context.Context, request operations.PatchSpacesIDFoldersFolderIDPersonsMemberIDActiveaccessRequest) (*operations.PatchSpacesIDFoldersFolderIDPersonsMemberIDActiveaccessResponse, error) {
	baseURL := s._serverURL
	url := utils.GenerateURL(ctx, baseURL, "/spaces/{id}/folders/{folderId}/persons/{memberId}/activeaccess", request, nil)

	req, err := http.NewRequestWithContext(ctx, "PATCH", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	client := s._securityClient

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.PatchSpacesIDFoldersFolderIDPersonsMemberIDActiveaccessResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 204:
	}

	return res, nil
}

// PatchSpacesIDFoldersFolderIDPersonsMemberIDUnactiveaccess - close an access
func (s *SDK) PatchSpacesIDFoldersFolderIDPersonsMemberIDUnactiveaccess(ctx context.Context, request operations.PatchSpacesIDFoldersFolderIDPersonsMemberIDUnactiveaccessRequest) (*operations.PatchSpacesIDFoldersFolderIDPersonsMemberIDUnactiveaccessResponse, error) {
	baseURL := s._serverURL
	url := utils.GenerateURL(ctx, baseURL, "/spaces/{id}/folders/{folderId}/persons/{memberId}/unactiveaccess", request, nil)

	req, err := http.NewRequestWithContext(ctx, "PATCH", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	client := s._securityClient

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.PatchSpacesIDFoldersFolderIDPersonsMemberIDUnactiveaccessResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 204:
	}

	return res, nil
}

// PatchSpacesIDGroupsGroupID - Modify a group
func (s *SDK) PatchSpacesIDGroupsGroupID(ctx context.Context, request operations.PatchSpacesIDGroupsGroupIDRequest) (*operations.PatchSpacesIDGroupsGroupIDResponse, error) {
	baseURL := s._serverURL
	url := utils.GenerateURL(ctx, baseURL, "/spaces/{id}/groups/{groupId}", request, nil)

	bodyReader, reqContentType, err := utils.SerializeRequestBody(ctx, request, "RequestBody", "json")
	if err != nil {
		return nil, fmt.Errorf("error serializing request body: %w", err)
	}
	if bodyReader == nil {
		return nil, fmt.Errorf("request body is required")
	}

	req, err := http.NewRequestWithContext(ctx, "PATCH", url, bodyReader)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	req.Header.Set("Content-Type", reqContentType)

	client := s._securityClient

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.PatchSpacesIDGroupsGroupIDResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 204:
	}

	return res, nil
}

// PatchSpacesIDGroupsGroupIDFoldersFolderID - Add access to a folder for a group
func (s *SDK) PatchSpacesIDGroupsGroupIDFoldersFolderID(ctx context.Context, request operations.PatchSpacesIDGroupsGroupIDFoldersFolderIDRequest) (*operations.PatchSpacesIDGroupsGroupIDFoldersFolderIDResponse, error) {
	baseURL := s._serverURL
	url := utils.GenerateURL(ctx, baseURL, "/spaces/{id}/groups/{groupId}/folders/{folderId}", request, nil)

	bodyReader, reqContentType, err := utils.SerializeRequestBody(ctx, request, "RequestBody", "json")
	if err != nil {
		return nil, fmt.Errorf("error serializing request body: %w", err)
	}
	if bodyReader == nil {
		return nil, fmt.Errorf("request body is required")
	}

	req, err := http.NewRequestWithContext(ctx, "PATCH", url, bodyReader)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	req.Header.Set("Content-Type", reqContentType)

	client := s._securityClient

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.PatchSpacesIDGroupsGroupIDFoldersFolderIDResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 204:
	}

	return res, nil
}

// PatchSpacesIDGroupsGroupIDPersonsMemberID - Add a person to a group
func (s *SDK) PatchSpacesIDGroupsGroupIDPersonsMemberID(ctx context.Context, request operations.PatchSpacesIDGroupsGroupIDPersonsMemberIDRequest) (*operations.PatchSpacesIDGroupsGroupIDPersonsMemberIDResponse, error) {
	baseURL := s._serverURL
	url := utils.GenerateURL(ctx, baseURL, "/spaces/{id}/groups/{groupId}/persons/{memberId}", request, nil)

	req, err := http.NewRequestWithContext(ctx, "PATCH", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	client := s._securityClient

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.PatchSpacesIDGroupsGroupIDPersonsMemberIDResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 204:
	}

	return res, nil
}

// PatchSpacesIDLegal - Modify legal information of a Space (except private)
func (s *SDK) PatchSpacesIDLegal(ctx context.Context, request operations.PatchSpacesIDLegalRequest) (*operations.PatchSpacesIDLegalResponse, error) {
	baseURL := s._serverURL
	url := utils.GenerateURL(ctx, baseURL, "/spaces/{id}/legal", request, nil)

	bodyReader, reqContentType, err := utils.SerializeRequestBody(ctx, request, "Legal", "json")
	if err != nil {
		return nil, fmt.Errorf("error serializing request body: %w", err)
	}
	if bodyReader == nil {
		return nil, fmt.Errorf("request body is required")
	}

	req, err := http.NewRequestWithContext(ctx, "PATCH", url, bodyReader)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	req.Header.Set("Content-Type", reqContentType)

	client := s._securityClient

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.PatchSpacesIDLegalResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 204:
	}

	return res, nil
}

// PatchSpacesIDPersonsMemberIDPlayer - Modify the role of a person
func (s *SDK) PatchSpacesIDPersonsMemberIDPlayer(ctx context.Context, request operations.PatchSpacesIDPersonsMemberIDPlayerRequest) (*operations.PatchSpacesIDPersonsMemberIDPlayerResponse, error) {
	baseURL := s._serverURL
	url := utils.GenerateURL(ctx, baseURL, "/spaces/{id}/persons/{memberId}/player", request, nil)

	bodyReader, reqContentType, err := utils.SerializeRequestBody(ctx, request, "RequestBody", "json")
	if err != nil {
		return nil, fmt.Errorf("error serializing request body: %w", err)
	}
	if bodyReader == nil {
		return nil, fmt.Errorf("request body is required")
	}

	req, err := http.NewRequestWithContext(ctx, "PATCH", url, bodyReader)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	req.Header.Set("Content-Type", reqContentType)

	client := s._securityClient

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.PatchSpacesIDPersonsMemberIDPlayerResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 204:
	}

	return res, nil
}

// PatchSpacesIDPersonsPersonID - Modify a person
func (s *SDK) PatchSpacesIDPersonsPersonID(ctx context.Context, request operations.PatchSpacesIDPersonsPersonIDRequest) (*operations.PatchSpacesIDPersonsPersonIDResponse, error) {
	baseURL := s._serverURL
	url := utils.GenerateURL(ctx, baseURL, "/spaces/{id}/persons/{personId}", request, nil)

	bodyReader, reqContentType, err := utils.SerializeRequestBody(ctx, request, "RequestBody", "json")
	if err != nil {
		return nil, fmt.Errorf("error serializing request body: %w", err)
	}
	if bodyReader == nil {
		return nil, fmt.Errorf("request body is required")
	}

	req, err := http.NewRequestWithContext(ctx, "PATCH", url, bodyReader)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	req.Header.Set("Content-Type", reqContentType)

	client := s._securityClient

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.PatchSpacesIDPersonsPersonIDResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 204:
	}

	return res, nil
}

// PatchSpacesIDPortfoliosPortfolioIDPersonsMemberID - Add/Modify/Delete a person in a portfolio (except manager)
func (s *SDK) PatchSpacesIDPortfoliosPortfolioIDPersonsMemberID(ctx context.Context, request operations.PatchSpacesIDPortfoliosPortfolioIDPersonsMemberIDRequest) (*operations.PatchSpacesIDPortfoliosPortfolioIDPersonsMemberIDResponse, error) {
	baseURL := s._serverURL
	url := utils.GenerateURL(ctx, baseURL, "/spaces/{id}/portfolios/{portfolioId}/persons/{memberId}", request, nil)

	bodyReader, reqContentType, err := utils.SerializeRequestBody(ctx, request, "RequestBody", "json")
	if err != nil {
		return nil, fmt.Errorf("error serializing request body: %w", err)
	}
	if bodyReader == nil {
		return nil, fmt.Errorf("request body is required")
	}

	req, err := http.NewRequestWithContext(ctx, "PATCH", url, bodyReader)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	req.Header.Set("Content-Type", reqContentType)

	client := s._securityClient

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.PatchSpacesIDPortfoliosPortfolioIDPersonsMemberIDResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 204:
	}

	return res, nil
}

// PatchSpacesSpaceIDCommonFoldersID - Modify a common folder
func (s *SDK) PatchSpacesSpaceIDCommonFoldersID(ctx context.Context, request operations.PatchSpacesSpaceIDCommonFoldersIDRequest) (*operations.PatchSpacesSpaceIDCommonFoldersIDResponse, error) {
	baseURL := s._serverURL
	url := utils.GenerateURL(ctx, baseURL, "/spaces/{spaceId}/common-folders/{id}", request, nil)

	bodyReader, reqContentType, err := utils.SerializeRequestBody(ctx, request, "RequestBody", "json")
	if err != nil {
		return nil, fmt.Errorf("error serializing request body: %w", err)
	}
	if bodyReader == nil {
		return nil, fmt.Errorf("request body is required")
	}

	req, err := http.NewRequestWithContext(ctx, "PATCH", url, bodyReader)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	req.Header.Set("Content-Type", reqContentType)

	client := s._securityClient

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.PatchSpacesSpaceIDCommonFoldersIDResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 204:
	}

	return res, nil
}

// PatchSpacesSpaceIDDocumentsDocumentID - modify a doc
func (s *SDK) PatchSpacesSpaceIDDocumentsDocumentID(ctx context.Context, request operations.PatchSpacesSpaceIDDocumentsDocumentIDRequest) (*operations.PatchSpacesSpaceIDDocumentsDocumentIDResponse, error) {
	baseURL := s._serverURL
	url := utils.GenerateURL(ctx, baseURL, "/spaces/{spaceId}/documents/{documentId}", request, nil)

	bodyReader, reqContentType, err := utils.SerializeRequestBody(ctx, request, "RequestBody", "json")
	if err != nil {
		return nil, fmt.Errorf("error serializing request body: %w", err)
	}
	if bodyReader == nil {
		return nil, fmt.Errorf("request body is required")
	}

	req, err := http.NewRequestWithContext(ctx, "PATCH", url, bodyReader)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	req.Header.Set("Content-Type", reqContentType)

	client := s._securityClient

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.PatchSpacesSpaceIDDocumentsDocumentIDResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 204:
	}

	return res, nil
}

// PatchSpacesSpaceIDFoldersFolderIDBankStatementsDocumentID - modify a bank statement
func (s *SDK) PatchSpacesSpaceIDFoldersFolderIDBankStatementsDocumentID(ctx context.Context, request operations.PatchSpacesSpaceIDFoldersFolderIDBankStatementsDocumentIDRequest) (*operations.PatchSpacesSpaceIDFoldersFolderIDBankStatementsDocumentIDResponse, error) {
	baseURL := s._serverURL
	url := utils.GenerateURL(ctx, baseURL, "/spaces/{spaceId}/folders/{folderId}/bank-statements/{documentId}", request, nil)

	bodyReader, reqContentType, err := utils.SerializeRequestBody(ctx, request, "RequestBody", "json")
	if err != nil {
		return nil, fmt.Errorf("error serializing request body: %w", err)
	}

	req, err := http.NewRequestWithContext(ctx, "PATCH", url, bodyReader)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	req.Header.Set("Content-Type", reqContentType)

	client := s._securityClient

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.PatchSpacesSpaceIDFoldersFolderIDBankStatementsDocumentIDResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 204:
	}

	return res, nil
}

// PatchSpacesSpaceIDFoldersFolderIDContractualDocumentsDocumentID - modify a contractual document
func (s *SDK) PatchSpacesSpaceIDFoldersFolderIDContractualDocumentsDocumentID(ctx context.Context, request operations.PatchSpacesSpaceIDFoldersFolderIDContractualDocumentsDocumentIDRequest) (*operations.PatchSpacesSpaceIDFoldersFolderIDContractualDocumentsDocumentIDResponse, error) {
	baseURL := s._serverURL
	url := utils.GenerateURL(ctx, baseURL, "/spaces/{spaceId}/folders/{folderId}/contractual-documents/{documentId}", request, nil)

	bodyReader, reqContentType, err := utils.SerializeRequestBody(ctx, request, "RequestBody", "json")
	if err != nil {
		return nil, fmt.Errorf("error serializing request body: %w", err)
	}

	req, err := http.NewRequestWithContext(ctx, "PATCH", url, bodyReader)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	req.Header.Set("Content-Type", reqContentType)

	client := s._securityClient

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.PatchSpacesSpaceIDFoldersFolderIDContractualDocumentsDocumentIDResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 204:
	}

	return res, nil
}

// PatchSpacesSpaceIDFoldersFolderIDCorporateTaxDeclarationsDocumentID - modify a coporate tax declaration
func (s *SDK) PatchSpacesSpaceIDFoldersFolderIDCorporateTaxDeclarationsDocumentID(ctx context.Context, request operations.PatchSpacesSpaceIDFoldersFolderIDCorporateTaxDeclarationsDocumentIDRequest) (*operations.PatchSpacesSpaceIDFoldersFolderIDCorporateTaxDeclarationsDocumentIDResponse, error) {
	baseURL := s._serverURL
	url := utils.GenerateURL(ctx, baseURL, "/spaces/{spaceId}/folders/{folderId}/corporate-tax-declarations/{documentId}", request, nil)

	bodyReader, reqContentType, err := utils.SerializeRequestBody(ctx, request, "RequestBody", "json")
	if err != nil {
		return nil, fmt.Errorf("error serializing request body: %w", err)
	}

	req, err := http.NewRequestWithContext(ctx, "PATCH", url, bodyReader)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	req.Header.Set("Content-Type", reqContentType)

	client := s._securityClient

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.PatchSpacesSpaceIDFoldersFolderIDCorporateTaxDeclarationsDocumentIDResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 204:
	}

	return res, nil
}

// PatchSpacesSpaceIDFoldersFolderIDExpenseProofsDocumentID - modify an expense report
func (s *SDK) PatchSpacesSpaceIDFoldersFolderIDExpenseProofsDocumentID(ctx context.Context, request operations.PatchSpacesSpaceIDFoldersFolderIDExpenseProofsDocumentIDRequest) (*operations.PatchSpacesSpaceIDFoldersFolderIDExpenseProofsDocumentIDResponse, error) {
	baseURL := s._serverURL
	url := utils.GenerateURL(ctx, baseURL, "/spaces/{spaceId}/folders/{folderId}/expense-proofs/{documentId}", request, nil)

	bodyReader, reqContentType, err := utils.SerializeRequestBody(ctx, request, "RequestBody", "json")
	if err != nil {
		return nil, fmt.Errorf("error serializing request body: %w", err)
	}

	req, err := http.NewRequestWithContext(ctx, "PATCH", url, bodyReader)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	req.Header.Set("Content-Type", reqContentType)

	client := s._securityClient

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.PatchSpacesSpaceIDFoldersFolderIDExpenseProofsDocumentIDResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 204:
	}

	return res, nil
}

// PatchSpacesSpaceIDFoldersFolderIDExpenseReportsDocumentID - modify an expense report
func (s *SDK) PatchSpacesSpaceIDFoldersFolderIDExpenseReportsDocumentID(ctx context.Context, request operations.PatchSpacesSpaceIDFoldersFolderIDExpenseReportsDocumentIDRequest) (*operations.PatchSpacesSpaceIDFoldersFolderIDExpenseReportsDocumentIDResponse, error) {
	baseURL := s._serverURL
	url := utils.GenerateURL(ctx, baseURL, "/spaces/{spaceId}/folders/{folderId}/expense-reports/{documentId}", request, nil)

	bodyReader, reqContentType, err := utils.SerializeRequestBody(ctx, request, "RequestBody", "json")
	if err != nil {
		return nil, fmt.Errorf("error serializing request body: %w", err)
	}

	req, err := http.NewRequestWithContext(ctx, "PATCH", url, bodyReader)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	req.Header.Set("Content-Type", reqContentType)

	client := s._securityClient

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.PatchSpacesSpaceIDFoldersFolderIDExpenseReportsDocumentIDResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 204:
	}

	return res, nil
}

// PatchSpacesSpaceIDFoldersFolderIDInvoicesDocumentID - modify a invoice
func (s *SDK) PatchSpacesSpaceIDFoldersFolderIDInvoicesDocumentID(ctx context.Context, request operations.PatchSpacesSpaceIDFoldersFolderIDInvoicesDocumentIDRequest) (*operations.PatchSpacesSpaceIDFoldersFolderIDInvoicesDocumentIDResponse, error) {
	baseURL := s._serverURL
	url := utils.GenerateURL(ctx, baseURL, "/spaces/{spaceId}/folders/{folderId}/invoices/{documentId}", request, nil)

	bodyReader, reqContentType, err := utils.SerializeRequestBody(ctx, request, "RequestBody", "json")
	if err != nil {
		return nil, fmt.Errorf("error serializing request body: %w", err)
	}

	req, err := http.NewRequestWithContext(ctx, "PATCH", url, bodyReader)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	req.Header.Set("Content-Type", reqContentType)

	client := s._securityClient

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.PatchSpacesSpaceIDFoldersFolderIDInvoicesDocumentIDResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 204:
	}

	return res, nil
}

// PatchSpacesSpaceIDFoldersFolderIDOtherTaxesDocumentID - modify an other tax declaration
func (s *SDK) PatchSpacesSpaceIDFoldersFolderIDOtherTaxesDocumentID(ctx context.Context, request operations.PatchSpacesSpaceIDFoldersFolderIDOtherTaxesDocumentIDRequest) (*operations.PatchSpacesSpaceIDFoldersFolderIDOtherTaxesDocumentIDResponse, error) {
	baseURL := s._serverURL
	url := utils.GenerateURL(ctx, baseURL, "/spaces/{spaceId}/folders/{folderId}/other-taxes/{documentId}", request, nil)

	bodyReader, reqContentType, err := utils.SerializeRequestBody(ctx, request, "RequestBody", "json")
	if err != nil {
		return nil, fmt.Errorf("error serializing request body: %w", err)
	}

	req, err := http.NewRequestWithContext(ctx, "PATCH", url, bodyReader)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	req.Header.Set("Content-Type", reqContentType)

	client := s._securityClient

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.PatchSpacesSpaceIDFoldersFolderIDOtherTaxesDocumentIDResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 204:
	}

	return res, nil
}

// PatchSpacesSpaceIDFoldersFolderIDPayrollsDocumentID - modify a payroll
func (s *SDK) PatchSpacesSpaceIDFoldersFolderIDPayrollsDocumentID(ctx context.Context, request operations.PatchSpacesSpaceIDFoldersFolderIDPayrollsDocumentIDRequest) (*operations.PatchSpacesSpaceIDFoldersFolderIDPayrollsDocumentIDResponse, error) {
	baseURL := s._serverURL
	url := utils.GenerateURL(ctx, baseURL, "/spaces/{spaceId}/folders/{folderId}/payrolls/{documentId}", request, nil)

	bodyReader, reqContentType, err := utils.SerializeRequestBody(ctx, request, "RequestBody", "json")
	if err != nil {
		return nil, fmt.Errorf("error serializing request body: %w", err)
	}

	req, err := http.NewRequestWithContext(ctx, "PATCH", url, bodyReader)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	req.Header.Set("Content-Type", reqContentType)

	client := s._securityClient

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.PatchSpacesSpaceIDFoldersFolderIDPayrollsDocumentIDResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 204:
	}

	return res, nil
}

// PatchSpacesSpaceIDFoldersFolderIDPayslipsDocumentID - modify a payslip
func (s *SDK) PatchSpacesSpaceIDFoldersFolderIDPayslipsDocumentID(ctx context.Context, request operations.PatchSpacesSpaceIDFoldersFolderIDPayslipsDocumentIDRequest) (*operations.PatchSpacesSpaceIDFoldersFolderIDPayslipsDocumentIDResponse, error) {
	baseURL := s._serverURL
	url := utils.GenerateURL(ctx, baseURL, "/spaces/{spaceId}/folders/{folderId}/payslips/{documentId}", request, nil)

	bodyReader, reqContentType, err := utils.SerializeRequestBody(ctx, request, "RequestBody", "json")
	if err != nil {
		return nil, fmt.Errorf("error serializing request body: %w", err)
	}

	req, err := http.NewRequestWithContext(ctx, "PATCH", url, bodyReader)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	req.Header.Set("Content-Type", reqContentType)

	client := s._securityClient

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.PatchSpacesSpaceIDFoldersFolderIDPayslipsDocumentIDResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 204:
	}

	return res, nil
}

// PatchSpacesSpaceIDFoldersFolderIDSocialContractsDocumentID - modify a social contract
func (s *SDK) PatchSpacesSpaceIDFoldersFolderIDSocialContractsDocumentID(ctx context.Context, request operations.PatchSpacesSpaceIDFoldersFolderIDSocialContractsDocumentIDRequest) (*operations.PatchSpacesSpaceIDFoldersFolderIDSocialContractsDocumentIDResponse, error) {
	baseURL := s._serverURL
	url := utils.GenerateURL(ctx, baseURL, "/spaces/{spaceId}/folders/{folderId}/social-contracts/{documentId}", request, nil)

	bodyReader, reqContentType, err := utils.SerializeRequestBody(ctx, request, "RequestBody", "json")
	if err != nil {
		return nil, fmt.Errorf("error serializing request body: %w", err)
	}

	req, err := http.NewRequestWithContext(ctx, "PATCH", url, bodyReader)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	req.Header.Set("Content-Type", reqContentType)

	client := s._securityClient

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.PatchSpacesSpaceIDFoldersFolderIDSocialContractsDocumentIDResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 204:
	}

	return res, nil
}

// PatchSpacesSpaceIDFoldersFolderIDSocialDeclarationsDocumentID - modify a social declaration
func (s *SDK) PatchSpacesSpaceIDFoldersFolderIDSocialDeclarationsDocumentID(ctx context.Context, request operations.PatchSpacesSpaceIDFoldersFolderIDSocialDeclarationsDocumentIDRequest) (*operations.PatchSpacesSpaceIDFoldersFolderIDSocialDeclarationsDocumentIDResponse, error) {
	baseURL := s._serverURL
	url := utils.GenerateURL(ctx, baseURL, "/spaces/{spaceId}/folders/{folderId}/social-declarations/{documentId}", request, nil)

	bodyReader, reqContentType, err := utils.SerializeRequestBody(ctx, request, "RequestBody", "json")
	if err != nil {
		return nil, fmt.Errorf("error serializing request body: %w", err)
	}

	req, err := http.NewRequestWithContext(ctx, "PATCH", url, bodyReader)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	req.Header.Set("Content-Type", reqContentType)

	client := s._securityClient

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.PatchSpacesSpaceIDFoldersFolderIDSocialDeclarationsDocumentIDResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 204:
	}

	return res, nil
}

// PatchSpacesSpaceIDFoldersFolderIDVatDeclarationsDocumentID - modify a vat declaration
func (s *SDK) PatchSpacesSpaceIDFoldersFolderIDVatDeclarationsDocumentID(ctx context.Context, request operations.PatchSpacesSpaceIDFoldersFolderIDVatDeclarationsDocumentIDRequest) (*operations.PatchSpacesSpaceIDFoldersFolderIDVatDeclarationsDocumentIDResponse, error) {
	baseURL := s._serverURL
	url := utils.GenerateURL(ctx, baseURL, "/spaces/{spaceId}/folders/{folderId}/vat-declarations/{documentId}", request, nil)

	bodyReader, reqContentType, err := utils.SerializeRequestBody(ctx, request, "RequestBody", "json")
	if err != nil {
		return nil, fmt.Errorf("error serializing request body: %w", err)
	}

	req, err := http.NewRequestWithContext(ctx, "PATCH", url, bodyReader)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	req.Header.Set("Content-Type", reqContentType)

	client := s._securityClient

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.PatchSpacesSpaceIDFoldersFolderIDVatDeclarationsDocumentIDResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 204:
	}

	return res, nil
}

// PatchSpacesSpaceIDFoldersID - Modify a Folder (except Name, Class, ModificationDate and ArchivalDate)
func (s *SDK) PatchSpacesSpaceIDFoldersID(ctx context.Context, request operations.PatchSpacesSpaceIDFoldersIDRequest) (*operations.PatchSpacesSpaceIDFoldersIDResponse, error) {
	baseURL := s._serverURL
	url := utils.GenerateURL(ctx, baseURL, "/spaces/{spaceId}/folders/{id}", request, nil)

	bodyReader, reqContentType, err := utils.SerializeRequestBody(ctx, request, "RequestBody", "json")
	if err != nil {
		return nil, fmt.Errorf("error serializing request body: %w", err)
	}
	if bodyReader == nil {
		return nil, fmt.Errorf("request body is required")
	}

	req, err := http.NewRequestWithContext(ctx, "PATCH", url, bodyReader)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	req.Header.Set("Content-Type", reqContentType)

	client := s._securityClient

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.PatchSpacesSpaceIDFoldersIDResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 204:
	}

	return res, nil
}

// PatchSpacesSpaceIDFoldersIDAccountingYear - Modify a Folder (except Name, Class, ModificationDate and ArchivalDate) and AccountingYear data
func (s *SDK) PatchSpacesSpaceIDFoldersIDAccountingYear(ctx context.Context, request operations.PatchSpacesSpaceIDFoldersIDAccountingYearRequest) (*operations.PatchSpacesSpaceIDFoldersIDAccountingYearResponse, error) {
	baseURL := s._serverURL
	url := utils.GenerateURL(ctx, baseURL, "/spaces/{spaceId}/folders/{id}/accounting-year", request, nil)

	bodyReader, reqContentType, err := utils.SerializeRequestBody(ctx, request, "RequestBody", "json")
	if err != nil {
		return nil, fmt.Errorf("error serializing request body: %w", err)
	}
	if bodyReader == nil {
		return nil, fmt.Errorf("request body is required")
	}

	req, err := http.NewRequestWithContext(ctx, "PATCH", url, bodyReader)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	req.Header.Set("Content-Type", reqContentType)

	client := s._securityClient

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.PatchSpacesSpaceIDFoldersIDAccountingYearResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 204:
	}

	return res, nil
}

// PatchSpacesSpaceIDFoldersIDBank - Modify a Folder (except Name, Class, ModificationDate and ArchivalDate) and Bank data
func (s *SDK) PatchSpacesSpaceIDFoldersIDBank(ctx context.Context, request operations.PatchSpacesSpaceIDFoldersIDBankRequest) (*operations.PatchSpacesSpaceIDFoldersIDBankResponse, error) {
	baseURL := s._serverURL
	url := utils.GenerateURL(ctx, baseURL, "/spaces/{spaceId}/folders/{id}/bank", request, nil)

	bodyReader, reqContentType, err := utils.SerializeRequestBody(ctx, request, "RequestBody", "json")
	if err != nil {
		return nil, fmt.Errorf("error serializing request body: %w", err)
	}
	if bodyReader == nil {
		return nil, fmt.Errorf("request body is required")
	}

	req, err := http.NewRequestWithContext(ctx, "PATCH", url, bodyReader)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	req.Header.Set("Content-Type", reqContentType)

	client := s._securityClient

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.PatchSpacesSpaceIDFoldersIDBankResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 204:
	}

	return res, nil
}

// PatchSpacesSpaceIDFoldersIDCollectiveDecision - Modify a Folder (except Name, Class, ModificationDate and ArchivalDate) and Collective Decision data
func (s *SDK) PatchSpacesSpaceIDFoldersIDCollectiveDecision(ctx context.Context, request operations.PatchSpacesSpaceIDFoldersIDCollectiveDecisionRequest) (*operations.PatchSpacesSpaceIDFoldersIDCollectiveDecisionResponse, error) {
	baseURL := s._serverURL
	url := utils.GenerateURL(ctx, baseURL, "/spaces/{spaceId}/folders/{id}/collective-decision", request, nil)

	bodyReader, reqContentType, err := utils.SerializeRequestBody(ctx, request, "RequestBody", "json")
	if err != nil {
		return nil, fmt.Errorf("error serializing request body: %w", err)
	}
	if bodyReader == nil {
		return nil, fmt.Errorf("request body is required")
	}

	req, err := http.NewRequestWithContext(ctx, "PATCH", url, bodyReader)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	req.Header.Set("Content-Type", reqContentType)

	client := s._securityClient

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.PatchSpacesSpaceIDFoldersIDCollectiveDecisionResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 204:
	}

	return res, nil
}

// PatchSpacesSpaceIDFoldersIDCustomer - Modify a Folder (except Name, Class, ModificationDate and ArchivalDate) and Customer data
func (s *SDK) PatchSpacesSpaceIDFoldersIDCustomer(ctx context.Context, request operations.PatchSpacesSpaceIDFoldersIDCustomerRequest) (*operations.PatchSpacesSpaceIDFoldersIDCustomerResponse, error) {
	baseURL := s._serverURL
	url := utils.GenerateURL(ctx, baseURL, "/spaces/{spaceId}/folders/{id}/customer", request, nil)

	bodyReader, reqContentType, err := utils.SerializeRequestBody(ctx, request, "RequestBody", "json")
	if err != nil {
		return nil, fmt.Errorf("error serializing request body: %w", err)
	}
	if bodyReader == nil {
		return nil, fmt.Errorf("request body is required")
	}

	req, err := http.NewRequestWithContext(ctx, "PATCH", url, bodyReader)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	req.Header.Set("Content-Type", reqContentType)

	client := s._securityClient

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.PatchSpacesSpaceIDFoldersIDCustomerResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 204:
	}

	return res, nil
}

// PatchSpacesSpaceIDFoldersIDDocumentsDocumentIDDetach - Detach a doc of a folder
func (s *SDK) PatchSpacesSpaceIDFoldersIDDocumentsDocumentIDDetach(ctx context.Context, request operations.PatchSpacesSpaceIDFoldersIDDocumentsDocumentIDDetachRequest) (*operations.PatchSpacesSpaceIDFoldersIDDocumentsDocumentIDDetachResponse, error) {
	baseURL := s._serverURL
	url := utils.GenerateURL(ctx, baseURL, "/spaces/{spaceId}/folders/{id}/documents/{documentId}/detach", request, nil)

	req, err := http.NewRequestWithContext(ctx, "PATCH", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	client := s._securityClient

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.PatchSpacesSpaceIDFoldersIDDocumentsDocumentIDDetachResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 204:
	}

	return res, nil
}

// PatchSpacesSpaceIDFoldersIDEmployee - Modify a Folder (except Name, Class, ModificationDate and ArchivalDate) and Employee data
func (s *SDK) PatchSpacesSpaceIDFoldersIDEmployee(ctx context.Context, request operations.PatchSpacesSpaceIDFoldersIDEmployeeRequest) (*operations.PatchSpacesSpaceIDFoldersIDEmployeeResponse, error) {
	baseURL := s._serverURL
	url := utils.GenerateURL(ctx, baseURL, "/spaces/{spaceId}/folders/{id}/employee", request, nil)

	bodyReader, reqContentType, err := utils.SerializeRequestBody(ctx, request, "RequestBody", "json")
	if err != nil {
		return nil, fmt.Errorf("error serializing request body: %w", err)
	}
	if bodyReader == nil {
		return nil, fmt.Errorf("request body is required")
	}

	req, err := http.NewRequestWithContext(ctx, "PATCH", url, bodyReader)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	req.Header.Set("Content-Type", reqContentType)

	client := s._securityClient

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.PatchSpacesSpaceIDFoldersIDEmployeeResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 204:
	}

	return res, nil
}

// PatchSpacesSpaceIDFoldersIDInsurance - Modify a Folder (except Name, Class, ModificationDate and ArchivalDate) and Insurance data
func (s *SDK) PatchSpacesSpaceIDFoldersIDInsurance(ctx context.Context, request operations.PatchSpacesSpaceIDFoldersIDInsuranceRequest) (*operations.PatchSpacesSpaceIDFoldersIDInsuranceResponse, error) {
	baseURL := s._serverURL
	url := utils.GenerateURL(ctx, baseURL, "/spaces/{spaceId}/folders/{id}/insurance", request, nil)

	bodyReader, reqContentType, err := utils.SerializeRequestBody(ctx, request, "RequestBody", "json")
	if err != nil {
		return nil, fmt.Errorf("error serializing request body: %w", err)
	}
	if bodyReader == nil {
		return nil, fmt.Errorf("request body is required")
	}

	req, err := http.NewRequestWithContext(ctx, "PATCH", url, bodyReader)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	req.Header.Set("Content-Type", reqContentType)

	client := s._securityClient

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.PatchSpacesSpaceIDFoldersIDInsuranceResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 204:
	}

	return res, nil
}

// PatchSpacesSpaceIDFoldersIDLoan - Modify a Folder (except Name, Class, ModificationDate and ArchivalDate) and Loan data
func (s *SDK) PatchSpacesSpaceIDFoldersIDLoan(ctx context.Context, request operations.PatchSpacesSpaceIDFoldersIDLoanRequest) (*operations.PatchSpacesSpaceIDFoldersIDLoanResponse, error) {
	baseURL := s._serverURL
	url := utils.GenerateURL(ctx, baseURL, "/spaces/{spaceId}/folders/{id}/loan", request, nil)

	bodyReader, reqContentType, err := utils.SerializeRequestBody(ctx, request, "RequestBody", "json")
	if err != nil {
		return nil, fmt.Errorf("error serializing request body: %w", err)
	}
	if bodyReader == nil {
		return nil, fmt.Errorf("request body is required")
	}

	req, err := http.NewRequestWithContext(ctx, "PATCH", url, bodyReader)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	req.Header.Set("Content-Type", reqContentType)

	client := s._securityClient

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.PatchSpacesSpaceIDFoldersIDLoanResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 204:
	}

	return res, nil
}

// PatchSpacesSpaceIDFoldersIDMessagesMessageID - Modify a Message
func (s *SDK) PatchSpacesSpaceIDFoldersIDMessagesMessageID(ctx context.Context, request operations.PatchSpacesSpaceIDFoldersIDMessagesMessageIDRequest) (*operations.PatchSpacesSpaceIDFoldersIDMessagesMessageIDResponse, error) {
	baseURL := s._serverURL
	url := utils.GenerateURL(ctx, baseURL, "/spaces/{spaceId}/folders/{id}/messages/{messageId}", request, nil)

	bodyReader, reqContentType, err := utils.SerializeRequestBody(ctx, request, "RequestBody", "json")
	if err != nil {
		return nil, fmt.Errorf("error serializing request body: %w", err)
	}
	if bodyReader == nil {
		return nil, fmt.Errorf("request body is required")
	}

	req, err := http.NewRequestWithContext(ctx, "PATCH", url, bodyReader)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	req.Header.Set("Content-Type", reqContentType)

	client := s._securityClient

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.PatchSpacesSpaceIDFoldersIDMessagesMessageIDResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 204:
	}

	return res, nil
}

// PatchSpacesSpaceIDFoldersIDPasswordsPasswordID - Modify a Password
func (s *SDK) PatchSpacesSpaceIDFoldersIDPasswordsPasswordID(ctx context.Context, request operations.PatchSpacesSpaceIDFoldersIDPasswordsPasswordIDRequest) (*operations.PatchSpacesSpaceIDFoldersIDPasswordsPasswordIDResponse, error) {
	baseURL := s._serverURL
	url := utils.GenerateURL(ctx, baseURL, "/spaces/{spaceId}/folders/{id}/passwords/{passwordId}", request, nil)

	bodyReader, reqContentType, err := utils.SerializeRequestBody(ctx, request, "RequestBody", "json")
	if err != nil {
		return nil, fmt.Errorf("error serializing request body: %w", err)
	}
	if bodyReader == nil {
		return nil, fmt.Errorf("request body is required")
	}

	req, err := http.NewRequestWithContext(ctx, "PATCH", url, bodyReader)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	req.Header.Set("Content-Type", reqContentType)

	client := s._securityClient

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.PatchSpacesSpaceIDFoldersIDPasswordsPasswordIDResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 204:
	}

	return res, nil
}

// PatchSpacesSpaceIDFoldersIDProfessionalVehicle - Modify a Folder (except Name, Class, ModificationDate and ArchivalDate) and Professional Vehicle data
func (s *SDK) PatchSpacesSpaceIDFoldersIDProfessionalVehicle(ctx context.Context, request operations.PatchSpacesSpaceIDFoldersIDProfessionalVehicleRequest) (*operations.PatchSpacesSpaceIDFoldersIDProfessionalVehicleResponse, error) {
	baseURL := s._serverURL
	url := utils.GenerateURL(ctx, baseURL, "/spaces/{spaceId}/folders/{id}/professional-vehicle", request, nil)

	bodyReader, reqContentType, err := utils.SerializeRequestBody(ctx, request, "RequestBody", "json")
	if err != nil {
		return nil, fmt.Errorf("error serializing request body: %w", err)
	}
	if bodyReader == nil {
		return nil, fmt.Errorf("request body is required")
	}

	req, err := http.NewRequestWithContext(ctx, "PATCH", url, bodyReader)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	req.Header.Set("Content-Type", reqContentType)

	client := s._securityClient

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.PatchSpacesSpaceIDFoldersIDProfessionalVehicleResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 204:
	}

	return res, nil
}

// PatchSpacesSpaceIDFoldersIDProvider - Modify a Folder (except Name, Class, ModificationDate and ArchivalDate) and Provider data
func (s *SDK) PatchSpacesSpaceIDFoldersIDProvider(ctx context.Context, request operations.PatchSpacesSpaceIDFoldersIDProviderRequest) (*operations.PatchSpacesSpaceIDFoldersIDProviderResponse, error) {
	baseURL := s._serverURL
	url := utils.GenerateURL(ctx, baseURL, "/spaces/{spaceId}/folders/{id}/provider", request, nil)

	bodyReader, reqContentType, err := utils.SerializeRequestBody(ctx, request, "RequestBody", "json")
	if err != nil {
		return nil, fmt.Errorf("error serializing request body: %w", err)
	}
	if bodyReader == nil {
		return nil, fmt.Errorf("request body is required")
	}

	req, err := http.NewRequestWithContext(ctx, "PATCH", url, bodyReader)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	req.Header.Set("Content-Type", reqContentType)

	client := s._securityClient

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.PatchSpacesSpaceIDFoldersIDProviderResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 204:
	}

	return res, nil
}

// PatchSpacesSpaceIDFoldersIDRequiredDocumentsRequireddocumentid - Modify the status of a requireddocument
func (s *SDK) PatchSpacesSpaceIDFoldersIDRequiredDocumentsRequireddocumentid(ctx context.Context, request operations.PatchSpacesSpaceIDFoldersIDRequiredDocumentsRequireddocumentidRequest) (*operations.PatchSpacesSpaceIDFoldersIDRequiredDocumentsRequireddocumentidResponse, error) {
	baseURL := s._serverURL
	url := utils.GenerateURL(ctx, baseURL, "/spaces/{spaceId}/folders/{id}/required-documents/{requireddocumentid}", request, nil)

	bodyReader, reqContentType, err := utils.SerializeRequestBody(ctx, request, "RequestBody", "json")
	if err != nil {
		return nil, fmt.Errorf("error serializing request body: %w", err)
	}
	if bodyReader == nil {
		return nil, fmt.Errorf("request body is required")
	}

	req, err := http.NewRequestWithContext(ctx, "PATCH", url, bodyReader)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	req.Header.Set("Content-Type", reqContentType)

	client := s._securityClient

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.PatchSpacesSpaceIDFoldersIDRequiredDocumentsRequireddocumentidResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 204:
	}

	return res, nil
}

// PatchSpacesSpaceIDFoldersIDSocialRegimes - Modify a Folder (except Name, Class, ModificationDate and ArchivalDate) and Social Regime data
func (s *SDK) PatchSpacesSpaceIDFoldersIDSocialRegimes(ctx context.Context, request operations.PatchSpacesSpaceIDFoldersIDSocialRegimesRequest) (*operations.PatchSpacesSpaceIDFoldersIDSocialRegimesResponse, error) {
	baseURL := s._serverURL
	url := utils.GenerateURL(ctx, baseURL, "/spaces/{spaceId}/folders/{id}/social-regimes", request, nil)

	bodyReader, reqContentType, err := utils.SerializeRequestBody(ctx, request, "RequestBody", "json")
	if err != nil {
		return nil, fmt.Errorf("error serializing request body: %w", err)
	}
	if bodyReader == nil {
		return nil, fmt.Errorf("request body is required")
	}

	req, err := http.NewRequestWithContext(ctx, "PATCH", url, bodyReader)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	req.Header.Set("Content-Type", reqContentType)

	client := s._securityClient

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.PatchSpacesSpaceIDFoldersIDSocialRegimesResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 204:
	}

	return res, nil
}

// PatchSpacesSpaceIDFoldersIDTaxContract - Modify a Folder (except Name, Class, ModificationDate and ArchivalDate) and Tax Contract data
func (s *SDK) PatchSpacesSpaceIDFoldersIDTaxContract(ctx context.Context, request operations.PatchSpacesSpaceIDFoldersIDTaxContractRequest) (*operations.PatchSpacesSpaceIDFoldersIDTaxContractResponse, error) {
	baseURL := s._serverURL
	url := utils.GenerateURL(ctx, baseURL, "/spaces/{spaceId}/folders/{id}/tax-contract", request, nil)

	bodyReader, reqContentType, err := utils.SerializeRequestBody(ctx, request, "RequestBody", "json")
	if err != nil {
		return nil, fmt.Errorf("error serializing request body: %w", err)
	}
	if bodyReader == nil {
		return nil, fmt.Errorf("request body is required")
	}

	req, err := http.NewRequestWithContext(ctx, "PATCH", url, bodyReader)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	req.Header.Set("Content-Type", reqContentType)

	client := s._securityClient

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.PatchSpacesSpaceIDFoldersIDTaxContractResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 204:
	}

	return res, nil
}

// PatchSpacesSpaceIDPersonsIDCallForDocument - modify the invitation of a person to collect documents
func (s *SDK) PatchSpacesSpaceIDPersonsIDCallForDocument(ctx context.Context, request operations.PatchSpacesSpaceIDPersonsIDCallForDocumentRequest, security operations.PatchSpacesSpaceIDPersonsIDCallForDocumentSecurity) (*operations.PatchSpacesSpaceIDPersonsIDCallForDocumentResponse, error) {
	baseURL := s._serverURL
	url := utils.GenerateURL(ctx, baseURL, "/spaces/{spaceId}/persons/{id}/call-for-document", request, nil)

	bodyReader, reqContentType, err := utils.SerializeRequestBody(ctx, request, "ModifyCollect", "json")
	if err != nil {
		return nil, fmt.Errorf("error serializing request body: %w", err)
	}
	if bodyReader == nil {
		return nil, fmt.Errorf("request body is required")
	}

	req, err := http.NewRequestWithContext(ctx, "PATCH", url, bodyReader)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	req.Header.Set("Content-Type", reqContentType)

	client := utils.ConfigureSecurityClient(s._defaultClient, security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.PatchSpacesSpaceIDPersonsIDCallForDocumentResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 204:
	}

	return res, nil
}

// PatchSpacesSpaceIDPersonsIDGuestInSpace - invite a person in a space
func (s *SDK) PatchSpacesSpaceIDPersonsIDGuestInSpace(ctx context.Context, request operations.PatchSpacesSpaceIDPersonsIDGuestInSpaceRequest, security operations.PatchSpacesSpaceIDPersonsIDGuestInSpaceSecurity) (*operations.PatchSpacesSpaceIDPersonsIDGuestInSpaceResponse, error) {
	baseURL := s._serverURL
	url := utils.GenerateURL(ctx, baseURL, "/spaces/{spaceId}/persons/{id}/guest-in-space", request, nil)

	bodyReader, reqContentType, err := utils.SerializeRequestBody(ctx, request, "ModifyInvitation", "json")
	if err != nil {
		return nil, fmt.Errorf("error serializing request body: %w", err)
	}
	if bodyReader == nil {
		return nil, fmt.Errorf("request body is required")
	}

	req, err := http.NewRequestWithContext(ctx, "PATCH", url, bodyReader)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	req.Header.Set("Content-Type", reqContentType)

	client := utils.ConfigureSecurityClient(s._defaultClient, security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.PatchSpacesSpaceIDPersonsIDGuestInSpaceResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 204:
	}

	return res, nil
}

// PatchSpacesSpaceIDPersonsIDInvitation - modify an invitation
func (s *SDK) PatchSpacesSpaceIDPersonsIDInvitation(ctx context.Context, request operations.PatchSpacesSpaceIDPersonsIDInvitationRequest, security operations.PatchSpacesSpaceIDPersonsIDInvitationSecurity) (*operations.PatchSpacesSpaceIDPersonsIDInvitationResponse, error) {
	baseURL := s._serverURL
	url := utils.GenerateURL(ctx, baseURL, "/spaces/{spaceId}/persons/{id}/invitation", request, nil)

	bodyReader, reqContentType, err := utils.SerializeRequestBody(ctx, request, "RequestBody", "json")
	if err != nil {
		return nil, fmt.Errorf("error serializing request body: %w", err)
	}
	if bodyReader == nil {
		return nil, fmt.Errorf("request body is required")
	}

	req, err := http.NewRequestWithContext(ctx, "PATCH", url, bodyReader)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	req.Header.Set("Content-Type", reqContentType)

	client := utils.ConfigureSecurityClient(s._defaultClient, security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.PatchSpacesSpaceIDPersonsIDInvitationResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 204:
	}

	return res, nil
}

// PatchSpacesSpaceIDPersonsMemberIDFoldersID - Modify an access
func (s *SDK) PatchSpacesSpaceIDPersonsMemberIDFoldersID(ctx context.Context, request operations.PatchSpacesSpaceIDPersonsMemberIDFoldersIDRequest) (*operations.PatchSpacesSpaceIDPersonsMemberIDFoldersIDResponse, error) {
	baseURL := s._serverURL
	url := utils.GenerateURL(ctx, baseURL, "/spaces/{spaceId}/persons/{memberId}/folders/{id}", request, nil)

	bodyReader, reqContentType, err := utils.SerializeRequestBody(ctx, request, "RequestBody", "json")
	if err != nil {
		return nil, fmt.Errorf("error serializing request body: %w", err)
	}
	if bodyReader == nil {
		return nil, fmt.Errorf("request body is required")
	}

	req, err := http.NewRequestWithContext(ctx, "PATCH", url, bodyReader)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	req.Header.Set("Content-Type", reqContentType)

	client := s._securityClient

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.PatchSpacesSpaceIDPersonsMemberIDFoldersIDResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 204:
	}

	return res, nil
}

// PostBusinessGroups - Adds a group (only for managers and ADN collaborators)
func (s *SDK) PostBusinessGroups(ctx context.Context, request operations.PostBusinessGroupsRequestBody, security operations.PostBusinessGroupsSecurity) (*operations.PostBusinessGroupsResponse, error) {
	baseURL := s._serverURL
	url := strings.TrimSuffix(baseURL, "/") + "/business-groups"

	bodyReader, reqContentType, err := utils.SerializeRequestBody(ctx, request, "Request", "json")
	if err != nil {
		return nil, fmt.Errorf("error serializing request body: %w", err)
	}
	if bodyReader == nil {
		return nil, fmt.Errorf("request body is required")
	}

	req, err := http.NewRequestWithContext(ctx, "POST", url, bodyReader)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	req.Header.Set("Content-Type", reqContentType)

	client := utils.ConfigureSecurityClient(s._defaultClient, security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.PostBusinessGroupsResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 201:
		res.Headers = httpRes.Header

		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *operations.PostBusinessGroups201ApplicationJSON
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.PostBusinessGroups201ApplicationJSONObject = out
		}
	}

	return res, nil
}

// PostBusinessGroupsIDSpacesSpaceIDLegalEntitiesPersonIDCustomersFolderIDGuestInSpace - send an invitation to manager the private space of personId
func (s *SDK) PostBusinessGroupsIDSpacesSpaceIDLegalEntitiesPersonIDCustomersFolderIDGuestInSpace(ctx context.Context, request operations.PostBusinessGroupsIDSpacesSpaceIDLegalEntitiesPersonIDCustomersFolderIDGuestInSpaceRequest, security operations.PostBusinessGroupsIDSpacesSpaceIDLegalEntitiesPersonIDCustomersFolderIDGuestInSpaceSecurity) (*operations.PostBusinessGroupsIDSpacesSpaceIDLegalEntitiesPersonIDCustomersFolderIDGuestInSpaceResponse, error) {
	baseURL := s._serverURL
	url := utils.GenerateURL(ctx, baseURL, "/business-groups/{id}/spaces/{spaceId}/legal-entities/{personId}/customers/{folderId}/guest-in-space", request, nil)

	bodyReader, reqContentType, err := utils.SerializeRequestBody(ctx, request, "RequestBody", "json")
	if err != nil {
		return nil, fmt.Errorf("error serializing request body: %w", err)
	}
	if bodyReader == nil {
		return nil, fmt.Errorf("request body is required")
	}

	req, err := http.NewRequestWithContext(ctx, "POST", url, bodyReader)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	req.Header.Set("Content-Type", reqContentType)

	client := utils.ConfigureSecurityClient(s._defaultClient, security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.PostBusinessGroupsIDSpacesSpaceIDLegalEntitiesPersonIDCustomersFolderIDGuestInSpaceResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 201:
		res.Headers = httpRes.Header

		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *operations.PostBusinessGroupsIDSpacesSpaceIDLegalEntitiesPersonIDCustomersFolderIDGuestInSpace201ApplicationJSON
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.PostBusinessGroupsIDSpacesSpaceIDLegalEntitiesPersonIDCustomersFolderIDGuestInSpace201ApplicationJSONObject = out
		}
	}

	return res, nil
}

// PostBusinessGroupsIDSpacesSpaceIDLegalEntitiesPersonIDCustomersFolderIDSpaces - Add a Space in a group
func (s *SDK) PostBusinessGroupsIDSpacesSpaceIDLegalEntitiesPersonIDCustomersFolderIDSpaces(ctx context.Context, request operations.PostBusinessGroupsIDSpacesSpaceIDLegalEntitiesPersonIDCustomersFolderIDSpacesRequest, security operations.PostBusinessGroupsIDSpacesSpaceIDLegalEntitiesPersonIDCustomersFolderIDSpacesSecurity) (*operations.PostBusinessGroupsIDSpacesSpaceIDLegalEntitiesPersonIDCustomersFolderIDSpacesResponse, error) {
	baseURL := s._serverURL
	url := utils.GenerateURL(ctx, baseURL, "/business-groups/{id}/spaces/{spaceId}/legal-entities/{personId}/customers/{folderId}/spaces", request, nil)

	bodyReader, reqContentType, err := utils.SerializeRequestBody(ctx, request, "RequestBody", "json")
	if err != nil {
		return nil, fmt.Errorf("error serializing request body: %w", err)
	}
	if bodyReader == nil {
		return nil, fmt.Errorf("request body is required")
	}

	req, err := http.NewRequestWithContext(ctx, "POST", url, bodyReader)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	req.Header.Set("Content-Type", reqContentType)

	client := utils.ConfigureSecurityClient(s._defaultClient, security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.PostBusinessGroupsIDSpacesSpaceIDLegalEntitiesPersonIDCustomersFolderIDSpacesResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 201:
		res.Headers = httpRes.Header

		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *operations.PostBusinessGroupsIDSpacesSpaceIDLegalEntitiesPersonIDCustomersFolderIDSpaces201ApplicationJSON
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.PostBusinessGroupsIDSpacesSpaceIDLegalEntitiesPersonIDCustomersFolderIDSpaces201ApplicationJSONObject = out
		}
	}

	return res, nil
}

// PostHubDocumentsJSON - Add a document (this document is analyzed to be saved in the correct folder and correct space)
func (s *SDK) PostHubDocumentsJSON(ctx context.Context, request operations.PostHubDocumentsApplicationJSON, security operations.PostHubDocumentsJSONSecurity) (*operations.PostHubDocumentsJSONResponse, error) {
	baseURL := s._serverURL
	url := strings.TrimSuffix(baseURL, "/") + "/hub/documents"

	bodyReader, reqContentType, err := utils.SerializeRequestBody(ctx, request, "Request", "json")
	if err != nil {
		return nil, fmt.Errorf("error serializing request body: %w", err)
	}
	if bodyReader == nil {
		return nil, fmt.Errorf("request body is required")
	}

	req, err := http.NewRequestWithContext(ctx, "POST", url, bodyReader)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	req.Header.Set("Content-Type", reqContentType)

	client := utils.ConfigureSecurityClient(s._defaultClient, security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.PostHubDocumentsJSONResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 201:
		res.Headers = httpRes.Header

		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *operations.PostHubDocumentsJSON201ApplicationJSON
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.PostHubDocumentsJSON201ApplicationJSONObject = out
		}
	}

	return res, nil
}

// PostHubDocumentsMultipart - Add a document (this document is analyzed to be saved in the correct folder and correct space)
func (s *SDK) PostHubDocumentsMultipart(ctx context.Context, request operations.PostHubDocumentsMultipartFormData1, security operations.PostHubDocumentsMultipartSecurity) (*operations.PostHubDocumentsMultipartResponse, error) {
	baseURL := s._serverURL
	url := strings.TrimSuffix(baseURL, "/") + "/hub/documents"

	bodyReader, reqContentType, err := utils.SerializeRequestBody(ctx, request, "Request", "multipart")
	if err != nil {
		return nil, fmt.Errorf("error serializing request body: %w", err)
	}
	if bodyReader == nil {
		return nil, fmt.Errorf("request body is required")
	}

	req, err := http.NewRequestWithContext(ctx, "POST", url, bodyReader)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	req.Header.Set("Content-Type", reqContentType)

	client := utils.ConfigureSecurityClient(s._defaultClient, security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.PostHubDocumentsMultipartResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 201:
		res.Headers = httpRes.Header

		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *operations.PostHubDocumentsMultipart201ApplicationJSON
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.PostHubDocumentsMultipart201ApplicationJSONObject = out
		}
	}

	return res, nil
}

// PostHubPayslipsJSON - Add a payslip (this document is analyzed to be saved in the correct folder and correct space)
func (s *SDK) PostHubPayslipsJSON(ctx context.Context, request operations.PostHubPayslipsApplicationJSON, security operations.PostHubPayslipsJSONSecurity) (*operations.PostHubPayslipsJSONResponse, error) {
	baseURL := s._serverURL
	url := strings.TrimSuffix(baseURL, "/") + "/hub/payslips"

	bodyReader, reqContentType, err := utils.SerializeRequestBody(ctx, request, "Request", "json")
	if err != nil {
		return nil, fmt.Errorf("error serializing request body: %w", err)
	}
	if bodyReader == nil {
		return nil, fmt.Errorf("request body is required")
	}

	req, err := http.NewRequestWithContext(ctx, "POST", url, bodyReader)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	req.Header.Set("Content-Type", reqContentType)

	client := utils.ConfigureSecurityClient(s._defaultClient, security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.PostHubPayslipsJSONResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 201:
		res.Headers = httpRes.Header

		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *operations.PostHubPayslipsJSON201ApplicationJSON
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.PostHubPayslipsJSON201ApplicationJSONObject = out
		}
	}

	return res, nil
}

// PostHubPayslipsMultipart - Add a payslip (this document is analyzed to be saved in the correct folder and correct space)
func (s *SDK) PostHubPayslipsMultipart(ctx context.Context, request operations.PostHubPayslipsMultipartFormData1, security operations.PostHubPayslipsMultipartSecurity) (*operations.PostHubPayslipsMultipartResponse, error) {
	baseURL := s._serverURL
	url := strings.TrimSuffix(baseURL, "/") + "/hub/payslips"

	bodyReader, reqContentType, err := utils.SerializeRequestBody(ctx, request, "Request", "multipart")
	if err != nil {
		return nil, fmt.Errorf("error serializing request body: %w", err)
	}
	if bodyReader == nil {
		return nil, fmt.Errorf("request body is required")
	}

	req, err := http.NewRequestWithContext(ctx, "POST", url, bodyReader)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	req.Header.Set("Content-Type", reqContentType)

	client := utils.ConfigureSecurityClient(s._defaultClient, security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.PostHubPayslipsMultipartResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 201:
		res.Headers = httpRes.Header

		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *operations.PostHubPayslipsMultipart201ApplicationJSON
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.PostHubPayslipsMultipart201ApplicationJSONObject = out
		}
	}

	return res, nil
}

// PostHubSpacesSpaceIDDocumentsJSON - Add a document in a space (this document is analyzed to be saved in the correct folder)
func (s *SDK) PostHubSpacesSpaceIDDocumentsJSON(ctx context.Context, request operations.PostHubSpacesSpaceIDDocumentsJSONRequest, security operations.PostHubSpacesSpaceIDDocumentsJSONSecurity) (*operations.PostHubSpacesSpaceIDDocumentsJSONResponse, error) {
	baseURL := s._serverURL
	url := utils.GenerateURL(ctx, baseURL, "/hub/spaces/{spaceId}/documents", request, nil)

	bodyReader, reqContentType, err := utils.SerializeRequestBody(ctx, request, "RequestBody", "json")
	if err != nil {
		return nil, fmt.Errorf("error serializing request body: %w", err)
	}
	if bodyReader == nil {
		return nil, fmt.Errorf("request body is required")
	}

	req, err := http.NewRequestWithContext(ctx, "POST", url, bodyReader)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	req.Header.Set("Content-Type", reqContentType)

	client := utils.ConfigureSecurityClient(s._defaultClient, security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.PostHubSpacesSpaceIDDocumentsJSONResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 201:
		res.Headers = httpRes.Header

		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *operations.PostHubSpacesSpaceIDDocumentsJSON201ApplicationJSON
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.PostHubSpacesSpaceIDDocumentsJSON201ApplicationJSONObject = out
		}
	}

	return res, nil
}

// PostHubSpacesSpaceIDDocumentsMultipart - Add a document in a space (this document is analyzed to be saved in the correct folder)
func (s *SDK) PostHubSpacesSpaceIDDocumentsMultipart(ctx context.Context, request operations.PostHubSpacesSpaceIDDocumentsMultipartRequest, security operations.PostHubSpacesSpaceIDDocumentsMultipartSecurity) (*operations.PostHubSpacesSpaceIDDocumentsMultipartResponse, error) {
	baseURL := s._serverURL
	url := utils.GenerateURL(ctx, baseURL, "/hub/spaces/{spaceId}/documents", request, nil)

	bodyReader, reqContentType, err := utils.SerializeRequestBody(ctx, request, "RequestBody", "multipart")
	if err != nil {
		return nil, fmt.Errorf("error serializing request body: %w", err)
	}
	if bodyReader == nil {
		return nil, fmt.Errorf("request body is required")
	}

	req, err := http.NewRequestWithContext(ctx, "POST", url, bodyReader)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	req.Header.Set("Content-Type", reqContentType)

	client := utils.ConfigureSecurityClient(s._defaultClient, security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.PostHubSpacesSpaceIDDocumentsMultipartResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 201:
		res.Headers = httpRes.Header

		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *operations.PostHubSpacesSpaceIDDocumentsMultipart201ApplicationJSON
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.PostHubSpacesSpaceIDDocumentsMultipart201ApplicationJSONObject = out
		}
	}

	return res, nil
}

// PostHubSpacesSpaceIDPayslipsJSON - Add a payslip in a space (this document is analyzed to be saved in the correct folder)
func (s *SDK) PostHubSpacesSpaceIDPayslipsJSON(ctx context.Context, request operations.PostHubSpacesSpaceIDPayslipsJSONRequest, security operations.PostHubSpacesSpaceIDPayslipsJSONSecurity) (*operations.PostHubSpacesSpaceIDPayslipsJSONResponse, error) {
	baseURL := s._serverURL
	url := utils.GenerateURL(ctx, baseURL, "/hub/spaces/{spaceId}/payslips", request, nil)

	bodyReader, reqContentType, err := utils.SerializeRequestBody(ctx, request, "RequestBody", "json")
	if err != nil {
		return nil, fmt.Errorf("error serializing request body: %w", err)
	}
	if bodyReader == nil {
		return nil, fmt.Errorf("request body is required")
	}

	req, err := http.NewRequestWithContext(ctx, "POST", url, bodyReader)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	req.Header.Set("Content-Type", reqContentType)

	client := utils.ConfigureSecurityClient(s._defaultClient, security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.PostHubSpacesSpaceIDPayslipsJSONResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 201:
		res.Headers = httpRes.Header

		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *operations.PostHubSpacesSpaceIDPayslipsJSON201ApplicationJSON
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.PostHubSpacesSpaceIDPayslipsJSON201ApplicationJSONObject = out
		}
	}

	return res, nil
}

// PostHubSpacesSpaceIDPayslipsMultipart - Add a payslip in a space (this document is analyzed to be saved in the correct folder)
func (s *SDK) PostHubSpacesSpaceIDPayslipsMultipart(ctx context.Context, request operations.PostHubSpacesSpaceIDPayslipsMultipartRequest, security operations.PostHubSpacesSpaceIDPayslipsMultipartSecurity) (*operations.PostHubSpacesSpaceIDPayslipsMultipartResponse, error) {
	baseURL := s._serverURL
	url := utils.GenerateURL(ctx, baseURL, "/hub/spaces/{spaceId}/payslips", request, nil)

	bodyReader, reqContentType, err := utils.SerializeRequestBody(ctx, request, "RequestBody", "multipart")
	if err != nil {
		return nil, fmt.Errorf("error serializing request body: %w", err)
	}
	if bodyReader == nil {
		return nil, fmt.Errorf("request body is required")
	}

	req, err := http.NewRequestWithContext(ctx, "POST", url, bodyReader)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	req.Header.Set("Content-Type", reqContentType)

	client := utils.ConfigureSecurityClient(s._defaultClient, security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.PostHubSpacesSpaceIDPayslipsMultipartResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 201:
		res.Headers = httpRes.Header

		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *operations.PostHubSpacesSpaceIDPayslipsMultipart201ApplicationJSON
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.PostHubSpacesSpaceIDPayslipsMultipart201ApplicationJSONObject = out
		}
	}

	return res, nil
}

// PostMenusMenuIDDocumentsJSON - add a document to the target menuId
func (s *SDK) PostMenusMenuIDDocumentsJSON(ctx context.Context, request operations.PostMenusMenuIDDocumentsJSONRequest, security operations.PostMenusMenuIDDocumentsJSONSecurity) (*operations.PostMenusMenuIDDocumentsJSONResponse, error) {
	baseURL := s._serverURL
	url := utils.GenerateURL(ctx, baseURL, "/menus/{menuId}/documents", request, nil)

	bodyReader, reqContentType, err := utils.SerializeRequestBody(ctx, request, "RequestBody", "json")
	if err != nil {
		return nil, fmt.Errorf("error serializing request body: %w", err)
	}
	if bodyReader == nil {
		return nil, fmt.Errorf("request body is required")
	}

	req, err := http.NewRequestWithContext(ctx, "POST", url, bodyReader)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	req.Header.Set("Content-Type", reqContentType)

	client := utils.ConfigureSecurityClient(s._defaultClient, security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.PostMenusMenuIDDocumentsJSONResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 201:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *operations.PostMenusMenuIDDocumentsJSON201ApplicationJSON
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.PostMenusMenuIDDocumentsJSON201ApplicationJSONObject = out
		}
	}

	return res, nil
}

// PostMenusMenuIDDocumentsMultipart - add a document to the target menuId
func (s *SDK) PostMenusMenuIDDocumentsMultipart(ctx context.Context, request operations.PostMenusMenuIDDocumentsMultipartRequest, security operations.PostMenusMenuIDDocumentsMultipartSecurity) (*operations.PostMenusMenuIDDocumentsMultipartResponse, error) {
	baseURL := s._serverURL
	url := utils.GenerateURL(ctx, baseURL, "/menus/{menuId}/documents", request, nil)

	bodyReader, reqContentType, err := utils.SerializeRequestBody(ctx, request, "RequestBody", "multipart")
	if err != nil {
		return nil, fmt.Errorf("error serializing request body: %w", err)
	}
	if bodyReader == nil {
		return nil, fmt.Errorf("request body is required")
	}

	req, err := http.NewRequestWithContext(ctx, "POST", url, bodyReader)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	req.Header.Set("Content-Type", reqContentType)

	client := utils.ConfigureSecurityClient(s._defaultClient, security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.PostMenusMenuIDDocumentsMultipartResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 201:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *operations.PostMenusMenuIDDocumentsMultipart201ApplicationJSON
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.PostMenusMenuIDDocumentsMultipart201ApplicationJSONObject = out
		}
	}

	return res, nil
}

// PostProfileJSON - create infos of profile
func (s *SDK) PostProfileJSON(ctx context.Context, request operations.PostProfileApplicationJSON, security operations.PostProfileJSONSecurity) (*operations.PostProfileJSONResponse, error) {
	baseURL := s._serverURL
	url := strings.TrimSuffix(baseURL, "/") + "/profile"

	bodyReader, reqContentType, err := utils.SerializeRequestBody(ctx, request, "Request", "json")
	if err != nil {
		return nil, fmt.Errorf("error serializing request body: %w", err)
	}
	if bodyReader == nil {
		return nil, fmt.Errorf("request body is required")
	}

	req, err := http.NewRequestWithContext(ctx, "POST", url, bodyReader)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	req.Header.Set("Content-Type", reqContentType)

	client := utils.ConfigureSecurityClient(s._defaultClient, security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.PostProfileJSONResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 204:
	}

	return res, nil
}

// PostProfileMultipart - create infos of profile
func (s *SDK) PostProfileMultipart(ctx context.Context, request operations.PostProfileMultipartFormData1, security operations.PostProfileMultipartSecurity) (*operations.PostProfileMultipartResponse, error) {
	baseURL := s._serverURL
	url := strings.TrimSuffix(baseURL, "/") + "/profile"

	bodyReader, reqContentType, err := utils.SerializeRequestBody(ctx, request, "Request", "multipart")
	if err != nil {
		return nil, fmt.Errorf("error serializing request body: %w", err)
	}
	if bodyReader == nil {
		return nil, fmt.Errorf("request body is required")
	}

	req, err := http.NewRequestWithContext(ctx, "POST", url, bodyReader)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	req.Header.Set("Content-Type", reqContentType)

	client := utils.ConfigureSecurityClient(s._defaultClient, security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.PostProfileMultipartResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 204:
	}

	return res, nil
}

// PostRegistration - complete the invitation
func (s *SDK) PostRegistration(ctx context.Context, request operations.PostRegistrationRequestBody, security operations.PostRegistrationSecurity) (*operations.PostRegistrationResponse, error) {
	baseURL := s._serverURL
	url := strings.TrimSuffix(baseURL, "/") + "/registration"

	bodyReader, reqContentType, err := utils.SerializeRequestBody(ctx, request, "Request", "json")
	if err != nil {
		return nil, fmt.Errorf("error serializing request body: %w", err)
	}
	if bodyReader == nil {
		return nil, fmt.Errorf("request body is required")
	}

	req, err := http.NewRequestWithContext(ctx, "POST", url, bodyReader)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	req.Header.Set("Content-Type", reqContentType)

	client := utils.ConfigureSecurityClient(s._defaultClient, security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.PostRegistrationResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 201:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *operations.PostRegistration201ApplicationJSON
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.PostRegistration201ApplicationJSONObject = out
		}
	}

	return res, nil
}

// PostSpaces - Add a Space in my group
func (s *SDK) PostSpaces(ctx context.Context, request operations.PostSpacesRequestBody, security operations.PostSpacesSecurity) (*operations.PostSpacesResponse, error) {
	baseURL := s._serverURL
	url := strings.TrimSuffix(baseURL, "/") + "/spaces"

	bodyReader, reqContentType, err := utils.SerializeRequestBody(ctx, request, "Request", "json")
	if err != nil {
		return nil, fmt.Errorf("error serializing request body: %w", err)
	}
	if bodyReader == nil {
		return nil, fmt.Errorf("request body is required")
	}

	req, err := http.NewRequestWithContext(ctx, "POST", url, bodyReader)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	req.Header.Set("Content-Type", reqContentType)

	client := utils.ConfigureSecurityClient(s._defaultClient, security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.PostSpacesResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 201:
		res.Headers = httpRes.Header

		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *operations.PostSpaces201ApplicationJSON
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.PostSpaces201ApplicationJSONObject = out
		}
	}

	return res, nil
}

// PostSpacesIDAccountingYear - Create a accounting year for the space id
func (s *SDK) PostSpacesIDAccountingYear(ctx context.Context, request operations.PostSpacesIDAccountingYearRequest, security operations.PostSpacesIDAccountingYearSecurity) (*operations.PostSpacesIDAccountingYearResponse, error) {
	baseURL := s._serverURL
	url := utils.GenerateURL(ctx, baseURL, "/spaces/{id}/accounting-year", request, nil)

	bodyReader, reqContentType, err := utils.SerializeRequestBody(ctx, request, "RequestBody", "json")
	if err != nil {
		return nil, fmt.Errorf("error serializing request body: %w", err)
	}
	if bodyReader == nil {
		return nil, fmt.Errorf("request body is required")
	}

	req, err := http.NewRequestWithContext(ctx, "POST", url, bodyReader)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	req.Header.Set("Content-Type", reqContentType)

	client := utils.ConfigureSecurityClient(s._defaultClient, security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.PostSpacesIDAccountingYearResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 201:
		res.Headers = httpRes.Header

		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *operations.PostSpacesIDAccountingYear201ApplicationJSON
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.PostSpacesIDAccountingYear201ApplicationJSONObject = out
		}
	}

	return res, nil
}

// PostSpacesIDCollectiveDecision - Create a colletive decision for the space id
func (s *SDK) PostSpacesIDCollectiveDecision(ctx context.Context, request operations.PostSpacesIDCollectiveDecisionRequest, security operations.PostSpacesIDCollectiveDecisionSecurity) (*operations.PostSpacesIDCollectiveDecisionResponse, error) {
	baseURL := s._serverURL
	url := utils.GenerateURL(ctx, baseURL, "/spaces/{id}/collective-decision", request, nil)

	bodyReader, reqContentType, err := utils.SerializeRequestBody(ctx, request, "RequestBody", "json")
	if err != nil {
		return nil, fmt.Errorf("error serializing request body: %w", err)
	}
	if bodyReader == nil {
		return nil, fmt.Errorf("request body is required")
	}

	req, err := http.NewRequestWithContext(ctx, "POST", url, bodyReader)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	req.Header.Set("Content-Type", reqContentType)

	client := utils.ConfigureSecurityClient(s._defaultClient, security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.PostSpacesIDCollectiveDecisionResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 201:
		res.Headers = httpRes.Header

		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *operations.PostSpacesIDCollectiveDecision201ApplicationJSON
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.PostSpacesIDCollectiveDecision201ApplicationJSONObject = out
		}
	}

	return res, nil
}

// PostSpacesIDCompanyEntities - Add a Company Entity in a Space
func (s *SDK) PostSpacesIDCompanyEntities(ctx context.Context, request operations.PostSpacesIDCompanyEntitiesRequest, security operations.PostSpacesIDCompanyEntitiesSecurity) (*operations.PostSpacesIDCompanyEntitiesResponse, error) {
	baseURL := s._serverURL
	url := utils.GenerateURL(ctx, baseURL, "/spaces/{id}/company-entities", request, nil)

	bodyReader, reqContentType, err := utils.SerializeRequestBody(ctx, request, "RequestBody", "json")
	if err != nil {
		return nil, fmt.Errorf("error serializing request body: %w", err)
	}
	if bodyReader == nil {
		return nil, fmt.Errorf("request body is required")
	}

	req, err := http.NewRequestWithContext(ctx, "POST", url, bodyReader)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	req.Header.Set("Content-Type", reqContentType)

	client := utils.ConfigureSecurityClient(s._defaultClient, security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.PostSpacesIDCompanyEntitiesResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 201:
		res.Headers = httpRes.Header

		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *operations.PostSpacesIDCompanyEntities201ApplicationJSON
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.PostSpacesIDCompanyEntities201ApplicationJSONObject = out
		}
	}

	return res, nil
}

// PostSpacesIDCompanyEntitiesPersonIDDetails - Replace or Add a contact detail for a person
func (s *SDK) PostSpacesIDCompanyEntitiesPersonIDDetails(ctx context.Context, request operations.PostSpacesIDCompanyEntitiesPersonIDDetailsRequest) (*operations.PostSpacesIDCompanyEntitiesPersonIDDetailsResponse, error) {
	baseURL := s._serverURL
	url := utils.GenerateURL(ctx, baseURL, "/spaces/{id}/company-entities/{personId}/details", request, nil)

	bodyReader, reqContentType, err := utils.SerializeRequestBody(ctx, request, "RequestBody", "json")
	if err != nil {
		return nil, fmt.Errorf("error serializing request body: %w", err)
	}
	if bodyReader == nil {
		return nil, fmt.Errorf("request body is required")
	}

	req, err := http.NewRequestWithContext(ctx, "POST", url, bodyReader)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	req.Header.Set("Content-Type", reqContentType)

	client := s._securityClient

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.PostSpacesIDCompanyEntitiesPersonIDDetailsResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 204:
	}

	return res, nil
}

// PostSpacesIDDocumentsDownload - create an archive with documents
func (s *SDK) PostSpacesIDDocumentsDownload(ctx context.Context, request operations.PostSpacesIDDocumentsDownloadRequest, security operations.PostSpacesIDDocumentsDownloadSecurity) (*operations.PostSpacesIDDocumentsDownloadResponse, error) {
	baseURL := s._serverURL
	url := utils.GenerateURL(ctx, baseURL, "/spaces/{id}/documents/download", request, nil)

	bodyReader, reqContentType, err := utils.SerializeRequestBody(ctx, request, "RequestBody", "json")
	if err != nil {
		return nil, fmt.Errorf("error serializing request body: %w", err)
	}
	if bodyReader == nil {
		return nil, fmt.Errorf("request body is required")
	}

	req, err := http.NewRequestWithContext(ctx, "POST", url, bodyReader)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	req.Header.Set("Content-Type", reqContentType)

	client := utils.ConfigureSecurityClient(s._defaultClient, security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.PostSpacesIDDocumentsDownloadResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 201:
		res.Headers = httpRes.Header

		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *operations.PostSpacesIDDocumentsDownload201ApplicationJSON
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.PostSpacesIDDocumentsDownload201ApplicationJSONObject = out
		case utils.MatchContentType(contentType, `multipart/form-data`):
			out, err := io.ReadAll(httpRes.Body)
			if err != nil {
				return nil, fmt.Errorf("error reading response body: %w", err)
			}

			res.Body = out
		}
	}

	return res, nil
}

// PostSpacesIDFoldersFolderIDPersonsPersonIDGuestInSpace - invite a owner in a space
func (s *SDK) PostSpacesIDFoldersFolderIDPersonsPersonIDGuestInSpace(ctx context.Context, request operations.PostSpacesIDFoldersFolderIDPersonsPersonIDGuestInSpaceRequest, security operations.PostSpacesIDFoldersFolderIDPersonsPersonIDGuestInSpaceSecurity) (*operations.PostSpacesIDFoldersFolderIDPersonsPersonIDGuestInSpaceResponse, error) {
	baseURL := s._serverURL
	url := utils.GenerateURL(ctx, baseURL, "/spaces/{id}/folders/{folderId}/persons/{personId}/guest-in-space", request, nil)

	bodyReader, reqContentType, err := utils.SerializeRequestBody(ctx, request, "InvitationPerson", "json")
	if err != nil {
		return nil, fmt.Errorf("error serializing request body: %w", err)
	}
	if bodyReader == nil {
		return nil, fmt.Errorf("request body is required")
	}

	req, err := http.NewRequestWithContext(ctx, "POST", url, bodyReader)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	req.Header.Set("Content-Type", reqContentType)

	client := utils.ConfigureSecurityClient(s._defaultClient, security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.PostSpacesIDFoldersFolderIDPersonsPersonIDGuestInSpaceResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 204:
	}

	return res, nil
}

// PostSpacesIDGroups - Add a group in a Space
func (s *SDK) PostSpacesIDGroups(ctx context.Context, request operations.PostSpacesIDGroupsRequest, security operations.PostSpacesIDGroupsSecurity) (*operations.PostSpacesIDGroupsResponse, error) {
	baseURL := s._serverURL
	url := utils.GenerateURL(ctx, baseURL, "/spaces/{id}/groups", request, nil)

	bodyReader, reqContentType, err := utils.SerializeRequestBody(ctx, request, "RequestBody", "json")
	if err != nil {
		return nil, fmt.Errorf("error serializing request body: %w", err)
	}
	if bodyReader == nil {
		return nil, fmt.Errorf("request body is required")
	}

	req, err := http.NewRequestWithContext(ctx, "POST", url, bodyReader)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	req.Header.Set("Content-Type", reqContentType)

	client := utils.ConfigureSecurityClient(s._defaultClient, security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.PostSpacesIDGroupsResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 201:
		res.Headers = httpRes.Header

		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *operations.PostSpacesIDGroups201ApplicationJSON
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.PostSpacesIDGroups201ApplicationJSONObject = out
		}
	}

	return res, nil
}

// PostSpacesIDPersons - Add a Person in a Space
func (s *SDK) PostSpacesIDPersons(ctx context.Context, request operations.PostSpacesIDPersonsRequest, security operations.PostSpacesIDPersonsSecurity) (*operations.PostSpacesIDPersonsResponse, error) {
	baseURL := s._serverURL
	url := utils.GenerateURL(ctx, baseURL, "/spaces/{id}/persons", request, nil)

	bodyReader, reqContentType, err := utils.SerializeRequestBody(ctx, request, "RequestBody", "json")
	if err != nil {
		return nil, fmt.Errorf("error serializing request body: %w", err)
	}
	if bodyReader == nil {
		return nil, fmt.Errorf("request body is required")
	}

	req, err := http.NewRequestWithContext(ctx, "POST", url, bodyReader)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	req.Header.Set("Content-Type", reqContentType)

	client := utils.ConfigureSecurityClient(s._defaultClient, security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.PostSpacesIDPersonsResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 201:
		res.Headers = httpRes.Header

		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *operations.PostSpacesIDPersons201ApplicationJSON
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.PostSpacesIDPersons201ApplicationJSONObject = out
		}
	}

	return res, nil
}

// PostSpacesIDPersonsPersonIDDetails - Replace or Add a contact detail for a person
func (s *SDK) PostSpacesIDPersonsPersonIDDetails(ctx context.Context, request operations.PostSpacesIDPersonsPersonIDDetailsRequest) (*operations.PostSpacesIDPersonsPersonIDDetailsResponse, error) {
	baseURL := s._serverURL
	url := utils.GenerateURL(ctx, baseURL, "/spaces/{id}/persons/{personId}/details", request, nil)

	bodyReader, reqContentType, err := utils.SerializeRequestBody(ctx, request, "RequestBody", "json")
	if err != nil {
		return nil, fmt.Errorf("error serializing request body: %w", err)
	}
	if bodyReader == nil {
		return nil, fmt.Errorf("request body is required")
	}

	req, err := http.NewRequestWithContext(ctx, "POST", url, bodyReader)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	req.Header.Set("Content-Type", reqContentType)

	client := s._securityClient

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.PostSpacesIDPersonsPersonIDDetailsResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 204:
	}

	return res, nil
}

// PostSpacesIDPersonsPersonIDPortfolios - Create a portfolio for the person personId
func (s *SDK) PostSpacesIDPersonsPersonIDPortfolios(ctx context.Context, request operations.PostSpacesIDPersonsPersonIDPortfoliosRequest, security operations.PostSpacesIDPersonsPersonIDPortfoliosSecurity) (*operations.PostSpacesIDPersonsPersonIDPortfoliosResponse, error) {
	baseURL := s._serverURL
	url := utils.GenerateURL(ctx, baseURL, "/spaces/{id}/persons/{personId}/portfolios", request, nil)

	bodyReader, reqContentType, err := utils.SerializeRequestBody(ctx, request, "RequestBody", "json")
	if err != nil {
		return nil, fmt.Errorf("error serializing request body: %w", err)
	}

	req, err := http.NewRequestWithContext(ctx, "POST", url, bodyReader)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	req.Header.Set("Content-Type", reqContentType)

	client := utils.ConfigureSecurityClient(s._defaultClient, security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.PostSpacesIDPersonsPersonIDPortfoliosResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 201:
		res.Headers = httpRes.Header

		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *operations.PostSpacesIDPersonsPersonIDPortfolios201ApplicationJSON
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.PostSpacesIDPersonsPersonIDPortfolios201ApplicationJSONObject = out
		}
	}

	return res, nil
}

// PostSpacesIDProfessionalVehicles - Create a professional vehicle for the space
func (s *SDK) PostSpacesIDProfessionalVehicles(ctx context.Context, request operations.PostSpacesIDProfessionalVehiclesRequest, security operations.PostSpacesIDProfessionalVehiclesSecurity) (*operations.PostSpacesIDProfessionalVehiclesResponse, error) {
	baseURL := s._serverURL
	url := utils.GenerateURL(ctx, baseURL, "/spaces/{id}/professional-vehicles", request, nil)

	bodyReader, reqContentType, err := utils.SerializeRequestBody(ctx, request, "RequestBody", "json")
	if err != nil {
		return nil, fmt.Errorf("error serializing request body: %w", err)
	}
	if bodyReader == nil {
		return nil, fmt.Errorf("request body is required")
	}

	req, err := http.NewRequestWithContext(ctx, "POST", url, bodyReader)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	req.Header.Set("Content-Type", reqContentType)

	client := utils.ConfigureSecurityClient(s._defaultClient, security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.PostSpacesIDProfessionalVehiclesResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 201:
		res.Headers = httpRes.Header

		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *operations.PostSpacesIDProfessionalVehicles201ApplicationJSON
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.PostSpacesIDProfessionalVehicles201ApplicationJSONObject = out
		}
	}

	return res, nil
}

// PostSpacesIDSettingsNf203Logs - Enable/Disable logs
func (s *SDK) PostSpacesIDSettingsNf203Logs(ctx context.Context, request operations.PostSpacesIDSettingsNf203LogsRequest, security operations.PostSpacesIDSettingsNf203LogsSecurity) (*operations.PostSpacesIDSettingsNf203LogsResponse, error) {
	baseURL := s._serverURL
	url := utils.GenerateURL(ctx, baseURL, "/spaces/{id}/settings/nf203/logs", request, nil)

	bodyReader, reqContentType, err := utils.SerializeRequestBody(ctx, request, "RequestBody", "json")
	if err != nil {
		return nil, fmt.Errorf("error serializing request body: %w", err)
	}

	req, err := http.NewRequestWithContext(ctx, "POST", url, bodyReader)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	req.Header.Set("Content-Type", reqContentType)

	client := utils.ConfigureSecurityClient(s._defaultClient, security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.PostSpacesIDSettingsNf203LogsResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 204:
	}

	return res, nil
}

// PostSpacesIDStatus - Replace or Add a status
func (s *SDK) PostSpacesIDStatus(ctx context.Context, request operations.PostSpacesIDStatusRequest) (*operations.PostSpacesIDStatusResponse, error) {
	baseURL := s._serverURL
	url := utils.GenerateURL(ctx, baseURL, "/spaces/{id}/status", request, nil)

	bodyReader, reqContentType, err := utils.SerializeRequestBody(ctx, request, "RequestBody", "json")
	if err != nil {
		return nil, fmt.Errorf("error serializing request body: %w", err)
	}
	if bodyReader == nil {
		return nil, fmt.Errorf("request body is required")
	}

	req, err := http.NewRequestWithContext(ctx, "POST", url, bodyReader)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	req.Header.Set("Content-Type", reqContentType)

	client := s._securityClient

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.PostSpacesIDStatusResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 204:
	}

	return res, nil
}

// PostSpacesIDTaxContracts - Create a tax contract for the space
func (s *SDK) PostSpacesIDTaxContracts(ctx context.Context, request operations.PostSpacesIDTaxContractsRequest, security operations.PostSpacesIDTaxContractsSecurity) (*operations.PostSpacesIDTaxContractsResponse, error) {
	baseURL := s._serverURL
	url := utils.GenerateURL(ctx, baseURL, "/spaces/{id}/tax-contracts", request, nil)

	bodyReader, reqContentType, err := utils.SerializeRequestBody(ctx, request, "RequestBody", "json")
	if err != nil {
		return nil, fmt.Errorf("error serializing request body: %w", err)
	}
	if bodyReader == nil {
		return nil, fmt.Errorf("request body is required")
	}

	req, err := http.NewRequestWithContext(ctx, "POST", url, bodyReader)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	req.Header.Set("Content-Type", reqContentType)

	client := utils.ConfigureSecurityClient(s._defaultClient, security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.PostSpacesIDTaxContractsResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 201:
		res.Headers = httpRes.Header

		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *operations.PostSpacesIDTaxContracts201ApplicationJSON
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.PostSpacesIDTaxContracts201ApplicationJSONObject = out
		}
	}

	return res, nil
}

// PostSpacesIDTriggersName - Creates a trigger for the space id
func (s *SDK) PostSpacesIDTriggersName(ctx context.Context, request operations.PostSpacesIDTriggersNameRequest, security operations.PostSpacesIDTriggersNameSecurity) (*operations.PostSpacesIDTriggersNameResponse, error) {
	baseURL := s._serverURL
	url := utils.GenerateURL(ctx, baseURL, "/spaces/{id}/triggers/{name}", request, nil)

	req, err := http.NewRequestWithContext(ctx, "POST", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	client := utils.ConfigureSecurityClient(s._defaultClient, security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.PostSpacesIDTriggersNameResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 201:
	}

	return res, nil
}

// PostSpacesSpaceIDDocumentsDocumentIDExtend - Add a data to a document
func (s *SDK) PostSpacesSpaceIDDocumentsDocumentIDExtend(ctx context.Context, request operations.PostSpacesSpaceIDDocumentsDocumentIDExtendRequest, security operations.PostSpacesSpaceIDDocumentsDocumentIDExtendSecurity) (*operations.PostSpacesSpaceIDDocumentsDocumentIDExtendResponse, error) {
	baseURL := s._serverURL
	url := utils.GenerateURL(ctx, baseURL, "/spaces/{spaceId}/documents/{documentId}/extend", request, nil)

	bodyReader, reqContentType, err := utils.SerializeRequestBody(ctx, request, "RequestBody", "json")
	if err != nil {
		return nil, fmt.Errorf("error serializing request body: %w", err)
	}
	if bodyReader == nil {
		return nil, fmt.Errorf("request body is required")
	}

	req, err := http.NewRequestWithContext(ctx, "POST", url, bodyReader)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	req.Header.Set("Content-Type", reqContentType)

	client := utils.ConfigureSecurityClient(s._defaultClient, security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.PostSpacesSpaceIDDocumentsDocumentIDExtendResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 201:
		res.Headers = httpRes.Header

		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *operations.PostSpacesSpaceIDDocumentsDocumentIDExtend201ApplicationJSON
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.PostSpacesSpaceIDDocumentsDocumentIDExtend201ApplicationJSONObject = out
		}
	}

	return res, nil
}

// PostSpacesSpaceIDDocumentsDocumentIDMailing - send by mail a document
func (s *SDK) PostSpacesSpaceIDDocumentsDocumentIDMailing(ctx context.Context, request operations.PostSpacesSpaceIDDocumentsDocumentIDMailingRequest, security operations.PostSpacesSpaceIDDocumentsDocumentIDMailingSecurity) (*operations.PostSpacesSpaceIDDocumentsDocumentIDMailingResponse, error) {
	baseURL := s._serverURL
	url := utils.GenerateURL(ctx, baseURL, "/spaces/{spaceId}/documents/{documentId}/mailing", request, nil)

	bodyReader, reqContentType, err := utils.SerializeRequestBody(ctx, request, "RequestBody", "json")
	if err != nil {
		return nil, fmt.Errorf("error serializing request body: %w", err)
	}
	if bodyReader == nil {
		return nil, fmt.Errorf("request body is required")
	}

	req, err := http.NewRequestWithContext(ctx, "POST", url, bodyReader)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	req.Header.Set("Content-Type", reqContentType)

	client := utils.ConfigureSecurityClient(s._defaultClient, security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.PostSpacesSpaceIDDocumentsDocumentIDMailingResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *operations.PostSpacesSpaceIDDocumentsDocumentIDMailing200ApplicationJSON
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.PostSpacesSpaceIDDocumentsDocumentIDMailing200ApplicationJSONObject = out
		}
	}

	return res, nil
}

// PostSpacesSpaceIDDocumentsDocumentIDVersionsJSON - Add a version to a document and set it as current
func (s *SDK) PostSpacesSpaceIDDocumentsDocumentIDVersionsJSON(ctx context.Context, request operations.PostSpacesSpaceIDDocumentsDocumentIDVersionsJSONRequest, security operations.PostSpacesSpaceIDDocumentsDocumentIDVersionsJSONSecurity) (*operations.PostSpacesSpaceIDDocumentsDocumentIDVersionsJSONResponse, error) {
	baseURL := s._serverURL
	url := utils.GenerateURL(ctx, baseURL, "/spaces/{spaceId}/documents/{documentId}/versions", request, nil)

	bodyReader, reqContentType, err := utils.SerializeRequestBody(ctx, request, "RequestBody", "json")
	if err != nil {
		return nil, fmt.Errorf("error serializing request body: %w", err)
	}
	if bodyReader == nil {
		return nil, fmt.Errorf("request body is required")
	}

	req, err := http.NewRequestWithContext(ctx, "POST", url, bodyReader)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	req.Header.Set("Content-Type", reqContentType)

	client := utils.ConfigureSecurityClient(s._defaultClient, security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.PostSpacesSpaceIDDocumentsDocumentIDVersionsJSONResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 201:
		res.Headers = httpRes.Header

		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *operations.PostSpacesSpaceIDDocumentsDocumentIDVersionsJSON201ApplicationJSON
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.PostSpacesSpaceIDDocumentsDocumentIDVersionsJSON201ApplicationJSONObject = out
		}
	}

	return res, nil
}

// PostSpacesSpaceIDDocumentsDocumentIDVersionsMultipart - Add a version to a document and set it as current
func (s *SDK) PostSpacesSpaceIDDocumentsDocumentIDVersionsMultipart(ctx context.Context, request operations.PostSpacesSpaceIDDocumentsDocumentIDVersionsMultipartRequest, security operations.PostSpacesSpaceIDDocumentsDocumentIDVersionsMultipartSecurity) (*operations.PostSpacesSpaceIDDocumentsDocumentIDVersionsMultipartResponse, error) {
	baseURL := s._serverURL
	url := utils.GenerateURL(ctx, baseURL, "/spaces/{spaceId}/documents/{documentId}/versions", request, nil)

	bodyReader, reqContentType, err := utils.SerializeRequestBody(ctx, request, "RequestBody", "multipart")
	if err != nil {
		return nil, fmt.Errorf("error serializing request body: %w", err)
	}
	if bodyReader == nil {
		return nil, fmt.Errorf("request body is required")
	}

	req, err := http.NewRequestWithContext(ctx, "POST", url, bodyReader)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	req.Header.Set("Content-Type", reqContentType)

	client := utils.ConfigureSecurityClient(s._defaultClient, security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.PostSpacesSpaceIDDocumentsDocumentIDVersionsMultipartResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 201:
		res.Headers = httpRes.Header

		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *operations.PostSpacesSpaceIDDocumentsDocumentIDVersionsMultipart201ApplicationJSON
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.PostSpacesSpaceIDDocumentsDocumentIDVersionsMultipart201ApplicationJSONObject = out
		}
	}

	return res, nil
}

// PostSpacesSpaceIDExtend - Add a data to a space
func (s *SDK) PostSpacesSpaceIDExtend(ctx context.Context, request operations.PostSpacesSpaceIDExtendRequest, security operations.PostSpacesSpaceIDExtendSecurity) (*operations.PostSpacesSpaceIDExtendResponse, error) {
	baseURL := s._serverURL
	url := utils.GenerateURL(ctx, baseURL, "/spaces/{spaceId}/extend", request, nil)

	bodyReader, reqContentType, err := utils.SerializeRequestBody(ctx, request, "RequestBody", "json")
	if err != nil {
		return nil, fmt.Errorf("error serializing request body: %w", err)
	}
	if bodyReader == nil {
		return nil, fmt.Errorf("request body is required")
	}

	req, err := http.NewRequestWithContext(ctx, "POST", url, bodyReader)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	req.Header.Set("Content-Type", reqContentType)

	client := utils.ConfigureSecurityClient(s._defaultClient, security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.PostSpacesSpaceIDExtendResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 201:
		res.Headers = httpRes.Header

		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *operations.PostSpacesSpaceIDExtend201ApplicationJSON
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.PostSpacesSpaceIDExtend201ApplicationJSONObject = out
		}
	}

	return res, nil
}

// PostSpacesSpaceIDFoldersFolderIDPayrollsDocumentIDRefresh - recalculate a payroll
func (s *SDK) PostSpacesSpaceIDFoldersFolderIDPayrollsDocumentIDRefresh(ctx context.Context, request operations.PostSpacesSpaceIDFoldersFolderIDPayrollsDocumentIDRefreshRequest) (*operations.PostSpacesSpaceIDFoldersFolderIDPayrollsDocumentIDRefreshResponse, error) {
	baseURL := s._serverURL
	url := utils.GenerateURL(ctx, baseURL, "/spaces/{spaceId}/folders/{folderId}/payrolls/{documentId}/refresh", request, nil)

	req, err := http.NewRequestWithContext(ctx, "POST", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	client := s._securityClient

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.PostSpacesSpaceIDFoldersFolderIDPayrollsDocumentIDRefreshResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 201:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *operations.PostSpacesSpaceIDFoldersFolderIDPayrollsDocumentIDRefresh201ApplicationJSON
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.PostSpacesSpaceIDFoldersFolderIDPayrollsDocumentIDRefresh201ApplicationJSONObject = out
		}
	case httpRes.StatusCode == 204:
	}

	return res, nil
}

// PostSpacesSpaceIDFoldersIDBankStatementsJSON - Add a bank statement in a folder bank
func (s *SDK) PostSpacesSpaceIDFoldersIDBankStatementsJSON(ctx context.Context, request operations.PostSpacesSpaceIDFoldersIDBankStatementsJSONRequest, security operations.PostSpacesSpaceIDFoldersIDBankStatementsJSONSecurity) (*operations.PostSpacesSpaceIDFoldersIDBankStatementsJSONResponse, error) {
	baseURL := s._serverURL
	url := utils.GenerateURL(ctx, baseURL, "/spaces/{spaceId}/folders/{id}/bank-statements", request, nil)

	bodyReader, reqContentType, err := utils.SerializeRequestBody(ctx, request, "RequestBody", "json")
	if err != nil {
		return nil, fmt.Errorf("error serializing request body: %w", err)
	}
	if bodyReader == nil {
		return nil, fmt.Errorf("request body is required")
	}

	req, err := http.NewRequestWithContext(ctx, "POST", url, bodyReader)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	req.Header.Set("Content-Type", reqContentType)

	client := utils.ConfigureSecurityClient(s._defaultClient, security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.PostSpacesSpaceIDFoldersIDBankStatementsJSONResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 201:
		res.Headers = httpRes.Header

		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *operations.PostSpacesSpaceIDFoldersIDBankStatementsJSON201ApplicationJSON
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.PostSpacesSpaceIDFoldersIDBankStatementsJSON201ApplicationJSONObject = out
		}
	}

	return res, nil
}

// PostSpacesSpaceIDFoldersIDBankStatementsMultipart - Add a bank statement in a folder bank
func (s *SDK) PostSpacesSpaceIDFoldersIDBankStatementsMultipart(ctx context.Context, request operations.PostSpacesSpaceIDFoldersIDBankStatementsMultipartRequest, security operations.PostSpacesSpaceIDFoldersIDBankStatementsMultipartSecurity) (*operations.PostSpacesSpaceIDFoldersIDBankStatementsMultipartResponse, error) {
	baseURL := s._serverURL
	url := utils.GenerateURL(ctx, baseURL, "/spaces/{spaceId}/folders/{id}/bank-statements", request, nil)

	bodyReader, reqContentType, err := utils.SerializeRequestBody(ctx, request, "RequestBody", "multipart")
	if err != nil {
		return nil, fmt.Errorf("error serializing request body: %w", err)
	}
	if bodyReader == nil {
		return nil, fmt.Errorf("request body is required")
	}

	req, err := http.NewRequestWithContext(ctx, "POST", url, bodyReader)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	req.Header.Set("Content-Type", reqContentType)

	client := utils.ConfigureSecurityClient(s._defaultClient, security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.PostSpacesSpaceIDFoldersIDBankStatementsMultipartResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 201:
		res.Headers = httpRes.Header

		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *operations.PostSpacesSpaceIDFoldersIDBankStatementsMultipart201ApplicationJSON
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.PostSpacesSpaceIDFoldersIDBankStatementsMultipart201ApplicationJSONObject = out
		}
	}

	return res, nil
}

// PostSpacesSpaceIDFoldersIDCommonFolders - Add a common folder in another folder
func (s *SDK) PostSpacesSpaceIDFoldersIDCommonFolders(ctx context.Context, request operations.PostSpacesSpaceIDFoldersIDCommonFoldersRequest, security operations.PostSpacesSpaceIDFoldersIDCommonFoldersSecurity) (*operations.PostSpacesSpaceIDFoldersIDCommonFoldersResponse, error) {
	baseURL := s._serverURL
	url := utils.GenerateURL(ctx, baseURL, "/spaces/{spaceId}/folders/{id}/common-folders", request, nil)

	bodyReader, reqContentType, err := utils.SerializeRequestBody(ctx, request, "RequestBody", "json")
	if err != nil {
		return nil, fmt.Errorf("error serializing request body: %w", err)
	}
	if bodyReader == nil {
		return nil, fmt.Errorf("request body is required")
	}

	req, err := http.NewRequestWithContext(ctx, "POST", url, bodyReader)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	req.Header.Set("Content-Type", reqContentType)

	client := utils.ConfigureSecurityClient(s._defaultClient, security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.PostSpacesSpaceIDFoldersIDCommonFoldersResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 201:
		res.Headers = httpRes.Header

		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *operations.PostSpacesSpaceIDFoldersIDCommonFolders201ApplicationJSON
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.PostSpacesSpaceIDFoldersIDCommonFolders201ApplicationJSONObject = out
		}
	}

	return res, nil
}

// PostSpacesSpaceIDFoldersIDContractualDocumentsJSON - Add a document in a folder
func (s *SDK) PostSpacesSpaceIDFoldersIDContractualDocumentsJSON(ctx context.Context, request operations.PostSpacesSpaceIDFoldersIDContractualDocumentsJSONRequest, security operations.PostSpacesSpaceIDFoldersIDContractualDocumentsJSONSecurity) (*operations.PostSpacesSpaceIDFoldersIDContractualDocumentsJSONResponse, error) {
	baseURL := s._serverURL
	url := utils.GenerateURL(ctx, baseURL, "/spaces/{spaceId}/folders/{id}/contractual-documents", request, nil)

	bodyReader, reqContentType, err := utils.SerializeRequestBody(ctx, request, "RequestBody", "json")
	if err != nil {
		return nil, fmt.Errorf("error serializing request body: %w", err)
	}
	if bodyReader == nil {
		return nil, fmt.Errorf("request body is required")
	}

	req, err := http.NewRequestWithContext(ctx, "POST", url, bodyReader)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	req.Header.Set("Content-Type", reqContentType)

	client := utils.ConfigureSecurityClient(s._defaultClient, security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.PostSpacesSpaceIDFoldersIDContractualDocumentsJSONResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 201:
		res.Headers = httpRes.Header

		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *operations.PostSpacesSpaceIDFoldersIDContractualDocumentsJSON201ApplicationJSON
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.PostSpacesSpaceIDFoldersIDContractualDocumentsJSON201ApplicationJSONObject = out
		}
	}

	return res, nil
}

// PostSpacesSpaceIDFoldersIDContractualDocumentsMultipart - Add a document in a folder
func (s *SDK) PostSpacesSpaceIDFoldersIDContractualDocumentsMultipart(ctx context.Context, request operations.PostSpacesSpaceIDFoldersIDContractualDocumentsMultipartRequest, security operations.PostSpacesSpaceIDFoldersIDContractualDocumentsMultipartSecurity) (*operations.PostSpacesSpaceIDFoldersIDContractualDocumentsMultipartResponse, error) {
	baseURL := s._serverURL
	url := utils.GenerateURL(ctx, baseURL, "/spaces/{spaceId}/folders/{id}/contractual-documents", request, nil)

	bodyReader, reqContentType, err := utils.SerializeRequestBody(ctx, request, "RequestBody", "multipart")
	if err != nil {
		return nil, fmt.Errorf("error serializing request body: %w", err)
	}
	if bodyReader == nil {
		return nil, fmt.Errorf("request body is required")
	}

	req, err := http.NewRequestWithContext(ctx, "POST", url, bodyReader)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	req.Header.Set("Content-Type", reqContentType)

	client := utils.ConfigureSecurityClient(s._defaultClient, security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.PostSpacesSpaceIDFoldersIDContractualDocumentsMultipartResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 201:
		res.Headers = httpRes.Header

		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *operations.PostSpacesSpaceIDFoldersIDContractualDocumentsMultipart201ApplicationJSON
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.PostSpacesSpaceIDFoldersIDContractualDocumentsMultipart201ApplicationJSONObject = out
		}
	}

	return res, nil
}

// PostSpacesSpaceIDFoldersIDCoporateTaxDeclarationsJSON - Add a corporate tax declaration
func (s *SDK) PostSpacesSpaceIDFoldersIDCoporateTaxDeclarationsJSON(ctx context.Context, request operations.PostSpacesSpaceIDFoldersIDCoporateTaxDeclarationsJSONRequest, security operations.PostSpacesSpaceIDFoldersIDCoporateTaxDeclarationsJSONSecurity) (*operations.PostSpacesSpaceIDFoldersIDCoporateTaxDeclarationsJSONResponse, error) {
	baseURL := s._serverURL
	url := utils.GenerateURL(ctx, baseURL, "/spaces/{spaceId}/folders/{id}/coporate-tax-declarations", request, nil)

	bodyReader, reqContentType, err := utils.SerializeRequestBody(ctx, request, "RequestBody", "json")
	if err != nil {
		return nil, fmt.Errorf("error serializing request body: %w", err)
	}
	if bodyReader == nil {
		return nil, fmt.Errorf("request body is required")
	}

	req, err := http.NewRequestWithContext(ctx, "POST", url, bodyReader)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	req.Header.Set("Content-Type", reqContentType)

	client := utils.ConfigureSecurityClient(s._defaultClient, security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.PostSpacesSpaceIDFoldersIDCoporateTaxDeclarationsJSONResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 201:
		res.Headers = httpRes.Header

		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *operations.PostSpacesSpaceIDFoldersIDCoporateTaxDeclarationsJSON201ApplicationJSON
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.PostSpacesSpaceIDFoldersIDCoporateTaxDeclarationsJSON201ApplicationJSONObject = out
		}
	}

	return res, nil
}

// PostSpacesSpaceIDFoldersIDCoporateTaxDeclarationsMultipart - Add a corporate tax declaration
func (s *SDK) PostSpacesSpaceIDFoldersIDCoporateTaxDeclarationsMultipart(ctx context.Context, request operations.PostSpacesSpaceIDFoldersIDCoporateTaxDeclarationsMultipartRequest, security operations.PostSpacesSpaceIDFoldersIDCoporateTaxDeclarationsMultipartSecurity) (*operations.PostSpacesSpaceIDFoldersIDCoporateTaxDeclarationsMultipartResponse, error) {
	baseURL := s._serverURL
	url := utils.GenerateURL(ctx, baseURL, "/spaces/{spaceId}/folders/{id}/coporate-tax-declarations", request, nil)

	bodyReader, reqContentType, err := utils.SerializeRequestBody(ctx, request, "RequestBody", "multipart")
	if err != nil {
		return nil, fmt.Errorf("error serializing request body: %w", err)
	}
	if bodyReader == nil {
		return nil, fmt.Errorf("request body is required")
	}

	req, err := http.NewRequestWithContext(ctx, "POST", url, bodyReader)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	req.Header.Set("Content-Type", reqContentType)

	client := utils.ConfigureSecurityClient(s._defaultClient, security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.PostSpacesSpaceIDFoldersIDCoporateTaxDeclarationsMultipartResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 201:
		res.Headers = httpRes.Header

		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *operations.PostSpacesSpaceIDFoldersIDCoporateTaxDeclarationsMultipart201ApplicationJSON
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.PostSpacesSpaceIDFoldersIDCoporateTaxDeclarationsMultipart201ApplicationJSONObject = out
		}
	}

	return res, nil
}

// PostSpacesSpaceIDFoldersIDDocumentsJSON - Add a document in a folder
func (s *SDK) PostSpacesSpaceIDFoldersIDDocumentsJSON(ctx context.Context, request operations.PostSpacesSpaceIDFoldersIDDocumentsJSONRequest, security operations.PostSpacesSpaceIDFoldersIDDocumentsJSONSecurity) (*operations.PostSpacesSpaceIDFoldersIDDocumentsJSONResponse, error) {
	baseURL := s._serverURL
	url := utils.GenerateURL(ctx, baseURL, "/spaces/{spaceId}/folders/{id}/documents", request, nil)

	bodyReader, reqContentType, err := utils.SerializeRequestBody(ctx, request, "RequestBody", "json")
	if err != nil {
		return nil, fmt.Errorf("error serializing request body: %w", err)
	}
	if bodyReader == nil {
		return nil, fmt.Errorf("request body is required")
	}

	req, err := http.NewRequestWithContext(ctx, "POST", url, bodyReader)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	req.Header.Set("Content-Type", reqContentType)

	client := utils.ConfigureSecurityClient(s._defaultClient, security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.PostSpacesSpaceIDFoldersIDDocumentsJSONResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 201:
		res.Headers = httpRes.Header

		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *operations.PostSpacesSpaceIDFoldersIDDocumentsJSON201ApplicationJSON
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.PostSpacesSpaceIDFoldersIDDocumentsJSON201ApplicationJSONObject = out
		}
	}

	return res, nil
}

// PostSpacesSpaceIDFoldersIDDocumentsMultipart - Add a document in a folder
func (s *SDK) PostSpacesSpaceIDFoldersIDDocumentsMultipart(ctx context.Context, request operations.PostSpacesSpaceIDFoldersIDDocumentsMultipartRequest, security operations.PostSpacesSpaceIDFoldersIDDocumentsMultipartSecurity) (*operations.PostSpacesSpaceIDFoldersIDDocumentsMultipartResponse, error) {
	baseURL := s._serverURL
	url := utils.GenerateURL(ctx, baseURL, "/spaces/{spaceId}/folders/{id}/documents", request, nil)

	bodyReader, reqContentType, err := utils.SerializeRequestBody(ctx, request, "RequestBody", "multipart")
	if err != nil {
		return nil, fmt.Errorf("error serializing request body: %w", err)
	}
	if bodyReader == nil {
		return nil, fmt.Errorf("request body is required")
	}

	req, err := http.NewRequestWithContext(ctx, "POST", url, bodyReader)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	req.Header.Set("Content-Type", reqContentType)

	client := utils.ConfigureSecurityClient(s._defaultClient, security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.PostSpacesSpaceIDFoldersIDDocumentsMultipartResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 201:
		res.Headers = httpRes.Header

		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *operations.PostSpacesSpaceIDFoldersIDDocumentsMultipart201ApplicationJSON
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.PostSpacesSpaceIDFoldersIDDocumentsMultipart201ApplicationJSONObject = out
		}
	}

	return res, nil
}

// PostSpacesSpaceIDFoldersIDExpenseProofsJSON - Add a expense proof in a folder followup or exchange
func (s *SDK) PostSpacesSpaceIDFoldersIDExpenseProofsJSON(ctx context.Context, request operations.PostSpacesSpaceIDFoldersIDExpenseProofsJSONRequest, security operations.PostSpacesSpaceIDFoldersIDExpenseProofsJSONSecurity) (*operations.PostSpacesSpaceIDFoldersIDExpenseProofsJSONResponse, error) {
	baseURL := s._serverURL
	url := utils.GenerateURL(ctx, baseURL, "/spaces/{spaceId}/folders/{id}/expense-proofs", request, nil)

	bodyReader, reqContentType, err := utils.SerializeRequestBody(ctx, request, "RequestBody", "json")
	if err != nil {
		return nil, fmt.Errorf("error serializing request body: %w", err)
	}
	if bodyReader == nil {
		return nil, fmt.Errorf("request body is required")
	}

	req, err := http.NewRequestWithContext(ctx, "POST", url, bodyReader)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	req.Header.Set("Content-Type", reqContentType)

	client := utils.ConfigureSecurityClient(s._defaultClient, security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.PostSpacesSpaceIDFoldersIDExpenseProofsJSONResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 201:
		res.Headers = httpRes.Header

		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *operations.PostSpacesSpaceIDFoldersIDExpenseProofsJSON201ApplicationJSON
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.PostSpacesSpaceIDFoldersIDExpenseProofsJSON201ApplicationJSONObject = out
		}
	}

	return res, nil
}

// PostSpacesSpaceIDFoldersIDExpenseProofsMultipart - Add a expense proof in a folder followup or exchange
func (s *SDK) PostSpacesSpaceIDFoldersIDExpenseProofsMultipart(ctx context.Context, request operations.PostSpacesSpaceIDFoldersIDExpenseProofsMultipartRequest, security operations.PostSpacesSpaceIDFoldersIDExpenseProofsMultipartSecurity) (*operations.PostSpacesSpaceIDFoldersIDExpenseProofsMultipartResponse, error) {
	baseURL := s._serverURL
	url := utils.GenerateURL(ctx, baseURL, "/spaces/{spaceId}/folders/{id}/expense-proofs", request, nil)

	bodyReader, reqContentType, err := utils.SerializeRequestBody(ctx, request, "RequestBody", "multipart")
	if err != nil {
		return nil, fmt.Errorf("error serializing request body: %w", err)
	}
	if bodyReader == nil {
		return nil, fmt.Errorf("request body is required")
	}

	req, err := http.NewRequestWithContext(ctx, "POST", url, bodyReader)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	req.Header.Set("Content-Type", reqContentType)

	client := utils.ConfigureSecurityClient(s._defaultClient, security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.PostSpacesSpaceIDFoldersIDExpenseProofsMultipartResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 201:
		res.Headers = httpRes.Header

		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *operations.PostSpacesSpaceIDFoldersIDExpenseProofsMultipart201ApplicationJSON
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.PostSpacesSpaceIDFoldersIDExpenseProofsMultipart201ApplicationJSONObject = out
		}
	}

	return res, nil
}

// PostSpacesSpaceIDFoldersIDExpenseReportsJSON - Add a expense report in a folder followup
func (s *SDK) PostSpacesSpaceIDFoldersIDExpenseReportsJSON(ctx context.Context, request operations.PostSpacesSpaceIDFoldersIDExpenseReportsJSONRequest, security operations.PostSpacesSpaceIDFoldersIDExpenseReportsJSONSecurity) (*operations.PostSpacesSpaceIDFoldersIDExpenseReportsJSONResponse, error) {
	baseURL := s._serverURL
	url := utils.GenerateURL(ctx, baseURL, "/spaces/{spaceId}/folders/{id}/expense-reports", request, nil)

	bodyReader, reqContentType, err := utils.SerializeRequestBody(ctx, request, "RequestBody", "json")
	if err != nil {
		return nil, fmt.Errorf("error serializing request body: %w", err)
	}
	if bodyReader == nil {
		return nil, fmt.Errorf("request body is required")
	}

	req, err := http.NewRequestWithContext(ctx, "POST", url, bodyReader)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	req.Header.Set("Content-Type", reqContentType)

	client := utils.ConfigureSecurityClient(s._defaultClient, security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.PostSpacesSpaceIDFoldersIDExpenseReportsJSONResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 201:
		res.Headers = httpRes.Header

		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *operations.PostSpacesSpaceIDFoldersIDExpenseReportsJSON201ApplicationJSON
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.PostSpacesSpaceIDFoldersIDExpenseReportsJSON201ApplicationJSONObject = out
		}
	}

	return res, nil
}

// PostSpacesSpaceIDFoldersIDExpenseReportsMultipart - Add a expense report in a folder followup
func (s *SDK) PostSpacesSpaceIDFoldersIDExpenseReportsMultipart(ctx context.Context, request operations.PostSpacesSpaceIDFoldersIDExpenseReportsMultipartRequest, security operations.PostSpacesSpaceIDFoldersIDExpenseReportsMultipartSecurity) (*operations.PostSpacesSpaceIDFoldersIDExpenseReportsMultipartResponse, error) {
	baseURL := s._serverURL
	url := utils.GenerateURL(ctx, baseURL, "/spaces/{spaceId}/folders/{id}/expense-reports", request, nil)

	bodyReader, reqContentType, err := utils.SerializeRequestBody(ctx, request, "RequestBody", "multipart")
	if err != nil {
		return nil, fmt.Errorf("error serializing request body: %w", err)
	}
	if bodyReader == nil {
		return nil, fmt.Errorf("request body is required")
	}

	req, err := http.NewRequestWithContext(ctx, "POST", url, bodyReader)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	req.Header.Set("Content-Type", reqContentType)

	client := utils.ConfigureSecurityClient(s._defaultClient, security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.PostSpacesSpaceIDFoldersIDExpenseReportsMultipartResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 201:
		res.Headers = httpRes.Header

		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *operations.PostSpacesSpaceIDFoldersIDExpenseReportsMultipart201ApplicationJSON
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.PostSpacesSpaceIDFoldersIDExpenseReportsMultipart201ApplicationJSONObject = out
		}
	}

	return res, nil
}

// PostSpacesSpaceIDFoldersIDInvoicesJSON - Add a invoice in a folder of a customer or a provider
func (s *SDK) PostSpacesSpaceIDFoldersIDInvoicesJSON(ctx context.Context, request operations.PostSpacesSpaceIDFoldersIDInvoicesJSONRequest, security operations.PostSpacesSpaceIDFoldersIDInvoicesJSONSecurity) (*operations.PostSpacesSpaceIDFoldersIDInvoicesJSONResponse, error) {
	baseURL := s._serverURL
	url := utils.GenerateURL(ctx, baseURL, "/spaces/{spaceId}/folders/{id}/invoices", request, nil)

	bodyReader, reqContentType, err := utils.SerializeRequestBody(ctx, request, "RequestBody", "json")
	if err != nil {
		return nil, fmt.Errorf("error serializing request body: %w", err)
	}
	if bodyReader == nil {
		return nil, fmt.Errorf("request body is required")
	}

	req, err := http.NewRequestWithContext(ctx, "POST", url, bodyReader)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	req.Header.Set("Content-Type", reqContentType)

	client := utils.ConfigureSecurityClient(s._defaultClient, security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.PostSpacesSpaceIDFoldersIDInvoicesJSONResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 201:
		res.Headers = httpRes.Header

		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *operations.PostSpacesSpaceIDFoldersIDInvoicesJSON201ApplicationJSON
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.PostSpacesSpaceIDFoldersIDInvoicesJSON201ApplicationJSONObject = out
		}
	}

	return res, nil
}

// PostSpacesSpaceIDFoldersIDInvoicesMultipart - Add a invoice in a folder of a customer or a provider
func (s *SDK) PostSpacesSpaceIDFoldersIDInvoicesMultipart(ctx context.Context, request operations.PostSpacesSpaceIDFoldersIDInvoicesMultipartRequest, security operations.PostSpacesSpaceIDFoldersIDInvoicesMultipartSecurity) (*operations.PostSpacesSpaceIDFoldersIDInvoicesMultipartResponse, error) {
	baseURL := s._serverURL
	url := utils.GenerateURL(ctx, baseURL, "/spaces/{spaceId}/folders/{id}/invoices", request, nil)

	bodyReader, reqContentType, err := utils.SerializeRequestBody(ctx, request, "RequestBody", "multipart")
	if err != nil {
		return nil, fmt.Errorf("error serializing request body: %w", err)
	}
	if bodyReader == nil {
		return nil, fmt.Errorf("request body is required")
	}

	req, err := http.NewRequestWithContext(ctx, "POST", url, bodyReader)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	req.Header.Set("Content-Type", reqContentType)

	client := utils.ConfigureSecurityClient(s._defaultClient, security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.PostSpacesSpaceIDFoldersIDInvoicesMultipartResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 201:
		res.Headers = httpRes.Header

		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *operations.PostSpacesSpaceIDFoldersIDInvoicesMultipart201ApplicationJSON
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.PostSpacesSpaceIDFoldersIDInvoicesMultipart201ApplicationJSONObject = out
		}
	}

	return res, nil
}

// PostSpacesSpaceIDFoldersIDMessages - Write a message in the journal of a folder
func (s *SDK) PostSpacesSpaceIDFoldersIDMessages(ctx context.Context, request operations.PostSpacesSpaceIDFoldersIDMessagesRequest, security operations.PostSpacesSpaceIDFoldersIDMessagesSecurity) (*operations.PostSpacesSpaceIDFoldersIDMessagesResponse, error) {
	baseURL := s._serverURL
	url := utils.GenerateURL(ctx, baseURL, "/spaces/{spaceId}/folders/{id}/messages", request, nil)

	bodyReader, reqContentType, err := utils.SerializeRequestBody(ctx, request, "RequestBody", "json")
	if err != nil {
		return nil, fmt.Errorf("error serializing request body: %w", err)
	}
	if bodyReader == nil {
		return nil, fmt.Errorf("request body is required")
	}

	req, err := http.NewRequestWithContext(ctx, "POST", url, bodyReader)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	req.Header.Set("Content-Type", reqContentType)

	client := utils.ConfigureSecurityClient(s._defaultClient, security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.PostSpacesSpaceIDFoldersIDMessagesResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
	}

	return res, nil
}

// PostSpacesSpaceIDFoldersIDOtherTaxesJSON - Add a tax declaration
func (s *SDK) PostSpacesSpaceIDFoldersIDOtherTaxesJSON(ctx context.Context, request operations.PostSpacesSpaceIDFoldersIDOtherTaxesJSONRequest, security operations.PostSpacesSpaceIDFoldersIDOtherTaxesJSONSecurity) (*operations.PostSpacesSpaceIDFoldersIDOtherTaxesJSONResponse, error) {
	baseURL := s._serverURL
	url := utils.GenerateURL(ctx, baseURL, "/spaces/{spaceId}/folders/{id}/other-taxes", request, nil)

	bodyReader, reqContentType, err := utils.SerializeRequestBody(ctx, request, "RequestBody", "json")
	if err != nil {
		return nil, fmt.Errorf("error serializing request body: %w", err)
	}
	if bodyReader == nil {
		return nil, fmt.Errorf("request body is required")
	}

	req, err := http.NewRequestWithContext(ctx, "POST", url, bodyReader)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	req.Header.Set("Content-Type", reqContentType)

	client := utils.ConfigureSecurityClient(s._defaultClient, security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.PostSpacesSpaceIDFoldersIDOtherTaxesJSONResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 201:
		res.Headers = httpRes.Header

		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *operations.PostSpacesSpaceIDFoldersIDOtherTaxesJSON201ApplicationJSON
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.PostSpacesSpaceIDFoldersIDOtherTaxesJSON201ApplicationJSONObject = out
		}
	}

	return res, nil
}

// PostSpacesSpaceIDFoldersIDOtherTaxesMultipart - Add a tax declaration
func (s *SDK) PostSpacesSpaceIDFoldersIDOtherTaxesMultipart(ctx context.Context, request operations.PostSpacesSpaceIDFoldersIDOtherTaxesMultipartRequest, security operations.PostSpacesSpaceIDFoldersIDOtherTaxesMultipartSecurity) (*operations.PostSpacesSpaceIDFoldersIDOtherTaxesMultipartResponse, error) {
	baseURL := s._serverURL
	url := utils.GenerateURL(ctx, baseURL, "/spaces/{spaceId}/folders/{id}/other-taxes", request, nil)

	bodyReader, reqContentType, err := utils.SerializeRequestBody(ctx, request, "RequestBody", "multipart")
	if err != nil {
		return nil, fmt.Errorf("error serializing request body: %w", err)
	}
	if bodyReader == nil {
		return nil, fmt.Errorf("request body is required")
	}

	req, err := http.NewRequestWithContext(ctx, "POST", url, bodyReader)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	req.Header.Set("Content-Type", reqContentType)

	client := utils.ConfigureSecurityClient(s._defaultClient, security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.PostSpacesSpaceIDFoldersIDOtherTaxesMultipartResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 201:
		res.Headers = httpRes.Header

		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *operations.PostSpacesSpaceIDFoldersIDOtherTaxesMultipart201ApplicationJSON
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.PostSpacesSpaceIDFoldersIDOtherTaxesMultipart201ApplicationJSONObject = out
		}
	}

	return res, nil
}

// PostSpacesSpaceIDFoldersIDPasswords - Write a identifier/password in aa folder
func (s *SDK) PostSpacesSpaceIDFoldersIDPasswords(ctx context.Context, request operations.PostSpacesSpaceIDFoldersIDPasswordsRequest, security operations.PostSpacesSpaceIDFoldersIDPasswordsSecurity) (*operations.PostSpacesSpaceIDFoldersIDPasswordsResponse, error) {
	baseURL := s._serverURL
	url := utils.GenerateURL(ctx, baseURL, "/spaces/{spaceId}/folders/{id}/passwords", request, nil)

	bodyReader, reqContentType, err := utils.SerializeRequestBody(ctx, request, "RequestBody", "json")
	if err != nil {
		return nil, fmt.Errorf("error serializing request body: %w", err)
	}
	if bodyReader == nil {
		return nil, fmt.Errorf("request body is required")
	}

	req, err := http.NewRequestWithContext(ctx, "POST", url, bodyReader)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	req.Header.Set("Content-Type", reqContentType)

	client := utils.ConfigureSecurityClient(s._defaultClient, security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.PostSpacesSpaceIDFoldersIDPasswordsResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
	}

	return res, nil
}

// PostSpacesSpaceIDFoldersIDPayrollsPayrollIDNominativeSocialDeclarationJSON - Add a nominative social declaration in a folder social
func (s *SDK) PostSpacesSpaceIDFoldersIDPayrollsPayrollIDNominativeSocialDeclarationJSON(ctx context.Context, request operations.PostSpacesSpaceIDFoldersIDPayrollsPayrollIDNominativeSocialDeclarationJSONRequest, security operations.PostSpacesSpaceIDFoldersIDPayrollsPayrollIDNominativeSocialDeclarationJSONSecurity) (*operations.PostSpacesSpaceIDFoldersIDPayrollsPayrollIDNominativeSocialDeclarationJSONResponse, error) {
	baseURL := s._serverURL
	url := utils.GenerateURL(ctx, baseURL, "/spaces/{spaceId}/folders/{id}/payrolls/{payrollId}/nominative-social-declaration", request, nil)

	bodyReader, reqContentType, err := utils.SerializeRequestBody(ctx, request, "RequestBody", "json")
	if err != nil {
		return nil, fmt.Errorf("error serializing request body: %w", err)
	}
	if bodyReader == nil {
		return nil, fmt.Errorf("request body is required")
	}

	req, err := http.NewRequestWithContext(ctx, "POST", url, bodyReader)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	req.Header.Set("Content-Type", reqContentType)

	client := utils.ConfigureSecurityClient(s._defaultClient, security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.PostSpacesSpaceIDFoldersIDPayrollsPayrollIDNominativeSocialDeclarationJSONResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 201:
		res.Headers = httpRes.Header

		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *operations.PostSpacesSpaceIDFoldersIDPayrollsPayrollIDNominativeSocialDeclarationJSON201ApplicationJSON
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.PostSpacesSpaceIDFoldersIDPayrollsPayrollIDNominativeSocialDeclarationJSON201ApplicationJSONObject = out
		}
	}

	return res, nil
}

// PostSpacesSpaceIDFoldersIDPayrollsPayrollIDNominativeSocialDeclarationMultipart - Add a nominative social declaration in a folder social
func (s *SDK) PostSpacesSpaceIDFoldersIDPayrollsPayrollIDNominativeSocialDeclarationMultipart(ctx context.Context, request operations.PostSpacesSpaceIDFoldersIDPayrollsPayrollIDNominativeSocialDeclarationMultipartRequest, security operations.PostSpacesSpaceIDFoldersIDPayrollsPayrollIDNominativeSocialDeclarationMultipartSecurity) (*operations.PostSpacesSpaceIDFoldersIDPayrollsPayrollIDNominativeSocialDeclarationMultipartResponse, error) {
	baseURL := s._serverURL
	url := utils.GenerateURL(ctx, baseURL, "/spaces/{spaceId}/folders/{id}/payrolls/{payrollId}/nominative-social-declaration", request, nil)

	bodyReader, reqContentType, err := utils.SerializeRequestBody(ctx, request, "RequestBody", "multipart")
	if err != nil {
		return nil, fmt.Errorf("error serializing request body: %w", err)
	}
	if bodyReader == nil {
		return nil, fmt.Errorf("request body is required")
	}

	req, err := http.NewRequestWithContext(ctx, "POST", url, bodyReader)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	req.Header.Set("Content-Type", reqContentType)

	client := utils.ConfigureSecurityClient(s._defaultClient, security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.PostSpacesSpaceIDFoldersIDPayrollsPayrollIDNominativeSocialDeclarationMultipartResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 201:
		res.Headers = httpRes.Header

		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *operations.PostSpacesSpaceIDFoldersIDPayrollsPayrollIDNominativeSocialDeclarationMultipart201ApplicationJSON
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.PostSpacesSpaceIDFoldersIDPayrollsPayrollIDNominativeSocialDeclarationMultipart201ApplicationJSONObject = out
		}
	}

	return res, nil
}

// PostSpacesSpaceIDFoldersIDPayrollsJSON - Add a payroll in a folder social
func (s *SDK) PostSpacesSpaceIDFoldersIDPayrollsJSON(ctx context.Context, request operations.PostSpacesSpaceIDFoldersIDPayrollsJSONRequest, security operations.PostSpacesSpaceIDFoldersIDPayrollsJSONSecurity) (*operations.PostSpacesSpaceIDFoldersIDPayrollsJSONResponse, error) {
	baseURL := s._serverURL
	url := utils.GenerateURL(ctx, baseURL, "/spaces/{spaceId}/folders/{id}/payrolls", request, nil)

	bodyReader, reqContentType, err := utils.SerializeRequestBody(ctx, request, "RequestBody", "json")
	if err != nil {
		return nil, fmt.Errorf("error serializing request body: %w", err)
	}
	if bodyReader == nil {
		return nil, fmt.Errorf("request body is required")
	}

	req, err := http.NewRequestWithContext(ctx, "POST", url, bodyReader)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	req.Header.Set("Content-Type", reqContentType)

	client := utils.ConfigureSecurityClient(s._defaultClient, security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.PostSpacesSpaceIDFoldersIDPayrollsJSONResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 201:
		res.Headers = httpRes.Header

		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *operations.PostSpacesSpaceIDFoldersIDPayrollsJSON201ApplicationJSON
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.PostSpacesSpaceIDFoldersIDPayrollsJSON201ApplicationJSONObject = out
		}
	}

	return res, nil
}

// PostSpacesSpaceIDFoldersIDPayrollsMultipart - Add a payroll in a folder social
func (s *SDK) PostSpacesSpaceIDFoldersIDPayrollsMultipart(ctx context.Context, request operations.PostSpacesSpaceIDFoldersIDPayrollsMultipartRequest, security operations.PostSpacesSpaceIDFoldersIDPayrollsMultipartSecurity) (*operations.PostSpacesSpaceIDFoldersIDPayrollsMultipartResponse, error) {
	baseURL := s._serverURL
	url := utils.GenerateURL(ctx, baseURL, "/spaces/{spaceId}/folders/{id}/payrolls", request, nil)

	bodyReader, reqContentType, err := utils.SerializeRequestBody(ctx, request, "RequestBody", "multipart")
	if err != nil {
		return nil, fmt.Errorf("error serializing request body: %w", err)
	}
	if bodyReader == nil {
		return nil, fmt.Errorf("request body is required")
	}

	req, err := http.NewRequestWithContext(ctx, "POST", url, bodyReader)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	req.Header.Set("Content-Type", reqContentType)

	client := utils.ConfigureSecurityClient(s._defaultClient, security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.PostSpacesSpaceIDFoldersIDPayrollsMultipartResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 201:
		res.Headers = httpRes.Header

		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *operations.PostSpacesSpaceIDFoldersIDPayrollsMultipart201ApplicationJSON
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.PostSpacesSpaceIDFoldersIDPayrollsMultipart201ApplicationJSONObject = out
		}
	}

	return res, nil
}

// PostSpacesSpaceIDFoldersIDPayslipsJSON - Add a payslip in a folder employee
func (s *SDK) PostSpacesSpaceIDFoldersIDPayslipsJSON(ctx context.Context, request operations.PostSpacesSpaceIDFoldersIDPayslipsJSONRequest, security operations.PostSpacesSpaceIDFoldersIDPayslipsJSONSecurity) (*operations.PostSpacesSpaceIDFoldersIDPayslipsJSONResponse, error) {
	baseURL := s._serverURL
	url := utils.GenerateURL(ctx, baseURL, "/spaces/{spaceId}/folders/{id}/payslips", request, nil)

	bodyReader, reqContentType, err := utils.SerializeRequestBody(ctx, request, "RequestBody", "json")
	if err != nil {
		return nil, fmt.Errorf("error serializing request body: %w", err)
	}
	if bodyReader == nil {
		return nil, fmt.Errorf("request body is required")
	}

	req, err := http.NewRequestWithContext(ctx, "POST", url, bodyReader)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	req.Header.Set("Content-Type", reqContentType)

	client := utils.ConfigureSecurityClient(s._defaultClient, security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.PostSpacesSpaceIDFoldersIDPayslipsJSONResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 201:
		res.Headers = httpRes.Header

		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *operations.PostSpacesSpaceIDFoldersIDPayslipsJSON201ApplicationJSON
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.PostSpacesSpaceIDFoldersIDPayslipsJSON201ApplicationJSONObject = out
		}
	}

	return res, nil
}

// PostSpacesSpaceIDFoldersIDPayslipsMultipart - Add a payslip in a folder employee
func (s *SDK) PostSpacesSpaceIDFoldersIDPayslipsMultipart(ctx context.Context, request operations.PostSpacesSpaceIDFoldersIDPayslipsMultipartRequest, security operations.PostSpacesSpaceIDFoldersIDPayslipsMultipartSecurity) (*operations.PostSpacesSpaceIDFoldersIDPayslipsMultipartResponse, error) {
	baseURL := s._serverURL
	url := utils.GenerateURL(ctx, baseURL, "/spaces/{spaceId}/folders/{id}/payslips", request, nil)

	bodyReader, reqContentType, err := utils.SerializeRequestBody(ctx, request, "RequestBody", "multipart")
	if err != nil {
		return nil, fmt.Errorf("error serializing request body: %w", err)
	}
	if bodyReader == nil {
		return nil, fmt.Errorf("request body is required")
	}

	req, err := http.NewRequestWithContext(ctx, "POST", url, bodyReader)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	req.Header.Set("Content-Type", reqContentType)

	client := utils.ConfigureSecurityClient(s._defaultClient, security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.PostSpacesSpaceIDFoldersIDPayslipsMultipartResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 201:
		res.Headers = httpRes.Header

		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *operations.PostSpacesSpaceIDFoldersIDPayslipsMultipart201ApplicationJSON
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.PostSpacesSpaceIDFoldersIDPayslipsMultipart201ApplicationJSONObject = out
		}
	}

	return res, nil
}

// PostSpacesSpaceIDFoldersIDRequiredDocumentsRequireddocumentidJSON - Add a required document to a line
func (s *SDK) PostSpacesSpaceIDFoldersIDRequiredDocumentsRequireddocumentidJSON(ctx context.Context, request operations.PostSpacesSpaceIDFoldersIDRequiredDocumentsRequireddocumentidJSONRequest, security operations.PostSpacesSpaceIDFoldersIDRequiredDocumentsRequireddocumentidJSONSecurity) (*operations.PostSpacesSpaceIDFoldersIDRequiredDocumentsRequireddocumentidJSONResponse, error) {
	baseURL := s._serverURL
	url := utils.GenerateURL(ctx, baseURL, "/spaces/{spaceId}/folders/{id}/required-documents/{requireddocumentid}", request, nil)

	bodyReader, reqContentType, err := utils.SerializeRequestBody(ctx, request, "RequestBody", "json")
	if err != nil {
		return nil, fmt.Errorf("error serializing request body: %w", err)
	}
	if bodyReader == nil {
		return nil, fmt.Errorf("request body is required")
	}

	req, err := http.NewRequestWithContext(ctx, "POST", url, bodyReader)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	req.Header.Set("Content-Type", reqContentType)

	client := utils.ConfigureSecurityClient(s._defaultClient, security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.PostSpacesSpaceIDFoldersIDRequiredDocumentsRequireddocumentidJSONResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 201:
		res.Headers = httpRes.Header

		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *operations.PostSpacesSpaceIDFoldersIDRequiredDocumentsRequireddocumentidJSON201ApplicationJSON
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.PostSpacesSpaceIDFoldersIDRequiredDocumentsRequireddocumentidJSON201ApplicationJSONObject = out
		}
	}

	return res, nil
}

// PostSpacesSpaceIDFoldersIDRequiredDocumentsRequireddocumentidMultipart - Add a required document to a line
func (s *SDK) PostSpacesSpaceIDFoldersIDRequiredDocumentsRequireddocumentidMultipart(ctx context.Context, request operations.PostSpacesSpaceIDFoldersIDRequiredDocumentsRequireddocumentidMultipartRequest, security operations.PostSpacesSpaceIDFoldersIDRequiredDocumentsRequireddocumentidMultipartSecurity) (*operations.PostSpacesSpaceIDFoldersIDRequiredDocumentsRequireddocumentidMultipartResponse, error) {
	baseURL := s._serverURL
	url := utils.GenerateURL(ctx, baseURL, "/spaces/{spaceId}/folders/{id}/required-documents/{requireddocumentid}", request, nil)

	bodyReader, reqContentType, err := utils.SerializeRequestBody(ctx, request, "RequestBody", "multipart")
	if err != nil {
		return nil, fmt.Errorf("error serializing request body: %w", err)
	}
	if bodyReader == nil {
		return nil, fmt.Errorf("request body is required")
	}

	req, err := http.NewRequestWithContext(ctx, "POST", url, bodyReader)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	req.Header.Set("Content-Type", reqContentType)

	client := utils.ConfigureSecurityClient(s._defaultClient, security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.PostSpacesSpaceIDFoldersIDRequiredDocumentsRequireddocumentidMultipartResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 201:
		res.Headers = httpRes.Header

		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *operations.PostSpacesSpaceIDFoldersIDRequiredDocumentsRequireddocumentidMultipart201ApplicationJSON
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.PostSpacesSpaceIDFoldersIDRequiredDocumentsRequireddocumentidMultipart201ApplicationJSONObject = out
		}
	}

	return res, nil
}

// PostSpacesSpaceIDFoldersIDSocialContractsJSON - Add a social contract in a folder employee
func (s *SDK) PostSpacesSpaceIDFoldersIDSocialContractsJSON(ctx context.Context, request operations.PostSpacesSpaceIDFoldersIDSocialContractsJSONRequest, security operations.PostSpacesSpaceIDFoldersIDSocialContractsJSONSecurity) (*operations.PostSpacesSpaceIDFoldersIDSocialContractsJSONResponse, error) {
	baseURL := s._serverURL
	url := utils.GenerateURL(ctx, baseURL, "/spaces/{spaceId}/folders/{id}/social-contracts", request, nil)

	bodyReader, reqContentType, err := utils.SerializeRequestBody(ctx, request, "RequestBody", "json")
	if err != nil {
		return nil, fmt.Errorf("error serializing request body: %w", err)
	}
	if bodyReader == nil {
		return nil, fmt.Errorf("request body is required")
	}

	req, err := http.NewRequestWithContext(ctx, "POST", url, bodyReader)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	req.Header.Set("Content-Type", reqContentType)

	client := utils.ConfigureSecurityClient(s._defaultClient, security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.PostSpacesSpaceIDFoldersIDSocialContractsJSONResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 201:
		res.Headers = httpRes.Header

		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *operations.PostSpacesSpaceIDFoldersIDSocialContractsJSON201ApplicationJSON
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.PostSpacesSpaceIDFoldersIDSocialContractsJSON201ApplicationJSONObject = out
		}
	}

	return res, nil
}

// PostSpacesSpaceIDFoldersIDSocialContractsMultipart - Add a social contract in a folder employee
func (s *SDK) PostSpacesSpaceIDFoldersIDSocialContractsMultipart(ctx context.Context, request operations.PostSpacesSpaceIDFoldersIDSocialContractsMultipartRequest, security operations.PostSpacesSpaceIDFoldersIDSocialContractsMultipartSecurity) (*operations.PostSpacesSpaceIDFoldersIDSocialContractsMultipartResponse, error) {
	baseURL := s._serverURL
	url := utils.GenerateURL(ctx, baseURL, "/spaces/{spaceId}/folders/{id}/social-contracts", request, nil)

	bodyReader, reqContentType, err := utils.SerializeRequestBody(ctx, request, "RequestBody", "multipart")
	if err != nil {
		return nil, fmt.Errorf("error serializing request body: %w", err)
	}
	if bodyReader == nil {
		return nil, fmt.Errorf("request body is required")
	}

	req, err := http.NewRequestWithContext(ctx, "POST", url, bodyReader)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	req.Header.Set("Content-Type", reqContentType)

	client := utils.ConfigureSecurityClient(s._defaultClient, security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.PostSpacesSpaceIDFoldersIDSocialContractsMultipartResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 201:
		res.Headers = httpRes.Header

		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *operations.PostSpacesSpaceIDFoldersIDSocialContractsMultipart201ApplicationJSON
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.PostSpacesSpaceIDFoldersIDSocialContractsMultipart201ApplicationJSONObject = out
		}
	}

	return res, nil
}

// PostSpacesSpaceIDFoldersIDSocialDeclarationsJSON - Add a social declaration
func (s *SDK) PostSpacesSpaceIDFoldersIDSocialDeclarationsJSON(ctx context.Context, request operations.PostSpacesSpaceIDFoldersIDSocialDeclarationsJSONRequest, security operations.PostSpacesSpaceIDFoldersIDSocialDeclarationsJSONSecurity) (*operations.PostSpacesSpaceIDFoldersIDSocialDeclarationsJSONResponse, error) {
	baseURL := s._serverURL
	url := utils.GenerateURL(ctx, baseURL, "/spaces/{spaceId}/folders/{id}/social-declarations", request, nil)

	bodyReader, reqContentType, err := utils.SerializeRequestBody(ctx, request, "RequestBody", "json")
	if err != nil {
		return nil, fmt.Errorf("error serializing request body: %w", err)
	}
	if bodyReader == nil {
		return nil, fmt.Errorf("request body is required")
	}

	req, err := http.NewRequestWithContext(ctx, "POST", url, bodyReader)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	req.Header.Set("Content-Type", reqContentType)

	client := utils.ConfigureSecurityClient(s._defaultClient, security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.PostSpacesSpaceIDFoldersIDSocialDeclarationsJSONResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 201:
		res.Headers = httpRes.Header

		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *operations.PostSpacesSpaceIDFoldersIDSocialDeclarationsJSON201ApplicationJSON
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.PostSpacesSpaceIDFoldersIDSocialDeclarationsJSON201ApplicationJSONObject = out
		}
	}

	return res, nil
}

// PostSpacesSpaceIDFoldersIDSocialDeclarationsMultipart - Add a social declaration
func (s *SDK) PostSpacesSpaceIDFoldersIDSocialDeclarationsMultipart(ctx context.Context, request operations.PostSpacesSpaceIDFoldersIDSocialDeclarationsMultipartRequest, security operations.PostSpacesSpaceIDFoldersIDSocialDeclarationsMultipartSecurity) (*operations.PostSpacesSpaceIDFoldersIDSocialDeclarationsMultipartResponse, error) {
	baseURL := s._serverURL
	url := utils.GenerateURL(ctx, baseURL, "/spaces/{spaceId}/folders/{id}/social-declarations", request, nil)

	bodyReader, reqContentType, err := utils.SerializeRequestBody(ctx, request, "RequestBody", "multipart")
	if err != nil {
		return nil, fmt.Errorf("error serializing request body: %w", err)
	}
	if bodyReader == nil {
		return nil, fmt.Errorf("request body is required")
	}

	req, err := http.NewRequestWithContext(ctx, "POST", url, bodyReader)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	req.Header.Set("Content-Type", reqContentType)

	client := utils.ConfigureSecurityClient(s._defaultClient, security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.PostSpacesSpaceIDFoldersIDSocialDeclarationsMultipartResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 201:
		res.Headers = httpRes.Header

		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *operations.PostSpacesSpaceIDFoldersIDSocialDeclarationsMultipart201ApplicationJSON
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.PostSpacesSpaceIDFoldersIDSocialDeclarationsMultipart201ApplicationJSONObject = out
		}
	}

	return res, nil
}

// PostSpacesSpaceIDFoldersIDVatDeclarationsJSON - Add a vat declaration
func (s *SDK) PostSpacesSpaceIDFoldersIDVatDeclarationsJSON(ctx context.Context, request operations.PostSpacesSpaceIDFoldersIDVatDeclarationsJSONRequest, security operations.PostSpacesSpaceIDFoldersIDVatDeclarationsJSONSecurity) (*operations.PostSpacesSpaceIDFoldersIDVatDeclarationsJSONResponse, error) {
	baseURL := s._serverURL
	url := utils.GenerateURL(ctx, baseURL, "/spaces/{spaceId}/folders/{id}/vat-declarations", request, nil)

	bodyReader, reqContentType, err := utils.SerializeRequestBody(ctx, request, "RequestBody", "json")
	if err != nil {
		return nil, fmt.Errorf("error serializing request body: %w", err)
	}
	if bodyReader == nil {
		return nil, fmt.Errorf("request body is required")
	}

	req, err := http.NewRequestWithContext(ctx, "POST", url, bodyReader)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	req.Header.Set("Content-Type", reqContentType)

	client := utils.ConfigureSecurityClient(s._defaultClient, security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.PostSpacesSpaceIDFoldersIDVatDeclarationsJSONResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 201:
		res.Headers = httpRes.Header

		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *operations.PostSpacesSpaceIDFoldersIDVatDeclarationsJSON201ApplicationJSON
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.PostSpacesSpaceIDFoldersIDVatDeclarationsJSON201ApplicationJSONObject = out
		}
	}

	return res, nil
}

// PostSpacesSpaceIDFoldersIDVatDeclarationsMultipart - Add a vat declaration
func (s *SDK) PostSpacesSpaceIDFoldersIDVatDeclarationsMultipart(ctx context.Context, request operations.PostSpacesSpaceIDFoldersIDVatDeclarationsMultipartRequest, security operations.PostSpacesSpaceIDFoldersIDVatDeclarationsMultipartSecurity) (*operations.PostSpacesSpaceIDFoldersIDVatDeclarationsMultipartResponse, error) {
	baseURL := s._serverURL
	url := utils.GenerateURL(ctx, baseURL, "/spaces/{spaceId}/folders/{id}/vat-declarations", request, nil)

	bodyReader, reqContentType, err := utils.SerializeRequestBody(ctx, request, "RequestBody", "multipart")
	if err != nil {
		return nil, fmt.Errorf("error serializing request body: %w", err)
	}
	if bodyReader == nil {
		return nil, fmt.Errorf("request body is required")
	}

	req, err := http.NewRequestWithContext(ctx, "POST", url, bodyReader)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	req.Header.Set("Content-Type", reqContentType)

	client := utils.ConfigureSecurityClient(s._defaultClient, security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.PostSpacesSpaceIDFoldersIDVatDeclarationsMultipartResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 201:
		res.Headers = httpRes.Header

		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *operations.PostSpacesSpaceIDFoldersIDVatDeclarationsMultipart201ApplicationJSON
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.PostSpacesSpaceIDFoldersIDVatDeclarationsMultipart201ApplicationJSONObject = out
		}
	}

	return res, nil
}

// PostSpacesSpaceIDFoldersIDDocumentClassJSON - Add a document in a folder
func (s *SDK) PostSpacesSpaceIDFoldersIDDocumentClassJSON(ctx context.Context, request operations.PostSpacesSpaceIDFoldersIDDocumentClassJSONRequest, security operations.PostSpacesSpaceIDFoldersIDDocumentClassJSONSecurity) (*operations.PostSpacesSpaceIDFoldersIDDocumentClassJSONResponse, error) {
	baseURL := s._serverURL
	url := utils.GenerateURL(ctx, baseURL, "/spaces/{spaceId}/folders/{id}/{documentClass}", request, nil)

	bodyReader, reqContentType, err := utils.SerializeRequestBody(ctx, request, "RequestBody", "json")
	if err != nil {
		return nil, fmt.Errorf("error serializing request body: %w", err)
	}
	if bodyReader == nil {
		return nil, fmt.Errorf("request body is required")
	}

	req, err := http.NewRequestWithContext(ctx, "POST", url, bodyReader)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	req.Header.Set("Content-Type", reqContentType)

	client := utils.ConfigureSecurityClient(s._defaultClient, security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.PostSpacesSpaceIDFoldersIDDocumentClassJSONResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 201:
		res.Headers = httpRes.Header

		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *operations.PostSpacesSpaceIDFoldersIDDocumentClassJSON201ApplicationJSON
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.PostSpacesSpaceIDFoldersIDDocumentClassJSON201ApplicationJSONObject = out
		}
	}

	return res, nil
}

// PostSpacesSpaceIDFoldersIDDocumentClassMultipart - Add a document in a folder
func (s *SDK) PostSpacesSpaceIDFoldersIDDocumentClassMultipart(ctx context.Context, request operations.PostSpacesSpaceIDFoldersIDDocumentClassMultipartRequest, security operations.PostSpacesSpaceIDFoldersIDDocumentClassMultipartSecurity) (*operations.PostSpacesSpaceIDFoldersIDDocumentClassMultipartResponse, error) {
	baseURL := s._serverURL
	url := utils.GenerateURL(ctx, baseURL, "/spaces/{spaceId}/folders/{id}/{documentClass}", request, nil)

	bodyReader, reqContentType, err := utils.SerializeRequestBody(ctx, request, "RequestBody", "multipart")
	if err != nil {
		return nil, fmt.Errorf("error serializing request body: %w", err)
	}
	if bodyReader == nil {
		return nil, fmt.Errorf("request body is required")
	}

	req, err := http.NewRequestWithContext(ctx, "POST", url, bodyReader)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	req.Header.Set("Content-Type", reqContentType)

	client := utils.ConfigureSecurityClient(s._defaultClient, security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.PostSpacesSpaceIDFoldersIDDocumentClassMultipartResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 201:
		res.Headers = httpRes.Header

		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *operations.PostSpacesSpaceIDFoldersIDDocumentClassMultipart201ApplicationJSON
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.PostSpacesSpaceIDFoldersIDDocumentClassMultipart201ApplicationJSONObject = out
		}
	}

	return res, nil
}

// PostSpacesSpaceIDLegalEntitiesIDBanks - Add a folder for a bank
func (s *SDK) PostSpacesSpaceIDLegalEntitiesIDBanks(ctx context.Context, request operations.PostSpacesSpaceIDLegalEntitiesIDBanksRequest, security operations.PostSpacesSpaceIDLegalEntitiesIDBanksSecurity) (*operations.PostSpacesSpaceIDLegalEntitiesIDBanksResponse, error) {
	baseURL := s._serverURL
	url := utils.GenerateURL(ctx, baseURL, "/spaces/{spaceId}/legal-entities/{id}/banks", request, nil)

	bodyReader, reqContentType, err := utils.SerializeRequestBody(ctx, request, "RequestBody", "json")
	if err != nil {
		return nil, fmt.Errorf("error serializing request body: %w", err)
	}
	if bodyReader == nil {
		return nil, fmt.Errorf("request body is required")
	}

	req, err := http.NewRequestWithContext(ctx, "POST", url, bodyReader)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	req.Header.Set("Content-Type", reqContentType)

	client := utils.ConfigureSecurityClient(s._defaultClient, security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.PostSpacesSpaceIDLegalEntitiesIDBanksResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 201:
		res.Headers = httpRes.Header

		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *operations.PostSpacesSpaceIDLegalEntitiesIDBanks201ApplicationJSON
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.PostSpacesSpaceIDLegalEntitiesIDBanks201ApplicationJSONObject = out
		}
	}

	return res, nil
}

// PostSpacesSpaceIDLegalEntitiesIDCustomers - Add a folder for a customer
func (s *SDK) PostSpacesSpaceIDLegalEntitiesIDCustomers(ctx context.Context, request operations.PostSpacesSpaceIDLegalEntitiesIDCustomersRequest, security operations.PostSpacesSpaceIDLegalEntitiesIDCustomersSecurity) (*operations.PostSpacesSpaceIDLegalEntitiesIDCustomersResponse, error) {
	baseURL := s._serverURL
	url := utils.GenerateURL(ctx, baseURL, "/spaces/{spaceId}/legal-entities/{id}/customers", request, nil)

	bodyReader, reqContentType, err := utils.SerializeRequestBody(ctx, request, "RequestBody", "json")
	if err != nil {
		return nil, fmt.Errorf("error serializing request body: %w", err)
	}
	if bodyReader == nil {
		return nil, fmt.Errorf("request body is required")
	}

	req, err := http.NewRequestWithContext(ctx, "POST", url, bodyReader)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	req.Header.Set("Content-Type", reqContentType)

	client := utils.ConfigureSecurityClient(s._defaultClient, security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.PostSpacesSpaceIDLegalEntitiesIDCustomersResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 201:
		res.Headers = httpRes.Header

		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *operations.PostSpacesSpaceIDLegalEntitiesIDCustomers201ApplicationJSON
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.PostSpacesSpaceIDLegalEntitiesIDCustomers201ApplicationJSONObject = out
		}
	}

	return res, nil
}

// PostSpacesSpaceIDLegalEntitiesIDInsurances - Add a folder for a insurance
func (s *SDK) PostSpacesSpaceIDLegalEntitiesIDInsurances(ctx context.Context, request operations.PostSpacesSpaceIDLegalEntitiesIDInsurancesRequest, security operations.PostSpacesSpaceIDLegalEntitiesIDInsurancesSecurity) (*operations.PostSpacesSpaceIDLegalEntitiesIDInsurancesResponse, error) {
	baseURL := s._serverURL
	url := utils.GenerateURL(ctx, baseURL, "/spaces/{spaceId}/legal-entities/{id}/insurances", request, nil)

	bodyReader, reqContentType, err := utils.SerializeRequestBody(ctx, request, "RequestBody", "json")
	if err != nil {
		return nil, fmt.Errorf("error serializing request body: %w", err)
	}
	if bodyReader == nil {
		return nil, fmt.Errorf("request body is required")
	}

	req, err := http.NewRequestWithContext(ctx, "POST", url, bodyReader)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	req.Header.Set("Content-Type", reqContentType)

	client := utils.ConfigureSecurityClient(s._defaultClient, security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.PostSpacesSpaceIDLegalEntitiesIDInsurancesResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 201:
		res.Headers = httpRes.Header

		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *operations.PostSpacesSpaceIDLegalEntitiesIDInsurances201ApplicationJSON
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.PostSpacesSpaceIDLegalEntitiesIDInsurances201ApplicationJSONObject = out
		}
	}

	return res, nil
}

// PostSpacesSpaceIDLegalEntitiesIDLoans - Add a folder for a loan
func (s *SDK) PostSpacesSpaceIDLegalEntitiesIDLoans(ctx context.Context, request operations.PostSpacesSpaceIDLegalEntitiesIDLoansRequest, security operations.PostSpacesSpaceIDLegalEntitiesIDLoansSecurity) (*operations.PostSpacesSpaceIDLegalEntitiesIDLoansResponse, error) {
	baseURL := s._serverURL
	url := utils.GenerateURL(ctx, baseURL, "/spaces/{spaceId}/legal-entities/{id}/loans", request, nil)

	bodyReader, reqContentType, err := utils.SerializeRequestBody(ctx, request, "RequestBody", "json")
	if err != nil {
		return nil, fmt.Errorf("error serializing request body: %w", err)
	}
	if bodyReader == nil {
		return nil, fmt.Errorf("request body is required")
	}

	req, err := http.NewRequestWithContext(ctx, "POST", url, bodyReader)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	req.Header.Set("Content-Type", reqContentType)

	client := utils.ConfigureSecurityClient(s._defaultClient, security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.PostSpacesSpaceIDLegalEntitiesIDLoansResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 201:
		res.Headers = httpRes.Header

		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *operations.PostSpacesSpaceIDLegalEntitiesIDLoans201ApplicationJSON
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.PostSpacesSpaceIDLegalEntitiesIDLoans201ApplicationJSONObject = out
		}
	}

	return res, nil
}

// PostSpacesSpaceIDLegalEntitiesIDProviders - Add a folder for a provider
func (s *SDK) PostSpacesSpaceIDLegalEntitiesIDProviders(ctx context.Context, request operations.PostSpacesSpaceIDLegalEntitiesIDProvidersRequest, security operations.PostSpacesSpaceIDLegalEntitiesIDProvidersSecurity) (*operations.PostSpacesSpaceIDLegalEntitiesIDProvidersResponse, error) {
	baseURL := s._serverURL
	url := utils.GenerateURL(ctx, baseURL, "/spaces/{spaceId}/legal-entities/{id}/providers", request, nil)

	bodyReader, reqContentType, err := utils.SerializeRequestBody(ctx, request, "RequestBody", "json")
	if err != nil {
		return nil, fmt.Errorf("error serializing request body: %w", err)
	}
	if bodyReader == nil {
		return nil, fmt.Errorf("request body is required")
	}

	req, err := http.NewRequestWithContext(ctx, "POST", url, bodyReader)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	req.Header.Set("Content-Type", reqContentType)

	client := utils.ConfigureSecurityClient(s._defaultClient, security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.PostSpacesSpaceIDLegalEntitiesIDProvidersResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 201:
		res.Headers = httpRes.Header

		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *operations.PostSpacesSpaceIDLegalEntitiesIDProviders201ApplicationJSON
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.PostSpacesSpaceIDLegalEntitiesIDProviders201ApplicationJSONObject = out
		}
	}

	return res, nil
}

// PostSpacesSpaceIDLegalEntitiesIDSocialRegimes - Add a folder for a social regime
func (s *SDK) PostSpacesSpaceIDLegalEntitiesIDSocialRegimes(ctx context.Context, request operations.PostSpacesSpaceIDLegalEntitiesIDSocialRegimesRequest, security operations.PostSpacesSpaceIDLegalEntitiesIDSocialRegimesSecurity) (*operations.PostSpacesSpaceIDLegalEntitiesIDSocialRegimesResponse, error) {
	baseURL := s._serverURL
	url := utils.GenerateURL(ctx, baseURL, "/spaces/{spaceId}/legal-entities/{id}/social-regimes", request, nil)

	bodyReader, reqContentType, err := utils.SerializeRequestBody(ctx, request, "RequestBody", "json")
	if err != nil {
		return nil, fmt.Errorf("error serializing request body: %w", err)
	}
	if bodyReader == nil {
		return nil, fmt.Errorf("request body is required")
	}

	req, err := http.NewRequestWithContext(ctx, "POST", url, bodyReader)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	req.Header.Set("Content-Type", reqContentType)

	client := utils.ConfigureSecurityClient(s._defaultClient, security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.PostSpacesSpaceIDLegalEntitiesIDSocialRegimesResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 201:
		res.Headers = httpRes.Header

		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *operations.PostSpacesSpaceIDLegalEntitiesIDSocialRegimes201ApplicationJSON
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.PostSpacesSpaceIDLegalEntitiesIDSocialRegimes201ApplicationJSONObject = out
		}
	}

	return res, nil
}

// PostSpacesSpaceIDPersonsIDCallForDocument - invite a person to collect documents
func (s *SDK) PostSpacesSpaceIDPersonsIDCallForDocument(ctx context.Context, request operations.PostSpacesSpaceIDPersonsIDCallForDocumentRequest, security operations.PostSpacesSpaceIDPersonsIDCallForDocumentSecurity) (*operations.PostSpacesSpaceIDPersonsIDCallForDocumentResponse, error) {
	baseURL := s._serverURL
	url := utils.GenerateURL(ctx, baseURL, "/spaces/{spaceId}/persons/{id}/call-for-document", request, nil)

	bodyReader, reqContentType, err := utils.SerializeRequestBody(ctx, request, "CallForDocument", "json")
	if err != nil {
		return nil, fmt.Errorf("error serializing request body: %w", err)
	}
	if bodyReader == nil {
		return nil, fmt.Errorf("request body is required")
	}

	req, err := http.NewRequestWithContext(ctx, "POST", url, bodyReader)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	req.Header.Set("Content-Type", reqContentType)

	client := utils.ConfigureSecurityClient(s._defaultClient, security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.PostSpacesSpaceIDPersonsIDCallForDocumentResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 201:
		res.Headers = httpRes.Header

		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *operations.PostSpacesSpaceIDPersonsIDCallForDocument201ApplicationJSON
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.PostSpacesSpaceIDPersonsIDCallForDocument201ApplicationJSONObject = out
		}
	}

	return res, nil
}

// PostSpacesSpaceIDPersonsIDEmployees - Add a folder for a employee
func (s *SDK) PostSpacesSpaceIDPersonsIDEmployees(ctx context.Context, request operations.PostSpacesSpaceIDPersonsIDEmployeesRequest, security operations.PostSpacesSpaceIDPersonsIDEmployeesSecurity) (*operations.PostSpacesSpaceIDPersonsIDEmployeesResponse, error) {
	baseURL := s._serverURL
	url := utils.GenerateURL(ctx, baseURL, "/spaces/{spaceId}/persons/{id}/employees", request, nil)

	bodyReader, reqContentType, err := utils.SerializeRequestBody(ctx, request, "RequestBody", "json")
	if err != nil {
		return nil, fmt.Errorf("error serializing request body: %w", err)
	}
	if bodyReader == nil {
		return nil, fmt.Errorf("request body is required")
	}

	req, err := http.NewRequestWithContext(ctx, "POST", url, bodyReader)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	req.Header.Set("Content-Type", reqContentType)

	client := utils.ConfigureSecurityClient(s._defaultClient, security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.PostSpacesSpaceIDPersonsIDEmployeesResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 201:
		res.Headers = httpRes.Header

		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *operations.PostSpacesSpaceIDPersonsIDEmployees201ApplicationJSON
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.PostSpacesSpaceIDPersonsIDEmployees201ApplicationJSONObject = out
		}
	}

	return res, nil
}

// PostSpacesSpaceIDPersonsIDGuestInSpace - invite a person in a space
func (s *SDK) PostSpacesSpaceIDPersonsIDGuestInSpace(ctx context.Context, request operations.PostSpacesSpaceIDPersonsIDGuestInSpaceRequest, security operations.PostSpacesSpaceIDPersonsIDGuestInSpaceSecurity) (*operations.PostSpacesSpaceIDPersonsIDGuestInSpaceResponse, error) {
	baseURL := s._serverURL
	url := utils.GenerateURL(ctx, baseURL, "/spaces/{spaceId}/persons/{id}/guest-in-space", request, nil)

	bodyReader, reqContentType, err := utils.SerializeRequestBody(ctx, request, "GuestInSpace", "json")
	if err != nil {
		return nil, fmt.Errorf("error serializing request body: %w", err)
	}
	if bodyReader == nil {
		return nil, fmt.Errorf("request body is required")
	}

	req, err := http.NewRequestWithContext(ctx, "POST", url, bodyReader)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	req.Header.Set("Content-Type", reqContentType)

	client := utils.ConfigureSecurityClient(s._defaultClient, security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.PostSpacesSpaceIDPersonsIDGuestInSpaceResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 204:
	}

	return res, nil
}

// PostSpacesSpaceIDPersonsIDInvitation - create an invitation in a space for a person
func (s *SDK) PostSpacesSpaceIDPersonsIDInvitation(ctx context.Context, request operations.PostSpacesSpaceIDPersonsIDInvitationRequest, security operations.PostSpacesSpaceIDPersonsIDInvitationSecurity) (*operations.PostSpacesSpaceIDPersonsIDInvitationResponse, error) {
	baseURL := s._serverURL
	url := utils.GenerateURL(ctx, baseURL, "/spaces/{spaceId}/persons/{id}/invitation", request, nil)

	bodyReader, reqContentType, err := utils.SerializeRequestBody(ctx, request, "RequestBody", "json")
	if err != nil {
		return nil, fmt.Errorf("error serializing request body: %w", err)
	}
	if bodyReader == nil {
		return nil, fmt.Errorf("request body is required")
	}

	req, err := http.NewRequestWithContext(ctx, "POST", url, bodyReader)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	req.Header.Set("Content-Type", reqContentType)

	client := utils.ConfigureSecurityClient(s._defaultClient, security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.PostSpacesSpaceIDPersonsIDInvitationResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 201:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *operations.PostSpacesSpaceIDPersonsIDInvitation201ApplicationJSON
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.PostSpacesSpaceIDPersonsIDInvitation201ApplicationJSONObject = out
		}
	}

	return res, nil
}

// PostSpacesSpaceIDPersonsIDInvitationInvitationIDSend - send the invitation of a person in a space
func (s *SDK) PostSpacesSpaceIDPersonsIDInvitationInvitationIDSend(ctx context.Context, request operations.PostSpacesSpaceIDPersonsIDInvitationInvitationIDSendRequest, security operations.PostSpacesSpaceIDPersonsIDInvitationInvitationIDSendSecurity) (*operations.PostSpacesSpaceIDPersonsIDInvitationInvitationIDSendResponse, error) {
	baseURL := s._serverURL
	url := utils.GenerateURL(ctx, baseURL, "/spaces/{spaceId}/persons/{id}/invitation/{invitationId}/send", request, nil)

	bodyReader, reqContentType, err := utils.SerializeRequestBody(ctx, request, "RequestBody", "json")
	if err != nil {
		return nil, fmt.Errorf("error serializing request body: %w", err)
	}
	if bodyReader == nil {
		return nil, fmt.Errorf("request body is required")
	}

	req, err := http.NewRequestWithContext(ctx, "POST", url, bodyReader)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	req.Header.Set("Content-Type", reqContentType)

	client := utils.ConfigureSecurityClient(s._defaultClient, security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.PostSpacesSpaceIDPersonsIDInvitationInvitationIDSendResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 201:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *operations.PostSpacesSpaceIDPersonsIDInvitationInvitationIDSend201ApplicationJSON
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.PostSpacesSpaceIDPersonsIDInvitationInvitationIDSend201ApplicationJSONObject = out
		}
	}

	return res, nil
}
