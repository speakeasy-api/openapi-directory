<?php

/**
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

declare(strict_types=1);

namespace OpenAPI\OpenAPI;

class Source 
{

	// SDK private variables namespaced with _ to avoid conflicts with API models
	private \GuzzleHttp\ClientInterface $_defaultClient;
	private \GuzzleHttp\ClientInterface $_securityClient;
	private string $_serverUrl;
	private string $_language;
	private string $_sdkVersion;
	private string $_genVersion;	

	/**
	 * @param \GuzzleHttp\ClientInterface $defaultClient
	 * @param \GuzzleHttp\ClientInterface $securityClient
	 * @param string $serverUrl
	 * @param string $language
	 * @param string $sdkVersion
	 * @param string $genVersion
	 */
	public function __construct(\GuzzleHttp\ClientInterface $defaultClient, \GuzzleHttp\ClientInterface $securityClient, string $serverUrl, string $language, string $sdkVersion, string $genVersion)
	{
		$this->_defaultClient = $defaultClient;
		$this->_securityClient = $securityClient;
		$this->_serverUrl = $serverUrl;
		$this->_language = $language;
		$this->_sdkVersion = $sdkVersion;
		$this->_genVersion = $genVersion;
	}
	
    /**
     * Incremental Refresh an existing Source
     * 
     * Incremental Refresh a source object
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\IncrementalRefreshSourceRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\IncrementalRefreshSourceResponse
     */
	public function incrementalRefreshSource(
        \OpenAPI\OpenAPI\Models\Operations\IncrementalRefreshSourceRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\IncrementalRefreshSourceResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/sources/{id}/incremental_refresh', \OpenAPI\OpenAPI\Models\Operations\IncrementalRefreshSourceRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_securityClient->request('PATCH', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\IncrementalRefreshSourceResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 204 or $httpResponse->getStatusCode() === 400 or $httpResponse->getStatusCode() === 404 or $httpResponse->getStatusCode() === 429) {
        }

        return $response;
    }
	
    /**
     * List ServiceInstances for Source
     * 
     * Returns an array of ServiceInstance objects
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\ListSourceServiceInstancesRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\ListSourceServiceInstancesResponse
     */
	public function listSourceServiceInstances(
        \OpenAPI\OpenAPI\Models\Operations\ListSourceServiceInstancesRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\ListSourceServiceInstancesResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/sources/{id}/service_instances', \OpenAPI\OpenAPI\Models\Operations\ListSourceServiceInstancesRequest::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\ListSourceServiceInstancesRequest::class, $request, null));
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\ListSourceServiceInstancesResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->serviceInstancesCollection = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\ServiceInstancesCollection', 'json');
            }
        }
        else if ($httpResponse->getStatusCode() === 404) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->errorNotFound = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\ErrorNotFound', 'json');
            }
        }

        return $response;
    }
	
    /**
     * List ServiceInventories for Source
     * 
     * Returns an array of ServiceInventory objects
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\ListSourceServiceInventoriesRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\ListSourceServiceInventoriesResponse
     */
	public function listSourceServiceInventories(
        \OpenAPI\OpenAPI\Models\Operations\ListSourceServiceInventoriesRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\ListSourceServiceInventoriesResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/sources/{id}/service_inventories', \OpenAPI\OpenAPI\Models\Operations\ListSourceServiceInventoriesRequest::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\ListSourceServiceInventoriesRequest::class, $request, null));
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\ListSourceServiceInventoriesResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->serviceInventoriesCollection = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\ServiceInventoriesCollection', 'json');
            }
        }
        else if ($httpResponse->getStatusCode() === 404) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->errorNotFound = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\ErrorNotFound', 'json');
            }
        }

        return $response;
    }
	
    /**
     * List ServiceOfferingNodes for Source
     * 
     * Returns an array of ServiceOfferingNode objects
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\ListSourceServiceOfferingNodesRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\ListSourceServiceOfferingNodesResponse
     */
	public function listSourceServiceOfferingNodes(
        \OpenAPI\OpenAPI\Models\Operations\ListSourceServiceOfferingNodesRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\ListSourceServiceOfferingNodesResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/sources/{id}/service_offering_nodes', \OpenAPI\OpenAPI\Models\Operations\ListSourceServiceOfferingNodesRequest::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\ListSourceServiceOfferingNodesRequest::class, $request, null));
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\ListSourceServiceOfferingNodesResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->serviceOfferingNodesCollection = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\ServiceOfferingNodesCollection', 'json');
            }
        }
        else if ($httpResponse->getStatusCode() === 404) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->errorNotFound = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\ErrorNotFound', 'json');
            }
        }

        return $response;
    }
	
    /**
     * List ServiceOfferings for Source
     * 
     * Returns an array of ServiceOffering objects
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\ListSourceServiceOfferingsRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\ListSourceServiceOfferingsResponse
     */
	public function listSourceServiceOfferings(
        \OpenAPI\OpenAPI\Models\Operations\ListSourceServiceOfferingsRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\ListSourceServiceOfferingsResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/sources/{id}/service_offerings', \OpenAPI\OpenAPI\Models\Operations\ListSourceServiceOfferingsRequest::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\ListSourceServiceOfferingsRequest::class, $request, null));
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\ListSourceServiceOfferingsResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->serviceOfferingsCollection = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\ServiceOfferingsCollection', 'json');
            }
        }
        else if ($httpResponse->getStatusCode() === 404) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->errorNotFound = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\ErrorNotFound', 'json');
            }
        }

        return $response;
    }
	
    /**
     * List ServicePlans for Source
     * 
     * Returns an array of ServicePlan objects
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\ListSourceServicePlansRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\ListSourceServicePlansResponse
     */
	public function listSourceServicePlans(
        \OpenAPI\OpenAPI\Models\Operations\ListSourceServicePlansRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\ListSourceServicePlansResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/sources/{id}/service_plans', \OpenAPI\OpenAPI\Models\Operations\ListSourceServicePlansRequest::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\ListSourceServicePlansRequest::class, $request, null));
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\ListSourceServicePlansResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->servicePlansCollection = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\ServicePlansCollection', 'json');
            }
        }
        else if ($httpResponse->getStatusCode() === 404) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->errorNotFound = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\ErrorNotFound', 'json');
            }
        }

        return $response;
    }
	
    /**
     * List Tasks for Source
     * 
     * Returns an array of Task objects
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\ListSourceTasksRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\ListSourceTasksResponse
     */
	public function listSourceTasks(
        \OpenAPI\OpenAPI\Models\Operations\ListSourceTasksRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\ListSourceTasksResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/sources/{id}/tasks', \OpenAPI\OpenAPI\Models\Operations\ListSourceTasksRequest::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\ListSourceTasksRequest::class, $request, null));
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\ListSourceTasksResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->tasksCollection = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\TasksCollection', 'json');
            }
        }
        else if ($httpResponse->getStatusCode() === 404) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->errorNotFound = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\ErrorNotFound', 'json');
            }
        }

        return $response;
    }
	
    /**
     * List Sources
     * 
     * Returns an array of Source objects
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\ListSourcesRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\ListSourcesResponse
     */
	public function listSources(
        \OpenAPI\OpenAPI\Models\Operations\ListSourcesRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\ListSourcesResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/sources');
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\ListSourcesRequest::class, $request, null));
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\ListSourcesResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->sourcesCollection = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\SourcesCollection', 'json');
            }
        }

        return $response;
    }
	
    /**
     *  Refresh an existing Source
     * 
     * Refresh a source object
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\RefreshSourceRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\RefreshSourceResponse
     */
	public function refreshSource(
        \OpenAPI\OpenAPI\Models\Operations\RefreshSourceRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\RefreshSourceResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/sources/{id}/refresh', \OpenAPI\OpenAPI\Models\Operations\RefreshSourceRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_securityClient->request('PATCH', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\RefreshSourceResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 204 or $httpResponse->getStatusCode() === 400 or $httpResponse->getStatusCode() === 404 or $httpResponse->getStatusCode() === 429) {
        }

        return $response;
    }
	
    /**
     * Show an existing Source
     * 
     * Returns a Source object
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\ShowSourceRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\ShowSourceResponse
     */
	public function showSource(
        \OpenAPI\OpenAPI\Models\Operations\ShowSourceRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\ShowSourceResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/sources/{id}', \OpenAPI\OpenAPI\Models\Operations\ShowSourceRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\ShowSourceResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->source = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\Source', 'json');
            }
        }
        else if ($httpResponse->getStatusCode() === 404) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->errorNotFound = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\ErrorNotFound', 'json');
            }
        }

        return $response;
    }
}