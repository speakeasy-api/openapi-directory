/*
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

import * as utils from "../internal/utils";
import * as operations from "./models/operations";
import * as shared from "./models/shared";
import { AxiosInstance, AxiosRequestConfig, AxiosResponse } from "axios";

/**
 * Interact with and view information about users and also current user.
 */
export class Users {
  _defaultClient: AxiosInstance;
  _securityClient: AxiosInstance;
  _serverURL: string;
  _language: string;
  _sdkVersion: string;
  _genVersion: string;

  constructor(
    defaultClient: AxiosInstance,
    securityClient: AxiosInstance,
    serverURL: string,
    language: string,
    sdkVersion: string,
    genVersion: string
  ) {
    this._defaultClient = defaultClient;
    this._securityClient = securityClient;
    this._serverURL = serverURL;
    this._language = language;
    this._sdkVersion = sdkVersion;
    this._genVersion = genVersion;
  }

  /**
   * Add an email address for the authenticated user
   *
   * @remarks
   * This endpoint is accessible with the `user` scope.
   *
   * @see {@link https://docs.github.com/enterprise-server@3.3/rest/reference/users#add-an-email-address-for-the-authenticated-user} - API method documentation
   */
  usersAddEmailForAuthenticatedUser(
    req: any,
    config?: AxiosRequestConfig
  ): Promise<operations.UsersAddEmailForAuthenticatedUserResponse> {
    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/user/emails";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "request",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UsersAddEmailForAuthenticatedUserResponse =
        new operations.UsersAddEmailForAuthenticatedUserResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.emails = [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.emails = utils.objectToClass(
              httpRes?.data,
              shared.Email,
              resFieldDepth
            );
          }
          break;
        case httpRes?.status == 304:
          break;
        case [401, 403, 404].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.basicError = utils.objectToClass(
              httpRes?.data,
              shared.BasicError
            );
          }
          break;
        case httpRes?.status == 422:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.validationError = utils.objectToClass(
              httpRes?.data,
              shared.ValidationError
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Check if a user follows another user
   *
   * @see {@link https://docs.github.com/enterprise-server@3.3/rest/reference/users#check-if-a-user-follows-another-user} - API method documentation
   */
  usersCheckFollowingForUser(
    req: operations.UsersCheckFollowingForUserRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.UsersCheckFollowingForUserResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.UsersCheckFollowingForUserRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/users/{username}/following/{target_user}",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UsersCheckFollowingForUserResponse =
        new operations.UsersCheckFollowingForUserResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case [204, 404].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Check if a person is followed by the authenticated user
   *
   * @see {@link https://docs.github.com/enterprise-server@3.3/rest/reference/users#check-if-a-person-is-followed-by-the-authenticated-user} - API method documentation
   */
  usersCheckPersonIsFollowedByAuthenticated(
    req: operations.UsersCheckPersonIsFollowedByAuthenticatedRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.UsersCheckPersonIsFollowedByAuthenticatedResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.UsersCheckPersonIsFollowedByAuthenticatedRequest(
        req
      );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/user/following/{username}",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UsersCheckPersonIsFollowedByAuthenticatedResponse =
        new operations.UsersCheckPersonIsFollowedByAuthenticatedResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case [204, 304].includes(httpRes?.status):
          break;
        case [401, 403, 404].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.basicError = utils.objectToClass(
              httpRes?.data,
              shared.BasicError
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Create a GPG key for the authenticated user
   *
   * @remarks
   * Adds a GPG key to the authenticated user's GitHub account. Requires that you are authenticated via Basic Auth, or OAuth with at least `write:gpg_key` [scope](https://docs.github.com/enterprise-server@3.3/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).
   *
   * @see {@link https://docs.github.com/enterprise-server@3.3/rest/reference/users#create-a-gpg-key-for-the-authenticated-user} - API method documentation
   */
  usersCreateGpgKeyForAuthenticatedUser(
    req: operations.UsersCreateGpgKeyForAuthenticatedUserRequestBody,
    config?: AxiosRequestConfig
  ): Promise<operations.UsersCreateGpgKeyForAuthenticatedUserResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.UsersCreateGpgKeyForAuthenticatedUserRequestBody(
        req
      );
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/user/gpg_keys";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "request",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UsersCreateGpgKeyForAuthenticatedUserResponse =
        new operations.UsersCreateGpgKeyForAuthenticatedUserResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.gpgKey = utils.objectToClass(httpRes?.data, shared.GpgKey);
          }
          break;
        case httpRes?.status == 304:
          break;
        case [401, 403, 404].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.basicError = utils.objectToClass(
              httpRes?.data,
              shared.BasicError
            );
          }
          break;
        case httpRes?.status == 422:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.validationError = utils.objectToClass(
              httpRes?.data,
              shared.ValidationError
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Create a public SSH key for the authenticated user
   *
   * @remarks
   * Adds a public SSH key to the authenticated user's GitHub account. Requires that you are authenticated via Basic Auth, or OAuth with at least `write:public_key` [scope](https://docs.github.com/enterprise-server@3.3/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).
   *
   * @see {@link https://docs.github.com/enterprise-server@3.3/rest/reference/users#create-a-public-ssh-key-for-the-authenticated-user} - API method documentation
   */
  usersCreatePublicSshKeyForAuthenticatedUser(
    req: operations.UsersCreatePublicSshKeyForAuthenticatedUserRequestBody,
    config?: AxiosRequestConfig
  ): Promise<operations.UsersCreatePublicSshKeyForAuthenticatedUserResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.UsersCreatePublicSshKeyForAuthenticatedUserRequestBody(
          req
        );
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/user/keys";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "request",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UsersCreatePublicSshKeyForAuthenticatedUserResponse =
        new operations.UsersCreatePublicSshKeyForAuthenticatedUserResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.key = utils.objectToClass(httpRes?.data, shared.Key);
          }
          break;
        case httpRes?.status == 304:
          break;
        case [401, 403, 404].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.basicError = utils.objectToClass(
              httpRes?.data,
              shared.BasicError
            );
          }
          break;
        case httpRes?.status == 422:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.validationError = utils.objectToClass(
              httpRes?.data,
              shared.ValidationError
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Delete an email address for the authenticated user
   *
   * @remarks
   * This endpoint is accessible with the `user` scope.
   *
   * @see {@link https://docs.github.com/enterprise-server@3.3/rest/reference/users#delete-an-email-address-for-the-authenticated-user} - API method documentation
   */
  usersDeleteEmailForAuthenticatedUser(
    req: any,
    config?: AxiosRequestConfig
  ): Promise<operations.UsersDeleteEmailForAuthenticatedUserResponse> {
    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/user/emails";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "request",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "delete",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UsersDeleteEmailForAuthenticatedUserResponse =
        new operations.UsersDeleteEmailForAuthenticatedUserResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case [204, 304].includes(httpRes?.status):
          break;
        case [401, 403, 404].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.basicError = utils.objectToClass(
              httpRes?.data,
              shared.BasicError
            );
          }
          break;
        case httpRes?.status == 422:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.validationError = utils.objectToClass(
              httpRes?.data,
              shared.ValidationError
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Delete a GPG key for the authenticated user
   *
   * @remarks
   * Removes a GPG key from the authenticated user's GitHub account. Requires that you are authenticated via Basic Auth or via OAuth with at least `admin:gpg_key` [scope](https://docs.github.com/enterprise-server@3.3/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).
   *
   * @see {@link https://docs.github.com/enterprise-server@3.3/rest/reference/users#delete-a-gpg-key-for-the-authenticated-user} - API method documentation
   */
  usersDeleteGpgKeyForAuthenticatedUser(
    req: operations.UsersDeleteGpgKeyForAuthenticatedUserRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.UsersDeleteGpgKeyForAuthenticatedUserResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.UsersDeleteGpgKeyForAuthenticatedUserRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/user/gpg_keys/{gpg_key_id}",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const r = client.request({
      url: url,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UsersDeleteGpgKeyForAuthenticatedUserResponse =
        new operations.UsersDeleteGpgKeyForAuthenticatedUserResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case [204, 304].includes(httpRes?.status):
          break;
        case [401, 403, 404].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.basicError = utils.objectToClass(
              httpRes?.data,
              shared.BasicError
            );
          }
          break;
        case httpRes?.status == 422:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.validationError = utils.objectToClass(
              httpRes?.data,
              shared.ValidationError
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Delete a public SSH key for the authenticated user
   *
   * @remarks
   * Removes a public SSH key from the authenticated user's GitHub account. Requires that you are authenticated via Basic Auth or via OAuth with at least `admin:public_key` [scope](https://docs.github.com/enterprise-server@3.3/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).
   *
   * @see {@link https://docs.github.com/enterprise-server@3.3/rest/reference/users#delete-a-public-ssh-key-for-the-authenticated-user} - API method documentation
   */
  usersDeletePublicSshKeyForAuthenticatedUser(
    req: operations.UsersDeletePublicSshKeyForAuthenticatedUserRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.UsersDeletePublicSshKeyForAuthenticatedUserResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.UsersDeletePublicSshKeyForAuthenticatedUserRequest(
        req
      );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(baseURL, "/user/keys/{key_id}", req);

    const client: AxiosInstance = this._defaultClient;

    const r = client.request({
      url: url,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UsersDeletePublicSshKeyForAuthenticatedUserResponse =
        new operations.UsersDeletePublicSshKeyForAuthenticatedUserResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case [204, 304].includes(httpRes?.status):
          break;
        case [401, 403, 404].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.basicError = utils.objectToClass(
              httpRes?.data,
              shared.BasicError
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Follow a user
   *
   * @remarks
   * Note that you'll need to set `Content-Length` to zero when calling out to this endpoint. For more information, see "[HTTP verbs](https://docs.github.com/enterprise-server@3.3/rest/overview/resources-in-the-rest-api#http-verbs)."
   *
   * Following a user requires the user to be logged in and authenticated with basic auth or OAuth with the `user:follow` scope.
   *
   * @see {@link https://docs.github.com/enterprise-server@3.3/rest/reference/users#follow-a-user} - API method documentation
   */
  usersFollow(
    req: operations.UsersFollowRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.UsersFollowResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.UsersFollowRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/user/following/{username}",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const r = client.request({
      url: url,
      method: "put",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UsersFollowResponse =
        new operations.UsersFollowResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case [204, 304].includes(httpRes?.status):
          break;
        case [401, 403, 404].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.basicError = utils.objectToClass(
              httpRes?.data,
              shared.BasicError
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Get the authenticated user
   *
   * @remarks
   * If the authenticated user is authenticated through basic authentication or OAuth with the `user` scope, then the response lists public and private profile information.
   *
   * If the authenticated user is authenticated through OAuth without the `user` scope, then the response lists only public profile information.
   *
   * @see {@link https://docs.github.com/enterprise-server@3.3/rest/reference/users#get-the-authenticated-user} - API method documentation
   */
  usersGetAuthenticated(
    config?: AxiosRequestConfig
  ): Promise<operations.UsersGetAuthenticatedResponse> {
    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/user";

    const client: AxiosInstance = this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UsersGetAuthenticatedResponse =
        new operations.UsersGetAuthenticatedResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.usersGetAuthenticated200ApplicationJSONOneOf = httpRes?.data;
          }
          break;
        case httpRes?.status == 304:
          break;
        case [401, 403].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.basicError = utils.objectToClass(
              httpRes?.data,
              shared.BasicError
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Get a user
   *
   * @remarks
   * Provides publicly available information about someone with a GitHub account.
   *
   * GitHub Apps with the `Plan` user permission can use this endpoint to retrieve information about a user's GitHub Enterprise Server plan. The GitHub App must be authenticated as a user. See "[Identifying and authorizing users for GitHub Apps](https://docs.github.com/enterprise-server@3.3/apps/building-github-apps/identifying-and-authorizing-users-for-github-apps/)" for details about authentication. For an example response, see 'Response with GitHub Enterprise Server plan information' below"
   *
   * The `email` key in the following response is the publicly visible email address from your GitHub Enterprise Server [profile page](https://github.com/settings/profile). When setting up your profile, you can select a primary email address to be “public” which provides an email entry for this endpoint. If you do not set a public email address for `email`, then it will have a value of `null`. You only see publicly visible email addresses when authenticated with GitHub Enterprise Server. For more information, see [Authentication](https://docs.github.com/enterprise-server@3.3/rest/overview/resources-in-the-rest-api#authentication).
   *
   * The Emails API enables you to list all of your email addresses, and toggle a primary email to be visible publicly. For more information, see "[Emails API](https://docs.github.com/enterprise-server@3.3/rest/reference/users#emails)".
   *
   * @see {@link https://docs.github.com/enterprise-server@3.3/rest/reference/users#get-a-user} - API method documentation
   */
  usersGetByUsername(
    req: operations.UsersGetByUsernameRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.UsersGetByUsernameResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.UsersGetByUsernameRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(baseURL, "/users/{username}", req);

    const client: AxiosInstance = this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UsersGetByUsernameResponse =
        new operations.UsersGetByUsernameResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.usersGetByUsername200ApplicationJSONOneOf = httpRes?.data;
          }
          break;
        case httpRes?.status == 404:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.basicError = utils.objectToClass(
              httpRes?.data,
              shared.BasicError
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Get contextual information for a user
   *
   * @remarks
   * Provides hovercard information when authenticated through basic auth or OAuth with the `repo` scope. You can find out more about someone in relation to their pull requests, issues, repositories, and organizations.
   *
   * The `subject_type` and `subject_id` parameters provide context for the person's hovercard, which returns more information than without the parameters. For example, if you wanted to find out more about `octocat` who owns the `Spoon-Knife` repository via cURL, it would look like this:
   *
   * ```shell
   *  curl -u username:token
   *   https://api.github.com/users/octocat/hovercard?subject_type=repository&subject_id=1300192
   * ```
   *
   * @see {@link https://docs.github.com/enterprise-server@3.3/rest/reference/users#get-contextual-information-for-a-user} - API method documentation
   */
  usersGetContextForUser(
    req: operations.UsersGetContextForUserRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.UsersGetContextForUserResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.UsersGetContextForUserRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/users/{username}/hovercard",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UsersGetContextForUserResponse =
        new operations.UsersGetContextForUserResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.hovercard = utils.objectToClass(
              httpRes?.data,
              shared.Hovercard
            );
          }
          break;
        case httpRes?.status == 404:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.basicError = utils.objectToClass(
              httpRes?.data,
              shared.BasicError
            );
          }
          break;
        case httpRes?.status == 422:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.validationError = utils.objectToClass(
              httpRes?.data,
              shared.ValidationError
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Get a GPG key for the authenticated user
   *
   * @remarks
   * View extended details for a single GPG key. Requires that you are authenticated via Basic Auth or via OAuth with at least `read:gpg_key` [scope](https://docs.github.com/enterprise-server@3.3/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).
   *
   * @see {@link https://docs.github.com/enterprise-server@3.3/rest/reference/users#get-a-gpg-key-for-the-authenticated-user} - API method documentation
   */
  usersGetGpgKeyForAuthenticatedUser(
    req: operations.UsersGetGpgKeyForAuthenticatedUserRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.UsersGetGpgKeyForAuthenticatedUserResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.UsersGetGpgKeyForAuthenticatedUserRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/user/gpg_keys/{gpg_key_id}",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UsersGetGpgKeyForAuthenticatedUserResponse =
        new operations.UsersGetGpgKeyForAuthenticatedUserResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.gpgKey = utils.objectToClass(httpRes?.data, shared.GpgKey);
          }
          break;
        case httpRes?.status == 304:
          break;
        case [401, 403, 404].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.basicError = utils.objectToClass(
              httpRes?.data,
              shared.BasicError
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Get a public SSH key for the authenticated user
   *
   * @remarks
   * View extended details for a single public SSH key. Requires that you are authenticated via Basic Auth or via OAuth with at least `read:public_key` [scope](https://docs.github.com/enterprise-server@3.3/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).
   *
   * @see {@link https://docs.github.com/enterprise-server@3.3/rest/reference/users#get-a-public-ssh-key-for-the-authenticated-user} - API method documentation
   */
  usersGetPublicSshKeyForAuthenticatedUser(
    req: operations.UsersGetPublicSshKeyForAuthenticatedUserRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.UsersGetPublicSshKeyForAuthenticatedUserResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.UsersGetPublicSshKeyForAuthenticatedUserRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(baseURL, "/user/keys/{key_id}", req);

    const client: AxiosInstance = this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UsersGetPublicSshKeyForAuthenticatedUserResponse =
        new operations.UsersGetPublicSshKeyForAuthenticatedUserResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.key = utils.objectToClass(httpRes?.data, shared.Key);
          }
          break;
        case httpRes?.status == 304:
          break;
        case [401, 403, 404].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.basicError = utils.objectToClass(
              httpRes?.data,
              shared.BasicError
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * List users
   *
   * @remarks
   * Lists all users, in the order that they signed up on GitHub Enterprise Server. This list includes personal user accounts and organization accounts.
   *
   * Note: Pagination is powered exclusively by the `since` parameter. Use the [Link header](https://docs.github.com/enterprise-server@3.3/rest/overview/resources-in-the-rest-api#link-header) to get the URL for the next page of users.
   *
   * @see {@link https://docs.github.com/enterprise-server@3.3/rest/reference/users#list-users} - API method documentation
   */
  usersList(
    req: operations.UsersListRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.UsersListResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.UsersListRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/users";

    const client: AxiosInstance = this._defaultClient;

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UsersListResponse =
        new operations.UsersListResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
          headers: utils.getHeadersFromResponse(httpRes.headers),
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.simpleUsers = [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.simpleUsers = utils.objectToClass(
              httpRes?.data,
              shared.SimpleUser,
              resFieldDepth
            );
          }
          break;
        case httpRes?.status == 304:
          break;
      }

      return res;
    });
  }

  /**
   * List email addresses for the authenticated user
   *
   * @remarks
   * Lists all of your email addresses, and specifies which one is visible to the public. This endpoint is accessible with the `user:email` scope.
   *
   * @see {@link https://docs.github.com/enterprise-server@3.3/rest/reference/users#list-email-addresses-for-the-authenticated-user} - API method documentation
   */
  usersListEmailsForAuthenticatedUser(
    req: operations.UsersListEmailsForAuthenticatedUserRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.UsersListEmailsForAuthenticatedUserResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.UsersListEmailsForAuthenticatedUserRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/user/emails";

    const client: AxiosInstance = this._defaultClient;

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UsersListEmailsForAuthenticatedUserResponse =
        new operations.UsersListEmailsForAuthenticatedUserResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
          headers: utils.getHeadersFromResponse(httpRes.headers),
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.emails = [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.emails = utils.objectToClass(
              httpRes?.data,
              shared.Email,
              resFieldDepth
            );
          }
          break;
        case httpRes?.status == 304:
          break;
        case [401, 403, 404].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.basicError = utils.objectToClass(
              httpRes?.data,
              shared.BasicError
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * List the people the authenticated user follows
   *
   * @remarks
   * Lists the people who the authenticated user follows.
   *
   * @see {@link https://docs.github.com/enterprise-server@3.3/rest/reference/users#list-the-people-the-authenticated-user-follows} - API method documentation
   */
  usersListFollowedByAuthenticatedUser(
    req: operations.UsersListFollowedByAuthenticatedUserRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.UsersListFollowedByAuthenticatedUserResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.UsersListFollowedByAuthenticatedUserRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/user/following";

    const client: AxiosInstance = this._defaultClient;

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UsersListFollowedByAuthenticatedUserResponse =
        new operations.UsersListFollowedByAuthenticatedUserResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
          headers: utils.getHeadersFromResponse(httpRes.headers),
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.simpleUsers = [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.simpleUsers = utils.objectToClass(
              httpRes?.data,
              shared.SimpleUser,
              resFieldDepth
            );
          }
          break;
        case httpRes?.status == 304:
          break;
        case [401, 403].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.basicError = utils.objectToClass(
              httpRes?.data,
              shared.BasicError
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * List followers of the authenticated user
   *
   * @remarks
   * Lists the people following the authenticated user.
   *
   * @see {@link https://docs.github.com/enterprise-server@3.3/rest/reference/users#list-followers-of-the-authenticated-user} - API method documentation
   */
  usersListFollowersForAuthenticatedUser(
    req: operations.UsersListFollowersForAuthenticatedUserRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.UsersListFollowersForAuthenticatedUserResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.UsersListFollowersForAuthenticatedUserRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/user/followers";

    const client: AxiosInstance = this._defaultClient;

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UsersListFollowersForAuthenticatedUserResponse =
        new operations.UsersListFollowersForAuthenticatedUserResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
          headers: utils.getHeadersFromResponse(httpRes.headers),
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.simpleUsers = [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.simpleUsers = utils.objectToClass(
              httpRes?.data,
              shared.SimpleUser,
              resFieldDepth
            );
          }
          break;
        case httpRes?.status == 304:
          break;
        case [401, 403].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.basicError = utils.objectToClass(
              httpRes?.data,
              shared.BasicError
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * List followers of a user
   *
   * @remarks
   * Lists the people following the specified user.
   *
   * @see {@link https://docs.github.com/enterprise-server@3.3/rest/reference/users#list-followers-of-a-user} - API method documentation
   */
  usersListFollowersForUser(
    req: operations.UsersListFollowersForUserRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.UsersListFollowersForUserResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.UsersListFollowersForUserRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/users/{username}/followers",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UsersListFollowersForUserResponse =
        new operations.UsersListFollowersForUserResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
          headers: utils.getHeadersFromResponse(httpRes.headers),
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.simpleUsers = [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.simpleUsers = utils.objectToClass(
              httpRes?.data,
              shared.SimpleUser,
              resFieldDepth
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * List the people a user follows
   *
   * @remarks
   * Lists the people who the specified user follows.
   *
   * @see {@link https://docs.github.com/enterprise-server@3.3/rest/reference/users#list-the-people-a-user-follows} - API method documentation
   */
  usersListFollowingForUser(
    req: operations.UsersListFollowingForUserRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.UsersListFollowingForUserResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.UsersListFollowingForUserRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/users/{username}/following",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UsersListFollowingForUserResponse =
        new operations.UsersListFollowingForUserResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
          headers: utils.getHeadersFromResponse(httpRes.headers),
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.simpleUsers = [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.simpleUsers = utils.objectToClass(
              httpRes?.data,
              shared.SimpleUser,
              resFieldDepth
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * List GPG keys for the authenticated user
   *
   * @remarks
   * Lists the current user's GPG keys. Requires that you are authenticated via Basic Auth or via OAuth with at least `read:gpg_key` [scope](https://docs.github.com/enterprise-server@3.3/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).
   *
   * @see {@link https://docs.github.com/enterprise-server@3.3/rest/reference/users#list-gpg-keys-for-the-authenticated-user} - API method documentation
   */
  usersListGpgKeysForAuthenticatedUser(
    req: operations.UsersListGpgKeysForAuthenticatedUserRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.UsersListGpgKeysForAuthenticatedUserResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.UsersListGpgKeysForAuthenticatedUserRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/user/gpg_keys";

    const client: AxiosInstance = this._defaultClient;

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UsersListGpgKeysForAuthenticatedUserResponse =
        new operations.UsersListGpgKeysForAuthenticatedUserResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
          headers: utils.getHeadersFromResponse(httpRes.headers),
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.gpgKeys = [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.gpgKeys = utils.objectToClass(
              httpRes?.data,
              shared.GpgKey,
              resFieldDepth
            );
          }
          break;
        case httpRes?.status == 304:
          break;
        case [401, 403, 404].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.basicError = utils.objectToClass(
              httpRes?.data,
              shared.BasicError
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * List GPG keys for a user
   *
   * @remarks
   * Lists the GPG keys for a user. This information is accessible by anyone.
   *
   * @see {@link https://docs.github.com/enterprise-server@3.3/rest/reference/users#list-gpg-keys-for-a-user} - API method documentation
   */
  usersListGpgKeysForUser(
    req: operations.UsersListGpgKeysForUserRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.UsersListGpgKeysForUserResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.UsersListGpgKeysForUserRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/users/{username}/gpg_keys",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UsersListGpgKeysForUserResponse =
        new operations.UsersListGpgKeysForUserResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
          headers: utils.getHeadersFromResponse(httpRes.headers),
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.gpgKeys = [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.gpgKeys = utils.objectToClass(
              httpRes?.data,
              shared.GpgKey,
              resFieldDepth
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * List public email addresses for the authenticated user
   *
   * @remarks
   * Lists your publicly visible email address, which you can set with the [Set primary email visibility for the authenticated user](https://docs.github.com/enterprise-server@3.3/rest/reference/users#set-primary-email-visibility-for-the-authenticated-user) endpoint. This endpoint is accessible with the `user:email` scope.
   *
   * @see {@link https://docs.github.com/enterprise-server@3.3/rest/reference/users#list-public-email-addresses-for-the-authenticated-user} - API method documentation
   */
  usersListPublicEmailsForAuthenticatedUser(
    req: operations.UsersListPublicEmailsForAuthenticatedUserRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.UsersListPublicEmailsForAuthenticatedUserResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.UsersListPublicEmailsForAuthenticatedUserRequest(
        req
      );
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/user/public_emails";

    const client: AxiosInstance = this._defaultClient;

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UsersListPublicEmailsForAuthenticatedUserResponse =
        new operations.UsersListPublicEmailsForAuthenticatedUserResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
          headers: utils.getHeadersFromResponse(httpRes.headers),
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.emails = [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.emails = utils.objectToClass(
              httpRes?.data,
              shared.Email,
              resFieldDepth
            );
          }
          break;
        case httpRes?.status == 304:
          break;
        case [401, 403, 404].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.basicError = utils.objectToClass(
              httpRes?.data,
              shared.BasicError
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * List public keys for a user
   *
   * @remarks
   * Lists the _verified_ public SSH keys for a user. This is accessible by anyone.
   *
   * @see {@link https://docs.github.com/enterprise-server@3.3/rest/reference/users#list-public-keys-for-a-user} - API method documentation
   */
  usersListPublicKeysForUser(
    req: operations.UsersListPublicKeysForUserRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.UsersListPublicKeysForUserResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.UsersListPublicKeysForUserRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/users/{username}/keys",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UsersListPublicKeysForUserResponse =
        new operations.UsersListPublicKeysForUserResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
          headers: utils.getHeadersFromResponse(httpRes.headers),
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.keySimples = [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.keySimples = utils.objectToClass(
              httpRes?.data,
              shared.KeySimple,
              resFieldDepth
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * List public SSH keys for the authenticated user
   *
   * @remarks
   * Lists the public SSH keys for the authenticated user's GitHub account. Requires that you are authenticated via Basic Auth or via OAuth with at least `read:public_key` [scope](https://docs.github.com/enterprise-server@3.3/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).
   *
   * @see {@link https://docs.github.com/enterprise-server@3.3/rest/reference/users#list-public-ssh-keys-for-the-authenticated-user} - API method documentation
   */
  usersListPublicSshKeysForAuthenticatedUser(
    req: operations.UsersListPublicSshKeysForAuthenticatedUserRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.UsersListPublicSshKeysForAuthenticatedUserResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.UsersListPublicSshKeysForAuthenticatedUserRequest(
        req
      );
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/user/keys";

    const client: AxiosInstance = this._defaultClient;

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UsersListPublicSshKeysForAuthenticatedUserResponse =
        new operations.UsersListPublicSshKeysForAuthenticatedUserResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
          headers: utils.getHeadersFromResponse(httpRes.headers),
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.keys = [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.keys = utils.objectToClass(
              httpRes?.data,
              shared.Key,
              resFieldDepth
            );
          }
          break;
        case httpRes?.status == 304:
          break;
        case [401, 403, 404].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.basicError = utils.objectToClass(
              httpRes?.data,
              shared.BasicError
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Unfollow a user
   *
   * @remarks
   * Unfollowing a user requires the user to be logged in and authenticated with basic auth or OAuth with the `user:follow` scope.
   *
   * @see {@link https://docs.github.com/enterprise-server@3.3/rest/reference/users#unfollow-a-user} - API method documentation
   */
  usersUnfollow(
    req: operations.UsersUnfollowRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.UsersUnfollowResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.UsersUnfollowRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/user/following/{username}",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const r = client.request({
      url: url,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UsersUnfollowResponse =
        new operations.UsersUnfollowResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case [204, 304].includes(httpRes?.status):
          break;
        case [401, 403, 404].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.basicError = utils.objectToClass(
              httpRes?.data,
              shared.BasicError
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Update the authenticated user
   *
   * @remarks
   * **Note:** If your email is set to private and you send an `email` parameter as part of this request to update your profile, your privacy settings are still enforced: the email address will not be displayed on your public profile or via the API.
   *
   * @see {@link https://docs.github.com/enterprise-server@3.3/rest/reference/users/#update-the-authenticated-user} - API method documentation
   */
  usersUpdateAuthenticated(
    req: operations.UsersUpdateAuthenticatedRequestBody,
    config?: AxiosRequestConfig
  ): Promise<operations.UsersUpdateAuthenticatedResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.UsersUpdateAuthenticatedRequestBody(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/user";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "request",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "patch",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UsersUpdateAuthenticatedResponse =
        new operations.UsersUpdateAuthenticatedResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.privateUser = utils.objectToClass(
              httpRes?.data,
              shared.PrivateUser
            );
          }
          break;
        case httpRes?.status == 304:
          break;
        case [401, 403, 404].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.basicError = utils.objectToClass(
              httpRes?.data,
              shared.BasicError
            );
          }
          break;
        case httpRes?.status == 422:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.validationError = utils.objectToClass(
              httpRes?.data,
              shared.ValidationError
            );
          }
          break;
      }

      return res;
    });
  }
}
