"use strict";
/*
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Uploads = void 0;
var utils = __importStar(require("../internal/utils"));
var operations = __importStar(require("./models/operations"));
var Uploads = /** @class */ (function () {
    function Uploads(defaultClient, securityClient, serverURL, language, sdkVersion, genVersion) {
        this._defaultClient = defaultClient;
        this._securityClient = securityClient;
        this._serverURL = serverURL;
        this._language = language;
        this._sdkVersion = sdkVersion;
        this._genVersion = genVersion;
    }
    /**
     * Abort multipart upload
     *
     * @remarks
     * This endpoint aborts the multipart upload initiated with /create-multipart.
     * This should be used when cancelling the upload. It does not matter if parts
     * were already uploaded into the external storage provider.
     *
     * You must have the correct permissions and CORS settings configured in your
     * external provider. We support AWS S3 as the default. See:
     *
     * https://meta.discourse.org/t/-/210469#s3-multipart-direct-uploads-4.
     *
     * An external file store must be set up and `enable_direct_s3_uploads` must
     * be set to true for this endpoint to function.
     *
     *
     */
    Uploads.prototype.abortMultipart = function (req, config) {
        var _a;
        if (!(req instanceof utils.SpeakeasyBase)) {
            req = new operations.AbortMultipartRequestBody(req);
        }
        var baseURL = this._serverURL;
        var url = baseURL.replace(/\/$/, "") + "/uploads/abort-multipart.json";
        var _b = [{}, {}], reqBodyHeaders = _b[0], reqBody = _b[1];
        try {
            _a = utils.serializeRequestBody(req, "request", "json"), reqBodyHeaders = _a[0], reqBody = _a[1];
        }
        catch (e) {
            if (e instanceof Error) {
                throw new Error("Error serializing request body, cause: ".concat(e.message));
            }
        }
        var client = this._defaultClient;
        var headers = __assign(__assign({}, reqBodyHeaders), config === null || config === void 0 ? void 0 : config.headers);
        var r = client.request(__assign({ url: url, method: "post", headers: headers, data: reqBody }, config));
        return r.then(function (httpRes) {
            var _a, _b;
            var contentType = (_b = (_a = httpRes === null || httpRes === void 0 ? void 0 : httpRes.headers) === null || _a === void 0 ? void 0 : _a["content-type"]) !== null && _b !== void 0 ? _b : "";
            if ((httpRes === null || httpRes === void 0 ? void 0 : httpRes.status) == null)
                throw new Error("status code not found in response: ".concat(httpRes));
            var res = new operations.AbortMultipartResponse({
                statusCode: httpRes.status,
                contentType: contentType,
                rawResponse: httpRes,
            });
            switch (true) {
                case (httpRes === null || httpRes === void 0 ? void 0 : httpRes.status) == 200:
                    if (utils.matchContentType(contentType, "application/json")) {
                        res.abortMultipart200ApplicationJSONObject = utils.objectToClass(httpRes === null || httpRes === void 0 ? void 0 : httpRes.data, operations.AbortMultipart200ApplicationJSON);
                    }
                    break;
            }
            return res;
        });
    };
    /**
     * Generates batches of presigned URLs for multipart parts
     *
     * @remarks
     * Multipart uploads are uploaded in chunks or parts to individual presigned
     * URLs, similar to the one generated by /generate-presigned-put. The part
     * numbers provided must be between 1 and 10000. The total number of parts
     * will depend on the chunk size in bytes that you intend to use to upload
     * each chunk. For example a 12MB file may have 2 5MB chunks and a final
     * 2MB chunk, for part numbers 1, 2, and 3.
     *
     * This endpoint will return a presigned URL for each part number provided,
     * which you can then use to send PUT requests for the binary chunk corresponding
     * to that part. When the part is uploaded, the provider should return an
     * ETag for the part, and this should be stored along with the part number,
     * because this is needed to complete the multipart upload.
     *
     * You must have the correct permissions and CORS settings configured in your
     * external provider. We support AWS S3 as the default. See:
     *
     * https://meta.discourse.org/t/-/210469#s3-multipart-direct-uploads-4.
     *
     * An external file store must be set up and `enable_direct_s3_uploads` must
     * be set to true for this endpoint to function.
     *
     *
     */
    Uploads.prototype.batchPresignMultipartParts = function (req, config) {
        var _a;
        if (!(req instanceof utils.SpeakeasyBase)) {
            req = new operations.BatchPresignMultipartPartsRequestBody(req);
        }
        var baseURL = this._serverURL;
        var url = baseURL.replace(/\/$/, "") +
            "/uploads/batch-presign-multipart-parts.json";
        var _b = [{}, {}], reqBodyHeaders = _b[0], reqBody = _b[1];
        try {
            _a = utils.serializeRequestBody(req, "request", "json"), reqBodyHeaders = _a[0], reqBody = _a[1];
        }
        catch (e) {
            if (e instanceof Error) {
                throw new Error("Error serializing request body, cause: ".concat(e.message));
            }
        }
        var client = this._defaultClient;
        var headers = __assign(__assign({}, reqBodyHeaders), config === null || config === void 0 ? void 0 : config.headers);
        var r = client.request(__assign({ url: url, method: "post", headers: headers, data: reqBody }, config));
        return r.then(function (httpRes) {
            var _a, _b;
            var contentType = (_b = (_a = httpRes === null || httpRes === void 0 ? void 0 : httpRes.headers) === null || _a === void 0 ? void 0 : _a["content-type"]) !== null && _b !== void 0 ? _b : "";
            if ((httpRes === null || httpRes === void 0 ? void 0 : httpRes.status) == null)
                throw new Error("status code not found in response: ".concat(httpRes));
            var res = new operations.BatchPresignMultipartPartsResponse({
                statusCode: httpRes.status,
                contentType: contentType,
                rawResponse: httpRes,
            });
            switch (true) {
                case (httpRes === null || httpRes === void 0 ? void 0 : httpRes.status) == 200:
                    if (utils.matchContentType(contentType, "application/json")) {
                        res.batchPresignMultipartParts200ApplicationJSONObject =
                            utils.objectToClass(httpRes === null || httpRes === void 0 ? void 0 : httpRes.data, operations.BatchPresignMultipartParts200ApplicationJSON);
                    }
                    break;
            }
            return res;
        });
    };
    /**
     * Completes a direct external upload
     *
     * @remarks
     * Completes an external upload initialized with /get-presigned-put. The
     * file will be moved from its temporary location in external storage to
     * a final destination in the S3 bucket. An Upload record will also be
     * created in the database in most cases.
     *
     * If a sha1-checksum was provided in the initial request it will also
     * be compared with the uploaded file in storage to make sure the same
     * file was uploaded. The file size will be compared for the same reason.
     *
     * You must have the correct permissions and CORS settings configured in your
     * external provider. We support AWS S3 as the default. See:
     *
     * https://meta.discourse.org/t/-/210469#s3-multipart-direct-uploads-4.
     *
     * An external file store must be set up and `enable_direct_s3_uploads` must
     * be set to true for this endpoint to function.
     *
     *
     */
    Uploads.prototype.completeExternalUpload = function (req, config) {
        var _a;
        if (!(req instanceof utils.SpeakeasyBase)) {
            req = new operations.CompleteExternalUploadRequestBody(req);
        }
        var baseURL = this._serverURL;
        var url = baseURL.replace(/\/$/, "") + "/uploads/complete-external-upload.json";
        var _b = [{}, {}], reqBodyHeaders = _b[0], reqBody = _b[1];
        try {
            _a = utils.serializeRequestBody(req, "request", "json"), reqBodyHeaders = _a[0], reqBody = _a[1];
        }
        catch (e) {
            if (e instanceof Error) {
                throw new Error("Error serializing request body, cause: ".concat(e.message));
            }
        }
        var client = this._defaultClient;
        var headers = __assign(__assign({}, reqBodyHeaders), config === null || config === void 0 ? void 0 : config.headers);
        var r = client.request(__assign({ url: url, method: "post", headers: headers, data: reqBody }, config));
        return r.then(function (httpRes) {
            var _a, _b;
            var contentType = (_b = (_a = httpRes === null || httpRes === void 0 ? void 0 : httpRes.headers) === null || _a === void 0 ? void 0 : _a["content-type"]) !== null && _b !== void 0 ? _b : "";
            if ((httpRes === null || httpRes === void 0 ? void 0 : httpRes.status) == null)
                throw new Error("status code not found in response: ".concat(httpRes));
            var res = new operations.CompleteExternalUploadResponse({
                statusCode: httpRes.status,
                contentType: contentType,
                rawResponse: httpRes,
            });
            switch (true) {
                case (httpRes === null || httpRes === void 0 ? void 0 : httpRes.status) == 200:
                    if (utils.matchContentType(contentType, "application/json")) {
                        res.completeExternalUpload200ApplicationJSONObject =
                            utils.objectToClass(httpRes === null || httpRes === void 0 ? void 0 : httpRes.data, operations.CompleteExternalUpload200ApplicationJSON);
                    }
                    break;
            }
            return res;
        });
    };
    /**
     * Complete multipart upload
     *
     * @remarks
     * Completes the multipart upload in the external store, and copies the
     * file from its temporary location to its final location in the store.
     * All of the parts must have been uploaded to the external storage provider.
     * An Upload record will be completed in most cases once the file is copied
     * to its final location.
     *
     * You must have the correct permissions and CORS settings configured in your
     * external provider. We support AWS S3 as the default. See:
     *
     * https://meta.discourse.org/t/-/210469#s3-multipart-direct-uploads-4.
     *
     * An external file store must be set up and `enable_direct_s3_uploads` must
     * be set to true for this endpoint to function.
     *
     *
     */
    Uploads.prototype.completeMultipart = function (req, config) {
        var _a;
        if (!(req instanceof utils.SpeakeasyBase)) {
            req = new operations.CompleteMultipartRequestBody(req);
        }
        var baseURL = this._serverURL;
        var url = baseURL.replace(/\/$/, "") + "/uploads/complete-multipart.json";
        var _b = [{}, {}], reqBodyHeaders = _b[0], reqBody = _b[1];
        try {
            _a = utils.serializeRequestBody(req, "request", "json"), reqBodyHeaders = _a[0], reqBody = _a[1];
        }
        catch (e) {
            if (e instanceof Error) {
                throw new Error("Error serializing request body, cause: ".concat(e.message));
            }
        }
        var client = this._defaultClient;
        var headers = __assign(__assign({}, reqBodyHeaders), config === null || config === void 0 ? void 0 : config.headers);
        var r = client.request(__assign({ url: url, method: "post", headers: headers, data: reqBody }, config));
        return r.then(function (httpRes) {
            var _a, _b;
            var contentType = (_b = (_a = httpRes === null || httpRes === void 0 ? void 0 : httpRes.headers) === null || _a === void 0 ? void 0 : _a["content-type"]) !== null && _b !== void 0 ? _b : "";
            if ((httpRes === null || httpRes === void 0 ? void 0 : httpRes.status) == null)
                throw new Error("status code not found in response: ".concat(httpRes));
            var res = new operations.CompleteMultipartResponse({
                statusCode: httpRes.status,
                contentType: contentType,
                rawResponse: httpRes,
            });
            switch (true) {
                case (httpRes === null || httpRes === void 0 ? void 0 : httpRes.status) == 200:
                    if (utils.matchContentType(contentType, "application/json")) {
                        res.completeMultipart200ApplicationJSONObject = utils.objectToClass(httpRes === null || httpRes === void 0 ? void 0 : httpRes.data, operations.CompleteMultipart200ApplicationJSON);
                    }
                    break;
            }
            return res;
        });
    };
    /**
     * Creates a multipart external upload
     *
     * @remarks
     * Creates a multipart upload in the external storage provider, storing
     * a temporary reference to the external upload similar to /get-presigned-put.
     *
     * You must have the correct permissions and CORS settings configured in your
     * external provider. We support AWS S3 as the default. See:
     *
     * https://meta.discourse.org/t/-/210469#s3-multipart-direct-uploads-4.
     *
     * An external file store must be set up and `enable_direct_s3_uploads` must
     * be set to true for this endpoint to function.
     *
     *
     */
    Uploads.prototype.createMultipartUpload = function (req, config) {
        var _a;
        if (!(req instanceof utils.SpeakeasyBase)) {
            req = new operations.CreateMultipartUploadRequestBody(req);
        }
        var baseURL = this._serverURL;
        var url = baseURL.replace(/\/$/, "") + "/uploads/create-multipart.json";
        var _b = [{}, {}], reqBodyHeaders = _b[0], reqBody = _b[1];
        try {
            _a = utils.serializeRequestBody(req, "request", "json"), reqBodyHeaders = _a[0], reqBody = _a[1];
        }
        catch (e) {
            if (e instanceof Error) {
                throw new Error("Error serializing request body, cause: ".concat(e.message));
            }
        }
        var client = this._defaultClient;
        var headers = __assign(__assign({}, reqBodyHeaders), config === null || config === void 0 ? void 0 : config.headers);
        var r = client.request(__assign({ url: url, method: "post", headers: headers, data: reqBody }, config));
        return r.then(function (httpRes) {
            var _a, _b;
            var contentType = (_b = (_a = httpRes === null || httpRes === void 0 ? void 0 : httpRes.headers) === null || _a === void 0 ? void 0 : _a["content-type"]) !== null && _b !== void 0 ? _b : "";
            if ((httpRes === null || httpRes === void 0 ? void 0 : httpRes.status) == null)
                throw new Error("status code not found in response: ".concat(httpRes));
            var res = new operations.CreateMultipartUploadResponse({
                statusCode: httpRes.status,
                contentType: contentType,
                rawResponse: httpRes,
            });
            switch (true) {
                case (httpRes === null || httpRes === void 0 ? void 0 : httpRes.status) == 200:
                    if (utils.matchContentType(contentType, "application/json")) {
                        res.createMultipartUpload200ApplicationJSONObject =
                            utils.objectToClass(httpRes === null || httpRes === void 0 ? void 0 : httpRes.data, operations.CreateMultipartUpload200ApplicationJSON);
                    }
                    break;
            }
            return res;
        });
    };
    /**
     * Creates an upload
     */
    Uploads.prototype.createUpload = function (req, config) {
        var _a;
        if (!(req instanceof utils.SpeakeasyBase)) {
            req = new operations.CreateUploadRequestBody(req);
        }
        var baseURL = this._serverURL;
        var url = baseURL.replace(/\/$/, "") + "/uploads.json";
        var _b = [{}, {}], reqBodyHeaders = _b[0], reqBody = _b[1];
        try {
            _a = utils.serializeRequestBody(req, "request", "multipart"), reqBodyHeaders = _a[0], reqBody = _a[1];
        }
        catch (e) {
            if (e instanceof Error) {
                throw new Error("Error serializing request body, cause: ".concat(e.message));
            }
        }
        var client = this._defaultClient;
        var headers = __assign(__assign({}, reqBodyHeaders), config === null || config === void 0 ? void 0 : config.headers);
        var r = client.request(__assign({ url: url, method: "post", headers: headers, data: reqBody }, config));
        return r.then(function (httpRes) {
            var _a, _b;
            var contentType = (_b = (_a = httpRes === null || httpRes === void 0 ? void 0 : httpRes.headers) === null || _a === void 0 ? void 0 : _a["content-type"]) !== null && _b !== void 0 ? _b : "";
            if ((httpRes === null || httpRes === void 0 ? void 0 : httpRes.status) == null)
                throw new Error("status code not found in response: ".concat(httpRes));
            var res = new operations.CreateUploadResponse({
                statusCode: httpRes.status,
                contentType: contentType,
                rawResponse: httpRes,
            });
            switch (true) {
                case (httpRes === null || httpRes === void 0 ? void 0 : httpRes.status) == 200:
                    if (utils.matchContentType(contentType, "application/json")) {
                        res.createUpload200ApplicationJSONObject = utils.objectToClass(httpRes === null || httpRes === void 0 ? void 0 : httpRes.data, operations.CreateUpload200ApplicationJSON);
                    }
                    break;
            }
            return res;
        });
    };
    /**
     * Initiates a direct external upload
     *
     * @remarks
     * Direct external uploads bypass the usual method of creating uploads
     * via the POST /uploads route, and upload directly to an external provider,
     * which by default is S3. This route begins the process, and will return
     * a unique identifier for the external upload as well as a presigned URL
     * which is where the file binary blob should be uploaded to.
     *
     * Once the upload is complete to the external service, you must call the
     * POST /complete-external-upload route using the unique identifier returned
     * by this route, which will create any required Upload record in the Discourse
     * database and also move file from its temporary location to the final
     * destination in the external storage service.
     *
     * You must have the correct permissions and CORS settings configured in your
     * external provider. We support AWS S3 as the default. See:
     *
     * https://meta.discourse.org/t/-/210469#s3-multipart-direct-uploads-4.
     *
     * An external file store must be set up and `enable_direct_s3_uploads` must
     * be set to true for this endpoint to function.
     *
     *
     */
    Uploads.prototype.generatePresignedPut = function (req, config) {
        var _a;
        if (!(req instanceof utils.SpeakeasyBase)) {
            req = new operations.GeneratePresignedPutRequestBody(req);
        }
        var baseURL = this._serverURL;
        var url = baseURL.replace(/\/$/, "") + "/uploads/generate-presigned-put.json";
        var _b = [{}, {}], reqBodyHeaders = _b[0], reqBody = _b[1];
        try {
            _a = utils.serializeRequestBody(req, "request", "json"), reqBodyHeaders = _a[0], reqBody = _a[1];
        }
        catch (e) {
            if (e instanceof Error) {
                throw new Error("Error serializing request body, cause: ".concat(e.message));
            }
        }
        var client = this._defaultClient;
        var headers = __assign(__assign({}, reqBodyHeaders), config === null || config === void 0 ? void 0 : config.headers);
        var r = client.request(__assign({ url: url, method: "post", headers: headers, data: reqBody }, config));
        return r.then(function (httpRes) {
            var _a, _b;
            var contentType = (_b = (_a = httpRes === null || httpRes === void 0 ? void 0 : httpRes.headers) === null || _a === void 0 ? void 0 : _a["content-type"]) !== null && _b !== void 0 ? _b : "";
            if ((httpRes === null || httpRes === void 0 ? void 0 : httpRes.status) == null)
                throw new Error("status code not found in response: ".concat(httpRes));
            var res = new operations.GeneratePresignedPutResponse({
                statusCode: httpRes.status,
                contentType: contentType,
                rawResponse: httpRes,
            });
            switch (true) {
                case (httpRes === null || httpRes === void 0 ? void 0 : httpRes.status) == 200:
                    if (utils.matchContentType(contentType, "application/json")) {
                        res.generatePresignedPut200ApplicationJSONObject =
                            utils.objectToClass(httpRes === null || httpRes === void 0 ? void 0 : httpRes.data, operations.GeneratePresignedPut200ApplicationJSON);
                    }
                    break;
            }
            return res;
        });
    };
    return Uploads;
}());
exports.Uploads = Uploads;
