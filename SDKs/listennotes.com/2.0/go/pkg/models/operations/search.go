// Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.

package operations

import (
	"encoding/json"
	"fmt"
	"net/http"
	"openapi/pkg/models/shared"
)

// SearchSafeModeEnum - Whether or not to exclude podcasts/episodes with explicit language. 1 is yes and 0 is no. It works only when **type** is *episode* or *podcast*.
type SearchSafeModeEnum string

const (
	SearchSafeModeEnumZero SearchSafeModeEnum = "0"
	SearchSafeModeEnumOne  SearchSafeModeEnum = "1"
)

func (e *SearchSafeModeEnum) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return err
	}
	switch s {
	case "0":
		fallthrough
	case "1":
		*e = SearchSafeModeEnum(s)
		return nil
	default:
		return fmt.Errorf("invalid value for SearchSafeModeEnum: %s", s)
	}
}

// SearchSortByDateEnum - Sort by date or not? If 0, then sort by relevance. If 1, then sort by date.
type SearchSortByDateEnum string

const (
	SearchSortByDateEnumZero SearchSortByDateEnum = "0"
	SearchSortByDateEnumOne  SearchSortByDateEnum = "1"
)

func (e *SearchSortByDateEnum) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return err
	}
	switch s {
	case "0":
		fallthrough
	case "1":
		*e = SearchSortByDateEnum(s)
		return nil
	default:
		return fmt.Errorf("invalid value for SearchSortByDateEnum: %s", s)
	}
}

// SearchTypeEnum - What type of contents do you want to search for?
type SearchTypeEnum string

const (
	SearchTypeEnumEpisode SearchTypeEnum = "episode"
	SearchTypeEnumPodcast SearchTypeEnum = "podcast"
	SearchTypeEnumCurated SearchTypeEnum = "curated"
)

func (e *SearchTypeEnum) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return err
	}
	switch s {
	case "episode":
		fallthrough
	case "podcast":
		fallthrough
	case "curated":
		*e = SearchTypeEnum(s)
		return nil
	default:
		return fmt.Errorf("invalid value for SearchTypeEnum: %s", s)
	}
}

// SearchUniquePodcastsEnum - Whether or not to keep only one episode per podcast in search results. 1 is yes and 0 is no. It works only when **type** is *episode*.
type SearchUniquePodcastsEnum string

const (
	SearchUniquePodcastsEnumZero SearchUniquePodcastsEnum = "0"
	SearchUniquePodcastsEnumOne  SearchUniquePodcastsEnum = "1"
)

func (e *SearchUniquePodcastsEnum) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return err
	}
	switch s {
	case "0":
		fallthrough
	case "1":
		*e = SearchUniquePodcastsEnum(s)
		return nil
	default:
		return fmt.Errorf("invalid value for SearchUniquePodcastsEnum: %s", s)
	}
}

type SearchRequest struct {
	// Get API Key on listennotes.com/api
	XListenAPIKey string `header:"style=simple,explode=false,name=X-ListenAPI-Key"`
	// Maximum number of episodes. Applicable only when type parameter is **podcast**.
	//
	EpisodeCountMax *int64 `queryParam:"style=form,explode=true,name=episode_count_max"`
	// Minimum number of episodes. Applicable only when type parameter is **podcast**.
	//
	EpisodeCountMin *int64 `queryParam:"style=form,explode=true,name=episode_count_min"`
	// A comma-delimited string of a list of genre ids. If not specified, then all genres are included. You can find the id and the name of all genres from `GET /genres`. It works only when **type** is *episode* or *podcast*.
	//
	GenreIds *string `queryParam:"style=form,explode=true,name=genre_ids"`
	// Limit search results to a specific language. If not specified, it'll be any language. You can get a list of supported languages from `GET /languages`. It works only when **type** is *episode* or *podcast*.
	//
	Language *string `queryParam:"style=form,explode=true,name=language"`
	// Maximum audio length in minutes. Applicable only when **type** parameter is **episode** or **podcast**.
	// If **type** parameter is **episode**, it's for audio length of an episode.
	// If **type** parameter is **podcast**, it's for average audio length of all episodes in a podcast.
	//
	LenMax *int64 `queryParam:"style=form,explode=true,name=len_max"`
	// Minimum audio length in minutes. Applicable only when **type** parameter is **episode** or **podcast**.
	// If **type** parameter is **episode**, it's for audio length of an episode.
	// If **type** parameter is **podcast**, it's for average audio length of all episodes in a podcast.
	//
	LenMin *int64 `queryParam:"style=form,explode=true,name=len_min"`
	// A comma-delimited string of podcast ids (up to 5 podcasts) - you can get a podcast id from the **podcast_id** field in response. This parameter is to exclude search results of a few specific podcasts. It works only when **type** is *episode*.
	//
	Ncid *string `queryParam:"style=form,explode=true,name=ncid"`
	// A comma-delimited string of podcast ids (up to 5 podcasts) - you can get a podcast id from the **podcast_id** field in response. This parameter is to limit search results from only a few specific podcasts. It works only when **type** is *episode*.
	//
	Ocid *string `queryParam:"style=form,explode=true,name=ocid"`
	// Offset for search results, for pagination. You'll use **next_offset** from response for this parameter.
	//
	Offset *int64 `queryParam:"style=form,explode=true,name=offset"`
	// A comma-delimited string to search only in specific fields. Allowed values are title, description, author, and audio. If not specified, then search every fields.
	//
	OnlyIn *string `queryParam:"style=form,explode=true,name=only_in"`
	// Only show episodes/podcasts/curated lists published after this timestamp (in milliseconds). If **published_before** & **published_after** are used at the same time, **published_before** should be bigger than **published_after**.
	//
	PublishedAfter *int64 `queryParam:"style=form,explode=true,name=published_after"`
	// Only show episodes/podcasts/curated lists published before this timestamp (in milliseconds). If **published_before** & **published_after** are used at the same time, **published_before** should be bigger than **published_after**.
	//
	PublishedBefore *int64 `queryParam:"style=form,explode=true,name=published_before"`
	// Search term, e.g., person, place, topic... You can use double quotes to do verbatim match, e.g., "game of thrones". Otherwise, it's fuzzy search.
	//
	Q string `queryParam:"style=form,explode=true,name=q"`
	// Limit search results to a specific region (e.g., us, gb, in...). If not specified, it'll be any region. You can get the supported country codes from `GET /regions`. It works only when **type** is *episode* or *podcast*.
	//
	Region *string `queryParam:"style=form,explode=true,name=region"`
	// Whether or not to exclude podcasts/episodes with explicit language. 1 is yes and 0 is no. It works only when **type** is *episode* or *podcast*.
	//
	SafeMode *SearchSafeModeEnum `queryParam:"style=form,explode=true,name=safe_mode"`
	// Sort by date or not? If 0, then sort by relevance. If 1, then sort by date.
	//
	SortByDate *SearchSortByDateEnum `queryParam:"style=form,explode=true,name=sort_by_date"`
	// What type of contents do you want to search for?
	//
	Type *SearchTypeEnum `queryParam:"style=form,explode=true,name=type"`
	// Whether or not to keep only one episode per podcast in search results. 1 is yes and 0 is no. It works only when **type** is *episode*.
	//
	UniquePodcasts *SearchUniquePodcastsEnum `queryParam:"style=form,explode=true,name=unique_podcasts"`
	// Maximum update frequency in hours (how frequently does a podcast release a new episode). For example, if you want to find "weekly" podcasts, then you can set **update_freq_min**=144 hours (or 6 days) and **update_freq_max**=192 hours (or 8 days). Applicable only when type parameter is **podcast**.
	//
	UpdateFreqMax *int64 `queryParam:"style=form,explode=true,name=update_freq_max"`
	// Minimum update frequency in hours (how frequently does a podcast release a new episode). For example, if you want to find "weekly" podcasts, then you can set **update_freq_min**=144 hours (or 6 days) and **update_freq_max**=192 hours (or 8 days). Applicable only when type parameter is **podcast**.
	//
	UpdateFreqMin *int64 `queryParam:"style=form,explode=true,name=update_freq_min"`
}

type SearchResponse struct {
	ContentType string
	Headers     map[string][]string
	// OK
	SearchResponse *shared.SearchResponse
	StatusCode     int
	RawResponse    *http.Response
}
