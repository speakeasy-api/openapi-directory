/*
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

import * as utils from "../internal/utils";
import * as operations from "./models/operations";
import * as shared from "./models/shared";
import { AxiosInstance, AxiosRequestConfig, AxiosResponse } from "axios";

/**
 * To change the description use /examples/TagsDescriptions.json
 */
export class Vendors {
  _defaultClient: AxiosInstance;
  _securityClient: AxiosInstance;
  _serverURL: string;
  _language: string;
  _sdkVersion: string;
  _genVersion: string;

  constructor(
    defaultClient: AxiosInstance,
    securityClient: AxiosInstance,
    serverURL: string,
    language: string,
    sdkVersion: string,
    genVersion: string
  ) {
    this._defaultClient = defaultClient;
    this._securityClient = securityClient;
    this._serverURL = serverURL;
    this._language = language;
    this._sdkVersion = sdkVersion;
    this._genVersion = genVersion;
  }

  /**
   * Removes a provider.
   *
   * @remarks
   * Removes a provider.
   */
  delete10(
    req: operations.Delete10Request,
    config?: AxiosRequestConfig
  ): Promise<operations.Delete10Response> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.Delete10Request(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/providers/{providerId}",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.Delete10Response = new operations.Delete10Response({
        statusCode: httpRes.status,
        contentType: contentType,
        rawResponse: httpRes,
      });
      switch (true) {
        case httpRes?.status == 204:
          break;
      }

      return res;
    });
  }

  /**
   * Removes a person.
   *
   * @remarks
   * Removes a person.
   */
  delete8(
    req: operations.Delete8Request,
    config?: AxiosRequestConfig
  ): Promise<operations.Delete8Response> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.Delete8Request(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/providers/persons/{personId}",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.Delete8Response = new operations.Delete8Response({
        statusCode: httpRes.status,
        contentType: contentType,
        rawResponse: httpRes,
      });
      switch (true) {
        case httpRes?.status == 204:
          break;
      }

      return res;
    });
  }

  /**
   * Removes a provider price list.
   *
   * @remarks
   * Removes a provider price list.
   */
  delete9(
    req: operations.Delete9Request,
    config?: AxiosRequestConfig
  ): Promise<operations.Delete9Response> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.Delete9Request(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/providers/priceLists/{priceListId}",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.Delete9Response = new operations.Delete9Response({
        statusCode: httpRes.status,
        contentType: contentType,
        rawResponse: httpRes,
      });
      switch (true) {
        case httpRes?.status == 204:
          break;
      }

      return res;
    });
  }

  /**
   * Returns address of a given provider.
   *
   * @remarks
   * Returns address of a given provider.
   */
  getAddress1(
    req: operations.GetAddress1Request,
    config?: AxiosRequestConfig
  ): Promise<operations.GetAddress1Response> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetAddress1Request(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/providers/{providerId}/address",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetAddress1Response =
        new operations.GetAddress1Response({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        default:
          if (
            utils.matchContentType(
              contentType,
              `application/vnd.xtrf-v1+json;charset=UTF-8`
            )
          ) {
            res.addressDTO = utils.objectToClass(
              httpRes?.data,
              shared.AddressDTO
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Returns persons' internal identifiers.
   *
   * @remarks
   * Returns persons' internal identifiers.
   */
  getAllIds4(
    req: operations.GetAllIds4Request,
    config?: AxiosRequestConfig
  ): Promise<operations.GetAllIds4Response> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetAllIds4Request(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/providers/persons/ids";

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetAllIds4Response =
        new operations.GetAllIds4Response({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        default:
          if (
            utils.matchContentType(
              contentType,
              `application/vnd.xtrf-v1+json;charset=UTF-8`
            )
          ) {
            res.getAllIds4DefaultApplicationVndXtrfV1PlusJsonInt32Integers =
              utils.objectToClass(httpRes?.data);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Returns providers' internal identifiers.
   *
   * @remarks
   * Returns providers' internal identifiers.
   */
  getAllIds5(
    req: operations.GetAllIds5Request,
    config?: AxiosRequestConfig
  ): Promise<operations.GetAllIds5Response> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetAllIds5Request(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/providers/ids";

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetAllIds5Response =
        new operations.GetAllIds5Response({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        default:
          if (
            utils.matchContentType(
              contentType,
              `application/vnd.xtrf-v1+json;charset=UTF-8`
            )
          ) {
            res.getAllIds5DefaultApplicationVndXtrfV1PlusJsonInt32Integers =
              utils.objectToClass(httpRes?.data);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Returns person details.
   *
   * @remarks
   * Returns person details.
   */
  getById4(
    req: operations.GetById4Request,
    config?: AxiosRequestConfig
  ): Promise<operations.GetById4Response> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetById4Request(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/providers/persons/{personId}",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetById4Response = new operations.GetById4Response({
        statusCode: httpRes.status,
        contentType: contentType,
        rawResponse: httpRes,
      });
      switch (true) {
        default:
          if (
            utils.matchContentType(
              contentType,
              `application/vnd.xtrf-v1+json;charset=UTF-8`
            )
          ) {
            res.providerPersonDTO = utils.objectToClass(
              httpRes?.data,
              shared.ProviderPersonDTO
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Returns provider details.
   *
   * @remarks
   * Returns provider details.
   */
  getById5(
    req: operations.GetById5Request,
    config?: AxiosRequestConfig
  ): Promise<operations.GetById5Response> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetById5Request(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/providers/{providerId}",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetById5Response = new operations.GetById5Response({
        statusCode: httpRes.status,
        contentType: contentType,
        rawResponse: httpRes,
      });
      switch (true) {
        default:
          if (
            utils.matchContentType(
              contentType,
              `application/vnd.xtrf-v1+json;charset=UTF-8`
            )
          ) {
            res.providerDTO = utils.objectToClass(
              httpRes?.data,
              shared.ProviderDTO
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Returns competencies of a given provider.
   *
   * @remarks
   * Returns competencies of a given provider.
   */
  getCompetencies(
    req: operations.GetCompetenciesRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetCompetenciesResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetCompetenciesRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/providers/{providerId}/competencies",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetCompetenciesResponse =
        new operations.GetCompetenciesResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        default:
          if (
            utils.matchContentType(
              contentType,
              `application/vnd.xtrf-v1+json;charset=UTF-8`
            )
          ) {
            res.competenciesDTO = utils.objectToClass(
              httpRes?.data,
              shared.CompetenciesDTO
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Returns contact of a given person.
   *
   * @remarks
   * Returns contact of a given person.
   */
  getContact2(
    req: operations.GetContact2Request,
    config?: AxiosRequestConfig
  ): Promise<operations.GetContact2Response> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetContact2Request(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/providers/persons/{personId}/contact",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetContact2Response =
        new operations.GetContact2Response({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        default:
          if (
            utils.matchContentType(
              contentType,
              `application/vnd.xtrf-v1+json;charset=UTF-8`
            )
          ) {
            res.personContactDTO = utils.objectToClass(
              httpRes?.data,
              shared.PersonContactDTO
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Returns contact of a given provider.
   *
   * @remarks
   * Returns contact of a given provider.
   */
  getContact3(
    req: operations.GetContact3Request,
    config?: AxiosRequestConfig
  ): Promise<operations.GetContact3Response> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetContact3Request(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/providers/{providerId}/contact",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetContact3Response =
        new operations.GetContact3Response({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        default:
          if (
            utils.matchContentType(
              contentType,
              `application/vnd.xtrf-v1+json;charset=UTF-8`
            )
          ) {
            res.contactDTO = utils.objectToClass(
              httpRes?.data,
              shared.ContactDTO
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Returns correspondence address of a given provider.
   *
   * @remarks
   * Returns correspondence address of a given provider.
   */
  getCorrespondenceAddress1(
    req: operations.GetCorrespondenceAddress1Request,
    config?: AxiosRequestConfig
  ): Promise<operations.GetCorrespondenceAddress1Response> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetCorrespondenceAddress1Request(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/providers/{providerId}/correspondenceAddress",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetCorrespondenceAddress1Response =
        new operations.GetCorrespondenceAddress1Response({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        default:
          if (
            utils.matchContentType(
              contentType,
              `application/vnd.xtrf-v1+json;charset=UTF-8`
            )
          ) {
            res.addressDTO = utils.objectToClass(
              httpRes?.data,
              shared.AddressDTO
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Returns custom fields of a given person.
   *
   * @remarks
   * Returns custom fields of a given person.
   */
  getCustomFields2(
    req: operations.GetCustomFields2Request,
    config?: AxiosRequestConfig
  ): Promise<operations.GetCustomFields2Response> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetCustomFields2Request(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/providers/persons/{personId}/customFields",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetCustomFields2Response =
        new operations.GetCustomFields2Response({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        default:
          if (
            utils.matchContentType(
              contentType,
              `application/vnd.xtrf-v1+json;charset=UTF-8`
            )
          ) {
            res.customFieldsDTO = [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.customFieldsDTO = utils.objectToClass(
              httpRes?.data,
              shared.CustomFieldDTO,
              resFieldDepth
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Returns custom fields of a given provider.
   *
   * @remarks
   * Returns custom fields of a given provider.
   */
  getCustomFields3(
    req: operations.GetCustomFields3Request,
    config?: AxiosRequestConfig
  ): Promise<operations.GetCustomFields3Response> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetCustomFields3Request(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/providers/{providerId}/customFields",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetCustomFields3Response =
        new operations.GetCustomFields3Response({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        default:
          if (
            utils.matchContentType(
              contentType,
              `application/vnd.xtrf-v1+json;charset=UTF-8`
            )
          ) {
            res.customFieldsDTO = [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.customFieldsDTO = utils.objectToClass(
              httpRes?.data,
              shared.CustomFieldDTO,
              resFieldDepth
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Sends invitation to Vendor Portal.
   *
   * @remarks
   * Sends invitation to Vendor Portal.
   */
  sendInvitations(
    req: operations.SendInvitationsRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.SendInvitationsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.SendInvitationsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/providers/persons/{personId}/notification/invitation",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "post",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.SendInvitationsResponse =
        new operations.SendInvitationsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        default:
          if (
            utils.matchContentType(
              contentType,
              `application/vnd.xtrf-v1+json;charset=UTF-8`
            )
          ) {
            res.invitationStatisticsDTO = utils.objectToClass(
              httpRes?.data,
              shared.InvitationStatisticsDTO
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Sends invitations to Vendor Portal.
   *
   * @remarks
   * Sends invitations to Vendor Portal.
   */
  sendInvitations1(
    req: operations.SendInvitations1Request,
    config?: AxiosRequestConfig
  ): Promise<operations.SendInvitations1Response> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.SendInvitations1Request(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/providers/{providerId}/notification/invitation",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "post",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.SendInvitations1Response =
        new operations.SendInvitations1Response({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        default:
          if (
            utils.matchContentType(
              contentType,
              `application/vnd.xtrf-v1+json;charset=UTF-8`
            )
          ) {
            res.invitationStatisticsDTO = utils.objectToClass(
              httpRes?.data,
              shared.InvitationStatisticsDTO
            );
          }
          break;
      }

      return res;
    });
  }
}
