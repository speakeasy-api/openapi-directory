"""Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT."""

from __future__ import annotations
import dataclasses
import requests as requests_http
from ..shared import cloudwatchlogsdestinationconfiguration as shared_cloudwatchlogsdestinationconfiguration
from ..shared import createloggingconfigurationresponse as shared_createloggingconfigurationresponse
from ..shared import firehosedestinationconfiguration as shared_firehosedestinationconfiguration
from ..shared import s3destinationconfiguration as shared_s3destinationconfiguration
from dataclasses_json import Undefined, dataclass_json
from sdk import utils
from typing import Any, Optional


@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class CreateLoggingConfigurationRequestBodyDestinationConfiguration:
    r"""A complex type that describes a location where chat logs will be stored. Each member represents the configuration of one log destination. For logging, you define only one type of destination (for CloudWatch Logs, Kinesis Firehose, or S3)."""
    
    cloud_watch_logs: Optional[shared_cloudwatchlogsdestinationconfiguration.CloudWatchLogsDestinationConfiguration] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('cloudWatchLogs'), 'exclude': lambda f: f is None }})  
    firehose: Optional[shared_firehosedestinationconfiguration.FirehoseDestinationConfiguration] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('firehose'), 'exclude': lambda f: f is None }})  
    s3: Optional[shared_s3destinationconfiguration.S3DestinationConfiguration] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('s3'), 'exclude': lambda f: f is None }})  
    

@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class CreateLoggingConfigurationRequestBody:
    
    destination_configuration: CreateLoggingConfigurationRequestBodyDestinationConfiguration = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('destinationConfiguration') }})
    r"""A complex type that describes a location where chat logs will be stored. Each member represents the configuration of one log destination. For logging, you define only one type of destination (for CloudWatch Logs, Kinesis Firehose, or S3)."""  
    name: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('name'), 'exclude': lambda f: f is None }})
    r"""Logging-configuration name. The value does not need to be unique."""  
    tags: Optional[dict[str, str]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('tags'), 'exclude': lambda f: f is None }})
    r"""Tags to attach to the resource. Array of maps, each of the form <code>string:string (key:value)</code>. See <a href=\\"https://docs.aws.amazon.com/general/latest/gr/aws_tagging.html\\">Tagging AWS Resources</a> for details, including restrictions that apply to tags and \\"Tag naming limits and requirements\\"; Amazon IVS Chat has no constraints on tags beyond what is documented there."""  
    

@dataclasses.dataclass
class CreateLoggingConfigurationRequest:
    
    request_body: CreateLoggingConfigurationRequestBody = dataclasses.field(metadata={'request': { 'media_type': 'application/json' }})  
    x_amz_algorithm: Optional[str] = dataclasses.field(default=None, metadata={'header': { 'field_name': 'X-Amz-Algorithm', 'style': 'simple', 'explode': False }})  
    x_amz_content_sha256: Optional[str] = dataclasses.field(default=None, metadata={'header': { 'field_name': 'X-Amz-Content-Sha256', 'style': 'simple', 'explode': False }})  
    x_amz_credential: Optional[str] = dataclasses.field(default=None, metadata={'header': { 'field_name': 'X-Amz-Credential', 'style': 'simple', 'explode': False }})  
    x_amz_date: Optional[str] = dataclasses.field(default=None, metadata={'header': { 'field_name': 'X-Amz-Date', 'style': 'simple', 'explode': False }})  
    x_amz_security_token: Optional[str] = dataclasses.field(default=None, metadata={'header': { 'field_name': 'X-Amz-Security-Token', 'style': 'simple', 'explode': False }})  
    x_amz_signature: Optional[str] = dataclasses.field(default=None, metadata={'header': { 'field_name': 'X-Amz-Signature', 'style': 'simple', 'explode': False }})  
    x_amz_signed_headers: Optional[str] = dataclasses.field(default=None, metadata={'header': { 'field_name': 'X-Amz-SignedHeaders', 'style': 'simple', 'explode': False }})  
    

@dataclasses.dataclass
class CreateLoggingConfigurationResponse:
    
    content_type: str = dataclasses.field()  
    status_code: int = dataclasses.field()  
    access_denied_exception: Optional[Any] = dataclasses.field(default=None)
    r"""AccessDeniedException"""  
    conflict_exception: Optional[Any] = dataclasses.field(default=None)
    r"""ConflictException"""  
    create_logging_configuration_response: Optional[shared_createloggingconfigurationresponse.CreateLoggingConfigurationResponse] = dataclasses.field(default=None)
    r"""Success"""  
    pending_verification: Optional[Any] = dataclasses.field(default=None)
    r"""PendingVerification"""  
    raw_response: Optional[requests_http.Response] = dataclasses.field(default=None)  
    resource_not_found_exception: Optional[Any] = dataclasses.field(default=None)
    r"""ResourceNotFoundException"""  
    service_quota_exceeded_exception: Optional[Any] = dataclasses.field(default=None)
    r"""ServiceQuotaExceededException"""  
    validation_exception: Optional[Any] = dataclasses.field(default=None)
    r"""ValidationException"""  
    