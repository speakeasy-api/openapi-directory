<?php

/**
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

declare(strict_types=1);

namespace OpenAPI\OpenAPI\Models\Shared;


/**
 * TensorflowTensorProto - Protocol buffer representing a tensor.
 * 
 * @package OpenAPI\OpenAPI\Models\Shared
 * @access public
 */
class TensorflowTensorProto
{
    /**
     * $boolVal
     * 
     * @var ?array<bool> $boolVal
     */
	#[\JMS\Serializer\Annotation\SerializedName('bool_val')]
    #[\JMS\Serializer\Annotation\Type('array<bool>')]
    #[\JMS\Serializer\Annotation\SkipWhenEmpty]
    public ?array $boolVal = null;
    
    /**
     * DT_COMPLEX128. dcomplex_val(2*i) and dcomplex_val(2*i+1) are real and imaginary parts of i-th double precision complex.
     * 
     * @var ?array<float> $dcomplexVal
     */
	#[\JMS\Serializer\Annotation\SerializedName('dcomplex_val')]
    #[\JMS\Serializer\Annotation\Type('array<float>')]
    #[\JMS\Serializer\Annotation\SkipWhenEmpty]
    public ?array $dcomplexVal = null;
    
    /**
     * DT_DOUBLE.
     * 
     * @var ?array<float> $doubleVal
     */
	#[\JMS\Serializer\Annotation\SerializedName('double_val')]
    #[\JMS\Serializer\Annotation\Type('array<float>')]
    #[\JMS\Serializer\Annotation\SkipWhenEmpty]
    public ?array $doubleVal = null;
    
    /**
     * - DT_INVALID: Not a legal value for DataType.  Used to indicate a DataType field has not been set. - DT_FLOAT: Data types that all computation devices are expected to be capable to support. - DT_FLOAT_REF: Do not use!  These are only for parameters.  Every enum above should have a corresponding value below (verified by types_test).
     * 
     * @var ?\OpenAPI\OpenAPI\Models\Shared\TensorflowDataTypeEnum $dtype
     */
	#[\JMS\Serializer\Annotation\SerializedName('dtype')]
    #[\JMS\Serializer\Annotation\Type('enum<OpenAPI\OpenAPI\Models\Shared\TensorflowDataTypeEnum>')]
    #[\JMS\Serializer\Annotation\SkipWhenEmpty]
    public ?TensorflowDataTypeEnum $dtype = null;
    
    /**
     * DT_FLOAT.
     * 
     * @var ?array<float> $floatVal
     */
	#[\JMS\Serializer\Annotation\SerializedName('float_val')]
    #[\JMS\Serializer\Annotation\Type('array<float>')]
    #[\JMS\Serializer\Annotation\SkipWhenEmpty]
    public ?array $floatVal = null;
    
    /**
     * DT_HALF, DT_BFLOAT16. Note that since protobuf has no int16 type, we'll have some pointless zero padding for each value here.
     * 
     * @var ?array<int> $halfVal
     */
	#[\JMS\Serializer\Annotation\SerializedName('half_val')]
    #[\JMS\Serializer\Annotation\Type('array<int>')]
    #[\JMS\Serializer\Annotation\SkipWhenEmpty]
    public ?array $halfVal = null;
    
    /**
     * $int64Val
     * 
     * @var ?array<string> $int64Val
     */
	#[\JMS\Serializer\Annotation\SerializedName('int64_val')]
    #[\JMS\Serializer\Annotation\Type('array<string>')]
    #[\JMS\Serializer\Annotation\SkipWhenEmpty]
    public ?array $int64Val = null;
    
    /**
     * DT_INT32, DT_INT16, DT_INT8, DT_UINT8.
     * 
     * @var ?array<int> $intVal
     */
	#[\JMS\Serializer\Annotation\SerializedName('int_val')]
    #[\JMS\Serializer\Annotation\Type('array<int>')]
    #[\JMS\Serializer\Annotation\SkipWhenEmpty]
    public ?array $intVal = null;
    
    /**
     * $resourceHandleVal
     * 
     * @var ?array<\OpenAPI\OpenAPI\Models\Shared\TensorflowResourceHandleProto> $resourceHandleVal
     */
	#[\JMS\Serializer\Annotation\SerializedName('resource_handle_val')]
    #[\JMS\Serializer\Annotation\Type('array<OpenAPI\OpenAPI\Models\Shared\TensorflowResourceHandleProto>')]
    #[\JMS\Serializer\Annotation\SkipWhenEmpty]
    public ?array $resourceHandleVal = null;
    
    /**
     * DT_COMPLEX64. scomplex_val(2*i) and scomplex_val(2*i+1) are real and imaginary parts of i-th single precision complex.
     * 
     * @var ?array<float> $scomplexVal
     */
	#[\JMS\Serializer\Annotation\SerializedName('scomplex_val')]
    #[\JMS\Serializer\Annotation\Type('array<float>')]
    #[\JMS\Serializer\Annotation\SkipWhenEmpty]
    public ?array $scomplexVal = null;
    
    /**
     * $stringVal
     * 
     * @var ?array<string> $stringVal
     */
	#[\JMS\Serializer\Annotation\SerializedName('string_val')]
    #[\JMS\Serializer\Annotation\Type('array<string>')]
    #[\JMS\Serializer\Annotation\SkipWhenEmpty]
    public ?array $stringVal = null;
    
    /**
     * Serialized raw tensor content from either Tensor::AsProtoTensorContent or memcpy in tensorflow::grpc::EncodeTensorToByteBuffer. This representation can be used for all tensor types. The purpose of this representation is to reduce serialization overhead during RPC call by avoiding serialization of many repeated small items.
     * 
     * @var ?string $tensorContent
     */
	#[\JMS\Serializer\Annotation\SerializedName('tensor_content')]
    #[\JMS\Serializer\Annotation\Type('string')]
    #[\JMS\Serializer\Annotation\SkipWhenEmpty]
    public ?string $tensorContent = null;
    
    /**
     * Dimensions of a tensor.
     * 
     * @var ?\OpenAPI\OpenAPI\Models\Shared\TensorflowTensorShapeProto $tensorShape
     */
	#[\JMS\Serializer\Annotation\SerializedName('tensor_shape')]
    #[\JMS\Serializer\Annotation\Type('OpenAPI\OpenAPI\Models\Shared\TensorflowTensorShapeProto')]
    #[\JMS\Serializer\Annotation\SkipWhenEmpty]
    public ?TensorflowTensorShapeProto $tensorShape = null;
    
    /**
     * $uint32Val
     * 
     * @var ?array<int> $uint32Val
     */
	#[\JMS\Serializer\Annotation\SerializedName('uint32_val')]
    #[\JMS\Serializer\Annotation\Type('array<int>')]
    #[\JMS\Serializer\Annotation\SkipWhenEmpty]
    public ?array $uint32Val = null;
    
    /**
     * $uint64Val
     * 
     * @var ?array<string> $uint64Val
     */
	#[\JMS\Serializer\Annotation\SerializedName('uint64_val')]
    #[\JMS\Serializer\Annotation\Type('array<string>')]
    #[\JMS\Serializer\Annotation\SkipWhenEmpty]
    public ?array $uint64Val = null;
    
    /**
     * $variantVal
     * 
     * @var ?array<\OpenAPI\OpenAPI\Models\Shared\TensorflowVariantTensorDataProto> $variantVal
     */
	#[\JMS\Serializer\Annotation\SerializedName('variant_val')]
    #[\JMS\Serializer\Annotation\Type('array<OpenAPI\OpenAPI\Models\Shared\TensorflowVariantTensorDataProto>')]
    #[\JMS\Serializer\Annotation\SkipWhenEmpty]
    public ?array $variantVal = null;
    
    /**
     * Version number.
     * 
     * In version 0, if the "repeated xxx" representations contain only one element, that element is repeated to fill the shape.  This makes it easy to represent a constant Tensor with a single value.
     * 
     * @var ?int $versionNumber
     */
	#[\JMS\Serializer\Annotation\SerializedName('version_number')]
    #[\JMS\Serializer\Annotation\Type('int')]
    #[\JMS\Serializer\Annotation\SkipWhenEmpty]
    public ?int $versionNumber = null;
    
	public function __construct()
	{
		$this->boolVal = null;
		$this->dcomplexVal = null;
		$this->doubleVal = null;
		$this->dtype = null;
		$this->floatVal = null;
		$this->halfVal = null;
		$this->int64Val = null;
		$this->intVal = null;
		$this->resourceHandleVal = null;
		$this->scomplexVal = null;
		$this->stringVal = null;
		$this->tensorContent = null;
		$this->tensorShape = null;
		$this->uint32Val = null;
		$this->uint64Val = null;
		$this->variantVal = null;
		$this->versionNumber = null;
	}
}
