// Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.

package shared

import (
	"encoding/json"
	"fmt"
)

type SslConfigTemplateClientCertTypeEnum string

const (
	SslConfigTemplateClientCertTypeEnumCertTypeUnspecified SslConfigTemplateClientCertTypeEnum = "CERT_TYPE_UNSPECIFIED"
	SslConfigTemplateClientCertTypeEnumPem                 SslConfigTemplateClientCertTypeEnum = "PEM"
)

func (e SslConfigTemplateClientCertTypeEnum) ToPointer() *SslConfigTemplateClientCertTypeEnum {
	return &e
}

func (e *SslConfigTemplateClientCertTypeEnum) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "CERT_TYPE_UNSPECIFIED":
		fallthrough
	case "PEM":
		*e = SslConfigTemplateClientCertTypeEnum(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SslConfigTemplateClientCertTypeEnum: %v", v)
	}
}

type SslConfigTemplateServerCertTypeEnum string

const (
	SslConfigTemplateServerCertTypeEnumCertTypeUnspecified SslConfigTemplateServerCertTypeEnum = "CERT_TYPE_UNSPECIFIED"
	SslConfigTemplateServerCertTypeEnumPem                 SslConfigTemplateServerCertTypeEnum = "PEM"
)

func (e SslConfigTemplateServerCertTypeEnum) ToPointer() *SslConfigTemplateServerCertTypeEnum {
	return &e
}

func (e *SslConfigTemplateServerCertTypeEnum) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "CERT_TYPE_UNSPECIFIED":
		fallthrough
	case "PEM":
		*e = SslConfigTemplateServerCertTypeEnum(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SslConfigTemplateServerCertTypeEnum: %v", v)
	}
}

// SslConfigTemplateSslTypeEnum - Controls the ssl type for the given connector version
type SslConfigTemplateSslTypeEnum string

const (
	SslConfigTemplateSslTypeEnumSslTypeUnspecified SslConfigTemplateSslTypeEnum = "SSL_TYPE_UNSPECIFIED"
	SslConfigTemplateSslTypeEnumTLS                SslConfigTemplateSslTypeEnum = "TLS"
	SslConfigTemplateSslTypeEnumMtls               SslConfigTemplateSslTypeEnum = "MTLS"
)

func (e SslConfigTemplateSslTypeEnum) ToPointer() *SslConfigTemplateSslTypeEnum {
	return &e
}

func (e *SslConfigTemplateSslTypeEnum) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "SSL_TYPE_UNSPECIFIED":
		fallthrough
	case "TLS":
		fallthrough
	case "MTLS":
		*e = SslConfigTemplateSslTypeEnum(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SslConfigTemplateSslTypeEnum: %v", v)
	}
}

// SslConfigTemplate - Ssl config details of a connector version
type SslConfigTemplate struct {
	// Any additional fields that need to be rendered
	AdditionalVariables []ConfigVariableTemplate `json:"additionalVariables,omitempty"`
	// List of supported Client Cert Types
	ClientCertType []SslConfigTemplateClientCertTypeEnum `json:"clientCertType,omitempty"`
	// Boolean for determining if the connector version mandates TLS.
	IsTLSMandatory *bool `json:"isTlsMandatory,omitempty"`
	// List of supported Server Cert Types
	ServerCertType []SslConfigTemplateServerCertTypeEnum `json:"serverCertType,omitempty"`
	// Controls the ssl type for the given connector version
	SslType *SslConfigTemplateSslTypeEnum `json:"sslType,omitempty"`
}
