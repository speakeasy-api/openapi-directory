// Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.

package shared

import (
	"encoding/json"
	"fmt"
)

// CopyPasteRequestPasteOrientationEnum - How that data should be oriented when pasting.
type CopyPasteRequestPasteOrientationEnum string

const (
	CopyPasteRequestPasteOrientationEnumNormal    CopyPasteRequestPasteOrientationEnum = "NORMAL"
	CopyPasteRequestPasteOrientationEnumTranspose CopyPasteRequestPasteOrientationEnum = "TRANSPOSE"
)

func (e *CopyPasteRequestPasteOrientationEnum) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return err
	}
	switch s {
	case "NORMAL":
		fallthrough
	case "TRANSPOSE":
		*e = CopyPasteRequestPasteOrientationEnum(s)
		return nil
	default:
		return fmt.Errorf("invalid value for CopyPasteRequestPasteOrientationEnum: %s", s)
	}
}

// CopyPasteRequestPasteTypeEnum - What kind of data to paste.
type CopyPasteRequestPasteTypeEnum string

const (
	CopyPasteRequestPasteTypeEnumPasteNormal                CopyPasteRequestPasteTypeEnum = "PASTE_NORMAL"
	CopyPasteRequestPasteTypeEnumPasteValues                CopyPasteRequestPasteTypeEnum = "PASTE_VALUES"
	CopyPasteRequestPasteTypeEnumPasteFormat                CopyPasteRequestPasteTypeEnum = "PASTE_FORMAT"
	CopyPasteRequestPasteTypeEnumPasteNoBorders             CopyPasteRequestPasteTypeEnum = "PASTE_NO_BORDERS"
	CopyPasteRequestPasteTypeEnumPasteFormula               CopyPasteRequestPasteTypeEnum = "PASTE_FORMULA"
	CopyPasteRequestPasteTypeEnumPasteDataValidation        CopyPasteRequestPasteTypeEnum = "PASTE_DATA_VALIDATION"
	CopyPasteRequestPasteTypeEnumPasteConditionalFormatting CopyPasteRequestPasteTypeEnum = "PASTE_CONDITIONAL_FORMATTING"
)

func (e *CopyPasteRequestPasteTypeEnum) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return err
	}
	switch s {
	case "PASTE_NORMAL":
		fallthrough
	case "PASTE_VALUES":
		fallthrough
	case "PASTE_FORMAT":
		fallthrough
	case "PASTE_NO_BORDERS":
		fallthrough
	case "PASTE_FORMULA":
		fallthrough
	case "PASTE_DATA_VALIDATION":
		fallthrough
	case "PASTE_CONDITIONAL_FORMATTING":
		*e = CopyPasteRequestPasteTypeEnum(s)
		return nil
	default:
		return fmt.Errorf("invalid value for CopyPasteRequestPasteTypeEnum: %s", s)
	}
}

// CopyPasteRequest - Copies data from the source to the destination.
type CopyPasteRequest struct {
	// A range on a sheet. All indexes are zero-based. Indexes are half open, i.e. the start index is inclusive and the end index is exclusive -- [start_index, end_index). Missing indexes indicate the range is unbounded on that side. For example, if `"Sheet1"` is sheet ID 123456, then: `Sheet1!A1:A1 == sheet_id: 123456, start_row_index: 0, end_row_index: 1, start_column_index: 0, end_column_index: 1` `Sheet1!A3:B4 == sheet_id: 123456, start_row_index: 2, end_row_index: 4, start_column_index: 0, end_column_index: 2` `Sheet1!A:B == sheet_id: 123456, start_column_index: 0, end_column_index: 2` `Sheet1!A5:B == sheet_id: 123456, start_row_index: 4, start_column_index: 0, end_column_index: 2` `Sheet1 == sheet_id: 123456` The start index must always be less than or equal to the end index. If the start index equals the end index, then the range is empty. Empty ranges are typically not meaningful and are usually rendered in the UI as `#REF!`.
	Destination *GridRange `json:"destination,omitempty"`
	// How that data should be oriented when pasting.
	PasteOrientation *CopyPasteRequestPasteOrientationEnum `json:"pasteOrientation,omitempty"`
	// What kind of data to paste.
	PasteType *CopyPasteRequestPasteTypeEnum `json:"pasteType,omitempty"`
	// A range on a sheet. All indexes are zero-based. Indexes are half open, i.e. the start index is inclusive and the end index is exclusive -- [start_index, end_index). Missing indexes indicate the range is unbounded on that side. For example, if `"Sheet1"` is sheet ID 123456, then: `Sheet1!A1:A1 == sheet_id: 123456, start_row_index: 0, end_row_index: 1, start_column_index: 0, end_column_index: 1` `Sheet1!A3:B4 == sheet_id: 123456, start_row_index: 2, end_row_index: 4, start_column_index: 0, end_column_index: 2` `Sheet1!A:B == sheet_id: 123456, start_column_index: 0, end_column_index: 2` `Sheet1!A5:B == sheet_id: 123456, start_row_index: 4, start_column_index: 0, end_column_index: 2` `Sheet1 == sheet_id: 123456` The start index must always be less than or equal to the end index. If the start index equals the end index, then the range is empty. Empty ranges are typically not meaningful and are usually rendered in the UI as `#REF!`.
	Source *GridRange `json:"source,omitempty"`
}
