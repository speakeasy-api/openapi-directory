"""Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT."""

from __future__ import annotations
import dataclasses
import requests as requests_http
from ..shared import csv_asr as shared_csv_asr
from ..shared import csv_conversations as shared_csv_conversations
from ..shared import csv_in_app_voice as shared_csv_in_app_voice
from ..shared import csv_messages_inbound as shared_csv_messages_inbound
from ..shared import csv_messages_outbound as shared_csv_messages_outbound
from ..shared import csv_ni as shared_csv_ni
from ..shared import csv_verify as shared_csv_verify
from ..shared import csv_voice as shared_csv_voice
from ..shared import csv_websockets as shared_csv_websockets
from ..shared import direction_enum as shared_direction_enum
from ..shared import json_sms_inbound_with_body as shared_json_sms_inbound_with_body
from ..shared import json_sms_outbound_with_body as shared_json_sms_outbound_with_body
from ..shared import product_asr_enum as shared_product_asr_enum
from ..shared import product_conversations_enum as shared_product_conversations_enum
from ..shared import product_in_app_voice_enum as shared_product_in_app_voice_enum
from ..shared import product_messages_enum as shared_product_messages_enum
from ..shared import product_ni_enum as shared_product_ni_enum
from ..shared import product_sms_enum as shared_product_sms_enum
from ..shared import product_verify_enum as shared_product_verify_enum
from ..shared import product_voice_enum as shared_product_voice_enum
from ..shared import product_websocket_enum as shared_product_websocket_enum
from ..shared import request_status_enum as shared_request_status_enum
from dataclasses_json import Undefined, dataclass_json
from datetime import date
from enum import Enum
from marshmallow import fields
from sdk import utils
from typing import Any, Optional


@dataclasses.dataclass
class GetRecordsSecurity:
    
    password: str = dataclasses.field(metadata={'security': { 'scheme': True, 'type': 'http', 'sub_type': 'basic', 'field_name': 'password' }})  
    username: str = dataclasses.field(metadata={'security': { 'scheme': True, 'type': 'http', 'sub_type': 'basic', 'field_name': 'username' }})  
    
class GetRecordsDirectionEnum(str, Enum):
    r"""Direction of the communication, either `inbound` (received by our services), or `outbound` (originated from our services). Required for products `SMS` and `MESSAGES`. Optional for `VOICE-CALL`. Invalid for `IN-APP-VOICE`, `CONVERSATIONS`, `NUMBER-INSIGHT`, `VERIFY-API`."""
    INBOUND = 'inbound'
    OUTBOUND = 'outbound'

class GetRecordsIncludeMessageEnum(str, Enum):
    r"""Include the message contents in the records. Only applicable for use with products `SMS` and `MESSAGES`, where it is optional."""
    TRUE = 'true'
    FALSE = 'false'

class GetRecordsProductEnum(str, Enum):
    r"""The product to return records for"""
    SMS = 'SMS'
    VOICE_CALL = 'VOICE-CALL'
    VOICE_FAILED = 'VOICE-FAILED'
    IN_APP_VOICE = 'IN-APP-VOICE'
    WEBSOCKET_CALL = 'WEBSOCKET-CALL'
    VERIFY_API = 'VERIFY-API'
    NUMBER_INSIGHT = 'NUMBER-INSIGHT'
    MESSAGES = 'MESSAGES'
    ASR = 'ASR'
    CONVERSATIONS = 'CONVERSATIONS'
    REPORTS_USAGE = 'REPORTS-USAGE'

class GetRecordsShowConcatenatedEnum(str, Enum):
    r"""Indicates whether the SMS was split up into multiple parts (due to its length)."""
    TRUE = 'true'
    FALSE = 'false'

class GetRecordsStatusEnum(str, Enum):
    r"""The SMS status to search for. Optional where product is `SMS`."""
    DELIVERED = 'delivered'
    EXPIRED = 'expired'
    FAILED = 'failed'
    REJECTED = 'rejected'
    ACCEPTED = 'accepted'
    BUFFERED = 'buffered'
    UNKNOWN = 'unknown'
    DELETED = 'deleted'


@dataclasses.dataclass
class GetRecordsRequest:
    
    account_id: str = dataclasses.field(metadata={'query_param': { 'field_name': 'account_id', 'style': 'form', 'explode': True }})
    r"""The account for which the list of reports will be queried."""  
    product: GetRecordsProductEnum = dataclasses.field(metadata={'query_param': { 'field_name': 'product', 'style': 'form', 'explode': True }})
    r"""The product to return records for"""  
    date_end: Optional[date] = dataclasses.field(default=None, metadata={'query_param': { 'field_name': 'date_end', 'style': 'form', 'explode': True }})
    r"""**Must be no more than 24 hours later than `date_start`**
    
    ISO-8601 extended time zone offset or ISO-8601 UTC zone offset formatted date (format `yyyy-mm-ddThh:mm:ss[.sss]±hh:mm` or `yyyy-mm-ddThh:mm:ss[.sss]Z`) for when report should end.
    
    It is exclusive, i.e. the provided value is strictly greater than the value in the field `date_received` in the CDR.
    
    If you provide this, you must provide `date_start` and must not provide `id`.
    """  
    date_start: Optional[date] = dataclasses.field(default=None, metadata={'query_param': { 'field_name': 'date_start', 'style': 'form', 'explode': True }})
    r"""ISO-8601 extended time zone offset or ISO-8601 UTC zone offset formatted date (format `yyyy-mm-ddThh:mm:ss[.sss]±hh:mm` or `yyyy-mm-ddThh:mm:ss[.sss]Z`) for when reports should begin.
    
    It filters on the time the API call was received by Vonage and corresponds to the field `date_received` (`date_start` for Voice) in the report file. It is inclusive, i.e. the provided value is less than or equal to the value in the field `date_received` (`date_start` for Voice) in the CDR.
    
    If you provide this, you must provide `date_end` and must not provide `id`.
    """  
    direction: Optional[GetRecordsDirectionEnum] = dataclasses.field(default=None, metadata={'query_param': { 'field_name': 'direction', 'style': 'form', 'explode': True }})
    r"""Direction of the communication, either `inbound` (received by our services), or `outbound` (originated from our services). Required for products `SMS` and `MESSAGES`. Optional for `VOICE-CALL`. Invalid for `IN-APP-VOICE`, `CONVERSATIONS`, `NUMBER-INSIGHT`, `VERIFY-API`."""  
    id: Optional[str] = dataclasses.field(default=None, metadata={'query_param': { 'field_name': 'id', 'style': 'form', 'explode': True }})
    r"""The UUID of the message or call to be searched for. You can specify a comma-separated list of UUIDs. If UUIDs are not found they are listed in the response in the `ids_not_found` field.
    
    If you specify `id`, you must not specify `status`, `date_start` or `date_end`.
    """  
    include_message: Optional[GetRecordsIncludeMessageEnum] = dataclasses.field(default=None, metadata={'query_param': { 'field_name': 'include_message', 'style': 'form', 'explode': True }})
    r"""Include the message contents in the records. Only applicable for use with products `SMS` and `MESSAGES`, where it is optional."""  
    show_concatenated: Optional[GetRecordsShowConcatenatedEnum] = dataclasses.field(default=None, metadata={'query_param': { 'field_name': 'show_concatenated', 'style': 'form', 'explode': True }})
    r"""Indicates whether the SMS was split up into multiple parts (due to its length)."""  
    status: Optional[GetRecordsStatusEnum] = dataclasses.field(default=None, metadata={'query_param': { 'field_name': 'status', 'style': 'form', 'explode': True }})
    r"""The SMS status to search for. Optional where product is `SMS`."""  
    

@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class GetRecords422ApplicationJSON3:
    r"""Invalid filter"""
    
    detail: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('detail'), 'exclude': lambda f: f is None }})  
    instance: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('instance'), 'exclude': lambda f: f is None }})  
    title: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('title'), 'exclude': lambda f: f is None }})  
    type: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('type'), 'exclude': lambda f: f is None }})  
    

@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class GetRecords422ApplicationJSON2InvalidParameters:
    
    name: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('name'), 'exclude': lambda f: f is None }})  
    reason: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('reason'), 'exclude': lambda f: f is None }})  
    

@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class GetRecords422ApplicationJSON2:
    r"""Invalid Product"""
    
    instance: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('instance'), 'exclude': lambda f: f is None }})  
    invalid_parameters: Optional[list[GetRecords422ApplicationJSON2InvalidParameters]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('invalid_parameters'), 'exclude': lambda f: f is None }})  
    title: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('title'), 'exclude': lambda f: f is None }})  
    

@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class GetRecords422ApplicationJSON1InvalidParameters:
    
    name: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('name'), 'exclude': lambda f: f is None }})  
    reason: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('reason'), 'exclude': lambda f: f is None }})  
    

@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class GetRecords422ApplicationJSON1:
    r"""Missing parameter"""
    
    instance: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('instance'), 'exclude': lambda f: f is None }})  
    invalid_parameters: Optional[list[GetRecords422ApplicationJSON1InvalidParameters]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('invalid_parameters'), 'exclude': lambda f: f is None }})  
    title: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('title'), 'exclude': lambda f: f is None }})  
    

@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class GetRecords403ApplicationJSON:
    r"""Unprocessable entity"""
    
    detail: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('detail'), 'exclude': lambda f: f is None }})  
    instance: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('instance'), 'exclude': lambda f: f is None }})  
    title: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('title'), 'exclude': lambda f: f is None }})  
    

@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class GetRecords200ApplicationJSON11LinksSelf:
    
    href: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('href'), 'exclude': lambda f: f is None }})  
    

@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class GetRecords200ApplicationJSON11Links:
    
    self_: Optional[GetRecords200ApplicationJSON11LinksSelf] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('self'), 'exclude': lambda f: f is None }})  
    

@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class GetRecords200ApplicationJSON11:
    r"""Conversations"""
    
    links: Optional[GetRecords200ApplicationJSON11Links] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('_links'), 'exclude': lambda f: f is None }})  
    account_id: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('account_id'), 'exclude': lambda f: f is None }})
    r"""The account ID (API key) you wish to search for. This can differ from the API key in the authorization header because some accounts can request reports for other accounts, e.g. a primary account owner wants to create a report for one of its subaccounts."""  
    currency: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('currency'), 'exclude': lambda f: f is None }})
    r"""Currency of the price of the request."""  
    ids_not_found: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('ids_not_found'), 'exclude': lambda f: f is None }})
    r"""If you request multiple records using a comma-separated list of UUIDs, then the UUIDs of any records not found are listed in this field."""  
    items_count: Optional[int] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('items_count'), 'exclude': lambda f: f is None }})
    r"""The number of returned records"""  
    price: Optional[float] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('price'), 'exclude': lambda f: f is None }})
    r"""Price of the request."""  
    product: Optional[shared_product_conversations_enum.ProductConversationsEnum] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('product'), 'exclude': lambda f: f is None }})
    r"""Which product you wish to generate a report for."""  
    received_at: Optional[date] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('received_at'), 'encoder': utils.dateisoformat(True), 'decoder': utils.datefromisoformat, 'mm_field': fields.DateTime(format='iso'), 'exclude': lambda f: f is None }})
    r"""Time at which the report request was received by the service."""  
    records: Optional[list[shared_csv_conversations.CsvConversations]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('records'), 'exclude': lambda f: f is None }})
    r"""Records in JSON format"""  
    request_id: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('request_id'), 'exclude': lambda f: f is None }})
    r"""UUID of the request."""  
    request_status: Optional[shared_request_status_enum.RequestStatusEnum] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('request_status'), 'exclude': lambda f: f is None }})
    r"""Status of the request."""  
    

@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class GetRecords200ApplicationJSON10LinksSelf:
    
    href: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('href'), 'exclude': lambda f: f is None }})  
    

@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class GetRecords200ApplicationJSON10Links:
    
    self_: Optional[GetRecords200ApplicationJSON10LinksSelf] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('self'), 'exclude': lambda f: f is None }})  
    

@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class GetRecords200ApplicationJSON10:
    r"""ASR"""
    
    links: Optional[GetRecords200ApplicationJSON10Links] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('_links'), 'exclude': lambda f: f is None }})  
    account_id: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('account_id'), 'exclude': lambda f: f is None }})
    r"""The account ID (API key) you wish to search for. This can differ from the API key in the authorization header because some accounts can request reports for other accounts, e.g. a primary account owner wants to create a report for one of its subaccounts."""  
    currency: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('currency'), 'exclude': lambda f: f is None }})
    r"""Currency of the price of the request."""  
    ids_not_found: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('ids_not_found'), 'exclude': lambda f: f is None }})
    r"""If you request multiple records using a comma-separated list of UUIDs, then the UUIDs of any records not found are listed in this field."""  
    items_count: Optional[int] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('items_count'), 'exclude': lambda f: f is None }})
    r"""The number of returned records"""  
    price: Optional[float] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('price'), 'exclude': lambda f: f is None }})
    r"""Price of the request."""  
    product: Optional[shared_product_asr_enum.ProductAsrEnum] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('product'), 'exclude': lambda f: f is None }})
    r"""Which product you wish to generate a report for."""  
    received_at: Optional[date] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('received_at'), 'encoder': utils.dateisoformat(True), 'decoder': utils.datefromisoformat, 'mm_field': fields.DateTime(format='iso'), 'exclude': lambda f: f is None }})
    r"""Time at which the report request was received by the service."""  
    records: Optional[list[shared_csv_asr.CsvAsr]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('records'), 'exclude': lambda f: f is None }})
    r"""Records in JSON format"""  
    request_id: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('request_id'), 'exclude': lambda f: f is None }})
    r"""UUID of the request."""  
    request_status: Optional[shared_request_status_enum.RequestStatusEnum] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('request_status'), 'exclude': lambda f: f is None }})
    r"""Status of the request."""  
    

@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class GetRecords200ApplicationJSON9LinksSelf:
    
    href: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('href'), 'exclude': lambda f: f is None }})  
    

@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class GetRecords200ApplicationJSON9Links:
    
    self_: Optional[GetRecords200ApplicationJSON9LinksSelf] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('self'), 'exclude': lambda f: f is None }})  
    
class GetRecords200ApplicationJSON9DirectionEnum(str, Enum):
    r"""Direction of the communication, either `inbound` (received by our services), or `outbound` (originated from our services). Required for products `SMS` and `MESSAGES`. Optional for `VOICE-CALL`. Invalid for `IN-APP-VOICE`, `CONVERSATIONS`, `NUMBER-INSIGHT`, `VERIFY-API`."""
    INBOUND = 'inbound'
    OUTBOUND = 'outbound'


@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class GetRecords200ApplicationJSON9:
    r"""Messages (Inbound)"""
    
    links: Optional[GetRecords200ApplicationJSON9Links] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('_links'), 'exclude': lambda f: f is None }})  
    account_id: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('account_id'), 'exclude': lambda f: f is None }})
    r"""The account ID (API key) you wish to search for. This can differ from the API key in the authorization header because some accounts can request reports for other accounts, e.g. a primary account owner wants to create a report for one of its subaccounts."""  
    currency: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('currency'), 'exclude': lambda f: f is None }})
    r"""Currency of the price of the request."""  
    direction: Optional[GetRecords200ApplicationJSON9DirectionEnum] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('direction'), 'exclude': lambda f: f is None }})
    r"""Direction of the communication, either `inbound` (received by our services), or `outbound` (originated from our services). Required for products `SMS` and `MESSAGES`. Optional for `VOICE-CALL`. Invalid for `IN-APP-VOICE`, `CONVERSATIONS`, `NUMBER-INSIGHT`, `VERIFY-API`."""  
    ids_not_found: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('ids_not_found'), 'exclude': lambda f: f is None }})
    r"""If you request multiple records using a comma-separated list of UUIDs, then the UUIDs of any records not found are listed in this field."""  
    include_message: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('include_message'), 'exclude': lambda f: f is None }})
    r"""Include the text of messages in the report."""  
    items_count: Optional[int] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('items_count'), 'exclude': lambda f: f is None }})
    r"""The number of returned records"""  
    price: Optional[float] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('price'), 'exclude': lambda f: f is None }})
    r"""Price of the request."""  
    product: Optional[shared_product_messages_enum.ProductMessagesEnum] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('product'), 'exclude': lambda f: f is None }})
    r"""Which product you wish to generate a report for."""  
    received_at: Optional[date] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('received_at'), 'encoder': utils.dateisoformat(True), 'decoder': utils.datefromisoformat, 'mm_field': fields.DateTime(format='iso'), 'exclude': lambda f: f is None }})
    r"""Time at which the report request was received by the service."""  
    records: Optional[list[shared_csv_messages_inbound.CsvMessagesInbound]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('records'), 'exclude': lambda f: f is None }})
    r"""Records in JSON format"""  
    request_id: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('request_id'), 'exclude': lambda f: f is None }})
    r"""UUID of the request."""  
    request_status: Optional[shared_request_status_enum.RequestStatusEnum] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('request_status'), 'exclude': lambda f: f is None }})
    r"""Status of the request."""  
    show_concatenated: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('show_concatenated'), 'exclude': lambda f: f is None }})
    r"""Indicates whether the SMS was split up into multiple parts (due to its length)."""  
    

@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class GetRecords200ApplicationJSON8LinksSelf:
    
    href: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('href'), 'exclude': lambda f: f is None }})  
    

@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class GetRecords200ApplicationJSON8Links:
    
    self_: Optional[GetRecords200ApplicationJSON8LinksSelf] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('self'), 'exclude': lambda f: f is None }})  
    
class GetRecords200ApplicationJSON8DirectionEnum(str, Enum):
    r"""Direction of the communication, either `inbound` (received by our services), or `outbound` (originated from our services). Required for products `SMS` and `MESSAGES`. Optional for `VOICE-CALL`. Invalid for `IN-APP-VOICE`, `CONVERSATIONS`, `NUMBER-INSIGHT`, `VERIFY-API`."""
    INBOUND = 'inbound'
    OUTBOUND = 'outbound'


@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class GetRecords200ApplicationJSON8:
    r"""Messages (Outbound)"""
    
    links: Optional[GetRecords200ApplicationJSON8Links] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('_links'), 'exclude': lambda f: f is None }})  
    account_id: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('account_id'), 'exclude': lambda f: f is None }})
    r"""The account ID (API key) you wish to search for. This can differ from the API key in the authorization header because some accounts can request reports for other accounts, e.g. a primary account owner wants to create a report for one of its subaccounts."""  
    currency: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('currency'), 'exclude': lambda f: f is None }})
    r"""Currency of the price of the request."""  
    direction: Optional[GetRecords200ApplicationJSON8DirectionEnum] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('direction'), 'exclude': lambda f: f is None }})
    r"""Direction of the communication, either `inbound` (received by our services), or `outbound` (originated from our services). Required for products `SMS` and `MESSAGES`. Optional for `VOICE-CALL`. Invalid for `IN-APP-VOICE`, `CONVERSATIONS`, `NUMBER-INSIGHT`, `VERIFY-API`."""  
    ids_not_found: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('ids_not_found'), 'exclude': lambda f: f is None }})
    r"""If you request multiple records using a comma-separated list of UUIDs, then the UUIDs of any records not found are listed in this field."""  
    include_message: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('include_message'), 'exclude': lambda f: f is None }})
    r"""Include the text of messages in the report."""  
    items_count: Optional[int] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('items_count'), 'exclude': lambda f: f is None }})
    r"""The number of returned records"""  
    price: Optional[float] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('price'), 'exclude': lambda f: f is None }})
    r"""Price of the request."""  
    product: Optional[shared_product_messages_enum.ProductMessagesEnum] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('product'), 'exclude': lambda f: f is None }})
    r"""Which product you wish to generate a report for."""  
    received_at: Optional[date] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('received_at'), 'encoder': utils.dateisoformat(True), 'decoder': utils.datefromisoformat, 'mm_field': fields.DateTime(format='iso'), 'exclude': lambda f: f is None }})
    r"""Time at which the report request was received by the service."""  
    records: Optional[list[shared_csv_messages_outbound.CsvMessagesOutbound]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('records'), 'exclude': lambda f: f is None }})
    r"""Records in JSON format"""  
    request_id: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('request_id'), 'exclude': lambda f: f is None }})
    r"""UUID of the request."""  
    request_status: Optional[shared_request_status_enum.RequestStatusEnum] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('request_status'), 'exclude': lambda f: f is None }})
    r"""Status of the request."""  
    show_concatenated: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('show_concatenated'), 'exclude': lambda f: f is None }})
    r"""Indicates whether the SMS was split up into multiple parts (due to its length)."""  
    

@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class GetRecords200ApplicationJSON7LinksSelf:
    
    href: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('href'), 'exclude': lambda f: f is None }})  
    

@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class GetRecords200ApplicationJSON7Links:
    
    self_: Optional[GetRecords200ApplicationJSON7LinksSelf] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('self'), 'exclude': lambda f: f is None }})  
    

@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class GetRecords200ApplicationJSON7:
    r"""Number Insight"""
    
    links: Optional[GetRecords200ApplicationJSON7Links] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('_links'), 'exclude': lambda f: f is None }})  
    account_id: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('account_id'), 'exclude': lambda f: f is None }})
    r"""The account ID (API key) you wish to search for. This can differ from the API key in the authorization header because some accounts can request reports for other accounts, e.g. a primary account owner wants to create a report for one of its subaccounts."""  
    currency: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('currency'), 'exclude': lambda f: f is None }})
    r"""Currency of the price of the request."""  
    ids_not_found: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('ids_not_found'), 'exclude': lambda f: f is None }})
    r"""If you request multiple records using a comma-separated list of UUIDs, then the UUIDs of any records not found are listed in this field."""  
    items_count: Optional[int] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('items_count'), 'exclude': lambda f: f is None }})
    r"""The number of returned records"""  
    price: Optional[float] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('price'), 'exclude': lambda f: f is None }})
    r"""Price of the request."""  
    product: Optional[shared_product_ni_enum.ProductNiEnum] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('product'), 'exclude': lambda f: f is None }})
    r"""Which product you wish to generate a report for."""  
    received_at: Optional[date] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('received_at'), 'encoder': utils.dateisoformat(True), 'decoder': utils.datefromisoformat, 'mm_field': fields.DateTime(format='iso'), 'exclude': lambda f: f is None }})
    r"""Time at which the report request was received by the service."""  
    records: Optional[list[shared_csv_ni.CsvNi]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('records'), 'exclude': lambda f: f is None }})
    r"""Records in JSON format"""  
    request_id: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('request_id'), 'exclude': lambda f: f is None }})
    r"""UUID of the request."""  
    request_status: Optional[shared_request_status_enum.RequestStatusEnum] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('request_status'), 'exclude': lambda f: f is None }})
    r"""Status of the request."""  
    

@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class GetRecords200ApplicationJSON6LinksSelf:
    
    href: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('href'), 'exclude': lambda f: f is None }})  
    

@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class GetRecords200ApplicationJSON6Links:
    
    self_: Optional[GetRecords200ApplicationJSON6LinksSelf] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('self'), 'exclude': lambda f: f is None }})  
    

@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class GetRecords200ApplicationJSON6:
    r"""Verify"""
    
    links: Optional[GetRecords200ApplicationJSON6Links] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('_links'), 'exclude': lambda f: f is None }})  
    account_id: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('account_id'), 'exclude': lambda f: f is None }})
    r"""The account ID (API key) you wish to search for. This can differ from the API key in the authorization header because some accounts can request reports for other accounts, e.g. a primary account owner wants to create a report for one of its subaccounts."""  
    currency: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('currency'), 'exclude': lambda f: f is None }})
    r"""Currency of the price of the request."""  
    ids_not_found: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('ids_not_found'), 'exclude': lambda f: f is None }})
    r"""If you request multiple records using a comma-separated list of UUIDs, then the UUIDs of any records not found are listed in this field."""  
    items_count: Optional[int] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('items_count'), 'exclude': lambda f: f is None }})
    r"""The number of returned records"""  
    price: Optional[float] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('price'), 'exclude': lambda f: f is None }})
    r"""Price of the request."""  
    product: Optional[shared_product_verify_enum.ProductVerifyEnum] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('product'), 'exclude': lambda f: f is None }})
    r"""Which product you wish to generate a report for."""  
    received_at: Optional[date] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('received_at'), 'encoder': utils.dateisoformat(True), 'decoder': utils.datefromisoformat, 'mm_field': fields.DateTime(format='iso'), 'exclude': lambda f: f is None }})
    r"""Time at which the report request was received by the service."""  
    records: Optional[list[shared_csv_verify.CsvVerify]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('records'), 'exclude': lambda f: f is None }})
    r"""Records in JSON format"""  
    request_id: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('request_id'), 'exclude': lambda f: f is None }})
    r"""UUID of the request."""  
    request_status: Optional[shared_request_status_enum.RequestStatusEnum] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('request_status'), 'exclude': lambda f: f is None }})
    r"""Status of the request."""  
    

@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class GetRecords200ApplicationJSON5LinksSelf:
    
    href: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('href'), 'exclude': lambda f: f is None }})  
    

@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class GetRecords200ApplicationJSON5Links:
    
    self_: Optional[GetRecords200ApplicationJSON5LinksSelf] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('self'), 'exclude': lambda f: f is None }})  
    

@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class GetRecords200ApplicationJSON5:
    r"""WebSocket Call"""
    
    links: Optional[GetRecords200ApplicationJSON5Links] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('_links'), 'exclude': lambda f: f is None }})  
    account_id: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('account_id'), 'exclude': lambda f: f is None }})
    r"""The account ID (API key) you wish to search for. This can differ from the API key in the authorization header because some accounts can request reports for other accounts, e.g. a primary account owner wants to create a report for one of its subaccounts."""  
    currency: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('currency'), 'exclude': lambda f: f is None }})
    r"""Currency of the price of the request."""  
    ids_not_found: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('ids_not_found'), 'exclude': lambda f: f is None }})
    r"""If you request multiple records using a comma-separated list of UUIDs, then the UUIDs of any records not found are listed in this field."""  
    items_count: Optional[int] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('items_count'), 'exclude': lambda f: f is None }})
    r"""The number of returned records"""  
    price: Optional[float] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('price'), 'exclude': lambda f: f is None }})
    r"""Price of the request."""  
    product: Optional[shared_product_websocket_enum.ProductWebsocketEnum] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('product'), 'exclude': lambda f: f is None }})
    r"""Which product you wish to generate a report for."""  
    received_at: Optional[date] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('received_at'), 'encoder': utils.dateisoformat(True), 'decoder': utils.datefromisoformat, 'mm_field': fields.DateTime(format='iso'), 'exclude': lambda f: f is None }})
    r"""Time at which the report request was received by the service."""  
    records: Optional[list[shared_csv_websockets.CsvWebsockets]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('records'), 'exclude': lambda f: f is None }})
    r"""Records in JSON format"""  
    request_id: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('request_id'), 'exclude': lambda f: f is None }})
    r"""UUID of the request."""  
    request_status: Optional[shared_request_status_enum.RequestStatusEnum] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('request_status'), 'exclude': lambda f: f is None }})
    r"""Status of the request."""  
    

@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class GetRecords200ApplicationJSON4LinksSelf:
    
    href: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('href'), 'exclude': lambda f: f is None }})  
    

@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class GetRecords200ApplicationJSON4Links:
    
    self_: Optional[GetRecords200ApplicationJSON4LinksSelf] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('self'), 'exclude': lambda f: f is None }})  
    

@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class GetRecords200ApplicationJSON4:
    r"""In App Voice"""
    
    links: Optional[GetRecords200ApplicationJSON4Links] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('_links'), 'exclude': lambda f: f is None }})  
    account_id: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('account_id'), 'exclude': lambda f: f is None }})
    r"""The account ID (API key) you wish to search for. This can differ from the API key in the authorization header because some accounts can request reports for other accounts, e.g. a primary account owner wants to create a report for one of its subaccounts."""  
    currency: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('currency'), 'exclude': lambda f: f is None }})
    r"""Currency of the price of the request."""  
    ids_not_found: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('ids_not_found'), 'exclude': lambda f: f is None }})
    r"""If you request multiple records using a comma-separated list of UUIDs, then the UUIDs of any records not found are listed in this field."""  
    items_count: Optional[int] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('items_count'), 'exclude': lambda f: f is None }})
    r"""The number of returned records"""  
    price: Optional[float] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('price'), 'exclude': lambda f: f is None }})
    r"""Price of the request."""  
    product: Optional[shared_product_in_app_voice_enum.ProductInAppVoiceEnum] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('product'), 'exclude': lambda f: f is None }})
    r"""Which product you wish to generate a report for."""  
    received_at: Optional[date] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('received_at'), 'encoder': utils.dateisoformat(True), 'decoder': utils.datefromisoformat, 'mm_field': fields.DateTime(format='iso'), 'exclude': lambda f: f is None }})
    r"""Time at which the report request was received by the service."""  
    records: Optional[list[shared_csv_in_app_voice.CsvInAppVoice]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('records'), 'exclude': lambda f: f is None }})
    r"""Records in JSON format"""  
    request_id: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('request_id'), 'exclude': lambda f: f is None }})
    r"""UUID of the request."""  
    request_status: Optional[shared_request_status_enum.RequestStatusEnum] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('request_status'), 'exclude': lambda f: f is None }})
    r"""Status of the request."""  
    

@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class GetRecords200ApplicationJSON3LinksSelf:
    
    href: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('href'), 'exclude': lambda f: f is None }})  
    

@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class GetRecords200ApplicationJSON3Links:
    
    self_: Optional[GetRecords200ApplicationJSON3LinksSelf] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('self'), 'exclude': lambda f: f is None }})  
    

@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class GetRecords200ApplicationJSON3:
    r"""Voice Call"""
    
    links: Optional[GetRecords200ApplicationJSON3Links] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('_links'), 'exclude': lambda f: f is None }})  
    account_id: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('account_id'), 'exclude': lambda f: f is None }})
    r"""The account ID (API key) you wish to search for. This can differ from the API key in the authorization header because some accounts can request reports for other accounts, e.g. a primary account owner wants to create a report for one of its subaccounts."""  
    currency: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('currency'), 'exclude': lambda f: f is None }})
    r"""Currency of the price of the request."""  
    direction: Optional[shared_direction_enum.DirectionEnum] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('direction'), 'exclude': lambda f: f is None }})
    r"""Direction of the communication, either `inbound` (received by our services), or `outbound` (originated from our services). Required for products `SMS` and `MESSAGES`. Optional for `VOICE-CALL`. Invalid for `IN-APP-VOICE`, `CONVERSATIONS`, `NUMBER-INSIGHT`, `VERIFY-API`."""  
    ids_not_found: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('ids_not_found'), 'exclude': lambda f: f is None }})
    r"""If you request multiple records using a comma-separated list of UUIDs, then the UUIDs of any records not found are listed in this field."""  
    items_count: Optional[int] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('items_count'), 'exclude': lambda f: f is None }})
    r"""The number of returned records"""  
    price: Optional[float] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('price'), 'exclude': lambda f: f is None }})
    r"""Price of the request."""  
    product: Optional[shared_product_voice_enum.ProductVoiceEnum] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('product'), 'exclude': lambda f: f is None }})
    r"""Which product you wish to generate a report for."""  
    received_at: Optional[date] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('received_at'), 'encoder': utils.dateisoformat(True), 'decoder': utils.datefromisoformat, 'mm_field': fields.DateTime(format='iso'), 'exclude': lambda f: f is None }})
    r"""Time at which the report request was received by the service."""  
    records: Optional[list[shared_csv_voice.CsvVoice]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('records'), 'exclude': lambda f: f is None }})
    r"""Records in JSON format"""  
    request_id: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('request_id'), 'exclude': lambda f: f is None }})
    r"""UUID of the request."""  
    request_status: Optional[shared_request_status_enum.RequestStatusEnum] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('request_status'), 'exclude': lambda f: f is None }})
    r"""Status of the request."""  
    

@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class GetRecords200ApplicationJSON2LinksSelf:
    
    href: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('href'), 'exclude': lambda f: f is None }})  
    

@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class GetRecords200ApplicationJSON2Links:
    
    self_: Optional[GetRecords200ApplicationJSON2LinksSelf] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('self'), 'exclude': lambda f: f is None }})  
    
class GetRecords200ApplicationJSON2DirectionEnum(str, Enum):
    r"""Direction of the communication, either `inbound` (received by our services), or `outbound` (originated from our services). Required for products `SMS` and `MESSAGES`. Optional for `VOICE-CALL`. Invalid for `CONVERSATIONS`, `NUMBER-INSIGHT`, `VERIFY-API`."""
    INBOUND = 'inbound'
    OUTBOUND = 'outbound'


@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class GetRecords200ApplicationJSON2:
    r"""SMS (Inbound)"""
    
    links: Optional[GetRecords200ApplicationJSON2Links] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('_links'), 'exclude': lambda f: f is None }})  
    account_id: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('account_id'), 'exclude': lambda f: f is None }})
    r"""The account ID (API key) you wish to search for. This can differ from the API key in the authorization header because some accounts can request reports for other accounts, e.g. a primary account owner wants to create a report for one of its subaccounts."""  
    currency: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('currency'), 'exclude': lambda f: f is None }})
    r"""Currency of the price of the request."""  
    direction: Optional[GetRecords200ApplicationJSON2DirectionEnum] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('direction'), 'exclude': lambda f: f is None }})
    r"""Direction of the communication, either `inbound` (received by our services), or `outbound` (originated from our services). Required for products `SMS` and `MESSAGES`. Optional for `VOICE-CALL`. Invalid for `CONVERSATIONS`, `NUMBER-INSIGHT`, `VERIFY-API`."""  
    ids_not_found: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('ids_not_found'), 'exclude': lambda f: f is None }})
    r"""If you request multiple records using a comma-separated list of UUIDs, then the UUIDs of any records not found are listed in this field."""  
    include_message: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('include_message'), 'exclude': lambda f: f is None }})
    r"""Include the text of messages in the report."""  
    items_count: Optional[int] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('items_count'), 'exclude': lambda f: f is None }})
    r"""The number of returned records"""  
    price: Optional[float] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('price'), 'exclude': lambda f: f is None }})
    r"""Price of the request."""  
    product: Optional[shared_product_sms_enum.ProductSmsEnum] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('product'), 'exclude': lambda f: f is None }})
    r"""Which product you wish to generate a report for."""  
    received_at: Optional[date] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('received_at'), 'encoder': utils.dateisoformat(True), 'decoder': utils.datefromisoformat, 'mm_field': fields.DateTime(format='iso'), 'exclude': lambda f: f is None }})
    r"""Time at which the report request was received by the service."""  
    records: Optional[list[shared_json_sms_inbound_with_body.JSONSmsInboundWithBody]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('records'), 'exclude': lambda f: f is None }})
    r"""Records in JSON format"""  
    request_id: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('request_id'), 'exclude': lambda f: f is None }})
    r"""UUID of the request."""  
    request_status: Optional[shared_request_status_enum.RequestStatusEnum] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('request_status'), 'exclude': lambda f: f is None }})
    r"""Status of the request."""  
    show_concatenated: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('show_concatenated'), 'exclude': lambda f: f is None }})
    r"""Indicates whether the SMS was split up into multiple parts (due to its length)."""  
    

@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class GetRecords200ApplicationJSON1LinksSelf:
    
    href: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('href'), 'exclude': lambda f: f is None }})  
    

@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class GetRecords200ApplicationJSON1Links:
    
    self_: Optional[GetRecords200ApplicationJSON1LinksSelf] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('self'), 'exclude': lambda f: f is None }})  
    
class GetRecords200ApplicationJSON1DirectionEnum(str, Enum):
    r"""Direction of the communication, either `inbound` (received by our services), or `outbound` (originated from our services). Required for products `SMS` and `MESSAGES`. Optional for `VOICE-CALL`. Invalid for `IN-APP-VOICE`, `CONVERSATIONS`, `NUMBER-INSIGHT`, `VERIFY-API`."""
    INBOUND = 'inbound'
    OUTBOUND = 'outbound'


@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class GetRecords200ApplicationJSON1:
    r"""SMS (Outbound)"""
    
    links: Optional[GetRecords200ApplicationJSON1Links] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('_links'), 'exclude': lambda f: f is None }})  
    account_id: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('account_id'), 'exclude': lambda f: f is None }})
    r"""The account ID (API key) you wish to search for. This can differ from the API key in the authorization header because some accounts can request reports for other accounts, e.g. a primary account owner wants to create a report for one of its subaccounts."""  
    currency: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('currency'), 'exclude': lambda f: f is None }})
    r"""Currency of the price of the request."""  
    direction: Optional[GetRecords200ApplicationJSON1DirectionEnum] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('direction'), 'exclude': lambda f: f is None }})
    r"""Direction of the communication, either `inbound` (received by our services), or `outbound` (originated from our services). Required for products `SMS` and `MESSAGES`. Optional for `VOICE-CALL`. Invalid for `IN-APP-VOICE`, `CONVERSATIONS`, `NUMBER-INSIGHT`, `VERIFY-API`."""  
    ids_not_found: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('ids_not_found'), 'exclude': lambda f: f is None }})
    r"""If you request multiple records using a comma-separated list of UUIDs, then the UUIDs of any records not found are listed in this field."""  
    include_message: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('include_message'), 'exclude': lambda f: f is None }})
    r"""Include the text of messages in the report."""  
    items_count: Optional[int] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('items_count'), 'exclude': lambda f: f is None }})
    r"""The number of returned records"""  
    price: Optional[float] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('price'), 'exclude': lambda f: f is None }})
    r"""Price of the request."""  
    product: Optional[shared_product_sms_enum.ProductSmsEnum] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('product'), 'exclude': lambda f: f is None }})
    r"""Which product you wish to generate a report for."""  
    received_at: Optional[date] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('received_at'), 'encoder': utils.dateisoformat(True), 'decoder': utils.datefromisoformat, 'mm_field': fields.DateTime(format='iso'), 'exclude': lambda f: f is None }})
    r"""Time at which the report request was received by the service."""  
    records: Optional[list[shared_json_sms_outbound_with_body.JSONSmsOutboundWithBody]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('records'), 'exclude': lambda f: f is None }})
    r"""Records in JSON format"""  
    request_id: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('request_id'), 'exclude': lambda f: f is None }})
    r"""UUID of the request."""  
    request_status: Optional[shared_request_status_enum.RequestStatusEnum] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('request_status'), 'exclude': lambda f: f is None }})
    r"""Status of the request."""  
    show_concatenated: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('show_concatenated'), 'exclude': lambda f: f is None }})
    r"""Indicates whether the SMS was split up into multiple parts (due to its length)."""  
    

@dataclasses.dataclass
class GetRecordsResponse:
    
    content_type: str = dataclasses.field()  
    status_code: int = dataclasses.field()  
    get_records_200_application_json_one_of: Optional[Any] = dataclasses.field(default=None)
    r"""OK"""  
    get_records_403_application_json_object: Optional[GetRecords403ApplicationJSON] = dataclasses.field(default=None)
    r"""Unprocessable entity"""  
    get_records_422_application_json_one_of: Optional[Any] = dataclasses.field(default=None)
    r"""Unprocessable entity"""  
    raw_response: Optional[requests_http.Response] = dataclasses.field(default=None)  
    